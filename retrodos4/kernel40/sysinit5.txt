     1                                  ; ****************************************************************************
     2                                  ; SYSINIT.BIN (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 21/10/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 02/11/2022 (Modified IO.SYS)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 03/06/2018 (Retro DOS 3.0), 21/03/2019 (Retro DOS 4.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11 (2.15) 
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm sysinit5.s -l sysinit5.lst -o SYSINIT5.BIN -Z error.txt)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Modified from 'sysinit2.s' (SYSINIT2.BIN) file of Retro DOS v3.0 (6/7/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'SYSINIT1.ASM' and 'SYSINIT2.ASM' files of MSDOS 6.0
    15                                  ; source code by Microsoft, 1991 
    16                                  ; ----------------------------------------------------------------------------
    17                                  ; Derived from 'SYSINIT.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    18                                  ; by Microsoft, 12/10/1983
    19                                  ; ****************************************************************************
    20                                  ; main file: 'retrodos4.s'
    21                                  ; incbin 'SYSINIT3.BIN' ; (SYINITSEG)
    22                                  
    23                                  ; 21/10/2022
    24                                  ; ----------------------------------------------------------------------------
    25                                  ; This source code (version) is based on SYSINIT source code of disassembled
    26                                  ; MSDOS 5.0 IO.SYS file (SYSINIT.BIN) 
    27                                  ; Dissassembler: Hex-Rays Interactive Disassembler (IDA)
    28                                  ; ----------------------------------------------------------------------------
    29                                  ; Binary file splitter & joiner: FFSJ v3.3
    30                                  
    31                                  ;--------------------------------------------------------------
    32                                  ; SYSINIT.TXT (27/01/1983)
    33                                  ;--------------------------------------------------------------
    34                                  ;    SYSINIT is  a module linked behind the OEM bios.  It takes
    35                                  ;over  the  system  initialization  after  the  OEM  bios   has
    36                                  ;performed any  initialization  it  needs  to  do.   Control is
    37                                  ;transfered with a long jump to the external  variable  SYSINIT
    38                                  ;
    39                                  ;
    40                                  ;   The OEM  has  the  following  variables declared external:
    41                                  ;
    42                                  ;   CURRENT_DOS_LOCATION    WORD
    43                                  ;
    44                                  ;This word  contains  the  segment  number of the DOS before it
    45                                  ;is relocated.  The OEM bios must set this value.
    46                                  ;
    47                                  ;   FINAL_DOS_LOCATION      WORD
    48                                  ;
    49                                  ;This word contains the segment number of the DOS after SYSINIT
    50                                  ;moves it.  The OEM bios must set this value.
    51                                  ;
    52                                  ;   DEVICE_LIST             DWORD
    53                                  ;
    54                                  ;This  double  word  pointer  points  to  the  linked  list  of
    55                                  ;character and block device drivers.  The  OEM  must  set  this
    56                                  ;value.
    57                                  ;
    58                                  ;   MEMORY_SIZE             WORD
    59                                  ;
    60                                  ;This word  contains  the  number  of  RAM  paragraphs.  If the
    61                                  ;bios doesn't set  this  variable  SYSINIT  will  automatically
    62                                  ;calculate it.   NOTE:  systems with PARITY checked memory must
    63                                  ;size memory in the BIOS.  SYSINITs method is to  write  memory
    64                                  ;and read it back until it gets a mismatch.
    65                                  ;
    66                                  ;   DEFAULT_DRIVE           BYTE
    67                                  ;
    68                                  ;This is  the initial default drive when the system first comes
    69                                  ;up.  drive a=0, drive b=1,  etc.   If  the  bios  doesn't  set
    70                                  ;it then drive a is assumed.
    71                                  ;
    72                                  ;   BUFFERS                 BYTE
    73                                  ;
    74                                  ;This is  the  default  number of buffers for the system.  This
    75                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    76                                  ;It is DBed to 2 in SYSINIT it should be greater than 1.
    77                                  ;
    78                                  ;   FILES                   BYTE
    79                                  ;
    80                                  ;This is  the  default  number  of  files for the system.  This
    81                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    82                                  ;It is  DBed  to  8 in SYSINIT, values less than 5 are ignored.
    83                                  ;
    84                                  ;   SYSINIT                 FAR
    85                                  ;
    86                                  ;The entry  point  of  the  SYSINIT  module.  OEM BIOS jumps to
    87                                  ;this label at the end of its INIT code.
    88                                  ;
    89                                  ;   The OEM  has  the  following  variables declared public:
    90                                  ;
    91                                  ;   RE_INIT                 FAR
    92                                  ;
    93                                  ;This is an entry point which allows the BIOS to do some INIT
    94                                  ;work  after  the  DOS is initialized.  ALL REGISTERS MUST BE
    95                                  ;PRESERVED.  On entry DS points to the first available memory
    96                                  ;(after  the DOS).  DS:0 points to a 100H byte program header
    97                                  ;prefix which represents  the  "program"  currently  running.
    98                                  ;This  program  should  be  thought  of  as  the OEM BIOS and
    99                                  ;SYSINIT taken together.  This is not  a  normal  program  in
   100                                  ;that  no  memory  is  allocated to it, it is running in free
   101                                  ;memory.
   102                                  ;NOTES:
   103                                  ;     At the time this routine is called SYSINIT occupies the
   104                                  ;highest 10K of memory ("highest" is determined by the  value
   105                                  ;of the MEMORY_SIZE variable), DO NOT DO WRITES THERE.
   106                                  ;     Since this is called AFTER DOS is initialized, you can
   107                                  ;make system calls.  This also implies that the code for this
   108                                  ;routine    CANNOT   be   thrown   away   by   use   of   the
   109                                  ;FINAL_DOS_LOCATION since the DOS has already been moved.
   110                                  ;     If you don't want  anything done just set this to point
   111                                  ;at a FAR RET instruction.
   112                                  
   113                                  ; ----------------------------------------------------------------------
   114                                  ; TITLE   BIOS SYSTEM INITIALIZATION
   115                                  ; ----------------------------------------------------------------------
   116                                  
   117                                  ;include version.inc
   118                                  ; ----------------------------------------------------------------------
   119                                  
   120                                  ;FALSE   EQU     0
   121                                  ;TRUE    EQU     0FFFFh
   122                                  
   123                                  ;IBMVER	    EQU     TRUE
   124                                  ;IBMCOPYRIGHT EQU   FALSE
   125                                  ;STACKSW    EQU	    TRUE		;Include Switchable Hardware Stacks
   126                                  ;IBMJAPVER  EQU     FALSE		; If TRUE set KANJI true also
   127                                  ;MSVER      EQU     FALSE
   128                                  ;ALTVECT    EQU     FALSE		; Switch to build ALTVECT version
   129                                  ;KANJI      EQU     FALSE
   130                                  
   131                                  ;(MSDOS 6.0, versiona.inc, 1991)
   132                                  ; ----------------------------------------------------------------------
   133                                  ;MAJOR_VERSION  EQU	6
   134                                  ;;MINOR_VERSION	EQU	0	;6.00
   135                                  ;MINOR_VERSION  EQU	21	;6.21  ; 21/03/2019 - Retro DOS v4.0
   136                                  
   137                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0)
   138                                  ; ----------------------------------------------------------------------
   139                                  MAJOR_VERSION   EQU	5
   140                                  MINOR_VERSION   EQU	0
   141                                  
   142                                  expected_version equ	(MINOR_VERSION<<8)+MAJOR_VERSION
   143                                  
   144                                  ;DOSREVNM equ	00000000b       ; m037 - bits 0-2 = revision number of DOS
   145                                  				; currently 0.
   146                                  DOSREVNM equ	00000111b	; [[[ 7 for Retro DOS v4.0 ]]] (21/03/2019)	
   147                                  DOSINROM equ	00001000B       ; bit 3 of ver flags returned in BH
   148                                  DOSINHMA equ	00010000B       ; bit 4 of ver flags 
   149                                  
   150                                  ;      if1
   151                                  ;      %OUT  ... for DOS Version 5.00 ...
   152                                  ;      endif
   153                                  
   154                                         ;******************************
   155                                         ;Each assembler program should:
   156                                         ;  mov ah,030h                   ;DOS Get Version function
   157                                         ;  int 021h                      ;Version ret. in AX,minor version first
   158                                         ;  cmp ax,expected_version       ;ALL utilities should check for an
   159                                         ;  jne error_handler             ; EXACT version match.
   160                                         ;******************************
   161                                  
   162                                  ; ----------------------------------------------------------------------
   163                                  ; device definitions
   164                                  
   165                                  ;Attribute bit masks
   166                                  DEVTYP  EQU     8000h           ;Bit 15 - 1  if Char, 0 if block
   167                                  DEVIOCTL EQU    4000h           ;Bit 14 - CONTROL mode bit
   168                                  ISFATBYDEV EQU  2000h           ;Bit 13 - Device uses FAT ID bytes, comp media.
   169                                  ISCIN   EQU     0001h           ;Bit 0 - This device is the console input.
   170                                  ISCOUT  EQU     0002h           ;Bit 1 - This device is the console output.
   171                                  ISNULL  EQU     0004h           ;Bit 2 - This device is the null device.
   172                                  ISCLOCK EQU     0008h           ;Bit 3 - This device is the clock device.
   173                                  ISIBM   EQU     0010h           ;Bit 4 - This device is special
   174                                  
   175                                  ; The device table list has the form:
   176                                  struc	SYSDEV
   177 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
   178 00000004 ????                    .ATT:		resw 1		;Attributes of the device
   179 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
   180 00000008 ????                    .INT:		resw 1		;Interrupt entry point
   181 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
   182                                  .size:
   183                                  endstruc
   184                                  
   185                                  ;Static Reguest Header
   186                                  struc	SRHEAD
   187 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
   188 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
   189 00000002 ??                      .REQFUNC:	resb 1		;Type of request
   190 00000003 ????                    .REQSTAT:	resw 1		;Status Word
   191 00000005 ????????????????                	resb 8		;Reserved for queue links
   192                                  .size:
   193                                  endstruc
   194                                  
   195                                  ;Status word masks
   196                                  STERR   EQU     8000H           ;Bit 15 - Error
   197                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
   198                                  STDON   EQU     0100H           ;Bit 8 - Done
   199                                  STECODE EQU     00FFH           ;Error code
   200                                  WRECODE EQU     0
   201                                  
   202                                  ;Function codes
   203                                  DEVINIT EQU     0               ;Initialization
   204                                  DINITHL EQU     26              ;Size of init header
   205                                  DEVMDCH EQU     1               ;Media check
   206                                  DMEDHL  EQU     15              ;Size of media check header
   207                                  DEVBPB  EQU     2               ;Get BPB
   208                                  DEVRDIOCTL EQU  3               ;IOCTL read
   209                                  DBPBHL  EQU     22              ;Size of Get BPB header
   210                                  DEVRD   EQU     4               ;Read
   211                                  DRDWRHL EQU     22              ;Size of RD/WR header
   212                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
   213                                  DRDNDHL EQU     14              ;Size of non destructive read header
   214                                  DEVIST  EQU     6               ;Input status
   215                                  DSTATHL EQU     13              ;Size of status header
   216                                  DEVIFL  EQU     7               ;Input flush
   217                                  DFLSHL  EQU     15              ;Size of flush header
   218                                  DEVWRT  EQU     8               ;Write
   219                                  DEVWRTV EQU     9               ;Write with verify
   220                                  DEVOST  EQU     10              ;Output status
   221                                  DEVOFL  EQU     11              ;Output flush
   222                                  DEVWRIOCTL EQU  12              ;IOCTL write
   223                                  
   224                                  ; ----------------------------------------------------------------------
   225                                  struc	SYS_FCB
   226 00000000 ??                      .fcb_drive:	resb 1
   227 00000001 ????????????????        .fcb_name:	resb 8
   228 00000009 ??????                  .fcb_ext:	resb 3
   229 0000000C ????                    .fcb_EXTENT:	resw 1
   230 0000000E ????                    .fcb_RECSIZ:	resw 1	; Size of record (user settable)
   231 00000010 ????                    .fcb_FILSIZ:	resw 1	; Size of file in bytes; used with the following
   232                                                          ; word
   233 00000012 ????                    .fcb_DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
   234 00000014 ????                    .fcb_FDATE:	resw 1	; Date of last writing
   235 00000016 ????                    .fcb_FTIME:	resw 1	; Time of last writing
   236 00000018 ??                      .fcb_DEVID:	resb 1	; Device ID number, bits 0-5 if file.
   237                                                          ; bit 7=0 for file, bit 7=1 for I/O device
   238                                                          ; If file, bit 6=0 if dirty
   239                                                          ; If I/O device, bit 6=0 if EOF (input)
   240                                                          ;               Bit 5=1 if Raw mode
   241                                                          ;               Bit 0=1 if console input device
   242                                                          ;               Bit 1=1 if console output device
   243                                                          ;               Bit 2=1 if null device
   244                                                          ;               Bit 3=1 if clock device
   245 00000019 ????                    .fcb_FIRCLUS:	resw 1	; First cluster of file
   246 0000001B ????                    .fcb_CLUSPOS:	resw 1	; Position of last cluster accessed
   247 0000001D ????                    .fcb_LSTCLUS:	resw 1	; Last cluster accessed and directory
   248 0000001F ??                                   	resb 1	; pack 2 12 bit numbers into 24 bits...
   249 00000020 ??                      .fcb_NR:	resb 1	; Next record
   250 00000021 ????????                .fcb_RR:	resb 4	; Random record
   251                                  .size:
   252                                  endstruc
   253                                  
   254                                  ; ----------------------------------------------------------------------
   255                                  ; Field definition for I/O buffer information
   256                                  
   257                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, BUFFER.INC, 1991)
   258                                  
   259                                  struc buffinfo
   260 00000000 ????                    .buf_next:	resw 1	; Pointer to next buffer in list
   261 00000002 ????                    .buf_prev:	resw 1	; Pointer to previous buffer in list
   262 00000004 ??                      .buf_ID:	resb 1	; Drive of buffer (bit 7 = 0)
   263                                  			; SFT table index (bit 7 = 1)
   264                                  			; = FFh if buffer free
   265 00000005 ??                      .buf_flags:	resb 1	; Bit 7 = 1 if Remote file buffer
   266                                  			;	= 0 if Local device buffer
   267                                  			; Bit 6 = 1 if buffer dirty
   268                                  			; Bit 5 = Reserved
   269                                  			; Bit 4 = Search bit (bit 7 = 1)
   270                                  			; Bit 3 = 1 if buffer is DATA
   271                                  			; Bit 2 = 1 if buffer is DIR
   272                                  			; Bit 1 = 1 if buffer is FAT
   273                                  			; Bit 0 = Reserved
   274 00000006 ????????                .buf_sector:	resd 1	; Sector number of buffer (bit 7 = 0)
   275                                  ; The next two items are often refed as a word (bit 7 = 0)
   276 0000000A ??                      .buf_wrtcnt:	resb 1	; For FAT sectors, # times sector written out
   277 0000000B ????                    .buf_wrtcntinc:	resw 1	; "   "     "   , # sectors between each write
   278 0000000D ????????                .buf_DPB :	resd 1	; Pointer to drive parameters
   279 00000011 ????                    .buf_fill:	resw 1	; How full buffer is (bit 7 = 1)
   280 00000013 ??                      .buf_reserved:	resb 1	; make DWORD boundary for 386
   281                                  .size:
   282                                  endstruc
   283                                  
   284                                  %define buf_offset	dword [buf_sector]
   285                                  			;For bit 7 = 1, this is the byte
   286                                  			;offset of the start of the buffer in
   287                                  			;the file pointed to by buf_ID.  Thus
   288                                  			;the buffer starts at location
   289                                  			;buf_offset in the file and contains
   290                                  			;buf_fill bytes.
   291                                  
   292                                  bufinsiz	equ	buffinfo.size ; ; Size of structure in bytes
   293                                  
   294                                  
   295                                  buf_Free	equ	0FFh		; buf_id of free buffer
   296                                  
   297                                  ;Flag byte masks
   298                                  buf_isnet	EQU	10000000B
   299                                  buf_dirty	EQU	01000000B
   300                                  ;***
   301                                  buf_visit	EQU	00100000B
   302                                  ;***
   303                                  buf_snbuf	EQU	00010000B
   304                                  
   305                                  buf_isDATA	EQU	00001000B
   306                                  buf_isDIR	EQU	00000100B
   307                                  buf_isFAT	EQU	00000010B
   308                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   309                                  
   310                                  buf_NetID	EQU	bufinsiz
   311                                  
   312                                  ; ----------------------------------------------------------------------
   313                                  
   314                                  ; ----------------------------------------------------------------------
   315                                  ;**	DPB - Drive Parameter Block
   316                                  
   317                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DPB.INC, 1991)
   318                                  
   319                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   320                                  ;	possibly inaccurate deductions from code study... - jgl
   321                                  ;
   322                                  ;	The DPB is DOS's main structure for describing block devices.
   323                                  ;	It contains info about the "Drive" intermingled with info about
   324                                  ;	the FAT file system which is presumably on the drive.  I don't know
   325                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   326                                  ;
   327                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   328                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   329                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   330                                  
   331                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3, DPB.INC, 24/07/1987)
   332                                  
   333                                  ; 12/05/2019 - Retro DOS v4.0
   334                                  
   335                                  struc	DPB
   336 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   337 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   338 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   339 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   340 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   341 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   342 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   343 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   344 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   345 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   346                                  ;.FAT_SIZE:	resb 1  ; MSDOS 3.3
   347 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   348 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   349 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   350 00000017 ??                      .MEDIA:		resb 1		; Media byte
   351 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   352                                  				; check the first time this DPB is used
   353 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   354 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   355 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   356                                  .size:
   357                                  endstruc
   358                                  
   359                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   360                                  
   361                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   362                                  
   363                                  ; ----------------------------------------------------------------------
   364                                  ; 26/03/2018
   365                                  
   366                                  ; IOCTL SUB-FUNCTIONS
   367                                  IOCTL_GET_DEVICE_INFO	EQU	0
   368                                  IOCTL_SET_DEVICE_INFO	EQU	1
   369                                  IOCTL_READ_HANDLE	EQU	2
   370                                  IOCTL_WRITE_HANDLE	EQU	3
   371                                  IOCTL_READ_DRIVE	EQU	4
   372                                  IOCTL_WRITE_DRIVE	EQU	5
   373                                  IOCTL_GET_INPUT_STATUS	EQU	6
   374                                  IOCTL_GET_OUTPUT_STATUS EQU	7
   375                                  IOCTL_CHANGEABLE?	EQU	8
   376                                  IOCTL_SHARING_RETRY	EQU	11
   377                                  GENERIC_IOCTL_HANDLE	EQU	12
   378                                  GENERIC_IOCTL		EQU	13
   379                                  
   380                                  ; GENERIC IOCTL SUB-FUNCTIONS
   381                                  RAWIO			EQU	8
   382                                  
   383                                  ; RAWIO SUB-FUNCTIONS
   384                                  GET_DEVICE_PARAMETERS	EQU	60H
   385                                  SET_DEVICE_PARAMETERS	EQU	40H
   386                                  READ_TRACK		EQU	61H
   387                                  WRITE_TRACK		EQU	41H
   388                                  VERIFY_TRACK		EQU	62H
   389                                  FORMAT_TRACK		EQU	42H
   390                                  
   391                                  ; DEVICETYPE VALUES
   392                                  MAX_SECTORS_IN_TRACK	EQU	63
   393                                  DEV_5INCH		EQU	0
   394                                  DEV_5INCH96TPI		EQU	1
   395                                  DEV_3INCH720KB		EQU	2
   396                                  DEV_8INCHSS		EQU	3
   397                                  DEV_8INCHDS		EQU	4
   398                                  DEV_HARDDISK		EQU	5
   399                                  DEV_OTHER		EQU	7
   400                                  ;DEV_3INCH1440KB	EQU	7
   401                                  DEV_3INCH2880KB		EQU	9
   402                                  ; Retro DOS v2.0 - 26/03/2018
   403                                  ;;DEV_TAPE		EQU	6
   404                                  ;;DEV_ERIMO		EQU	8
   405                                  ;DEV_3INCH2880KB	EQU	9
   406                                  DEV_3INCH1440KB		EQU	10
   407                                  
   408                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
   409                                  					; CURRENTLY SUPPORT.
   410                                  MAX_DEV_TYPE		EQU	10
   411                                  
   412                                  struc A_SECTORTABLE
   413 00000000 ????                    .ST_SECTORNUMBER:	resw	1
   414 00000002 ????                    .ST_SECTORSIZE:		resw	1
   415                                  .size:
   416                                  endstruc
   417                                  
   418                                  ; 25/03/2019 - Retro DOS v4.0  (MSDOS 6.0, BPB.INC, IOCTL.INC)
   419                                  
   420                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   421                                  ;
   422                                  ;	The BPB contains information about the disk structure.  It dates
   423                                  ;	back to the earliest FAT systems and so FAT information is
   424                                  ;	intermingled with physical driver information.
   425                                  ;
   426                                  ;	A boot sector contains a BPB for its device; for other disks
   427                                  ;	the driver creates a BPB.  DOS keeps copies of some of this
   428                                  ;	information in the DPB.
   429                                  ;
   430                                  ;	The BDS structure contains a BPB within it.
   431                                  
   432                                  struc A_BPB
   433 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   434 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   435 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   436 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   437 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   438 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   439 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   440 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   441 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   442 0000000F ????                    .BPB_HEADS:		resw	1
   443 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   444 00000013 ????                    			resw	1
   445 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   446 00000017 ????                    			resw	1
   447 00000019 ????????????            			resb	6	; NOTE:  many times these
   448                                  ;					; 	 6 bytes are omitted
   449                                  ;					;	 when BPB manipulations
   450                                  ;					;	 are performed!
   451                                  .size:
   452                                  endstruc
   453                                  
   454                                  struc A_DEVICEPARAMETERS
   455 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
   456 00000001 ??                      .DP_DEVICETYPE:		resb	1
   457 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
   458 00000004 ????                    .DP_CYLINDERS:		resw	1
   459 00000006 ??                      .DP_MEDIATYPE:		resb	1
   460 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
   461 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
   462 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
   463                                  endstruc
   464                                  
   465                                  ; ----------------------------------------------------------------------
   466                                  ; structure, equates for devmark for mem command.
   467                                  
   468                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DEVMARK.INC, 1991)
   469                                  
   470                                  struc devmark
   471 00000000 ??                       .id:	    resb 1
   472 00000001 ????                     .seg:	    resw 1
   473 00000003 ????                     .size:	    resw 1
   474 00000005 ??????                   .dum:	    resb 3
   475 00000008 ????????????????         .filename: resb 8
   476                                  endstruc
   477                                  
   478                                  devmark_stk	equ	'S'
   479                                  devmark_device	equ	'D'
   480                                  devmark_ifs	equ	'I'
   481                                  devmark_buf	equ	'B'
   482                                  devmark_cds	equ	'L' ; lastdrive
   483                                  devmark_files	equ	'F'
   484                                  devmark_fcbs	equ	'X'
   485                                  devmark_inst	equ	'T' ; used for sysinit base for install= command.
   486                                  devmark_ems_stub equ	'E'
   487                                  
   488                                  setbrkdone	equ	00000001b
   489                                  for_devmark	equ	00000010b
   490                                  not_for_devmark equ	11111101b
   491                                  
   492                                  ; ----------------------------------------------------------------------
   493                                  ; Memory arena structure
   494                                  
   495                                  ; 24/03/2019 - Retro DOS v4.0 
   496                                  ; (MSDOS 6.0, ARENA.INC)
   497                                  
   498                                  ;** Arena Header
   499                                  
   500                                  struc ARENA
   501 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
   502 00000001 ????                    .OWNER:		resw 1		; owner of arena item
   503 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
   504 00000005 ??????                  .RESERVED	resb 3		; reserved
   505 00000008 ????????????????        .NAME:		resb 8		; owner file name
   506                                  endstruc
   507                                  
   508                                  ; 12/04/2019
   509                                  
   510                                  arena_owner_system	EQU 0	; free block indication
   511                                  
   512                                  arena_signature_normal	EQU 4Dh ; valid signature, not end of arena
   513                                  arena_signature_end	EQU 5Ah ; valid signature, last block in arena
   514                                  
   515                                  ; ----------------------------------------------------------------------
   516                                  ; Process data block (otherwise known as program header)
   517                                  
   518                                  ; 23/03/2019 - Retro DOS v4.0
   519                                  
   520                                  ; (MSDOS 6.0 - PDB.INC, 1991)
   521                                  
   522                                  FILPERPROC	EQU     20
   523                                  
   524                                  struc PDB	; Process_data_block
   525 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   526 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   527 00000004 ??                                      resb 1
   528 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   529 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   530 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   531 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   532 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   533 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   534 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   535 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   536 00000032 ????                    .JFN_LENGTH:	resw 1 		; number of handles allowed
   537 00000034 ????????                .JFN_POINTER:	resd 1 		; pointer to JFN table
   538 00000038 ????????                .NEXT_PDB:	resd 1		; pointer to nested PDB's
   539 0000003C ??                      .INTERCON:	resb 1 		; *** jh-3/28/90 ***
   540 0000003D ??                      .APPEND:	resb 1		; *** Not sure if still used ***
   541 0000003E ????                    .NOVELL_USED:	resb 2		; Novell shell (redir) uses these
   542 00000040 ????                    .VERSION:	resw 1		; DOS version reported to this app
   543 00000042 <res Eh>                .PAD1:		resb 14		; 	
   544 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   545 00000055 ??????????????          .PAD2:		resb 7 		; reserved so FCB 1 can be used as an extended FCB
   546 0000005C <res 10h>               .FCB1:		resb 16		; default FCB 1
   547 0000006C <res 10h>               .FCB2:		resb 16		; default FCB 2
   548 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   549 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   550                                  ;.size:
   551                                  endstruc
   552                                  
   553                                  ; ----------------------------------------------------------------------
   554                                  ; <system call definitions>
   555                                  
   556                                  ; 23/03/2019 - Retro DOS v4.0
   557                                  
   558                                  ; (MSDOS 6.0 - SYSCALL.INC, 1991)
   559                                  
   560                                  ABORT                           EQU 0   ;  0      0
   561                                  STD_CON_INPUT                   EQU 1   ;  1      1
   562                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
   563                                  STD_AUX_INPUT                   EQU 3   ;  3      3
   564                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
   565                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
   566                                  RAW_CON_IO                      EQU 6   ;  6      6
   567                                  RAW_CON_INPUT                   EQU 7   ;  7      7
   568                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
   569                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
   570                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
   571                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
   572                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
   573                                  DISK_RESET                      EQU 13  ; 13      D
   574                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
   575                                  FCB_OPEN                        EQU 15  ; 15      F
   576                                  FCB_CLOSE                       EQU 16  ; 16     10
   577                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
   578                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
   579                                  FCB_DELETE                      EQU 19  ; 19     13
   580                                  FCB_SEQ_READ                    EQU 20  ; 20     14
   581                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
   582                                  FCB_CREATE                      EQU 22  ; 22     16
   583                                  FCB_RENAME                      EQU 23  ; 23     17
   584                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
   585                                  SET_DMA                         EQU 26  ; 26     1A
   586                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
   587                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
   588                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
   589                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
   590                                  GET_FCB_POSITION                EQU 36  ; 36     24
   591                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
   592                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
   593                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
   594                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
   595                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
   596                                  GET_DATE                        EQU 42  ; 42     2A
   597                                  SET_DATE                        EQU 43  ; 43     2B
   598                                  GET_TIME                        EQU 44  ; 44     2C
   599                                  SET_TIME                        EQU 45  ; 45     2D
   600                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
   601                                  ; Extended functionality group
   602                                  GET_DMA                         EQU 47  ; 47     2F
   603                                  GET_VERSION                     EQU 48  ; 48     30
   604                                  KEEP_PROCESS                    EQU 49  ; 49     31
   605                                  GET_DPB                         EQU 50  ; 50     32
   606                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
   607                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
   608                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
   609                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
   610                                  CHAR_OPER                       EQU 55  ; 55     37
   611                                  INTERNATIONAL                   EQU 56  ; 56     38
   612                                  ;   Directory Group
   613                                  MKDIR                           EQU 57  ; 57     39
   614                                  RMDIR                           EQU 58  ; 58     3A
   615                                  CHDIR                           EQU 59  ; 59     3B
   616                                  ;   File Group
   617                                  CREAT                           EQU 60  ; 60     3C
   618                                  OPEN                            EQU 61  ; 61     3D
   619                                  CLOSE                           EQU 62  ; 62     3E
   620                                  READ                            EQU 63  ; 63     3F
   621                                  WRITE                           EQU 64  ; 64     40
   622                                  UNLINK                          EQU 65  ; 65     41
   623                                  LSEEK                           EQU 66  ; 66     42
   624                                  CHMOD                           EQU 67  ; 67     43
   625                                  IOCTL                           EQU 68  ; 68     44
   626                                  XDUP                            EQU 69  ; 69     45
   627                                  XDUP2                           EQU 70  ; 70     46
   628                                  CURRENT_DIR                     EQU 71  ; 71     47
   629                                  ;    Memory Group
   630                                  ALLOC                           EQU 72  ; 72     48
   631                                  DEALLOC                         EQU 73  ; 73     49
   632                                  SETBLOCK                        EQU 74  ; 74     4A
   633                                  ;    Process Group
   634                                  EXEC                            EQU 75  ; 75     4B
   635                                  EXIT                            EQU 76  ; 76     4C
   636                                  WAITPROCESS			EQU 77  ; 77     4D
   637                                  FIND_FIRST                      EQU 78  ; 78     4E
   638                                  ;   Special Group
   639                                  FIND_NEXT                       EQU 79  ; 79     4F
   640                                  ; SPECIAL SYSTEM GROUP
   641                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
   642                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
   643                                  GET_IN_VARS                     EQU 82  ; 82     52
   644                                  SETDPB                          EQU 83  ; 83     53
   645                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
   646                                  DUP_PDB                         EQU 85  ; 85     55
   647                                  RENAME                          EQU 86  ; 86     56
   648                                  FILE_TIMES                      EQU 87  ; 87     57
   649                                  ;
   650                                  ALLOCOPER			EQU 88	; 88     58	
   651                                  ; Network extention system calls
   652                                  GetExtendedError		EQU 89	; 89	 59
   653                                  CreateTempFile			EQU 90	; 90	 5A
   654                                  CreateNewFile			EQU 91	; 91	 5B
   655                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   656                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   657                                  					;	    CloseByName, CloseUser,
   658                                  					;	    CloseUserProcess,
   659                                  					;	    GetOpenFileList
   660                                  UserOper			EQU 94	; 94	 5E Get and Set
   661                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   662                                  xNameTrans			EQU 96	; 96	 60
   663                                  PathParse			EQU 97	; 97	 61
   664                                  GetCurrentPSP			EQU 98	; 98	 62
   665                                  Hongeul 			EQU 99	; 99	 63
   666                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   667                                  Set_Printer_Flag		EQU 100 ; 100	 64
   668                                  GetExtCntry			EQU 101 ; 101	 65
   669                                  GetSetCdPg			EQU 102 ; 102	 66
   670                                  ExtHandle			EQU 103 ; 103	 67
   671                                  Commit				EQU 104 ; 104	 68
   672                                  GetSetMediaID			EQU 105 ; 105	 69
   673                                  IFS_IOCTL			EQU 107 ; 107	 6B
   674                                  ExtOpen 			EQU 108 ; 108	 6C
   675                                  ;
   676                                  ;ifdef ROMEXEC
   677                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   678                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   679                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F
   680                                  ;endif
   681                                  ;
   682                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   683                                  OEM_C1				EQU 249 ; 249	 F9
   684                                  OEM_C2				EQU 250 ; 250	 FA
   685                                  OEM_C3				EQU 251 ; 251	 FB
   686                                  OEM_C4				EQU 252 ; 252	 FC
   687                                  OEM_C5				EQU 253 ; 253	 FD
   688                                  OEM_C6				EQU 254 ; 254	 FE
   689                                  OEM_C7				EQU 255 ; 255	 FF
   690                                  
   691                                  ; ----------------------------------------------------------------------
   692                                  ; SYSCONF.ASM (MSDOS 3.3 - 24/07/1987) 	
   693                                  ; ----------------------------------------------------------------------
   694                                  
   695                                  ;;	IF	STACKSW
   696                                  
   697                                  ;;
   698                                  ;; Internal Stack Parameters
   699                                  ;EntrySize		equ	8
   700                                  ;
   701                                  ;MinCount		equ	8
   702                                  ;DefaultCount		equ	9
   703                                  ;MaxCount		equ	64
   704                                  ;
   705                                  ;MinSize 		equ	32
   706                                  ;DefaultSize		equ	128
   707                                  ;MaxSize 		equ	512
   708                                  
   709                                  ;;	ENDIF
   710                                  
   711                                  ; ----------------------------------------------------------------------
   712                                  ; BIOSTRUC.INC (MSDOS 3.3 - 24/07/1987) 	
   713                                  ; ----------------------------------------------------------------------
   714                                  					  ;;Rev 3.30 Modification
   715                                  ; ROM BIOS CALL PACKET STRUCTURES					  
   716                                  									  
   717                                  ;*******************************					  
   718                                  ;System Service call ( Int 15h )					  
   719                                  ;*******************************					  
   720                                  ;Function AH = 0C0h, Return system configuration			  
   721                                  ;For PC and PCJR on return:						  
   722                                  ;	(AH)	= 80h							  
   723                                  ;	(CY)	= 1							  
   724                                  ;For PCXT, PC PORTABLE and PCAT on return:				  
   725                                  ;	(AH)	= 86h							  
   726                                  ;	(CY)	= 1							  
   727                                  ;For all others:							  
   728                                  ;	(AH)	= 0							  
   729                                  ;	(CY)	= 0							  
   730                                  ;	(ES:BX) = pointer to system descriptor vector in ROS		  
   731                                  ; System descriptor :							  
   732                                  ;	DW	xxxx		length of descriptor in bytes,		  
   733                                  ;				minimum length = 8			  
   734                                  ;	DB	xx		model byte				  
   735                                  ;				0FFh	= PC				  
   736                                  ;				0FEh	= PC/XT, Portable		  
   737                                  ;				0FDh	= PC/JR 			  
   738                                  ;				0FCh	= PC/AT				  
   739                                  ;				0F9h	= Convertable			  
   740                                  ;				0F8h	= Model 80			  
   741                                  ;				0E0 thru 0EFh = reserved		  
   742                                  ;									  
   743                                  ;	DB	xx		secondary model byte			  
   744                                  ;				000h	= PC1				  
   745                                  ;				000h	= PC/XT, Portable		  
   746                                  ;				000h	= PC/JR 			  
   747                                  ;				000h	= PC/AT 			  
   748                                  ;				001h	= PC/AT Model 339		  
   749                                  ;				003h	= PC/RT				  
   750                                  ;				000h	= Convertable			  
   751                                  ;									  
   752                                  ;	DB	xx		bios revision level			  
   753                                  ;				00 for first release, subsequent release  
   754                                  ;				of code with same model byte and	  
   755                                  ;				secondary model byte require revison level
   756                                  ;				to increase by one.			  
   757                                  ;									  
   758                                  ;	DB	xx		feature information byte 1		  
   759                                  ;				X0000000 = 1, bios use DMA channel 3	  
   760                                  ;					 = 0, DMA channel 3 not used	  
   761                                  ;									  
   762                                  ;				0X000000 = 1, 2nd Interrupt chip present  
   763                                  ;					 = 0, 2nd Interrupt chip not present
   764                                  ;									  
   765                                  ;				00X00000 = 1, Real Time Clock present	  
   766                                  ;					 = 0, Real Time Clock not present 
   767                                  ;									  
   768                                  ;				000X0000 = 1, Keyboard escape sequence(INT 15h)
   769                                  ;						called in keyboard interrupt
   770                                  ;						(Int 09h).		  
   771                                  ;					 = 0, Keyboard escape sequence not
   772                                  ;						called. 		  
   773                                  ;				0000XXXX reserved			  
   774                                  ;									  
   775                                  ;	DB	xx		feature information byte 2 - reserved	  
   776                                  ;									  
   777                                  ;	DB	xx		feature information byte 2 - reserved	  
   778                                  ;									  
   779                                  ;	DB	xx		feature information byte 2 - reserved	  
   780                                  ;									  
   781                                  ;	DB	xx		feature information byte 2 - reserved	  
   782                                  ;									  
   783                                  
   784                                  ; 22/03/2019									  
   785                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   786 00000000 ????                    .bios_sd_leng:		resw 1				  
   787 00000002 ??                      .bios_sd_modelbyte:	resb 1					  
   788                                  .bios_sd_scnd_modelbyte: 
   789 00000003 ??                      			resb 1					  
   790 00000004 ??                      			resb 1					  
   791 00000005 ??                      .bios_sd_featurebyte1:	resb 1					  
   792 00000006 ????????                			resb 4					  
   793                                  endstruc					  
   794                                  									  
   795                                  ;FeatureByte1	bit map equates 					  
   796                                  DMAchannel3		equ 10000000b					  
   797                                  ScndIntController	equ 01000000b					  
   798                                  RealTimeClock		equ 00100000b					  
   799                                  KeyEscapeSeq		equ 00010000b					  
   800                                  					;;End of Modification
   801                                  
   802                                  ; ----------------------------------------------------------------------
   803                                  ; SYSVAR.INC (MSDOS 6.0 - 1991) 	
   804                                  ; ----------------------------------------------------------------------
   805                                  ; 22/03/2019 - Retro DOS v4.0
   806                                  
   807                                  ;	SCCSID = @(#)sysvar.asm 1.1 85/04/10
   808                                  
   809                                  struc SysInitVars
   810                                  ; MSDOS 3.3
   811 00000000 ????????                .SYSI_DPB:    resd 1			; DPB chain
   812 00000004 ????????                .SYSI_SFT:    resd 1			; SFT chain
   813 00000008 ????????                .SYSI_CLOCK:  resd 1			; CLOCK device
   814 0000000C ????????                .SYSI_CON:    resd 1			; CON device
   815 00000010 ????                    .SYSI_MAXSEC: resw 1			; maximum sector size
   816 00000012 ????????                .SYSI_BUF:    resd 1			; buffer chain
   817 00000016 ????????                .SYSI_CDS:    resd 1			; CDS list
   818 0000001A ????????                .SYSI_FCB:    resd 1			; FCB chain
   819 0000001E ????                    .SYSI_KEEP:   resw 1			; keep count
   820 00000020 ??                      .SYSI_NUMIO:  resb 1			; number of block devices
   821 00000021 ??                      .SYSI_NCDS:   resb 1			; number of CDS's
   822 00000022 ????????                .SYSI_DEV:    resd 1			; device list
   823                                  ; MSDOS 6.0
   824 00000026 ????                    .SYSI_ATTR:	    resw 1		; null device attribute word
   825 00000028 ????                    .SYSI_STRAT:	    resw 1		; null device strategy entry point
   826 0000002A ????                    .SYSI_INTER:	    resw 1		; null device interrupt entry point
   827 0000002C ????????????????        .SYSI_NAME:	    resb 8		; null device name
   828                                  .SYSI_SPLICE:	    resb 0		; TRUE -> splicees being done
   829 00000034 ????                    .SYSI_IBMDOS_SIZE:  resw 1		; DOS size in paragraphs
   830 00000036 ????????                .SYSI_IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
   831 0000003A ????????                .SYSI_IFS:	    resd 1	 	; IFS header chain
   832 0000003E ????????                .SYSI_BUFFERS:	    resw 2		; BUFFERS= values (m,n)
   833 00000042 ??                      .SYSI_BOOT_DRIVE:   resb 1		; boot drive A=1 B=2,..
   834 00000043 ??                      .SYSI_DWMOVE:	    resb 1		; 1 if 386 machine
   835 00000044 ????                    .SYSI_EXT_MEM:	    resw 1		; Extended memory size in KB.
   836                                  .size:
   837                                  endstruc
   838                                  
   839                                  ;This is added for more information exchage between DOS, BIOS.
   840                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
   841                                  
   842                                  ; 22/03/2019
   843                                  struc SysInitVars_Ext
   844 00000000 ????????                .SYSI_InitVars:	   resd 1	; Points to the above structure.
   845 00000004 ????????                .SYSI_Country_Tab: resd 1	; DOS_Country_cdpg_info
   846                                  endstruc
   847                                  
   848                                  ; 09/06/2018
   849                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
   850                                  SYSI_DPB    equ	0
   851                                  SYSI_SFT    equ 4
   852                                  SYSI_CLOCK  equ 8
   853                                  SYSI_CON    equ 12
   854                                  SYSI_MAXSEC equ 16
   855                                  SYSI_BUF    equ 18 		
   856                                  SYSI_CDS    equ 22
   857                                  SYSI_FCB    equ 26
   858                                  SYSI_KEEP   equ 30
   859                                  SYSI_NUMIO  equ	32
   860                                  SYSI_NCDS   equ	33
   861                                  SYSI_DEV    equ 34
   862                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0)
   863                                  SYSI_ATTR	  equ 38
   864                                  SYSI_STRAT	  equ 40
   865                                  SYSI_INTER	  equ 42
   866                                  SYSI_NAME	  equ 44
   867                                  SYSI_SPLICE	  equ 52
   868                                  SYSI_IBMDOS_SIZE  equ 53
   869                                  SYSI_IFS_DOSCALL@ equ 55
   870                                  SYSI_IFS	  equ 59
   871                                  SYSI_BUFFERS	  equ 63
   872                                  SYSI_BOOT_DRIVE   equ 67
   873                                  SYSI_DWMOVE	  equ 68
   874                                  SYSI_EXT_MEM	  equ 69
   875                                  
   876                                  ;The SYSI_BUF of SysInitVars points to the following structure
   877                                  
   878                                  EMS_MAP_BUFF_SIZE EQU 12	; EMS map buffer size
   879                                  
   880                                  struc BUFFINF 	; BUFFINFO
   881 00000000 ????????                .Buff_Queue:	   resd	1	; Head of list of buffers
   882 00000004 ????                    .Dirty_Buff_Count: resw 1	; number of dirty buffers in list
   883 00000006 ????????                .Cache_ptr:	   resd 1	; pointer to secondary cache
   884 0000000A ????                    .Cache_count:      resw 1	; number of secondary cache entries
   885                                  
   886 0000000C ??                      .Buff_In_HMA:	   resb 1	; flag to indicate that buffers
   887                                  				; are in HMA
   888 0000000D ????????                .Lo_Mem_Buff:	   resd 1	; Ptr to scratch buff in Low Mem
   889                                  				;  used to read/write on disks
   890 00000011 ????????                .UU_EMS_FIRST_PAGE:	resw 2
   891 00000015 ????                    .UU_EMS_NPA640:		resw 1
   892 00000017 ??                      .UU_EMS_mode:		resb 1	 ; no EMS = -1
   893 00000018 ????                    .UU_EMS_handle:		resw 1	 ; EMS handle for buffers
   894 0000001A ????                    .UU_EMS_PageFrame_Number: resw 1 ; EMS page frame number
   895 0000001C ????                    .UU_EMS_Seg_Cnt:	resw 1	 ; EMS segment count
   896 0000001E ????                    .UU_EMS_Page_Frame:	resw 1	 ; EMS page frame segment address
   897 00000020 ????                    .UU_EMS_reserved:	resw 1	 ; EMS segment count
   898 00000022 ??                      .UU_EMS_Map_Buff:	resb 1	 ; map buffer
   899                                  .size:
   900                                  endstruc
   901                                  
   902                                  ; ----------------------------------------------------------------------
   903                                  ; CURDIR.INC (MSDOS 6.0 - 1991) 	
   904                                  ; ----------------------------------------------------------------------
   905                                  ; 22/03/2019 - Retro DOS v4.0
   906                                  
   907                                  ;**	CDS - Current Directory Structure
   908                                  ;
   909                                  ; CDS items are used bu the internal routines to store cluster numbers and
   910                                  ; network identifiers for each logical name.  The ID field is used dually,
   911                                  ; both as net ID and for a cluster number for local devices. In the case
   912                                  ; of local devices, the cluster number will be -1 if there is a potential
   913                                  ; of the disk being changed or if the path must be recracked.
   914                                  ;
   915                                  ;	Some pathnames have special preambles, such as
   916                                  ;
   917                                  ;		\\machine\sharename\...
   918                                  ;	For these pathnames we can't allow ".." processing to back us
   919                                  ;	up into the special front part of the name.  The CURDIR_END field
   920                                  ;	holds the address of the seperator character which marks
   921                                  ;	the split between the special preamble and the regular
   922                                  ;	path list; ".." processing isn't allowed to back us up past
   923                                  ;	(i.e., before) CURDIR_END
   924                                  ;	For the root, it points at the leading /. For net
   925                                  ;	assignments it points at the end (nul) of the initial assignment:
   926                                  ;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
   927                                  ;	  ^		 ^		     ^
   928                                  
   929                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   930                                  TEMPLEN 	EQU	DIRSTRLEN*2
   931                                  
   932                                  struc 		curdir_list
   933                                  ; MSDOS 3.3
   934 00000000 <res 43h>               .cdir_text	resb	DIRSTRLEN	; text of assignment and curdir
   935 00000043 ????                    .cdir_flags	resw	1		; various flags
   936 00000045 ????????                .cdir_devptr	resd	1		; local pointer to DPB or net device
   937 00000049 ????????                .cdir_ID	resw	2		; cluster of current dir (net ID)
   938 0000004D ????                    .cdir_usr_word	resw	1
   939 0000004F ????                    .cdir_end	resw	1		; end of assignment
   940                                  ; MSDOS 6.0
   941 00000051 ??                      .cdir_type:	resb	1		; IFS drive (2=ifs, 4=netuse)
   942 00000052 ????????                .cdir_ifd_hdr:	resd	1		; Ptr to File System Header
   943 00000056 ????                    .cdir_fsda:	resb	2		; File System Dependent Data Area
   944                                  .size:
   945                                  endstruc
   946                                  
   947                                  curdirlen	EQU	curdir_list.size	; Needed for screwed up
   948                                  						; ASM87 which doesn't allow
   949                                  						; Size directive as a macro
   950                                  						; argument
   951                                  %define curdir_netID	dword [curdir_list.cdir_ID]
   952                                  
   953                                  ;**	Flag values for CURDIR_FLAGS
   954                                  
   955                                  ;Flag word masks
   956                                  curdir_isnet	EQU	1000000000000000B
   957                                  curdir_isifs	EQU	1000000000000000B
   958                                  curdir_inuse	EQU	0100000000000000B
   959                                  curdir_splice	EQU	0010000000000000B
   960                                  curdir_local	EQU	0001000000000000B
   961                                  
   962                                  ; ----------------------------------------------------------------------
   963                                  ; SF.INC (MSDOS 6.0 - 1991) 	
   964                                  ; ----------------------------------------------------------------------
   965                                  ; 25/03/2019 - Retro DOS v4.0
   966                                  
   967                                  ; system file table
   968                                  
   969                                  ;**	System File Table SuperStructure
   970                                  ;
   971                                  ;	The system file table entries are allocated in contiguous groups.
   972                                  ;	There may be more than one such groups; the SF "superstructure"
   973                                  ;	tracks the groups.
   974                                  
   975                                  struc	SF
   976 00000000 ????????                .SFLink:	resd	1
   977 00000004 ????                    .SFCount:	resw	1		; number of entries
   978 00000006 ????                    .SFTable:	resw	1		; beginning of array of the following
   979                                  .size:
   980                                  endstruc
   981                                  
   982                                  ;**	System file table entry
   983                                  ;
   984                                  ;	These are the structures which are at SFTABLE in the SF structure.
   985                                  
   986                                  struc	SF_ENTRY
   987 00000000 ????                    .sf_ref_count:	resw	1		; number of processes sharing entry
   988                                  					;   if FCB then ref count
   989 00000002 ????                    .sf_mode: 	resw	1		; mode of access or high bit on if FCB
   990 00000004 ??                      .sf_attr: 	resb	1		; attribute of file
   991 00000005 ????                    .sf_flags:	resw	1		;Bits 8-15
   992                                  					; Bit 15 = 1 if remote file
   993                                  					;	 = 0 if local file or device
   994                                  					; Bit 14 = 1 if date/time is not to be
   995                                  					;   set from clock at CLOSE.  Set by
   996                                  					;   FILETIMES and FCB_CLOSE.  Reset by
   997                                  					;   other reseters of the dirty bit
   998                                  					;   (WRITE)
   999                                  					; Bit 13 = Pipe bit (reserved)
  1000                                  					;
  1001                                  					; Bits 0-7 (old FCB_devid bits)
  1002                                  					; If remote file or local file, bit
  1003                                  					; 6=0 if dirty Device ID number, bits
  1004                                  					; 0-5 if local file.
  1005                                  					; bit 7=0 for local file, bit 7
  1006                                  					;      =1 for local I/O device
  1007                                  					; If local I/O device, bit 6=0 if EOF (input)
  1008                                  					;		Bit 5=1 if Raw mode
  1009                                  					;		Bit 0=1 if console input device
  1010                                  					;		Bit 1=1 if console output device
  1011                                  					;		Bit 2=1 if null device
  1012                                  					;		Bit 3=1 if clock device
  1013 00000007 ????????                .sf_devptr:	resd	1		; Points to DPB if local file, points
  1014                                  					; to device header if local device,
  1015                                  					; points to net device header if
  1016                                  					; remote
  1017 0000000B ????                    .sf_firclus:	resw	1		; First cluster of file (bit 15 = 0)
  1018                                  ;.sf_lstclus:	resw	1 ; *	
  1019 0000000D ????                    .sf_time: 	resw	1		; Time associated with file
  1020 0000000F ????                    .sf_date: 	resw	1		; Date associated with file
  1021 00000011 ????????                .sf_size: 	resd	1		; Size associated with file
  1022 00000015 ????????                .sf_position:	resd	1		; Read/Write pointer or LRU count for FCBs
  1023                                  ;
  1024                                  ; Starting here, the next 7 bytes may be used by the file system to store an
  1025                                  ; ID
  1026                                  ;
  1027 00000019 ????                    .sf_cluspos:	resw	1		; Position of last cluster accessed
  1028 0000001B ????                    .sf_dirsec:	resw	1		; Sector number of directory sector for this file
  1029 0000001D ??                      .sf_dirpos:	resb	1		; Offset of this entry in the above
  1030                                  ;
  1031                                  ; End of 7 bytes of file-system specific info.
  1032                                  ;
  1033 0000001E <res Bh>                .sf_name:	resb	11		; 11 character name that is in the
  1034                                  					; directory entry.  This is used by
  1035                                  					; close to detect file deleted and
  1036                                  					; disk changed errors.
  1037                                  ; SHARING INFO
  1038 00000029 ????????                .sf_chain:	resd	1		; link to next SF
  1039 0000002D ????                    .sf_UID:	resw	1
  1040 0000002F ????                    .sf_PID:	resw	1
  1041 00000031 ????                    .sf_MFT:	resw	1
  1042 00000033 ????                    .sf_lstclus:	resw	1 ; *		; Last cluster accessed
  1043 00000035 ????????                .sf_IFS_HDR:	resd 	1 ; **
  1044                                  .size:
  1045                                  endstruc
  1046                                  
  1047                                  ; ----------------------------------------------------------------------
  1048                                  ; DOSCNTRY.INC (MSDOS 3.3 - 24/07/1987) 	
  1049                                  ; ----------------------------------------------------------------------
  1050                                  ; 11/06/2018 - Retro DOS v3.0
  1051                                  
  1052                                  ;Equates for COUNTRY INFORMATION.
  1053                                  SetCountryInfo		EQU	1	;country info
  1054                                  SetUcase		EQU	2	;uppercase table
  1055                                  SetLcase		EQU	3	;lowercase table (Reserved)
  1056                                  SetUcaseFile		EQU	4	;uppercase file spec table
  1057                                  SetFileList		EQU	5	;valid file character list
  1058                                  SetCollate		EQU	6	;collating sequence
  1059                                  SetDBCS 		EQU	7	;double byte character set
  1060                                  SetALL			EQU	-1	;all the entries
  1061                                  
  1062                                  ;DOS country and code page information table structure.
  1063                                  ;Internally, IBMDOS gives a pointer to this table.
  1064                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  1065                                  ;this structure.
  1066                                  
  1067                                  struc country_cdpg_info ; DOS_country_cdpg_info
  1068 00000000 ????????????????        .ccInfo_reserved :	resb	8	;reserved for internal use
  1069 00000008 <res 40h>               .ccPath_CountrySys:	resb	64	;path and filename for country info
  1070 00000048 ????                    .ccSysCodePage:		resw	1	;system code page id
  1071 0000004A ????                    .ccNumber_of_entries:	resw	1 ; dw 5
  1072 0000004C ??                      .ccSetUcase:		resb	1 ; db SetUcase ; = 2
  1073 0000004D ????????                .ccUcase_ptr:		resd	1	;pointer to Ucase table
  1074                                  
  1075 00000051 ??                      .ccSetUcaseFile:	resb	1 ; db SetUcaseFile ; = 4
  1076 00000052 ????????                .ccFileUcase_ptr: 	resd	1	;pointer to File Ucase table
  1077                                  
  1078 00000056 ??                      .ccSetFileList:		resb	1 ; db SetFileList ; = 5
  1079 00000057 ????????                .ccFileChar_ptr:	resd	1	;pointer to File char list table
  1080                                  
  1081 0000005B ??                      .ccSetCollate:		resb	1 ; db SetCollate ; = 6
  1082 0000005C ????????                .ccCollate_ptr:		resd	1	;pointer to collate table
  1083                                  
  1084 00000060 ??                      .ccSetCountryInfo:	resb	1 ; db SetCountryInfo ; = 1
  1085 00000061 ????                    .ccCountryInfoLen:	resw	1	;length of country info
  1086 00000063 ????                    .ccDosCountry:		resw	1	;system country code id
  1087 00000065 ????                    .ccDosCodePage:		resw	1	;system code page id
  1088 00000067 ????                    .ccDFormat:		resw	1	;date format
  1089 00000069 ??????????              .ccCurSymbol:		resb	5 ; db "    ",0
  1090                                  					;5 byte of (currency symbol+0)
  1091 0000006E ????                    .cc1000Sep:		resb	2 ; db " ",0 ;2 byte of (1000 sep. + 0)
  1092 00000070 ????                    .ccDecSep:		resb	2 ; db " ",0 ;2 byte of (Decimal sep. + 0)
  1093 00000072 ????                    .ccDateSep:		resb	2 ; db " ",0 ;2 byte of (date sep. + 0)
  1094 00000074 ????                    .ccTimeSep:		resb 	2 ; db " ",0 ;2 byte of (time sep. + 0)
  1095 00000076 ??                      .ccCFormat:		resb	1 	;currency format flags
  1096 00000077 ??                      .ccCSigDigits:		resb	1	;# of digits in currency
  1097 00000078 ??                      .ccTFormat:		resb	1	;time format
  1098 00000079 ????????                .ccMono_Ptr:		resd	1	;monocase routine entry point
  1099 0000007D ????                    .ccListSep:		resb	2 ; db " ",0 ;data list separator
  1100 0000007F <res Ah>                .ccReserved_area: 	resw	5 ; dw 5 dup(?) ;reserved
  1101                                  .size:
  1102                                  endstruc
  1103                                  
  1104                                  NEW_COUNTRY_SIZE    equ  country_cdpg_info.size - country_cdpg_info.ccDosCountry
  1105                                  
  1106                                  ; ======================================================================
  1107                                  ; retrodos4.s (offset addresses in MSDOS.SYS or RETRODOS.SYS)
  1108                                  ; ======================================================================
  1109                                  ; 21/03/2019 - Retro DOS v4.0
  1110                                  ; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)
  1111                                  
  1112                                  ;KERNEL_SEGMENT	equ 0070h  ; (IO.SYS loading segment, BIOS_DATA segment)
  1113                                  ; 21/10/2022
  1114                                  DOSBIODATASEG equ 0070h	; (IO.SYS loading segment, BIOS_DATA segment)
  1115                                  ; 22/10/2022
  1116                                  DOSBIOCODESEG equ 02C7h ; (MSDOS 5.0 IO.SYS, BIOS_CODE segment)
  1117                                  
  1118                                  ; Note: These offset addresses must be chanqed when the code 
  1119                                  ; 	in retrodos4.s (MSDOS.SYS) file will be changed.
  1120                                  
  1121                                  ; (following addresses can be verified by searching them in retrodos4.lst) 
  1122                                  
  1123                                  ; 13/05/2019
  1124                                  
  1125                                  ;IsWin386         equ 08CFh
  1126                                  ;V86_Crit_SetFocus equ 08D0h
  1127                                  ; 21/10/2022
  1128                                  IsWin386          equ 08D0h
  1129                                  V86_Crit_SetFocus equ 08D1h 
  1130                                  
  1131                                  ;seg_reinit	  equ 0772h ; not used in Retro DOS v4.0
  1132                                  ; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)
  1133                                  seg_reinit	  equ 0032h ; DOSBIOCODESEG:0032h
  1134                                  
  1135                                  ;SysinitPresent	  equ 08FCh
  1136                                  ; 21/10/2022
  1137                                  SysinitPresent	  equ 08FDh
  1138                                  
  1139                                  inHMA		  equ 000Dh
  1140                                  xms		  equ 000Eh
  1141                                  ;FreeHMAPtr	  equ 08F6h
  1142                                  ;multrk_flag	  equ 0533h
  1143                                  ;ec35_flag	  equ 0535h
  1144                                  ;EOT		  equ 012Eh
  1145                                  ; 21/10/2022
  1146                                  FreeHMAPtr	  equ 08F7h
  1147                                  multrk_flag	  equ 052Fh
  1148                                  ec35_flag	  equ 0531h
  1149                                  EOT		  equ 012Ch
  1150                                  
  1151                                  ;NextStack	  equ 08BFh
  1152                                  ;IT_StackLoc	  equ 08C5h
  1153                                  ;IT_StackSize	  equ 08C9h
  1154                                  ; 21/10/2022
  1155                                  NextStack	  equ 08C0h
  1156                                  IT_StackLoc	  equ 08C6h
  1157                                  IT_StackSize	  equ 08CAh
  1158                                  
  1159                                  ;MoveDOSIntoHMA	  equ 08F8h
  1160                                  ; 21/10/2022
  1161                                  MoveDOSIntoHMA	  equ 08F9h
  1162                                  
  1163                                  ;INT19SEM equ 0644h ; 01/05/2019 - retrodos4.lst
  1164                                  ;I19_LST  equ 0645h ; 27/03/2019 - retrodos4.lst
  1165                                  ; 21/10/2022
  1166                                  INT19SEM equ 0640h ; (iosys5.txt)
  1167                                  I19_LST  equ 0641h ; (iosys5.txt)
  1168                                  
  1169                                  INT19OLD02 equ I19_LST+1 ; 0642h ; 21/10/2022
  1170                                  INT19OLD08 equ I19_LST+6
  1171                                  INT19OLD09 equ I19_LST+11
  1172                                  INT19OLD0A equ I19_LST+16
  1173                                  INT19OLD0B equ I19_LST+21
  1174                                  INT19OLD0C equ I19_LST+26
  1175                                  INT19OLD0D equ I19_LST+31
  1176                                  INT19OLD0E equ I19_LST+36
  1177                                  INT19OLD70 equ I19_LST+41
  1178                                  INT19OLD72 equ I19_LST+46
  1179                                  INT19OLD73 equ I19_LST+51
  1180                                  INT19OLD74 equ I19_LST+56
  1181                                  INT19OLD76 equ I19_LST+61
  1182                                  INT19OLD77 equ I19_LST+66 ; 0683h ; 21/10/2022
  1183                                  
  1184                                  ;keyrd_func	equ 04E9h
  1185                                  ;keysts_func	equ 04EAh
  1186                                  ;t_switch	equ 04F6h
  1187                                  ; 21/10/2022
  1188                                  keyrd_func	equ 04E5h
  1189                                  keysts_func	equ 04E6h
  1190                                  t_switch	equ 04F2h
  1191                                  
  1192                                  ; 22/10/2022
  1193                                  SYSINITSEG	equ 046Dh  ; SYSINIT segment
  1194                                  BCODE_END	equ (SYSINITSEG-DOSBIOCODESEG)*16 ; = 1A60h
  1195                                  BCODE_START	equ 30h  ; (offset BiosDataWord in DOSBIOCODESEG) 
  1196                                  RE_INIT		equ 089Bh ; (re_init offset in DOSBIODATASEG)
  1197                                  
  1198                                  ; ----------------------------------------------------------------------
  1199                                  ; CONFIG.INC (MSDOS 6.0 - 1991) 	
  1200                                  ; ----------------------------------------------------------------------
  1201                                  ; 15/04/2019 - Retro DOS v4.0
  1202                                  
  1203                                  CONFIG_BEGIN        equ  '['
  1204                                  CONFIG_BREAK        equ  'C'
  1205                                  CONFIG_BUFFERS      equ  'B'
  1206                                  CONFIG_COMMENT      equ  'Y'
  1207                                  CONFIG_COUNTRY      equ  'Q'
  1208                                  CONFIG_DEVICE       equ  'D'
  1209                                  CONFIG_DEVICEHIGH   equ  'U'
  1210                                  CONFIG_DOS          equ  'H'
  1211                                  CONFIG_DRIVPARM     equ  'P'
  1212                                  CONFIG_FCBS         equ  'X'
  1213                                  CONFIG_FILES        equ  'F'
  1214                                  CONFIG_INCLUDE      equ  'J'
  1215                                  CONFIG_INSTALL      equ  'I'
  1216                                  CONFIG_INSTALLHIGH  equ  'W'
  1217                                  CONFIG_LASTDRIVE    equ  'L'
  1218                                  CONFIG_MENUCOLOR    equ  'R'
  1219                                  CONFIG_MENUDEFAULT  equ  'A'
  1220                                  CONFIG_MENUITEM     equ  'E'
  1221                                  CONFIG_MULTITRACK   equ  'M'
  1222                                  CONFIG_NUMLOCK      equ  'N'
  1223                                  CONFIG_REM          equ  '0'
  1224                                  CONFIG_SEMICOLON    equ  ';'
  1225                                  CONFIG_SET          equ  'V'
  1226                                  CONFIG_SHELL        equ  'S'
  1227                                  CONFIG_STACKS       equ  'K'
  1228                                  CONFIG_SUBMENU      equ  'O'
  1229                                  CONFIG_SWITCHES     equ  '1'
  1230                                  
  1231                                  CONFIG_UNKNOWN      equ  'Z'
  1232                                  
  1233                                  CONFIG_OPTION_QUERY equ 80h
  1234                                  
  1235                                  ; ----------------------------------------------------------------------
  1236                                  ; SYSINIT1.ASM (MSDOS 6.0 - 1991) 	
  1237                                  ; ----------------------------------------------------------------------
  1238                                  ; 21/03/2019 - Retro DOS v4.0
  1239                                  
  1240                                  true	equ	0FFFFh
  1241                                  false	equ	0
  1242                                  cr	equ	13
  1243                                  lf	equ	10
  1244                                  tab	equ	9
  1245                                  
  1246                                  multMULT	   equ	4Ah
  1247                                  multMULTGETHMAPTR  equ	1
  1248                                  multMULTALLOCHMA   equ	2
  1249                                  
  1250                                  ;NOEXEC    equ	FALSE
  1251                                  
  1252                                  stacksw    equ	true	;include switchable hardware stacks
  1253                                  mycds_size equ	88	;size of curdir_list. if it is not
  1254                                  			;the same, then will generate compile error.
  1255                                  
  1256                                  entrysize   equ     8
  1257                                  
  1258                                  mincount    equ     8
  1259                                  defaultcount equ    9
  1260                                  maxcount    equ     64
  1261                                  
  1262                                  minsize     equ     32
  1263                                  defaultsize equ     128
  1264                                  maxsize     equ     512
  1265                                  
  1266                                  ;%define allocbyte  byte [es:bp+0]
  1267                                  ;%define intlevel   byte [es:bp+1]
  1268                                  ;%define savedsp    word [es:bp+2]
  1269                                  ;%define savedss    word [es:bp+4]
  1270                                  ;%define newsp	    word [es:bp+6]
  1271                                  
  1272                                  allocbyte   equ     0
  1273                                  intlevel    equ     1
  1274                                  savedsp     equ     2
  1275                                  savedss     equ     4
  1276                                  newsp       equ     6
  1277                                  
  1278                                  free	    equ     0
  1279                                  allocated   equ     1
  1280                                  overflowed  equ     2
  1281                                  clobbered   equ     3
  1282                                  
  1283                                  ;---------------------------------------
  1284                                  ; external variable defined in ibmbio module for multi-track
  1285                                  
  1286                                  multrk_on equ	10000000b ;user specified mutitrack=on,or system turns
  1287                                  			  ; it on after handling config.sys file as a
  1288                                  			  ; default value,if multrk_flag = multrk_off1.
  1289                                  multrk_off1 equ 00000000b ;initial value. no "multitrack=" command entered.
  1290                                  multrk_off2 equ 00000001b ;user specified multitrack=off.
  1291                                  
  1292                                  ; SYSINITSEG	SEGMENT PUBLIC 'SYSTEM_INIT'
  1293                                  
  1294                                  SYSINIT$:
  1295                                  	;IF	STACKSW 
  1296                                  	; include MSSTACK.INC	;Main stack program and data definitions
  1297                                  	; include STKMES.INC	;Fatal stack error message
  1298                                  	;   public Endstackcode
  1299                                  ;Endstackcode	label byte
  1300                                  	;ENDIF
  1301                                  
  1302                                  ; 05/07/2018
  1303                                  ; ----------------------------------------------------------------------
  1304                                  ; 04/06/2018 - Retro DOS v3.0
  1305                                  
  1306                                  ; ----------------------------------------------------------------------
  1307                                  ; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS - SYSINIT)
  1308                                  ; ----------------------------------------------------------------------
  1309                                  
  1310                                  ;	MSStack.inc
  1311                                  ;
  1312                                  ;	Interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - AT level)
  1313                                  ;	should follow the standard Interrupt Sharing Scheme which has
  1314                                  ;	a standard header structure.
  1315                                  ;	Fyi, the following shows the relations between
  1316                                  ;	the interrupt vector and interrupt level.
  1317                                  ; VEC(Hex)    2  8  9  A  B  C	D  E  70  72  73  74  76  77
  1318                                  ; LVL(Deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
  1319                                  ;	MSSTACK module modifies the following interrupt vectors
  1320                                  ;	to meet the standard Interrupt Sharing standard;
  1321                                  ;	  A, B, C, D, E, 72, 73, 74, 76, 77.
  1322                                  ;	Also, for interrupt level 7 and 15, the FirstFlag in a standard header
  1323                                  ;	should be initialized to indicat whether this interrupt handler is
  1324                                  ;	the first (= 80h) or not.  The FirstFlag entry of INT77h's
  1325                                  ;	program header is initialized in STKINIT.INC module.
  1326                                  ;	FirstFlag is only meaningful for interrupt level 7 and 15.
  1327                                  ;
  1328                                  
  1329                                  ;  User specifies the number of stack elements - default = 9
  1330                                  ;						 minimum = 8
  1331                                  ;						 maximum = 64
  1332                                  ;
  1333                                  ;  Intercepts Asynchronous Hardware Interrupts only
  1334                                  ;
  1335                                  ;  Picks a stack from pool of stacks and switches to it
  1336                                  ;
  1337                                  ;  Calls the previously saved interrupt vector after pushing flags
  1338                                  ;
  1339                                  ;  On return, returns the stack to the stack pool
  1340                                  ;
  1341                                  
  1342                                  ; This is a modification of STACKS:
  1343                                  ; 1. To fix a bug which was causing the program to take up too much space.
  1344                                  ; 2. To dispense stack space from hi-mem first rather than low-mem first.
  1345                                  ;    . Clobbers the stack that got too big instead of innocent stack
  1346                                  ;    . Allows system to work if the only stack that got too big was the most
  1347                                  ;      deeply nested one
  1348                                  ; 3. Disables NMI interrupts while setting the NMI vector.
  1349                                  ; 4. Does not intercept any interupts on a PCjr.
  1350                                  ; 5. Double checks that a nested interrupt didn't get the same stack.
  1351                                  ; 6. Intercepts Ints 70, 72-77 for PC-ATs and other future products
  1352                                  
  1353                                  		;EVEN
  1354                                  ;align 2
  1355                                  
  1356                                  		; 21/10/2022
  1357                                  
  1358 00000000 0000                    		dw	0	; spare field but leave these in order
  1359 00000002 0000                    stackcount:	dw	0
  1360 00000004 0000                    stackat: 	dw	0
  1361 00000006 0000                    stacksize:	dw	0
  1362 00000008 0000                    stacks:		dw	0
  1363 0000000A 0000                    		dw	0
  1364                                  
  1365 0000000C [0800]                  firstentry:	dw	stacks
  1366 0000000E [4800]                  lastentry:	dw	stacks+(defaultcount*entrysize)-entrysize
  1367 00000010 [4800]                  nextentry:	dw	stacks+(defaultcount*entrysize)-entrysize
  1368                                  
  1369                                  ;***********************************************************************
  1370                                  ; THESE ARE THE INDIVIDUAL INTERRUPT HANDLERS
  1371                                  
  1372                                  ; ----------------------------------------------------------------------
  1373                                  
  1374 00000012 00000000                old02:	dd	0
  1375                                  
  1376                                  int02:
  1377                                  
  1378                                  ; *********************************************************************
  1379                                  ;
  1380                                  ; this is special support for the pc convertible / nmi handler
  1381                                  ;
  1382                                  ;	on the pc convertible, there is a situation where an nmi can be 
  1383                                  ;	caused by using the "out" instructions to certain ports. when this
  1384                                  ;	occurs, the pc convertible hardware *guarantees* that **nothing** 
  1385                                  ;	can stop the nmi or interfere with getting to the nmi handler. this
  1386                                  ;	includes other type of interrupts (hardware and software), and
  1387                                  ;	also includes other type of nmi's. when any nmi has occured,
  1388                                  ;	no other interrtupt (hardware, software or nmi) can occur until
  1389                                  ;	the software takes specific steps to allow further interrupting.
  1390                                  ;
  1391                                  ;	for pc convertible, the situation where the nmi is generated by the
  1392                                  ;	"out" to a control port requires "fixing-up" and re-attempting. in
  1393                                  ;	otherwords, it is actually a "restartable exception". in this
  1394                                  ;	case, the software handler must be able to get to the stack in
  1395                                  ;	order to figure out what instruction caused the problem, where
  1396                                  ;	it was "out"ing to and what value it was "out"ing.  therefore,
  1397                                  ;	we will not switch stacks in this situation. this situation is
  1398                                  ;	detected by interrogating port 62h, and checking for a bit value
  1399                                  ;	of 80h. if set, *****do not switch stacks*****.
  1400                                  ;
  1401                                  ; *********************************************************************
  1402                                  
  1403 00000016 50                      	push	ax
  1404 00000017 06                      	push	es
  1405 00000018 B800F0                  	mov	ax,0F000h
  1406 0000001B 8EC0                    	mov	es,ax
  1407                                  	; 02/11/2022
  1408 0000001D 26803EFEFFF9            	cmp	byte [es:0FFFEh],0F9h ; mdl_convert ;check if convertible
  1409 00000023 07                      	pop	es
  1410 00000024 750C                    	jne	short normal02
  1411                                  
  1412 00000026 E462                    	in	al,62h		; PC/XT PPI port C. Bits:
  1413                                  				; 0-3: values of DIP switches
  1414                                  				; 5: 1=Timer 2 channel out
  1415                                  				; 6: 1=I/O channel check
  1416                                  				; 7: 1=RAM parity check error occurred.
  1417 00000028 A880                    	test	al,80h
  1418 0000002A 7406                    	jz	short normal02
  1419                                  special02:
  1420 0000002C 58                      	pop	ax
  1421 0000002D 2EFF2E[1200]            	jmp	far [cs:old02]
  1422                                  normal02:
  1423 00000032 58                      	pop	ax
  1424 00000033 E81101                  	call	do_int_stacks
  1425 00000036 [1200]                  	dw	old02
  1426                                  
  1427                                  ; ----------------------------------------------------------------------
  1428                                  
  1429 00000038 00000000                old08:	dd	0
  1430                                  
  1431                                  int08:
  1432 0000003C E80801                  	call	do_int_stacks
  1433 0000003F [3800]                  	dw	old08
  1434                                  
  1435                                  ; ----------------------------------------------------------------------
  1436                                  
  1437 00000041 00000000                old09:	dd	0
  1438                                  
  1439                                  int09:
  1440                                  
  1441                                  ; keyboard interrupt must have a three byte jump, a nop and a zero byte
  1442                                  ; as its first instruction for compatibility reasons
  1443                                  
  1444 00000045 EB02                    	jmp	short keyboard_lbl
  1445 00000047 90                      	nop
  1446 00000048 00                      	db	0
  1447                                  
  1448                                  keyboard_lbl:
  1449 00000049 E8FB00                  	call	do_int_stacks
  1450 0000004C [4100]                  	dw	old09
  1451                                  
  1452                                  ; ----------------------------------------------------------------------
  1453                                  
  1454 0000004E 00000000                old70:	dd	0
  1455                                  
  1456                                  int70:
  1457 00000052 E8F200                  	call	do_int_stacks
  1458 00000055 [4E00]                  	dw	old70
  1459                                  
  1460                                  ; ----------------------------------------------------------------------
  1461                                  
  1462                                  ;	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
  1463                                  ;public	int&a
  1464                                  ;public	old&a
  1465                                  ;public	firstflag&a
  1466                                  ;int&a	proc	far
  1467                                  ;	jmp	short entry_int&a&_stk
  1468                                  ;old&a	dd	  0		;forward pointer
  1469                                  ;	dw	  424bh 	;compatible signature for int. sharing
  1470                                  ;firstflag&a db   0		;the firstly hooked.
  1471                                  ;	jmp	short intret_&a	;reset routine. we don't care this.
  1472                                  ;	db	7 dup (0)	;reserved for future.
  1473                                  ;entry_int&a&_stk:
  1474                                  ;	call	do_int_stacks
  1475                                  ;	dw	old&a
  1476                                  ;intret_&a:
  1477                                  ;	iret
  1478                                  ;int&a	endp
  1479                                  ;	endm
  1480                                  
  1481                                  ; ----------------------------------------------------------------------
  1482                                  
  1483                                  int0A:
  1484 00000057 EB10                    	jmp	short entry_int0A_stk
  1485 00000059 00000000                old0A:	dd	0	
  1486 0000005D 4B42                    	dw	424Bh
  1487                                  firstflag0A:
  1488 0000005F 00                      	db	0
  1489 00000060 EB0C                    	jmp	short intret_0A
  1490 00000062 00<rep 7h>              	times	7 db 0
  1491                                  
  1492                                  entry_int0A_stk:
  1493 00000069 E8DB00                  	call	do_int_stacks
  1494 0000006C [5900]                  	dw	old0A
  1495                                  intret_0A:
  1496 0000006E CF                      	iret
  1497                                  
  1498                                  ; ----------------------------------------------------------------------
  1499                                  
  1500                                  int0B:
  1501 0000006F EB10                    	jmp	short entry_int0B_stk
  1502 00000071 00000000                old0B:	dd	0	
  1503 00000075 4B42                    	dw	424Bh
  1504                                  firstflag0B:
  1505 00000077 00                      	db	0
  1506 00000078 EB0C                    	jmp	short intret_0B
  1507 0000007A 00<rep 7h>              	times	7 db 0
  1508                                  
  1509                                  entry_int0B_stk:
  1510 00000081 E8C300                  	call	do_int_stacks
  1511 00000084 [7100]                  	dw	old0B
  1512                                  intret_0B:
  1513 00000086 CF                      	iret
  1514                                  
  1515                                  ; ----------------------------------------------------------------------
  1516                                  
  1517                                  int0C:
  1518 00000087 EB10                    	jmp	short entry_int0C_stk
  1519 00000089 00000000                old0C:	dd	0	
  1520 0000008D 4B42                    	dw	424Bh
  1521                                  firstflag0C:
  1522 0000008F 00                      	db	0
  1523 00000090 EB0C                    	jmp	short intret_0C
  1524 00000092 00<rep 7h>              	times	7 db 0
  1525                                  
  1526                                  entry_int0C_stk:
  1527 00000099 E8AB00                  	call	do_int_stacks
  1528 0000009C [8900]                  	dw	old0C
  1529                                  intret_0C:
  1530 0000009E CF                      	iret
  1531                                  
  1532                                  ; ----------------------------------------------------------------------
  1533                                  
  1534                                  int0D:
  1535 0000009F EB10                    	jmp	short entry_int0D_stk
  1536 000000A1 00000000                old0D:	dd	0	
  1537 000000A5 4B42                    	dw	424Bh
  1538                                  firstflag0D:
  1539 000000A7 00                      	db	0
  1540 000000A8 EB0C                    	jmp	short intret_0D
  1541 000000AA 00<rep 7h>              	times	7 db 0
  1542                                  
  1543                                  entry_int0D_stk:
  1544 000000B1 E89300                  	call	do_int_stacks
  1545 000000B4 [A100]                  	dw	old0D
  1546                                  intret_0D:
  1547 000000B6 CF                      	iret
  1548                                  
  1549                                  ; ----------------------------------------------------------------------
  1550                                  
  1551                                  int0E:
  1552 000000B7 EB10                    	jmp	short entry_int0E_stk
  1553 000000B9 00000000                old0E:	dd	0	
  1554 000000BD 4B42                    	dw	424Bh
  1555                                  firstflag0E:
  1556 000000BF 00                      	db	0
  1557 000000C0 EB0C                    	jmp	short intret_0E
  1558 000000C2 00<rep 7h>              	times	7 db 0
  1559                                  
  1560                                  entry_int0E_stk:
  1561 000000C9 E87B00                  	call	do_int_stacks
  1562 000000CC [B900]                  	dw	old0E
  1563                                  intret_0E:
  1564 000000CE CF                      	iret
  1565                                  
  1566                                  ; ----------------------------------------------------------------------
  1567                                  
  1568                                  int72:
  1569 000000CF EB10                    	jmp	short entry_int72_stk
  1570 000000D1 00000000                old72:	dd	0	
  1571 000000D5 4B42                    	dw	424Bh
  1572                                  firstflag72:
  1573 000000D7 00                      	db	0
  1574 000000D8 EB0C                    	jmp	short intret_72
  1575 000000DA 00<rep 7h>              	times	7 db 0
  1576                                  
  1577                                  entry_int72_stk:
  1578 000000E1 E86300                  	call	do_int_stacks
  1579 000000E4 [D100]                  	dw	old72
  1580                                  intret_72:
  1581 000000E6 CF                      	iret
  1582                                  
  1583                                  ; ----------------------------------------------------------------------
  1584                                  
  1585                                  int73:
  1586 000000E7 EB10                    	jmp	short entry_int73_stk
  1587 000000E9 00000000                old73:	dd	0	
  1588 000000ED 4B42                    	dw	424Bh
  1589                                  firstflag73:
  1590 000000EF 00                      	db	0
  1591 000000F0 EB0C                    	jmp	short intret_73
  1592 000000F2 00<rep 7h>              	times	7 db 0
  1593                                  
  1594                                  entry_int73_stk:
  1595 000000F9 E84B00                  	call	do_int_stacks
  1596 000000FC [E900]                  	dw	old73
  1597                                  intret_73:
  1598 000000FE CF                      	iret
  1599                                  
  1600                                  ; ----------------------------------------------------------------------
  1601                                  
  1602                                  int74:
  1603 000000FF EB10                    	jmp	short entry_int74_stk
  1604 00000101 00000000                old74:	dd	0	
  1605 00000105 4B42                    	dw	424Bh
  1606                                  firstflag74:
  1607 00000107 00                      	db	0
  1608 00000108 EB0C                    	jmp	short intret_74
  1609 0000010A 00<rep 7h>              	times	7 db 0
  1610                                  
  1611                                  entry_int74_stk:
  1612 00000111 E83300                  	call	do_int_stacks
  1613 00000114 [0101]                  	dw	old74
  1614                                  intret_74:
  1615 00000116 CF                      	iret
  1616                                  
  1617                                  ; ----------------------------------------------------------------------
  1618                                  
  1619                                  int76:
  1620 00000117 EB10                    	jmp	short entry_int76_stk
  1621 00000119 00000000                old76:	dd	0	
  1622 0000011D 4B42                    	dw	424Bh
  1623                                  firstflag76:
  1624 0000011F 00                      	db	0
  1625 00000120 EB0C                    	jmp	short intret_76
  1626 00000122 00<rep 7h>              	times	7 db 0
  1627                                  
  1628                                  entry_int76_stk:
  1629 00000129 E81B00                  	call	do_int_stacks
  1630 0000012C [1901]                  	dw	old76
  1631                                  intret_76:
  1632 0000012E CF                      	iret
  1633                                  
  1634                                  ; ----------------------------------------------------------------------
  1635                                  
  1636                                  int77:
  1637 0000012F EB10                    	jmp	short entry_int77_stk
  1638 00000131 00000000                old77:	dd	0	
  1639 00000135 4B42                    	dw	424Bh
  1640                                  firstflag77:
  1641 00000137 00                      	db	0
  1642 00000138 EB0C                    	jmp	short intret_77
  1643 0000013A 00<rep 7h>              	times	7 db 0
  1644                                  
  1645                                  entry_int77_stk:
  1646 00000141 E80300                  	call	do_int_stacks
  1647 00000144 [3101]                  	dw	old77
  1648                                  intret_77:
  1649 00000146 CF                      	iret
  1650                                  
  1651                                  ; ----------------------------------------------------------------------
  1652                                  
  1653                                  ;********************************************************************
  1654                                  ;common routines
  1655                                  ;********************************************************************
  1656                                  
  1657                                  ; do interrupt stack switching. the fake return address holds
  1658                                  ; a pointer to the far-pointer of the actual interrupt
  1659                                  ; service routine
  1660                                  
  1661                                  ; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 SYSINIT)
  1662                                  ; 21/03/2019 - Retro DOS v4.0
  1663                                  
  1664                                  ;allocbyte   equ 0
  1665                                  ;intlevel    equ 1
  1666                                  ;savedsp     equ 2
  1667                                  ;savedss     equ 4
  1668                                  ;newsp       equ 6
  1669                                  
  1670                                  do_int_stacks:
  1671 00000147 50                      	push	ax
  1672 00000148 55                      	push	bp
  1673 00000149 06                      	push	es
  1674 0000014A 2E8E06[0A00]            	mov	es,[cs:stacks+2]	; Get segment of stacks
  1675 0000014F 2E8B2E[1000]            	mov	bp,[cs:nextentry]	; get most likely candidate
  1676 00000154 B001                    	mov	al,allocated ; 1
  1677                                  	; 21/10/2022
  1678 00000156 26864600                	xchg	[es:bp+allocbyte],al 
  1679                                  	;xchg	[es:bp],al		; grab the entry
  1680 0000015A 3C00                    	cmp	al,free ; 0		; still avail?
  1681 0000015C 754F                    	jne	short notfree02
  1682                                  
  1683 0000015E 2E832E[1000]08          	sub	word [cs:nextentry],entrysize ; set for next interrupt
  1684                                  
  1685                                  found02:
  1686 00000164 26896602                	mov	[es:bp+savedsp],sp	; save sp value
  1687 00000168 268C5604                	mov	[es:bp+savedss],ss	; save ss also
  1688                                  
  1689 0000016C 89E8                    	mov	ax,bp			; temp save of table offset
  1690                                  
  1691 0000016E 268B6E06                	mov	bp,[es:bp+newsp]	; get new SP value
  1692                                  	; 21/10/2022
  1693                                  	;mov	bp,[es:bp+6]
  1694 00000172 26394600                	cmp	[es:bp+0],ax	
  1695                                  	;cmp	[es:bp],ax		; check for offset into table
  1696 00000176 7542                    	jne	short foundbad02
  1697                                  
  1698                                  	;mov	ax,es			; point ss,sp to the new stack
  1699                                  	;mov	es,bp
  1700                                  	;mov	bp,sp
  1701                                  	;mov	bp,[bp+6]
  1702                                  	;mov	ss,ax
  1703                                  	;mov	sp,es
  1704                                  	;mov	es,ax
  1705                                  	;mov	bp,[cs:bp]
  1706                                  
  1707                                  	; 21/10/2022 (MSDOS 5.0 code SYSINIT code)
  1708 00000178 55                      	push    bp
  1709 00000179 89E5                    	mov     bp, sp
  1710 0000017B 8B4608                  	mov     ax, [bp+8]
  1711 0000017E 5D                      	pop     bp
  1712 0000017F 06                      	push    es
  1713 00000180 17                      	pop     ss
  1714 00000181 89EC                    	mov     sp, bp
  1715 00000183 89C5                    	mov     bp, ax
  1716 00000185 2E8B6E00                	mov     bp, [cs:bp+0]	
  1717                                  	
  1718 00000189 9C                      	pushf				; go execute the real interrupt handler
  1719                                  	;call	far [cs:bp]		;  which will iret back to here
  1720                                  	; 21/10/2022
  1721 0000018A 2EFF5E00                	call	far [cs:bp+0]
  1722                                  
  1723 0000018E 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1724                                  	;mov	bp,[es:bp]		;  but leave it on the stack
  1725                                  	; 21/10/2022
  1726 00000190 268B6E00                	mov	bp, [es:bp+0]
  1727 00000194 268E5604                	mov	ss,[es:bp+savedss]	; get old stack back
  1728 00000198 268B6602                	mov	sp,[es:bp+savedsp]
  1729                                  
  1730 0000019C 26C6460000              	mov	byte [es:bp+allocbyte],free ; free the entry
  1731                                  	; 21/10/2022
  1732                                  	;mov	byte [es:bp],free ; 0
  1733 000001A1 2E892E[1000]            	mov	[cs:nextentry],bp	; setup to use next time
  1734                                  
  1735 000001A6 07                      	pop	es
  1736 000001A7 5D                      	pop	bp			; saved on entry
  1737 000001A8 58                      	pop	ax			; saved on entry
  1738 000001A9 83C402                  	add	sp,2
  1739 000001AC CF                      	iret				; done with this interrupt
  1740                                  
  1741                                  notfree02:
  1742 000001AD 3C01                    	cmp	al,allocated		; error flag
  1743 000001AF 7404                    	je	short findnext02	;  no, continue
  1744 000001B1 26864600                	xchg	[es:bp+allocbyte],al	;  yes, restore error value
  1745                                  	; 21/10/2022
  1746                                  	;xchg	[es:bp],al
  1747                                  
  1748                                  findnext02:
  1749 000001B5 E81200                  	call	longpath
  1750 000001B8 EBAA                    	jmp	short found02
  1751                                  
  1752                                  foundbad02:
  1753 000001BA 2E3B2E[0C00]            	cmp	bp,[cs:firstentry]
  1754 000001BF 72F4                    	jc	short findnext02
  1755 000001C1 89C5                    	mov	bp,ax			; flag this entry
  1756 000001C3 26C6460003              	mov	byte [es:bp+allocbyte],clobbered
  1757                                  	; 21/10/2022
  1758                                  	;mov	byte [es:bp],clobbered ; 3
  1759 000001C8 EBEB                    	jmp	short findnext02	; keep looking
  1760                                  
  1761                                  ; ----------------------------------------------------------------------
  1762                                  
  1763                                  ; Common routines
  1764                                  
  1765                                  longpath:
  1766                                  	; 21/03/2019
  1767 000001CA 2E8B2E[0E00]            	mov	bp,[cs:lastentry]	; start with last entry in table
  1768                                  lploopp:
  1769 000001CF 26807E0000              	cmp	byte [es:bp+allocbyte],free ; is entry free?
  1770                                  	; 21/10/2022
  1771                                  	;cmp	byte [es:bp],free
  1772 000001D4 7512                    	jne	short inuse		;  no, try next one
  1773                                  
  1774 000001D6 B001                    	mov	al,allocated
  1775 000001D8 26864600                	xchg	[es:bp+allocbyte],al	; allocate entry
  1776                                  	; 21/10/2022
  1777                                  	;xchg	[es:bp],al
  1778 000001DC 3C00                    	cmp	al,free 		; is it still free?
  1779 000001DE 7414                    	je	short found		;  yes, go use it
  1780                                  
  1781 000001E0 3C01                    	cmp	al,allocated		; is it other than Allocated or Free?
  1782 000001E2 7404                    	je	short inuse		;  no, check the next one
  1783                                  
  1784 000001E4 26884600                	mov	[es:bp+allocbyte],al	;  yes, put back the error state
  1785                                  	; 21/10/2022
  1786                                  	;mov	[es:bp],al
  1787                                  inuse:
  1788 000001E8 2E3B2E[0C00]            	cmp	bp,[cs:firstentry]
  1789 000001ED 7406                    	je	short fatal
  1790 000001EF 83ED08                  	sub	bp,entrysize
  1791 000001F2 EBDB                    	jmp	short lploopp
  1792                                  found:
  1793 000001F4 C3                      	retn
  1794                                  fatal:
  1795 000001F5 1E                      	push	ds
  1796 000001F6 B800F0                  	mov	ax,0F000h		;look at the model byte
  1797 000001F9 8ED8                    	mov	ds,ax
  1798 000001FB 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ; convertible?
  1799 00000200 1F                      	pop	ds
  1800 00000201 7504                    	jne	short skip_nmis
  1801                                  
  1802 00000203 B007                    	mov	al,07h			; disable pc convertible nmis
  1803 00000205 E672                    	out	72h,al
  1804                                  
  1805                                  skip_nmis:
  1806 00000207 FA                      	cli				; disable and mask
  1807 00000208 B0FF                    	mov	al,0FFh			;   all other ints
  1808 0000020A E621                    	out	021h,al
  1809 0000020C E6A1                    	out	0A1h,al
  1810                                  
  1811 0000020E 8CCE                    	mov	si,cs
  1812 00000210 8EDE                    	mov	ds,si
  1813 00000212 BE[3902]                	mov	si,fatal_msg
  1814                                  ;SR;
  1815                                  ;   We set all foci to this VM to issue the stack failure message
  1816                                  ;
  1817 00000215 50                      	push	ax
  1818 00000216 1E                      	push	ds
  1819                                  	;;mov	ax,Bios_Data ; 0070h
  1820                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
  1821                                  	; 21/10/2022
  1822 00000217 B87000                  	mov	ax,DOSBIODATASEG
  1823 0000021A 8ED8                    	mov	ds,ax
  1824                                  
  1825                                  	;test	byte [08D0h],1 	; (MSDOS 6.21, IO.SYS - SYSINIT:021Eh)
  1826 0000021C F606D00801              	test	byte [IsWin386],1 ; (retrodos4.sys, offset: ****h)
  1827 00000221 1F                      	pop	ds
  1828 00000222 58                      	pop	ax
  1829 00000223 7405                    	jz	short fatal_loop	; win386 not present, continue
  1830                                  
  1831                                  	;;call	far ptr 0070h:08D1h ; (MSDOS 621, IO.SYS - SYSINIT:0227h)
  1832                                  	;call	KERNEL_SEGMENT:V86_Crit_SetFocus ; set focus to this VM
  1833                                  	; 21/10/2022
  1834 00000225 9AD1087000              	call	DOSBIODATASEG:V86_Crit_SetFocus ; 0070h:08D1h
  1835                                  ;
  1836                                  ;SR; We do not bother about the returned status of this call. 
  1837                                  ;
  1838                                  fatal_loop:
  1839 0000022A AC                      	lodsb
  1840 0000022B 3C24                    	cmp	al,'$'
  1841 0000022D 7408                    	je	short fatal_done
  1842                                  
  1843 0000022F B307                    	mov	bl,7
  1844 00000231 B40E                    	mov	ah,14
  1845 00000233 CD10                    	int	10h			; whoops, this enables ints
  1846 00000235 EBF3                    	jmp	short fatal_loop
  1847                                  
  1848                                  fatal_done:
  1849 00000237 EBFE                    	jmp	short fatal_done
  1850                                  
  1851                                  
  1852                                  ; 21/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
  1853                                  ; ----------------------------------------------------------------------
  1854                                  ;	include msbio.cl5		; fatal stack error message
  1855                                  
  1856                                  ; MSDOS 6.21, IO.SYS, SYSINIT:023Bh
  1857                                  
  1858                                  ; STKMES.INC - MSDOS 3.3 (24/07/1987)
  1859                                  ; ----------------------------------------------------------------------
  1860                                  ; 04/06/2018 - Retro DOS v3.0
  1861                                  
  1862                                  fatal_msg:
  1863 00000239 0D0A                    	db	0Dh,0Ah
  1864 0000023B 070D0A                  	db	7,0Dh,0Ah
  1865 0000023E 496E7465726E616C20-     	db	"Internal stack overflow",0Dh,0Ah
  1865 00000247 737461636B206F7665-
  1865 00000250 72666C6F770D0A     
  1866 00000257 53797374656D206861-     	db	"System halted",0Dh,0Ah,"$" 
  1866 00000260 6C7465640D0A24     
  1867                                  
  1868                                  endstackcode:
  1869                                  
  1870                                  ; ----------------------------------------------------------------------
  1871                                  ; SYINIT1.ASM (MSDOS 6.0, 1991) 'SYSINIT' jump addr from 'MSINIT.ASM'
  1872                                  ; ----------------------------------------------------------------------
  1873                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT1.ASM, 24/07/1987)
  1874                                  
  1875                                  ; 22/03/2019 - Retro DOS v4.0
  1876                                  
  1877                                  ; SYSINIT:0269h (MSDOS 6.21 IO.SYS, SYSINIT segment, offset: 0269h)
  1878                                  
  1879                                  ; ('SYSINIT:' location/address is used in 'retrodos4.s'. If following
  1880                                  ; address will be changed, it must also be changed in 'retrodos4.s'.)
  1881                                  
  1882                                  ; 21/10/2022- Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  1883                                  ; ----------------------------------------------------------------------
  1884                                  ; SYSINITSEG:0267h (MSDOS 5.0 IO.SYS, SYSINIT segment, offset: 0267h)
  1885                                  
  1886                                  SYSINIT:	
  1887 00000267 E91C02                          JMP	GOINIT
  1888                                  	;JMP	SYSIN ; 25/02/2018 - Retro DOS 2.0 modification
  1889                                  
  1890                                  ; ----------------------------------------------------------------------
  1891                                  
  1892                                  struc DDHighInfo
  1893 00000000 ????????                 .ddhigh_CSegPtr resd 1	; pointer to code segment to be relocated
  1894 00000004 ????                     .ddhigh_CSegLen resw 1	; length of code segment to be relocated
  1895 00000006 ????????                 .ddhigh_CallBak resd 1	; pointer to the call back routine
  1896                                  endstruc
  1897                                  
  1898                                  ; 22/03/2019 - Retro DOS v4.0
  1899                                  
  1900 0000026A 00                      runhigh: db	0
  1901                                  
  1902                                  ; 02/11/2022
  1903                                  ;align 4
  1904                                  
  1905                                  DOSINFO: 
  1906 0000026B 00000000                	dd	0	; address of the DOS Sysini Variables
  1907                                  ;MSDOS:
  1908                                  dos_temp_location: ; dword ; MSDOS 6.0
  1909                                  dosinit:		 ; MSDOS 6.0
  1910 0000026F 0000                    	dw	0
  1911                                  
  1912                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  1913                                  ;FINAL_DOS_LOCATION: ; 20/04/2019 - Retro DOS v4.0
  1914                                  ;	dw	0
  1915                                  ;MSDOS 5.0 IO.SYS - SYSINIT:0271h
  1916                                  
  1917                                  CURRENT_DOS_LOCATION:
  1918 00000271 0000                    	dw	0
  1919                                  
  1920                                  ;DOSSIZE: ; Retro DOS 2.0 feature - 25/02/2018
  1921                                  ;	dw	0   ; 'MSDOS.BIN' kernel size in words
  1922                                  
  1923                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  1924                                  ; (MSDOS 5.0 MSDOS.SYS size is 37394 bytes)
  1925                                  DOSSIZE	equ	0A000h	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)
  1926                                  
  1927                                  DEVICE_LIST:
  1928 00000273 00000000                	dd	0
  1929                                  
  1930                                  ; 04/06/2018 - Retro DOS v3.0
  1931                                  ; 28/03/2018
  1932                                  ;; MSDOS 3.3 - SYSINIT1.ASM - 24/07/1987
  1933                                  ;
  1934                                  sysi_country:	
  1935 00000277 00000000                	dd	0 ; 5/29/86 Pointer to country table in DOS
  1936                                  
  1937                                  ; MSDOS 6.0
  1938 0000027B 00000000                dos_segreinit:	dw	0,0	; room for dword
  1939                                  
  1940 0000027F 0000                    lo_doscod_size:	dw	0	; dos code size when in low mem
  1941 00000281 0000                    hi_doscod_size:	dw	0	; dos code size when in HMA
  1942                                  
  1943 00000283 0000                    def_php:	dw	0
  1944                                  
  1945                                  ; M022--
  1946                                  ; pointer for calling into Bios_Code for re-initializing segment values.
  1947                                  ;  call with ax = new segment for Bios_Code. Notice that we'll
  1948                                  ;  call it in its temporary home, cuz seg_reinit won't get moved to
  1949                                  ;  the new home.
  1950                                  
  1951                                  ;Bios_Code	equ	KERNEL_SEGMENT  ; 0070h
  1952                                  ; 21/10/2022
  1953                                  ;DOSBIOCODESEG	equ	02C7h ; (MSDOS 5.0 IO.SYS)
  1954                                  
  1955                                  ; 22/10/2022
  1956                                  seg_reinit_ptr:	; label dword
  1957 00000285 3200                    		dw	seg_reinit ; Bios_Code:0032h for MSDOS 6.21 IO.SYS
  1958                                  temp_bcode_seg:
  1959                                  		;dw	Bios_Code  ; 02CCh for MSDOS 6.21 IO.SYS
  1960                                  		; 22/10/2022
  1961 00000287 C702                    		dw	DOSBIOCODESEG ; 02C7h for MSDOS 5.0 IO.SYS 		
  1962                                  
  1963                                  fake_floppy_drv:
  1964 00000289 00                      		db	0	; set to 1 if this machine
  1965                                  				; does not have any floppies!!!
  1966                                  
  1967                                  ; Internal Stack Parameters
  1968                                  
  1969 0000028A 0900                    stack_count:	dW	defaultcount ; 9
  1970 0000028C 8000                    stack_size:	dw	defaultsize  ; 128
  1971 0000028E 00000000                stack_addr:	dd	0	
  1972                                  
  1973                                  ; 05/06/2018 - Retro DOS v3.0
  1974                                  
  1975                                  ; various default values
  1976                                  
  1977 00000292 0100                    MEMORY_SIZE:	dw	1
  1978                                  
  1979                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0 source, MSDOS 6.21 disassembled src.)
  1980                                  
  1981 00000294 0000                    RPLMemTop:	dw	0  ; 22/10/2022 (MSDOS 5.0 IO.SYS SYSINIT:0294h)	
  1982 00000296 00                      DEFAULT_DRIVE:	db	0	;initialized by ibminit.
  1983 00000297 FFFF                    buffers:	dw	0FFFFh	; initialized during buffer allocation
  1984 00000299 0000                    h_buffers:	dw	0	; # of the heuristic buffers. initially 0.
  1985 0000029B 0000                    singlebuffersize: dw	0	; maximum sector size + buffer head
  1986                                  
  1987 0000029D 08                      FILES:	db	8	; enough files for pipe
  1988 0000029E 04                      FCBS:	db	4	; performance for recycling
  1989 0000029F 00                      KEEP:	db	0	; keep original set
  1990 000002A0 05                      NUM_CDS: db	5	; 5 net drives
  1991                                  ; 22/10/2022 (MSDOS 5.0 SYSINIT)
  1992                                  ;CONFBOT: dw	0
  1993                                  ;ALLOCLIM: dw	0
  1994                                  CONFBOT: ; 02/11/2022
  1995 000002A1 0000                    top_of_cdss: dw 0
  1996                                  ; 02/11/2022 (MSDOS 5.0 SYSINIT)
  1997 000002A3 0000                    ALLOCLIM: dw	0	; (SYSINIT:02A3h)	
  1998                                  
  1999 000002A5 413A5C00                DirStrng: db	"A:\",0	; string for the root directory of a drive
  2000                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SAYSINIT compatibility)
  2001                                  ; (SYSINIT:02A9h)
  2002                                  command_line:
  2003 000002A9 0200                    	db	2,0
  2004 000002AB 50                      	db	'P'
  2005 000002AC 00                      	db	0
  2006 000002AD 00<rep 7Ch>             	times	124 db 0 ; db 124 dup(0)	
  2007                                  ; (SYSINIT:0329h)
  2008 00000329 00                      ZERO:	db	0
  2009 0000032A 00                      sepchr:	db	0
  2010 0000032B 0000                    linecount: dw	0			; line count in config.sys
  2011 0000032D 20202020200D0A24        showcount: db	'     ',cr,lf,'$'	; used to convert linecount to ascii.
  2012 00000335 0000                    buffer_linenum: dw	0		; line count for "buffers=" command if entered.
  2013                                  
  2014 00000337 FF                      sys_model_byte:	db	0FFh		; model byte used in sysinit
  2015 00000338 00                      sys_scnd_model_byte: db 0		; secondary model byte used in sysinit
  2016                                  
  2017 00000339 0000                    buf_prev_off:	dw	0
  2018                                  
  2019                                          ;IF      NOT NOEXEC
  2020                                  ;COMEXE EXEC0 <0,COMMAND_LINE,DEFAULT_DRIVE,ZERO>
  2021                                          ;ENDIF
  2022                                  
  2023                                  ; 01/05/2018
  2024                                  COMEXE:
  2025 0000033B 0000                    EXEC0.ENVIRON:	dw	0	; seg addr of environment
  2026 0000033D [A902]                  EXEC0.COM_LINE:	dw	command_line ; pointer to asciz command line
  2027 0000033F 0000                    		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
  2028 00000341 [9602]                  EXEC0.5C_FCB:	dw	DEFAULT_DRIVE ; default fcb at 5C
  2029 00000343 0000                    		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
  2030 00000345 [2903]                  EXEC0.6C_FCB:	dw	ZERO	; default fcb at 6C
  2031 00000347 0000                    		dw	0
  2032                                  
  2033                                  ; variables for install= command.
  2034                                  
  2035 00000349 00                      multi_pass_id:	db	0		; parameter passed to multi_pass
  2036                                  					;  indicating the pass number
  2037                                  					; 0 - do scan for DOS=HIGH/LOW
  2038                                  					; 1 - load device drivers
  2039                                  					; 2 - was to load IFS
  2040                                  					;      now it is unused
  2041                                  					; 3 - do install=
  2042                                  					; >3 - nop
  2043 0000034A 0000                    install_flag:	dw	0
  2044                                  
  2045                                  have_install_cmd equ	00000001b	; config.sys has install= commands
  2046                                  has_installed	equ	00000010b	; sysinit_base installed.
  2047                                  
  2048 0000034C 0000                    config_size:	dw	0		; size of config.sys file. set by sysconf.asm
  2049 0000034E 00000000                sysinit_base_ptr: dd	0		; pointer to sysinit_base
  2050 00000352 00000000                sysinit_ptr:	dd	0		; returning addr. from sysinit_base
  2051 00000356 0000                    checksum:	dw	0		; used by sum_up
  2052                                  
  2053 00000358 20<rep 14h>             ldexec_fcb:	times 20 db 20h ; db 20 dup (' ') ;big enough
  2054 0000036C 00                      ldexec_line:	db	0		;# of parm characters
  2055 0000036D 20                      ldexec_start:	db	' '
  2056 0000036E 00<rep 50h>             ldexec_parm:	times 80 db 0	; db 80 dup (0)
  2057                                  
  2058                                  ;instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>
  2059                                  
  2060                                  instexe:
  2061 000003BE 0000                    iexec.environ:	dw	0		; seg addr of environment
  2062 000003C0 [6C03]                  iexec.ldexec_line: dw	ldexec_line ; pointer to asciz command line
  2063 000003C2 0000                    		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
  2064 000003C4 [5803]                  iexec.ldexec_5c_fcb: dw	ldexec_fcb	; default fcb at 5C
  2065 000003C6 0000                    		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
  2066 000003C8 [5803]                  iexec.ldexec_6c_fcb: dw	ldexec_fcb	; default fcb at 6C
  2067 000003CA 0000                    		dw	0
  2068                                  
  2069                                  ; variables for comment=
  2070                                  
  2071 000003CC 00                      com_level:	db	0		; level of " " in command line
  2072 000003CD 00                      cmmt:		db	0		; length of comment string token
  2073 000003CE 00                      cmmt1:		db	0		; token
  2074 000003CF 00                      cmmt2:		db	0		; token
  2075 000003D0 00                      cmd_indicator:	db	0
  2076 000003D1 00                      donotshownum:	db	0
  2077                                  
  2078 000003D2 0000                    count:		dw	0
  2079 000003D4 0000                    org_count:	dw	0
  2080 000003D6 0000                    chrptr:		dw	0
  2081 000003D8 0000                    cntryfilehandle: dw	0
  2082 000003DA 0000                    old_area:	dw	0
  2083 000003DC 0000                    impossible_owner_size: dw 0		; paragraph
  2084                                  
  2085                                  bucketptr: ; label dword
  2086                                  bufptr:	   ; label dword		; leave this stuff in order!
  2087 000003DE 0000                    memlo:	dw	0
  2088                                  prmblk:	   ; label word
  2089 000003E0 0000                    memhi:	dw	0
  2090 000003E2 0000                    ldoff:	dw	0
  2091 000003E4 0000                    area:	dw	0
  2092                                  
  2093                                  ; Following is the request packet used to call INIT routines for 
  2094                                  ; all device drivers. Some fields may be accessed individually in
  2095                                  ; the code, and hence have individual labels, but they should not
  2096                                  ; be separated.
  2097                                  
  2098 000003E6 18                      packet:	db	24			; was 22
  2099 000003E7 00                      	db	0
  2100 000003E8 00                      	db	0			; initialize code
  2101 000003E9 0000                    	dw	0
  2102 000003EB 00<rep 8h>              	times	8 db 0	; db 8 dup (?)
  2103                                  
  2104 000003F3 00                      unitcount:	db	0
  2105 000003F4 00000000                break_addr:	dd	0
  2106 000003F8 00000000                bpb_addr:	dd	0
  2107                                  drivenumber:	; 22/10/2022
  2108 000003FC 00                      devdrivenum:	db	0 
  2109 000003FD 0000                    configmsgflag:	dw	0  ; used to control "error in config.sys line #" message
  2110                                  
  2111                                  ; end of request packet
  2112                                  
  2113                                  ;drivenumber:	db	0  ; 22/03/2019
  2114                                  
  2115                                  toomanydrivesflag:
  2116 000003FF 00                      		db	0  ; >24 fixed disk partitions flag ; M029 
  2117                                  align 2
  2118                                  
  2119                                  BCodeSeg:	; 21/10/2022
  2120 00000400 C702                    	dw	DOSBIOCODESEG ; (02C7h for MSDOS 5.0 IO.SYS)
  2121                                  	;dw	Bios_Code ; = KERNEL_SEGMENT = 0070h (for Retro DOS v4.0)
  2122                                  			   ; BCodeSeg = 2CCh (for MSDOS 6.21 IO.SYS)
  2123                                  
  2124                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  2125                                  ;; 19/04/2019
  2126                                  ;_timer_lw_:
  2127                                  ;	dw	0  ; MSDOS 6.21 IO.SYS - SYSINIT:038Ch
  2128                                  	
  2129                                  ;SR;
  2130                                  ; This is the communication block between the DOS and the BIOS. It starts at
  2131                                  ;the SysinitPresent flag. Any other data that needs to be communicated 
  2132                                  ;to the DOS should be added after SysinitPresent. The pointer to this block
  2133                                  ;is passed to DOS as part of the DOSINIT call.
  2134                                  ;
  2135                                  
  2136                                  BiosComBlock:
  2137                                  	;dd	Bios_Data:SysinitPresent 
  2138                                  		; 0070h:08FDh for MSDOS 6.21 IO.SYS
  2139 00000402 FD08                    	dw	SysinitPresent  ; (retrodos4.sys, offset: ****h)
  2140                                  	;dw	KERNEL_SEGMENT ; 0070h
  2141                                  	; 21/10/2022
  2142 00000404 7000                    	dw	DOSBIODATASEG ; 0070h
  2143                                  
  2144                                  ;align 2
  2145                                  
  2146                                  	; 22/10/2022 - (MSDOS 5.0 IO.SYS, SYSINIT:0406h)
  2147                                  tempstack:	
  2148 00000406 00<rep 80h>             	times	128 db 0  ; db	80h dup (?)
  2149                                  
  2150                                  ; ----------------------------------------------------------------------------
  2151                                  
  2152                                  	; 22/10/2022 - Retro DOS v4.0
  2153                                  	;	; (MSDOS 5.0 IO.SYS, SYSINIT:0486h)
  2154                                  GOINIT:		; (MSDOS 6.21 IO.SYS, SYSINIT:0412h)
  2155                                  	; 22/03/2019 - Retro DOS v4.0
  2156                                  	; 06/07/2018
  2157                                  	; 04/06/2018 - Retro DOS v3.0
  2158                                  ; before doing anything else, let's set the model byte
  2159 00000486 B4C0                    	mov	ah,0C0h 		; get system configuration
  2160 00000488 CD15                    	int	15h			; *
  2161 0000048A 7217                    	jc	short no_rom_config
  2162                                  
  2163 0000048C 80FC00                  	cmp	ah,0			; double check
  2164 0000048F 7512                    	jne	short no_rom_config
  2165 00000491 268A4702                	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
  2166 00000495 2EA2[3703]              	mov	[cs:sys_model_byte],al 
  2167 00000499 268A4703                	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
  2168 0000049D 2EA2[3803]              	mov	[cs:sys_scnd_model_byte],al
  2169                                  
  2170                                  	;jmp	short SYSIN
  2171                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  2172 000004A1 EB2E                    	jmp	short move_myself
  2173                                  
  2174                                  no_rom_config:				; Old ROM
  2175 000004A3 B800F0                  	mov	ax,0F000h
  2176 000004A6 8ED8                    	mov	ds,ax
  2177 000004A8 A0FEFF                  	mov	al,[0FFFEh]
  2178 000004AB 2EA2[3703]              	mov	[cs:sys_model_byte],al	; set the model byte.
  2179                                  
  2180                                  ; set fake_floppy_drv if there is no diskette drives in this machine.
  2181                                  ; execute the equipment determination interrupt and then
  2182                                  ; check the returned value to see if we have any floppy drives
  2183                                  ; if we have no floppy drive we set cs:fake_floppy_drv to 1
  2184                                  ; see the at tech ref bios listings for help on the equipment
  2185                                  ; flag interrupt (11h)	
  2186                                  
  2187                                  	; 22/10/2022
  2188                                  check_for_fake_floppy:			; entry point for rom_config above
  2189 000004AF CD11                    	int	11h			; check equipment flag
  2190                                  
  2191 000004B1 A90100                  	test	ax,1			; have any floppies?
  2192 000004B4 751B                    	jnz	short move_myself	; yes,normal system
  2193                                  
  2194                                  ; Some ROM BIOSs lie that there are no floppy drives. Lets find out
  2195                                  ; whether it is an old ROM BIOS or a new one
  2196                                  ;
  2197                                  ; WARNING !!!
  2198                                  ;
  2199                                  ; This sequence of code is present in MSINIT.ASM also. Any modification
  2200                                  ; here will require an equivalent modification in MSINIT.ASM also
  2201                                  
  2202 000004B6 06                      	push	es
  2203                                  
  2204 000004B7 30C9                    	xor	cl,cl	
  2205 000004B9 B408                    	mov	ah,8			; get disk parameters
  2206 000004BB B200                    	mov	dl,0			; of drive 0
  2207 000004BD CD13                    	int	13h
  2208                                  
  2209 000004BF 07                      	pop	es
  2210                                  
  2211 000004C0 720F                    	jc	short move_myself	; if error lets assume that the
  2212                                  					;  ROM BIOS lied
  2213 000004C2 80F900                  	cmp	cl,0			; double check (max sec no cannot be 0
  2214 000004C5 740A                    	je	short move_myself
  2215                                  
  2216 000004C7 08D2                    	or	dl,dl			; number of flp drvs == 0?
  2217 000004C9 7506                    	jnz	short move_myself
  2218                                  
  2219 000004CB 2EC606[8902]01          	mov	byte [cs:fake_floppy_drv],1 ; set fake flag.
  2220                                  
  2221                                  move_myself:
  2222 000004D1 FC                      	cld				; set up move
  2223 000004D2 31F6                    	xor	si,si
  2224 000004D4 89F7                    	mov	di,si
  2225                                  
  2226 000004D6 2E8B0E[9202]            	mov	cx,[cs:MEMORY_SIZE]
  2227                                  
  2228                                  	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)
  2229                                  ;;;	if	msver
  2230                                  ;	cmp	cx,1		; 1 means do scan
  2231                                  ;	jnz	short noscan
  2232                                  ;	mov	cx,2048		; start scanning at 32k boundary
  2233                                  ;	xor	bx,bx
  2234                                  ;
  2235                                  ;memscan:inc	cx
  2236                                  ;	jz	setend
  2237                                  ;	mov	ds,cx
  2238                                  ;	mov	al,[bx]
  2239                                  ;	not	al
  2240                                  ;	mov	[bx],al
  2241                                  ;	cmp	al,[bx]
  2242                                  ;	not	al
  2243                                  ;	mov	[bx],al
  2244                                  ;	jz	short memscan
  2245                                  ;setend:
  2246                                  ;	mov	cs:[memory_size],cx
  2247                                  ;;;	endif
  2248                                  
  2249                                  ;noscan: 				; cx is mem size in para
  2250                                  ;;
  2251                                  ;;	cas -- a) if we got our memory size from the ROM, we should test it
  2252                                  ;;		  before we try to run.
  2253                                  ;;	       b) in any case, we should check for sufficient memory and give
  2254                                  ;;		  an appropriate error diagnostic if there isn't enough
  2255                                  ;
  2256                                  ;	push	cs
  2257                                  ;	pop	ds
  2258                                  ;
  2259                                  ;;	cas note:  It would be better to put dos + bios_code BELOW sysinit
  2260                                  ;;	  that way it would be easier to slide them down home in a minimal
  2261                                  ;;	  memory system after sysinit.  As it is, you need room to keep
  2262                                  ;;	  two full non-overlapping copies, since sysinit sits between the
  2263                                  ;;	  temporary home and the final one.  the problem with doing that
  2264                                  ;;	  is that sys*.asm are filled with "mov ax,cs, sub ax,11h" type stuff.
  2265                                  ;
  2266                                  ;	dec	cx			; one para for an arena at end of mem
  2267                                  ;					; in case of UMBs
  2268                                  
  2269                                  	; 22/10/2022
  2270                                  	; (MSDOS 5.0 IOSYSY SYSINIT:04DBh)
  2271                                  
  2272 000004DB 0E                      	push	cs
  2273 000004DC 1F                      	pop	ds
  2274 000004DD 49                      	dec	cx
  2275                                  
  2276                                  ;------ Check if an RPL program is present at TOM and do not tromp over it
  2277                                  
  2278 000004DE 31DB                    	xor	bx,bx
  2279 000004E0 8EC3                    	mov	es,bx
  2280 000004E2 268B1EBC00              	mov	bx,[es:(2Fh*4)] ; INT 2Fh address (0:0BCh)
  2281 000004E7 268E06BE00              	mov	es,[es:((2Fh*4)+2)] ; INT 2Fh segment (0:0BEh)
  2282 000004EC 26817F035250            	cmp	word [es:bx+3],'RP'
  2283 000004F2 751C                    	jne	short NoRPL
  2284 000004F4 26807F054C              	cmp	byte [es:bx+5],'L'
  2285 000004F9 7515                    	jne	short NoRPL
  2286                                  
  2287 000004FB 89CA                    	mov	dx,cx			; get TOM into DX
  2288 000004FD 52                      	push	dx
  2289 000004FE B8064A                  	mov	ax,4A06h
  2290                                  	;mov	ax,(multMULT<<8)+multMULTRPLTOM
  2291 00000501 CD2F                    	int	2Fh			; Get new TOM from any RPL
  2292 00000503 58                      	pop	ax
  2293 00000504 89D1                    	mov	cx,dx
  2294 00000506 39C2                    	cmp	dx,ax
  2295 00000508 7406                    	je	short NoRPL
  2296                                  	
  2297                                  	;mov	[RPLMemTop],dx
  2298                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  2299 0000050A 2E8916[9402]            	mov	[cs:RPLMemTop],dx
  2300                                  	
  2301 0000050F 49                      	dec	cx
  2302                                  NoRPL:
  2303 00000510 B8[203D]                	mov	ax,SI_end		; need this much room for sysinit
  2304                                  					; (SI_end == sysinit code size)
  2305 00000513 E81607                  	call	off_to_para
  2306 00000516 29C1                    	sub	cx,ax
  2307                                  
  2308                                  ; we need to leave room for the DOS and (if not ROMDOS) for the BIOS
  2309                                  ; code above sysinit in memory
  2310                                  ;
  2311 00000518 81E9000A                	sub	cx,DOSSIZE/16		; leave this much room for DOS
  2312                                  
  2313 0000051C B8601A                  	mov	ax,BCODE_END 		; (1A60h for MSDOS 5.0 IO.SYS)
  2314 0000051F E80A07                  	call	off_to_para		; leave this much room for BIOS code
  2315 00000522 29C1                    	sub	cx,ax
  2316 00000524 8EC1                    	mov	es,cx			; offset where sysinit will be located
  2317                                  
  2318 00000526 B9[203D]                	mov	cx,SI_end		; (sysinit code size)
  2319 00000529 D1E9                    	shr	cx,1			; divide by 2 to get words
  2320 0000052B F3A5                    	rep	movsw			; relocate sysinit
  2321                                  
  2322 0000052D 06                      	push	es			; push relocated segment
  2323 0000052E B8[3305]                	mov	ax,SYSIN
  2324 00000531 50                      	push	ax			; push relocated entry point
  2325                                  
  2326 00000532 CB                      	retf				; far jump to relocated sysinit
  2327                                  
  2328                                  ; ----------------------------------------------------------------------------
  2329                                  
  2330                                  ;	MOVE THE DOS TO ITS PROPER LOCATION
  2331                                  
  2332                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
  2333                                  	; (SYSINIT:0533h)
  2334                                  SYSIN:
  2335                                  	; Retro DOS 4.0 - 22/03/2019
  2336                                  	; Retro DOS 2.0 - 25/02/2018
  2337                                  
  2338                                  	; 23/04/2019
  2339                                  	;;mov	ax,Bios_Data
  2340                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
  2341                                  	; 21/10/2022
  2342 00000533 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  2343 00000536 8ED8                    	mov	ds,ax
  2344 00000538 8C0EFB08                	mov	[MoveDOSIntoHMA+2],cs	; set seg of routine to move DOS
  2345 0000053C C606FD0801              	mov	byte [SysinitPresent],1	; flag that MoveDOSIntoHMA can be called
  2346                                  
  2347                                  ; first move the MSDOS.SYS image up to a harmless place 
  2348                                  ; on top of our new sysinitseg
  2349                                  
  2350                                  	; 22/10/2022
  2351 00000541 B8[203D]                	mov	ax,SI_end		; how big is sysinitseg?
  2352 00000544 E8E506                  	call	off_to_para
  2353 00000547 8CC9                    	mov	cx,cs			; pick a buffer for msdos above us
  2354 00000549 01C8                    	add	ax,cx
  2355 0000054B 8EC0                    	mov	es,ax
  2356                                  	
  2357 0000054D 31F6                    	xor	si,si
  2358 0000054F 89F7                    	mov	di,si
  2359                                  
  2360 00000551 2E8E1E[7102]            	mov	ds,[cs:CURRENT_DOS_LOCATION] ; where it is (set by msinit)
  2361                                  
  2362                                  	;mov	ax,cs	
  2363                                  	;mov	ds,ax
  2364                                  
  2365                                  	;;;mov	cx,20480  ; MSDOS 6.21 IO.SYS - SYSINIT:04E2h
  2366                                  	;;mov	cx,dossize/2 ; MSDOS 6.0
  2367                                  	;mov	cx,[DOSSIZE] ; words (not bytes!)  ; Retro DOS v4.0 (3.0, 2.0)
  2368                                  	;mov	es,[FINAL_DOS_LOCATION] ; on top of SYSINIT code
  2369                                  	;mov	ds,[CURRENT_DOS_LOCATION]
  2370                                  
  2371                                  	; 22/10/2022
  2372 00000556 B90050                  	mov	cx,DOSSIZE/2 ; 5000h
  2373 00000559 F3A5                    	rep     movsw
  2374 0000055B 2E8C06[7102]            	mov	[cs:CURRENT_DOS_LOCATION],es
  2375                                  
  2376                                  ; The DOS code is ORGed at a non-zero value to allow it to be located in
  2377                                  ; HIMEM. Thus, the DOS segment location must be adjusted accordingly.
  2378                                  ; If this is ROMDOS, however, only the init code is loaded into RAM, so
  2379                                  ; this ORG is not done. The entry point is at offset zero in the segment.
  2380                                  
  2381                                  	; 22/04/2019 (MSDOS 6.0 & MSDOS 6.21 kernel address modification)
  2382                                  	;mov	ax,cs
  2383                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  2384                                  	;mov	ds,ax
  2385                                  
  2386                                  ; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !
  2387                                  
  2388                                  ;	; 24/04/2019 
  2389                                  ;;ifndef ROMDOS
  2390                                  ;	mov	ax,[es:3] 		; get offset of dos
  2391                                  ;		; ax = 3DE0h for MSDOS 6.21 kernel (MSDOS.SYS, offset 3) 
  2392                                  ;	mov	[dosinit],ax		; that's the entry point offset
  2393                                  ;	call	off_to_para		; subtract this much from segment
  2394                                  ;	; 23/04/2019
  2395                                  ;	;sub	[CURRENT_DOS_LOCATION],ax
  2396                                  ;	sub	[FINAL_DOS_LOCATION],ax
  2397                                  ;;else
  2398                                  ;;	mov	word [dosinit],0	; entry to init is at zero
  2399                                  ;;
  2400                                  ;;endif ; ROMDOS
  2401                                  
  2402                                  	; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !
  2403                                  	; (! MSDOS6.BIN starts with DOSDATA ! - Retro DOS v4.0 modification) 
  2404                                  
  2405                                  	;mov	ax,[es:0] ; DOSCODE start address = DOSDATA size (= 136Ah)
  2406                                  	;		  ; (Valid for Retro DOS v4.0 only!)
  2407                                  
  2408                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  2409                                  	; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
  2410 00000560 A10300                  	mov	ax, [3]		; mov ax, word ptr ds:3
  2411                                  
  2412 00000563 2EA3[6F02]              	mov	[cs:dosinit],ax ; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
  2413                                  	; 02/11/2022
  2414 00000567 E8C206                  	call	off_to_para		; subtract this much from segment
  2415 0000056A 2E2906[7102]            	sub	[cs:CURRENT_DOS_LOCATION],ax
  2416                                  
  2417                                  	; Current DOSCODE start address = dword [dosinit]
  2418                                  
  2419                                  ;; If this is not ROMDOS, then the BIOS code is moved to the top of memory
  2420                                  ;; until it is determined whether it will be running in HIMEM or not.
  2421                                  
  2422                                  ;ifndef ROMDOS
  2423                                  
  2424                                  ; now put Bios_Code up on top of that. Assume Bios_Code + dossize < 64k
  2425                                  
  2426                                  	; 22/10/2022
  2427 0000056F 8CC0                    	mov	ax,es
  2428 00000571 05000A                  	add	ax,DOSSIZE/16		; get paragraph of end of dos
  2429 00000574 8EC0                    	mov	es,ax
  2430 00000576 2E8706[8702]            	xchg	ax,[cs:temp_bcode_seg]	; swap with original home of Bios_Code
  2431 0000057B 8ED8                    	mov	ds,ax			; point to loaded image of Bios_Code
  2432                                  
  2433 0000057D BE3000                  	mov	si,BCODE_START ; mov si,30h
  2434                                  	; 02/11/2022
  2435 00000580 89F7                    	mov	di,si
  2436 00000582 B9601A                  	mov	cx,BCODE_END   ; mov cx,1A60h
  2437 00000585 29F1                    	sub	cx,si
  2438 00000587 D1E9                    	shr	cx,1
  2439 00000589 F3A5                    	rep	movsw			; move Bios_Code into place
  2440                                  
  2441 0000058B 8CC0                    	mov	ax,es			; tell it what segment it's in
  2442 0000058D 2EFF1E[8502]            	call	far [cs:seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)
  2443                                  
  2444                                  ;endif	; not ROMDOS
  2445                                  
  2446                                  ; now call dosinit while it's in its temporary home
  2447                                  
  2448                                  	;mov	ax,cs
  2449                                  	;mov	ds,ax	 
  2450                                  
  2451                                  	;mov	dx,[MEMORY_SIZE]	; set for call to dosinit
  2452                                  
  2453                                  	; 22/10/2022
  2454                                  
  2455 00000592 2EC43E[0204]            	les	di,[cs:BiosComBlock]	; ptr to BIOS communication block
  2456                                  		; es = KERNEL_SEGMENT (70h), di = 'SysInitPresent' address
  2457 00000597 2EC536[7302]            	lds	si,[cs:DEVICE_LIST]	; set for call to dosinit
  2458                                  		; ds = KERNEL_SEGMENT (70h), si = 'res_dev_list' address
  2459                                  
  2460 0000059C 2E8B16[9202]            	mov	dx,[cs:MEMORY_SIZE]	; set for call to dosinit
  2461                                  
  2462 000005A1 FA                      	cli
  2463 000005A2 8CC8                    	mov	ax,cs
  2464 000005A4 8ED0                    	mov	ss,ax
  2465                                  
  2466                                  ; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM)
  2467                                  %define locstack ($ - SYSINIT$) & 0FFFEh  ; 532h in MSDOS 6.21 IO.SYS
  2468                                  					  ; 5A6h in MSDOS 5.0 IO.SYS SYSINIT
  2469                                  ;SYSINIT:0532h:
  2470                                  
  2471                                  ; 22/10/2022
  2472                                  ; ----------------------------------------------------------------------------
  2473                                  ;SYSINIT:05A6h:
  2474                                  ;locstack:	; (at SYSINIT:05A6h for MSDOS 5.0 IO.SYS)
  2475                                  
  2476                                  	;mov	sp, 05A6h
  2477 000005A6 BCA605                  	mov     sp,locstack		; set stack
  2478                                  
  2479 000005A9 FB                      	sti
  2480                                  
  2481                                  ;align 2
  2482                                  	; 30/03/2018
  2483                                  ;LOCSTACK:
  2484                                          ;CALL	FAR [CS:MSDOS]	; FINAL_DOS_LOCATION:0 
  2485                                  		       		;('jmp DOSINIT' in 'MSHEAD.ASM')
  2486                                  		       		;('DOSINIT:' is in 'MSINIT.ASM')
  2487                                  
  2488                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  2489                                  	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21)
  2490                                  
  2491                                  ; This call to DOSINIT will relocate the DOS data from its present location
  2492                                  ; at the top of memory, to its final location in low memory just above the
  2493                                  ; BIOS data. It will then build important DOS data structures in low 
  2494                                  ; memory following the DOS data. It returns (among many other things) the
  2495                                  ; new starting address of free memory.
  2496                                  
  2497 000005AA 2EFF1E[6F02]            	call	far [cs:dosinit]	; call dosinit	
  2498                                  			 ; es:di -> sysinitvars_ext
  2499                                  
  2500 000005AF 2E8C1E[8302]            	mov	[cs:def_php],ds		; save pointer to PSP
  2501                                  
  2502                                  	; 22/03/2019
  2503                                  	;push	cs
  2504                                  	;pop	ds
  2505                                  	; 22/10/2022
  2506                                  	;mov	[hi_doscod_size],ax
  2507                                  	;mov	[lo_doscod_size],cx
  2508                                  	;mov	[dos_segreinit],dx
  2509                                  
  2510 000005B4 2EA3[8102]              	mov	[cs:hi_doscod_size],ax	; size of doscode (including exepatch)
  2511 000005B8 2E890E[7F02]            	mov	[cs:lo_doscod_size],cx	; (not including exepatch)
  2512 000005BD 2E8916[7B02]            	mov	[cs:dos_segreinit],dx	; save offset of segreinit
  2513                                  
  2514                                  	; 05/06/2018 - Retro DOS v3.0
  2515                                  	; ES:DI = Address of pointer to SYSINITVARS structure (MSDOS 3.3)
  2516                                  
  2517                                  	; 22/10/2022
  2518                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars] ; 5/29/86
  2519 000005C2 268B05                  	mov	ax,[es:di] ; 22/03/2019
  2520 000005C5 2EA3[6B02]              	mov	[cs:DOSINFO],ax
  2521                                  	;mov	[DOSINFO],ax
  2522                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars+2]
  2523 000005C9 268B4502                	mov	ax,[es:di+2]
  2524 000005CD 2EA3[6D02]              	mov	[cs:DOSINFO+2],ax
  2525                                  	;mov	[DOSINFO+2],ax	; set the sysvar pointer
  2526                                  
  2527                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab]
  2528 000005D1 268B4504                	mov	ax,[es:di+4]
  2529 000005D5 2EA3[7702]              	mov	[cs:sysi_country],ax
  2530                                  	;mov	[sysi_country],ax
  2531                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
  2532 000005D9 268B4506                	mov	ax,[es:di+6]
  2533 000005DD 2EA3[7902]              	mov	[cs:sysi_country+2],ax
  2534                                  	;mov	[sysi_country+2],ax	; set the SYSI_Country pointer
  2535                                  
  2536                                  	; 20/04/2019
  2537                                  	;mov	ax,[CURRENT_DOS_LOCATION]
  2538                                  	;;mov	es,[CURRENT_DOS_LOCATION]
  2539                                  	;mov	ax,[FINAL_DOS_LOCATION] ; give dos its temporary location
  2540                                  	; 22/10/2022
  2541                                  	;mov	ax,[cs:CURRENT_DOS_LOCATION]
  2542                                  	;;;mov	[dos_segreinit+2],es
  2543                                  	;;mov	[dos_segreinit+2],ax
  2544                                  	;mov	[cs:dos_segreinit+2],ax
  2545                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  2546 000005E1 2E8E06[7102]            	mov	es,[cs:CURRENT_DOS_LOCATION]
  2547 000005E6 2E8C06[7D02]            	mov	[cs:dos_segreinit+2],es
  2548                                  
  2549                                  ; ----------------------------------------------------------------------------
  2550                                  
  2551                                  ;SYSINIT:0577h:
  2552                                  	; ... RPLArena ... MSDOS 6.21 IO.SYS (SYSINIT:0577h to SYSINIT:05D1h)
  2553                                  ;SYSINIT:05D1h:	; NoPRLArena 
  2554                                  
  2555                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
  2556                                  ;------ Cover up RPL code with an arena
  2557                                  ;SYSINIT:05EBh:
  2558 000005EB 2E833E[9402]00          	cmp	word [cs:RPLMemTop],0
  2559 000005F1 7452                    	je	short NoRPLArena
  2560                                  
  2561                                  ;------ alloc all memory
  2562                                  
  2563 000005F3 BBFFFF                  	mov	bx,0FFFFh
  2564 000005F6 B448                    	mov	ah,48h
  2565 000005F8 CD21                    	int	21h
  2566                                  			; DOS - 2+ - ALLOCATE MEMORY
  2567                                  			; BX = number of 16-byte paragraphs desired
  2568 000005FA B448                    	mov	ah,48h
  2569 000005FC CD21                    	int	21h
  2570                                  
  2571 000005FE 8EC0                    	mov	es,ax			; get it into ES and save it
  2572 00000600 06                      	push	es
  2573                                  
  2574                                  ;------ resize upto RPL mem
  2575                                  
  2576 00000601 2E2B06[9402]            	sub	ax,[cs:RPLMemTop]
  2577 00000606 F7D8                    	neg	ax
  2578 00000608 48                      	dec	ax
  2579 00000609 89C3                    	mov	bx,ax
  2580 0000060B B44A                    	mov	ah,4Ah
  2581 0000060D CD21                    	int	21h
  2582                                    			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2583                                  			; ES = segment address of block to change
  2584                                  			; BX = new size in paragraphs
  2585                                  
  2586                                  ;------ allocate the free (RPL MEM)
  2587                                  
  2588 0000060F BBFFFF                  	mov	bx,0FFFFh
  2589 00000612 B448                    	mov	ah,48h
  2590 00000614 CD21                    	int	21h
  2591 00000616 B448                    	mov	ah,48h
  2592 00000618 CD21                    	int	21h
  2593                                  
  2594                                  ;----- mark that it belongs to RPL
  2595                                  
  2596 0000061A 48                      	dec	ax
  2597 0000061B 8EC0                    	mov	es,ax
  2598                                  	;mov	word [es:arena_owner],8
  2599 0000061D 26C70601000800          	mov	word [es:1],8
  2600                                  	;mov	word [es:arena_name],'RP'
  2601 00000624 26C70608005250          	mov	word [es:8],'RP'
  2602                                  	;mov	word [es:arena_name+2], 'L'
  2603 0000062B 26C7060A004C00          	mov	word [es:10],'L'
  2604                                  	;mov	word [es:arena_name+4], 0
  2605 00000632 26C7060C000000          	mov	word [es:12], 0
  2606                                  	;mov	word [es:arena_name+6], 0
  2607 00000639 26C7060E000000          	mov	word [es:14], 0	
  2608                                  
  2609 00000640 07                              pop     es                      ; get back ptr to first block
  2610 00000641 B449                            mov     ah, 49h	; Dealloc	; and free it
  2611 00000643 CD21                    	int	21h		
  2612                                  					; DOS - 2+ - FREE MEMORY
  2613                                  					; ES = segment address of area to be freed
  2614                                  
  2615                                  ; ----------------------------------------------------------------------------
  2616                                  
  2617                                  NoRPLArena:
  2618                                  
  2619                                  	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21, IO.SYS)
  2620                                  	;les	di,[DOSINFO]	; es:di -> dosinfo
  2621                                  	; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
  2622 00000645 2EC43E[6B02]            	les	di,[cs:DOSINFO]	; es:di -> dosinfo
  2623                                  
  2624 0000064A F8                      	clc				; get the extended memory size
  2625                                  
  2626                                  ;	execute the get extended memory size subfunction in the bios int 15h
  2627                                  ;	if the function reports an error do nothing else store the extended
  2628                                  ;	memory size reported at the appropriate location in the dosinfo buffer
  2629                                  ;	currently pointed to by es:di. use the offsets specified in the
  2630                                  ;	definition of the sysinitvars struct in inc\sysvar.inc
  2631                                  
  2632 0000064B B488                    	mov	ah,88h
  2633 0000064D CD15                    	int	15h			; check extended memory size
  2634 0000064F 720B                    	jc	short no_ext_memory
  2635                                  			; Get Extended Memory Size
  2636                                  			; Return: CF clear on success
  2637                                  			; AX = size of memory above 1M in K	
  2638                                  	;mov	[es:di+SYSI_EXT_MEM],ax ; save extended memory size
  2639                                  	; 22/10/2022
  2640 00000651 26894545                	mov	[es:di+45h],ax ; save extended memory size
  2641 00000655 09C0                    	or	ax,ax
  2642 00000657 7403                    	jz	short no_ext_memory
  2643 00000659 E84205                  	call	ClrVDISKHeader
  2644                                  no_ext_memory:
  2645                                  	;mov	ax,[es:di+SYSI_MAXSEC]	; get the sector size
  2646 0000065C 268B4510                	mov	ax,[es:di+10h]
  2647                                  	;add	ax,bufinsiz
  2648 00000660 83C014                  	add	ax,20			; size of buffer header
  2649                                  	;mov	[singlebuffersize],ax	; total size for a buffer
  2650 00000663 2EA3[9B02]              	mov	[cs:singlebuffersize],ax	
  2651                                  
  2652                                  	;mov	al,[DEFAULT_DRIVE]	; get the 1 based boot drive number set by msinit
  2653 00000667 2EA0[9602]              	mov	al,[cs:DEFAULT_DRIVE]
  2654                                  	;mov	[es:di+SYSI_BOOT_DRIVE],al ; set sysi_boot_drive
  2655 0000066B 26884543                	mov	[es:di+43h],al
  2656                                  
  2657                                  ; determine if 386 system...
  2658                                  
  2659                                  	;get_cpu_type			; macro to determine cpu type
  2660                                  
  2661                                  get_cpu_type:
  2662 0000066F 9C                      	pushf
  2663 00000670 53                      	push    bx
  2664 00000671 31DB                    	xor     bx,bx
  2665 00000673 31C0                    	xor     ax,ax
  2666 00000675 50                      	push    ax
  2667 00000676 9D                      	popf
  2668 00000677 9C                      	pushf
  2669 00000678 58                      	pop     ax
  2670 00000679 2500F0                  	and     ax,0F000h
  2671 0000067C 3D00F0                  	cmp     ax,0F000h
  2672 0000067F 740E                    	je      short cpu_8086
  2673 00000681 B800F0                  	mov     ax,0F000h
  2674 00000684 50                      	push    ax
  2675 00000685 9D                      	popf
  2676 00000686 9C                      	pushf
  2677 00000687 58                      	pop     ax
  2678 00000688 2500F0                  	and     ax,0F000h
  2679 0000068B 7401                    	jz      short cpu_286
  2680                                  cpu_386:
  2681 0000068D 43                      	inc     bx
  2682                                  cpu_286:
  2683 0000068E 43                      	inc     bx
  2684                                  cpu_8086:
  2685 0000068F 89D8                    	mov     ax,bx
  2686 00000691 5B                      	pop     bx
  2687 00000692 9D                      	popf
  2688                                  
  2689                                  	;...
  2690                                  
  2691 00000693 83F802                  	cmp	ax,2			; is it a 386?
  2692 00000696 7505                    	jne	short not_386_system	; no: don't mess with flag
  2693                                  	;mov	byte [es:di+SYSI_DWMOVE],1
  2694                                  	; 22/10/2022
  2695 00000698 26C6454401              	mov	byte [es:di+44h],1
  2696                                  not_386_system:
  2697                                  	;mov	al,[es:di+SYSI_NUMIO]
  2698 0000069D 268A4520                	mov	al,[es:di+20h]
  2699                                  	;mov	[drivenumber],al	; save start of installable block drvs
  2700 000006A1 2EA2[FC03]              	mov	[cs:drivenumber],al
  2701                                  
  2702 000006A5 8CC8                    	mov	ax,cs
  2703 000006A7 83E811                  	sub	ax,11h			; room for PSP we will copy shortly
  2704                                  	;mov	cx,[singlebuffersize]	; temporary single buffer area
  2705 000006AA 2E8B0E[9B02]            	mov	cx, [cs:singlebuffersize]
  2706 000006AF D1E9                    	shr	cx,1			
  2707 000006B1 D1E9                    	shr	cx,1			; divide size by 16...
  2708 000006B3 D1E9                    	shr	cx,1
  2709 000006B5 D1E9                    	shr	cx,1			; ...to get paragraphs...
  2710 000006B7 41                      	inc	cx			; ... and round up
  2711                                  
  2712                                  ;	cas note: this unorthodox paragraph rounding scheme wastes a byte if
  2713                                  ;	  [singlebuffersize] ever happens to be zero mod 16. Could this
  2714                                  ;	  ever happen? Only if the buffer overhead was zero mod 16, since
  2715                                  ;	  it is probably safe to assume that the sector size always will be.
  2716                                  ;
  2717                                  ;	 mohans also found a bug in CONFIG.SYS processing where it replaces
  2718                                  ;	  EOF's with cr,lf's, without checking for collision with [confbot].
  2719                                  ;	  perhaps the extra byte this code guarantees is what has kept that
  2720                                  ;	  other code from ever causing a problem???
  2721                                  
  2722 000006B8 29C8                    	sub	ax,cx
  2723                                  	;mov	[top_of_cdss],ax	; temp "unsafe" location
  2724                                  	; 22/10/2022
  2725 000006BA 2EA3[A102]              	mov	[cs:top_of_cdss],ax
  2726                                  
  2727                                  ;	chuckst -- 25 Jul 92 -- added code here to pre-allocate space
  2728                                  ;	for 26 temporary CDSs, which makes it easier to use alloclim
  2729                                  ;	for allocating memory for MagicDrv.
  2730                                  
  2731 000006BE 06                      	push	es			; preserve pointer to dosinfo
  2732 000006BF 57                      	push	di
  2733                                  
  2734                                  	; 22/10/2022
  2735                                  ;	mov	cx,ax			; save pointer for buffer
  2736                                  ;
  2737                                  ;;	now allocate space for 26 CDSs
  2738                                  ;
  2739                                  ;	sub	ax,((26 *(curdirlen))+15)/16
  2740                                  ;	mov	[ALLOCLIM],ax		; init top of free memory pointer
  2741                                  ;	mov	[CONFBOT],ax		; init this in case no CONFIG.SYS
  2742                                  
  2743                                  ; setup and initialize the temporary buffer at cx
  2744                                  
  2745                                  	;les	di,[es:di+SYSI_BUF]	; get the buffer chain entry pointer
  2746 000006C0 26C47D12                	les	di,[es:di+12h]
  2747                                  	;xor	ax,ax
  2748                                  	;mov	[es:di+BUFFINF.Dirty_Buff_Count],ax ; 0
  2749 000006C4 26C745040000            	mov	word [es:di+4],0
  2750                                  	;mov	[es:di+BUFFINF.Buff_Queue],ax ; 0
  2751 000006CA 26C7050000              	mov	word [es:di],0
  2752                                  	;mov	[es:di+BUFFINF.Buff_Queue+2],cx
  2753 000006CF 26894502                	mov	[es:di+2],ax
  2754                                  
  2755                                  	;mov	es,cx
  2756 000006D3 8EC0                    	mov	es,ax
  2757                                  
  2758 000006D5 31C0                    	xor	ax,ax
  2759 000006D7 89C7                    	mov	di,ax			; es:di -> single buffer
  2760                                  
  2761                                  	;mov	[es:di+buffinfo.buf_next],ax ; points to itself
  2762 000006D9 268905                  	mov	[es:di],ax
  2763                                  	;mov	[es:di+buffinfo.buf_prev],ax ; points to itself
  2764 000006DC 26894502                	mov	[es:di+2],ax
  2765                                  
  2766                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS SYINIT)
  2767                                  	; MSDOS 5.0 IO.SYS - SYSINIT:06E0h
  2768                                  
  2769                                  	;mov	word [es:di+buffinfo.buf_ID],00FFh ; free buffer,clear flag
  2770 000006E0 26C74504FF00            	mov	word [es:di+4],00FFh
  2771                                  ;SYSINIT:06E6h
  2772                                  	;mov	[es:di+buffinfo.buf_sector],ax ; 0
  2773 000006E6 26C745060000            	mov	word [es:di+6],0
  2774                                  	;mov	[es:di+buffinfo.buf_sector+2],ax ; 0
  2775 000006EC 26C745080000            	mov	word [es:di+8],0
  2776                                  
  2777 000006F2 5F                      	pop	di			; restore pointer to DOSINFO data
  2778 000006F3 07                      	pop	es
  2779                                  
  2780                                  	; 22/10/2022
  2781 000006F4 0E                      	push	cs
  2782 000006F5 1F                      	pop	ds
  2783                                  
  2784 000006F6 E83C05                  	call	TempCDS 		; set up cdss so re_init and sysinit
  2785                                  					;   can make disk system calls
  2786                                  					; tempcds trashes ds
  2787                                  	; 10/05/2019
  2788 000006F9 2E8E1E[8302]            	mov	ds,[cs:def_php]		; retrieve pointer to PSP returned by DOSINIT
  2789                                  
  2790                                  	;if not ibmjapver
  2791                                  	;call	far KERNEL_SEGMENT:re_init ; re-call the bios
  2792                                  	;endif
  2793                                  
  2794                                  	; 22/10/2022
  2795                                  ;SYSINIT:06FEh:	; (MSDOS 5.0 IO.SYS, SYSINIT)
  2796                                  	;call	far ptr 70h:89Bh
  2797 000006FE 9A9B087000              	call	DOSBIODATASEG:RE_INIT
  2798                                  
  2799 00000703 FB                      	sti				; ints ok
  2800 00000704 FC                      	cld				; make sure
  2801                                  
  2802                                  ; 23/03/2019
  2803                                  
  2804                                  ;SYSINIT:069Ch
  2805                                  
  2806                                  ; dosinit has set up a default "process" (php) at ds:0. we will move it out
  2807                                  ; of the way by putting it just below sysinit at end of memory.
  2808                                  
  2809 00000705 8CCB                    	mov	bx,cs
  2810 00000707 83EB10                  	sub	bx,10h
  2811 0000070A 8EC3                    	mov	es,bx
  2812 0000070C 31F6                    	xor	si,si
  2813 0000070E 89F7                    	mov	di,si
  2814 00000710 B98000                  	mov	cx,128
  2815 00000713 F3A5                    	rep	movsw
  2816                                  
  2817                                  	;mov	[es:PDB.JFN_POINTER+2],es ; Relocate
  2818                                  	; 22/10/2022
  2819 00000715 268C063600              	mov	[es:36h],es
  2820                                  
  2821                                   	; Set Process Data Block - Program Segment Prefix address
  2822                                  	; BX = PDB/PSP segment
  2823 0000071A B450                            mov	ah,50h ; SET_CURRENT_PDB
  2824 0000071C CD21                    	int	21h			; tell DOS we moved it
  2825                                  			; DOS - 2+ internal - SET PSP SEGMENT
  2826                                  			; BX = segment address of new PSP
  2827                                  	; 22/10/2022
  2828                                  	; 27/03/2019
  2829 0000071E 1E                      	push	ds ; */			; preserve DS returned by DOSINIT
  2830                                  
  2831 0000071F 0E                      	push	cs	
  2832 00000720 1F                      	pop	ds
  2833                                  
  2834                                  	; set up temp. critical error handler
  2835 00000721 BA[8937]                	mov	dx,int24		; set up int 24 handler
  2836                                  	;;mov	ax,(SET_INTERRUPT_VECTOR*256)+24h
  2837                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)|24h
  2838 00000724 B82425                  	mov	ax,2524h
  2839 00000727 CD21                    	int	21h
  2840                                  
  2841 00000729 803E[FF03]00                    cmp     byte [toomanydrivesflag],0 ; Q: >24 partitions?      M029
  2842 0000072E 7406                            je      short no_err		   ;  N: continue            M029
  2843 00000730 BA[E03C]                        mov     dx,TooManyDrivesMsg	   ;  Y: print error message M029
  2844                                          ; 22/10/2022
  2845 00000733 E82930                  	call	print 			   ;		             M029
  2846                                  	;jmp	short p_dosinit_msg ; 23/03/2019 - Retro DOS v4.0                    
  2847                                  no_err:
  2848                                  	; 12/05/2019
  2849                                  	;----------------------------------------------
  2850                                  	; 27/06/2018 - Retro DOS v3.0	; 23/03/2019 - Retro DOS v4.0
  2851                                  	; 22/10/2022 - Retro DOS v4.0
  2852                                  	;mov	dx,BOOTMES		; Display (fake) MSDOS version message
  2853                                  ;p_dosinit_msg:
  2854                                  	;call	print			; Print message
  2855                                  	;----------------------------------------------
  2856                                  	
  2857                                  	; 22/10/2022
  2858                                  	; 23/03/2019 - Retro DOS v4.0
  2859 00000736 1F                      	pop	ds			; start of free memory
  2860 00000737 2E8A16[9602]            	mov	dl,[cs:DEFAULT_DRIVE]
  2861                                  	
  2862                                  	; 27/03/2019
  2863                                  	;mov	dl,[DEFAULT_DRIVE]	
  2864                                  	;pop	ds ; */
  2865                                  
  2866 0000073C 08D2                    	or	dl,dl
  2867                                  	;jz	short nodrvset		; bios didn't say
  2868 0000073E 7406                    	jz	short ProcessConfig  ; (Retro DOS v4.0 does not contain DBLSPACE code)
  2869 00000740 FECA                    	dec	dl			; A = 0
  2870 00000742 B40E                    	mov	ah, 0Eh ; SET_DEFAULT_DRIVE
  2871 00000744 CD21                    	int	21h			; select the disk
  2872                                  			; DOS - SELECT DISK
  2873                                  			; DL = new default drive number (0 = A, 1 = B, etc.)
  2874                                  			; Return: AL = number of logical drives
  2875                                  nodrvset:
  2876                                  	;ifdef	dblspace_hooks
  2877                                  	;	....
  2878                                  	;	....
  2879                                  	;endif	
  2880                                  
  2881                                  ; MSDOS 6.21 IO.SYS, SYSINIT:0744h
  2882                                  
  2883                                  ; 23/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
  2884                                  ; ----------------------------------------------------------------------------
  2885                                  ; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
  2886                                  
  2887                                  ProcessConfig:
  2888                                  	; ds = cs ; 27/03/2019	
  2889                                  
  2890                                  ; (MSDOS 5.0 IO.SYS - SYSINIT:0746h)
  2891                                  
  2892 00000746 E8151A                  	call	doconf			; do pre-scan for dos=high/low
  2893                                  
  2894                                  	; 27/03/2019
  2895                                  	; ds = cs (at return from doconf)
  2896                                  
  2897                                  ; Now, if this is not romdos, we decide what to do with the DOS code.
  2898                                  ; It will either be relocated to low memory, above the DOS data structures,
  2899                                  ; or else it will be located in HiMem, in which case a stub with the DOS
  2900                                  ; code entry points will be located in low memory. Dos_segreinit is used
  2901                                  ; to tell the DOS data where the code has been placed, and to install the
  2902                                  ; low memory stub if necessary. If the DOS is going to go into HiMem, we
  2903                                  ; must first initialize it in its present location and load the installable
  2904                                  ; device drivers. Then, if a HiMem driver has been located, we can actually
  2905                                  ; relocate the DOS code into HiMem.
  2906                                  ;
  2907                                  ; For ROMDOS, if DOS=HIGH is indicated, then we need to call dos_segreinit
  2908                                  ; to install the low memory stub (this must be done before allowing any
  2909                                  ; device drivers to hook interrupt vectors). Otherwise, we don't need to 
  2910                                  ; call dos_segreinit at all, since the interrupt vector table has already 
  2911                                  ; been patched.
  2912                                  
  2913                                  	; 22/10/2022 - Retro DOS v4.0
  2914                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:0749h)
  2915 00000749 2E803E[6A02]00          	cmp	byte [cs:runhigh],0	; Did user choose to run low ?
  2916                                  	;cmp	byte [runhigh],0
  2917 0000074F 740E                    	je	short dont_install_stub	; yes, don't install dos low mem stub
  2918                                  
  2919                                  ;------ user chose to load high
  2920                                  
  2921                                  	; 22/10/2022
  2922 00000751 2E8E06[7102]            	mov	es,[cs:CURRENT_DOS_LOCATION] ; MSDOS 6.21 (& MSDOS 6.0) 
  2923                                  	;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
  2924                                  	; 27/03/2019
  2925                                  	;;mov	es,[FINAL_DOS_LOCATION]
  2926                                  
  2927 00000756 31C0                    	xor	ax,ax			; ax = 0 ---> install stub
  2928 00000758 2EFF1E[7B02]            	call	far [cs:dos_segreinit]	; call dos segreinit
  2929                                  	;call	far [dos_segreinit]
  2930                                  
  2931 0000075D EB12                    	jmp	short do_multi_pass
  2932                                  
  2933                                  ;------ User chose to load dos low
  2934                                  
  2935                                  dont_install_stub:
  2936                                  	; 22/10/2022
  2937 0000075F 31DB                    	xor	bx,bx			; M012
  2938                                  					; don't use int 21 call to alloc mem
  2939 00000761 E8F901                  	call	MovDOSLo		; move it !
  2940                                  
  2941 00000764 B80100                  	mov	ax,1			; dont install stub
  2942 00000767 2E8E06[7102]            	mov	es,[cs:CURRENT_DOS_LOCATION] ; set_dos_final_position set it up
  2943                                  	;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
  2944                                  	; 27/03/2019
  2945                                  ;do_multi_pass:
  2946                                  	;mov	es,[FINAL_DOS_LOCATION] 
  2947                                  
  2948 0000076C 2EFF1E[7B02]            	call	far [cs:dos_segreinit]	; inform dos about new seg
  2949                                  	;call	far [dos_segreinit]
  2950                                  do_multi_pass:
  2951 00000771 E82701                  	call	AllocFreeMem		; allocate all the free mem
  2952                                  					; & update [memhi] & [area]
  2953                                  					; start of free memory.
  2954                                  	;ifdef	dblspace_hooks
  2955                                  	;mov	bx,0			; magic backdoor to place int hooks
  2956                                  	;call	cs:MagicBackdoor
  2957                                  	;endif
  2958                                  
  2959                                  ; Now, process config.sys some more.  
  2960                                  ; Load the device drivers and install programs
  2961                                  
  2962                                  	; 22/10/2022
  2963 00000774 2EFE06[4903]            	inc	byte [cs:multi_pass_id]	; multi_pass_id = 1
  2964                                  	;inc	byte [multi_pass_id]
  2965 00000779 E8761A                  	call	multi_pass		; load device drivers
  2966 0000077C E87A28                  	call	ShrinkUMB
  2967 0000077F E8A428                  	call	UnlinkUMB		; unlink all UMBs	;M002
  2968                                  	; 02/11/2022
  2969 00000782 2EFE06[4903]            	inc	byte [cs:multi_pass_id]	; multi_pass_id = 2
  2970                                  	;inc	byte [multi_pass_id]
  2971 00000787 E8681A                  	call	multi_pass		; was load ifs (now does nothing)
  2972                                  
  2973                                  	;ifdef	dblspace_hooks
  2974                                  	;call	MagicPostload		; make sure Magicdrv is final placed
  2975                                  	;endif
  2976                                  
  2977                                  	; ds = cs
  2978                                  	
  2979 0000078A E84005                  	call	endfile			; setup fcbs, files, buffers etc
  2980                                  
  2981                                  	;ifdef	dblspace_hooks
  2982                                  	;call	MagicSetCdss		; disable CDSs of reserved drives
  2983                                  	;endif
  2984                                  
  2985                                  ;Reset SysinitPresent flag here. This is needed for the special fix for lying
  2986                                  ;to device drivers. This has been moved up to this point to avoid problems 
  2987                                  ;with overlays called from installed programs
  2988                                  
  2989                                  	;;mov	ax,Bios_Data ; 0070h
  2990                                  	;mov	ax,KERNEL_SEGMENT
  2991                                  	; 21/10/2022
  2992 0000078D B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  2993 00000790 8EC0                    	mov	es,ax			; point ES to bios data
  2994                                  
  2995 00000792 26C606FD0800            	mov	byte [es:SysinitPresent],0 ; clear SysinitPresent flag
  2996                                  
  2997                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  2998 00000798 2EF706[4A03]0100        	test	word [cs:install_flag],have_install_cmd ; 1
  2999                                  	;;test	byte [cs:install_flag], 1
  3000                                  	;test	byte [cs:install_flag],have_install_cmd
  3001                                  					; are there install commands?
  3002 0000079F 7408                    	jz	short dolast		; no, no need for further processing
  3003 000007A1 2EFE06[4903]            	inc	byte [cs:multi_pass_id]	; mult_pass_id = 3
  3004                                  	;inc	byte [multi_pass_id]
  3005 000007A6 E8491A                  	call	multi_pass		; execute install= commands
  3006                                  
  3007                                  dolast:
  3008                                  	
  3009                                  ; [area] has the segment address for the allocated memory of sysinit, confbot.
  3010                                  ;  free the confbot area used for config.sys and sysinit itself.
  3011                                  
  3012                                  ; Now if DOS is supposed to run high, we actually move it into high memory 
  3013                                  ; (if HiMem manager is available). For ROMDOS, we don't actually move
  3014                                  ; anything, but just set up the ROM area for suballocation (or print
  3015                                  ; a message if HiMem is not available).
  3016                                  ;
  3017                                  ; There is also this little hack for CPM style DOS calls that needs to
  3018                                  ; be done when A20 is set...
  3019                                  
  3020                                  	; 22/10/2022
  3021 000007A9 2E803E[6A02]FF          	cmp	byte [cs:runhigh],0FFh	; are we still waiting to be moved?
  3022                                  	;cmp	byte [runhigh],0FFh
  3023 000007AF 7503                    	jne	short _@@		; no, our job is over
  3024 000007B1 E84E01                  	call	LoadDOSHiOrLo
  3025                                  _@@:
  3026 000007B4 2E803E[6A02]00          	cmp	byte [cs:runhigh],0	; are we running low
  3027                                  	;cmp	byte [runhigh],0
  3028                                  	;je	short _@@@
  3029 000007BA 7403                    	je	short ConfigDone	; yes, no CPM hack needed
  3030 000007BC E85504                  	call	CPMHack			; make ffff:d0 same as 0:c0
  3031                                  _@@@:
  3032                                  
  3033                                  ; We are now done with CONFIG.SYS processing
  3034                                  
  3035                                  ConfigDone:
  3036                                  	; 22/10/2022
  3037 000007BF 2EC606[D103]01          	mov	byte [cs:donotshownum],1 
  3038                                  					; done with config.sys.
  3039                                  					; do not show line number message.
  3040 000007C5 2E8E06[E403]            	mov	es,[cs:area]
  3041                                  	; 27/03/2019
  3042                                  	; ds = cs
  3043                                  	;mov	byte [donotshownum],1
  3044                                  	;mov	es,[area]
  3045                                  
  3046 000007CA B449                            mov     ah, 49h ; DEALLOC	; free allocated memory for command.com
  3047 000007CC CD21                    	int	21h
  3048                                  			; DOS - 2+ - FREE MEMORY
  3049                                  			; ES = segment address of area to be freed
  3050                                  
  3051                                  	; 22/10/2022
  3052                                  	;test	word [cs:install_flag],2
  3053 000007CE 2EF706[4A03]0200        	test	word [cs:install_flag],has_installed ; sysinit_base installed?
  3054                                  	;test	byte [cs:install_flag],has_installed
  3055                                  	;test	byte [install_flag],has_installed
  3056 000007D5 7425                    	jz	short skip_free_sysinitbase ; no.
  3057                                  
  3058                                  ; set block from the old_area with impossible_owner_size.
  3059                                  ; this will free the unnecessary sysinit_base that had been put in memory to
  3060                                  ; handle install= command.
  3061                                  
  3062 000007D7 06                              push    es                      ; BUGBUG 3-30-92 JeffPar: no reason to save ES
  3063 000007D8 53                      	push	bx
  3064                                  	; 22/10/2022
  3065 000007D9 2E8E06[DA03]            	mov	es,[cs:old_area]
  3066 000007DE 2E8B1E[DC03]            	mov	bx,[cs:impossible_owner_size]
  3067                                  	;mov	es,[old_area]
  3068                                  	;mov	bx,[impossible_owner_size]
  3069 000007E3 B44A                    	mov	ah, 4Ah ; SETBLOCK
  3070 000007E5 CD21                    	int	21h
  3071                                  			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3072                                  			; ES = segment address of block to change
  3073                                  			; BX = new size in paragraphs
  3074 000007E7 8CC0                    	mov	ax,es
  3075 000007E9 48                      	dec	ax
  3076 000007EA 8EC0                    	mov	es,ax			; point to arena
  3077                                  	;mov	word [es:ARENA.OWNER],8	; set impossible owner
  3078 000007EC 26C70601000800          	mov	word [es:1],8
  3079                                  	;mov	word [es:ARENA.NAME],'SD' ; 4453h ; System Data
  3080 000007F3 26C70608005344          	mov	word [es:8], 'SD'
  3081 000007FA 5B                      	pop	bx
  3082 000007FB 07                              pop     es                      ; BUGBUG 3-30-92 JeffPar: no reason to save ES
  3083                                  
  3084                                  skip_free_sysinitbase:
  3085                                  	; 22/10/2022
  3086 000007FC 2E803E[6A02]00          	cmp	byte [cs:runhigh],0
  3087                                  	;cmp	byte [runhigh],0	
  3088 00000802 7403                    	je	short _@@@@
  3089 00000804 E8ED02                  	call	InstVDiskHeader		; Install VDISK header (allocates some mem from DOS)
  3090                                  
  3091                                  ; ----------------------------------------------------------------------------
  3092                                  
  3093                                  _@@@@:
  3094                                  	; 22/10/2022
  3095                                  	; 27/03/2019
  3096 00000807 0E                      	push	cs
  3097 00000808 1F                      	pop	ds			; point DS to sysinitseg
  3098                                  
  3099                                  ; set up the parameters for command
  3100                                  
  3101                                  	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
  3102                                  ;;ifdef  MULTI_CONFIG
  3103                                  ;	mov	byte [config_cmd],0	; set special code for query_user
  3104                                  ;       call    query_user		; to issue the AUTOEXEC prompt
  3105                                  ;	jnc	short process_autoexec	; we should process autoexec normally
  3106                                  ;	; !!!
  3107                                  ;	or	byte [bQueryOpt],4 ; MSDOS 6.21 IO.SYS - SYSINIT:081Fh
  3108                                  ;       ; !!!
  3109                                  ;	call    disable_autoexec        ; no, we should disable it
  3110                                  ;process_autoexec:
  3111                                  ;;endif	; !!!
  3112                                  ;	call	CheckQueryOpt	; MSDOS 6.21 IO.SYS - SYSINIT:0827h	
  3113                                  ;	; !!!
  3114                                  
  3115                                  	; 22/10/2022 
  3116                                  	;mov     cl,[command_line]
  3117                                          ;mov     ch,0
  3118                                          ;inc     cx
  3119                                          ;mov     si,command_line	
  3120                                  	;add     si,cx
  3121                                          ;mov     byte [si],cr	; cr-terminate command line
  3122                                  
  3123                                  	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
  3124                                  	; (SYSINIT:0809h)
  3125                                  	
  3126                                  	;mov	si, (offset command_line+1)
  3127 00000809 BE[AA02]                	mov	si, command_line+1
  3128 0000080C 1E                      	push    ds
  3129 0000080D 07                      	pop     es
  3130 0000080E 89F7                    	mov     di, si
  3131 00000810 B1FF                    	mov     cl, 0FFh ; -1
  3132                                  _@_loop:                                  ; CODE XREF: seg000:0818j
  3133 00000812 FEC1                    	inc     cl ; +1
  3134 00000814 AC                      	lodsb
  3135 00000815 AA                      	stosb
  3136 00000816 08C0                    	or      al, al
  3137 00000818 75F8                    	jnz     short _@_loop
  3138 0000081A 4F                      	dec     di
  3139 0000081B B00D                    	mov     al, 0Dh
  3140 0000081D AA                      	stosb			; cr-terminate command line
  3141 0000081E 880E[A902]              	mov     [command_line], cl ; command line length (except CR)
  3142                                  
  3143                                  ; ----------------------------------------------------------------------------
  3144                                  
  3145                                  ;   Once we get to this point, the above code, which is below "retry"
  3146                                  ;   in memory, can be trashed (and in fact is -- see references to retry
  3147                                  ;   which follow....)
  3148                                  
  3149                                  retry:
  3150 00000822 BA[6D38]                	mov	dx,commnd	; now pointing to file description
  3151                                  
  3152                                  ; we are going to open the command interpreter and size it as is done in
  3153                                  ; ldfil. the reason we must do this is that sysinit is in free memory. if
  3154                                  ; there is not enough room for the command interpreter,exec will probably
  3155                                  ; overlay our stack and code so when it returns with an error sysinit won't be
  3156                                  ; here to catch it. this code is not perfect (for instance .exe command
  3157                                  ; interpreters are possible) because it does its sizing based on the
  3158                                  ; assumption that the file being loaded is a .com file. it is close enough to
  3159                                  ; correctness to be usable.
  3160                                  
  3161                                  ; first, find out where the command interpreter is going to go.
  3162                                  
  3163 00000825 52                      	push	dx		; save pointer to name
  3164 00000826 BBFFFF                  	mov	bx,0FFFFh
  3165 00000829 B448                    	mov	ah,48h	; ALLOC
  3166 0000082B CD21                            int     21h             ; get biggest piece
  3167 0000082D B448                    	mov	ah,48h	; ALLOC
  3168 0000082F CD21                    	int	21h		; second time gets it
  3169 00000831 7243                    	jc	short memerrjx	; oooops
  3170                                  
  3171 00000833 8EC0                    	mov	es,ax
  3172 00000835 B449                    	mov	ah,49h	; DEALLOC
  3173 00000837 CD21                    	int	21h		; give it right back
  3174 00000839 89DD                    	mov	bp,bx
  3175                                  
  3176                                  ; es:0 points to block,and bp is the size of the block in para.
  3177                                  
  3178                                  ; we will now adjust the size in bp down by the size of sysinit.
  3179                                  ; we need to do this because exec might get upset if some of the exec
  3180                                  ; data in sysinit is overlayed during the exec.
  3181                                  
  3182                                  	; 22/10/2022
  3183                                  	; (MSDOS 5.0 IO.SYS SYSINIT:083Bh)
  3184 0000083B 8B1E[9202]                      mov     bx,[MEMORY_SIZE] ; get location of end of memory
  3185 0000083F 8CC8                    	mov	ax,cs		 ; get location of beginning of sysinit
  3186                                  
  3187                                  ; Note that the "config_wrkseg" environment data is a segment in
  3188                                  ; unallocated memory (as of the Dealloc of [area], above). This is ideal
  3189                                  ; in one sense, because Exec is going to make a copy of it for COMMAND.COM
  3190                                  ; anyway, and no one has responsibility for freeing "config_wrkseg". But
  3191                                  ; we need to make sure that there's no way Exec will stomp on that data
  3192                                  ; before it can copy it, and one way to do that is to make the available
  3193                                  ; memory calculation even more "paranoid", by subtracting "config_wrkseg"
  3194                                  ; from the "memory_size" segment value (which is typically A000h) instead
  3195                                  ; of the current sysinit CS....
  3196                                  ;
  3197                                  ; The reason I use the term "paranoid" is because this code should have
  3198                                  ; slid the data required by Exec up to the very top of memory, because as
  3199                                  ; it stands, you have to have sizeof(COMMAND.COM) PLUS 64K to load just
  3200                                  ; COMMAND.COM (64k is about what sysinit, and all the goop above sysinit,
  3201                                  ; consumes). Now it's just a little worse (65K or more, depending on
  3202                                  ; the size of your CONFIG.SYS, since the size of the environment workspace
  3203                                  ; is determined by the size of CONFIG.SYS.... -JTP
  3204                                  
  3205                                  	; 22/10/2022
  3206                                  	;mov	cx,[config_envlen]
  3207                                          ;jcxz	no_env		; use config_wrkseg only if there's env data
  3208                                          ;mov	ax,[config_wrkseg]
  3209                                  ;no_env:
  3210                                  	; 22/10/2022
  3211                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0841h)
  3212 00000841 29C3                      	sub     bx,ax           ; bx is size of sysinit in para
  3213 00000843 83C311                  	add	bx,11h		; add the sysinit php
  3214 00000846 29DD                    	sub	bp,bx		; sub sysinit size from amount of free memory
  3215 00000848 722C                    	jc	short memerrjx	; if there isn't even this much memory, give up
  3216                                  
  3217                                          ;mov	ax,(OPEN<<8)	; open the file being execed
  3218 0000084A B8003D                          mov	ax,3D00h
  3219 0000084D F9                      	stc                     ; in case of int 24
  3220 0000084E CD21                    	int	21h
  3221 00000850 7241                    	jc	short comerr	; ooops
  3222                                  			; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  3223                                  			; DS:DX -> ASCIZ filename
  3224                                  			; AL = access mode
  3225                                  			; 0 - read
  3226                                  	; 22/10/2022
  3227                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0852h)
  3228 00000852 89C3                            mov     bx,ax           ; handle in bx
  3229                                  
  3230                                  ;   If the standard command interpreter is being used, verify it is correct
  3231                                  
  3232                                  	; 22/10/2022
  3233                                  	;cmp	byte [newcmd],0	; was a new shell selected?
  3234                                  	;jne	short skip_validation ; yes
  3235                                  	;mov	dx,retry-4
  3236                                  	;mov	cx,4		;
  3237                                  	;mov	ah,READ		;
  3238                                  	;int	21h		;
  3239                                  	;cmp	byte [retry-4],0E9h
  3240                                  	;jne	short comerr
  3241                                  	;; 20/04/2019 - Retro DOS v4.0
  3242                                  	;cmp	byte [retry-1],64h ; MSDOS 6.21 IO.SYS - SYSINIT:088Ch
  3243                                  	;;cmp	byte [retry-1],((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  3244                                  	;jne	short comerr	;
  3245                                  
  3246                                  ;skip_validation:
  3247                                  	; 22/10/2022
  3248                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0854h)
  3249 00000854 31C9                    	xor	cx,cx
  3250 00000856 31D2                    	xor	dx,dx
  3251                                  	;mov	ax,(LSEEK<<8)|2
  3252 00000858 B80242                  	mov	ax,4202h
  3253 0000085B F9                      	stc			;in case of int 24
  3254 0000085C CD21                    	int	21h		; get file size in dx:ax
  3255 0000085E 7233                    	jc	short comerr
  3256                                  				; convert size in dx:ax to para in ax
  3257 00000860 83C00F                  	add	ax,15		; round up size for conversion to para
  3258 00000863 83D200                  	adc	dx,0
  3259 00000866 E8C303                  	call	off_to_para
  3260 00000869 B10C                    	mov	cl,12
  3261 0000086B D3E2                    	shl	dx,cl		; low nibble of dx to high nibble
  3262 0000086D 09D0                    	or	ax,dx		; ax is now # of para for file
  3263 0000086F 83C010                  	add	ax,10h		; 100h byte php
  3264 00000872 39E8                    	cmp	ax,bp		; will command fit in available mem?
  3265 00000874 7203                    	jb	short okld	; jump if yes.
  3266                                  
  3267                                  	; 22/10/2022
  3268                                  memerrjx:	; (MSDOS 5.0 IO.SYS SYSINIT:0876h)
  3269                                  	;jmp	memerr	; (MSDOS 5.0 IO.SYS SYSINIT:34D5h)
  3270                                  	; 02/11/2022
  3271 00000876 E95C2C                  	jmp	mem_err
  3272                                  
  3273                                  ;memerrjx:
  3274                                  ;	mov	dx,badmem
  3275                                  ;	call	print
  3276                                  ;       jmp     short continue
  3277                                  
  3278                                  okld:
  3279 00000879 B43E                    	mov	ah,3Eh ; CLOSE
  3280 0000087B CD21                    	int	21h		; close file
  3281                                  
  3282                                  	; 22/10/2022
  3283 0000087D 5A                      	pop	dx	; (MSDOS 5.0 IO.SYS SYSINIT:087Dh)
  3284                                  
  3285                                  	; 24/03/2019
  3286                                  
  3287 0000087E 0E                      	push	cs		; point es to sysinitseg
  3288 0000087F 07                      	pop	es
  3289 00000880 BB[3B03]                        mov     bx,COMEXE	; point to exec block
  3290                                  	; 22/10/2022
  3291                                  	;pop	dx              ; recover pointer to name
  3292                                  
  3293                                  ;;ifdef	MULTI_CONFIG
  3294                                  
  3295                                  ;   If there's any environment data in "config_wrkseg", pass it to shell;
  3296                                  ;   there will be data if there were any valid SET commands and/or if a menu
  3297                                  ;   selection was made (in which case the CONFIG environment variable will be
  3298                                  ;   set to that selection).
  3299                                  
  3300                                  	; 23/10/2022
  3301                                  	;mov	cx,[config_envlen]
  3302                                  	;jcxz	no_envdata
  3303                                          ;mov	cx,[config_wrkseg]
  3304                                  ;no_envdata:
  3305                                  	;;mov	[bx+EXEC0.ENVIRON],cx
  3306                                  	;mov	[bx],cx
  3307                                  
  3308                                  ;;endif	;MULTI_CONFIG
  3309                                  
  3310                                  	; 23/10/2022
  3311                                  	; (MSDOS 5.0 IO.SYS SYSINIT:0883h)
  3312                                  
  3313                                  	;mov	[bx+EXEC0.COM_LINE+2],cs ; set segments
  3314 00000883 8C4F04                  	mov	[bx+4],cs
  3315                                  	;mov	[bx+EXEC0.5C_FCB+2],cs
  3316 00000886 8C4F08                  	mov	[bx+8],cs
  3317                                  	;mov	[bx+EXEC0.6C_FCB+2],cs
  3318 00000889 8C4F0C                  	mov	[bx+12],cs
  3319                                  
  3320                                  	;mov	ax,(EXEC<<8) + 0
  3321                                  	; 23/10/2022
  3322 0000088C 31C0                    	xor	ax,ax
  3323 0000088E B44B                    	mov	ah,4Bh        
  3324                                  
  3325 00000890 F9                      	stc                     ; in case of int 24
  3326 00000891 CD21                            int     21h             ; go start up command
  3327                                  			; DOS - 2+ - LOAD OR EXECUTE (EXEC)
  3328                                  			; DS:DX -> ASCIZ filename
  3329                                  			; ES:BX -> parameter block
  3330                                  			; AL = subfunc: load & execute program
  3331                                  	;push	cs
  3332                                  	;pop	ds
  3333                                  
  3334                                  	; 23/10/2022
  3335                                  	;push	dx		; push to balance fall-through pop
  3336                                  
  3337                                  ; note fall through if exec returns (an error)
  3338                                  comerr:
  3339                                  	; 23/10/2022
  3340                                  ;;ifdef	MULTI_CONFIG
  3341                                  	;cmp	byte [commnd4],0
  3342                                  	;je	short comerr2	; all defaults exhausted, print err msg
  3343                                  	;cmp	byte [newcmd],0
  3344                                  	;je	short continue	; don't print err msg for defaults just yet
  3345                                  ;comerr2:
  3346                                  ;;endif
  3347 00000893 BA[BD3B]                        mov     dx,badcom	; want to print command error
  3348 00000896 E8982E                  	call	badfil
  3349                                  continue:
  3350                                  	; 23/10/2022
  3351                                  	;pop	dx
  3352                                  
  3353                                  ;;ifndef MULTI_CONFIG
  3354                                  	;jmp	stall
  3355                                  	; 24/10/2022
  3356                                  stall:		; (MSDOS 5.0 IO.SYS, SYSINIT:0899h)
  3357 00000899 EBFE                    	jmp	short stall
  3358                                  ;;else
  3359                                  	; 23/10/2022
  3360                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  3361                                  	;int	21h             ;
  3362                                  	;add	al,'A'          ;
  3363                                  	;mov	dl,al           ; DL == default drive letter
  3364                                  	;mov	si,commnd2
  3365                                  	;cmp	byte [newcmd],0 ; if a SHELL= was given
  3366                                  	;jne	short do_def2	; then try the 2nd alternate;
  3367                                  	;mov	byte [si],0	; otherwise, the default SHELL= was tried,
  3368                                  	;jmp	short do_def3   ; which is the same as our 2nd alt, so skip it
  3369                                  ;do_def2:			
  3370                                  	;cmp	byte [si],0	; has 2nd alternate been tried?
  3371                                          ;jne	short do_alt    ; no
  3372                                  ;do_def3:
  3373                                  	;mov	si,commnd3
  3374                                  	;cmp	byte [si],0	; has 3rd alternate been tried?
  3375                                  	;jne	short do_alt	; no
  3376                                  	;mov	si,commnd4
  3377                                  	;cmp	byte [si],0	; has 4th alternate been tried?
  3378                                  	;jne	short do_alt	; no
  3379                                  	;push	dx              ;
  3380                                  	;mov	dx,badcomprmpt
  3381                                  	;call	print		;
  3382                                  	;pop	dx              ; recover default drive letter in DL
  3383                                  ;request_input:			;
  3384                                  	;mov	ah,STD_CON_OUTPUT
  3385                                  	;int	21h             ;
  3386                                  	;push	dx              ;
  3387                                  	;mov	dl,'>'          ;
  3388                                  	;int	21h             ;
  3389                                  	;mov	bl,[tmplate+1]	;
  3390                                  	;mov	bh,0            ;
  3391                                  	;mov	byte [commnd+bx],0Dh
  3392                                  	;mov	dx,tmplate
  3393                                  	;mov	ah,STD_CON_STRING_INPUT
  3394                                  	;int	21h             ; read a line of input
  3395                                  	;mov	dx,crlfm	;
  3396                                  	;call	print           ;
  3397                                  	;pop	dx              ;
  3398                                  	;mov	bl,[tmplate+1]	;
  3399                                  	;or	bl,bl           ; was anything typed?
  3400                                  	;jz	short request_input ;
  3401                                  	;mov	byte [newcmd],1 ; disable validation for user-specified binaries
  3402                                  	;mov	byte [commnd+bx],0 ; NULL-terminate it before execing it
  3403                                  	;mov	word [command_line],0D00h
  3404                                  	;jmp	short do_exec   ;
  3405                                  ;do_alt:
  3406                                  	;push	ds
  3407                                  	;pop	es
  3408                                  	;mov	byte [newcmd],0 ; force validation for alternate binaries
  3409                                  	;mov	di,commnd	;
  3410                                  ;do_alt1:
  3411                                  	;lodsb			; copy the alternate, zapping it as we go,
  3412                                  	;mov	byte [si-1],0	; so that we know it's been tried
  3413                                  	;stosb 			;
  3414                                  	;or	al,al		;
  3415                                  	;jnz	short do_alt1	;
  3416                                  	;mov	di,command_line
  3417                                  	;cmp	byte [si+2],':'
  3418                                  	;jne	short do_alt2	;
  3419                                  	;mov	[si+1],dl	; stuff default drive into alt. command line
  3420                                  ;do_alt2:			;
  3421                                  	;lodsb			;
  3422                                  	;stosb			;
  3423                                  	;or	al,al           ;
  3424                                  	;jnz	short do_alt2   ;
  3425                                  	;mov	byte [di-1],cr
  3426                                  
  3427                                  ;;   Last but not least, see if we need to call disable_autoexec
  3428                                  
  3429                                  	; MSDOS 6.0 (SYSINIT1.ASM)
  3430                                  	;;cmp	[command_line-1],0
  3431                                          ;;jne	short do_exec   ;
  3432                                          ;;mov	[command_line-1],'/'
  3433                                  	;;call	disable_autoexec ;
  3434                                  
  3435                                  	; MSDOS 6.21 IO.SYS (SYSINIT:0994h)
  3436                                  	;mov	byte [dae_flag],0 ; 24/03/2019 - Retro DOS v4.0 	
  3437                                  	;call	disable_autoexec
  3438                                  	;call	CheckQueryOpt	; 24/03/2019 - Retro DOS v4.0
  3439                                  ;do_exec:
  3440                                  	;jmp     retry		;
  3441                                  
  3442                                  ;;endif	;MULTI_CONFIG
  3443                                  
  3444                                  ; 24/03/2019 - Retro DOS v4.0
  3445                                  
  3446                                  ; ----------------------------------------------------------------------
  3447                                  ; procedure : AllocFreeMem
  3448                                  ;
  3449                                  ; Allocate Max memory from DOS to find out where to load DOS.
  3450                                  ; DOS is at temporary location when this call is being made
  3451                                  ;
  3452                                  ; Inputs : None
  3453                                  ; Outputs: The biggest chunk of memory is allocated (all mem at init time)
  3454                                  ;	   [area] & [memhi] set to the para value of the start of the
  3455                                  ;	   free memory.
  3456                                  ;
  3457                                  ; Uses   : AX, BX
  3458                                  ;
  3459                                  ; ----------------------------------------------------------------------
  3460                                  
  3461                                  	; 23/10/2022
  3462                                  AllocFreeMem:
  3463 0000089B BBFFFF                  	mov	bx,0FFFFh
  3464 0000089E B448                    	mov	ah,48h ; ALLOC
  3465 000008A0 CD21                    	int	21h			; first time fails
  3466 000008A2 B448                    	mov	ah,48h ; ALLOC
  3467 000008A4 CD21                    	int	21h			; second time gets it
  3468 000008A6 2EA3[E403]              	mov	[cs:area],ax
  3469 000008AA 2EA3[E003]              	mov	[cs:memhi],ax		; memhi:memlo now points to
  3470 000008AE C3                      	retn				; start of free memory
  3471                                  
  3472                                  	; include msbio.cl6
  3473                                  ; ----------------------------------------------------------------------
  3474                                  DOSLOMSG:
  3475 000008AF 484D41206E6F742061-     	db	'HMA not available: Loading DOS low',0Dh,0Ah,'$'
  3475 000008B8 7661696C61626C653A-
  3475 000008C1 204C6F6164696E6720-
  3475 000008CA 444F53206C6F770D0A-
  3475 000008D3 24                 
  3476                                  FEmsg:
  3477 000008D4 466174616C20457272-     	db	'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$'
  3477 000008DD 6F723A2043616E6E6F-
  3477 000008E6 7420616C6C6F636174-
  3477 000008EF 65204D656D6F727920-
  3477 000008F8 666F7220444F530D0A-
  3477 00000901 24                 
  3478                                  
  3479                                  ; ----------------------------------------------------------------------
  3480                                  ;
  3481                                  ; procedure : LoadDOSHiOrLo
  3482                                  ;
  3483                                  ;		Tries to move DOS into HMA. If it fails then loads
  3484                                  ;		DOS into Low memory. For ROMDOS, nothing is actually
  3485                                  ;		moved; this just tries to allocate the HMA, and prints
  3486                                  ;		a message if this is not possible.
  3487                                  ;
  3488                                  ; ----------------------------------------------------------------------
  3489                                  
  3490                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3491                                  LoadDOSHiOrLo:
  3492                                  	; 27/03/2019 - Retro DOS v4.0
  3493                                  	; ds = cs
  3494 00000902 E82500                  	call	TryToMovDOSHi		; Try moving it into HMA (M024)
  3495 00000905 7201                    	jc	short LdngLo		; If that don't work...
  3496 00000907 C3                      	retn
  3497                                  LdngLo:
  3498                                  	; 23/10/2022
  3499 00000908 0E                      	push	cs
  3500 00000909 1F                      	pop	ds
  3501 0000090A B409                    	mov	ah,9
  3502 0000090C BA[AF08]                	mov	dx,DOSLOMSG		; inform user that we are
  3503 0000090F CD21                    	int	21h			; loading low
  3504                                  
  3505                                  ;ifndef ROMDOS
  3506                                  	; actually move the dos, and reinitialize it.
  3507                                  
  3508 00000911 BB0100                  	mov	bx,1				; M012
  3509                                  						;  use int 21 alloc for mem
  3510 00000914 E84600                  	call	MovDOSLo
  3511 00000917 2E8E06[7102]            	mov	es,[cs:CURRENT_DOS_LOCATION]	; give dos its temporary loc.
  3512                                  	; 23/10/2022
  3513                                  	;mov	es,[CURRENT_DOS_LOCATION]
  3514                                  	;;mov	es,[cs:FINAL_DOS_LOCATION]  ; 24/03/2019 - Retro DOS v4.0
  3515                                  	;mov	es,[FINAL_DOS_LOCATION] ; 27/03/2019
  3516 0000091C 31C0                    	xor	ax,ax				; ax = 00 ---> install stub
  3517 0000091E 2EFF1E[7B02]            	call	far [cs:dos_segreinit]		; call dos segreinit
  3518                                  	;call	far [dos_segreinit] ; 27/03/2019
  3519                                  	
  3520                                  ;endif ; ROMDOS
  3521                                  	; 23/10/2022
  3522 00000923 2EC606[6A02]00          	mov	byte [cs:runhigh],0		; mark that we are running lo
  3523                                  	;mov	byte [runhigh],0 ; 27/03/2019
  3524 00000929 C3                      	retn
  3525                                  
  3526                                  ; ----------------------------------------------------------------------
  3527                                  ;
  3528                                  ; procedure : TryToMovDOSHi
  3529                                  ;
  3530                                  ;		This tries to move DOS into HMA.
  3531                                  ;		Returns CY if it failed.
  3532                                  ;		If it succeeds returns with carry cleared.
  3533                                  ;
  3534                                  ;		For ROMDOS, dos_segreinit must be called again to allow
  3535                                  ;		the A20 switching code in the low mem stub to be installed.
  3536                                  ; 
  3537                                  ; ----------------------------------------------------------------------
  3538                                  
  3539                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3540                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:092Ah)
  3541                                  TryToMovDOSHi:
  3542                                  	; 27/03/2019 - Retro DOS v4.0
  3543                                  	; ds = cs
  3544 0000092A E81600                  	call	MovDOSHi
  3545 0000092D 7213                    	jc	short ttldhx
  3546                                  
  3547                                  ;ifndef ROMDOS
  3548                                  	; 23/10/2022
  3549 0000092F 2E8E06[7102]            	mov	es,[cs:CURRENT_DOS_LOCATION] ; give dos its temporary loc.
  3550                                  	;mov	es,[cs:FINAL_DOS_LOCATION] ; 24/03/2019 - Retro DOS v4.0
  3551                                  ;else
  3552                                  ;	..
  3553                                  ;endif ; ROMDOS
  3554                                  
  3555 00000934 31C0                    	xor	ax,ax			; ax = 00 ---> install stub
  3556 00000936 2EFF1E[7B02]            	call	far [cs:dos_segreinit]	; call dos segreinit
  3557                                  
  3558 0000093B 2EC606[6A02]01          	mov	byte [cs:runhigh],1
  3559 00000941 F8                      	clc
  3560                                  ttldhx:
  3561 00000942 C3                      	retn
  3562                                  
  3563                                  ; ----------------------------------------------------------------------
  3564                                  ;
  3565                                  ; procedure : MovDOSHi
  3566                                  ;
  3567                                  ;		Tries to allocate HMA and Move DOS/BIOS code into HMA
  3568                                  ;		For ROMDOS, the code is not actually moved, but the
  3569                                  ;		HMA is allocated and prepared for sub-allocation.
  3570                                  ;
  3571                                  ;		Returns : CY if it failed
  3572                                  ;
  3573                                  ; ----------------------------------------------------------------------
  3574                                  
  3575                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3576                                  MovDOSHi:
  3577                                  	; 14/05/2019
  3578                                  	; 27/03/2019 - Retro DOS v4.0
  3579                                  	; ds = cs
  3580 00000943 E8E000                  	call	AllocHMA
  3581 00000946 7214                    	jc	short mdhx			; did we get HMA?
  3582 00000948 B8FFFF                  	mov	ax,0FFFFh			; yes, HMA seg = 0ffffh
  3583 0000094B 8EC0                    	mov	es,ax
  3584                                  
  3585                                  ;ifndef ROMDOS
  3586                                  	; actually move the BIOS and DOS
  3587                                  
  3588                                  	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
  3589                                  	; 24/03/2019
  3590                                  	
  3591                                  	; 23/10/2022
  3592 0000094D E81E00                  	call	MovBIOS				; First move BIOS into HMA
  3593                                  
  3594                                  	; ES:DI points to free HMA after BIOS
  3595                                  	
  3596                                  	; 14/05/2019
  3597                                  	; 24/03/2019 - Retro DOS v4.0
  3598                                  	;xor	di,di
  3599                                  	
  3600                                  	; 23/10/2022
  3601 00000950 2E8B0E[8102]            	mov	cx,[cs:hi_doscod_size]		; pass the code size of DOS
  3602                                  	;mov	cx,[hi_doscod_size]		;  when it is in HMA
  3603 00000955 E83900                  	call	MovDOS				; and move it
  3604                                  
  3605                                  	; ES:DI points to free HMA after DOS
  3606                                  ;else
  3607                                  ;	; allocate space at beginning of HMA to allow for CPMHack
  3608                                  ;
  3609                                  ;	mov	di,0E0h				; room for 5 bytes at ffff:d0
  3610                                  ;
  3611                                  ;endif ; ROMDOS
  3612                                  
  3613 00000958 E86D02                  	call	SaveFreeHMAPtr			; Save the Free HMA ptr
  3614 0000095B F8                      	clc
  3615                                  mdhx:
  3616 0000095C C3                      	retn
  3617                                  
  3618                                  ; ----------------------------------------------------------------------
  3619                                  ;
  3620                                  ; procedure : MovDOSLo
  3621                                  ;
  3622                                  ;		Allocates memory from DOS and moves BIOS/DOS code into it
  3623                                  ;
  3624                                  ; ----------------------------------------------------------------------
  3625                                  
  3626                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3627                                  
  3628                                  ;ifndef ROMDOS
  3629                                  
  3630                                  MovDOSLo:
  3631                                  	; 14/05/2019
  3632                                  	; 27/03/2019 - Retro DOS v4.0
  3633                                  	; ds = cs
  3634 0000095D E84D00                  	call	AllocMemForDOS			; incestuosly!!!
  3635                                  	
  3636                                  	; 23/10/2022
  3637                                  	; 14/05/2019
  3638                                  	;inc	ax  ; skip MCB
  3639                                  	
  3640 00000960 8EC0                    	mov	es,ax				; pass the segment to MovBIOS
  3641                                  	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
  3642                                  	; 24/03/2019
  3643                                  	
  3644                                  	; 23/10/2022
  3645 00000962 E80900                  	call	MovBIOS
  3646                                  
  3647                                  ;------ ES:DI points memory immediately after BIOS
  3648                                  
  3649                                  	; 14/05/2019
  3650                                  	; NOTE: 
  3651                                  	;     Order of (RETRO) DOS kernel sections at memory:
  3652                                  	;	BIOSDATA+BIOSCODE+BIOSDATAINIT+DOSDATA+DOSCODE(LOW)
  3653                                  
  3654                                  	; 24/03/2019 - Retro DOS v4.0
  3655                                  	;xor	di,di	
  3656                                  
  3657                                  	; 23/10/2022
  3658 00000965 2E8B0E[7F02]            	mov	cx,[cs:lo_doscod_size]		; DOS code size when loaded
  3659                                  	;mov	cx,[lo_doscod_size]		;  low
  3660 0000096A E82400                  	call	MovDOS
  3661 0000096D C3                      	retn
  3662                                  
  3663                                  ;endif ; ROMDOS
  3664                                  
  3665                                  ; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
  3666                                  ; 24/03/2019
  3667                                  ; ----------------------------------------------------------------------
  3668                                  ;
  3669                                  ; procedure : MovBIOS
  3670                                  ;
  3671                                  ;		Moves BIOS code into requested segment
  3672                                  ;
  3673                                  ;	In : ES - segment to which BIOS is to be moved
  3674                                  ;		  ( it moves always into offset BCode_Start)
  3675                                  ;
  3676                                  ;	Out : ES:DI - pointer to memory immediately after BIOS
  3677                                  ;
  3678                                  ; ----------------------------------------------------------------------
  3679                                  
  3680                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3681                                  
  3682                                  ;ifndef ROMDOS
  3683                                  
  3684                                  MovBIOS: ; proc	near
  3685                                  	; 23/10/2022
  3686 0000096E 2E8E1E[8702]            	mov	ds,[cs:temp_bcode_seg]		; current BIOS code seg
  3687 00000973 BE3000                  	mov	si,BCODE_START ; mov si,30h
  3688 00000976 89F7                    	mov	di,si
  3689 00000978 B9601A                  	mov	cx,BCODE_END ; mov cx,1A60h
  3690 0000097B 29F1                    	sub	cx,si				; size of BIOS
  3691 0000097D D1E9                    	shr	cx,1				; Both the labels are para
  3692                                  						;  aligned
  3693 0000097F F3A5                    	rep	movsw
  3694 00000981 06                      	push	es
  3695 00000982 57                      	push	di				; save end of BIOS
  3696 00000983 8CC0                    	mov	ax,es
  3697 00000985 2EA3[0004]              	mov	[cs:BCodeSeg],ax		; save it for later use
  3698                                  	;call	dword ptr cs:_seg_reinit_ptr
  3699 00000989 2EFF1E[8502]            	call	far [cs:seg_reinit_ptr]		; far call to seg_reinit (M022)
  3700 0000098E 5F                      	pop	di
  3701 0000098F 07                      	pop	es				; get back end of BIOS
  3702 00000990 C3                      	retn
  3703                                  
  3704                                  ;MovBIOS endp
  3705                                  
  3706                                  ;endif ; ROMDOS
  3707                                  
  3708                                  ; 24/03/2019
  3709                                  
  3710                                  ; ----------------------------------------------------------------------
  3711                                  ;
  3712                                  ; procedure : MovDOS
  3713                                  ;
  3714                                  ;		Moves DOS code into requested area
  3715                                  ;
  3716                                  ;	In : ES:DI - pointer to memory where DOS is to be moved
  3717                                  ;	     CX    - size of DOS code to be moved
  3718                                  ;
  3719                                  ;	Out : ES:DI - pointer to memory immediately after DOS
  3720                                  ;
  3721                                  ; ----------------------------------------------------------------------
  3722                                  
  3723                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3724                                  
  3725                                  ;ifndef ROMDOS
  3726                                  
  3727                                  MovDOS:
  3728                                  	; 14/05/2019
  3729                                  	; 27/03/2019 - Retro DOS v4.0
  3730                                  	; ds = cs
  3731                                  	
  3732                                  	; 23/10/2022
  3733                                  	;push	ds ; *//
  3734                                  	
  3735 00000991 06                      	push	es
  3736 00000992 57                      	push	di
  3737                                  
  3738                                  	; 29/04/2019
  3739                                  	;lds	si,[dosinit]
  3740                                  	; 23/10/2022
  3741 00000993 2EC536[6F02]            	lds	si, [cs:dosinit]
  3742                                  	;mov	ax,si
  3743                                  
  3744 00000998 F3A4                    	rep	movsb
  3745 0000099A 5B                      	pop	bx				; get back offset into which
  3746                                  						;  DOS was moved
  3747 0000099B 2EA1[6F02]              	mov	ax,[cs:dosinit]			; get the offset at which DOS
  3748                                  						;  wants to run
  3749 0000099F 29D8                    	sub	ax,bx
  3750 000009A1 E88802                  	call	off_to_para
  3751 000009A4 5B                      	pop	bx				; get the segment at which
  3752                                  						;  we moved DOS into
  3753 000009A5 29C3                    	sub	bx,ax				; Adjust segment
  3754                                  	; 23/10/2022
  3755 000009A7 2E891E[7102]            	mov	[cs:CURRENT_DOS_LOCATION],bx	; and save it
  3756                                  	;mov	[cs:FINAL_DOS_LOCATION],bx
  3757                                  		
  3758                                  	; 27/03/2019
  3759                                  	;pop	ds ; *//
  3760                                  	; ds = cs
  3761                                  	;mov	[FINAL_DOS_LOCATION],bx
  3762                                  
  3763 000009AC C3                      	retn
  3764                                  
  3765                                  ;endif ;ROMDOS
  3766                                  
  3767                                  ; ----------------------------------------------------------------------
  3768                                  ;
  3769                                  ; procedure : AllocMemForDOS
  3770                                  ;
  3771                                  ;		Allocate memory for DOS/BIOS code from DOS !!!
  3772                                  ;
  3773                                  ;	Out : AX - seg of allocated memoryblock
  3774                                  ;
  3775                                  ; ----------------------------------------------------------------------
  3776                                  
  3777                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3778                                  
  3779                                  ;ifndef ROMDOS
  3780                                  
  3781                                  AllocMemForDOS:
  3782                                  	; 14/05/2019
  3783                                  	; 27/03/2019 - Retro DOS v4.0
  3784                                  	; ds = cs
  3785                                  	;mov	ax,BCode_end
  3786                                  	;sub	ax,BCode_start		; BIOS code size
  3787                                  	; 23/10/2022
  3788 000009AD B8601A                  	mov	ax,BCODE_END ; 1A60h
  3789 000009B0 83E830                  	sub	ax,BCODE_START ; 30h
  3790                                  	; 24/03/2019 - Retro DOS v4.0 
  3791                                  	; 02/11/2022
  3792 000009B3 2E0306[7F02]            	add	ax,[cs:lo_doscod_size]	; DOS code size
  3793                                  	;add	ax,[lo_doscod_size]
  3794 000009B8 83C00F                  	add	ax,15
  3795 000009BB E86E02                  	call	off_to_para			; convert to para
  3796                                  	; 23/10/2022
  3797                                  	; 14/05/2019
  3798                                  	;inc	ax ; + 1 paragraph for MCB
  3799 000009BE 09DB                    	or	bx,bx				; M012
  3800 000009C0 89C3                    	mov	bx,ax				;  can we use int 21 for alloc
  3801 000009C2 741A                    	jz	short update_arena		; M012
  3802 000009C4 B448                    	mov	ah,48h				; request DOS
  3803 000009C6 CD21                    	int	21h
  3804 000009C8 7251                    	jc	short FatalErr			; IF ERR WE ARE HOSED
  3805                                   	; 23/10/2022
  3806                                  	; 24/03/2019 - Retro DOS v4.0 (ORG 0)
  3807 000009CA 83E803                  	sub	ax,3				; Take care ORG 30h of
  3808                                  						;  BIOS code
  3809 000009CD 8EC0                    	mov	es,ax
  3810                                  	;mov	word [es:20h+ARENA.OWNER],08h	; mark it as system
  3811                                  	;mov	word [es:20h+ARENA.NAME],'SC'	;  code area
  3812                                  	; 14/05/2019
  3813                                  	;mov	word [es:ARENA.OWNER],08h	; mark it as system
  3814                                  	;mov	word [es:ARENA.NAME],'SC'	;  code area
  3815                                  	; 23/10/2022
  3816 000009CF 26C70621000800          	mov	word [es:20h+1],08h		; mark it as system
  3817 000009D6 26C70628005343          	mov	word [es:20h+8],'SC'		;  code area
  3818                                  
  3819 000009DD C3                      	retn
  3820                                  
  3821                                  ; BUGBUG -- 5 Aug 92 -- chuckst -- Allocating space for DOS
  3822                                  ;	  using DOS itself causes an arena to be generated.
  3823                                  ;	  Unfortunately, certain programs (like PROTMAN$)
  3824                                  ;	  assume that the device drivers are loaded into
  3825                                  ;	  the first arena. For this reason, MagicDrv's
  3826                                  ;	  main device driver header arena is manually
  3827                                  ;	  truncated from the arena chain, and the space
  3828                                  ;	  for DOS is allocated using the following
  3829                                  ;	  simple code, which also assumes that the
  3830                                  ;	  first arena is the free one where DOS's low
  3831                                  ;	  stub will go.
  3832                                  ;
  3833                                  ; M012 : BEGIN
  3834                                  
  3835                                  	; 23/10/2022
  3836                                  update_arena:
  3837 000009DE 1E                      	push	ds ; ds = cs
  3838 000009DF 57                      	push	di
  3839 000009E0 51                      	push	cx
  3840 000009E1 52                      	push	dx
  3841                                  	; 23/10/2022
  3842 000009E2 2EC53E[6B02]            	lds	di,[cs:DOSINFO]			; get ptr to DOS var
  3843                                  	;lds	di,[DOSINFO] ; 27/03/2019	
  3844 000009E7 4F                      	dec	di
  3845 000009E8 4F                      	dec	di				; Arena head is immediately
  3846                                  						;  before sysvar
  3847 000009E9 8E05                    	mov	es,[di]				; es = arena head
  3848                                  	;mov	cx,[es:ARENA.SIZE]		; cx = total low mem size
  3849 000009EB 268B0E0300              	mov	cx,[es:3]
  3850 000009F0 39D9                    	cmp	cx,bx				; is it sufficient ?
  3851 000009F2 7227                    	jb	short FatalErr			; no, fatal error
  3852                                  
  3853                                  	;mov	dl,[es:ARENA.SIGNATURE]
  3854 000009F4 268A160000              	mov	dl,[es:0]
  3855 000009F9 8CC0                    	mov	ax,es
  3856 000009FB 01D8                    	add	ax,bx				; ax = new arena head
  3857 000009FD 8905                    	mov	[di],ax			; store it in DOS data area
  3858 000009FF 8ED8                    	mov	ds,ax
  3859                                  	;mov	[ARENA.SIGNATURE],dl		; type of arena
  3860 00000A01 88160000                	mov	[0],dl
  3861                                  	;mov	word [ARENA.OWNER],0		; free
  3862 00000A05 C70601000000            	mov	word [1],0
  3863 00000A0B 29D9                    	sub	cx,bx				; size of the new block
  3864                                  	;mov	[ARENA.SIZE],cx			; store it in the arena
  3865 00000A0D 890E0300                	mov	[3],cx
  3866 00000A11 8CC0                    	mov	ax,es				; return seg to the caller
  3867                                  	; 23/10/2022
  3868                                  	;; 24/03/2019 - Retro DOS v4.0 (ORG 0)	; Take care ORG 30h of
  3869 00000A13 83E803                  	sub	ax,3				;  BIOS code
  3870 00000A16 5A                      	pop	dx
  3871 00000A17 59                      	pop	cx
  3872 00000A18 5F                      	pop	di
  3873 00000A19 1F                      	pop	ds ; ds = cs
  3874 00000A1A C3                      	retn
  3875                                  ;
  3876                                  ; M012 : END
  3877                                  ;
  3878                                  FatalErr:
  3879 00000A1B 0E                      	push	cs
  3880 00000A1C 1F                      	pop	ds
  3881 00000A1D BA[D408]                	mov	dx,FEmsg
  3882 00000A20 B409                    	mov	ah,9
  3883 00000A22 CD21                    	int	21h 		; DOS - PRINT STRING
  3884                                  				; DS:DX -> string terminated by "$"
  3885                                          ;jmp     stall
  3886                                  	; 23/10/2022
  3887 00000A24 FA                      	cli
  3888 00000A25 F4                      	hlt
  3889                                  
  3890                                  ;endif ;ROMDOS
  3891                                  
  3892                                  ; 25/03/2019 - Retro DOS v4.0
  3893                                  
  3894                                  ; ----------------------------------------------------------------------
  3895                                  ;
  3896                                  ; procedure : AllocHMA
  3897                                  ;
  3898                                  ;	grab_the_hma tries to enable a20 and make sure there is memory
  3899                                  ;	  up there. If it gets any sort of error, it will return with
  3900                                  ;	  carry set so that we can resort to running low.
  3901                                  ;
  3902                                  ;	It also returns ES: -> 0ffffh if it returns success
  3903                                  ;
  3904                                  ; ----------------------------------------------------------------------
  3905                                  
  3906                                  AllocHMA:
  3907                                  ;	cas note:  The pre-286 check is no longer needed here since the
  3908                                  ;		   presence of XMS is sufficient. However, this code hasn't
  3909                                  ;		   been deleted because it can be recycled for skipping the
  3910                                  ;		   extra pass of CONFIG.SYS and assuming we're running low
  3911                                  ;		   in the case of a pre-286.
  3912                                  
  3913                                  ;;	see if we're running on a pre-286. If not, force low.
  3914                                  ;
  3915                                  ;	xor	ax,ax
  3916                                  ;	pushf			; save flags (like int)
  3917                                  ;	push	ax
  3918                                  ;	popf
  3919                                  ;	pushf
  3920                                  ;	pop	ax
  3921                                  ;	popf			; restore original flags (like int)
  3922                                  ;	and	ax,0F000h
  3923                                  ;	cmp	ax,0F000h	; 8088/8086?
  3924                                  ;	jz	short grab_hma_error
  3925                                  
  3926                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  3927                                  	; (SYSINIT:0A26h)
  3928                                  
  3929 00000A26 1E                      	push	ds
  3930                                  	;;mov	ax,Bios_Data
  3931                                  	;mov	ax,KERNEL_SEGMENT
  3932                                  	; 21/10/2022
  3933 00000A27 B87000                  	mov	ax,DOSBIODATASEG
  3934 00000A2A 8ED8                    	mov	ds,ax
  3935                                  
  3936 00000A2C E84D00                  	call	IsXMSLoaded
  3937 00000A2F 7548                    	jnz	short grabhma_error
  3938                                  
  3939 00000A31 B81043                  	mov	ax,4310h
  3940 00000A34 CD2F                    	int	2Fh		; get the vector into es:bx
  3941                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  3942                                  		; Return: ES:BX -> driver entry point
  3943                                  
  3944 00000A36 891E0E00                	mov	[xms],bx
  3945                                  	;mov	[0Eh], bx
  3946 00000A3A 8C061000                	mov	[xms+2],es
  3947                                  	;mov	[10h], es
  3948                                  
  3949 00000A3E B401                    	mov	ah,1		; request HMA
  3950 00000A40 BAFFFF                  	mov	dx,0FFFFh
  3951                                  	;call	dword ptr ds:0Eh
  3952 00000A43 FF1E0E00                	call	far [xms]
  3953 00000A47 48                      	dec	ax
  3954 00000A48 7409                    	jz	short allocHMA_1 ; error if not able to allocate HMA
  3955                                  
  3956                                  ;------ Himem may be lying because it has allocated mem for int 15
  3957                                  
  3958 00000A4A B488                    	mov	ah,88h
  3959 00000A4C CD15                    	int	15h
  3960                                  		; Get Extended Memory Size
  3961                                  		; Return: CF clear on success
  3962                                  		; AX = size of memory above 1M in K
  3963 00000A4E 83F840                  	cmp	ax,64		; less than 64 K of hma ?
  3964 00000A51 7226                    	jb	short grabhma_error
  3965                                  allocHMA_1:
  3966 00000A53 B405                    	mov	ah,5		; localenableA20
  3967                                  	;call	dword ptr ds:0Eh
  3968 00000A55 FF1E0E00                	call	far [xms]
  3969 00000A59 48                      	dec	ax
  3970 00000A5A 751D                    	jnz	short grabhma_error ; error if couldn't enable A20
  3971                                  
  3972 00000A5C E88D01                  	call	IsVDiskInstalled
  3973 00000A5F 7418                    	jz	short grabhma_error ; yes, we cant use HMA
  3974                                  
  3975 00000A61 B8FFFF                  	mov	ax,0FFFFh
  3976 00000A64 8EC0                    	mov	es,ax
  3977 00000A66 26C70610003412          	mov	word [es:10h],1234h ; see if we can really read/write there
  3978 00000A6D 26813E10003412          	cmp	word [es:10h],1234h
  3979 00000A74 7503                    	jne	short grabhma_error ; don't try to load there if XMS lied
  3980                                  
  3981 00000A76 F8                      	clc
  3982 00000A77 1F                      	pop	ds
  3983 00000A78 C3                      	retn
  3984                                  
  3985                                  grabhma_error:
  3986 00000A79 F9                      	stc
  3987 00000A7A 1F                      	pop	ds
  3988 00000A7B C3                      	retn
  3989                                  
  3990                                  ; ----------------------------------------------------------------------
  3991                                  ;
  3992                                  ; procedure : IsXMSLoaded
  3993                                  ;
  3994                                  ;             Checks whether a XMS driver is loaded
  3995                                  ;
  3996                                  ; Returns : Z flag set if XMS driver loaded
  3997                                  ;           Z flag reset if no XMS drivers are present
  3998                                  ;
  3999                                  ; ----------------------------------------------------------------------
  4000                                  
  4001                                  IsXMSLoaded:
  4002 00000A7C B80043                  	mov	ax,4300h
  4003 00000A7F CD2F                    	int	2Fh		; - Multiplex - XMS - INSTALLATION CHECK
  4004                                  				; Return: AL = 80h XMS driver installed
  4005                                  				; AL <> 80h no driver
  4006 00000A81 3C80                    	cmp	al,80h		; XMS installed?
  4007 00000A83 C3                      	retn
  4008                                  
  4009                                  ; ----------------------------------------------------------------------
  4010                                  ; procedure : FTryToMovDOSHi
  4011                                  ;
  4012                                  ;		Called from HMA suballoc calls
  4013                                  ;	
  4014                                  ; ----------------------------------------------------------------------
  4015                                  
  4016                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4017                                  	; (SYSINIT:0A84h)
  4018                                  
  4019                                  FTryToMovDOSHi:	; proc	far
  4020                                  
  4021 00000A84 50                      	push	ax
  4022 00000A85 53                      	push	bx
  4023 00000A86 51                      	push	cx
  4024 00000A87 52                      	push	dx
  4025 00000A88 56                      	push	si
  4026 00000A89 57                      	push	di
  4027 00000A8A 1E                      	push	ds
  4028 00000A8B 06                      	push	es
  4029                                  
  4030                                  	; 23/10/2022
  4031                                  	; 27/03/2019 - Retro DOS v4.0
  4032                                  	;push	cs
  4033                                  	;pop	ds
  4034                                  
  4035 00000A8C 2E803E[6A02]FF          	cmp	byte [cs:runhigh],0FFh
  4036                                  	;cmp	byte [runhigh],0FFh
  4037 00000A92 7503                    	jne	short _ftymdh_1
  4038                                  
  4039                                  	; ds = cs
  4040 00000A94 E893FE                  	call	TryToMovDOSHi
  4041                                  _ftymdh_1:
  4042 00000A97 07                      	pop	es
  4043 00000A98 1F                      	pop	ds
  4044 00000A99 5F                      	pop	di
  4045 00000A9A 5E                      	pop	si
  4046 00000A9B 5A                      	pop	dx
  4047 00000A9C 59                      	pop	cx
  4048 00000A9D 5B                      	pop	bx
  4049 00000A9E 58                      	pop	ax
  4050                                  
  4051 00000A9F CB                      	retf
  4052                                  
  4053                                  ; ----------------------------------------------------------------------
  4054                                  ;
  4055                                  ; following piece of code will be moved into a para boundary. And the para
  4056                                  ; address posted in seg of int 19h vector. Offset of int 19h will point to
  4057                                  ; VDint19. This is to protect HMA from apps which use VDISK header method
  4058                                  ; to determine free extended memory.
  4059                                  ;
  4060                                  ; For more details read "power programming" column by Ray Duncan in the
  4061                                  ; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
  4062                                  ;
  4063                                  ; ----------------------------------------------------------------------
  4064                                  
  4065                                  StartVDHead:
  4066                                  ;-------------- what follows is a dummy device driver header (not used by DOS)
  4067                                  
  4068 00000AA0 00000000                	dd	0		; link to next device driver
  4069 00000AA4 0080                    	dw	8000h		; device attribute
  4070 00000AA6 0000                    	dw	0		; strategy routine offset
  4071 00000AA8 0000                    	dw	0		; interrupt routine offset
  4072 00000AAA 01                      	db	1		; number of units
  4073                                  	;db	7 dup(0) 
  4074 00000AAB 00<rep 7h>              	times	7 db 0 		; reserved area
  4075                                  VDiskSig1:
  4076 00000AB2 564449534B              	db	'VDISK'
  4077                                  
  4078                                  VLEN1	equ	($-VDiskSig1)
  4079                                  
  4080 00000AB7 202056332E33            	db	'  V3.3'	; vdisk label
  4081                                  	;db	15 dup (0)	; pad
  4082 00000ABD 00<rep Fh>              	times	15 db 0
  4083 00000ACC 0000                    	dw	0		; bits 0-15 of free HMA
  4084 00000ACE 11                      	db	11h		; bits 16-23 of free HMA (1M + 64K)
  4085                                  VDInt19:
  4086 00000ACF EA                      	db	0EAh		; jmp to old vector
  4087                                  OldVDInt19:
  4088 00000AD0 00000000                	dd	0		; Saved int 19 vector
  4089                                  
  4090                                  EndVDHead: ; label byte
  4091                                  
  4092                                  VDiskHMAHead:	
  4093 00000AD4 000000                  	db	0,0,0		; non-bootable disk
  4094                                  VDiskSig2:
  4095 00000AD7 564449534B              	db	'VDISK'
  4096                                  
  4097                                  VLEN2	equ	($-VDiskSig2)
  4098                                  
  4099 00000ADC 332E33                  	db	'3.3'		; OEM - signature
  4100 00000ADF 8000                    	dw	128		; number of bytes/sector
  4101 00000AE1 01                      	db	1		; sectors/cluster
  4102 00000AE2 0100                    	dw	1		; reserved sectors
  4103 00000AE4 01                      	db	1		; number of FAT copies
  4104 00000AE5 4000                    	dw	64		; number of root dir entries
  4105 00000AE7 0002                    	dw	512		; number of sectors
  4106 00000AE9 FE                      	db	0FEh		; media descriptor
  4107 00000AEA 0600                    	dw	6		; number of sectors/FAT
  4108 00000AEC 0800                    	dw	8		; sectors per track
  4109 00000AEE 0100                    	dw	1		; number of heads
  4110 00000AF0 0000                    	dw	0		; number of hidden sectors
  4111 00000AF2 4004                    	dw	440h		; Start of free HMA in K (1M+64K)
  4112                                  
  4113                                  EndVDiskHMAHead: ; label byte
  4114                                  
  4115                                  ; ----------------------------------------------------------------------
  4116                                  ;
  4117                                  ; procedure : InstVDiskHeader
  4118                                  ;
  4119                                  ;             Installs the VDISK header to reserve the 64k of HMA
  4120                                  ;	      It puts a 32 byte header at 10000:0 and
  4121                                  ;	      another header at (seg of int19):0
  4122                                  ;
  4123                                  ; Inputs : None
  4124                                  ;
  4125                                  ; Outputs : None
  4126                                  ;
  4127                                  ; USES : DS,SI,AX,CX,DX
  4128                                  ;
  4129                                  ; ----------------------------------------------------------------------
  4130                                  
  4131                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4132                                  
  4133                                  InstVDiskHeader:
  4134 00000AF4 31C0                    	xor	ax,ax
  4135 00000AF6 8ED8                    	mov	ds,ax			; seg of int vect table
  4136                                  
  4137                                  ;-------------- save old int 19 vector
  4138                                  
  4139                                  	; 23/10/2022
  4140 00000AF8 A16400                  	mov	ax,[19h*4]
  4141                                  	;mov	[OldVDInt19],ax
  4142 00000AFB 2EA3[D00A]              	mov	[cs:OldVDInt19],ax
  4143 00000AFF A16600                  	mov	ax,[19h*4+2]
  4144                                  	;mov	[OldVDInt19+2],ax
  4145 00000B02 2EA3[D20A]              	mov	[cs:OldVDInt19+2],ax
  4146                                  
  4147                                  ;-------------- calculate seg of new int 19 handler
  4148                                  
  4149 00000B06 B448                    	mov	ah,48h			; allocate memory
  4150                                  	;mov	bx,(EndVDHead-StartVDHead+15)>>4
  4151                                  	; 23/10/2022
  4152 00000B08 BB0400                  	mov	bx,4
  4153 00000B0B CD21                    	int	21h
  4154                                  
  4155                                  ;	if carry, fatal hanging error!!!!!
  4156                                  
  4157 00000B0D 48                      	dec	ax			; point to arena
  4158 00000B0E 8EC0                    	mov	es,ax
  4159                                  	;mov	word [es:ARENA.OWNER],8	; owner = System
  4160 00000B10 26C70601000800          	mov	word [es:1],8
  4161                                  	;mov	word [es:ARENA.NAME],'SC' ; System Code
  4162 00000B17 26C70608005343          	mov	word [es:8],'SC'
  4163 00000B1E 40                      	inc	ax
  4164 00000B1F 8EC0                    	mov	es,ax			; get back to allocated memory
  4165                                  
  4166                                  ;-------------- install new int 19 vector
  4167                                  
  4168 00000B21 FA                      	cli				; no reboots at this time
  4169                                  	;mov	word [19h*4],(VDInt19-StartVDHead)
  4170 00000B22 C70664002F00            	mov	word [19h*4],47
  4171 00000B28 A36600                  	mov	[19h*4+2],ax
  4172                                  
  4173                                  ;-------------- move the code into proper place
  4174                                  
  4175                                  	;mov	cx,(EndVDHead-StartVDHead)
  4176 00000B2B B93400                  	mov	cx,52
  4177 00000B2E BE[A00A]                	mov	si,StartVDHead
  4178 00000B31 31FF                    	xor	di,di
  4179 00000B33 0E                      	push	cs
  4180 00000B34 1F                      	pop	ds
  4181 00000B35 FC                      	cld
  4182 00000B36 F3A4                    	rep	movsb
  4183 00000B38 FB                      	sti				; BUGBUG is sti OK now?
  4184                                  
  4185                                  ;-------------- mov the HMA VDisk head into HMA
  4186                                  
  4187                                  	; 23/10/2022
  4188 00000B39 57                      	push	di
  4189 00000B3A 06                      	push	es
  4190                                  
  4191 00000B3B B8FFFF                  	mov	ax,0FFFFh
  4192 00000B3E 8EC0                    	mov	es,ax
  4193 00000B40 BF1000                  	mov	di,10h
  4194                                  	;mov	cx,(EndVDiskHMAHead-VDiskHMAHead)
  4195 00000B43 B92000                  	mov	cx,32
  4196 00000B46 BE[D40A]                	mov	si,VDiskHMAHead
  4197 00000B49 F3A4                    	rep	movsb			; ds already set to cs
  4198                                  
  4199 00000B4B 5F                      	pop	di
  4200 00000B4C 07                      	pop	es
  4201                                  
  4202 00000B4D C3                      	retn
  4203                                  
  4204                                  ; ----------------------------------------------------------------------
  4205                                  ; procedure : ClrVDISKHeader
  4206                                  ;
  4207                                  ;		Clears the first 32 bytes at 1MB boundary
  4208                                  ;		So that DOS/HIMEM is not confused about the VDISK header
  4209                                  ;		left by previous DOS=HIGH session
  4210                                  ;
  4211                                  ; ----------------------------------------------------------------------
  4212                                  
  4213                                  struc desc
  4214 00000000 ????                     .seg_lim:	resw	1		; seg limit 64K 
  4215 00000002 ????                     .lo_word:	resw	1		; 24 bit seg physical 
  4216 00000004 ??                       .hi_byte:	resb 	1		; address
  4217 00000005 ??                       .acc_rights:	resb	1		; access rights ( CPL0 - R/W )
  4218 00000006 ????                     .reserved:	resw	1		;
  4219                                   .size:
  4220                                  endstruc
  4221                                  
  4222                                  		; 23/10/2022
  4223                                  bmove:		;label byte
  4224                                  
  4225                                  dummy:		;times desc.size db 0	; desc	<>
  4226 00000B4E 00<rep 8h>              		times 8 db 0		 
  4227                                  gdt:		;times desc.size db 0	; desc	<>
  4228 00000B56 00<rep 8h>              		times 8 db 0
  4229 00000B5E FFFF                    src_desc:	dw	0FFFFh		; desc	<0ffffh,0,0,93h,0>
  4230 00000B60 0000                    		dw	0
  4231 00000B62 00                      		db	0
  4232 00000B63 93                      		db	93h
  4233 00000B64 0000                    		dw	0
  4234 00000B66 FFFF                    tgt_desc:	dw	0FFFFh		; desc	<0ffffh,0,10h,93h,0>  ; 1MB
  4235 00000B68 0000                    		dw	0
  4236 00000B6A 10                      		db	10h
  4237 00000B6B 93                      		db	93h
  4238 00000B6C 0000                    		dw	0
  4239                                  
  4240                                  rombios_code:	;times desc.size db 0	; desc	<>
  4241 00000B6E 00<rep 8h>              		times 8 db 0
  4242                                  temp_stack:	;times desc.size db 0	; desc	<>
  4243 00000B76 00<rep 8h>              		times 8 db 0
  4244                                  
  4245 00000B7E 00<rep 20h>             ClrdVDISKHead:	times 32 db 0		; db 32 dup (0)
  4246                                  
  4247                                  
  4248                                  ; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.21 IO.SYS, MSDOS 6.0 SYSINIt1.ASM)
  4249                                  
  4250                                  ClrVDISKHeader:	; proc	near
  4251                                  
  4252                                  ;;-----------------------------------------------------------	      ;I070
  4253                                  ;; The following workaround get around a problem with the	      ;I070
  4254                                  ;; Tortugas and PS/2 30-286 BIOS when password server mode	      ;I070
  4255                                  ;; is set. On those machines the INT 15h block move code	      ;I070
  4256                                  ;; goes through the 8042 to twiddle A20 instead of port 92h.	      ;I070
  4257                                  ;; In password server mode the 8042 is disabled so the block	      ;I070
  4258                                  ;; move crashes the system. We can do this because these	      ;I070
  4259                                  ;; systems clear all of memory on a cold boot.			      ;I070
  4260                                  ;								      ;I070
  4261                                  ;               in      al,64h         ; Test for password servr mode ;I070
  4262                                  ;               test    al,10h         ; Is keyboard inhibited?	      ;I070
  4263                                  ;               jnz     short ClrVDISKok ; No, go do block move.      ;I070
  4264                                  ;                                      ; Check for Tortugas...	      ;I070
  4265                                  ;               cmp     word [cs:sys_model_byte],19F8h                ;I070
  4266                                  ;               je      short ClrVDISKno                              ;I070
  4267                                  ;                                      ; Check for mod 30-286	      ;I070
  4268                                  ;               cmp     word [cs:sys_model_byte],09FCh                ;I070
  4269                                  ;               jne     short ClrVDISKok			      ;I070
  4270                                  ;ClrVDISKno: 	retn	               ; Return w/o block move.	      ;I070
  4271                                  ;								      ;I070
  4272                                  ;ClrVDISKok:							      ;I070
  4273                                  ;-----------------------------------------------------------	      ;I070
  4274                                  
  4275 00000B9E 06                      	push	es
  4276 00000B9F 8CC8                    	mov	ax,cs
  4277 00000BA1 89C2                    	mov	dx,ax
  4278 00000BA3 B10C                    	mov	cl,12
  4279 00000BA5 D3EA                    	shr	dx,cl
  4280 00000BA7 B104                    	mov	cl,4
  4281 00000BA9 D3E0                    	shl	ax,cl
  4282 00000BAB 05[7E0B]                	add	ax,ClrdVDISKHead
  4283 00000BAE 80D200                  	adc	dl,0
  4284                                  	; 23/10/2022
  4285                                  	;mov	[cs:src_desc+desc.lo_word],ax
  4286 00000BB1 2EA3[600B]              	mov	[cs:src_desc+2],ax
  4287                                  	;mov	[cs:src_desc+desc.hi_byte],dl
  4288 00000BB5 2E8816[620B]            	mov	[cs:src_desc+4],dl
  4289 00000BBA B91000                  	mov	cx,16			; 16 words
  4290 00000BBD 0E                      	push	cs
  4291 00000BBE 07                      	pop	es
  4292 00000BBF BE[4E0B]                	mov	si,bmove
  4293 00000BC2 B487                    	mov	ah,87h
  4294 00000BC4 CD15                    	int	15h	; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
  4295                                  			; CX = number of words to move 
  4296                                  			; ES:SI -> global descriptor table
  4297                                  			; Return: CF set on error, AH = status
  4298 00000BC6 07                      	pop	es
  4299 00000BC7 C3                      	retn
  4300                                  
  4301                                  ; ----------------------------------------------------------------------
  4302                                  ;
  4303                                  ; procedure : SaveFreeHMAPtr
  4304                                  ;
  4305                                  ;		Save the Free HMA pointer in BIOS variable for later use.
  4306                                  ;		(INT 2f ax==4a01 call returns pointer to free HMA)
  4307                                  ;		Normalizes the pointer to ffff:xxxx format and stores only
  4308                                  ;		the offset.
  4309                                  ;
  4310                                  ; Inputs : ES:DI - pointer to free HMA
  4311                                  ; Output : FreeHMAPtr in BIOS data segment updated
  4312                                  ;
  4313                                  ; ----------------------------------------------------------------------
  4314                                  
  4315                                  SaveFreeHMAPtr:
  4316 00000BC8 8CC3                    	mov	bx,es
  4317 00000BCA B8FFFF                  	mov	ax,0FFFFh		; HMA segment
  4318 00000BCD 29D8                    	sub	ax,bx
  4319 00000BCF 83C70F                  	add	di,15			; para round
  4320 00000BD2 83E7F0                  	and	di,0FFF0h
  4321 00000BD5 B104                    	mov	cl,4
  4322 00000BD7 D3E0                    	shl	ax,cl
  4323 00000BD9 29C7                    	sub	di,ax
  4324 00000BDB 1E                      	push	ds
  4325                                  	;;mov	ax,Bios_Data ; 0070h
  4326                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
  4327                                  	; 21/10/2022
  4328 00000BDC B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  4329 00000BDF 8ED8                    	mov	ds,ax
  4330 00000BE1 893EF708                	mov	[FreeHMAPtr],di	 ; (ds:8F7h for MSDOS 6.21 IO.SYS)
  4331 00000BE5 C6060D00FF              	mov	byte [inHMA],0FFh  ; (ds:0Dh)
  4332 00000BEA 1F                      	pop	ds
  4333 00000BEB C3                      	retn
  4334                                  
  4335                                  ; ----------------------------------------------------------------------
  4336                                  ;
  4337                                  ; procedure : IsVDiskInstalled
  4338                                  ;
  4339                                  ;		Checks for the presence of VDISK header at 1MB boundary
  4340                                  ;		& INT 19 vector
  4341                                  ;
  4342                                  ; Inputs  : A20 flag should be ON
  4343                                  ; Outputs : Zero set if VDISK header found else Zero cleared
  4344                                  ;
  4345                                  ; ----------------------------------------------------------------------
  4346                                  
  4347                                  IsVDiskInstalled:
  4348 00000BEC 31C0                    	xor	ax,ax
  4349 00000BEE 8ED8                    	mov	ds,ax
  4350 00000BF0 8E1E4E00                	mov	ds,[19*4+2]
  4351                                  	;mov	si,VDiskSig1-StartVDHead ; 12h
  4352                                  	; 23/10/2022
  4353 00000BF4 BE1200                  	mov	si,18
  4354                                  	;mov	cx,VLEN1 ; 5
  4355 00000BF7 B90500                  	mov	cx,5
  4356 00000BFA 0E                      	push	cs
  4357 00000BFB 07                      	pop	es
  4358 00000BFC BF[B20A]                	mov	di,VDiskSig1
  4359 00000BFF F3A6                    	rep	cmpsb
  4360 00000C01 7410                    	je	short ivdins_retn
  4361 00000C03 B8FFFF                  	mov	ax,0FFFFh
  4362 00000C06 8ED8                    	mov	ds,ax
  4363                                  	;mov	si,10h+(VDiskSig2-VDiskHMAHead) ; 13h
  4364 00000C08 BE1300                  	mov	si,13h
  4365 00000C0B BF[D70A]                	mov	di,VDiskSig2
  4366                                  	;mov	cx,VLEN2  ; 5
  4367 00000C0E B90500                  	mov	cx,5
  4368 00000C11 F3A6                    	rep	cmpsb
  4369                                  ivdins_retn: 
  4370 00000C13 C3                      	retn			; returns the Zero flag
  4371                                  
  4372                                  ; ----------------------------------------------------------------------
  4373                                  ;
  4374                                  ; procedure : CPMHack
  4375                                  ;
  4376                                  ;		Copies the code from 0:c0 into ffff:0d0h
  4377                                  ;		for CPM compatibility
  4378                                  ;
  4379                                  ; ----------------------------------------------------------------------
  4380                                  
  4381                                  CPMHack:
  4382 00000C14 1E                      	push	ds
  4383 00000C15 B9FFFF                  	mov	cx,0FFFFh
  4384 00000C18 8EC1                    	mov	es,cx		; ES = FFFF
  4385 00000C1A 31C9                    	xor	cx,cx
  4386 00000C1C 8ED9                    	mov	ds,cx		; DS = 0
  4387 00000C1E BEC000                  	mov	si,0C0h
  4388 00000C21 BFD000                  	mov	di,0D0h
  4389 00000C24 B90500                  	mov	cx,5
  4390 00000C27 FC                      	cld
  4391 00000C28 F3A4                    	rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
  4392 00000C2A 1F                      	pop	ds
  4393 00000C2B C3                      	retn
  4394                                  
  4395                                  ; ----------------------------------------------------------------------
  4396                                  ;
  4397                                  ; procedure : off_to_para
  4398                                  ;
  4399                                  ; ----------------------------------------------------------------------
  4400                                  off_to_para:
  4401 00000C2C D1E8                    	shr	ax,1
  4402 00000C2E D1E8                    	shr	ax,1
  4403 00000C30 D1E8                    	shr	ax,1
  4404 00000C32 D1E8                    	shr	ax,1
  4405 00000C34 C3                      	retn
  4406                                  
  4407                                  ; ----------------------------------------------------------------------
  4408                                  ;**	TempCDS - Create (Temporary?) CDS
  4409                                  ;
  4410                                  ;	ENTRY	?? BUGBUG
  4411                                  ;		(DS) = SysInitSeg
  4412                                  ;	EXIT	?? BUGBUG
  4413                                  ;	USES	?? BUGBUG
  4414                                  ; ----------------------------------------------------------------------
  4415                                  
  4416                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4417                                  TempCDS:
  4418 00000C35 C43E[6B02]              	les	di,[DOSINFO]
  4419 00000C39 268A4D20                	mov	cl,[es:di+SYSI_NUMIO]
  4420                                  	;mov	cl, [es:di+20h]
  4421 00000C3D 30ED                    	xor	ch,ch			; (cx) = # of block devices
  4422                                  
  4423 00000C3F 26884D21                	mov	[es:di+SYSI_NCDS],cl	; one CDS per device
  4424                                  	;mov	[es:di+21h],cl	
  4425                                  
  4426 00000C43 88C8                    	mov	al,cl
  4427 00000C45 B458                    	mov	ah,curdirlen ; curdir_list.size ; 88
  4428                                  	;mov	ah,88
  4429 00000C47 F6E4                    	mul	ah			; (ax) = byte size for those CDSs
  4430 00000C49 E80405                  	call	ParaRound		; (ax) = paragraph size for CDSs
  4431 00000C4C 8B36[A102]              	mov	si,[top_of_cdss]
  4432                                  
  4433                                  ;	BUGBUG - we don't update confbot - won't someone else use it?
  4434                                  ;	chuckst -- answer: no. Confbot is used to access the CDSs,
  4435                                  ;	25 jul 92  which are stored BELOW it. Alloclim is the
  4436                                  ;		   variable which has the top of free memory for
  4437                                  ;		   device driver loads, etc.
  4438                                  
  4439 00000C50 29C6                    	sub	si,ax
  4440                                  
  4441                                  ;	chuckst, 25 Jul 92 -- note: I'm removing the code here
  4442                                  ;		that automatically updates alloclim every time we
  4443                                  ;		set up some new CDSs. Instead, I've added code
  4444                                  ;		which pre-allocates space for 26 CDSs. This
  4445                                  ;	        way we've got room for worst case CDSs before
  4446                                  ;		we place MagicDrv.sys
  4447                                  ;
  4448                                  ;	mov	[ALLOCLIM],si		; can't alloc past here!
  4449                                  
  4450                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  4451                                  	; (SYSINIT:0C52h)
  4452 00000C52 8936[A302]              	mov	[ALLOCLIM],si
  4453                                  
  4454 00000C56 26897518                	mov	[es:di+SYSI_CDS+2],si
  4455                                  	;mov	[es:di+18h],si
  4456 00000C5A 89F0                    	mov	ax,si
  4457 00000C5C 26C745160000            	mov	word [es:di+SYSI_CDS],0	; set address of CDS list
  4458                                  	;mov	[word es:di+16h],0
  4459                                  	;lds	si,[es:di+SYSI_DPB]	; (ds:si) = address of first DPB
  4460 00000C62 26C535                  	lds	si,[es:di]
  4461 00000C65 8EC0                    	mov	es,ax
  4462 00000C67 31FF                    	xor	di,di			; (es:di) = address of 1st CDS
  4463                                  
  4464                                  ;*	Initialize our temporary CDSs. We'll init each CDS with the
  4465                                  ;	info from the corresponding DPB.
  4466                                  ;
  4467                                  ;	(cx) = count of CDSs left to process
  4468                                  ;	(es:di) = address of next CDS
  4469                                  
  4470                                  fooset:
  4471                                  	; 23/10/2022
  4472 00000C69 2EA1[A502]              	mov	ax, [cs:DirStrng] ; "A:"
  4473 00000C6D AB                      	stosw				; setup the root as the curdir
  4474                                  
  4475                                  	;call	get_dpb_for_drive_al	; get dpb for drive in dpb
  4476                                  
  4477                                  ;	(ds:si) = address of DPB
  4478                                  ;		    (si) = -1 if no drive
  4479                                  
  4480 00000C6E 2EA1[A702]              	mov	ax,[cs:DirStrng+2] ; "\",0
  4481 00000C72 AB                      	stosw
  4482 00000C73 2EFE06[A502]            	inc	byte [cs:DirStrng]
  4483 00000C78 31C0                    	xor	ax,ax
  4484 00000C7A 51                      	push	cx
  4485                                  	;mov	cx,curdir_list.cdir_flags - 4 ; 63
  4486 00000C7B B93F00                  	mov	cx,63	; 23/10/2022
  4487 00000C7E F3AA                    	rep	stosb			; zero out rest of CURDIR_TEXTs
  4488                                  
  4489                                  ;	should handle the system that does not have any floppies.
  4490                                  ;	in this case,we are going to pretended there are two dummy floppies
  4491                                  ;	in the system. still they have dpb and cds,but we are going to
  4492                                  ;	0 out curdir_flags,curdir_devptr of cds so ibmdos can issue
  4493                                  ;	"invalid drive specification" message when the user try to
  4494                                  ;	access them.
  4495                                  ;
  4496                                  ;	(ax) = 0
  4497                                  ;	(es:di) = CURDIR_FLAGS in the CDS records
  4498                                  ;	(ds:si) = Next DPB (-1 if none)
  4499                                  
  4500 00000C80 83FEFF                  	cmp	si,-1	; cmp si,0FFFFh
  4501 00000C83 7414                    	je	short fooset_zero	; don't have any physical drive.
  4502                                  
  4503                                  ;	check to see if we are faking floppy drives. if not go to normcds.
  4504                                  ;	if we are faking floppy drives then see if this cds being initialised
  4505                                  ;	is for drive a: or b: by checking the appropriate field in the dpb
  4506                                  ;	pointed to by ds:si. if not for a: or b: then go to normcds. if
  4507                                  ;	for a: or b: then execute the code given below starting at fooset_zero.
  4508                                  ;	for dpb offsets look at inc\dpb.inc.
  4509                                  
  4510 00000C85 2E803E[8902]01          	cmp	byte [cs:fake_floppy_drv],1
  4511 00000C8B 7513                    	jne	short normcds 		; machine has floppy drives
  4512                                  	;cmp	byte [si+DPB.drive],1	; if dpb_drive = 0 (a) or 1 (b).
  4513 00000C8D 803C01                  	cmp	byte [si],1
  4514 00000C90 770E                    	ja	short normcds
  4515 00000C92 B103                    	mov	cl,3			; the next dbp pointer
  4516                                  					; AX should be zero here
  4517 00000C94 F3AB                    	rep	stosw
  4518 00000C96 59                      	pop	cx
  4519 00000C97 EB18                    	jmp	short get_next_dpb
  4520                                  
  4521                                  ;	(ax) = 0
  4522                                  
  4523                                  fooset_zero:
  4524 00000C99 B103                    	mov	cl,3
  4525 00000C9B F3AB                    	rep	stosw
  4526 00000C9D 59                      	pop	cx
  4527 00000C9E EB14                    	jmp	short fincds
  4528                                  
  4529                                  ;*	We have a "normal" DPB and thus a normal CDS.
  4530                                  ;
  4531                                  ;	(ax) = 0
  4532                                  ;	(es:di) = CURDIR_FLAGS in the CDS records
  4533                                  ;	(ds:si) = Next DPB (-1 if none)
  4534                                  
  4535                                  normcds:
  4536 00000CA0 59                      	pop	cx
  4537                                  
  4538                                  ;	if a non-fat based media is detected (by dpb.numberoffat == 0), then
  4539                                  ;	set curdir_flags to 0. this is for signaling ibmdos and ifsfunc that
  4540                                  ;	this media is a non-fat based one.
  4541                                  
  4542                                  	;cmp	byte [si+DPB.FAT_COUNT],0 ; non fat system?
  4543                                  	; 23/10/2022
  4544 00000CA1 807C0800                	cmp	byte [si+8], 0
  4545 00000CA5 7403                    	je	short setnormcds	; yes. set curdir_flags to 0. ax = 0 now.
  4546 00000CA7 B80040                  	mov	ax,curdir_inuse ; 4000h	; else,fat system. set the flag to curdir_inuse.
  4547                                  	;mov	ax,4000h
  4548                                  setnormcds:
  4549 00000CAA AB                      	stosw				; curdir_flags
  4550 00000CAB 89F0                    	mov	ax,si
  4551 00000CAD AB                      	stosw				; curdir_devptr
  4552 00000CAE 8CD8                    	mov	ax,ds
  4553 00000CB0 AB                      	stosw
  4554                                  
  4555                                  get_next_dpb:				; entry point for fake_fooset_zero
  4556                                  	; 23/10/2022
  4557 00000CB1 C57419                  	lds	si,[si+19h]
  4558                                  	;lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
  4559                                  fincds:
  4560 00000CB4 B8FFFF                  	mov	ax,-1	; mov ax,0FFFFh
  4561 00000CB7 AB                      	stosw				; curdir_id
  4562 00000CB8 AB                      	stosw				; curdir_id
  4563 00000CB9 AB                      	stosw				; curdir_user_word
  4564 00000CBA B80200                  	mov	ax,2
  4565 00000CBD AB                      	stosw				; curdir_end
  4566 00000CBE B000                    	mov	al,0			; clear out 7 bytes (curdir_type,
  4567 00000CC0 AA                      	stosb
  4568 00000CC1 AB                      	stosw				;  curdir_ifs_hdr,curdir_fsda)
  4569 00000CC2 AB                      	stosw
  4570 00000CC3 AB                      	stosw
  4571                                  
  4572 00000CC4 E2A3                    	loop	fooset
  4573                                  	
  4574 00000CC6 2EC606[A502]41          	mov	byte [cs:DirStrng],"A"	; "A:\"
  4575                                  	
  4576 00000CCC C3                      	retn
  4577                                  
  4578                                  ; ----------------------------------------------------------------------
  4579                                  ;***	get_dpb_for_drive_al -- lookup the DPB for drive in al
  4580                                  ;
  4581                                  ;	entry:
  4582                                  ;	   al == ASCII CAPS drive letter
  4583                                  ;
  4584                                  ;	exit:
  4585                                  ;	   ds:si -> DPB, or si = -1 if not found
  4586                                  ; ----------------------------------------------------------------------
  4587                                  
  4588                                  ;	; 23/10/2022 (get_dpb_for_drive_al
  4589                                  ;
  4590                                  ;get_dpb_for_drive_al:
  4591                                  ;	lds	si,[cs:DOSINFO]		; point to first DPB
  4592                                  ;	;lds	si,[si+SYSI_DPB]	; (ds:si) = address of first DPB
  4593                                  ;	lds	si,[si]
  4594                                  ;	sub	al,'A'
  4595                                  ;
  4596                                  ;get_dpb_for_drive_1:
  4597                                  ;	;cmp	al,[si+DPB.DRIVE]	; match?
  4598                                  ;	cmp	al,[si]
  4599                                  ;	je	short got_dpb_for_drive	;  done if so
  4600                                  ;
  4601                                  ;	lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
  4602                                  ;	cmp	si,-1
  4603                                  ;	jne	short get_dpb_for_drive_1 ; loop until hit end of DPBs
  4604                                  ;
  4605                                  ;got_dpb_for_drive:
  4606                                  ;	retn
  4607                                  
  4608                                  ;=======================================================================
  4609                                  
  4610                                  ;**	EndFile - Build DOS structures
  4611                                  ;
  4612                                  ; This procedure is called after the config.sys has been processed and
  4613                                  ; installable device drivers have been loaded (but before "install="
  4614                                  ; programs are loaded) to create the dos structures such as SFTs, buffers,
  4615                                  ; FCBs, CDSs, etc. It also loads the sysinit_base module in low memory
  4616                                  ; to allow for the safe EXECing of "install=" programs. All memory
  4617                                  ; above these structures is deallocated back to DOS.
  4618                                  ;
  4619                                  ;	ENTRY	?? BUGBUG
  4620                                  ;	EXIT	?? BUGBUG
  4621                                  ;	USES	?? BUGBUG
  4622                                  
  4623                                  ;=======================================================================
  4624                                  ; allocate files
  4625                                  ; ----------------------------------------------------------------------
  4626                                  
  4627                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4628                                  	; (SYSINIT:0CCDh)
  4629                                  
  4630                                  endfile:
  4631                                  ; we are now setting up final cdss,buffers,files,fcss strings etc. we no
  4632                                  ; longer need the space taken by the temp stuff below confbot,so set alloclim
  4633                                  ; to confbot.
  4634                                  
  4635                                  ;	if this procedure has been called to take care of install= command,
  4636                                  ;	    then we have to save es,si registers.
  4637                                  
  4638                                  	; 23/10/2022
  4639                                  	; 31/03/2019
  4640 00000CCD 1E                      	push	ds
  4641                                  
  4642                                  	;;mov	ax,Bios_Data ; 0070h
  4643                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
  4644                                  	; 21/10/2022
  4645 00000CCE B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  4646 00000CD1 8ED8                    	mov	ds,ax
  4647                                  
  4648                                  	;cmp	word [052Fh], 0
  4649 00000CD3 833E2F0500              	cmp	word [multrk_flag],multrk_off1 ;=0,multrack= command entered?
  4650 00000CD8 7506                    	jne	short multrk_flag_done
  4651                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  4652 00000CDA 810E2F058000            	or	word [multrk_flag],multrk_on ; 80h  ; default will be on.
  4653                                  	;or	byte [multrk_flag],multrk_on ; 80h
  4654                                  multrk_flag_done:
  4655                                  	; 23/10/2022
  4656                                  	; 31/03/2019
  4657 00000CE0 1F                      	pop	ds
  4658                                  
  4659                                  	;mov	ax,[cs:CONFBOT]
  4660                                  	;mov	[cs:ALLOCLIM],ax
  4661                                  	; 23/10/2022
  4662 00000CE1 2EA1[A102]              	mov	ax, [cs:top_of_cdss]
  4663 00000CE5 2EA3[A302]              	mov	[cs:ALLOCLIM], ax 
  4664                                  
  4665 00000CE9 0E                      	push	cs
  4666 00000CEA 1F                      	pop	ds
  4667                                  	
  4668                                  	;mov	ax,[CONFBOT]
  4669                                  	;mov	[ALLOCLIM],ax
  4670                                  
  4671 00000CEB E8A527                  	call	round
  4672 00000CEE 2EA0[9D02]              	mov	al,[cs:FILES]
  4673                                  	; 23/10/2022
  4674                                  	;mov	al,[FILES]
  4675 00000CF2 2C05                    	sub	al,5
  4676 00000CF4 7652                    	jbe	short dofcbs
  4677                                  
  4678 00000CF6 50                      	push	ax
  4679                                  	;mov	al,devmark_files ; 'F'
  4680 00000CF7 B046                    	mov	al,'F'
  4681 00000CF9 E83B09                  	call	setdevmark		; set devmark for sfts (files)
  4682 00000CFC 58                      	pop	ax
  4683 00000CFD 30E4                    	xor	ah,ah			; do not use cbw instruction!!!!!
  4684                                  					;  it does sign extend.
  4685                                  	;mov	bx,[memlo]
  4686                                  	;mov	dx,[memhi]
  4687                                  	;lds	di,[DOSINFO]		;get pointer to dos data
  4688                                  	; 23/10/2022
  4689 00000CFF 2E8B1E[DE03]            	mov	bx,[cs:memlo]
  4690 00000D04 2E8B16[E003]            	mov	dx,[cs:memhi]
  4691 00000D09 2EC53E[6B02]            	lds	di,[cs:DOSINFO]		
  4692                                  
  4693                                  	;lds	di,[di+SYSI_SFT]	;ds:bp points to sft
  4694 00000D0E C57D04                  	lds	di,[di+4]
  4695                                  
  4696                                  	;mov	[di+SF.SFLink],bx
  4697 00000D11 891D                    	mov	[di],bx
  4698 00000D13 895502                  	mov	[di+SF.SFLink+2],dx	;set pointer to new sft
  4699                                  
  4700 00000D16 0E                      	push	cs
  4701 00000D17 1F                      	pop	ds
  4702                                  
  4703                                  	;les	di,[memlo]		;point to new sft
  4704                                  	; 23/10/2022
  4705 00000D18 2EC43E[DE03]            	les	di,[cs:memlo]
  4706                                  
  4707                                  	;mov	word [es:di+SF.SFLink],-1
  4708 00000D1D 26C705FFFF              	mov	word [es:di],-1		; 0FFFFh
  4709                                  	;mov	[es:di+SF.SFCount],ax
  4710 00000D22 26894504                	mov	[es:di+4],ax
  4711                                  	;mov	bl,SF_ENTRY.size ; 59
  4712 00000D26 B33B                    	mov	bl,59
  4713 00000D28 F6E3                    	mul	bl			;ax = number of bytes to clear
  4714 00000D2A 89C1                    	mov	cx,ax
  4715                                  	;add	[memlo],ax		;allocate memory
  4716                                  	; 23/10/2022
  4717 00000D2C 2E0106[DE03]            	add	[cs:memlo],ax
  4718 00000D31 B80600                  	mov	ax,6
  4719                                  	;add	[memlo],ax		;remember the header too
  4720 00000D34 2E0106[DE03]            	add	[cs:memlo],ax
  4721                                  	;or	byte [setdevmarkflag],for_devmark ; 2
  4722 00000D39 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  4723 00000D3F E85127                  	call	round			; check for mem error before the stosb
  4724 00000D42 01C7                    	add	di,ax
  4725 00000D44 31C0                    	xor	ax,ax
  4726 00000D46 F3AA                    	rep	stosb			;clean out the stuff
  4727                                  
  4728                                  ; allocate fcbs
  4729                                  ; ----------------------------------------------------------------------
  4730                                  
  4731                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4732                                  	; (SYSINIT:0D48h)
  4733                                  dofcbs:
  4734 00000D48 0E                      	push	cs
  4735 00000D49 1F                      	pop	ds
  4736 00000D4A E84627                  	call	round
  4737                                  	;mov	al,devmark_fcbs	; 'X'	;='x'
  4738 00000D4D B058                    	mov	al,'X'
  4739 00000D4F E8E508                  	call	setdevmark
  4740                                  	;mov	al,[FCBS]
  4741 00000D52 2EA0[9E02]              	mov	al,[cs:FCBS]
  4742 00000D56 30E4                    	xor	ah,ah			; do not use cbw instruction!!!!!
  4743                                  					;  it does sign extend.
  4744                                  	;mov	bx,[memlo]
  4745                                  	;mov	dx,[memhi]
  4746                                  	;lds	di,[DOSINFO]		;get pointer to dos data
  4747                                  	; 23/10/2022
  4748 00000D58 2E8B1E[DE03]            	mov	bx,[cs:memlo]
  4749 00000D5D 2E8B16[E003]            	mov	dx,[cs:memhi]
  4750 00000D62 2EC53E[6B02]            	lds	di,[cs:DOSINFO]
  4751                                  
  4752                                  	;mov	[di+SYSI_FCB],bx
  4753                                  	;mov	[di+SYSI_FCB+2],dx ;set pointer to new table
  4754                                  	; 23/10/2022
  4755 00000D67 895D1A                  	mov	[di+1Ah],bx		; [di+SYSI_FCB]
  4756 00000D6A 89551C                  	mov	[di+1Ch],dx		; [di+SYSI_FCB+2]
  4757                                  
  4758 00000D6D 2E8A1E[9F02]            	mov	bl,[cs:KEEP]
  4759 00000D72 30FF                    	xor	bh,bh
  4760                                  	;mov	[di+SYSI_KEEP],bx
  4761 00000D74 895D1E                  	mov	[di+1Eh],bx		; [di+SYSI_KEEP]	
  4762                                  
  4763 00000D77 0E                      	push	cs
  4764 00000D78 1F                      	pop	ds
  4765                                  	
  4766 00000D79 C43E[DE03]              	les	di,[memlo]		;point to new table
  4767                                  	;mov	word [es:di+SF.SFLink],-1
  4768 00000D7D 26C705FFFF              	mov	word [es:di],-1
  4769                                  	;mov	[es:di+SF.SFCount],ax
  4770                                  	; 02/11/2022
  4771 00000D82 26894504                	mov	[es:di+4],ax
  4772 00000D86 B339                    	mov	bl,SF_ENTRY.size ; 59
  4773 00000D88 89C1                    	mov	cx,ax
  4774 00000D8A F6E3                    	mul	bl			;ax = number of bytes to clear
  4775 00000D8C 0106[DE03]              	add	[memlo],ax		;allocate memory
  4776                                  	;mov	ax,6
  4777 00000D90 B80600                  	mov	ax,SF.size-2 ; 6
  4778 00000D93 0106[DE03]              	add	[memlo],ax		;remember the header too
  4779                                  	;or	byte [setdevmarkflag],for_devmark ; 2
  4780 00000D97 800E[5A16]02            	or	byte [setdevmarkflag],2
  4781 00000D9C E8F426                  	call	round			; check for mem error before the stosb
  4782 00000D9F 01C7                    	add	di,ax			;skip over header
  4783 00000DA1 B041                    	mov	al,'A'
  4784                                  fillloop:
  4785 00000DA3 51                      	push	cx			; save count
  4786 00000DA4 B93900                  	mov	cx,SF_ENTRY.size ; 59	; number of bytes to fill
  4787 00000DA7 FC                      	cld
  4788 00000DA8 F3AA                    	rep	stosb			; filled
  4789                                  
  4790                                  	;;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],0  ; [es:di-59]
  4791                                  	;;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],0   ; [es:di-38]	
  4792                                  	;;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],0 ; [es:di-36]
  4793                                  
  4794                                  	;cx = 0
  4795                                  	;mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],cx ;0  ; [es:di-59]
  4796                                  	;mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],cx ;0   ; [es:di-38]	
  4797                                  	;mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],cx ;0 ; [es:di-36]
  4798                                  	; 23/10/2022	
  4799 00000DAA 26C745C50000            	mov     word [es:di-3Bh],0
  4800 00000DB0 26C745DA0000            	mov     word [es:di-26h],0
  4801 00000DB6 26C745DC0000            	mov     word [es:di-24h],0
  4802                                  
  4803 00000DBC 59                      	pop	cx
  4804 00000DBD E2E4                    	loop	fillloop
  4805                                  
  4806                                  ; allocate buffers
  4807                                  ; ----------------------------------------------------------------------
  4808                                  
  4809                                  ; search through the list of media supported and allocate 3 buffers if the
  4810                                  ; capacity of the drive is > 360kb
  4811                                  
  4812 00000DBF 833E[9702]FF            	cmp	word [buffers],-1	; has buffers been already set?
  4813 00000DC4 7403                    	je	short dodefaultbuff
  4814 00000DC6 E99700                  	jmp	dobuff			; the user entered the buffers=.
  4815                                  
  4816                                  dodefaultbuff:
  4817 00000DC9 C706[9902]0000          	mov	word [h_buffers],0	; default is no heuristic buffers.
  4818 00000DCF C706[9702]0200          	mov	word [buffers],2	; default to 2 buffers
  4819                                  
  4820                                  	; 23/10/2022	
  4821 00000DD5 50                      	push	ax
  4822 00000DD6 1E                      	push	ds ; 26/03/2019
  4823                                  	;les	bp,[DOSINFO]		; search through the dpb's
  4824 00000DD7 2EC42E[6B02]            	les	bp,[cs:DOSINFO]
  4825                                  	;;les	bp,[es:bp+SYSI_DPB]	; get first dpb
  4826                                  	;les	bp,[es:bp]
  4827                                  	; 23/10/2022
  4828 00000DDC 26C46E00                	les	bp,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !	
  4829                                  
  4830 00000DE0 0E                      	push	cs
  4831 00000DE1 1F                      	pop	ds
  4832                                  ;SYSINIT:0DE2h:
  4833                                  nextdpb:				; test if the drive supports removeable media
  4834                                  	;;mov	bl,[es:bp+DPB.drive]
  4835                                  	;mov	bl,[es:bp]
  4836                                  	; 23/10/2022
  4837 00000DE2 268A5E00                	mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !
  4838                                  
  4839 00000DE6 FEC3                    	inc	bl
  4840                                  	;mov	ax,(IOCTL<<8)|8
  4841 00000DE8 B80844                  	mov	ax,4408h
  4842 00000DEB CD21                    	int	21h		; DOS - 2+ - IOCTL -
  4843                                  
  4844                                  ; ignore fixed disks
  4845                                  
  4846 00000DED 09C0                    	or	ax,ax			; ax is nonzero if disk is nonremoveable
  4847 00000DEF 7536                    	jnz	short nosetbuf
  4848                                  
  4849                                  ; get parameters of drive
  4850                                  
  4851 00000DF1 31DB                    	xor	bx,bx
  4852                                  	;;mov	bl,[es:bp+DPB.drive]
  4853                                  	;mov	bl,[es:bp]
  4854                                  	; 23/10/2022
  4855 00000DF3 268A5E00                	mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !
  4856                                  	
  4857 00000DF7 FEC3                    	inc	bl
  4858 00000DF9 BA[7E39]                	mov	dx,deviceparameters
  4859                                  	;mov	ax,(IOCTL<<8)|GENERIC_IOCTL
  4860 00000DFC B80D44                  	mov	ax,440Dh
  4861                                  	;mov	cx,(RAWIO<<8)|GET_DEVICE_PARAMETERS
  4862 00000DFF B96008                  	mov	cx,860h
  4863 00000E02 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  4864 00000E04 7221                    	jc	short nosetbuf		; get next dpb if driver doesn't support
  4865                                  					; generic ioctl
  4866                                  ; determine capacity of drive
  4867                                  ; media capacity = #sectors * bytes/sector
  4868                                  
  4869                                  	;mov	bx,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
  4870                                  	; 23/10/2022
  4871 00000E06 8B1E[8D39]              	mov	bx,[deviceparameters+15] ; total sectors (16 bit)
  4872                                  	
  4873                                  ; to keep the magnitude of the media capacity within a word,
  4874                                  ; scale the sector size
  4875                                  ; (ie. 1 -> 512 bytes,2 -> 1024 bytes,...)
  4876                                  
  4877                                  	;mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
  4878                                  	; 23/10/2022
  4879 00000E0A A1[8539]                	mov	ax, [deviceparameters+7] ; bytes per sector
  4880 00000E0D 31D2                    	xor	dx,dx
  4881 00000E0F B90002                  	mov	cx,512
  4882 00000E12 F7F1                    	div	cx			; scale sector size in factor of
  4883                                  					; 512 bytes
  4884                                  
  4885 00000E14 F7E3                    	mul	bx			; ax = #sectors * size factor
  4886 00000E16 09D2                    	or	dx,dx			; just in case of large floppies
  4887 00000E18 7505                    	jnz	short setbuf
  4888 00000E1A 3DD002                  	cmp	ax,720			; 720 sectors * size factor of 1
  4889 00000E1D 7608                    	jbe	short nosetbuf
  4890                                  setbuf:
  4891 00000E1F C706[9702]0300          	mov	word [buffers],3
  4892 00000E25 EB0D                    	jmp	short chk_memsize_for_buffers ; now check the memory size
  4893                                  					; for default buffer count
  4894                                  nosetbuf:
  4895                                  	; 23/10/2022
  4896                                  	;cmp	word [es:bp+DPB.NEXT_DPB],-1
  4897 00000E27 26837E19FF              	cmp	word [es:bp+19h], -1 ; 0FFFFh
  4898 00000E2C 7406                    	je	short chk_memsize_for_buffers
  4899                                  	;les	bp,[es:bp+DPB.NEXT_DPB] ; [es:bp+19h]
  4900 00000E2E 26C46E19                	les	bp,[es:bp+19h]
  4901 00000E32 EBAE                    	jmp	short nextdpb
  4902                                  
  4903                                  ;from dos 3.3,the default number of buffers will be changed according to the
  4904                                  ;memory size too.
  4905                                  ; default buffers = 2
  4906                                  ; if diskette media > 360 kb,then default buffers = 3
  4907                                  ; if memory size > 128 kb (2000h para),then default buffers = 5
  4908                                  ; if memory size > 256 kb (4000h para),then default buffers = 10
  4909                                  ; if memory size > 512 kb (8000h para),then default buffers = 15.
  4910                                  
  4911                                  chk_memsize_for_buffers:
  4912 00000E34 813E[9202]0020          	cmp	word [MEMORY_SIZE],2000h
  4913 00000E3A 7622                    	jbe	short bufset
  4914 00000E3C C706[9702]0500          	mov	word [buffers],5
  4915 00000E42 813E[9202]0040          	cmp	word [MEMORY_SIZE],4000h
  4916 00000E48 7614                    	jbe	short bufset
  4917 00000E4A C706[9702]0A00          	mov	word [buffers],10
  4918 00000E50 813E[9202]0080          	cmp	word [MEMORY_SIZE],8000h
  4919 00000E56 7606                    	jbe	short bufset
  4920 00000E58 C706[9702]0F00          	mov	word [buffers],15
  4921                                  bufset:
  4922                                  	; 23/10/2022
  4923                                  	; 26/03/2019
  4924 00000E5E 1F                      	pop	ds
  4925 00000E5F 58                      	pop	ax
  4926                                  
  4927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4928                                  ;j.k. here we should put extended stuff and new allocation scheme!!!
  4929                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  4930                                  
  4931                                  ; 26/03/2019
  4932                                  
  4933                                  ;*******************************************************************************
  4934                                  ;									       *
  4935                                  ; function: actually allocate buffers in the memory and initialize it. 	       *
  4936                                  ; input :								       *
  4937                                  ;    memhi:memlo - start of the next available memory			       *
  4938                                  ;    buffers = number of buffers					       *
  4939                                  ;    h_buffers = number of secondary buffers				       *
  4940                                  ;									       *
  4941                                  ; output:								       *
  4942                                  ;	buffinfo.cache_count - # of caches to be installed.		       *
  4943                                  ;	buffinfo set.							       *
  4944                                  ;	bufferqueue set.						       *
  4945                                  ;									       *
  4946                                  ; subroutines to be called:						       *
  4947                                  ;									       *
  4948                                  ;*******************************************************************************
  4949                                  
  4950                                  	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  4951                                  	; (SYSINIT:0E60h)
  4952                                  dobuff:
  4953                                  	; ds = cs ; 31/03/2019
  4954                                  	; 23/10/2022
  4955 00000E60 2EC51E[6B02]            	lds	bx,[cs:DOSINFO]	; ds:bx -> sysinitvar
  4956                                  	;mov	ax,[buffers] ; 31/03/2019
  4957                                  	;lds	bx,[DOSINFO]
  4958 00000E65 2EA1[9702]              	mov	ax,[cs:buffers]	; set sysi_buffers
  4959                                  	;mov	[bx+SYSI_BUFFERS],ax ; [bx+3Fh]
  4960 00000E69 89473F                  	mov	[bx+3Fh],ax
  4961 00000E6C 2EA1[9902]              	mov	ax,[cs:h_buffers]
  4962                                  	;mov	[bx+SYSI_BUFFERS+2],ax ; [bx+41h]
  4963 00000E70 894741                  	mov	[bx+41h],ax
  4964 00000E73 C55F12                  	lds	bx,[bx+12h]
  4965                                  	;lds	bx,[bx+SYSI_BUF] ; now,ds:bx -> buffinfo
  4966 00000E76 E81A26                  	call	round		; get [memhi]:[memlo]
  4967                                  	;mov	al,devmark_buf	; ='B'
  4968 00000E79 B042                    	mov	al,'B'	
  4969 00000E7B E8B907                  	call	setdevmark
  4970                                  
  4971                                  ;allocate buffers
  4972                                  
  4973 00000E7E 1E                      	push	ds			; save buffer info. ptr.
  4974 00000E7F 53                      	push	bx
  4975                                  
  4976 00000E80 E85903                  	call	set_buffer
  4977                                  
  4978 00000E83 5B                      	pop	bx
  4979 00000E84 1F                      	pop	ds
  4980                                  
  4981                                  ;now set the secondary buffer if specified.
  4982                                  
  4983 00000E85 2E833E[9902]00          	cmp	word [cs:h_buffers],0
  4984 00000E8B 742D                    	je	short xif16
  4985 00000E8D E80326                  	call	round
  4986                                  	; 23/10/2022
  4987 00000E90 2E8B0E[DE03]            	mov	cx,[cs:memlo]
  4988                                  	;mov	[bx+BUFFINF.Cache_ptr],cx  ; [bx+6]
  4989 00000E95 894F06                  	mov	[bx+6],cx
  4990 00000E98 2E8B0E[E003]            	mov	cx,[cs:memhi]
  4991                                  	;mov	[bx+BUFFINF.Cache_ptr+2],cx ; [bx+8]
  4992 00000E9D 894F08                  	mov	[bx+8],cx
  4993 00000EA0 2E8B0E[9902]            	mov	cx,[cs:h_buffers]
  4994                                  	;mov	[bx+BUFFINF.Cache_count],cx ; [bx+10]
  4995 00000EA5 894F0A                  	mov	[bx+10],cx
  4996 00000EA8 B80002                  	mov	ax,512			; 512 byte
  4997 00000EAB F7E1                    	mul	cx
  4998 00000EAD 2EA3[DE03]              	mov	[cs:memlo],ax
  4999                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
  5000 00000EB1 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  5001 00000EB7 E8D925                  	call	round
  5002                                  xif16:
  5003                                  
  5004                                  ; ----------------------------------------------------------------------
  5005                                  ; allocate cdss
  5006                                  ; ----------------------------------------------------------------------
  5007                                  
  5008                                  buf1:
  5009 00000EBA E8D625                  	call	round
  5010                                  
  5011 00000EBD 50                      	push	ax
  5012                                  	; 23/10/2022
  5013                                  	;mov	ax,devmark_cds		;='L'
  5014 00000EBE B84C00                  	mov	ax, 'L'
  5015 00000EC1 E87307                  	call	setdevmark
  5016 00000EC4 58                      	pop	ax
  5017                                  
  5018 00000EC5 2EC43E[6B02]            	les	di,[cs:DOSINFO]
  5019                                  	;mov	cl,[es:di+SYSI_NUMIO]
  5020 00000ECA 268A4D20                	mov	cl,[es:di+20h]
  5021 00000ECE 2E3A0E[A002]            	cmp	cl,[cs:NUM_CDS]
  5022 00000ED3 7305                    	jae	short gotncds 		; user setting must be at least numio
  5023 00000ED5 2E8A0E[A002]            	mov	cl,[cs:NUM_CDS]
  5024                                  gotncds:
  5025 00000EDA 30ED                    	xor	ch,ch
  5026                                  	;mov	[es:di+SYSI_NCDS],cl	; [es:di+33]
  5027 00000EDC 26884D21                	mov	[es:di+21h],cl
  5028 00000EE0 2EA1[E003]              	mov	ax,[cs:memhi]
  5029                                  	;mov	[es:di+SYSI_CDS+2],ax
  5030 00000EE4 26894518                	mov	[es:di+18h],ax
  5031 00000EE8 2EA1[DE03]              	mov	ax,[cs:memlo]
  5032                                  	;mov	[es:di+SYSI_CDS],ax
  5033 00000EEC 26894516                	mov	[es:di+16h],ax
  5034 00000EF0 88C8                    	mov	al,cl
  5035                                  	;mov	ah,curdirlen ; curdir_list.size
  5036 00000EF2 B458                    	mov	ah,88
  5037 00000EF4 F6E4                    	mul	ah
  5038 00000EF6 E85702                  	call	ParaRound
  5039 00000EF9 2E0106[E003]            	add	[cs:memhi],ax
  5040                                  
  5041                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
  5042 00000EFE 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  5043 00000F04 E88C25                  	call	round			; check for mem error before initializing
  5044                                  	;lds	si,[es:di+SYSI_DPB] ; [es:di+0]
  5045 00000F07 26C535                  	lds	si,[es:di]
  5046                                  	;les	di,[es:di+SYSI_CDS] ; [es:di+22]
  5047 00000F0A 26C47D16                	les	di,[es:di+16h]
  5048 00000F0E E858FD                  	call	fooset
  5049                                  
  5050                                  ; ----------------------------------------------------------------------
  5051                                  ; allocate space for internal stack
  5052                                  ; ----------------------------------------------------------------------
  5053                                  
  5054 00000F11 0E                      	push	cs
  5055 00000F12 1F                      	pop	ds
  5056                                  
  5057                                  ;	if the user did not entered stacks= command, as a default, do not install
  5058                                  ;	sytem stacks for pc1,pc xt,pc portable cases.
  5059                                  ;	otherwise,install it to the user specified value or to the default
  5060                                  ;	value of 9,128 for other systems.
  5061                                  
  5062 00000F13 833E[8E02]FF            	cmp	word [stack_addr],-1 ; has the user entered "stacks=" command?
  5063 00000F18 740E                    	je	short doinstallstack	; then install as specified by the user
  5064 00000F1A 803E[3803]00            	cmp	byte [sys_scnd_model_byte],0 ; pc1,xt has the secondary model byte = 0
  5065 00000F1F 7507                    	jne	short doinstallstack	; other model should have default stack of 9,128
  5066 00000F21 803E[3703]FE            	cmp	byte [sys_model_byte],0FEh ; pc1, pc/xt or pc portable ?
  5067 00000F26 7371                    	jae	short skipstack
  5068                                  doinstallstack:
  5069 00000F28 A1[8A02]                	mov	ax,[stack_count]	; stack_count = 0?
  5070 00000F2B 09C0                    	or	ax,ax			; then, stack size must be 0 too.
  5071 00000F2D 746A                    	jz	short skipstack		; don't install stack.
  5072                                  
  5073                                  ;	dynamic relocation of stack code.
  5074                                  
  5075 00000F2F E86125                  	call	round			;[memhi] = seg. for stack code
  5076                                  					;[memlo] = 0
  5077                                  
  5078                                  ; set devmark block into memory for mem command
  5079                                  ; devmark_id = 's' for stack
  5080                                  
  5081                                  	;mov	al,devmark_stk	;='S'
  5082                                  	; 23/10/2022
  5083 00000F32 B053                    	mov	al,'S'
  5084 00000F34 E80007                  	call	setdevmark
  5085                                  
  5086 00000F37 A1[E003]                	mov	ax,[memhi]
  5087 00000F3A 8EC0                    	mov	es,ax		;es -> seg. the stack code is going to move.
  5088                                  	;push	cs
  5089                                  	;pop	ds
  5090                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5091 00000F3C 0E                      	push	cs
  5092 00000F3D 1F                      	pop	ds
  5093 00000F3E 31F6                    	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
  5094 00000F40 31FF                    	xor	di,di
  5095 00000F42 B9[6702]                	mov	cx,endstackcode
  5096 00000F45 890E[DE03]              	mov	[memlo],cx
  5097 00000F49 E84725                  	call	round		;have enough space for relocation?
  5098 00000F4C F3A4                    	rep	movsb
  5099                                  
  5100 00000F4E 1E                      	push	ds		; stick the location of the NextStack entry
  5101                                  	;;mov	ax,Bios_Data	; into the Win386 Instance Data tables
  5102                                  	;mov	ax,KERNEL_SEGMENT ; 70h
  5103                                  	; 21/10/2022
  5104 00000F4F B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  5105 00000F52 8ED8                    	mov	ds,ax
  5106 00000F54 C706C008[1000]          	mov	word [NextStack],nextentry ; (8C0h for MSDOS 6.21 IO.SYS)
  5107 00000F5A 8C06C208                	mov	[NextStack+2],es	   ; (8C2h for MSDOS 6.21 IO.SYS)
  5108                                  
  5109 00000F5E 2EA1[DE03]              	mov	ax,[cs:memlo]
  5110 00000F62 2EA3[8E02]              	mov	[cs:stack_addr],ax ;set for stack area initialization
  5111 00000F66 A3C608                  	mov	[IT_StackLoc],ax ; pass it as Instance Data, too
  5112 00000F69 2EA1[E003]              	mov	ax,[cs:memhi]	;this will be used by stack_init routine.
  5113 00000F6D 2EA3[9002]              	mov	[cs:stack_addr+2],ax
  5114 00000F71 A3C808                  	mov	[IT_StackLoc+2],ax
  5115                                  
  5116                                  ;	space for internal stack area = stack_count(entrysize + stack_size)
  5117                                  
  5118                                  	;mov	ax,entrysize ; mov ax,8
  5119                                  	; 23/10/2022
  5120 00000F74 B80800                  	mov	ax,8
  5121 00000F77 2E0306[8C02]            	add	ax,[cs:stack_size]
  5122 00000F7C 2EF726[8A02]            	mul	word [cs:stack_count]
  5123                                  
  5124 00000F81 A3CA08                  	mov	[IT_StackSize],ax ; pass through to Instance Tables
  5125                                  
  5126 00000F84 1F                      	pop	ds		; no more need to access Instance Table
  5127                                  
  5128 00000F85 E8C801                  	call	ParaRound	; convert size to paragraphs
  5129 00000F88 2E0106[E003]            	add	[cs:memhi],ax
  5130                                  	;add	[memhi],ax
  5131                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
  5132 00000F8D 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  5133                                  	;or	byte [setdevmarkflag],for_devmark 
  5134                                  				;to set the devmark_size for stack by round routine.
  5135 00000F93 E8FD24                  	call	round		; check for memory error before
  5136                                  				; continuing
  5137 00000F96 E8EE02                  	call	stackinit	; initialize hardware stack. 
  5138                                  				; cs=ds=sysinitseg,es=relocated stack code & data
  5139                                  skipstack:
  5140                                  	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  5141                                  	; (SYSINIT:0F99h)
  5142                                  
  5143 00000F99 0E                      	push	cs
  5144 00000F9A 1F                      	pop	ds
  5145                                  
  5146 00000F9B A0[9D02]                	mov	al,[FILES]
  5147 00000F9E 30E4                    	xor	ah,ah		; do not use cbw instruction!!!!!
  5148                                  				;  it does sign extend.
  5149 00000FA0 89C1                    	mov	cx,ax
  5150 00000FA2 31DB                    	xor	bx,bx		;close standard input
  5151 00000FA4 B43E                    	mov	ah,3Eh ; CLOSE
  5152 00000FA6 CD21                    	int	21h
  5153 00000FA8 BB0200                  	mov	bx,2
  5154                                  rcclloop:			;close everybody but standard output
  5155 00000FAB B43E                    	mov	ah,3Eh ; CLOSE	; need output so we can print message
  5156 00000FAD CD21                    	int	21h		; in case we can't get new one open.
  5157 00000FAF 43                      	inc	bx
  5158 00000FB0 E2F9                    	loop	rcclloop
  5159                                  
  5160 00000FB2 BA[0838]                	mov	dx,condev
  5161 00000FB5 B002                    	mov	al,2
  5162 00000FB7 B43D                    	mov	ah,3Dh ; OPEN 	;open con for read/write
  5163 00000FB9 F9                      	stc			; set for possible int 24
  5164 00000FBA CD21                    	int	21h
  5165 00000FBC 7305                    	jnc	short goaux
  5166 00000FBE E87027                  	call	badfil
  5167 00000FC1 EB13                    	jmp	short goaux2
  5168                                  goaux:	
  5169 00000FC3 50                      	push	ax
  5170 00000FC4 BB0100                  	mov	bx,1		;close standard output
  5171 00000FC7 B43E                    	mov	ah,3Eh ; CLOSE
  5172 00000FC9 CD21                    	int	21h
  5173 00000FCB 58                      	pop	ax
  5174                                  
  5175 00000FCC 89C3                    	mov	bx,ax		;new device handle
  5176 00000FCE B445                    	mov	ah,45h ; XDUP
  5177 00000FD0 CD21                    	int	21h		;dup to 1,stdout
  5178 00000FD2 B445                    	mov	ah,45h ; XDUP
  5179 00000FD4 CD21                    	int	21h		;dup to 2,stderr
  5180                                  goaux2: 
  5181 00000FD6 BA[0C38]                	mov	dx,auxdev
  5182 00000FD9 B002                    	mov	al,2		;read/write access
  5183 00000FDB E88627                  	call	open_dev
  5184                                  
  5185 00000FDE BA[1038]                	mov	dx,prndev
  5186 00000FE1 B001                    	mov	al,1		;write only
  5187 00000FE3 E87E27                  	call	open_dev
  5188                                  
  5189                                  ;global rearm command for shared interrupt devices attached in the system;
  5190                                  ;shared interrupt attachment has some problem when it issues interrupt
  5191                                  ;during a warm reboot. once the interrupt is presented by the attachment,
  5192                                  ;no further interrupts on that level will be presented until a global rearm
  5193                                  ;is issued. by the request of the system architecture group, msbio will
  5194                                  ;issue a global rearm after every device driver is loaded.
  5195                                  ;to issue a global rearm:	;for pc1,xt,palace
  5196                                  ;
  5197                                  ;			  out 02f2h,xx  ; interrupt level 2
  5198                                  ;			  out 02f3h,xx  ; interrupt level 3
  5199                                  ;			  out 02f4h,xx  ; interrupt level 4
  5200                                  ;			  out 02f5h,xx  ; interrupt level 5
  5201                                  ;			  out 02f6h,xx  ; interrupt level 6
  5202                                  ;			  out 02f7h,xx  ; interrupt level 7
  5203                                  ;
  5204                                  ;	for pc at,in addition to the above commands,
  5205                                  ;	need to handle the secondary interrupt handler
  5206                                  ;
  5207                                  ;			  out 06f2h,xx  ; interrupt level 10
  5208                                  ;			  out 06f3h,xx  ; interrupt level 11
  5209                                  ;			  out 06f4h,xx  ; interrupt level 12
  5210                                  ;			  out 06f6h,xx  ; interrupt level 14
  5211                                  ;			  out 06f7h,xx  ; interrupt level 15
  5212                                  ;
  5213                                  ;	for round-up machine
  5214                                  ;
  5215                                  ;			  none.
  5216                                  
  5217                                  ; where xx stands for any value.
  5218                                  ;
  5219                                  ; for your information,after naples level machine,the system service bios
  5220                                  ; call (int 15h),function ah=0c0h returns the system configuration parameters
  5221                                  
  5222                                  	; 24/10/2022
  5223                                  
  5224 00000FE6 50                      	push	ax
  5225 00000FE7 53                      	push	bx
  5226 00000FE8 52                      	push	dx
  5227 00000FE9 06                      	push	es
  5228                                  
  5229 00000FEA B0FF                    	mov	al,0FFh 		;reset h/w by writing to port
  5230 00000FEC BAF202                  	mov	dx,2F2h 		;get starting address
  5231 00000FEF EE                      	out	dx,al			; out 02f2h,0ffh
  5232 00000FF0 42                      	inc	dx
  5233 00000FF1 EE                      	out	dx,al			; out 02f3h,0ffh
  5234 00000FF2 42                      	inc	dx
  5235 00000FF3 EE                      	out	dx,al			; out 02f4h,0ffh
  5236 00000FF4 42                      	inc	dx
  5237 00000FF5 EE                      	out	dx,al			; out 02f5h,0ffh
  5238 00000FF6 42                      	inc	dx
  5239 00000FF7 EE                      	out	dx,al			; out 02f6h,0ffh
  5240 00000FF8 42                      	inc	dx
  5241 00000FF9 EE                      	out	dx,al			; out 02f7h,0ffh
  5242                                  
  5243                                  ;sb secondary global rearm
  5244                                  
  5245 00000FFA B800F0                  	mov	ax,0F000h		;get machine type
  5246 00000FFD 8EC0                    	mov	es,ax
  5247 00000FFF 26803EFEFFFC            	cmp	byte [es:0FFFEh],0FCh ;q:is it a at type machine
  5248 00001005 740D                    	je	short startrearm	; *if at no need to check
  5249                                  
  5250 00001007 B4C0                    	mov	ah,0C0h 		;get system configuration
  5251 00001009 CD15                    	int	15h			; *
  5252 0000100B 7216                    	jc	short finishrearm	; *jmp if old rom
  5253                                  
  5254                                  ; test feature byte for secondary interrupt controller
  5255                                  
  5256 0000100D 26F6470540              	test	byte [es:bx+5],40h
  5257                                  	; 24/10/2022
  5258                                  	;test	byte [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],ScndIntController
  5259 00001012 740F                    	je	short finishrearm	;jmp if it is there
  5260                                  
  5261                                  startrearm:
  5262 00001014 B0FF                    	mov	al,0FFh 		;write any pattern to port
  5263 00001016 BAF206                  	mov	dx,6F2h 		;get starting address
  5264 00001019 EE                      	out	dx,al			;out 06f2h,0ffh
  5265 0000101A 42                      	inc	dx			;bump address
  5266 0000101B EE                      	out	dx,al			;out 06f3h,0ffh
  5267 0000101C 42                      	inc	dx			;bump address
  5268 0000101D EE                      	out	dx,al			;out 06f4h,0ffh
  5269 0000101E 42                      	inc	dx			;bump address
  5270 0000101F 42                      	inc	dx			;bump address
  5271 00001020 EE                      	out	dx,al			;out 06f6h,0ffh
  5272 00001021 42                      	inc	dx			;bump address
  5273 00001022 EE                      	out	dx,al			;out 06f7h,0ffh
  5274                                  
  5275                                  finishrearm:
  5276 00001023 07                      	pop	es
  5277 00001024 5A                      	pop	dx
  5278 00001025 5B                      	pop	bx
  5279 00001026 58                      	pop	ax
  5280                                  
  5281                                  ;    global rearm end *******************
  5282                                  
  5283                                  ; ----------------------------------------------------------------------
  5284                                  ; allocate sysinit_base for install= command
  5285                                  ; ----------------------------------------------------------------------
  5286                                  ; sysinit_base allocation.
  5287                                  ;   check if endfile has been called to handle install= command.
  5288                                  
  5289                                  set_sysinit_base:
  5290                                  
  5291                                  ; ----------------------------------------------------------------------
  5292                                  ;sysinit_base will be established in the secure area of
  5293                                  ;lower memory when it handles the first install= command.
  5294                                  ;sysinit_base is the place where the actual exec function will be called and
  5295                                  ;will check sysinit module in high memory if it is damaged by the application
  5296                                  ;program.  if sysinit module has been broken,then "memory error..." message
  5297                                  ;is displayed by sysinit_base.
  5298                                  ; ----------------------------------------------------------------------
  5299                                  
  5300                                  	; 24/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
  5301                                  	; (SYSINIT:1028h)
  5302                                  
  5303 00001027 50                      	push	ax			; set devmark for mem command
  5304 00001028 A1[E003]                	mov	ax,[memhi]
  5305 0000102B 2B06[E403]              	sub	ax,[area]
  5306 0000102F A3[DC03]                	mov	[impossible_owner_size],ax ;remember the size in case.
  5307                                  	;mov	al,devmark_inst ; 'T'
  5308 00001032 B054                    	mov	al,'T'
  5309 00001034 E80006                  	call	setdevmark
  5310 00001037 58                      	pop	ax
  5311                                  
  5312 00001038 8B3E[E003]              	mov	di,[memhi]
  5313 0000103C 8EC7                    	mov	es,di
  5314 0000103E 893E[5003]              	mov	[sysinit_base_ptr+2],di ; save this entry for the next use.
  5315 00001042 31FF                    	xor	di,di
  5316 00001044 893E[4E03]              	mov	[sysinit_base_ptr],di	; es:di -> destination.
  5317 00001048 BE[5C11]                	mov	si,sysinit_base		;ds:si -> source code to be relocated.
  5318 0000104B B98000                  	mov	cx,end_sysinit_base-sysinit_base ; 129
  5319                                  	; 24/10/2022 
  5320                                  	;mov	cx,128	; 11DCh-115Ch 	; (MSDOS 5.0 IO.SYS, SYSINIT)
  5321 0000104E 010E[DE03]              	add	[memlo],cx
  5322                                  	;or	byte cs:[setdevmarkflag],for_devmark ; 2
  5323 00001052 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  5324                                  	;or	byte [setdevmarkflag],for_devmark
  5325 00001058 E83824                  	call	round			; check mem error. also,readjust memhi for the next use.
  5326 0000105B F3A4                    	rep	movsb			; reallocate it.
  5327                                  
  5328 0000105D C706[5203][3411]        	mov	word [sysinit_ptr],sysinitptr ; returning address from
  5329 00001063 8C0E[5403]              	mov	[sysinit_ptr+2],cs	 ; sysinit_base back to sysinit.
  5330                                  	;or	word [install_flag],has_installed ; set the flag.
  5331                                  	;or	byte [install_flag],has_installed ; 2
  5332                                  	; 24/10/2022
  5333 00001067 830E[4A03]02            	or	word [install_flag],2	
  5334                                  
  5335                                  ; ----------------------------------------------------------------------
  5336                                  ; free the rest of the memory from memhi to confbot. still from confbot to
  5337                                  ; the top of the memory will be allocated for sysinit and config.sys if
  5338                                  ; have_install_cmd.
  5339                                  ; ----------------------------------------------------------------------
  5340                                  
  5341 0000106C E82424                  	call	round
  5342 0000106F 8B1E[E003]              	mov	bx,[memhi]
  5343 00001073 A1[E403]                	mov	ax,[area]
  5344 00001076 A3[DA03]                	mov	[old_area],ax		; save [area]
  5345 00001079 8EC0                    	mov	es,ax			;calc what we needed
  5346 0000107B 29C3                    	sub	bx,ax
  5347                                  	; 24/10/2022
  5348 0000107D B44A                    	mov	ah,4Ah ; SETBLOCK
  5349 0000107F CD21                    	int	21h			;give the rest back
  5350                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  5351                                  		; ES = segment address of block to change
  5352                                  		; BX = new size in paragraphs
  5353 00001081 06                      	push	es
  5354 00001082 8CC0                    	mov	ax,es
  5355 00001084 48                      	dec	ax
  5356 00001085 8EC0                    	mov	es,ax			;point to arena
  5357                                  	;mov	word [es:ARENA.OWNER],8	;set impossible owner
  5358                                  	;;mov	word [es:ARENA.NAME],4453h	; System Data
  5359                                  	;mov	word [es:ARENA.NAME],'SD'	; System Data
  5360                                  	; 24/10/2022
  5361 00001087 26C70601000800          	mov	word [es:1],8		;set impossible owner
  5362 0000108E 26C70608005344          	mov	word [es:8],'SD'	; System Data
  5363 00001095 07                      	pop	es
  5364                                  
  5365 00001096 BBFFFF                  	mov	bx,0FFFFh
  5366 00001099 B448                    	mov	ah,48h ; ALLOC
  5367 0000109B CD21                    	int	21h
  5368 0000109D B448                    	mov	ah,48h ; ALLOC
  5369 0000109F CD21                    	int	21h			; allocate the rest of the memory
  5370                                  		; DOS - 2+ - ALLOCATE MEMORY
  5371                                  		; BX = number of 16-byte paragraphs desired
  5372 000010A1 A3[E003]                	mov	[memhi],ax		; start of the allocated memory
  5373 000010A4 C706[DE03]0000          	mov	word [memlo],0		;  to be used next.
  5374                                  
  5375                                  ;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
  5376                                  ;;;; allocated.
  5377                                  ;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
  5378                                  ;;;; this time) to the top-of-the memory),here we are going to
  5379                                  ;;;; 1). "setblock" from memhi to confbot.
  5380                                  ;;;; 2). "alloc" from confbot to the top of the memory.
  5381                                  ;;;; 3). "free alloc memory" from memhi to confbot.
  5382                                  
  5383                                  ;memory allocation for sysinit,confbot module.
  5384                                  
  5385 000010AA 8EC0                    	mov	es,ax
  5386                                  	;mov	bx,[CONFBOT]
  5387                                  	; 24/10/2022
  5388 000010AC 8B1E[A102]              	mov	bx,[top_of_cdss]
  5389 000010B0 29C3                    	sub	bx,ax			; confbot - memhi
  5390 000010B2 4B                      	dec	bx			; make a room for the memory block id.
  5391 000010B3 4B                      	dec	bx			; make sure!!!.
  5392 000010B4 B44A                    	mov	ah,4Ah ; SETBLOCK
  5393 000010B6 CD21                    	int	21h			; this will free (confbot to top of memory)
  5394                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  5395                                  		; ES = segment address of block to change
  5396                                  		; BX = new size in paragraphs
  5397 000010B8 BBFFFF                  	mov	bx,0FFFFh
  5398 000010BB B448                    	mov	ah,48h ; ALLOC
  5399 000010BD CD21                    	int	21h
  5400 000010BF B448                    	mov	ah,48h ; ALLOC
  5401 000010C1 CD21                    	int	21h			; allocate (confbot to top of memory)
  5402                                  		; DOS - 2+ - ALLOCATE MEMORY
  5403                                  		; BX = number of 16-byte paragraphs desired
  5404 000010C3 A3[E403]                	mov	[area],ax		; save allocated memory segment.
  5405                                  					; need this to free this area for command.com.
  5406 000010C6 8E06[E003]              	mov	es,[memhi]
  5407 000010CA B449                    	mov	ah,49h			; free allocated memory.
  5408 000010CC CD21                    	int	21h			; free (memhi to confbot(=area))
  5409                                  		; DOS - 2+ - FREE MEMORY
  5410                                  		; ES = segment address of area to be freed
  5411                                  endfile_ret:
  5412 000010CE C3                      	retn
  5413                                  
  5414                                  ; End of "EndFile" DOS structure configuration.
  5415                                  
  5416                                  ; ----------------------------------------------------------------------
  5417                                  ; 26/03/2019 - Retro DOS v4.0
  5418                                  ; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)	
  5419                                  ; ----------------------------------------------------------------------
  5420                                  ; Do_Install_Exec
  5421                                  ;
  5422                                  ; This procedure is used to EXEC a program being loaded via the 
  5423                                  ; "install=" mechanism in config.sys. It does this by setting up
  5424                                  ; the parameters, and then jumping to sysinit_base, which has been
  5425                                  ; setup in low memory. When complete, sysinit_base will jump back
  5426                                  ; up to this procedure (if sysinit remains uncorrupted by the installed
  5427                                  ; program).
  5428                                  
  5429                                  ;SYSINIT:10CFh:
  5430                                  
  5431                                  do_install_exec:			; now,handles install= command.
  5432                                  
  5433 000010CF 56                      	push	si			; save si for config.sys again.
  5434                                  
  5435                                  ; we are going to call load/exec function.
  5436                                  ; set es:bx to the parameter block here;;;;;;;
  5437                                  ; set ds:dx to the asciiz string. remember that we already has 0
  5438                                  ; after the filename. so parameter starts after that. if next
  5439                                  ; character is a line feed (i.e. 10),then assume that the 0
  5440                                  ; we already encountered used to be a carrage return. in this
  5441                                  ; case,let's set the length to 0 which will be followed by
  5442                                  ; carridge return.
  5443                                  
  5444                                  ; es:si -> command line in config.sys. points to the first non blank
  5445                                  ;character after =.
  5446                                  
  5447 000010D0 06                      	push	es
  5448 000010D1 1E                      	push	ds
  5449 000010D2 07                      	pop	es
  5450 000010D3 1F                      	pop	ds			; es->sysinitseg,ds->confbot seg
  5451 000010D4 89F2                    	mov	dx,si			; ds:dx->file name,0 in config.sys image.
  5452                                  
  5453 000010D6 31C9                    	xor	cx,cx
  5454 000010D8 FC                      	cld
  5455 000010D9 2EC606[6D03]20          	mov	byte [cs:ldexec_start],' ' ; clear out the parm area
  5456 000010DF BF[6E03]                	mov	di,ldexec_parm
  5457                                  installfilename:			;  skip the file name
  5458 000010E2 AC                      	lodsb				;  al = ds:si; si++
  5459 000010E3 3C00                    	cmp	al,0
  5460 000010E5 7402                    	je	short got_installparm
  5461 000010E7 EBF9                    	jmp	short installfilename
  5462                                  got_installparm:			;  copy the parameters to ldexec_parm
  5463 000010E9 AC                      	lodsb
  5464 000010EA 268805                  	mov	[es:di],al
  5465 000010ED 3C0A                    	cmp	al,lf	; cmp al,0Ah	;  line feed?
  5466 000010EF 7405                    	je	short done_installparm
  5467 000010F1 FEC1                    	inc	cl			;  # of char. in the parm.
  5468 000010F3 47                      	inc	di
  5469 000010F4 EBF3                    	jmp	short got_installparm
  5470                                  done_installparm:
  5471 000010F6 2E880E[6C03]            	mov	byte [cs:ldexec_line],cl ; length of the parm.
  5472 000010FB 80F900                  	cmp	cl,0			;if no parm,then
  5473 000010FE 7506                    	jne	short install_seg_set 	; let the parm area
  5474 00001100 2EC606[6D03]0D          	mov	byte [cs:ldexec_start],cr ; 0Dh 
  5475                                  					; starts with cr.
  5476                                  install_seg_set:
  5477 00001106 2EC70600000000          	mov	word [cs:0],0		; make a null environment segment
  5478 0000110D 8CC8                    	mov	ax,cs			; by overlap jmp instruction of sysinitseg.
  5479                                  
  5480                                  ;---------------------------------------------------M067----------------
  5481                                  ;
  5482                                  ; 	the environment pointer is made 0. so the current environment ptr.
  5483                                  ; 	will be the same as pdb_environ which after dosinit is 0.
  5484                                  ;
  5485                                  ; 	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.
  5486                                  ;
  5487                                  ; 	instexe.exec0_environ need not be initialized to 0 above. It was
  5488                                  ; 	done as a fix for bug #529. The actual bug was in NLSFUNC and
  5489                                  ; 	was fixed. 
  5490                                  ;
  5491                                  ; ----------------------------------------------------------------------
  5492                                  
  5493                                  ;;ifdef   MULTI_CONFIG
  5494                                  
  5495                                  ; If there's any environment data in "config_wrkseg", pass to app
  5496                                  
  5497                                  	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
  5498                                          ;mov     cx,ax
  5499                                          ;cmp     word [cs:config_envlen],0
  5500                                          ;je      short no_envdata2
  5501                                          ;mov     cx,[cs:config_wrkseg]
  5502                                  ;no_envdata2:
  5503                                  ;;endif  ;MULTI_CONFIG
  5504                                  
  5505                                  	;mov	[cs:instexe.exec0_environ],cx ; set the environment seg.
  5506                                  	; 24/10/2022
  5507                                  	;mov	[cs:iexec.environ],cx
  5508                                  	; 02/11/2022
  5509 0000110F 2EA3[BE03]              	mov	[cs:iexec.environ],ax	
  5510                                  
  5511                                  	;mov	[cs:instexe.exec0_com_line+2],ax ; set the seg.
  5512 00001113 2EA3[C203]              	mov	[cs:iexec.ldexec_line+2],ax
  5513                                  	;mov	[cs:instexe.exec0_5c_fcb+2],ax
  5514 00001117 2EA3[C603]              	mov	[cs:iexec.ldexec_5c_fcb+2],ax
  5515                                  	;mov	[cs:instexe.exec0_6c_fcb+2],ax
  5516 0000111B 2EA3[CA03]              	mov	[cs:iexec.ldexec_6c_fcb+2],ax
  5517 0000111F E86E00                  	call	sum_up
  5518 00001122 26A3[5603]              	mov	[es:checksum],ax	; save the value of the sum
  5519 00001126 31C0                    	xor	ax,ax
  5520 00001128 B44B                    	mov	ah,4Bh ; EXEC		; load/exec
  5521 0000112A BB[BE03]                	mov	bx,instexe		; es:bx -> parm block.
  5522 0000112D 06                      	push	es			; save es,ds for load/exec
  5523 0000112E 1E                      	push	ds			; these registers will be restored in sysinit_base.
  5524 0000112F 2EFF2E[4E03]            	jmp	far [cs:sysinit_base_ptr] ; jmp to sysinit_base to execute
  5525                                  					; load/exec function and check sum.
  5526                                  
  5527                                  ;----------------------------------------
  5528                                  
  5529                                  ;j.k. this is the returning address from sysinit_base.
  5530                                  
  5531                                  	; 24/10/2022 - Retro DSOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
  5532                                  
  5533                                  sysinitptr:				; returning far address from sysinit_base
  5534 00001134 5E                      	pop	si			; restore si for config.sys file.
  5535 00001135 06                      	push	es
  5536 00001136 1E                      	push	ds
  5537 00001137 07                      	pop	es
  5538 00001138 1F                      	pop	ds			; now ds - sysinitseg,es - confbot
  5539 00001139 7307                            jnc     short install_exit_ret
  5540                                  
  5541 0000113B 56                      	push	si			; error in loading the file for install=.
  5542 0000113C E8F625                  	call	badload 		; es:si-> path,filename,0.
  5543 0000113F 5E                      	pop	si
  5544                                  
  5545                                  	; 24/10/2022
  5546 00001140 EB0D                    	jmp	short sysinitptr_retn ; (MSDOS 5.0 IO.SYS, SYSINIT:1140h)
  5547                                  
  5548                                  install_exit_ret:
  5549                                  	;retn
  5550                                  
  5551                                  	; 24/10/2022 (MSDOS 5.0 IO.SYS SYSINIT)
  5552                                  ;SYSINIT:1142h:
  5553 00001142 B44D                    	mov     ah, 4Dh
  5554 00001144 CD21                    	int     21h             ; DOS - 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
  5555 00001146 80FC03                  	cmp     ah, 3
  5556 00001149 7404                    	jz      short sysinitptr_retn
  5557 0000114B E82C19                  	call    error_line
  5558 0000114E F9                      	stc
  5559                                  sysinitptr_retn:	; (SYSINIT:114fh)
  5560 0000114F C3                      	retn		
  5561                                  
  5562                                  ; ----------------------------------------------------------------------
  5563                                  
  5564                                  ;**	ParaRound - Round Up length to paragraph multiple
  5565                                  ;
  5566                                  ;	ParaRound rounds a byte count up to a multiple of 16, then divides
  5567                                  ;	by 16 yielding a "length in paragraphs" value.
  5568                                  ;
  5569                                  ;	ENTRY	(ax) = byte length
  5570                                  ;	EXIT	(ax) = rounded up length in paragraphs
  5571                                  ;	USES	ax, flags
  5572                                  
  5573                                  ParaRound:
  5574 00001150 83C00F                  	add	ax,15
  5575 00001153 D1D8                    	rcr	ax,1
  5576 00001155 D1E8                    	shr	ax,1
  5577 00001157 D1E8                    	shr	ax,1
  5578 00001159 D1E8                    	shr	ax,1
  5579 0000115B C3                      	retn
  5580                                  
  5581                                  ; ----------------------------------------------------------------------
  5582                                  ; sysinit_base module.
  5583                                  ;
  5584                                  ; This module is relocated by the routine EndFile to a location in low
  5585                                  ; memory. It is then called by SYSINIT to perform the EXEC of programs
  5586                                  ; that are being loaded by the "install=" command. After the EXEC call
  5587                                  ; completes, this module performs a checksum on the SYSINIT code (at the
  5588                                  ; top of memory) to be sure that the EXECed program did not damage it.
  5589                                  ; If it did, then this module will print an error message and stop the
  5590                                  ; system. Otherwise, it returns control to SYSINIT.
  5591                                  ;
  5592                                  ;in: after relocation,
  5593                                  ;    ax = 4b00h - load and execute the program dos function.
  5594                                  ;    ds = confbot. segment of config.sys file image
  5595                                  ;    es = sysinitseg. segment of sysinit module itself.
  5596                                  ;    ds:dx = pointer to asciiz string of the path,filename to be executed.
  5597                                  ;    es:bx = pointer to a parameter block for load.
  5598                                  ;    SI_end (byte) - offset vaule of end of sysinit module label
  5599                                  ;    bigsize (word) - # of word from confbot to SI_end.
  5600                                  ;    chksum (word) - sum of every byte from confbot to SI_end in a
  5601                                  ;			word boundary moduler form.
  5602                                  ;    sysinit_ptr (dword ptr) - return address to sysinit module.
  5603                                  ;
  5604                                  ;note: sysinit should save necessary registers and when the control is back
  5605                                  
  5606                                  	; 24/10/2022
  5607                                  	; (SYSINIT:115Ch for MSDOS 5.0 SYSINIT)
  5608                                  sysinit_base:				
  5609 0000115C 2E8C166100              	mov	[cs:sysinit_base_ss],ss	; save stack
  5610 00001161 2E89266300              	mov	[cs:sysinit_base_sp],sp	
  5611 00001166 CD21                    	int	21h			; load/exec dos call.
  5612 00001168 2E8E166100              	mov	ss,[cs:sysinit_base_ss]	; restore stack
  5613 0000116D 2E8B266300              	mov	sp,[cs:sysinit_base_sp]
  5614 00001172 1F                      	pop	ds			; restore confbot seg
  5615 00001173 07                      	pop	es			; restore sysinitseg
  5616 00001174 7215                    	jc	short sysinit_base_end	; load/exec function failed.
  5617                                  					; at this time,i don't have to worry about
  5618                                  					; that sysinit module has been broken or not.
  5619 00001176 E81700                  	call	sum_up			; otherwise,check if it is good.
  5620 00001179 263906[5603]            	cmp	[es:checksum],ax
  5621 0000117E 740B                    	je	short sysinit_base_end
  5622                                  
  5623                                  ;	memory broken. show "memory allocation error" message and stall.
  5624                                  
  5625 00001180 B409                    	mov	ah,9
  5626 00001182 0E                      	push	cs
  5627 00001183 1F                      	pop	ds
  5628 00001184 BA6500                  	mov	dx,mem_alloc_err_msgx-sysinit_base ; 65h (for MSDOS 5.0 SYSINIT)
  5629 00001187 CD21                    	int	21h
  5630                                  		; DOS - PRINT STRING
  5631                                  		; DS:DX -> string terminated by "$"
  5632                                  	; 24/10/2022
  5633                                  _stall:  
  5634                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5635                                  	;hlt				;use HLT to minimize energy consumption
  5636 00001189 EBFE                            jmp	short _stall
  5637                                  
  5638                                  sysinit_base_end: 
  5639 0000118B 26FF2E[5203]            	jmp	far [es:sysinit_ptr]	;return back to sysinit module
  5640                                  
  5641                                  ;-------------------------------------
  5642                                  
  5643                                  sum_up:
  5644                                  
  5645                                  ;in:   es - sysinitseg.
  5646                                  ;out:  ax - result
  5647                                  ;
  5648                                  ;remark: since this routine will only check starting from "locstack" to the end of
  5649                                  ;	 sysinit segment,the data area, and the current stack area are not
  5650                                  ;	 coverd. in this sense,this check sum routine only gives a minimal
  5651                                  ;	 gaurantee to be safe.
  5652                                  ;
  5653                                  ;first sum up confbot seg.
  5654                                  
  5655 00001190 1E                      	push	ds
  5656                                  	;mov	ax,[es:CONFBOT]
  5657                                  	; 24/10/2022
  5658 00001191 26A1[A102]              	mov	ax,[es:top_of_cdss]
  5659 00001195 8ED8                    	mov	ds,ax
  5660 00001197 31F6                    	xor	si,si
  5661 00001199 31C0                    	xor	ax,ax
  5662 0000119B 268B0E[4C03]            	mov	cx,[es:config_size]	; if config_size has been broken,then this
  5663                                  					;whole test better fail.
  5664 000011A0 D1E9                    	shr	cx,1			; make it a word count
  5665 000011A2 7406                    	jz	short sum_sys_code	; when config.sys file not exist.
  5666                                  sum1:
  5667 000011A4 0304                    	add	ax,[si]
  5668 000011A6 46                      	inc	si
  5669 000011A7 46                      	inc	si
  5670 000011A8 E2FA                    	loop	sum1
  5671                                  ;now,sum up sysinit module.
  5672                                  sum_sys_code:
  5673                                  	; 24/10/2022
  5674 000011AA BEAA11                  	mov	si,locstack ; 5A6h (MSDOS 5.0 IO.SYS, SYSINIT)
  5675                                  				        ; starting after the stack.  M069
  5676                                  					;  this does not cover the possible stack code!!!
  5677                                  	;;mov	cx,22688  ; for MSDOS 6.21 IO.SYS
  5678                                  	; 02/11/2022
  5679 000011AD B9203D                  	mov	cx,3D20h  ; (15648) for MSDOS 5.0 IO.SYS (SYSINIT)	
  5680                                  	;mov	cx,SI_end ; (22688) 	; SI_end is the label at the end of sysinit
  5681 000011B0 29F1                    	sub	cx,si			;  from after_checksum to SI_end
  5682 000011B2 D1E9                    	shr	cx,1
  5683                                  sum2:
  5684 000011B4 260304                  	add	ax,[es:si]
  5685 000011B7 46                      	inc	si
  5686 000011B8 46                      	inc	si
  5687 000011B9 E2F9                    	loop	sum2
  5688 000011BB 1F                      	pop	ds
  5689 000011BC C3                      	retn
  5690                                  
  5691                                  ; 24/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  5692                                  
  5693                                  sysinit_base_ss equ $-sysinit_base  ; = 61 (MSDOS 5.0 IO.SYS, SYSINIT:115Ch)
  5694                                  ;SYSINIT:11BDh:
  5695 000011BD 0000                    	dw	0
  5696                                  sysinit_base_sp equ $-sysinit_base  ; = 63 (MSDOS 5.0 IO.SYS, SYSINIT:1161h)
  5697                                  ;SYSINIT:11BFh:
  5698 000011BF 0000                    	dw	0
  5699                                  
  5700                                  mem_alloc_err_msgx:
  5701                                  
  5702                                         ;include msbio.cl4		; memory allocation error message
  5703                                  
  5704                                  ;SYSINIT:12F6:  ; MSDOS 6.21 IO.SYS SYSINIT:12F6h
  5705 000011C1 0D0A                    	db	0Dh,0Ah
  5706 000011C3 4D656D6F727920616C-     	db 	'Memory allocation error $'
  5706 000011CC 6C6F636174696F6E20-
  5706 000011D5 6572726F722024     
  5707                                  
  5708                                  end_sysinit_base: ; label byte
  5709                                  	; 24/10/2022
  5710                                  	; (SYSINIT:11DCh for MSDOS 5.0 SYSINIT)
  5711                                  
  5712                                  ; ----------------------------------------------------------------------
  5713                                  ; Set_Buffer
  5714                                  ;
  5715                                  ;function: set buffers in the real memory.				  
  5716                                  ;	   lastly set the memhi,memlo for the next available free address.
  5717                                  ;
  5718                                  ;input:    ds:bx -> buffinfo.
  5719                                  ;	   [memhi]:[memlo = 0] = available space for the hash bucket.	  
  5720                                  ;	   singlebuffersize = buffer header size + sector size		  
  5721                                  ;
  5722                                  ;output:   buffers Queue established.	       				   
  5723                                  ;	   [memhi]:[memlo] = address of the next available free space.	   
  5724                                  ; ----------------------------------------------------------------------
  5725                                  
  5726                                  	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  5727                                  	; (SYSINIT:11DCh)
  5728                                  
  5729                                  set_buffer:
  5730 000011DC 30D2                    	xor	dl,dl				; assume buffers not in HMA
  5731 000011DE E85600                  	call	GetBufferAddr
  5732 000011E1 7402                    	jz	short set_buff_1
  5733 000011E3 B201                    	mov	dl,1				; buffers in HMA
  5734                                  set_buff_1:
  5735                                  	; 25/10/2022
  5736                                  	;mov	[bx+BUFFINF.Buff_Queue],di	; head of Buff Q
  5737 000011E5 893F                    	mov	[bx],di
  5738                                  	;mov	[bx+BUFFINF.Buff_Queue+2],es
  5739 000011E7 8C4702                  	mov	[bx+2],es
  5740                                  	;mov	word [bx+BUFFINF.Dirty_Buff_Count],0 ;set dirty_count to 0.
  5741 000011EA C747040000              	mov	word [bx+4], 0
  5742                                  
  5743 000011EF 89F8                    	mov	ax,di
  5744 000011F1 2E8B0E[9702]            	mov	cx,[cs:buffers]
  5745 000011F6 57                      	push	di				; remember first buffer
  5746                                  
  5747                                  ;	for each buffer
  5748                                  
  5749                                  nxt_buff:
  5750 000011F7 E86500                  	call	set_buffer_info 		; set buf_link,buf_id...
  5751 000011FA 89C7                    	mov	di,ax
  5752 000011FC E2F9                    	loop	nxt_buff
  5753                                  
  5754 000011FE 2E2B3E[9B02]            	sub	di,[cs:singlebuffersize]	; point to last buffer
  5755                                  
  5756 00001203 59                      	pop	cx				; get first buffer
  5757                                  	;mov	[es:di+buffinfo.buf_next],cx	; last->next = first
  5758 00001204 26890D                  	mov	[es:di],cx
  5759 00001207 87CF                    	xchg	cx,di
  5760                                  	;mov	[es:di+buffinfo.buf_prev],cx	; first->prev = last
  5761                                  	; 25/10/2022
  5762 00001209 26894D02                	mov	[es:di+2],cx
  5763                                  
  5764 0000120D 08D2                    	or	dl,dl				; In HMa ?
  5765 0000120F 7417                    	jz	short set_buff_2		; no
  5766                                  	;mov	byte [bx+BUFFINF.Buff_In_HMA],1
  5767 00001211 C6470C01                	mov	byte [bx+12],1
  5768 00001215 2EA1[E003]              	mov	ax,[cs:memhi]			; seg of scratch buff
  5769                                  	;mov	word [bx+BUFFINF.Lo_Mem_Buff],0	; offset of sctarch buff is 0
  5770 00001219 C7470D0000              	mov	word [bx+13],0
  5771                                  	;mov	[bx+BUFFINF.Lo_Mem_Buff+2],ax
  5772 0000121E 89470F                  	mov	word [bx+15],ax
  5773 00001221 2EA1[9B02]              	mov	ax,[cs:singlebuffersize]	; size of scratch buff
  5774                                  	;sub	ax,bufinsiz ; 20		; buffer head not required
  5775 00001225 83E814                  	sub	ax,20
  5776                                  set_buff_2:
  5777 00001228 2E0106[DE03]            	add	[cs:memlo],ax
  5778                                  	;or	byte [cs:setdevmarkflag],for_devmark ; 2
  5779 0000122D 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],2
  5780 00001233 E85D22                  	call	round
  5781 00001236 C3                      	retn
  5782                                  
  5783                                  ; ----------------------------------------------------------------------
  5784                                  ; procedure : GetBufferAddr
  5785                                  ;
  5786                                  ;	      Gets the buffer address either in HMA or in Lo Mem
  5787                                  ;
  5788                                  ; returns in es:di the buffer adress
  5789                                  ; returns NZ if allocated in HMA
  5790                                  ; ----------------------------------------------------------------------
  5791                                  
  5792                                  	; 25/10/2022 
  5793                                  GetBufferAddr:
  5794 00001237 53                      	push	bx
  5795 00001238 52                      	push	dx
  5796 00001239 2EA1[9B02]              	mov	ax, [cs:singlebuffersize]
  5797 0000123D 2EF726[9702]            	mul	word [cs:buffers]
  5798                                  	;add	ax,0Fh
  5799 00001242 83C00F                  	add	ax,15 
  5800                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5801 00001245 83E0F0                  	and	ax,~15	; 0FFF0h	; para round
  5802                                  	;and	al,~15	; 0F0h
  5803 00001248 89C3                    	mov	bx,ax
  5804 0000124A B8024A                  	mov	ax,4A02h
  5805                                  	;mov	ax,((multMULT<<8)+multMULTALLOCHMA)
  5806 0000124D CD2F                    	int	2Fh
  5807 0000124F 83FFFF                  	cmp	di,0FFFFh
  5808 00001252 7508                    	jne	short got_hma
  5809 00001254 BF0000                  	mov	di,0			; dont xor di,di Z flag needed
  5810                                  	;zf=1
  5811                                  	;xor	di,di	; 25/10/2022
  5812                                  	;zf=1
  5813 00001257 2E8E06[E003]            	mov	es,[cs:memhi]
  5814                                  got_hma:
  5815 0000125C 5A                      	pop	dx
  5816 0000125D 5B                      	pop	bx
  5817 0000125E C3                      	retn
  5818                                  
  5819                                  ; ----------------------------------------------------------------------
  5820                                  
  5821                                  set_buffer_info:
  5822                                  
  5823                                  ;function: set buf_link,buf_id,buf_sector
  5824                                  ;
  5825                                  ;in: es:di -> buffer header to be set.
  5826                                  ;    ax = di
  5827                                  ;
  5828                                  ;out:
  5829                                  ;    above entries set.
  5830                                  
  5831                                  	; 25/10/2022 
  5832 0000125F 2EFF36[3903]            	push	word [cs:buf_prev_off]
  5833                                  	;pop	word [es:di+buffinfo.buf_prev]
  5834 00001264 268F4502                	pop	word [es:di+2]
  5835 00001268 2EA3[3903]              	mov	[cs:buf_prev_off],ax
  5836 0000126C 2E0306[9B02]            	add	ax,[cs:singlebuffersize]	;adjust ax
  5837                                  	;mov	[es:di+buffinfo.buf_next],ax
  5838 00001271 268905                  	mov	[es:di],ax
  5839                                  	;mov	word [es:di+buffinfo.buf_ID],00FFh  ; new buffer free
  5840 00001274 26C74504FF00            	mov	word [es:di+4],00FFh
  5841                                  	;mov	word [es:di+buffinfo.buf_sector],0   ; to compensate the masm 3 bug
  5842 0000127A 26C745060000            	mov	word [es:di+6],0
  5843                                  	;mov	word [es:di+buffinfo.buf_sector+2],0 ; to compensate the masm 3 bug
  5844 00001280 26C745080000            	mov	word [es:di+8],0
  5845 00001286 C3                      	retn
  5846                                  
  5847                                  ; ======================================================================
  5848                                  ; MSSTACK initialization routine - MSDOS 6.0 - SYSDINIT1.ASM - 1991
  5849                                  ; ----------------------------------------------------------------------
  5850                                  ; 27/03/2019 - Retro DOS v4.0
  5851                                  
  5852                                  ; ----------------------------------------------------------------------
  5853                                  ; ibmstack initialization routine.
  5854                                  ;
  5855                                  ;	to follow the standard interrupt sharing scheme, msstack.asm
  5856                                  ;	has been modified. this initialization routine also has to
  5857                                  ;	be modified because for the interrupt level 7 and 15, firstflag
  5858                                  ;	should be set to signal that this interrupt handler is the
  5859                                  ;	first handler hooked to this interrupt vector.
  5860                                  ;	we determine this by looking at the instruction pointed by
  5861                                  ;	this vector. if it is iret, then this handler should be the
  5862                                  ;	first one. in our case, only the interrupt vector 77h is the
  5863                                  ;	interrupt level 15. (we don't hook interrupt level 7.)
  5864                                  ;
  5865                                  ;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
  5866                                  ;	some design changes are needed to the above interrupt sharing
  5867                                  ;	method. the above sharing scheme assumes that 1). interrupt
  5868                                  ;	sharing is never done on levels that have bios support. 2). "phantom"
  5869                                  ;	interrupts would only be generated on levels 7 and 15.
  5870                                  ;	these assumptions are not true any more. we have to use the firstflag
  5871                                  ;	for every level of interrupt. we will set the firstflag on the following
  5872                                  ;	conditions:
  5873                                  ;
  5874                                  ;	 a.	 if the cs portion of the vector is 0000, then "first"
  5875                                  ;	 b. else if cs:ip points to valid shared header, then not "first"
  5876                                  ;	 c. else if cs:ip points to an iret, then "first"
  5877                                  ;	 d. else if cs:ip points to dummy, then "first"
  5878                                  ;
  5879                                  ;	where dummy is - the cs portion must be f000, and the ip portion must
  5880                                  ;	be equal to the value at f000:ff01. this location is the initial value
  5881                                  ;	from vector_table for interrupt 7, one of the preserved addresses in all
  5882                                  ;	the bioses for all of the machines.
  5883                                  ;
  5884                                  ;	system design group requests bios to handle the phantom interrupts.
  5885                                  ;
  5886                                  ;	the "phantom" interrupt is an illegal interrupt such as an interrupt
  5887                                  ;	produced by the bogus adapter card even without interrupt request is
  5888                                  ;	set.  more specifically, 1). the 8259 has a feature when running in
  5889                                  ;	edge triggered mode to latch a pulse and present the interrupt when
  5890                                  ;	the processor indicates interrupt acknowledge (inta). the interrupt
  5891                                  ;	pulse was exist at the time of inta to get a "phantom" interrupt.
  5892                                  ;	2). or, this is caused by adapter cards placing a glitch on the
  5893                                  ;	interrupt line.
  5894                                  ;
  5895                                  ;	to handle those "phantom" interrupts, the main stack code will check
  5896                                  ;	the own firstflag, and if it is not "first" (which means the forward
  5897                                  ;	pointer points to the legal shared interrupt handler), then pass the
  5898                                  ;	control. if it is the first, then the following action should be
  5899                                  ;	taken. we don't have to implement skack logic in this case.
  5900                                  ;
  5901                                  ;	to implement this logic, we rather choose a simple method.
  5902                                  ;	if ont of the above "firstflag" conditions is met, we are not
  5903                                  ;	going to hook this interrupt vector. the reason is if the original
  5904                                  ;	vector points to "iret" and do nothing, we don't need
  5905                                  ;	to implement the stack logic for it. this will simplify implementation
  5906                                  ;	while maintaining compatibility with the old version of dos.
  5907                                  ;	this implies that in the main stack code, there might be a stack code
  5908                                  ;	that will never be used, a dead code.
  5909                                  ;
  5910                                  ;in - cs, ds -> sysinitseg, es -> relocated stack code & data.
  5911                                  
  5912                                  	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  5913                                  	; (SYSINIT:1287h)
  5914                                  
  5915                                  stackinit:
  5916 00001287 50                      	push	ax
  5917 00001288 1E                      	push	ds
  5918 00001289 06                      	push	es
  5919 0000128A 53                      	push	bx
  5920 0000128B 51                      	push	cx
  5921 0000128C 52                      	push	dx
  5922 0000128D 57                      	push	di
  5923 0000128E 56                      	push	si
  5924 0000128F 55                      	push	bp
  5925                                  
  5926                                  ;currently es -> stack code area
  5927                                  
  5928                                  	;mov	ax,[stack_count]
  5929                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5930                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1290h)
  5931 00001290 2EA1[8A02]              	mov	ax,[cs:stack_count] ; !!	;defined in cs
  5932 00001294 26A3[0200]              	mov	[es:stackcount],ax		;defined in stack code area
  5933                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1298h)
  5934 00001298 A1[8C02]                	mov	ax,[stack_size]	 ; !!		;in cs
  5935 0000129B 26A3[0600]              	mov	[es:stacksize],ax
  5936                                  	;mov	ax,[stack_addr]			; offset
  5937                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5938                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
  5939 0000129F 2EA1[8E02]              	mov	ax,[cs:stack_addr]  ; !!
  5940 000012A3 26A3[0800]              	mov	[es:stacks],ax
  5941                                  	;mov	ax,[stack_addr+2]
  5942                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  5943                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
  5944 000012A7 2EA1[9002]              	mov	ax,[cs:stack_addr+2] ; !!	; segment
  5945 000012AB 26A3[0A00]              	mov	[es:stacks+2],ax
  5946                                  
  5947                                  ; initialize the data fields with the parameters
  5948                                  
  5949                                  ; "firstentry" will always be at stacks
  5950                                  
  5951 000012AF 268B2E[0800]            	mov	bp,[es:stacks]			; get offset of stack
  5952 000012B4 26892E[0C00]            	mov	[es:firstentry],bp
  5953                                  
  5954                                  ; the stacks will always immediately follow the table entries
  5955                                  
  5956 000012B9 B80800                  	mov	ax,entrysize ; 8
  5957 000012BC 268B0E[0200]            	mov	cx,[es:stackcount]
  5958 000012C1 F7E1                    	mul	cx
  5959 000012C3 01E8                    	add	ax,bp
  5960 000012C5 26A3[0400]              	mov	[es:stackat],ax
  5961 000012C9 89C3                    	mov	bx,ax
  5962 000012CB 83EB02                  	sub	bx,2
  5963                                  
  5964                                  ; zero the entire stack area to start with
  5965                                  
  5966 000012CE 268B3E[0400]            	mov	di,[es:stackat]
  5967 000012D3 26A1[0600]              	mov	ax,[es:stacksize]
  5968 000012D7 F7E1                    	mul	cx
  5969 000012D9 89C1                    	mov	cx,ax
  5970 000012DB 31C0                    	xor	ax,ax
  5971 000012DD 06                      	push	es
  5972 000012DE 1F                      	pop	ds				;ds = relocated stack code seg.
  5973                                  
  5974                                  ;now, ds -> stack code area
  5975                                  
  5976 000012DF 8E06[0A00]              	mov	es,[stacks+2]			; get segment of stack area.
  5977 000012E3 FC                      	cld
  5978 000012E4 F3AA                    	rep	stosb
  5979                                  
  5980 000012E6 8B0E[0200]              	mov	cx,[stackcount]
  5981                                  
  5982                                  ; loop for "count" times, building a table entry
  5983                                  ;  cs = sysinitseg, ds = relocated stack code seg, es = segment of stack space
  5984                                  ;  cx = number of entries
  5985                                  ;  es:bp => base of stacks - 2
  5986                                  ;  es:bx => first table entry
  5987                                  
  5988                                  buildloop:
  5989 000012EA 26C6460000              	mov	byte [es:bp+allocbyte],free	; mov [es:bp+0],0
  5990                                  	; 25/10/2022
  5991                                  	;mov	byte [es:bp],free
  5992 000012EF 26884601                	mov	[es:bp+intlevel],al	; ax = 0
  5993                                  	;mov	[es:bp+1],al
  5994 000012F3 26894602                	mov	[es:bp+savedsp],ax
  5995                                  	;mov	[es:bp2],ax
  5996 000012F7 26894604                	mov	[es:bp+savedss],ax
  5997                                  	;mov	[es:bp+4],ax
  5998 000012FB 031E[0600]              	add	bx,[stacksize]
  5999 000012FF 26895E06                	mov	[es:bp+newsp],bx		; mov [es:bp+6],bx
  6000                                  	;mov	[es:bp+6],bx
  6001 00001303 26892F                  	mov	[es:bx],bp
  6002 00001306 83C508                  	add	bp,entrysize ; 8
  6003                                  
  6004 00001309 E2DF                    	loop	buildloop
  6005                                  
  6006 0000130B 83ED08                  	sub	bp,entrysize ; 8
  6007 0000130E 892E[0E00]              	mov	[lastentry],bp
  6008 00001312 892E[1000]              	mov	[nextentry],bp
  6009                                  
  6010 00001316 1E                      	push	ds
  6011 00001317 B800F0                  	mov	ax,0F000h		;look at the model byte
  6012 0000131A 8ED8                    	mov	ds,ax
  6013 0000131C 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ;convertible?
  6014 00001321 1F                      	pop	ds
  6015 00001322 7504                    	jne	short skip_disablenmis
  6016                                  
  6017 00001324 B007                    	mov	al,07h			; disable convertible nmis
  6018 00001326 E672                    	out	72h,al
  6019                                  
  6020                                  skip_disablenmis:
  6021 00001328 31C0                    	xor	ax,ax
  6022 0000132A 8EC0                    	mov	es,ax			;es - segid of vector table at 0
  6023                                  					;ds - relocated stack code segment
  6024 0000132C FA                      	cli
  6025                                  
  6026                                  	;irp	aa,<02,08,09,70>
  6027                                  	;
  6028                                  	;mov	si,aa&h*4		;pass where vector is to be adjusted
  6029                                  	;mov	di,offset int19old&aa	;we have to set old&aa for int19 handler too.
  6030                                  	;mov	bx,offset old&aa	;pass where to save original owner pointer
  6031                                  	;mov	dx,offset int&aa	;pass where new handler is
  6032                                  	;call	new_init_loop		;adjust the vector to new handler,
  6033                                  	;				;saving pointer to original owner
  6034                                  	;endm
  6035                                  
  6036                                  stkinit_02:
  6037 0000132D BE0800                  	mov	si,02h*4 ; 8
  6038 00001330 BF4206                  	mov	di,INT19OLD02
  6039 00001333 BB[1200]                	mov	bx,old02
  6040 00001336 BA[1600]                	mov	dx,int02
  6041 00001339 E8D402                  	call	new_init_loop
  6042                                  stkinit_08:
  6043 0000133C BE2000                  	mov	si,08h*4 ; 32
  6044 0000133F BF4706                  	mov	di,INT19OLD08
  6045 00001342 BB[3800]                	mov	bx,old08
  6046 00001345 BA[3C00]                	mov	dx,int08
  6047 00001348 E8C502                  	call	new_init_loop
  6048                                  stkinit_09:
  6049 0000134B BE2400                  	mov	si,09h*4 ; 36
  6050 0000134E BF4C06                  	mov	di,INT19OLD09
  6051 00001351 BB[4100]                	mov	bx,old09
  6052 00001354 BA[4500]                	mov	dx,int09
  6053 00001357 E8B602                  	call	new_init_loop
  6054                                  stkinit_70:
  6055 0000135A BEC001                  	mov	si,70h*4 ; 448
  6056 0000135D BF6A06                  	mov	di,INT19OLD70
  6057 00001360 BB[4E00]                	mov	bx,old70
  6058 00001363 BA[5200]                	mov	dx,int70
  6059 00001366 E8A702                  	call	new_init_loop
  6060                                  
  6061                                  	;irp	aa,<0a,0b,0c,0d,0e,72,73,74,76,77> ;shared interrupts
  6062                                  	;
  6063                                  	;mov	si,aa&h*4		;pass where vector is to be adjusted
  6064                                  	;push	ds			;save relocated stack code segment
  6065                                  	;lds	bx, es:[si]		;ds:bx -> original interrupt handler
  6066                                  	;push	ds
  6067                                  	;pop	dx			;dx = segment value
  6068                                  	;	
  6069                                  	;cmp	dx,0
  6070                                  	;jz	int&aa&_first
  6071                                  	;
  6072                                  	;cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
  6073                                  	;jz	int&aa&_first
  6074                                  	;
  6075                                  	;cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
  6076                                  	;jz	int&aa&_not_first
  6077                                  	;
  6078                                  	;cmp	dx,0f000h		;rom bios segment
  6079                                  	;jnz	int&aa&_not_first
  6080                                  	;
  6081                                  	;push	es
  6082                                  	;push	dx
  6083                                  	;mov	dx,0f000h
  6084                                  	;mov	es,dx
  6085                                  	;cmp	bx,word ptr es:0ff01h
  6086                                         	;pop	dx
  6087                                  	;pop	es
  6088                                  	;jz	int&aa&_first
  6089                                  	;
  6090                                  ;int&aa&_not_first:			;not the first. we are going to hook vector.
  6091                                  	;pop	ds
  6092                                  	;mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
  6093                                  	;mov	bx, offset old&aa	;pass where to save original owner pointer
  6094                                  	;mov	dx, offset int&aa	;pass where new handler is
  6095                                  	;call	new_init_loop		;adjust the vector to new handler, saving
  6096                                  	;				;pointer to original owner.
  6097                                  	;jmp	short int&aa&_end
  6098                                  ;int&aa&_first:				;the first. don't have to hook stack code.
  6099                                  	;pop	ds
  6100                                  ;int&aa&_end:
  6101                                  	;
  6102                                  	;endm
  6103                                  
  6104                                  stkinit_0A:
  6105 00001369 BE2800                  	mov	si,0Ah*4 ; 40
  6106                                  	
  6107                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6108 0000136C 1E                      	push	ds
  6109                                  	
  6110 0000136D 26C51C                  	lds	bx,[es:si]
  6111 00001370 1E                      	push	ds
  6112 00001371 5A                      	pop	dx
  6113                                  		
  6114 00001372 83FA00                  	cmp	dx,0
  6115 00001375 7431                    	je	short int_0A_first
  6116                                  	
  6117 00001377 803FCF                  	cmp	byte [bx],0CFh
  6118 0000137A 742C                    	je	short int_0A_first
  6119                                  	
  6120 0000137C 817F064B42              	cmp	word [bx+6],424Bh
  6121 00001381 7416                    	je	short int_0A_not_first
  6122                                  	
  6123 00001383 81FA00F0                	cmp	dx,0F000h
  6124 00001387 7510                    	jne	short int_0A_not_first
  6125                                  	
  6126 00001389 06                      	push	es
  6127 0000138A 52                      	push	dx
  6128 0000138B BA00F0                  	mov	dx,0F000h
  6129 0000138E 8EC2                    	mov	es,dx
  6130 00001390 263B1E01FF              	cmp	bx,[es:0FF01h]
  6131 00001395 5A                             	pop	dx
  6132 00001396 07                      	pop	es
  6133 00001397 740F                    	je	short int_0A_first
  6134                                  
  6135                                  	; 25/10/2022
  6136                                  	;call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
  6137                                  	;jnc	short int_0A_first
  6138                                  	
  6139                                  int_0A_not_first:
  6140                                  	; 25/10/2022
  6141 00001399 1F                      	pop	ds
  6142 0000139A BF5106                  	mov	di,INT19OLD0A
  6143 0000139D BB[5900]                	mov	bx,old0A
  6144 000013A0 BA[5700]                	mov	dx,int0A
  6145 000013A3 E86A02                  	call	new_init_loop
  6146 000013A6 EB01                    	jmp	short int_0A_end
  6147                                  
  6148                                  ; -----------------------------------
  6149                                  
  6150                                  ; 25/10/2022
  6151                                  ;
  6152                                  ;	; 27/03/2019 - Retro DOS v4.0
  6153                                  ;int_xx_first_check:
  6154                                  ;	push	ds
  6155                                  ;	lds	bx,[es:si]
  6156                                  ;	push	ds
  6157                                  ;	pop	dx
  6158                                  ;		
  6159                                  ;	cmp	dx,0
  6160                                  ;	je	short int_xx_first
  6161                                  ;	
  6162                                  ;	cmp	byte [bx],0CFh
  6163                                  ;	je	short int_xx_first
  6164                                  ;	
  6165                                  ;	cmp	word [bx+6],424Bh
  6166                                  ;	je	short int_xx_not_first
  6167                                  ;	
  6168                                  ;	cmp	dx,0F000h
  6169                                  ;	jne	short int_xx_not_first
  6170                                  ;
  6171                                  ;	push	es
  6172                                  ;	;push	dx
  6173                                  ;	;mov	dx,0F000h
  6174                                  ;	mov	es,dx
  6175                                  ;	cmp	bx,[es:0FF01h]
  6176                                  ;      	;pop	dx
  6177                                  ;	pop	es
  6178                                  ;	je	short int_xx_first
  6179                                  ;
  6180                                  ;int_xx_not_first:
  6181                                  ;	stc
  6182                                  ;int_xx_first:
  6183                                  ;	pop	ds
  6184                                  ;	retn
  6185                                  
  6186                                  ; -----------------------------------
  6187                                  
  6188                                  int_0A_first:
  6189                                  	; 25/10/2022
  6190 000013A8 1F                      	pop	ds
  6191                                  int_0A_end:
  6192                                  
  6193                                  stkinit_0B:
  6194 000013A9 BE2C00                  	mov	si,0Bh*4 ; 44
  6195                                  	
  6196                                  	; 25/10/2022
  6197                                  	;call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
  6198                                  	;jnc	short int_0B_end ; int_0B_first
  6199                                  
  6200                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6201 000013AC 1E                      	push	ds
  6202 000013AD 26C51C                  	lds	bx,[es:si]
  6203 000013B0 1E                      	push	ds
  6204 000013B1 5A                      	pop	dx
  6205                                  		
  6206 000013B2 83FA00                  	cmp	dx,0
  6207 000013B5 7431                    	je	short int_0B_first
  6208                                  
  6209 000013B7 803FCF                  	cmp	byte [bx],0CFh
  6210 000013BA 742C                    	je	short int_0B_first
  6211                                  	
  6212 000013BC 817F064B42              	cmp	word [bx+6],424Bh
  6213 000013C1 7416                    	je	short int_0B_not_first
  6214                                  	
  6215 000013C3 81FA00F0                	cmp	dx,0F000h
  6216 000013C7 7510                    	jne	short int_0B_not_first
  6217                                  
  6218 000013C9 06                      	push	es
  6219 000013CA 52                      	push	dx
  6220 000013CB BA00F0                  	mov	dx,0F000h
  6221 000013CE 8EC2                    	mov	es,dx
  6222 000013D0 263B1E01FF              	cmp	bx,[es:0FF01h]
  6223 000013D5 5A                      	pop	dx
  6224 000013D6 07                      	pop	es
  6225 000013D7 740F                    	je	short int_0B_first
  6226                                  	
  6227                                  int_0B_not_first:
  6228                                  	; 25/10/2022
  6229 000013D9 1F                      	pop	ds
  6230 000013DA BF5606                  	mov	di,INT19OLD0B
  6231 000013DD BB[7100]                	mov	bx,old0B
  6232 000013E0 BA[6F00]                	mov	dx,int0B
  6233 000013E3 E82A02                  	call	new_init_loop
  6234 000013E6 EB01                    	jmp	short int_0B_end
  6235                                  
  6236                                  int_0B_first:
  6237                                  	; 25/10/2022
  6238 000013E8 1F                      	pop	ds
  6239                                  int_0B_end:
  6240                                  	
  6241                                  stkinit_0C:
  6242 000013E9 BE3000                  	mov	si,0Ch*4 ; 48
  6243                                  	
  6244                                  	; 25/10/2022
  6245                                  	;call	int_xx_first_check
  6246                                  	;jnc	short int_0B_end ; int_0C_first
  6247                                  
  6248                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6249 000013EC 1E                      	push	ds
  6250 000013ED 26C51C                  	lds	bx,[es:si]
  6251 000013F0 1E                      	push	ds
  6252 000013F1 5A                      	pop	dx
  6253                                  		
  6254 000013F2 83FA00                  	cmp	dx,0
  6255 000013F5 7431                    	je	short int_0C_first
  6256                                  
  6257 000013F7 803FCF                  	cmp	byte [bx],0CFh
  6258 000013FA 742C                    	je	short int_0C_first
  6259                                  	
  6260 000013FC 817F064B42              	cmp	word [bx+6],424Bh
  6261 00001401 7416                    	je	short int_0C_not_first
  6262                                  	
  6263 00001403 81FA00F0                	cmp	dx,0F000h
  6264 00001407 7510                    	jne	short int_0C_not_first
  6265                                  
  6266 00001409 06                      	push	es
  6267 0000140A 52                      	push	dx
  6268 0000140B BA00F0                  	mov	dx,0F000h
  6269 0000140E 8EC2                    	mov	es,dx
  6270 00001410 263B1E01FF              	cmp	bx,[es:0FF01h]
  6271 00001415 5A                      	pop	dx
  6272 00001416 07                      	pop	es
  6273 00001417 740F                    	je	short int_0C_first
  6274                                  	
  6275                                  int_0C_not_first:
  6276                                  	; 25/10/2022
  6277 00001419 1F                      	pop	ds
  6278 0000141A BF5B06                  	mov	di,INT19OLD0C
  6279 0000141D BB[8900]                	mov	bx,old0C
  6280 00001420 BA[8700]                	mov	dx,int0C
  6281 00001423 E8EA01                  	call	new_init_loop
  6282 00001426 EB01                    	jmp	short int_0C_end
  6283                                  int_0C_first:
  6284                                  	; 25/10/2022
  6285 00001428 1F                      	pop	ds
  6286                                  int_0C_end:
  6287                                  
  6288                                  stkinit_0D:
  6289 00001429 BE3400                  	mov	si,0Dh*4 ; 52
  6290                                  	
  6291                                  	; 25/10/2022
  6292                                  	;call	int_xx_first_check
  6293                                  	;jnc	short int_0D_end ; int_0D_first
  6294                                  
  6295                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6296 0000142C 1E                      	push	ds
  6297 0000142D 26C51C                  	lds	bx,[es:si]
  6298 00001430 1E                      	push	ds
  6299 00001431 5A                      	pop	dx
  6300                                  		
  6301 00001432 83FA00                  	cmp	dx,0
  6302 00001435 7431                    	je	short int_0D_first
  6303                                  
  6304 00001437 803FCF                  	cmp	byte [bx],0CFh
  6305 0000143A 742C                    	je	short int_0D_first
  6306                                  	
  6307 0000143C 817F064B42              	cmp	word [bx+6],424Bh
  6308 00001441 7416                    	je	short int_0D_not_first
  6309                                  	
  6310 00001443 81FA00F0                	cmp	dx,0F000h
  6311 00001447 7510                    	jne	short int_0D_not_first
  6312                                  
  6313 00001449 06                      	push	es
  6314 0000144A 52                      	push	dx
  6315 0000144B BA00F0                  	mov	dx,0F000h
  6316 0000144E 8EC2                    	mov	es,dx
  6317 00001450 263B1E01FF              	cmp	bx,[es:0FF01h]
  6318 00001455 5A                      	pop	dx
  6319 00001456 07                      	pop	es
  6320 00001457 740F                    	je	short int_0D_first
  6321                                  	
  6322                                  int_0D_not_first:
  6323                                  	; 25/10/2022
  6324 00001459 1F                      	pop	ds
  6325 0000145A BF6006                  	mov	di,INT19OLD0D
  6326 0000145D BB[A100]                	mov	bx,old0D
  6327 00001460 BA[9F00]                	mov	dx,int0D
  6328 00001463 E8AA01                  	call	new_init_loop
  6329 00001466 EB01                    	jmp	short int_0D_end
  6330                                  	; 02/11/2022
  6331                                  int_0D_first:
  6332 00001468 1F                      	pop	ds
  6333                                  int_0D_end:
  6334                                  
  6335                                  stkinit_0E:
  6336 00001469 BE3800                  	mov	si,0Eh*4 ; 56
  6337                                  	
  6338                                  	; 25/10/2022
  6339                                  	;call	int_xx_first_check
  6340                                  	;jnc	short int_0E_end ; int_0E_first
  6341                                  
  6342                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6343 0000146C 1E                      	push	ds
  6344 0000146D 26C51C                  	lds	bx,[es:si]
  6345 00001470 1E                      	push	ds
  6346 00001471 5A                      	pop	dx
  6347                                  		
  6348 00001472 83FA00                  	cmp	dx,0
  6349 00001475 7431                    	je	short int_0E_first
  6350                                  
  6351 00001477 803FCF                  	cmp	byte [bx],0CFh
  6352 0000147A 742C                    	je	short int_0E_first
  6353                                  	
  6354 0000147C 817F064B42              	cmp	word [bx+6],424Bh
  6355 00001481 7416                    	je	short int_0E_not_first
  6356                                  	
  6357 00001483 81FA00F0                	cmp	dx,0F000h
  6358 00001487 7510                    	jne	short int_0E_not_first
  6359                                  
  6360 00001489 06                      	push	es
  6361 0000148A 52                      	push	dx
  6362 0000148B BA00F0                  	mov	dx,0F000h
  6363 0000148E 8EC2                    	mov	es,dx
  6364 00001490 263B1E01FF              	cmp	bx,[es:0FF01h]
  6365 00001495 5A                      	pop	dx
  6366 00001496 07                      	pop	es
  6367 00001497 740F                    	je	short int_0E_first
  6368                                  	
  6369                                  int_0E_not_first:
  6370                                  	; 25/10/2022
  6371 00001499 1F                      	pop	ds
  6372 0000149A BF6506                  	mov	di,INT19OLD0E
  6373 0000149D BB[B900]                	mov	bx,old0E
  6374 000014A0 BA[B700]                	mov	dx,int0E
  6375 000014A3 E86A01                  	call	new_init_loop
  6376 000014A6 EB01                    	jmp	short int_0E_end
  6377                                  
  6378                                  int_0E_first:
  6379                                  	; 25/10/2022
  6380 000014A8 1F                      	pop	ds	
  6381                                  int_0E_end:
  6382                                  
  6383                                  stkinit_72:
  6384 000014A9 BEC801                  	mov	si,72h*4 ; 456
  6385                                  	
  6386                                  	; 25/10/2022
  6387                                  	;call	int_xx_first_check
  6388                                  	;jnc	short int_72_end ; int_72_first
  6389                                  
  6390                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6391 000014AC 1E                      	push	ds
  6392 000014AD 26C51C                  	lds	bx,[es:si]
  6393 000014B0 1E                      	push	ds
  6394 000014B1 5A                      	pop	dx
  6395                                  		
  6396 000014B2 83FA00                  	cmp	dx,0
  6397 000014B5 7431                    	je	short int_72_first
  6398                                  
  6399 000014B7 803FCF                  	cmp	byte [bx],0CFh
  6400 000014BA 742C                    	je	short int_72_first
  6401                                  	
  6402 000014BC 817F064B42              	cmp	word [bx+6],424Bh
  6403 000014C1 7416                    	je	short int_72_not_first
  6404                                  	
  6405 000014C3 81FA00F0                	cmp	dx,0F000h
  6406 000014C7 7510                    	jne	short int_72_not_first
  6407                                  
  6408 000014C9 06                      	push	es
  6409 000014CA 52                      	push	dx
  6410 000014CB BA00F0                  	mov	dx,0F000h
  6411 000014CE 8EC2                    	mov	es,dx
  6412 000014D0 263B1E01FF              	cmp	bx,[es:0FF01h]
  6413 000014D5 5A                      	pop	dx
  6414 000014D6 07                      	pop	es
  6415 000014D7 740F                    	je	short int_72_first
  6416                                  	
  6417                                  int_72_not_first:
  6418                                  	; 25/10/2022
  6419 000014D9 1F                      	pop	ds
  6420 000014DA BF6F06                  	mov	di,INT19OLD72
  6421 000014DD BB[D100]                	mov	bx,old72
  6422 000014E0 BA[CF00]                	mov	dx,int72
  6423 000014E3 E82A01                  	call	new_init_loop
  6424 000014E6 EB01                    	jmp	short int_72_end
  6425                                  
  6426                                  int_72_first:
  6427                                  	; 25/10/2022
  6428 000014E8 1F                      	pop	ds
  6429                                  int_72_end:
  6430                                  
  6431                                  stkinit_73:
  6432 000014E9 BECC01                  	mov	si,73h*4 ; 460
  6433                                  	
  6434                                  	; 25/10/2022
  6435                                  	;call	int_xx_first_check
  6436                                  	;jnc	short int_73_end ; int_73_first
  6437                                  
  6438                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6439 000014EC 1E                      	push	ds
  6440 000014ED 26C51C                  	lds	bx,[es:si]
  6441 000014F0 1E                      	push	ds
  6442 000014F1 5A                      	pop	dx
  6443                                  		
  6444 000014F2 83FA00                  	cmp	dx,0
  6445 000014F5 7431                    	je	short int_73_first
  6446                                  
  6447 000014F7 803FCF                  	cmp	byte [bx],0CFh
  6448 000014FA 742C                    	je	short int_73_first
  6449                                  	
  6450 000014FC 817F064B42              	cmp	word [bx+6],424Bh
  6451 00001501 7416                    	je	short int_73_not_first
  6452                                  	
  6453 00001503 81FA00F0                	cmp	dx,0F000h
  6454 00001507 7510                    	jne	short int_73_not_first
  6455                                  
  6456 00001509 06                      	push	es
  6457 0000150A 52                      	push	dx
  6458 0000150B BA00F0                  	mov	dx,0F000h
  6459 0000150E 8EC2                    	mov	es,dx
  6460 00001510 263B1E01FF              	cmp	bx,[es:0FF01h]
  6461 00001515 5A                      	pop	dx
  6462 00001516 07                      	pop	es
  6463 00001517 740F                    	je	short int_73_first
  6464                                  	
  6465                                  int_73_not_first:
  6466                                  	; 25/10/2022
  6467 00001519 1F                      	pop	ds
  6468 0000151A BF7406                  	mov	di,INT19OLD73
  6469 0000151D BB[E900]                	mov	bx,old73
  6470 00001520 BA[E700]                	mov	dx,int73
  6471 00001523 E8EA00                  	call	new_init_loop
  6472 00001526 EB01                    	jmp	short int_73_end
  6473                                  
  6474                                  int_73_first:
  6475                                  	; 25/10/2022
  6476 00001528 1F                      	pop	ds
  6477                                  int_73_end:
  6478                                  
  6479                                  stkinit_74:
  6480 00001529 BED001                  	mov	si,74h*4 ; 464
  6481                                  	
  6482                                  	; 25/10/2022
  6483                                  	;call	int_xx_first_check
  6484                                  	;jnc	short int_74_end ; int_74_first
  6485                                  	
  6486                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6487 0000152C 1E                      	push	ds
  6488 0000152D 26C51C                  	lds	bx,[es:si]
  6489 00001530 1E                      	push	ds
  6490 00001531 5A                      	pop	dx
  6491                                  		
  6492 00001532 83FA00                  	cmp	dx,0
  6493 00001535 7431                    	je	short int_74_first
  6494                                  
  6495 00001537 803FCF                  	cmp	byte [bx],0CFh
  6496 0000153A 742C                    	je	short int_74_first
  6497                                  	
  6498 0000153C 817F064B42              	cmp	word [bx+6],424Bh
  6499 00001541 7416                    	je	short int_74_not_first
  6500                                  	
  6501 00001543 81FA00F0                	cmp	dx,0F000h
  6502 00001547 7510                    	jne	short int_74_not_first
  6503                                  
  6504 00001549 06                      	push	es
  6505 0000154A 52                      	push	dx
  6506 0000154B BA00F0                  	mov	dx,0F000h
  6507 0000154E 8EC2                    	mov	es,dx
  6508 00001550 263B1E01FF              	cmp	bx,[es:0FF01h]
  6509 00001555 5A                      	pop	dx
  6510 00001556 07                      	pop	es
  6511 00001557 740F                    	je	short int_74_first
  6512                                  
  6513                                  int_74_not_first:
  6514                                  	; 25/10/2022
  6515 00001559 1F                      	pop	ds
  6516 0000155A BF7906                  	mov	di,INT19OLD74
  6517 0000155D BB[0101]                	mov	bx,old74
  6518 00001560 BA[FF00]                	mov	dx,int74
  6519 00001563 E8AA00                  	call	new_init_loop
  6520 00001566 EB01                    	jmp	short int_74_end
  6521                                  
  6522                                  int_74_first:
  6523                                  	; 25/10/2022
  6524 00001568 1F                      	pop	ds
  6525                                  int_74_end:
  6526                                  
  6527                                  stkinit_76:
  6528 00001569 BED801                  	mov	si,76h*4 ; 472
  6529                                  	
  6530                                  	; 25/10/2022
  6531                                  	;call	int_xx_first_check
  6532                                  	;jnc	short int_76_end ; int_76_first
  6533                                  
  6534                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6535 0000156C 1E                      	push	ds
  6536 0000156D 26C51C                  	lds	bx,[es:si]
  6537 00001570 1E                      	push	ds
  6538 00001571 5A                      	pop	dx
  6539                                  		
  6540 00001572 83FA00                  	cmp	dx,0
  6541 00001575 7431                    	je	short int_76_first
  6542                                  
  6543 00001577 803FCF                  	cmp	byte [bx],0CFh
  6544 0000157A 742C                    	je	short int_76_first
  6545                                  	
  6546 0000157C 817F064B42              	cmp	word [bx+6],424Bh
  6547 00001581 7416                    	je	short int_76_not_first
  6548                                  	
  6549 00001583 81FA00F0                	cmp	dx,0F000h
  6550 00001587 7510                    	jne	short int_76_not_first
  6551                                  
  6552 00001589 06                      	push	es
  6553 0000158A 52                      	push	dx
  6554 0000158B BA00F0                  	mov	dx,0F000h
  6555 0000158E 8EC2                    	mov	es,dx
  6556 00001590 263B1E01FF              	cmp	bx,[es:0FF01h]
  6557 00001595 5A                      	pop	dx
  6558 00001596 07                      	pop	es
  6559 00001597 740F                    	je	short int_76_first
  6560                                  	
  6561                                  int_76_not_first:
  6562                                  	; 25/10/2022
  6563 00001599 1F                      	pop	ds
  6564 0000159A BF7E06                  	mov	di,INT19OLD76
  6565 0000159D BB[1901]                	mov	bx,old76
  6566 000015A0 BA[1701]                	mov	dx,int76
  6567 000015A3 E86A00                  	call	new_init_loop
  6568 000015A6 EB01                    	jmp	short int_76_end
  6569                                  
  6570                                  int_76_first:
  6571                                  	; 25/10/2022
  6572 000015A8 1F                      	pop	ds
  6573                                  int_76_end:
  6574                                  
  6575                                  stkinit_77:
  6576 000015A9 BEDC01                  	mov	si,77h*4 ; 476
  6577                                  	
  6578                                  	; 25/10/2022
  6579                                  	;call	int_xx_first_check
  6580                                  	;jnc	short int_77_end ; int_77_first
  6581                                  
  6582                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  6583 000015AC 1E                      	push	ds
  6584 000015AD 26C51C                  	lds	bx,[es:si]
  6585 000015B0 1E                      	push	ds
  6586 000015B1 5A                      	pop	dx
  6587                                  		
  6588 000015B2 83FA00                  	cmp	dx,0
  6589 000015B5 7431                    	je	short int_77_first
  6590                                  
  6591 000015B7 803FCF                  	cmp	byte [bx],0CFh
  6592 000015BA 742C                    	je	short int_77_first
  6593                                  	
  6594 000015BC 817F064B42              	cmp	word [bx+6],424Bh
  6595 000015C1 7416                    	je	short int_77_not_first
  6596                                  	
  6597 000015C3 81FA00F0                	cmp	dx,0F000h
  6598 000015C7 7510                    	jne	short int_77_not_first
  6599                                  
  6600 000015C9 06                      	push	es
  6601 000015CA 52                      	push	dx
  6602 000015CB BA00F0                  	mov	dx,0F000h
  6603 000015CE 8EC2                    	mov	es,dx
  6604 000015D0 263B1E01FF              	cmp	bx,[es:0FF01h]
  6605 000015D5 5A                      	pop	dx
  6606 000015D6 07                      	pop	es
  6607 000015D7 740F                    	je	short int_77_first
  6608                                  	
  6609                                  int_77_not_first:
  6610                                  	; 25/10/2022
  6611 000015D9 1F                      	pop	ds
  6612 000015DA BF8306                  	mov	di,INT19OLD77
  6613 000015DD BB[3101]                	mov	bx,old77
  6614 000015E0 BA[2F01]                	mov	dx,int77
  6615 000015E3 E82A00                  	call	new_init_loop
  6616 000015E6 EB01                    	jmp	short int_77_end
  6617                                  
  6618                                  int_77_first:
  6619                                  	; 25/10/2022
  6620 000015E8 1F                      	pop	ds
  6621                                  
  6622                                  int_77_end:
  6623 000015E9 1E                      	push	ds
  6624 000015EA B800F0                  	mov	ax,0F000h		; look at the model byte
  6625 000015ED 8ED8                    	mov	ds,ax
  6626 000015EF 803EFEFFF9              	cmp	byte [0FFFEh],0F9h ; mdl_convert ; pc convertible?
  6627 000015F4 1F                      	pop	ds
  6628 000015F5 7504                    	jne	short skip_enablenmis
  6629                                  
  6630 000015F7 B027                    	mov	al,27h			; enable convertible nmis
  6631 000015F9 E672                    	out	72h,al
  6632                                  
  6633                                  ; 25/10/2022
  6634                                  ; (MSDOS 5.0 SYSINIT:15FBh)
  6635                                  
  6636                                  skip_enablenmis:
  6637 000015FB FB                      	sti
  6638                                  	;;mov	ax,Bios_Data ; 70h
  6639                                  	;mov	ax,KERNEL_SEGMENT ; 70h
  6640                                  	; 21/10/2022
  6641 000015FC B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  6642 000015FF 8ED8                    	mov	ds,ax
  6643                                  
  6644                                  	;mov	[640h],1 ; SYSINIT:1736h for MSDOS 6.21 IO.SYS
  6645                                  
  6646 00001601 C606400601              	mov	byte [INT19SEM],1	; indicate that int 19
  6647                                  					; initialization is complete
  6648                                  
  6649 00001606 5D                      	pop	bp			; restore all
  6650 00001607 5E                      	pop	si
  6651 00001608 5F                      	pop	di
  6652 00001609 5A                      	pop	dx
  6653 0000160A 59                      	pop	cx
  6654 0000160B 5B                      	pop	bx
  6655 0000160C 07                      	pop	es
  6656 0000160D 1F                      	pop	ds
  6657 0000160E 58                      	pop	ax
  6658 0000160F C3                      	retn
  6659                                  
  6660                                  ; ----------------------------------------------------------------------
  6661                                  ; 27/03/2019 - Retro DOS v4.0
  6662                                  
  6663                                  ; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  6664                                  ; (SYSINIT:1610h)
  6665                                  
  6666                                  new_init_loop:
  6667                                  
  6668                                  ;input: si=ofset into vector table of the particular int vector being adjusted
  6669                                  ;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
  6670                                  ;	dx=ds:offset of intxx, the new interrupt handler
  6671                                  ;	di=offset value of int19old&aa variable in bios.
  6672                                  ;	es=zero, segid of vector table
  6673                                  ;	ds=relocated stack code segment
  6674                                  
  6675 00001610 268B04                  	mov	ax,[es:si]		;remember offset in vector
  6676 00001613 8907                    	mov	[bx],ax			; to original owner in ds
  6677 00001615 268B4402                	mov	ax,[es:si+2]		;remember segid in vector
  6678 00001619 894702                  	mov	[bx+2],ax		; to original owner in ds
  6679                                  
  6680 0000161C 1E                      	push	ds
  6681                                  	;;mov	ax,Bios_Data ; 70h
  6682                                  	;mov	ax,KERNEL_SEGMENT ; 70h
  6683                                  	; 21/10/2022
  6684 0000161D B87000                  	mov	ax,DOSBIODATASEG ; 0070h
  6685 00001620 8ED8                    	mov	ds,ax			;set int19oldxx value in bios for
  6686 00001622 268B04                  	mov	ax,[es:si]		;int 19 handler
  6687 00001625 8905                    	mov	[di],ax
  6688 00001627 268B4402                	mov	ax,[es:si+2]
  6689 0000162B 894502                  	mov	word [di+2],ax
  6690 0000162E 1F                      	pop	ds
  6691                                  
  6692 0000162F 268914                  	mov	[es:si],dx  	;set vector to point to new int handler
  6693 00001632 268C5C02                	mov	[es:si+2],ds
  6694 00001636 C3                      	retn
  6695                                  
  6696                                  ; End of STACK initialization routine
  6697                                  ; ----------------------------------------------------------------------
  6698                                  
  6699                                  ; ----------------------------------------------------------------------
  6700                                  ;set the devmark for mem command.
  6701                                  ;in: [memhi] - the address to place devmark
  6702                                  ;    [memlo] = 0
  6703                                  ;    al = id for devmark_id
  6704                                  ;out: devmark established.
  6705                                  ;     the address saved in cs:[devmark_addr]
  6706                                  ;     [memhi] increase by 1.
  6707                                  ; ----------------------------------------------------------------------
  6708                                  
  6709                                  ; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
  6710                                  ; (SYSINIT:1637h)
  6711                                  
  6712                                  setdevmark:
  6713                                  
  6714 00001637 06                      	push	es
  6715 00001638 51                      	push	cx
  6716                                  
  6717 00001639 2E8B0E[E003]            	mov	cx,[cs:memhi]
  6718 0000163E 2E890E[5816]            	mov	[cs:devmark_addr],cx
  6719 00001643 8EC1                    	mov	es,cx
  6720                                  	; 25/10/2022
  6721                                  	;mov	[es:devmark.id],al
  6722 00001645 26A20000                	mov	[es:0],al
  6723 00001649 41                      	inc	cx
  6724                                  	;mov	[es:devmark.seg],cx
  6725 0000164A 26890E0100              	mov	[es:1],cx
  6726                                  
  6727 0000164F 59                      	pop	cx
  6728 00001650 07                      	pop	es
  6729 00001651 2EFF06[E003]            	inc	word [cs:memhi]
  6730 00001656 C3                      	retn
  6731                                  
  6732                                  ; ----------------------------------------------------------------------
  6733                                  ; SYSCONF.ASM - MSDOS 6.0 - 1991
  6734                                  ; ----------------------------------------------------------------------
  6735                                  ; 27/03/2019 - Retro DOS v4.0
  6736                                  
  6737                                  ;MULTI_CONFIG	equ 1
  6738                                  
  6739                                  HIGH_FIRST 	equ 080h		; from ARENA.INC - modifier for
  6740                                                                          ; allocation strategy call
  6741                                  
  6742                                  ;have_install_cmd equ 00000001b 	; config.sys has install= commands
  6743                                  ;has_installed	  equ 00000010b 	; sysinit_base installed.
  6744                                  
  6745                                  default_filenum equ 8
  6746                                  
  6747                                  ;stacksw	equ true		; include switchable hardware stacks
  6748                                  
  6749                                  ; external variable defined in ibmbio module for multi-track
  6750                                  
  6751                                  ;multrk_on	equ 10000000b		;user spcified mutitrack=on,or system turns
  6752                                  					; it on after handling config.sys file as a
  6753                                  					; default value,if multrk_flag = multrk_off1.
  6754                                  ;multrk_off1	equ 00000000b		;initial value. no "multitrack=" command entered.
  6755                                  ;multrk_off2	equ 00000001b		;user specified multitrack=off.
  6756                                  
  6757                                  ; if stacksw
  6758                                  
  6759                                  ; internal stack parameters
  6760                                  
  6761                                  ;entrysize	equ 8
  6762                                  
  6763                                  ;mincount	equ 8
  6764                                  ;defaultcount	equ 9
  6765                                  ;maxcount	equ 64
  6766                                  
  6767                                  ;minsize 	equ 32
  6768                                  ;defaultsize	equ 128
  6769                                  ;maxsize 	equ 512
  6770                                  
  6771                                  DOS_FLAG_OFFSET	equ 86h
  6772                                  
  6773                                  ;ifdef MULTI_CONFIG
  6774                                  ;
  6775                                  ;   config_envlen must immediately precede config_wrkseg, because they
  6776                                  ;   may be loaded as a dword ptr
  6777                                  
  6778                                  ; 25/10/2022
  6779                                  ;config_envlen:	dw  0  			; when config_wrkseg is being used as
  6780                                  ;               			;  a scratch env, this is its length
  6781                                  ;config_wrkseg:	dw  0			; config work area (above confbot)
  6782                                  ;                   			;  segment of work area
  6783                                  ;
  6784                                  ;config_cmd:	db  0  			; current config cmd
  6785                                  ;                 			;  (with CONFIG_OPTION_QUERY bit intact)
  6786                                  ;config_multi:	db  0                   ; non-zero if multi-config config.sys
  6787                                  
  6788                                  ;endif ; MULTI_CONFIG
  6789                                  
  6790 00001657 00                      multdeviceflag:	db  0
  6791                                  
  6792 00001658 0000                    devmark_addr:	dw  0			;segment address for devmark.
  6793                                  
  6794 0000165A 00                      setdevmarkflag: db  0			;flag used for devmark
  6795                                  
  6796 0000165B 00                      driver_units:	db  0			;total unitcount for driver
  6797                                  
  6798                                  ems_stub_installed:
  6799 0000165C 00                      		db  0
  6800                                  
  6801                                  badparm_ptr:	; label	dword
  6802 0000165D 0000                    badparm_off:	dw  0
  6803 0000165F 0000                    badparm_seg:	dw  0
  6804                                  
  6805                                  ;******************************************************************************
  6806                                  ;take care of config.sys file.
  6807                                  ;system parser data and code.
  6808                                  ;******************************************************************************
  6809                                  
  6810                                  ;*******************************************************************
  6811                                  ; parser options set for msbio sysconf module
  6812                                  ;*******************************************************************
  6813                                  ;
  6814                                  ;**** default assemble swiches definition **************************
  6815                                  
  6816                                  ;farsw	equ 0		; near call expected
  6817                                  ;datesw	equ 0		; check date format
  6818                                  ;timesw	equ 0		; check time format
  6819                                  ;filesw	equ 1		; check file specification
  6820                                  ;capsw	equ 0		; perform caps if specified
  6821                                  ;cmpxsw	equ 0		; check complex list
  6822                                  ;numsw	equ 1		; check numeric value
  6823                                  ;keysw	equ 0		; support keywords
  6824                                  ;swsw	equ 1		; support switches
  6825                                  ;val1sw	equ 1		; support value definition 1
  6826                                  ;val2sw	equ 0		; support value definition 2
  6827                                  ;val3sw	equ 1		; support value definition 3
  6828                                  ;drvsw	equ 1		; support drive only format
  6829                                  ;qussw	equ 0		; support quoted string format
  6830                                  
  6831                                  ; psdata_seg equ cs
  6832                                  
  6833                                  	;.xlist
  6834                                  	;include parse.asm		;together with psdata.inc
  6835                                  	;.list
  6836                                  
  6837                                  ; PSDATA.INC - MSDOS 6.0 - 1991
  6838                                  ; ======================================================================
  6839                                  ; 27/03/2019 - Retro DOS v4.0
  6840                                  
  6841                                  ; 30/03/2019
  6842                                  ; VERSION.INC (MSDOS 6.0) 
  6843                                  ; Set DBCS Blank constant
  6844                                  
  6845                                  ; ifndef DBCS
  6846                                  DB_SPACE EQU 2020h
  6847                                  DB_SP_HI EQU 20h
  6848                                  DB_SP_LO EQU 20h
  6849                                  ; else
  6850                                  
  6851                                  ;*******************************************************************
  6852                                  ; Parser include file
  6853                                  ;*******************************************************************
  6854                                  
  6855                                  ;**** Equation field
  6856                                  ;-------- Character code definition
  6857                                  
  6858                                  _$P_DBSP1	   equ	DB_SP_HI	;AN000; 1st byte of DBCS blank
  6859                                  _$P_DBSP2	   equ	DB_SP_LO	;AN000; 2nd byte of DBCS blank
  6860                                  _$P_Period	   equ	"."             ;AN020;
  6861                                  _$P_Slash	   equ	"/"             ;AN020;
  6862                                  _$P_Space	   equ	" "             ;AN000; SBCS blank
  6863                                  _$P_Comma	   equ	","             ;AN000;
  6864                                  _$P_Switch	   equ	"/"             ;AN000;
  6865                                  _$P_Keyword	   equ	"="             ;AN000;
  6866                                  _$P_Colon	   equ	":"             ;AN000;
  6867                                  _$P_Plus 	   equ	"+"             ;AN000;
  6868                                  _$P_Minus	   equ	"-"             ;AN000;
  6869                                  _$P_Rparen	   equ	")"             ;AN000;
  6870                                  _$P_Lparen	   equ	"("             ;AN000;
  6871                                  ;_$P_SQuote        equ  "'"			;AN025; deleted
  6872                                  _$P_DQuote	   equ	'"'             ;AN000;
  6873                                  _$P_NULL 	   equ	0		;AN000;
  6874                                  _$P_TAB		   equ	9		;AN000;
  6875                                  _$P_CR		   equ	0Dh		;AN000;
  6876                                  _$P_LF		   equ	0Ah		;AN000;
  6877                                  _$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
  6878                                  
  6879                                  ;-------- Masks
  6880                                  _$P_Make_Lower	   equ	20h		;AN000; make lower case character
  6881                                  _$P_Make_Upper	   equ	0FFh-_$P_Make_Lower ;AN000; make upper case character
  6882                                  
  6883                                  ;-------- DOS function call related equs
  6884                                  
  6885                                  _$P_DOS_Get_CDI	   equ	3800h		;AN000; get country dependent information
  6886                                  					; by this call, following information
  6887                                  struc _$P_CDI	
  6888 00000000 ????                     .DateF: resw 1
  6889 00000002 ??????????               .Money: resb 5
  6890 00000007 ????                     .1000:	 resb 2
  6891 00000009 ????                     .Dec:	 resb 2
  6892 0000000B ????                     .DateS: resb 2
  6893 0000000D ????                     .TimeS: resb 2
  6894 0000000F ??                          	 resb 1
  6895 00000010 ??                      	 resb 1
  6896 00000011 ??                       .TimeF: resb 1	 
  6897 00000012 ????????                	 resw 2
  6898 00000016 ????                    	 resb 2
  6899 00000018 <res Ah>                	 resw 5
  6900                                   .size:
  6901                                  endstruc
  6902                                  
  6903                                  _$P_Date_MDY	   equ	0		;AN000;
  6904                                  _$P_Date_DMY	   equ	1		;AN000;
  6905                                  _$P_Date_YMD	   equ	2		;AN000;
  6906                                  ;-------------
  6907                                  _$P_DOS_GetEV	   equ	6300h		;AN000; get DBCS EV call
  6908                                  					;AN000; DS:SI will points to DBCS EV
  6909                                  ;-------------
  6910                                  _$P_DOS_Get_TBL	   equ	65h		;AN000; get uppercase table call
  6911                                  					;AN000; following parameters are set
  6912                                  					;AN000; to get casemap table.
  6913                                  _$P_DOSTBL_Def	   equ	-1		;AN000; get default
  6914                                  _$P_DOSTBL_BL	   equ	5		;AN000; buffer length for Tbl pointer
  6915                                  _$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
  6916                                  _$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
  6917                                  					; By this call following information
  6918                                  					; is returned.
  6919                                  struc _$P_DOS_TBL
  6920 00000000 ??                       .InfoID: resb 1			;AN000; information id for the table
  6921 00000001 ????                     .Off:	 resw 1				;AN000; offset address of the table
  6922 00000003 ????                     .Seg:	 resw 1				;AN000; segment address of the table
  6923                                  endstruc
  6924                                  
  6925                                  ; ----------------------------------------------------------------------------
  6926                                  ; PARMS 	LABEL	BYTE
  6927                                  ;		DW	PARMSX
  6928                                  ;		DB	2		; NUMBER OF STRINGS (0, 1, 2)
  6929                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  6930                                  ;		DB	" .. "          ; EXTRA DELIMITER LIST,
  6931                                  ;					; TYPICAL ARE ";", "="
  6932                                  ;					; "," & WHITESPACE ALWAYS
  6933                                  ;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
  6934                                  ;		DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
  6935                                  ; ----------------------------------------------------------------------------
  6936                                  
  6937                                  ;-------------------------------- PARMS block structure
  6938                                  struc _$P_PARMS_Blk
  6939 00000000 ????                     .PARMSX_Address:  resw 1		;AN000; Address of PARMSX
  6940 00000002 ??                       .Num_Extra:	   resb 1		;AN000; Number of extra stuff
  6941 00000003 ??                       .Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
  6942                                  endstruc
  6943                                  
  6944                                  _$P_Len_PARMS	   equ	4		;AN000;
  6945                                  _$P_I_Use_Default  equ	0		;AN000; no extra stuff specified
  6946                                  _$P_I_Have_Delim   equ	1		;AN000; extra delimiter specified
  6947                                  _$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
  6948                                  
  6949                                  ; ----------------------------------------------------------------------------
  6950                                  ; PARMSX	LABEL	BYTE
  6951                                  ;		DB	minp,maxp	; MIN, MAX POSITIONAL OPERANDS ALLOWED
  6952                                  ;		DW	CONTROL 	; DESCRIPTION OF POSITIONAL 1
  6953                                  ;		:			; REPEATS maxp-1 TIMES
  6954                                  ;		DB	maxs		; # OF SWITCHES
  6955                                  ;		DW	CONTROL 	; DESCRIPTION OF SWITCH 1
  6956                                  ;		:			; REPEATS maxs-1 TIMES
  6957                                  ;		DB	maxk		; # OF KEYWORD
  6958                                  ;		DW	CONTROL 	; DESCRIPTION OF KEYWORD 1
  6959                                  ;		:			; REPEATS maxk-1 TIMES
  6960                                  ; ----------------------------------------------------------------------------
  6961                                  
  6962                                  ;-------------------------------- PARMSX block structure
  6963                                  struc _$P_PARMSX_Blk		;AN000;
  6964 00000000 ??                       .MinP: resb 1			;AN000; Minimum positional number
  6965 00000001 ??                       .MaxP:	resb 1			;AN000; Maximum positional number
  6966 00000002 ????                     .1st_Control: resw 1		;AN000; Address of the 1st CONTROL block
  6967                                  endstruc
  6968                                  
  6969                                  ; ----------------------------------------------------------------------------
  6970                                  ; << Control field definition  >>
  6971                                  ;
  6972                                  ;
  6973                                  ;CONTROL   LABEL   BYTE
  6974                                  ;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
  6975                                  ;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
  6976                                  ;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
  6977                                  ;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
  6978                                  ;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
  6979                                  ;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
  6980                                  ;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
  6981                                  ;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
  6982                                  ;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
  6983                                  ;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
  6984                                  ;				   ; 0010H=IGNORE ":" AT END IN MATCH
  6985                                  ;				   ; 0002H=REPEATS ALLOWED
  6986                                  ;				   ; 0001H=OPTIONAL
  6987                                  ;	   DW	   FUNCTION_FLAGS
  6988                                  ;				   ; 0001H=CAP RESULT BY FILE TABLE
  6989                                  ;				   ; 0002H=CAP RESULT BY CHAR TABLE
  6990                                  ;				   ; 0010H=REMOVE ":" AT END
  6991                                  ; (tm10)			   ; 0020H=colon is not necessary for switch
  6992                                  ;	   DW	   RESULT	   ; RESULT BUFFER
  6993                                  ;	   DW	   VALUES	   ; VALUE LISTS
  6994                                  ;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
  6995                                  ;	   DB	   "...",0         ; IF n >0, KEYWORD 1
  6996                                  ;	   :
  6997                                  ;
  6998                                  ;Note:
  6999                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
  7000                                  ;      DATE bit simalteniously.
  7001                                  ;
  7002                                  ;      The parser examins each bit along with the following priority.
  7003                                  ;
  7004                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
  7005                                  ;      FILE SPEC -> SIMPLE STRING.
  7006                                  ;
  7007                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
  7008                                  ;      in the result buffer is capitalized.
  7009                                  ;
  7010                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
  7011                                  ;
  7012                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
  7013                                  ;      switch, for example, '/A', then STRING points to;
  7014                                  ;
  7015                                  ;			DB    1 	; number of following synonyms
  7016                                  ;			DB   '/A',0
  7017                                  ;
  7018                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
  7019                                  ;
  7020                                  ;			DB    1 	; number of following synonyms
  7021                                  ;			DB   'CODEPAGE=',0
  7022                                  ;
  7023                                  ;    - "..." must consist of upper case characters only because the parser
  7024                                  ;      performs pattern matching after converting input to upper case (by
  7025                                  ;      using the current country upper case table)
  7026                                  ;
  7027                                  ;    - One "..." can contain only one switch or keyword. If you need, for
  7028                                  ;      example /A and /B, the format will be;
  7029                                  ;
  7030                                  ;			DB    2 	; number of following synonyms
  7031                                  ;			DB    '/A',0
  7032                                  ;			DB    '/B',0
  7033                                  ; ----------------------------------------------------------------------------
  7034                                  
  7035                                  ;**** Match_Flags
  7036                                  
  7037                                  _$P_Num_Val	   equ	8000h		;AN000; Numeric Value
  7038                                  _$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
  7039                                  _$P_Simple_S	   equ	2000h		;AN000; Simple string
  7040                                  _$P_Date_S	   equ	1000h		;AN000; Date string
  7041                                  _$P_Time_S	   equ	0800h		;AN000; Time string
  7042                                  _$P_Cmpx_S	   equ	0400h		;AN000; Complex string
  7043                                  _$P_File_Spc	   equ	0200h		;AN000; File Spec
  7044                                  _$P_Drv_Only	   equ	0100h		;AN000; Drive Only
  7045                                  _$P_Qu_String	   equ	0080h		;AN000; Quoted string
  7046                                  _$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
  7047                                  _$P_Repeat	   equ	0002h		;AN000; Repeat allowed
  7048                                  _$P_Optional	   equ	0001h		;AN000; Optional
  7049                                  
  7050                                  ;**** Function flags
  7051                                  
  7052                                  _$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
  7053                                  _$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
  7054                                  _$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
  7055                                  _$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
  7056                                  
  7057                                  ;-------------------------------- Control block structure
  7058                                  struc _$P_Control_Blk
  7059 00000000 ????                     .Match_Flag:	 resw 1		;AN000; Controls type matched
  7060 00000002 ????                     .Function_Flag: resw 1		;AN000; Function should be taken
  7061 00000004 ????                     .Result_Buf:	 resw 1		; Result buffer address
  7062 00000006 ????                     .Value_List:	 resw 1		;AN000; Value list address
  7063 00000008 ??                       .nid:		 resb 1		;AN000; # of keyword/SW synonyms
  7064 00000009 ??                       .KEYorSW:	 resb 1		;AN000; keyword or sw
  7065                                  endstruc
  7066                                  
  7067                                  ; ----------------------------------------------------------------------------
  7068                                  ; << Value List Definition >>
  7069                                  ;
  7070                                  ;VALUES 	LABEL	BYTE
  7071                                  ;		DB	nval			; NUMBER OF VALUE DEFINITIONS (0 - 3)
  7072                                  ;	     +-
  7073                                  ;	     |	DB	nrng			; NUMBER OF RANGES
  7074                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF RANGE MATCHED
  7075                                  ;	     | +DD	X,Y			; RANGE OF VALUES
  7076                                  ;	     |	:
  7077                                  ;	     |	DB	nnval			; NUMBER OF CHOICES
  7078                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF NUMBER CHOICE MATCHED
  7079                                  ;	     | +DD	VALUE			; SPECIFIC CHOICE IF NUMBER
  7080                                  ;	     |	:
  7081                                  ;	     |	DB	nstrval 		; NUMBER OF CHOICES
  7082                                  ;	     | +DB	ITEM_TAG		; RETURN VALUE IF STRING CHOICE MATCHED
  7083                                  ;	     | +DW	STRING			; SPECIFIC CHOICE IF STING
  7084                                  ;	     +-	:
  7085                                  ;
  7086                                  ;STRING 	DB	"...",0                 ; ASCIIZ STRING IMAGE
  7087                                  ;
  7088                                  ;Note:
  7089                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
  7090                                  ;      when no choice lists are provided.
  7091                                  ;
  7092                                  ;    - STRING must consist of upper case characters only because the parser
  7093                                  ;      performs pattern matching after converting input to upper case (by
  7094                                  ;      using the current country upper case table)
  7095                                  ; ----------------------------------------------------------------------------
  7096                                  
  7097                                  _$P_nval_None	   equ	0		;AN000; no value list ID
  7098                                  _$P_nval_Range	   equ	1		;AN000; range list ID
  7099                                  _$P_nval_Value	   equ	2		;AN000; value list ID
  7100                                  _$P_nval_String	   equ	3		;AN000; string list ID
  7101                                  _$P_Len_Range	   equ	9		;AN000; Length of a range choice(two DD plus one DB)
  7102                                  _$P_Len_Value	   equ	5		;AN000; Length of a value choice(one DD plus one DB)
  7103                                  _$P_Len_String	   equ	3		;AN000; Length of a string choice(one DW plus one DB)
  7104                                  _$P_No_nrng	   equ	0		;AN000; (tm07) no nrng. nnval must not be 0.
  7105                                  
  7106                                  struc _$P_Val_List
  7107 00000000 ??                       .NumofList: resb 1			;AN000; number of following choice
  7108 00000001 ????                     .Val_XL:    resw 1			;AN000; lower word of value
  7109 00000003 ????                     .Val_XH:    resw 1			;AN000; higher word of value
  7110 00000005 ????                     .Val_YL:    resw 1			;AN000; lower word of another value
  7111 00000007 ????                     .Val_YH:    resw 1			;AN000; higher word of another value
  7112                                  endstruc
  7113                                  
  7114                                  ; ----------------------------------------------------------------------------
  7115                                  ; << Result Buffer Definition  >>
  7116                                  ;
  7117                                  ;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
  7118                                  ;		DB	type			; TYPE RETURNED: 0=RESERVED,
  7119                                  ;						;	1=NUMBER, 2=LIST INDEX,
  7120                                  ;						;	3=STRING, 4=COMPLEX,
  7121                                  ;						;	5=FILESPEC, 6=DRIVE
  7122                                  ;						;	7=DATE, 8=TIME
  7123                                  ;						;	9=QUOTED STRING
  7124                                  ;		DB	ITEM_TAG		; MATCHED ITEM TAG
  7125                                  ;
  7126                                  ;		dw	synonym@		; es:@ points to found SYNONYM if provided.
  7127                                  ;
  7128                                  ;            +-
  7129                                  ;	    | DD	n			; VALUE IF NUMBER
  7130                                  ;	    | or
  7131                                  ;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
  7132                                  ;	    |					; (ES presents Segment address)
  7133                                  ;	    | or
  7134                                  ;	    |	DD	STRING			; OFFSET OF STRING VALUE
  7135                                  ;	    | or
  7136                                  ;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
  7137                                  ;	    | or
  7138                                  ;	    |	DW	YEAR	   ;(1980-2099)  IN CASE OF DATE
  7139                                  ;	    |	DB	MONTH	   ;(1-12)	 Note: Range check is not performed.
  7140                                  ;	    |	DB	DATE	   ;(1-31)	       0 is filled when the corresponding field was not specified.
  7141                                  ;	    | or
  7142                                  ;	    |	DB	HOUR	   ;(0-23)	  IN CASE OF TIME
  7143                                  ;	    |	DB	MINUTES    ;(0-59)	  Note: Range check is not performed .
  7144                                  ;	    |	DB	SECONDS    ;(0-59)		0 is filled when the corresponding field was not specified .
  7145                                  ;	    |	DB	HUNDREDTHS ;(0-99)
  7146                                  ;	    +-
  7147                                  ;
  7148                                  ;
  7149                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
  7150                                  ;      list.
  7151                                  ;
  7152                                  ;      YEAR: If the input value for the year is less than 100, parser
  7153                                  ;	     adds 1900 to it.  For example, when 87 is input to parser for
  7154                                  ;	     the year value, he returns 1987.
  7155                                  ; ----------------------------------------------------------------------------
  7156                                  
  7157                                  ;-------------------------------- Result block structure
  7158                                  struc _$P_Result_Blk
  7159 00000000 ??                       .Type:        resb 1		;AN000; Type returned
  7160 00000001 ??                       .Item_Tag:    resb 1		;AN000; Matched item tag
  7161 00000002 ????                     .SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
  7162 00000004 ????????                 .Picked_Val:  resb 4		;AN000; value
  7163                                  endstruc
  7164                                  
  7165                                  ;--------------------------------
  7166                                  ;**** values for the type field in the result block
  7167                                  
  7168                                  _$P_EOL		   equ	0		;AN000; End of line
  7169                                  _$P_Number	   equ	1		;AN000; Number
  7170                                  _$P_List_Idx	   equ	2		;AN000; List Index
  7171                                  _$P_String	   equ	3		;AN000; String
  7172                                  _$P_Complex	   equ	4		;AN000; Complex
  7173                                  _$P_File_Spec	   equ	5		;AN000; File Spec
  7174                                  _$P_Drive	   equ	6		;AN000; Drive
  7175                                  _$P_Date_F	   equ	7		;AN000; Date
  7176                                  _$P_Time_F	   equ	8		;AN000; Time
  7177                                  _$P_Quoted_String  equ	9		;AN000; Quoted String
  7178                                  
  7179                                  _$P_No_Tag	   equ	0FFh		;AN000; No ITEM_TAG found
  7180                                  
  7181                                  ;**** Return code
  7182                                  ;
  7183                                  ; following return code will be returned in the AX register.
  7184                                  
  7185                                  _$P_No_Error	   equ	0		;AN000; No error
  7186                                  _$P_Too_Many	   equ	1		;AN000; Too many operands
  7187                                  _$P_Op_Missing	   equ	2		;AN000; Required operand missing
  7188                                  _$P_Not_In_SW	   equ	3		;AN000; Not in switch list provided
  7189                                  _$P_Not_In_Key	   equ	4		;AN000; Not in keyword list provided
  7190                                  _$P_Out_Of_Range   equ	6		;AN000; Out of range specified
  7191                                  _$P_Not_In_Val	   equ	7		;AN000; Not in value list provided
  7192                                  _$P_Not_In_Str	   equ	8		;AN000; Not in string list provided
  7193                                  _$P_Syntax	   equ	9		;AN000; Syntax error
  7194                                  _$P_RC_EOL	   equ	-1		;AN000; End of command line
  7195                                  
  7196                                  ; DATA - Retro DOS v4.0 - 27/03/2019
  7197                                  
  7198                                  ; MSDOS 6.2 IO.SYS SYSINIT:179Ch
  7199                                  
  7200                                  ;********************** Local Data *************************************
  7201 00001661 0000                    _$P_ORDINAL:	   dw	0		;AN000; Operand ordinal save area
  7202 00001663 0000                    _$P_RC:		   dw	0		;AN000; Return code from parser
  7203 00001665 0000                    _$P_SI_Save:	   dw	0		;AN000; Pointer of command buffer
  7204 00001667 0000                    _$P_DX:		   dw	0		;AN000; Return result buffer address
  7205 00001669 00                      _$P_Terminator:	   db	0		;AN000; Terminator code (ASCII)
  7206 0000166A 0000                    _$P_DBCSEV_OFF:	   dw	0		;AN000; Offset of DBCS EV
  7207 0000166C 0000                    _$P_DBCSEV_SEG:	   dw	0		;AN000; Segment of DBCS EV
  7208 0000166E 0000                    _$P_Flags:	   dw	0		;AN000; Parser internal flags
  7209                                  %define _$P_Flags1 _$P_Flags		;AN038; to reference first byte flags
  7210                                  %define _$P_Flags2 _$P_Flags+1		;AN038; to reference second byte flags only
  7211                                  
  7212                                  ;in second byte of _$P_Flags, referenced as _$P_Flags2:
  7213                                  _$P_equ		   equ	01h	      ;AN000; "=" packed in string buffet
  7214                                  _$P_Neg		   equ	02h	      ;AN000; Negative value
  7215                                  _$P_Time12	   equ	04h	      ;AN000; set when PM is specified
  7216                                  _$P_Key_Cmp	   equ	08h	      ;AN000; set when keyword compare
  7217                                  _$P_SW_Cmp	   equ	10h	      ;AN000; set when switch compare
  7218                                  _$P_Extra	   equ	20h	      ;AN000; set when extra delimiter found
  7219                                  _$P_SW		   equ	40h	      ;AN000; set when switch found (tm08)
  7220                                  _$P_Signed	   equ	80h	      ;AN000; signed numeric specified
  7221                                  
  7222                                  ;in first byte of _$P_Flags, referenced as _$P_Flags1:
  7223                                  _$P_time12am	   equ	01h	      ;AN038; set when AM is specified on time
  7224                                  _$P_TIME_AGAIN	   equ	02h	      ;AN039; SET WHEN READY TO RE-PARSE TIME
  7225                                  
  7226 00001670 0000                    _$P_SaveSI_Cmpx:   dw	0		;AN000; save si for later use by complex
  7227 00001672 0000                    _$P_KEYorSW_Ptr:   dw	0		;AN000; points next to "=" or ":" code
  7228 00001674 0000                    _$P_Save_EOB:	   dw	0		;AN000; save pointer to EOB
  7229 00001676 0000                    _$P_Found_SYNONYM: dw	0		;AN000; es:@ points to found synonym
  7230                                  
  7231 00001678 00<rep 80h>             _$P_STRING_BUF:	   times 128 db 0	;AN000; Pick a operand from command line
  7232                                  _$P_STRING_BUF_END equ	$		;AN000;
  7233                                  
  7234                                  ; 25/10/2022
  7235                                  ; (MSDOS 5.0 IO.SYS, SYSINIT:16F8h)
  7236                                  
  7237 000016F8 FF                      _$P_Char_CAP_Ptr:  db	0FFh		;AN000; info id
  7238 000016F9 0000                    		   dw	0		;AN000; offset	of char case map table
  7239 000016FB 0000                    		   dw	0		;AN000; segment of char case map table
  7240                                  ; 25/10/2022
  7241                                  ;_$P_File_CAP_Ptr: db	0FFh		;AN000; info id
  7242                                  ;		   dw	0		;AN000; offset	of file case map table
  7243                                  ;		   dw	0		;AN000; segment of file case map table
  7244                                  
  7245                                  ; (tm06) IF FileSW			;AN000;(Check if file spec is supported)
  7246                                  ;
  7247                                  
  7248                                  ;M029
  7249                                  ;!!!WARNING!!!
  7250                                  ; In routine SYSPARSE (parse.asm), _$P_FileSp_Char is reinitialized using 
  7251                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
  7252                                  ;changes need to be made in SYSPARSE
  7253                                  
  7254                                  ;IF FileSW+DrvSW 			;AN000;(Check if file spec is supported)
  7255                                  
  7256                                  ; 25/10/2022
  7257                                  ; (MSDOS 5.0 IO.SYS, SYSINIT:16FDh)
  7258                                  
  7259 000016FD 5B5D7C3C3E2B3D3B22      _$P_FileSp_Char	   db	'[]|<>+=;"'     ;AN000; delimitter of file spec
  7260                                  _$P_FileSp_Len	   equ	$-_$P_FileSp_Char ;AN000;
  7261                                  
  7262                                  ;ENDIF					;AN000;(of FileSW)
  7263                                  
  7264                                  ; delimiter parsing
  7265                                  _$P_colon_period   equ	01h		;AN032; check for colon & period
  7266                                  _$P_period_only	   equ	02h		;AN032; check only for period
  7267                                  
  7268                                  ;filespec error flag
  7269 00001706 00                      _$P_err_flag:	   db	0		;AN033; flag set if filespec parsing error
  7270                                  					;AN033;  was detected.
  7271                                  _$P_error_filespec equ	01h		;AN033; mask to set flag
  7272                                  
  7273                                  
  7274                                  ; PARSE.ASM - MSDOS 6.0 - 1991
  7275                                  ; ======================================================================
  7276                                  ; 27/03/2019 - Retro DOS v4.0
  7277                                  
  7278                                  ;***********************************************************************
  7279                                  ; SysParse;
  7280                                  ;
  7281                                  ;  Function : Parser Entry
  7282                                  ;
  7283                                  ;  Input: DS:SI -> command line
  7284                                  ;	  ES:DI -> parameter block
  7285                                  ;	  cs -> psdata.inc
  7286                                  ;	  CX = operand ordinal
  7287                                  ;
  7288                                  ;	  Note:  ES is the segment containing all the control blocks defined
  7289                                  ;		 by the caller, except for the DOS COMMAND line parms, which
  7290                                  ;		 is in DS.
  7291                                  ;
  7292                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
  7293                                  ;		    invalid value list. But this parser does NOT implement
  7294                                  ;		    this feature. Therefore CY always zero.
  7295                                  ;
  7296                                  ;	   CY = 0   AX = return code
  7297                                  ;		    BL = terminated delimiter code
  7298                                  ;		    CX = new operand ordinal
  7299                                  ;		    SI = set past scaned operand
  7300                                  ;		    DX = selected result buffer
  7301                                  ;
  7302                                  ; Use:	_$P_Skip_Delim, _$P_Chk_EOL, _$P_Chk_Delim, _$P_Chk_DBCS
  7303                                  ;	_$P_Chk_Swtch, _$P_Chk_Pos_Control, _$P_Chk_Key_Control
  7304                                  ;	_$P_Chk_Sw_Control, _$P_Fill_Result
  7305                                  ;
  7306                                  ; Vars: _$P_Ordinal(RW), _$P_RC(RW), _$P_SI_Save(RW), _$P_DX(R), _$P_Terminator(R)
  7307                                  ;	_$P_SaveSI_Cmpx(W), _$P_Flags(RW), _$P_Found_SYNONYM(R), _$P_Save_EOB(W)
  7308                                  ;
  7309                                  ;-------- Modification History -----------------------------------------
  7310                                  ;
  7311                                  ;  4/04/87 : Created by K. K,
  7312                                  ;  4/28/87 : _$P_Val_YH assemble error (tm01)
  7313                                  ;	   : JMP SHORT assemble error (tm02)
  7314                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
  7315                                  ;  6/12/87 : _$P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
  7316                                  ;	     DateSW equ 1)	      (tm04)
  7317                                  ;  6/12/87 : _$P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
  7318                                  ;				      (tm05) in PSDATA.INC
  7319                                  ;  6/12/87 : _$P_FileSp_Char and _$P_FileSP_Len are missing
  7320                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
  7321                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
  7322                                  ;	     value-list block	      (tm07)
  7323                                  ;  6/20/87 : Add _$P_SW to check if there's an omiting parameter after
  7324                                  ;	     switch (keyword) or not. If there is, backup si for next call
  7325                                  ;	     (tm08)
  7326                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
  7327                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
  7328                                  ;  6/24/87 : New function flag _$P_colon_is_not_necessary for switch
  7329                                  ;	     /+15 and /+:15 are allowed for user (tm10)
  7330                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
  7331                                  ;	     in user's routines. _$P_Chk_DBCS (tm11)
  7332                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
  7333                                  ;					  (tm12)
  7334                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
  7335                                  ;					  (tm13)
  7336                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
  7337                                  ;					  (tm14)
  7338                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
  7339                                  ;					  (tm15)
  7340                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
  7341                                  
  7342                                  ;  7/24/87 : Quoted strings being returned with quotes.
  7343                                  
  7344                                  ;  7/28/87 : Kerry S (;AN018;)
  7345                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
  7346                                  ;	     as an error when missing.	Solution: return error 2.  Modules
  7347                                  ;	     affected: _$P_Chk_SW_Control.
  7348                                  
  7349                                  ;  7/29/87 : Kerry S (;AN019;)
  7350                                  ;	     Now allow the optional bit in match flags for switches.  This
  7351                                  ;	     allows the switch to be encountered with a value or without a
  7352                                  ;	     value and no error is returned.
  7353                                  ;
  7354                                  
  7355                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
  7356                                  ;  9/14/87   In PROC _$P_Get_DecNum, when checking for field separators
  7357                                  ;	     within a date response, instead of checking just for the one
  7358                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
  7359                                  ;	     all three chars, "-", "/", and ".". Change _$P_Chk_Switch to allow
  7360                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
  7361                                  
  7362                                  ;  9/1/87  : Kerry S (;AN021)
  7363                                  ;	     In PROC _$P_String_Comp, when comparing the switch or keyword on
  7364                                  ;	     the command line with the string in the control block the
  7365                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
  7366                                  ;	     on the command line and assuming a match.	This allowed a shorter
  7367                                  ;	     string on the command line than in the synonym list in the control
  7368                                  ;	     block.  I put in a test for a null in the control block so the
  7369                                  ;	     string in the control block must be the same length as the string
  7370                                  ;	     preceeding the colon or equal on the command line.
  7371                                  
  7372                                  ;  8/28/87 : Kerry S (;AN022;)
  7373                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
  7374                                  ;	     problems for people who included it themselves in a segment other
  7375                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
  7376                                  ;	     segment.
  7377                                  
  7378                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
  7379                                  ;	     in _$P_set_cdi PROC, it assumes CS points to psdata. Change Push CS
  7380                                  ;	     into PUSH cs.  In _$P_Get_DecNum PROC, fix AN020
  7381                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
  7382                                  ;	     Created FLag, in _$P_time_Format PROC, to request the delim in
  7383                                  ;	     BL be used if TIME is being parsed.
  7384                                  
  7385                                  ;  9/24/87 : Ed K
  7386                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
  7387                                  ;	     invocations with their normally expanded code; made comments
  7388                                  ;	     out of the STRUC macro invocation statements to maintain readability.
  7389                                  
  7390                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
  7391                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
  7392                                  ;	     pointed to by non-existant CONTROL.
  7393                                  
  7394                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
  7395                                  ;	     A quoted text string can be framed only by double quote.  Remove
  7396                                  ;	     support to frame quoted text string with single quote.
  7397                                  ;	     (apostrophe) _$P_SorD_Quote is removed from PSDATA.INC.
  7398                                  ;	     _$P_SQuote EQU also removed from PSDATA.INC.  Any references to
  7399                                  ;	     single quote in PROC prologues are left as is for history reasons.
  7400                                  
  7401                                  ;	     This fixes another bug, not mentioned in p1672, in that two
  7402                                  ;	     quote chars within a quoted string is supposed to be reported as
  7403                                  ;	     one quote character, but is reported as two quotes.  This changed
  7404                                  ;	     two instructions in PROC _$P_Quoted_Str.
  7405                                  
  7406                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
  7407                                  ;	     have the SHORT operator to avoid the unneeded NOP.
  7408                                  
  7409                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
  7410                                  
  7411                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
  7412                                  ;	     psdata buffer should have cs.
  7413                                  
  7414                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
  7415                                  ;	     positional missing.
  7416                                  
  7417                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
  7418                                  ;	     as a line delimiter, should use carriage return.
  7419                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
  7420                                  
  7421                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
  7422                                  
  7423                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
  7424                                  ;	     endless loop since SI is returned still pointing to start
  7425                                  ;	     of that parm.
  7426                                  
  7427                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
  7428                                  ;	     Vector to returned string has CS instead of cs, but
  7429                                  ;	     when tried to fix it on previous version, changed similar
  7430                                  ;	     but wrong place.
  7431                                  
  7432                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
  7433                                  ;	     delimiters between hours, minutes, seconds for time. And period
  7434                                  ;	     and comma are valid delimiters between seconds and 100th second.
  7435                                  
  7436                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
  7437                                  ;	     in a filespec, then flag an error.
  7438                                  
  7439                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
  7440                                  ;	     indexed off of the cs equate instead of the DS register.
  7441                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
  7442                                  ;  -->	     local parser data. Why were some references to local data changed
  7443                                  ;	     to do this before, but not all ?????
  7444                                  
  7445                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
  7446                                  
  7447                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, cs HOSED.
  7448                                  ;
  7449                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
  7450                                  
  7451                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
  7452                                  
  7453                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
  7454                                  ;	     separator in TIME before hundredths field.
  7455                                  ;
  7456                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
  7457                                  ;			strings as keywords.
  7458                                  ;
  7459                                  ;***********************************************************************
  7460                                  
  7461                                  ;IF FarSW				;AN000;(Check if need far return)
  7462                                  ;SysParse proc far			;AN000;
  7463                                  ;ELSE					;AN000;
  7464                                  ;SysParse proc near			;AN000;
  7465                                  ;ENDIF					;AN000;(of FarSW)
  7466                                  
  7467                                  ; 27/03/2019 - Retro DOS v4.0
  7468                                  ; (MSDOS 6.21 IO.SYS - SYSINIT:1842h)
  7469                                  
  7470                                  ; 25/10/2022 - Retro DOS v4.0
  7471                                  ; (MSDOS 5.0 IO.SYS - SYSINIT:1707h)
  7472                                  
  7473                                  SysParse:
  7474 00001707 2EC706[6E16]0000        	mov	word [cs:_$P_Flags],0	;AC034; Clear all internal flags
  7475 0000170E FC                      	cld				;AN000; confirm forward direction
  7476 0000170F 2E890E[6116]            	mov	word [cs:_$P_ORDINAL],cx ;AC034; save operand ordinal
  7477 00001714 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; Assume no error
  7478 0000171B 2EC706[7616]0000        	mov	word [cs:_$P_Found_SYNONYM],0 ;AC034; initalize synonym pointer
  7479                                  
  7480 00001722 2EC706[6716]0000        	mov	word [cs:_$P_DX],0	;AC034; (tm15)
  7481                                  
  7482                                  ;M029 -- Begin changes
  7483                                  ; The table of special chars _$P_FileSp_Char should be initialized on every
  7484                                  ;entry to SysParse. This is in the non-checksum region and any program that
  7485                                  ;corrupts this table but does not corrupt the checksum region will leave
  7486                                  ;command.com parsing in an inconsistent state.
  7487                                  ; NB: The special characters string has been hardcoded here. If any change
  7488                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
  7489                                  
  7490                                  ;IF FileSW + DrvSW
  7491 00001729 2EC706[FD16]5D5B        	mov	word [cs:_$P_FileSp_Char], ']['
  7492 00001730 2EC706[FF16]3C7C        	mov	word [cs:_$P_FileSp_Char+2], '<|'
  7493 00001737 2EC706[0117]2B3E        	mov	word [cs:_$P_FileSp_Char+4], '+>'
  7494 0000173E 2EC706[0317]3B3D        	mov 	word [cs:_$P_FileSp_Char+6], ';='
  7495                                  ;ENDIFtHHH
  7496                                  
  7497                                  ;M029 -- End of changes
  7498                                  
  7499 00001745 E8CF06                  	call	_$P_Skip_Delim		;AN000; Move si to 1st non white space
  7500 00001748 7313                    	jnc	short _$P_Start		;AN000; If EOL is not encountered, do parse
  7501                                  ;--------------------------- End of Line
  7502 0000174A B8FFFF                  	mov	ax,_$P_RC_EOL		;AN000; set exit code to -1
  7503 0000174D 53                      	push	bx			;AN000;
  7504                                  	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address]
  7505                                  					;AN000; Get the PARMSX address to
  7506 0000174E 268B1D                  	mov	bx,[es:di]
  7507                                  	;cmp	cl,[es:bx+_$P_PARMSX_Blk.MinP]
  7508                                  					;AN000; check ORDINAL to see if the minimum
  7509 00001751 263A0F                  	cmp	cl,[es:bx]	
  7510 00001754 7303                    	jae	short _$P_Fin		;AN000; positional found.
  7511                                  
  7512 00001756 B80200                  	mov	ax,_$P_Op_Missing	;AN000; If no, set exit code to missing operand
  7513                                  _$P_Fin: 				;AN000;
  7514 00001759 5B                      	pop	bx			;AN000;
  7515 0000175A E92301                  	jmp	_$P_Single_Exit		;AN000; return to the caller
  7516                                  ;---------------------------
  7517                                  _$P_Start:				;AN000;
  7518 0000175D 2E8936[7016]            	mov	[cs:_$P_SaveSI_Cmpx],si ;AN000;AC034; save ptr to command line for later use by complex,
  7519 00001762 53                      	push	bx			;AN000; quoted string or file spec.
  7520 00001763 57                      	push	di			;AN000;
  7521 00001764 55                      	push	bp			;AN000;
  7522                                  	;lea	bx,[cs:_$P_STRING_BUF] ;AC034; set buffer to copy from command string
  7523                                  	; 02/11/2022
  7524 00001765 8D1E[7816]              	lea	bx,[_$P_STRING_BUF]
  7525 00001769 2EF606[6F16]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 extra delimiter encountered ?
  7526 0000176F 7543                    	jnz	short _$P_Pack_End	;AN000; 3/9 if yes, no need to copy
  7527                                  
  7528                                  _$P_Pack_Loop:				;AN000;
  7529 00001771 AC                      	lodsb				;AN000; Pick a operand from buffer
  7530 00001772 E85F07                  	call	_$P_Chk_Switch		;AN000; Check switch character
  7531 00001775 723C                    	jc	short _$P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
  7532                                  
  7533 00001777 E8C306                  	call	_$P_Chk_EOL		;AN000; Check EOL character
  7534 0000177A 7437                    	je	short _$P_Pack_End_BY_EOL ;AN000; need backup si
  7535                                  
  7536 0000177C E8F406                  	call	_$P_Chk_Delim		;AN000; Check delimiter
  7537 0000177F 7518                    	jne	short _$P_PL01 		;AN000; If no, process next byte
  7538                                  
  7539 00001781 2EF606[6F16]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 If yes and white spec,
  7540                                  ; (tm08)jne	short _$P_Pack_End	;AN000; 3/9 then
  7541 00001787 7505                    	jnz	short _$P_Pack_End_backup_si ;AN000; (tm08)
  7542                                  
  7543 00001789 E88B06                  	call	_$P_Skip_Delim		;AN000; skip subsequent white space,too
  7544 0000178C EB26                    	jmp	short _$P_Pack_End	;AN000; finish copy by placing NUL at end
  7545                                  
  7546                                  _$P_Pack_End_backup_si:			;AN000; (tm08)
  7547 0000178E 2EF606[6F16]41          	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AN000;AC034;  (tm08)
  7548 00001794 741E                    	jz	short _$P_Pack_End	;AN000; (tm08)
  7549                                  
  7550 00001796 4E                      	dec	si			;AN000; (tm08)
  7551 00001797 EB1B                    	jmp	short _$P_Pack_End	;AN025; (tm08)
  7552                                  
  7553                                  _$P_PL01:				;AN000;
  7554 00001799 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
  7555 0000179C 3C3D                    	cmp	al,_$P_Keyword  ;'='	;AN000; if it is equal character,
  7556 0000179E 7506                    	jne	short _$P_PL00 		;AN000; then
  7557                                  
  7558 000017A0 2E800E[6F16]01          	or	byte [cs:_$P_Flags2],_$P_equ ;AC034; remember it in flag
  7559                                  _$P_PL00:				;AN000;
  7560 000017A6 43                      	inc	bx			;AN000; ready to see next byte
  7561 000017A7 E84807                  	call	_$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
  7562 000017AA 73C5                    	jnc	_$P_Pack_Loop		;AN000; if no, process to next byte
  7563                                  
  7564 000017AC AC                      	lodsb				;AN000; if yes, store
  7565 000017AD 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
  7566 000017B0 43                      	inc	bx			;AN000; update pointer
  7567 000017B1 EBBE                    	jmp	short _$P_Pack_Loop	;AN000; process to next byte
  7568                                  
  7569                                  _$P_Pack_End_BY_EOL:			;AN000;
  7570 000017B3 4E                      	dec	si			;AN000; backup si pointer
  7571                                  _$P_Pack_End:				;AN000;
  7572 000017B4 2E8936[6516]            	mov	[cs:_$P_SI_Save],si     ;AC034; save next pointer, SI
  7573 000017B9 2EC60700                	mov	byte [cs:bx],_$P_NULL	;AN000; put NULL at the end
  7574 000017BD 2E891E[7416]            	mov	[cs:_$P_Save_EOB],bx    ;AC034; 3/17/87 keep the address for later use of complex
  7575                                  	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address] ;AN000; get PARMSX address
  7576 000017C2 268B1D                  	mov	bx,[es:di]
  7577                                  	;lea	si,[cs:_$P_STRING_BUF]	;AC034;
  7578                                  	; 02/11/2022
  7579 000017C5 8D36[7816]              	lea	si,[_$P_STRING_BUF]
  7580 000017C9 2E803C2F                	cmp	byte [cs:si],_$P_Switch ;AN000; the operand begins w/ switch char ?
  7581 000017CD 7436                    	je	short _$P_SW_Manager	;AN000; if yes, process as switch
  7582                                  
  7583 000017CF 2E803C22                	cmp	byte [cs:si],_$P_DQuote	;M005;is it a string?
  7584 000017D3 7408                    	je	short _$P_Positional_Manager ;M005;if so, process as one!
  7585                                  
  7586 000017D5 2EF606[6F16]01          	test	byte [cs:_$P_Flags2],_$P_equ ;AC034; the operand includes equal char ?
  7587 000017DB 7554                    	jnz	short _$P_Key_Manager	;AN000; if yes, process as keyword
  7588                                  
  7589                                  _$P_Positional_Manager:			;AN000; else process as positional
  7590 000017DD 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
  7591 000017E1 30E4                    	xor	ah,ah			;AN000; ax = maxp
  7592 000017E3 2E3906[6116]            	cmp	[cs:_$P_ORDINAL],ax	;AC034; too many positional ?
  7593 000017E8 7312                    	jae	short _$P_Too_Many_Error ;AN000; if yes, set exit code to too many
  7594                                  
  7595 000017EA 2EA1[6116]              	mov	ax,[cs:_$P_ORDINAL]	;AC034; see what the current ordinal
  7596 000017EE D1E0                    	shl	ax,1			;AN000; ax = ax*2
  7597 000017F0 43                      	inc	bx			;AC035; add '2' to
  7598 000017F1 43                      	inc	bx			;AC035;  BX reg
  7599                                  					;AN000; now bx points to 1st CONTROL
  7600 000017F2 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
  7601 000017F4 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
  7602 000017F7 E88800                  	call	_$P_Chk_Pos_Control	;AN000; Do process for positional
  7603 000017FA EB69                    	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller
  7604                                  
  7605                                  _$P_Too_Many_Error:			;AN000;
  7606 000017FC 2EC706[6316]0100        	mov	word [cs:_$P_RC],_$P_Too_Many ;AC034; set exit code
  7607 00001803 EB60                    	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller
  7608                                  
  7609                                  _$P_SW_Manager:				;AN000;
  7610 00001805 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
  7611 00001809 30E4                    	xor	ah,ah			;AN000; ax = maxp
  7612 0000180B 40                      	inc	ax			;AN000;
  7613 0000180C D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
  7614 0000180E 01C3                    	add	bx,ax			;AN000; now bx points to maxs
  7615 00001810 268A0F                  	mov	cl,[es:bx]		;AN000;
  7616 00001813 30ED                    	xor	ch,ch			;AN000; cx = maxs
  7617 00001815 09C9                    	or	cx,cx			;AN000; at least one switch ?
  7618 00001817 740F                    	jz	short _$P_SW_Not_Found 	;AN000;
  7619                                  
  7620 00001819 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
  7621                                  
  7622                                  _$P_SW_Mgr_Loop: 			;AN000;
  7623 0000181A 53                      	push	bx			;AN000;
  7624 0000181B 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
  7625 0000181E E8C600                  	call	_$P_Chk_SW_Control	;AN000; do process for switch
  7626 00001821 5B                      	pop	bx			;AN000;
  7627 00001822 7341                    	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the switch, exit
  7628                                  
  7629 00001824 43                      	inc	bx			;AC035; add '2' to
  7630 00001825 43                      	inc	bx			;AC035;  BX reg
  7631                                  					;AN000; else bx points to the next CONTROL
  7632 00001826 E2F2                    	loop	_$P_SW_Mgr_Loop		;AN000; and loop
  7633                                  
  7634                                  _$P_SW_Not_Found:			;AN000;
  7635 00001828 2EC706[6316]0300        	mov	word [cs:_$P_RC],_$P_Not_In_SW ;AC034; here no CONTROL for the switch has
  7636 0000182F EB34                    	jmp	short _$P_Return_to_Caller ;AN000; not been found, means error.
  7637                                  
  7638                                  _$P_Key_Manager: 			;AN000;
  7639 00001831 268A4701                	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
  7640 00001835 30E4                    	xor	ah,ah			;AN000; ax = maxp
  7641 00001837 40                      	inc	ax			;AN000;
  7642 00001838 D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
  7643 0000183A 01C3                    	add	bx,ax			;AN000; now bx points to maxs
  7644 0000183C 268A07                  	mov	al,[es:bx]		;AN000;
  7645 0000183F 30E4                    	xor	ah,ah			;AN000; ax = maxs
  7646 00001841 D1E0                    	shl	ax,1			;AN000;
  7647 00001843 40                      	inc	ax			;AN000; ax = ax*2+1
  7648 00001844 01C3                    	add	bx,ax			;AN000; now bx points to maxk
  7649 00001846 268A0F                  	mov	cl,[es:bx]		;AN000;
  7650 00001849 30ED                    	xor	ch,ch			;AN000; cx = maxk
  7651 0000184B 09C9                    	or	cx,cx			;AN000; at least one keyword ?
  7652 0000184D 740F                    	je	short _$P_Key_Not_Found	;AN000;
  7653                                  
  7654 0000184F 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
  7655                                  
  7656                                  _$P_Key_Mgr_Loop:			;AN000;
  7657 00001850 53                      	push	bx			;AN000;
  7658 00001851 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
  7659 00001854 E85D00                  	call	_$P_Chk_Key_Control	;AN000; do process for keyword
  7660 00001857 5B                      	pop	bx			;AN000;
  7661 00001858 730B                    	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the keyword, exit
  7662                                  
  7663 0000185A 43                      	inc	bx			;AC035; add '2' to
  7664 0000185B 43                      	inc	bx			;AC035;  BX reg
  7665                                  					;AN000; else bx points to the next CONTROL
  7666 0000185C E2F2                    	loop	_$P_Key_Mgr_Loop 	;AN000; and loop
  7667                                  
  7668                                  _$P_Key_Not_Found:			;AN000;
  7669 0000185E 2EC706[6316]0400        	mov	word [cs:_$P_RC],_$P_Not_In_Key ;AC034; here no CONTROL for the keyword has
  7670                                  _$P_Return_to_Caller:			;AN000;
  7671 00001865 5D                      	pop	bp			;AN000;
  7672 00001866 5F                      	pop	di			;AN000;
  7673 00001867 5B                      	pop	bx			;AN000;
  7674 00001868 2E8B0E[6116]            	mov	cx,[cs:_$P_ORDINAL]	;AC034; return next ordinal
  7675 0000186D 2EA1[6316]              	mov	ax,[cs:_$P_RC]		;AC034; return exit code
  7676 00001871 2E8B36[6516]            	mov	si,[cs:_$P_SI_Save]	;AC034; return next operand pointer
  7677 00001876 2E8B16[6716]            	mov	dx,[cs:_$P_DX]		;AC034; return result buffer address
  7678 0000187B 2E8A1E[6916]            	mov	bl,[cs:_$P_Terminator]	;AC034; return delimiter code found
  7679                                  _$P_Single_Exit: 			;AN000;
  7680 00001880 F8                      	clc				;AN000;
  7681 00001881 C3                      	retn				;AN000;
  7682                                  
  7683                                  ;***********************************************************************
  7684                                  ; _$P_Chk_Pos_Control
  7685                                  ;
  7686                                  ; Function: Parse CONTROL block for a positional
  7687                                  ;
  7688                                  ; Input:     ES:BX -> CONTROL block
  7689                                  ;	     cs:SI -> _$P_STRING_BUF
  7690                                  ;
  7691                                  ; Output:    None
  7692                                  ;
  7693                                  ; Use:	 _$P_Fill_Result, _$P_Check_Match_Flags
  7694                                  ;
  7695                                  ; Vars: _$P_Ordinal(W), _$P_RC(W)
  7696                                  ;***********************************************************************
  7697                                  
  7698                                  _$P_Chk_Pos_Control:
  7699 00001882 50                      	push	ax			;AN000;
  7700                                  	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag] ;AN000;
  7701 00001883 268B07                  	mov	ax,[es:bx]
  7702 00001886 A90200                  	test	ax,_$P_Repeat		;AN000; repeat allowed ?
  7703 00001889 7505                    	jnz	short _$P_CPC00		;AN000; then do not increment ORDINAL
  7704                                  
  7705 0000188B 2EFF06[6116]            	inc	word [cs:_$P_ORDINAL]	;AC034; update the ordinal
  7706                                  _$P_CPC00:				;AN000;
  7707 00001890 2E803C00                	cmp	byte [cs:si],_$P_NULL	;AN000; no data ?
  7708 00001894 7519                    	jne	short _$P_CPC01		;AN000;
  7709                                  
  7710 00001896 A90100                  	test	ax,_$P_Optional		;AN000; yes, then is it optional ?
  7711 00001899 7509                    	jnz	short _$P_CPC02		;AN000;
  7712                                  
  7713 0000189B 2EC706[6316]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; no, then error 3/17/87
  7714 000018A2 EB0E                    	jmp	short _$P_CPC_Exit	;AN000;
  7715                                  
  7716                                  _$P_CPC02:				;AN000;
  7717 000018A4 50                      	push	ax			;AN000;
  7718 000018A5 B003                    	mov	al,_$P_String		;AN000; if it is optional return NULL
  7719 000018A7 B4FF                    	mov	ah,_$P_No_Tag		;AN000; no item tag indication
  7720 000018A9 E89E00                  	call	_$P_Fill_Result		;AN000;
  7721 000018AC 58                      	pop	ax			;AN000;
  7722 000018AD EB03                    	jmp	short _$P_CPC_Exit	;AN000;
  7723                                  
  7724                                  _$P_CPC01:				;AN000;
  7725 000018AF E81D01                  	call	_$P_Check_Match_Flags	;AN000;
  7726                                  _$P_CPC_Exit:				;AN000;
  7727 000018B2 58                      	pop	ax			;AN000;
  7728 000018B3 C3                      	retn				;AN000;
  7729                                  
  7730                                  ;***********************************************************************
  7731                                  ; _$P_Chk_Key_Control
  7732                                  ;
  7733                                  ; Function: Parse CONTROL block for a keyword
  7734                                  ;
  7735                                  ; Input:     ES:BX -> CONTROL block
  7736                                  ;	     cs:SI -> _$P_STRING_BUF
  7737                                  ;
  7738                                  ; Output:    CY = 1 : not match
  7739                                  ;
  7740                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  7741                                  ;
  7742                                  ; Vars: _$P_RC(W), _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  7743                                  ;***********************************************************************
  7744                                  
  7745                                  _$P_Chk_Key_Control:
  7746 000018B4 F9                      	stc				;AN000; this logic works when the KeySW
  7747 000018B5 C3                      	retn				;AN000; is reset.
  7748                                  
  7749                                  ;***********************************************************************
  7750                                  ; _$P_Search_KEYorSW:
  7751                                  ;
  7752                                  ; Function: Seach specified keyword or switch from CONTROL
  7753                                  ;
  7754                                  ; Input:     ES:BX -> CONTROL block
  7755                                  ;	     cs:SI -> _$P_STRING_BUF
  7756                                  ;
  7757                                  ; Output:    CY = 1 : not match
  7758                                  ;
  7759                                  ; Use:	 _$P_String_Comp, _$P_MoveBP_NUL, _$P_Found_SYNONYM
  7760                                  ;***********************************************************************
  7761                                  
  7762                                  	; 25/10/2022 - Retro DOS v4.0
  7763                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:18B6h)
  7764                                  
  7765                                  _$P_Search_KEYorSW:			;AN000;
  7766 000018B6 55                      	push	bp			;AN000;
  7767 000018B7 51                      	push	cx			;AN000;
  7768 000018B8 268A4F08                	mov	cl,[es:bx+_$P_Control_Blk.nid] ;AN000; Get synonym count
  7769 000018BC 30ED                    	xor	ch,ch			;AN000; and set it to cx
  7770 000018BE 09C9                    	or	cx,cx			;AN000; No synonyms specified ?
  7771 000018C0 740D                    	jz	short _$P_KEYorSW_Not_Found ;AN000; then indicate not found by CY
  7772                                  
  7773                                  	;lea	bp,[es:bx+_$P_Control_Blk.KEYorSW] ;AN000; BP points to the 1st synonym
  7774                                  	; 25/10/2022
  7775 000018C2 8D6F09                  	lea	bp,[bx+_$P_Control_Blk.KEYorSW]
  7776                                  	;lea	bp,[bx+9]
  7777                                  _$P_KEYorSW_Loop:			;AN000;
  7778 000018C5 E8E203                  	call	_$P_String_Comp		;AN000; compare string in buffer w/ the synonym
  7779 000018C8 7308                    	jnc	short _$P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
  7780                                  
  7781 000018CA E80E00                  	call	_$P_MoveBP_NUL		;AN000; else, bp points to the next string
  7782 000018CD E2F6                    	loop	_$P_KEYorSW_Loop 	;AN000; loop nid times
  7783                                  _$P_KEYorSW_Not_Found:			;AN000;
  7784 000018CF F9                      	stc				;AN000; indicate not found in synonym list
  7785 000018D0 EB06                    	jmp	short _$P_KEYorSW_Exit	;AN000; and exit
  7786                                  
  7787                                  _$P_KEYorSW_Found:			;AN000;
  7788 000018D2 2E892E[7616]            	mov	[cs:_$P_Found_SYNONYM],bp ;AC034; set synonym pointer
  7789 000018D7 F8                      	clc				;AN000; indicate found
  7790                                  _$P_KEYorSW_Exit:			;AN000;
  7791 000018D8 59                      	pop	cx			;AN000;
  7792 000018D9 5D                      	pop	bp			;AN000;
  7793 000018DA C3                      	retn				;AN000;
  7794                                   
  7795                                  ;***********************************************************************
  7796                                  ; _$P_MoveBP_NUL
  7797                                  ;***********************************************************************
  7798                                  
  7799                                  _$P_MoveBP_NUL:
  7800                                  _$P_MBP_Loop:				;AN000;
  7801                                  	;cmp	byte [es:bp],_$P_NULL	;AN000; Increment BP that points
  7802                                  	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
  7803                                  	; (SYSINIT:18DBh)
  7804 000018DB 26807E0000               	cmp     byte [es:bp+0], 0
  7805 000018E0 7403                    	je	short _$P_MBP_Exit	;AN000; to the synomym list
  7806                                  
  7807 000018E2 45                      	inc	bp			;AN000; until
  7808 000018E3 EBF6                    	jmp	short _$P_MBP_Loop	;AN000; NULL encountered.
  7809                                  
  7810                                  _$P_MBP_Exit:				;AN000;
  7811 000018E5 45                      	inc	bp			;AN000; bp points to next to NULL
  7812 000018E6 C3                      	retn				;AN000;
  7813                                  
  7814                                  ;***********************************************************************
  7815                                  ; _$P_Chk_SW_Control
  7816                                  ;
  7817                                  ; Function: Parse CONTROL block for a switch
  7818                                  ;
  7819                                  ; Input:     ES:BX -> CONTROL block
  7820                                  ;	     cs:SI -> _$P_STRING_BUF
  7821                                  ;
  7822                                  ; Output:    CY = 1 : not match
  7823                                  ;
  7824                                  ; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
  7825                                  ;
  7826                                  ; Vars:  _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
  7827                                  ;***********************************************************************
  7828                                  
  7829                                  _$P_Chk_SW_Control:
  7830                                  
  7831                                  ;IF SwSW				;AN000;(Check if switch is supported)
  7832                                  	;or	byte [cs:_$P_Flags+1],10h
  7833 000018E7 2E800E[6F16]10          	or	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; Indicate switch for later string comparison
  7834 000018ED E8C6FF                  	call	_$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
  7835 000018F0 724A                    	jc	short _$P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
  7836                                  
  7837                                  	;and	[cs:_$P_Flags+],0EFh
  7838 000018F2 2E8026[6F16]EF          	and	byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp 
  7839                                  					;AC034; reset the indicator previously set
  7840 000018F8 50                      	push	ax			;AN000; 	      /switch:
  7841 000018F9 2EA1[7216]              	mov	ax,[cs:_$P_KEYorSW_Ptr] ;AC034;	      ^       ^
  7842 000018FD 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
  7843 000018FF 2E0106[7016]            	add	[cs:_$P_SaveSI_Cmpx],ax	;AC034; update for complex list
  7844 00001904 58                      	pop	ax			;AN000;
  7845                                  
  7846 00001905 2E8B36[7216]            	mov	si,[cs:_$P_KEYorSW_Ptr] ;AC034; set si at the end or colon
  7847 0000190A 2E803C00                	cmp	byte [cs:si],_$P_NULL	;AN000; any data after colon
  7848 0000190E 7526                    	jne	short _$P_CSW00		;AN000; if yes, process match flags
  7849                                  
  7850 00001910 2E807CFF3A              	cmp	byte [cs:si-1],_$P_Colon ;AN000; if no, the switch terminated by colon ?
  7851 00001915 7509                    	jne	short _$P_Chk_if_data_required ;AN000; if yes,
  7852                                  
  7853 00001917 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; return syntax error
  7854 0000191E EB1F                    	jmp	short _$P_Chk_SW_Exit	;AN000;
  7855                                  
  7856                                  _$P_Chk_if_data_required:		;AN018; no data, no colon
  7857                                  	;cmp	word [es:bx+_$P_Control_Blk.Match_Flag],0 
  7858 00001920 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
  7859 00001924 7419                    	je	short _$P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
  7860                                  
  7861                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional 
  7862                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYINIT compatibility)
  7863                                  	;test	word [es:bx],1
  7864 00001926 26F7070100              	test	word [es:bx],_$P_Optional ;AN019; see if no value is valid
  7865                                  	;test	byte [es:bx],_$P_Optional
  7866 0000192B 7512                    	jnz	short _$P_Chk_SW_Exit	;AN019; if so, then leave, else yell
  7867                                  
  7868 0000192D 2EC706[6316]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; return required operand missing
  7869 00001934 EB09                    	jmp	short _$P_Chk_SW_Exit	;AN018;
  7870                                  
  7871                                  _$P_CSW00:				;AN000;
  7872 00001936 E89600                  	call	_$P_Check_Match_Flags	;AN000; process match flag
  7873 00001939 F8                      	clc				;AN000; indicate match
  7874 0000193A EB0D                    	jmp	short _$P_Chk_SW_Single_Exit ;AN000;
  7875                                  
  7876                                  _$P_Chk_SW_Err0: 			;AN000;
  7877 0000193C F9                      	stc				;AN000; not found in switch synonym list
  7878 0000193D EB0A                    	jmp	short _$P_Chk_SW_Single_Exit ;AN000;
  7879                                  
  7880                                  _$P_Chk_SW_Exit: 			;AN000;
  7881 0000193F 50                      	push	ax			;AN000;
  7882 00001940 B003                    	mov	al,_$P_String		;AN000; set
  7883 00001942 B4FF                    	mov	ah,_$P_No_Tag		;AN000;    result
  7884 00001944 E80300                  	call	_$P_Fill_Result		;AN000; 	 buffer
  7885 00001947 58                      	pop	ax			;AN000;
  7886 00001948 F8                      	clc				;AN000;
  7887                                  _$P_Chk_SW_Single_Exit:			;AN000;
  7888 00001949 C3                      	retn				;AN000;
  7889                                  ;ELSE					;AN000;(of IF SwSW)
  7890                                  ;	stc				;AN000; this logic works when the SwSW
  7891                                  ;	retn				;AN000; is reset.
  7892                                  
  7893                                  ;***********************************************************************
  7894                                  ; _$P_Fill_Result
  7895                                  ;
  7896                                  ; Function: Fill the result buffer
  7897                                  ;
  7898                                  ; Input:    AH = Item tag
  7899                                  ;	    AL = type
  7900                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
  7901                                  ;		  AL = 2: DX has index(offset) into value list
  7902                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
  7903                                  ;		  AL = 7: DX has year, CL has month and CH has date
  7904                                  ;		  AL = 8: DL has hours, DH has minutes, CL has seconds,
  7905                                  ;			  amd CH has hundredths
  7906                                  ;		  AL = else: cs:SI points to returned string buffer
  7907                                  ;	    ES:BX -> CONTROL block
  7908                                  ;
  7909                                  ; Output:   None
  7910                                  ;
  7911                                  ; Use:	_$P_Do_CAPS_String, _$P_Remove_Colon, _$P_Found_SYNONYM
  7912                                  ;
  7913                                  ; Vars: _$P_DX(W)
  7914                                  ;***********************************************************************
  7915                                  
  7916                                  _$P_Fill_Result:
  7917 0000194A 57                      	push	di			;AN000;
  7918 0000194B 268B7F04                	mov	di,[es:bx+_$P_Control_Blk.Result_Buf]
  7919                                  					;AN000; di points to result buffer
  7920 0000194F 2E893E[6716]            	mov	[cs:_$P_DX],di		;AC034; set returned result address
  7921 00001954 268805                  	mov	[es:di+_$P_Result_Blk.Type],al ;AN000; store type
  7922 00001957 26886501                	mov	[es:di+_$P_Result_Blk.Item_Tag],ah ;AN000; store item tag
  7923 0000195B 50                      	push	ax			;AN000;
  7924 0000195C 2EA1[7616]              	mov	ax,[cs:_$P_Found_SYNONYM] ;AC034; if yes,
  7925 00001960 26894502                	mov	[es:di+_$P_Result_Blk.SYNONYM_Ptr],ax 
  7926                                  					;AN000;   then set it to the result
  7927 00001964 58                      	pop	ax			;AN000;
  7928                                  _$P_RLT04:				;AN000;
  7929 00001965 3C01                    	cmp	al,_$P_Number		;AN000; if number
  7930 00001967 750A                    	jne	short _$P_RLT00		;AN000;
  7931                                  
  7932                                  _$P_RLT02:				;AN000;
  7933 00001969 26895504                	mov	[es:di+_$P_Result_Blk.Picked_Val],dx ;AN000; then store 32bit
  7934 0000196D 26894D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cx ;AN000; number
  7935 00001971 EB5A                    	jmp	short _$P_RLT_Exit	;AN000;
  7936                                  
  7937                                  _$P_RLT00:				;AN000;
  7938 00001973 3C02                    	cmp	al,_$P_List_Idx		;AN000; if list index
  7939 00001975 7506                    	jne	short _$P_RLT01		;AN000;
  7940                                  
  7941 00001977 26895504                	mov	word [es:di+_$P_Result_Blk.Picked_Val],dx 
  7942                                  					;AN000; then store list index
  7943 0000197B EB50                    	jmp	short _$P_RLT_Exit	;AN000;
  7944                                  
  7945                                  _$P_RLT01:				;AN000;
  7946 0000197D 3C07                    	cmp	al,_$P_Date_F		;AN000; Date format ?
  7947 0000197F 74E8                    	je	short _$P_RLT02		;AN000;
  7948                                  
  7949 00001981 3C08                    	cmp	al,_$P_Time_F		;AN000; Time format ?
  7950 00001983 74E4                    	je	short _$P_RLT02		;AN000;
  7951                                  
  7952 00001985 3C06                    	cmp	al,_$P_Drive		;AN000; drive format ?
  7953 00001987 7506                    	jne	short _$P_RLT03		;AN000;
  7954                                  
  7955 00001989 26885504                	mov	[es:di+_$P_Result_Blk.Picked_Val],dl ;AN000; store drive number
  7956 0000198D EB3E                    	jmp	short _$P_RLT_Exit	;AN000;
  7957                                  
  7958                                  _$P_RLT03:				;AN000;
  7959 0000198F 3C04                    	cmp	al,_$P_Complex		;AN000; complex format ?
  7960 00001991 750F                    	jne	short _$P_RLT05		;AN000;
  7961                                  
  7962 00001993 2EA1[7016]              	mov	ax,[cs:_$P_SaveSI_Cmpx] ;AC034; then get pointer in command buffer
  7963 00001997 40                      	inc	ax			;AN000; skip left Parentheses
  7964 00001998 26894504                	mov	[es:di+_$P_Result_Blk.Picked_Val],ax ;AN000; store offset
  7965 0000199C 268C5D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],ds ;AN000; store segment
  7966 000019A0 EB2B                    	jmp	short _$P_RLT_Exit	;AN000;
  7967                                  
  7968                                  _$P_RLT05:				;AN000;
  7969                                  ;------------------------  AL = 3, 5, or 9
  7970 000019A2 26897504                	mov	[es:di+_$P_Result_Blk.Picked_Val],si 
  7971                                  					;AN000; store offset of STRING_BUF
  7972 000019A6 268C4D06                	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cs 
  7973                                  					;AN031; store segment of STRING_BUF
  7974 000019AA 50                      	push	ax			;AN000;
  7975 000019AB 26F6470201              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_File 
  7976                                  					;AN000; need CAPS by file table?
  7977 000019B0 7404                    	jz	short _$P_RLT_CAP00	;AN000;
  7978                                  
  7979 000019B2 B004                    	mov	al,_$P_DOSTBL_File	;AN000; use file upper case table
  7980 000019B4 EB09                    	jmp	short _$P_RLT_CAP02	;AN000;
  7981                                  
  7982                                  _$P_RLT_CAP00:				;AN000;
  7983 000019B6 26F6470202              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_Char 
  7984                                  					;AN000; need CAPS by char table ?
  7985 000019BB 7405                    	jz	short _$P_RLT_CAP01	;AN000;
  7986                                  
  7987 000019BD B002                    	mov	al,_$P_DOSTBL_Char	;AN000; use character upper case table
  7988                                  _$P_RLT_CAP02:				;AN000;
  7989 000019BF E8E500                  	call	_$P_Do_CAPS_String	;AN000;  process CAPS along the table
  7990                                  _$P_RLT_CAP01:				;AN000;
  7991 000019C2 58                      	pop	ax			;AN000;
  7992 000019C3 26F6470210              	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_Rm_Colon 
  7993                                  					;AN000; removing colon at end ?
  7994 000019C8 7403                    	jz	short _$P_RLT_Exit	;AN000;
  7995                                  
  7996 000019CA E8B400                  	call	_$P_Remove_Colon 	;AN000; then process it.
  7997                                  _$P_RLT_Exit:				;AN000;
  7998 000019CD 5F                      	pop	di			;AN000;
  7999 000019CE C3                      	retn				;AN000;
  8000                                  
  8001                                  ;***********************************************************************
  8002                                  ; _$P_Check_Match_Flags
  8003                                  ;
  8004                                  ; Function:  Check the mutch_flags and make the exit code and set the
  8005                                  ;	     result buffer
  8006                                  ;
  8007                                  ;	    Check for types in this order:
  8008                                  ;		Complex
  8009                                  ;		Date
  8010                                  ;		Time
  8011                                  ;		Drive
  8012                                  ;		Filespec
  8013                                  ;		Quoted String
  8014                                  ;		Simple String
  8015                                  ;
  8016                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8017                                  ;	     ES:BX -> CONTROL block
  8018                                  ;
  8019                                  ; Output:    None
  8020                                  ;
  8021                                  ; Use:	     _$P_Value, P$_SValue, _$P_Simple_String, _$P_Date_Format
  8022                                  ;	     _$P_Time_Format, _$P_Complex_Format, _$P_File_Foemat
  8023                                  ;	     _$P_Drive_Format
  8024                                  ;***********************************************************************
  8025                                  
  8026                                  	; 25/10/2022 - Retro DOS v4.0
  8027                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:19CFh)
  8028                                  
  8029                                  _$P_Check_Match_Flags:
  8030 000019CF 2EC606[0617]00          	mov	byte [cs:_$P_err_flag],_$P_NULL 
  8031                                  					;AN033;AC034;; clear filespec error flag.
  8032 000019D5 50                      	push	ax			;AN000;
  8033                                  	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag]
  8034 000019D6 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
  8035 000019D9 09C0                    	or	ax,ax			;AC035; test ax for zero
  8036 000019DB 7518                    	jnz	short _$P_Mat		;AN000; (tm12)
  8037                                  
  8038 000019DD 50                      	push	ax			;AN000; (tm12)
  8039 000019DE 53                      	push	bx			;AN000; (tm12)
  8040 000019DF 52                      	push	dx			;AN000; (tm12)
  8041 000019E0 57                      	push	di			;AN000; (tm12)
  8042 000019E1 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; (tm12)
  8043 000019E8 B4FF                    	mov	ah,_$P_No_Tag		;AN000; (tm12)
  8044 000019EA B003                    	mov	al,_$P_String		;AN000; (tm12)
  8045 000019EC E85BFF                  	call	_$P_Fill_Result		;AN000; (tm12)
  8046 000019EF 5F                      	pop	di			;AN000; (tm12)
  8047 000019F0 5A                      	pop	dx			;AN000; (tm12)
  8048 000019F1 5B                      	pop	bx			;AN000; (tm12)
  8049 000019F2 58                      	pop	ax			;AN000; (tm12)
  8050 000019F3 EB02                    	jmp	short _$P_Bridge 	;AC035; (tm12)
  8051                                  _$P_Mat: 				;AN000; (tm12)
  8052 000019F5 EB03                    	jmp	short _$P_Match03	;AN025; (tm09)
  8053                                  _$P_Bridge:
  8054 000019F7 EB6F                    	jmp	short _$P_Match_Exit	;AN000; (tm02)
  8055                                  	
  8056                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8057                                  	; (SYSINIT:19F9h)
  8058 000019F9 90                      	nop	; db 90h
  8059                                  
  8060                                  _$P_Match03:				;AN000;
  8061 000019FA A90080                  	test	ax,_$P_Num_Val		;AN000; Numeric value
  8062 000019FD 7412                    	jz	short _$P_Match04	;AN000;
  8063                                  
  8064 000019FF 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
  8065 00001A06 E82601                  	call	_$P_Value		;AN000; do process
  8066 00001A09 2E833E[6316]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
  8067 00001A0F 7557                    	jne	short _$P_Match_Exit	;AN000;
  8068                                  _$P_Match04:				;AN000;
  8069 00001A11 A90040                  	test	ax,_$P_SNum_Val		;AN000; Signed numeric value
  8070 00001A14 7412                    	jz	short _$P_Match05	;AN000;
  8071                                  
  8072 00001A16 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
  8073 00001A1D E8EB00                  	call	_$P_SValue		;AN000; do process
  8074 00001A20 2E833E[6316]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
  8075 00001A26 7540                    	jne	short _$P_Match_Exit	;AN000;
  8076                                  _$P_Match05:				;AN000;
  8077 00001A28 A90001                  	test	ax,_$P_Drv_Only		;AN000; Drive only
  8078 00001A2B 7415                    	jz	short _$P_Match06	;AN000;
  8079                                  
  8080 00001A2D 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
  8081 00001A34 E81603                  	call	_$P_File_Format		;AN000; 1st, call file format
  8082 00001A37 E89903                  	call	_$P_Drive_Format	;AN000; check drive format, next
  8083 00001A3A 2E833E[6316]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
  8084 00001A40 7526                    	jne	short _$P_Match_Exit	;AN000;
  8085                                  _$P_Match06:				;AN000;
  8086 00001A42 A90002                  	test	ax,_$P_File_Spc		;AN000; File spec
  8087 00001A45 7412                    	jz	short _$P_Match07	;AN000;
  8088                                  
  8089 00001A47 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
  8090 00001A4E E8FC02                  	call	_$P_File_Format		;AN000; do process
  8091 00001A51 2E833E[6316]09          	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
  8092 00001A57 750F                    	jne	short _$P_Match_Exit	;AN000;
  8093                                  _$P_Match07:				;AN000;
  8094 00001A59 A90020                  	test	ax,_$P_Simple_S		;AN000; Simple string
  8095 00001A5C 740A                    	jz	short _$P_Match09	;AN000;
  8096                                  
  8097 00001A5E 2EC706[6316]0000        	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
  8098 00001A65 E8D901                  	call	_$P_Simple_String	;AN000; do process
  8099                                  _$P_Match09:				;AN000;
  8100                                  _$P_Match_Exit:				;AN000;
  8101 00001A68 2E833E[0617]01          	cmp	word [cs:_$P_err_flag],_$P_error_filespec ;AC034; bad filespec ?
  8102 00001A6E 750F                    	jne	short _$P_Match2_Exit	;AN033; no, continue
  8103 00001A70 2E833E[6316]00          	cmp	word [cs:_$P_RC],_$P_No_Error ;AN033;AC034;; check for other errors ?
  8104 00001A76 7507                    	jne	short _$P_Match2_Exit	;AN033; no, continue
  8105 00001A78 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AN033;AC034;; set error flag
  8106                                  _$P_Match2_Exit: 			;AN033;
  8107 00001A7F 58                      	pop	ax			;AN000;
  8108 00001A80 C3                      	retn				;AN000;
  8109                                  
  8110                                  ;***********************************************************************
  8111                                  ; _$P_Remove_Colon;
  8112                                  ;
  8113                                  ; Function: Remove colon at end
  8114                                  ;
  8115                                  ; Input:    cs:SI points to string buffer to be examineed
  8116                                  ;
  8117                                  ; Output:   None
  8118                                  ;
  8119                                  ; Use:	_$P_Chk_DBCS
  8120                                  ;***********************************************************************
  8121                                  
  8122                                  _$P_Remove_Colon:
  8123 00001A81 50                      	push	ax			;AN000;
  8124 00001A82 56                      	push	si			;AN000;
  8125                                  _$P_RCOL_Loop:				;AN000;
  8126 00001A83 2E8A04                  	mov	al,[cs:si]		;AN000; get character
  8127 00001A86 08C0                    	or	al,al			;AN000; end of string ?
  8128 00001A88 741A                    	jz	short _$P_RCOL_Exit	;AN000; if yes, just exit
  8129                                  
  8130 00001A8A 3C3A                    	cmp	al,_$P_Colon		;AN000; is it colon ?
  8131 00001A8C 750D                    	jne	short _$P_RCOL00	;AN000;
  8132                                  
  8133 00001A8E 2E807C0100              	cmp	byte [cs:si+1],_$P_NULL ;AN000; if so, next is NULL ?
  8134 00001A93 7506                    	jne	short _$P_RCOL00	;AN000; no, then next char
  8135                                  
  8136 00001A95 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000; yes, remove colon
  8137 00001A99 EB09                    	jmp	short _$P_RCOL_Exit	;AN000; and exit.
  8138                                  
  8139                                  _$P_RCOL00:				;AN000;
  8140 00001A9B E85404                  	call	_$P_Chk_DBCS		;AN000; if not colon, then check if
  8141 00001A9E 7301                    	jnc	short _$P_RCOL01	;AN000; DBCS leading byte.
  8142                                  
  8143 00001AA0 46                      	inc	si			;AN000; if yes, skip trailing byte
  8144                                  _$P_RCOL01:				;AN000;
  8145 00001AA1 46                      	inc	si			;AN000; si points to next byte
  8146 00001AA2 EBDF                    	jmp	short _$P_RCOL_Loop	;AN000; loop until NULL encountered
  8147                                  
  8148                                  _$P_RCOL_Exit:				;AN000;
  8149 00001AA4 5E                      	pop	si			;AN000;
  8150 00001AA5 58                      	pop	ax			;AN000;
  8151 00001AA6 C3                      	retn				;AN000;
  8152                                  
  8153                                  ;***********************************************************************
  8154                                  ; _$P_Do_CAPS_String;
  8155                                  ;
  8156                                  ; Function: Perform capitalization along with the file case map table
  8157                                  ;	    or character case map table.
  8158                                  ;
  8159                                  ; Input:    AL = 2 : Use character table
  8160                                  ;	    AL = 4 : Use file table
  8161                                  ;	    cs:SI points to string buffer to be capitalized
  8162                                  ;
  8163                                  ; Output:   None
  8164                                  ;
  8165                                  ; Use:	_$P_Do_CAPS_Char, _$P_Chk_DBCS
  8166                                  ;***********************************************************************
  8167                                  
  8168                                  _$P_Do_CAPS_String:
  8169 00001AA7 56                      	push	si			;AN000;
  8170 00001AA8 52                      	push	dx			;AN000;
  8171 00001AA9 88C2                    	mov	dl,al			;AN000; save info id
  8172                                  
  8173                                  _$P_DCS_Loop:				;AN000;
  8174 00001AAB 2E8A04                  	mov	al,[cs:si]		;AN000; load charater and
  8175 00001AAE E84104                  	call	_$P_Chk_DBCS		;AN000; check if DBCS leading byte
  8176 00001AB1 720C                    	jc	short _$P_DCS00		;AN000; if yes, do not need CAPS
  8177                                  
  8178 00001AB3 08C0                    	or	al,al			;AN000; end of string ?
  8179 00001AB5 740C                    	jz	short _$P_DCS_Exit	;AN000; then exit.
  8180                                  
  8181 00001AB7 E80C00                  	call	_$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
  8182 00001ABA 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
  8183 00001ABD EB01                    	jmp	short _$P_DCS01		;AN000; process next
  8184                                  _$P_DCS00:				;AN000;
  8185 00001ABF 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
  8186                                  _$P_DCS01:				;AN000;
  8187 00001AC0 46                      	inc	si			;AN000; si point to next byte
  8188 00001AC1 EBE8                    	jmp	short _$P_DCS_Loop	;AN000; loop until NULL encountered
  8189                                  _$P_DCS_Exit:				;AN000;
  8190 00001AC3 5A                      	pop	dx			;AN000;
  8191 00001AC4 5E                      	pop	si			;AN000;
  8192 00001AC5 C3                      	retn
  8193                                  
  8194                                  ;***********************************************************************
  8195                                  ; _$P_Do_CAPS_Char;
  8196                                  ;
  8197                                  ; Function: Perform capitalization along with the file case map table
  8198                                  ;	    or character case map table.
  8199                                  ;
  8200                                  ; Input:    DL = 2 : Use character table
  8201                                  ;	    DL = 4 : Use file table
  8202                                  ;	    AL = character to be capitalized
  8203                                  ;
  8204                                  ; Output:   None
  8205                                  ;
  8206                                  ; Use:	INT 21h /w AH=65h
  8207                                  ;***********************************************************************
  8208                                  
  8209                                  _$P_Do_CAPS_Char:
  8210 00001AC6 3C80                    	cmp	al,_$P_ASCII80	;80h	;AN000; need upper case table ?
  8211 00001AC8 730C                    	jae	short _$P_DCC_Go	;AN000;
  8212                                  
  8213 00001ACA 3C61                    	cmp	al,"a"                  ;AN000; if no,
  8214 00001ACC 723C                    	jb	short _$P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
  8215                                  
  8216 00001ACE 3C7A                    	cmp	al,"z"                  ;AN000;
  8217 00001AD0 7738                    	ja	short _$P_CAPS_Ret	;AN000;   if yes, make CAPS
  8218                                  
  8219 00001AD2 24DF                    	and	al,_$P_Make_Upper ;0DFh ;AN000;   else do nothing.
  8220 00001AD4 EB34                    	jmp	short _$P_CAPS_Ret	;AN000;
  8221                                  
  8222                                  _$P_DCC_Go:				;AN000;
  8223 00001AD6 53                      	push	bx			;AN000;
  8224 00001AD7 06                      	push	es			;AN000;
  8225 00001AD8 57                      	push	di			;AN000;
  8226                                  
  8227                                  	;lea	di,[cs:_$P_Char_CAP_Ptr] ;AC034; or use char CAPS table ?
  8228 00001AD9 8D3E[F816]              	lea	di,[_$P_Char_CAP_Ptr]
  8229                                  _$P_DCC00:				;AN000;
  8230 00001ADD 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
  8231 00001AE0 7417                    	je	short _$P_DCC01		;AN000; if no,
  8232                                  
  8233                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
  8234                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
  8235                                  ; call, regardless of what base register is currently be defined as cs.
  8236                                  
  8237 00001AE2 50                      	push	ax			;AN000; get CAPS table thru DOS call
  8238 00001AE3 51                      	push	cx			;AN000;
  8239 00001AE4 52                      	push	dx			;AN000;
  8240                                  
  8241 00001AE5 0E                      	push	cs			;AC036; pass current base seg into
  8242                                  					;(Note: this used to push CS.  BUG...
  8243 00001AE6 07                      	pop	es			;AN000;   ES reg, required for
  8244                                  					;get extended country information
  8245 00001AE7 B465                    	mov	ah,_$P_DOS_Get_TBL	;AN000; get extended CDI
  8246 00001AE9 88D0                    	mov	al,dl			;AN000; upper case table
  8247 00001AEB BBFFFF                  	mov	bx,_$P_DOSTBL_Def	;AN000; get active CON
  8248 00001AEE B90500                  	mov	cx,_$P_DOSTBL_BL 	;AN000; buffer length
  8249 00001AF1 BAFFFF                  	mov	dx,_$P_DOSTBL_Def	;AN000; get for default code page
  8250                                  					;DI already set to point to buffer
  8251 00001AF4 CD21                    	int	21h			;AN000; es:di point to buffer that
  8252                                  					;now has been filled in with info
  8253 00001AF6 5A                      	pop	dx			;AN000;
  8254 00001AF7 59                      	pop	cx			;AN000;
  8255 00001AF8 58                      	pop	ax			;AN000;
  8256                                  
  8257                                  _$P_DCC01:				;AN000;
  8258                                  
  8259                                  ;In this next section, ES will be used as the base of the XLAT table, provided
  8260                                  ; by the previous GET COUNTRY INFO DOS call.  This usage of ES is made
  8261                                  ; regardless of which base reg is currently the cs reg.
  8262                                  
  8263 00001AF9 2E8B5D01                	mov	bx,[cs:di+_$P_DOS_TBL.Off] ;AN000; get offset of table
  8264 00001AFD 2E8E4503                	mov	es,[cs:di+_$P_DOS_TBL.Seg] ;AN000; get segment of table
  8265 00001B01 43                      	inc	bx			;AC035; add '2' to
  8266 00001B02 43                      	inc	bx			;AC035;  BX reg
  8267                                  					;AN000; skip length field
  8268 00001B03 2C80                    	sub	al,_$P_ASCII80 ; 80h	;AN000; make char to index
  8269                                  	;xlat	es:[bx] 		;AN000; perform case map
  8270 00001B05 26                      	es
  8271 00001B06 D7                      	xlat
  8272 00001B07 5F                      	pop	di			;AN000;
  8273 00001B08 07                      	pop	es			;AN000;
  8274 00001B09 5B                      	pop	bx			;AN000;
  8275                                  _$P_CAPS_Ret:				;AN000;
  8276 00001B0A C3                      	retn				;AN000;
  8277                                  
  8278                                  ;***********************************************************************
  8279                                  ; _$P_Value / _$P_SValue
  8280                                  ;
  8281                                  ; Function:  Make 32bit value from cs:SI and see value list
  8282                                  ;	     and make result buffer.
  8283                                  ;	     _$P_SValue is an entry point for the signed value
  8284                                  ;	     and this will simply call _$P_Value after the handling
  8285                                  ;	     of the sign character, "+" or "-"
  8286                                  ;
  8287                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8288                                  ;	     ES:BX -> CONTROL block
  8289                                  ;
  8290                                  ; Output:    None
  8291                                  ;
  8292                                  ; Use:	_$P_Fill_Result, _$P_Check_OVF
  8293                                  ;
  8294                                  ; Vars: _$P_RC(W), _$P_Flags(RW)
  8295                                  ;***********************************************************************
  8296                                  
  8297                                  	; 26/10/2022 - Retro DOS v4.0
  8298                                  	; (MSDOS 5.0 IO.SYS - SYSINIT:1B0Bh)
  8299                                  
  8300                                  _$P_SValue:				;AN000; when signed value here
  8301 00001B0B 50                      	push	ax			;AN000;
  8302 00001B0C 2E800E[6F16]80          	or	byte [cs:_$P_Flags2],_$P_Signed ;AC034; indicate a signed numeric
  8303 00001B12 2E8026[6F16]FD          	and	byte [cs:_$P_Flags2],0FFh-_$P_Neg ;AC034; assume positive value
  8304 00001B18 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
  8305 00001B1B 3C2B                    	cmp	al,_$P_Plus		;AN000; "+" ?
  8306 00001B1D 740A                    	je	short _$P_SVal00	;AN000;
  8307                                  
  8308 00001B1F 3C2D                    	cmp	al,_$P_Minus		;AN000; "-" ?
  8309 00001B21 7507                    	jne	short _$P_Sval01	;AN000; else
  8310                                  
  8311 00001B23 2E800E[6F16]02          	or	byte [cs:_$P_Flags2],_$P_Neg ;AC034; set this is negative value
  8312                                  _$P_SVal00:				;AN000;
  8313 00001B29 46                      	inc	si			;AN000; skip sign char
  8314                                  _$P_Sval01:				;AN000;
  8315 00001B2A E80200                  	call	_$P_Value		;AN000; and process value
  8316 00001B2D 58                      	pop	ax			;AN000;
  8317 00001B2E C3                      	retn
  8318                                  
  8319                                  ;***********************************************************************
  8320                                  
  8321                                  	; 26/10/2022
  8322                                  _$P_Value:				;AN000;
  8323 00001B2F 50                      	push	ax			;AN000;
  8324 00001B30 51                      	push	cx			;AN000;
  8325 00001B31 52                      	push	dx			;AN000;
  8326 00001B32 56                      	push	si			;AN000;
  8327 00001B33 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
  8328 00001B35 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
  8329 00001B37 53                      	push	bx			;AN000; save control pointer
  8330                                  _$P_Value_Loop:				;AN000;
  8331 00001B38 2E8A04                  	mov	al,[cs:si]		;AN000; get character
  8332 00001B3B 08C0                    	or	al,al			;AN000; end of line ?
  8333 00001B3D 7442                    	jz	short _$P_Value00	;AN000;
  8334                                  
  8335 00001B3F E8F100                  	call	_$P_0099 		;AN000; make asc(0..9) to bin(0..9)
  8336 00001B42 7239                    	jc	short _$P_Value_Err0	;AN000;
  8337                                  
  8338 00001B44 30E4                    	xor	ah,ah			;AN000;
  8339 00001B46 89C5                    	mov	bp,ax			;AN000; save binary number
  8340 00001B48 D1E2                    	shl	dx,1			;AN000; to have 2*x
  8341 00001B4A D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
  8342 00001B4C E8D200                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
  8343 00001B4F 722C                    	jc	short _$P_Value_Err0	;AN000; then error, exit
  8344                                  
  8345 00001B51 89D3                    	mov	bx,dx			;AN000; save low(2*x)
  8346 00001B53 89C8                    	mov	ax,cx			;AN000; save high(2*x)
  8347 00001B55 D1E2                    	shl	dx,1			;AN000; to have 4*x
  8348 00001B57 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
  8349 00001B59 E8C500                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
  8350 00001B5C 721F                    	jc	short _$P_Value_Err0	;AN000; then error, exit
  8351                                  
  8352 00001B5E D1E2                    	shl	dx,1			;AN000; to have 8*x
  8353 00001B60 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
  8354 00001B62 E8BC00                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
  8355 00001B65 7216                    	jc	short _$P_Value_Err0	;AN000; then error, exit
  8356                                  
  8357 00001B67 01DA                    	add	dx,bx			;AN000; now have 10*x
  8358 00001B69 11C1                    	adc	cx,ax			;AN000; 32bit ADD
  8359 00001B6B E8B300                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
  8360 00001B6E 720D                    	jc	short _$P_Value_Err0	;AN000; then error, exit
  8361                                  
  8362 00001B70 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
  8363 00001B72 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
  8364 00001B75 E8A900                  	call	_$P_Check_OVF		;AN000; Overflow occurred ?
  8365 00001B78 7203                    	jc	short _$P_Value_Err0	;AN000; then error, exit
  8366                                  
  8367 00001B7A 46                      	inc	si			;AN000; update pointer
  8368 00001B7B EBBB                    	jmp	short _$P_Value_Loop	;AN000; loop until NULL encountered
  8369                                  ;
  8370                                  _$P_Value_Err0:				;AN000;
  8371 00001B7D 5B                      	pop	bx			;AN000;
  8372 00001B7E E98D00                  	jmp	_$P_Value_Err		;AN000; Bridge
  8373                                  ;
  8374                                  _$P_Value00:				;AN000;
  8375 00001B81 5B                      	pop	bx			;AN000; restore control pointer
  8376 00001B82 2EF606[6F16]02          	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; here cx,dx = 32bit value
  8377 00001B88 740A                    	jz	short _$P_Value01	;AN000; was it negative ?
  8378                                  
  8379 00001B8A F7D1                    	not	cx			;AN000; +
  8380 00001B8C F7D2                    	not	dx			;AN000; |- Make 2's complement
  8381 00001B8E 83C201                  	add	dx,1			;AN000; |
  8382 00001B91 83D100                  	adc	cx,0			;AN000; +
  8383                                  
  8384                                  _$P_Value01:				;AN000; / nval =0
  8385 00001B94 268B7706                	mov	si,[es:bx+_$P_Control_Blk.Value_List] ;AN000; si points to value list
  8386 00001B98 268A04                  	mov	al,[es:si]		;AN000; get nval
  8387 00001B9B 3C00                    	cmp	al,_$P_nval_None 	;AN000; no value list ?
  8388 00001B9D 7507                    	jne	short _$P_Value02	;AN000;
  8389                                  
  8390 00001B9F B001                    	mov	al,_$P_Number		;AN000; Set type
  8391 00001BA1 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8392 00001BA3 EB74                    	jmp	short _$P_Value_Exit	;AN000;
  8393                                  
  8394                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS, SYSINIT compatibility)
  8395                                  	; (SYSINIT:1BA5h)
  8396 00001BA5 90                      	nop	; db  90h
  8397                                  
  8398                                  _$P_Value02:				;AN000; / nval = 1
  8399                                  ;IF	Val1SW				;AN000;(Check if value list id #1 is supported)
  8400                                  ;(tm07) cmp	al,_$P_nval_Range	;AN000; have range list ?
  8401                                  ;(tm07) jne	short _$P_Value03	;AN000;
  8402                                  
  8403 00001BA6 46                      	inc	si			;AN000;
  8404 00001BA7 268A04                  	mov	al,[es:si]		;AN000; al = number of range
  8405 00001BAA 3C00                    	cmp	al,_$P_No_nrng		;AN000; (tm07)
  8406 00001BAC 7460                    	je	short _$P_Value03	;AN000; (tm07)
  8407                                  
  8408 00001BAE 46                      	inc	si			;AN000; si points to 1st item_tag
  8409                                  _$P_Val02_Loop:				;AN000;
  8410 00001BAF 2EF606[6F16]80          	test	byte [cs:_$P_Flags2],_$P_Signed ;AC034;
  8411 00001BB5 751E                    	jnz	short _$P_Val02_Sign	;AN000;
  8412                                  
  8413 00001BB7 263B4C03                	cmp	cx,[es:si+_$P_Val_List.Val_XH] ;AN000; comp cx with XH
  8414 00001BBB 7236                    	jb	short _$P_Val02_Next	;AN000;
  8415 00001BBD 7706                    	ja	short _$P_Val_In	;AN000;
  8416                                  
  8417 00001BBF 263B5401                	cmp	dx,[es:si+_$P_Val_List.Val_XL] ;AN000; comp dx with XL
  8418 00001BC3 722E                    	jb	short _$P_Val02_Next	;AN000;
  8419                                  
  8420                                  _$P_Val_In:				;AN000;
  8421 00001BC5 263B4C07                	cmp	cx,[es:si+_$P_Val_List.Val_YH] ;AN000; comp cx with YH (tm01)
  8422 00001BC9 7728                    	ja	short _$P_Val02_Next	;AN000;
  8423 00001BCB 723A                    	jb	short _$P_Val_Found	;AN000;
  8424                                  
  8425 00001BCD 263B5405                	cmp	dx,[es:si+_$P_Val_List.Val_YL] ;AN000; comp dx with YL
  8426 00001BD1 7720                    	ja	short _$P_Val02_Next	;AN000;
  8427                                  
  8428 00001BD3 EB32                    	jmp	short _$P_Val_Found	;AN000;
  8429                                  
  8430                                  _$P_Val02_Sign:				;AN000;
  8431 00001BD5 263B4C03                	cmp	cx,[es:si+_$P_Val_List.Val_XH]	;AN000; comp cx with XH
  8432 00001BD9 7C18                    	jl	short _$P_Val02_Next	;AN000;
  8433 00001BDB 7F06                    	jg	short _$P_SVal_In	;AN000;
  8434                                  
  8435 00001BDD 263B5401                	cmp	dx,[es:si+_$P_Val_List.Val_XL]	;AN000; comp dx with XL
  8436 00001BE1 7C10                    	jl	short _$P_Val02_Next	;AN000;
  8437                                  
  8438                                  _$P_SVal_In:				;AN000;
  8439 00001BE3 263B4C07                	cmp	cx,[es:si+_$P_Val_List.Val_YH]	;AN000; comp cx with YH
  8440 00001BE7 7F0A                    	jg	short _$P_Val02_Next	;AN000;
  8441                                  
  8442 00001BE9 7C1C                    	jl	short _$P_Val_Found	;AN000;
  8443                                  
  8444 00001BEB 263B5405                	cmp	dx,[es:si+_$P_Val_List.Val_YL]	;AN000; comp dx with YL
  8445 00001BEF 7F02                    	jg	short _$P_Val02_Next	;AN000;
  8446                                  
  8447 00001BF1 EB14                    	jmp	short _$P_Val_Found	;AN000;
  8448                                  
  8449                                  _$P_Val02_Next:				;AN000;
  8450 00001BF3 83C609                  	add	si,_$P_Len_Range 	;AN000;
  8451 00001BF6 FEC8                    	dec	al			;AN000; loop nrng times in AL
  8452 00001BF8 75B5                    	jne	short _$P_Val02_Loop	;AN000;
  8453                                  					; / Not found
  8454 00001BFA 2EC706[6316]0600        	mov	word [cs:_$P_RC],_$P_Out_Of_Range ;AC034;
  8455 00001C01 B001                    	mov	al,_$P_Number		;AN000;
  8456 00001C03 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8457 00001C05 EB12                    	jmp	short _$P_Value_Exit	;AN000;
  8458                                  
  8459                                  _$P_Val_Found:				;AN000;
  8460 00001C07 B001                    	mov	al,_$P_Number		;AN000;
  8461 00001C09 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
  8462 00001C0C EB0B                    	jmp	short _$P_Value_Exit	;AN000;
  8463                                  
  8464                                  _$P_Value03:				;AN000; / nval = 2
  8465                                  
  8466                                  ;IF	Val2SW				;AN000;(Check if value list id #2 is supported)
  8467                                  ;;;;	cmp	al,$P_nval_Value	; have match list ? ASSUME nval=2,
  8468                                  ;;;;	jne	$P_Value04		; even if it is 3 or more.
  8469                                  ;(tm07) inc	si			;AN000;
  8470                                  ;(tm07) mov	al,es:[si]		;AN000; al = nrng
  8471                                  ;	mov	ah,$P_Len_Range 	;AN000;
  8472                                  ;	mul	ah			;AN000;  Skip nrng field
  8473                                  ;	inc	ax			;AN000;
  8474                                  ;	add	si,ax			;AN000; si points to nnval
  8475                                  ;	mov	al,es:[si]		;AN000; get nnval
  8476                                  ;	inc	si			;AN000; si points to 1st item_tag
  8477                                  ;$P_Val03_Loop:				;AN000;
  8478                                  ;	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
  8479                                  ;	jne	$P_Val03_Next		;AN000;
  8480                                  ;
  8481                                  ;	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
  8482                                  ;	je	$P_Val_Found		;AN000;
  8483                                  ;
  8484                                  ;$P_Val03_Next:				;AN000;
  8485                                  ;	add	si,$P_Len_Value 	;AN000; points to next value choice
  8486                                  ;	dec	al			;AN000; loop nval times in AL
  8487                                  ;	jne	$P_Val03_Loop		;AN000;
  8488                                  ;					;AN000; / Not found
  8489                                  ;	mov	psdata_seg:$P_RC,$P_Not_in_Val ;AC034;
  8490                                  ;	mov	al,$P_Number		;AN000;
  8491                                  ;	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
  8492                                  ;	jmp	short $P_Value_Exit	;AN000;
  8493                                  ;
  8494                                  ;ENDIF					;AN000;(of Val2SW)
  8495                                  ;$P_Value04:
  8496                                  
  8497                                  _$P_Value_Err:				;AN000;
  8498 00001C0E 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
  8499 00001C15 B003                    	mov	al,_$P_String		;AN000; Set type
  8500 00001C17 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8501                                  _$P_Value_Exit:				;AN000;
  8502 00001C19 E82EFD                  	call	_$P_Fill_Result		;AN000;
  8503 00001C1C 5E                      	pop	si			;AN000;
  8504 00001C1D 5A                      	pop	dx			;AN000;
  8505 00001C1E 59                      	pop	cx			;AN000;
  8506 00001C1F 58                      	pop	ax			;AN000;
  8507 00001C20 C3                      	retn				;AN000;
  8508                                  
  8509                                  ; 28/03/2019 - Retro DOS v4.0
  8510                                  
  8511                                  ;***********************************************************************
  8512                                  ; _$P_Check_OVF
  8513                                  ;
  8514                                  ; Function:  Check if overflow is occurred with consideration of
  8515                                  ;	     signed or un-signed numeric value
  8516                                  ;
  8517                                  ; Input:     Flag register
  8518                                  ;
  8519                                  ; Output:    CY = 1  :	Overflow
  8520                                  ;
  8521                                  ; Vars:     _$P_Flags(R)
  8522                                  ;***********************************************************************
  8523                                  
  8524                                  	; 26/10/2022
  8525                                  _$P_Check_OVF:
  8526 00001C21 9C                      	pushf				;AN000;
  8527 00001C22 2EF606[6F16]02          	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; is it negative value ?
  8528 00001C28 7502                    	jnz	short _$P_COVF 		;AN000; if no, check overflow
  8529                                  
  8530 00001C2A 9D                      	popf				;AN000; by the CY bit
  8531 00001C2B C3                      	retn				;AN000;
  8532                                  
  8533                                  _$P_COVF:				;AN000;
  8534 00001C2C 9D                      	popf				;AN000; else,
  8535 00001C2D 7002                    	jo	short _$P_COVF00	;AN000; check overflow by the OF
  8536                                  
  8537 00001C2F F8                      	clc				;AN000; indicate it with CY bit
  8538 00001C30 C3                      	retn				;AN000; CY=0 means no overflow
  8539                                  
  8540                                  _$P_COVF00:				;AN000;
  8541 00001C31 F9                      	stc				;AN000; and CY=1 means overflow
  8542 00001C32 C3                      	retn				;AN000;
  8543                                  
  8544                                  ;***********************************************************************
  8545                                  ; _$P_0099;
  8546                                  ;
  8547                                  ; Function:  Make ASCII 0-9 to Binary 0-9
  8548                                  ;
  8549                                  ; Input:     AL = character code
  8550                                  ;
  8551                                  ; Output:    CY = 1 : AL is not number
  8552                                  ;	     CY = 0 : AL contains binary value
  8553                                  ;***********************************************************************
  8554                                  
  8555                                  _$P_0099:
  8556 00001C33 3C30                    	cmp	al,"0"                  ;AN000;
  8557 00001C35 7208                    	jb	short _$P_0099Err	;AN000; must be 0 =< al =< 9
  8558                                  
  8559 00001C37 3C39                    	cmp	al,"9"                  ;AN000;
  8560 00001C39 7704                    	ja	short _$P_0099Err	;AN000; must be 0 =< al =< 9
  8561                                  
  8562 00001C3B 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
  8563 00001C3D F8                      	clc				;AN000; indicate no error
  8564 00001C3E C3                      	retn				;AN000;
  8565                                  
  8566                                  _$P_0099Err:				;AN000;
  8567 00001C3F F9                      	stc				;AN000; indicate error
  8568 00001C40 C3                      	retn				;AN000;
  8569                                  
  8570                                  ;***********************************************************************
  8571                                  ; _$P_Simple_String
  8572                                  ;
  8573                                  ; Function:  See value list for the simple string
  8574                                  ;	     and make result buffer.
  8575                                  ;
  8576                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8577                                  ;	     ES:BX -> CONTROL block
  8578                                  ;
  8579                                  ; Output:    None
  8580                                  ;
  8581                                  ; Use:	_$P_Fill_Result, _$P_String_Comp
  8582                                  ;
  8583                                  ; Vars: _$P_RC(W)
  8584                                  ;***********************************************************************
  8585                                  
  8586                                  _$P_Simple_String:
  8587 00001C41 50                      	push	ax			;AN000;
  8588 00001C42 53                      	push	bx			;AN000;
  8589 00001C43 52                      	push	dx			;AN000;
  8590 00001C44 57                      	push	di			;AN000;
  8591 00001C45 268B7F06                	mov	di,[es:bx+_$P_Control_Blk.Value_List] ;AN000; di points to value list
  8592 00001C49 268A05                  	mov	al,[es:di]		;AN000; get nval
  8593 00001C4C 08C0                    	or	al,al			;AN000; no value list ?
  8594 00001C4E 7504                    	jnz	short _$P_Sim00		;AN000; then
  8595                                  
  8596 00001C50 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8597 00001C52 EB4C                    	jmp	short _$P_Sim_Exit	;AN000; and set result buffer
  8598                                  
  8599                                  _$P_Sim00:				;AN000;
  8600                                  ;IF	Val3SW+KeySW			;AN000;(Check if keyword or value list id #3 is supported)
  8601 00001C54 3C03                    	cmp	al,_$P_nval_String	;AN000; String choice list provided ?
  8602 00001C56 753F                    	jne	short _$P_Sim01		;AN000; if no, syntax error
  8603                                  
  8604 00001C58 47                      	inc	di			;AN000;
  8605 00001C59 268A05                  	mov	al,[es:di]		;AN000; al = nrng
  8606 00001C5C B409                    	mov	ah,_$P_Len_Range 	;AN000;
  8607 00001C5E F6E4                    	mul	ah			;AN000; Skip nrng field
  8608 00001C60 40                      	inc	ax			;AN000; ax = (nrng*9)+1
  8609 00001C61 01C7                    	add	di,ax			;AN000; di points to nnval
  8610 00001C63 268A05                  	mov	al,[es:di]		;AN000; get nnval
  8611 00001C66 B405                    	mov	ah,_$P_Len_Value 	;AN000;
  8612 00001C68 F6E4                    	mul	ah			;AN000; Skip nnval field
  8613 00001C6A 40                      	inc	ax			;AN000; ax = (nnval*5)+1
  8614 00001C6B 01C7                    	add	di,ax			;AN000; di points to nstrval
  8615 00001C6D 268A05                  	mov	al,[es:di]		;AN000; get nstrval c
  8616 00001C70 47                      	inc	di			;AC035; add '2' to
  8617 00001C71 47                      	inc	di			;AC035;  DI reg
  8618                                  					;AN000; di points to 1st string in list
  8619                                  _$P_Sim_Loop:				;AN000;
  8620 00001C72 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
  8621 00001C75 E83200                  	call	_$P_String_Comp		;AN000; compare it with operand
  8622 00001C78 7312                    	jnc	short _$P_Sim_Found	;AN000; found on list ?
  8623                                  
  8624 00001C7A 83C703                  	add	di,_$P_Len_String ; 3	;AN000; if no, point to next choice
  8625 00001C7D FEC8                    	dec	al			;AN000; loop nstval times in AL
  8626 00001C7F 75F1                    	jne	short _$P_Sim_Loop	;AN000;
  8627                                  					;AN000; / Not found
  8628 00001C81 2EC706[6316]0800        	mov	word [cs:_$P_RC],_$P_Not_In_Str ;AC034;
  8629 00001C88 B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8630 00001C8A EB14                    	jmp	short _$P_Sim_Exit	;AN000;
  8631                                  
  8632                                  _$P_Sim_Found:				;AN000;
  8633 00001C8C 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
  8634 00001C90 B002                    	mov	al,_$P_List_Idx		;AN000;
  8635 00001C92 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
  8636 00001C95 EB0B                    	jmp	short _$P_Sim_Exit0	;AN000;
  8637                                  ;ENDIF					;AN000;(of Val3SW+KeySW)
  8638                                  _$P_Sim01:				;AN000;
  8639 00001C97 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
  8640 00001C9E B4FF                    	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
  8641                                  _$P_Sim_Exit:				;AN000;
  8642 00001CA0 B003                    	mov	al,_$P_String		;AN000; Set type
  8643                                  _$P_Sim_Exit0:				;AN000;
  8644 00001CA2 E8A5FC                  	call	_$P_Fill_Result		;AN000;
  8645 00001CA5 5F                      	pop	di			;AN000;
  8646 00001CA6 5A                      	pop	dx			;AN000;
  8647 00001CA7 5B                      	pop	bx			;AN000;
  8648 00001CA8 58                      	pop	ax			;AN000;
  8649 00001CA9 C3                      	retn				;AN000;
  8650                                  
  8651                                  ;***********************************************************************
  8652                                  ; _$P_String_Comp:
  8653                                  ;
  8654                                  ; Function:  Compare two string
  8655                                  ;
  8656                                  ; Input:     cs:SI -> 1st string
  8657                                  ;	     ES:BP -> 2nd string  (Must be upper case)
  8658                                  ;	     ES:BX -> CONTROL block
  8659                                  ;
  8660                                  ; Output:    CY = 1 if not match
  8661                                  ;
  8662                                  ; Use:	_$P_Chk_DBCS, _$P_Do_CAPS_Char
  8663                                  ;
  8664                                  ; Vars: _$P_KEYor_SW_Ptr(W), _$P_Flags(R). _$P_KEYorSW_Ptr
  8665                                  ;***********************************************************************
  8666                                  
  8667                                  _$P_String_Comp:
  8668 00001CAA 50                      	push	ax			;AN000;
  8669 00001CAB 55                      	push	bp			;AN000;
  8670 00001CAC 52                      	push	dx			;AN000;
  8671 00001CAD 56                      	push	si			;AN000;
  8672 00001CAE B202                    	mov	dl,_$P_DOSTBL_Char	;AN000; use character case map table
  8673                                  _$P_SCOM_Loop:				;AN000;
  8674 00001CB0 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
  8675 00001CB3 E83C02                  	call	_$P_Chk_DBCS		;AN000; DBCS ?
  8676 00001CB6 723C                    	jc	short _$P_SCOM00	;AN000; yes,DBCS
  8677                                  
  8678 00001CB8 E80BFE                  	call	_$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
  8679                                  ;IF KeySW+SwSW				;AN000;(Check if keyword or switch is supported)
  8680 00001CBB 2EF606[6F16]08          	test	byte [cs:_$P_Flags2],_$P_Key_Cmp ;AC034; keyword search ?
  8681 00001CC1 740D                    	jz	short _$P_SCOM04	;AN000;
  8682                                  
  8683 00001CC3 3C3D                    	cmp	al,_$P_Keyword		;AN000; "=" is delimiter
  8684 00001CC5 751F                    	jne	short _$P_SCOM03	;AN000; IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
  8685                                  
  8686 00001CC7 26807E0100              	cmp	byte [es:bp+1],_$P_NULL ;AN021;  at end of keyword string in the control block THEN
  8687 00001CCC 7571                    	jne	short _$P_SCOM_Differ	;AN021;
  8688                                  
  8689 00001CCE EB13                    	jmp	short _$P_SCOM05 	;AN000; keyword found in synonym list
  8690                                  
  8691                                  _$P_SCOM04:				;AN000;
  8692 00001CD0 2EF606[6F16]10          	test	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; switch search ?
  8693 00001CD6 740E                    	jz	short _$P_SCOM03	;AN000;
  8694                                  
  8695 00001CD8 3C3A                    	cmp	al,_$P_Colon		;AN000; ":" is delimiter, at end of switch on command line
  8696 00001CDA 750A                    	jne	short _$P_SCOM03	;AN000; continue compares
  8697                                  
  8698                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8699 00001CDC 26807E0000              	cmp	byte [es:bp+0],_$P_NULL
  8700                                  	;cmp	byte [es:bp],_$P_NULL	;AN021; IF at end of switch on command AND
  8701 00001CE1 755C                    	jne	short _$P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
  8702                                  
  8703                                  _$P_SCOM05:				;AN000;   found a match
  8704 00001CE3 46                      	inc	si			;AN000; si points to just after "=" or ":"
  8705 00001CE4 EB5C                    	jmp	short _$P_SCOM_Same	;AN000; exit
  8706                                  
  8707                                  _$P_SCOM03:				;AN000;
  8708                                  ;ENDIF					;AN000;(of KeySW+SwSW)
  8709                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8710 00001CE6 263A4600                	cmp	al,[es:bp+0]
  8711                                  	;cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
  8712 00001CEA 751D                    	jne	short _$P_SCOM_Differ0 	;AN000; if different, check ignore colon option
  8713                                  
  8714 00001CEC 08C0                    	or	al,al			;AN000; end of line
  8715 00001CEE 7452                    	jz	short _$P_SCOM_Same	;AN000; if so, exit
  8716                                  
  8717 00001CF0 46                      	inc	si			;AN000; update operand pointer
  8718 00001CF1 45                      	inc	bp			;AN000;    and synonym pointer
  8719                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8720 00001CF2 EB13                    	jmp	short _$P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
  8721                                  
  8722                                  _$P_SCOM00:				;AN000; Here al is DBCS leading byte
  8723                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8724 00001CF4 263A4600                	cmp	al,[es:bp+0]
  8725                                  	;cmp	al,[es:bp]		;AN000; compare leading byte
  8726 00001CF8 7545                    	jne	short _$P_SCOM_Differ	;AN000; if not match, say different
  8727                                  
  8728 00001CFA 46                      	inc	si			;AN000; else, load next byte
  8729 00001CFB 2E8A04                  	mov	al,[cs:si]		;AN000; and
  8730 00001CFE 45                      	inc	bp			;AN000;
  8731                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8732 00001CFF 263A4600                	cmp	al,[es:bp+0]
  8733                                  	;cmp	al,[es:bp]		;AN000; compare 2nd byte
  8734 00001D03 753A                    	jne	short _$P_SCOM_Differ	;AN000; if not match, say different, too
  8735                                  
  8736                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8737                                  ;_$P_SCOM01:
  8738 00001D05 46                      	inc	si			;AN000; else update operand pointer
  8739 00001D06 45                      	inc	bp			;AN000; 		and synonym pointer
  8740                                  _$P_SCOM01:				;AN000;
  8741 00001D07 EBA7                    	jmp	short _$P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
  8742                                  
  8743                                  _$P_SCOM_Differ0:			;AN000;
  8744                                  ;IF SwSW				;AN000;(tm10)
  8745 00001D09 2EF606[6F16]40          	test	byte [cs:_$P_Flags2],_$P_SW ;AC034;(tm10)
  8746 00001D0F 740F                    	jz	short _$P_not_applicable ;AN000;(tm10)
  8747                                  
  8748                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  8749 00001D11 26F747022000            	test	word [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary ;AN000;(tm10)
  8750                                  	;test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary
  8751 00001D17 7407                    	je	short _$P_not_applicable ;AN000;(tm10)
  8752                                  
  8753                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8754 00001D19 26807E0000              	cmp	byte [es:bp+0],_$P_NULL
  8755                                  	;cmp	byte [es:bp],_$P_NULL	;AN000;(tm10)
  8756                                  ;(deleted ;AN025;) jne short _$P_not_applicable ;AN000;(tm10)
  8757 00001D1E 7422                    	je	short _$P_SCOM_Same	;AN025;(tm10)
  8758                                  
  8759                                  _$P_not_applicable:			;AN000;(tm10)
  8760                                  ;ENDIF					;AN000;(tm10)
  8761                                  
  8762                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
  8763                                  					;AN000; ignore colon option specified ?
  8764                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon
  8765                                  	;test	byte [es:bx],_$P_Ig_Colon
  8766                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8767 00001D20 26F7071000              	test	word [es:bx],_$P_Ig_Colon ; 10h
  8768 00001D25 7418                    	jz	short _$P_SCOM_Differ	;AN000; if no, say different.
  8769                                  
  8770 00001D27 3C3A                    	cmp	al,_$P_Colon		;AN000; End up with ":" and
  8771 00001D29 7509                    	jne	short _$P_SCOM02	;AN000;    subseqently
  8772                                  
  8773                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8774 00001D2B 26807E0000              	cmp	byte [es:bp+0],_$P_NULL
  8775                                  	;cmp	byte [es:bp],_$P_NULL	;AN000; NULL ?
  8776 00001D30 750D                    	jne	short _$P_SCOM_Differ	;AN000; if no, say different
  8777                                  
  8778 00001D32 EB0E                    	jmp	short _$P_SCOM_Same	;AN000; else, say same
  8779                                  
  8780                                  _$P_SCOM02:				;AN000;
  8781 00001D34 3C00                    	cmp	al,_$P_NULL		;AN000; end up NULL and :
  8782 00001D36 7507                    	jne	short _$P_SCOM_Differ	;AN000;
  8783                                  
  8784                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8785 00001D38 26807E003A              	cmp	byte [es:bp+0],_$P_Colon
  8786                                  	;cmp	byte [es:bp],_$P_Colon	;AN000; if no, say different
  8787 00001D3D 7403                    	je	short _$P_SCOM_Same	;AN000; else, say same
  8788                                  
  8789                                  _$P_SCOM_Differ: 			;AN000;
  8790 00001D3F F9                      	stc				;AN000; indicate not found
  8791 00001D40 EB06                    	jmp	short _$P_SCOM_Exit	;AN000;
  8792                                  
  8793                                  _$P_SCOM_Same:				;AN000;
  8794 00001D42 2E8936[7216]            	mov	[cs:_$P_KEYorSW_Ptr],si ;AC034; for later use by keyword or switch
  8795 00001D47 F8                      	clc				;AN000; indicate found
  8796                                  _$P_SCOM_Exit:				;AN000;
  8797 00001D48 5E                      	pop	si			;AN000;
  8798 00001D49 5A                      	pop	dx			;AN000;
  8799 00001D4A 5D                      	pop	bp			;AN000;
  8800 00001D4B 58                      	pop	ax			;AN000;
  8801 00001D4C C3                      	retn
  8802                                  
  8803                                  ; 30/03/2019
  8804                                  
  8805                                  ;IF FileSW+DrvSW			;AN000;(Check if file spec or drive only is supported)
  8806                                  
  8807                                  ;***********************************************************************
  8808                                  ; _$P_File_Format;
  8809                                  ;
  8810                                  ; Function:  Check if the input string is valid file spec format.
  8811                                  ;	     And set the result buffer.
  8812                                  ;
  8813                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8814                                  ;	     ES:BX -> CONTROL block
  8815                                  ;
  8816                                  ; Output:    None
  8817                                  ;
  8818                                  ; Use:	_$P_Fill_Result, _$P_Chk_DBCS, _$P_FileSp_Chk
  8819                                  ;
  8820                                  ; Vars: _$P_RC(W), _$P_SI_Save(W), _$P_Terminator(W), _$P_SaveSI_Cmpx(R)
  8821                                  ;	_$P_SaveSI_Cmpx(R)
  8822                                  ;***********************************************************************
  8823                                  
  8824                                  _$P_File_Format:
  8825 00001D4D 50                      	push	ax			;AN000;
  8826 00001D4E 57                      	push	di			;AN000;
  8827 00001D4F 56                      	push	si			;AN000;
  8828 00001D50 2E8B3E[7016]            	mov	di,[cs:_$P_SaveSI_Cmpx]	;AC034; get user buffer address
  8829                                  _$P_FileF_Loop0: 			;AN000; / skip special characters
  8830 00001D55 2E8A04                  	mov	al,[cs:si]		;AN000; load character
  8831 00001D58 08C0                    	or	al,al			;AN000; end of line ?
  8832 00001D5A 7413                    	jz	short _$P_FileF_Err	;AN000; if yes, error exit
  8833                                  
  8834 00001D5C E85F00                  	call	_$P_FileSp_Chk		;AN000; else, check if file special character
  8835 00001D5F 7524                    	jne	short _$P_FileF03	;AN000; if yes,
  8836                                  
  8837 00001D61 2EC606[0617]01          	mov	byte [cs:_$P_err_flag],_$P_error_filespec 
  8838                                  					;AN033;AC034;; set error flag- bad char.
  8839 00001D67 5E                      	pop	si			;AN033;
  8840 00001D68 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN033;
  8841 00001D6C 5F                      	pop	di			;AN033;
  8842 00001D6D EB3F                    	jmp	short _$P_FileF02	;AN033;
  8843                                  
  8844                                  _$P_FileF_Err:				;AN000;
  8845 00001D6F 5E                      	pop	si			;AN000;
  8846 00001D70 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000;
  8847 00001D74 5F                      	pop	di			;AN000;
  8848                                  
  8849                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional ;AN000; is it optional ?
  8850                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional
  8851                                  	;test	byte [es:bx],_$P_Optional
  8852                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8853 00001D75 26F7070100              	test	word [es:bx],_$P_Optional
  8854 00001D7A 7532                    	jnz	short _$P_FileF02	;AN000;
  8855                                  
  8856 00001D7C 2EC706[6316]0200        	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; 3/17/87
  8857 00001D83 EB29                    	jmp	short _$P_FileF02	;AN000;
  8858                                  
  8859                                  _$P_FileF03:				;AN000;
  8860 00001D85 58                      	pop	ax			;AN000; discard save si
  8861 00001D86 56                      	push	si			;AN000; save new si
  8862                                  _$P_FileF_Loop1: 			;AN000;
  8863 00001D87 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
  8864 00001D8A 08C0                    	or	al,al			;AN000; end of line ?
  8865 00001D8C 741E                    	jz	short _$P_FileF_RLT	;AN000;
  8866                                  
  8867 00001D8E E82D00                  	call	_$P_FileSp_Chk		;AN000; File special character ?
  8868 00001D91 740B                    	je	short _$P_FileF00	;AN000;
  8869                                  
  8870 00001D93 E85C01                  	call	_$P_Chk_DBCS		;AN000; no, then DBCS ?
  8871 00001D96 7302                    	jnc	short _$P_FileF01	;AN000;
  8872 00001D98 47                      	inc	di			;AN000; if yes, skip next byte
  8873 00001D99 46                      	inc	si			;AN000;
  8874                                  _$P_FileF01:				;AN000;
  8875 00001D9A 47                      	inc	di			;AN000;
  8876 00001D9B 46                      	inc	si			;AN000;
  8877 00001D9C EBE9                    	jmp	short _$P_FileF_Loop1	;AN000;
  8878                                  ;
  8879                                  _$P_FileF00:				;AN000;
  8880 00001D9E 2EA2[6916]              	mov	[cs:_$P_Terminator],al	;AC034;
  8881 00001DA2 2EC60400                	mov	byte [cs:si],_$P_NULL	;AN000; update end of string
  8882 00001DA6 47                      	inc	di			;AN000;
  8883 00001DA7 2E893E[6516]            	mov	[cs:_$P_SI_Save],di	;AC034; update next pointer in command line
  8884                                  _$P_FileF_RLT:				;AN000;
  8885 00001DAC 5E                      	pop	si			;AN000;
  8886 00001DAD 5F                      	pop	di			;AN000;
  8887                                  _$P_FileF02:				;AN000;
  8888 00001DAE 58                      	pop	ax			;AN000; (tm14)
  8889 00001DAF A90002                  	test	ax,_$P_File_Spc		;AN000; (tm14)
  8890 00001DB2 7409                    	jz	short _$P_Drv_Only_Exit	;AN000; (tm14)
  8891                                  
  8892 00001DB4 50                      	push	ax			;AN000;  (tm14)
  8893                                  
  8894 00001DB5 B4FF                    	mov	ah,_$P_No_Tag		;AN000; set
  8895 00001DB7 B005                    	mov	al,_$P_File_Spec 	;AN000;    result
  8896 00001DB9 E88EFB                  	call	_$P_Fill_Result		;AN000; 	 buffer to file spec
  8897 00001DBC 58                      	pop	ax			;AN000;
  8898                                  
  8899                                  _$P_Drv_Only_Exit:			;AN000; (tm14)
  8900 00001DBD C3                      	retn				;AN000;
  8901                                  
  8902                                  ;***********************************************************************
  8903                                  ; _$P_FileSp_Chk
  8904                                  ;
  8905                                  ; Function:  Check if the input byte is one of file special characters
  8906                                  ;
  8907                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8908                                  ;	     AL = character code to be examineed
  8909                                  ;
  8910                                  ; Output:    ZF = 1 , AL is one of special characters
  8911                                  ;***********************************************************************
  8912                                  
  8913                                  _$P_FileSp_Chk:
  8914 00001DBE 53                      	push	bx			;AN000;
  8915 00001DBF 51                      	push	cx			;AN000;
  8916                                  	;lea	bx,[cs:_$P_FileSp_Char] ;AC034; special character table
  8917 00001DC0 8D1E[FD16]              	lea	bx,[_$P_FileSp_Char]
  8918 00001DC4 B90900                  	mov	cx,_$P_FileSp_Len	;AN000; load length of it
  8919                                  _$P_FileSp_Loop: 			;AN000;
  8920 00001DC7 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
  8921 00001DCA 7404                    	je	short _$P_FileSp_Exit	;AN000;
  8922                                  
  8923 00001DCC 43                      	inc	bx			;AN000;
  8924 00001DCD E2F8                    	loop	_$P_FileSp_Loop		;AN000;
  8925                                  
  8926 00001DCF 41                      	inc	cx			;AN000; reset ZF
  8927                                  _$P_FileSp_Exit: 			;AN000;
  8928 00001DD0 59                      	pop	cx			;AN000;
  8929 00001DD1 5B                      	pop	bx			;AN000;
  8930 00001DD2 C3                      	retn
  8931                                  
  8932                                  ;ENDIF					;AN000;(of FileSW+DrvSW)
  8933                                  
  8934                                  ;IF	DrvSW				;AN000;(Check if drive only is supported)
  8935                                  
  8936                                  ;***********************************************************************
  8937                                  ; _$P_Drive_Format;
  8938                                  ;
  8939                                  ; Function:  Check if the input string is valid drive only format.
  8940                                  ;	     And set the result buffer.
  8941                                  ;
  8942                                  ; Input:     cs:SI -> _$P_STRING_BUF
  8943                                  ;	     ES:BX -> CONTROL block
  8944                                  ;
  8945                                  ; Output:    None
  8946                                  ;
  8947                                  ; Use:	_$P_Fill_Result, _$P_Chk_DBCS
  8948                                  ;
  8949                                  ; Vars: _$P_RC(W)
  8950                                  ;***********************************************************************
  8951                                  
  8952                                  _$P_Drive_Format:
  8953 00001DD3 50                      	push	ax			;AN000;
  8954 00001DD4 52                      	push	dx			;AN000;
  8955 00001DD5 2E8A04                  	mov	al,[cs:si]		;AN000;
  8956 00001DD8 08C0                    	or	al,al			;AN000; if null string
  8957 00001DDA 7438                    	je	short _$P_Drv_Exit	;AN000; do nothing
  8958                                  
  8959 00001DDC E81301                  	call	_$P_Chk_DBCS		;AN000; is it leading byte ?
  8960 00001DDF 722C                    	jc	short _$P_Drv_Err	;AN000;
  8961                                  
  8962 00001DE1 2E837C013A              	cmp	word [cs:si+1],_$P_Colon ;AN000; "d", ":", 0  ?
  8963 00001DE6 740E                    	je	short _$P_DrvF00	;AN000;
  8964                                  
  8965                                  	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
  8966                                  	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon ;AN000; colon can be ignored?
  8967                                  	;test	byte [es:bx],_$P_Ig_Colon
  8968                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
  8969 00001DE8 26F7071000              	test	word [es:bx],_$P_Ig_Colon
  8970 00001DED 741E                    	jz	short _$P_Drv_Err	;AN000;
  8971                                  
  8972 00001DEF 2E807C0100              	cmp	byte [cs:si+1],_$P_NULL ;AN000; "d", 0  ?
  8973 00001DF4 7517                    	jne	short _$P_Drv_Err	;AN000;
  8974                                  
  8975                                  _$P_DrvF00:				;AN000;
  8976 00001DF6 0C20                    	or	al,_$P_Make_Lower	;AN000; lower case
  8977 00001DF8 3C61                    	cmp	al,"a"                  ;AN000; drive letter must
  8978 00001DFA 7211                    	jb	short _$P_Drv_Err	;AN000; in range of
  8979                                  
  8980 00001DFC 3C7A                    	cmp	al,"z"                  ;AN000; "a" - "z"
  8981 00001DFE 770D                    	ja	short _$P_Drv_Err	;AN000; if no, error
  8982                                  
  8983 00001E00 2C60                    	sub	al,"a"-1                ;AN000; make text drive to binary drive
  8984 00001E02 88C2                    	mov	dl,al			;AN000; set
  8985 00001E04 B4FF                    	mov	ah,_$P_No_Tag		;AN000;    result
  8986 00001E06 B006                    	mov	al,_$P_Drive		;AN000; 	 buffer
  8987 00001E08 E83FFB                  	call	_$P_Fill_Result		;AN000; 	       to drive
  8988 00001E0B EB07                    	jmp	short _$P_Drv_Exit	;AN000;
  8989                                  
  8990                                  _$P_Drv_Err:				;AN000;
  8991 00001E0D 2EC706[6316]0900        	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
  8992                                  _$P_Drv_Exit:				;AN000;
  8993 00001E14 5A                      	pop	dx			;AN000;
  8994 00001E15 58                      	pop	ax			;AN000;
  8995 00001E16 C3                      	retn				;AN000;
  8996                                  
  8997                                  ;ENDIF					;AN000;(of DrvSW)
  8998                                  
  8999                                  ;***********************************************************************
  9000                                  ; _$P_Skip_Delim;
  9001                                  ;
  9002                                  ; Function: Skip delimiters specified in the PARMS list, white space
  9003                                  ;	    and comma.
  9004                                  ;
  9005                                  ; Input:    DS:SI -> Command String
  9006                                  ;	    ES:DI -> Parameter List
  9007                                  ;
  9008                                  ; Output:   CY = 1 if the end of line encounterd
  9009                                  ;	    CY = 0 then SI move to 1st non-delimiter character
  9010                                  ;	    AL = Last examineed character
  9011                                  ;
  9012                                  ; Use:	    _$P_Chk_EOL, _$P_Chk_Delim,
  9013                                  ;
  9014                                  ; Vars:     _$P_Flags(R)
  9015                                  ;***********************************************************************
  9016                                  
  9017                                  _$P_Skip_Delim:
  9018                                  _$P_Skip_Delim_Loop:			;AN000;
  9019 00001E17 AC                      	lodsb				;AN000;
  9020 00001E18 E82200                  	call	_$P_Chk_EOL		;AN000; is it EOL character ?
  9021 00001E1B 7418                    	jz	short _$P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
  9022                                  
  9023 00001E1D E85300                  	call	_$P_Chk_Delim		;AN000; is it one of delimiters ?
  9024 00001E20 7516                    	jnz	short _$P_Skip_Delim_NCY ;AN000; if no, exit w/ CY off
  9025                                  
  9026 00001E22 2EF606[6F16]20          	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; extra delim or comma found ?
  9027 00001E28 74ED                    	jz	short _$P_Skip_Delim_Loop ;AN000; if no, loop
  9028                                  
  9029 00001E2A 2EF606[6F16]41          	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AC034; /x , or xxx=zzz , (tm08)
  9030 00001E30 7409                    	jz	short _$P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
  9031                                  
  9032 00001E32 4E                      	dec	si			;AN000; backup si for next call (tm08)
  9033 00001E33 EB06                    	jmp	short _$P_Exit_At_Extra	;AN000; else exit w/ CY off
  9034                                  
  9035                                  _$P_Skip_Delim_CY:			;AN000;
  9036 00001E35 F9                      	stc				;AN000; indicate EOL
  9037 00001E36 EB01                    	jmp	short _$P_Skip_Delim_Exit ;AN000;
  9038                                  
  9039                                  _$P_Skip_Delim_NCY:			;AN000;
  9040 00001E38 F8                      	clc				;AN000; indicate non delim
  9041                                  _$P_Skip_Delim_Exit:			;AN000; in this case, need
  9042 00001E39 4E                      	dec	si			;AN000;  backup index pointer
  9043 00001E3A C3                      	retn				;AN000;
  9044                                  
  9045                                  _$P_Exit_At_Extra:			;AN000;
  9046 00001E3B F8                      	clc				;AN000; indicate extra delim
  9047 00001E3C C3                      	retn				;AN000;
  9048                                  
  9049                                  ;***********************************************************************
  9050                                  ; _$P_Chk_EOL;
  9051                                  ;
  9052                                  ; Function: Check if AL is one of End of Line characters.
  9053                                  ;
  9054                                  ; Input:    AL = character code
  9055                                  ;	    ES:DI -> Parameter List
  9056                                  ;
  9057                                  ; Output:   ZF = 1 if one of End of Line characters
  9058                                  ;**********************************************************************
  9059                                  
  9060                                  _$P_Chk_EOL:
  9061 00001E3D 53                      	push	bx			;AN000;
  9062 00001E3E 51                      	push	cx			;AN000;
  9063 00001E3F 3C0D                    	cmp	al,_$P_CR		;AN000; Carriage return ?
  9064 00001E41 742D                    	je	short _$P_Chk_EOL_Exit 	;AN000;
  9065                                  
  9066 00001E43 3C00                    	cmp	al,_$P_NULL		;AN000; zero ?
  9067 00001E45 7429                    	je	short _$P_Chk_EOL_Exit 	;AN000;
  9068                                  
  9069                                  ;IF LFEOLSW				;AN028; IF LF TO BE ACCEPTED AS EOL
  9070 00001E47 3C0A                    	cmp	al,_$P_LF		;AN000; Line feed ?
  9071 00001E49 7425                    	je	short _$P_Chk_EOL_Exit 	;AN000;
  9072                                  ;ENDIF					;AN028;
  9073                                  
  9074 00001E4B 26807D0202              	cmp	byte [es:di+_$P_PARMS_Blk.Num_Extra],_$P_I_Have_EOL 
  9075                                  					;AN000; EOL character specified ?
  9076 00001E50 721E                    	jb	short _$P_Chk_EOL_Exit 	;AN000;
  9077                                  
  9078 00001E52 31DB                    	xor	bx,bx			;AN000;
  9079 00001E54 268A5D03                	mov	bl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim]
  9080                                  					;AN000; get length of delimiter list
  9081 00001E58 83C304                  	add	bx,_$P_Len_PARMS 	;AN000; skip it
  9082 00001E5B 26803900                	cmp	byte [es:bx+di],_$P_I_Use_Default ;AN000; No extra EOL character ?
  9083 00001E5F 740D                    	je	short _$P_Chk_EOL_NZ	;AN000;
  9084                                  
  9085                                  	;xor	cx,cx			;AN000; Get number of extra character
  9086 00001E61 30ED                    	xor	ch,ch
  9087 00001E63 268A09                  	mov	cl,[es:bx+di]		;AN000;
  9088                                  _$P_Chk_EOL_Loop:			;AN000;
  9089 00001E66 43                      	inc	bx			;AN000;
  9090 00001E67 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
  9091 00001E6A 7404                    	je	short _$P_Chk_EOL_Exit 	;AN000;
  9092                                  
  9093 00001E6C E2F8                    	loop	_$P_Chk_EOL_Loop 	;AN000;
  9094                                  
  9095                                  _$P_Chk_EOL_NZ:				;AN000;
  9096 00001E6E 3C0D                    	cmp	al,_$P_CR		;AN000; reset ZF
  9097                                  _$P_Chk_EOL_Exit:			;AN000;
  9098 00001E70 59                      	pop	cx			;AN000;
  9099 00001E71 5B                      	pop	bx			;AN000;
  9100 00001E72 C3                      	retn
  9101                                  
  9102                                  ;***********************************************************************
  9103                                  ; _$P_Chk_Delim;
  9104                                  ;
  9105                                  ; Function: Check if AL is one of delimiter characters.
  9106                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
  9107                                  ;	    blanks.
  9108                                  ;
  9109                                  ; Input:    AL = character code
  9110                                  ;	    DS:SI -> Next Character
  9111                                  ;	    ES:DI -> Parameter List
  9112                                  ;
  9113                                  ; Output:   ZF = 1 if one of delimiter characters
  9114                                  ;	    SI points to the next character
  9115                                  ; Vars:  _$P_Terminator(W), _$P_Flags(W)
  9116                                  ;***********************************************************************
  9117                                  
  9118                                  _$P_Chk_Delim:
  9119 00001E73 53                      	push	bx			;AN000;
  9120 00001E74 51                      	push	cx			;AN000;
  9121 00001E75 2EC606[6916]20          	mov	byte [cs:_$P_Terminator],_$P_Space 
  9122                                  					;AC034; Assume terminated by space
  9123                                  	;and	byte [cs:_$P_Flags20,0DFh
  9124 00001E7B 2E8026[6F16]DF          	and	byte [cs:_$P_Flags2],0FFh-_$P_Extra ;AC034;
  9125 00001E81 3C20                    	cmp	al,_$P_Space ; 20h	;AN000; Space ?
  9126 00001E83 7436                    	je	short _$P_Chk_Delim_Exit ;AN000;
  9127                                  
  9128 00001E85 3C09                    	cmp	al,_$P_TAB		;AN000; TAB ?
  9129 00001E87 7432                    	je	short _$P_Chk_Delim_Exit ;AN000;
  9130                                  
  9131 00001E89 3C2C                    	cmp	al,_$P_Comma		;AN000; Comma ?
  9132 00001E8B 7431                    	je	short _$P_Chk_Delim_Exit0 ;AN000;
  9133                                  
  9134                                  	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  9135                                  _$P_Chk_Delim00: 			;AN000;
  9136 00001E8D 3C20                    	cmp	al,_$P_DBSP1	; 20h	;AN000; 1st byte of DBCS Space ?
  9137 00001E8F 750C                    	jne	short _$P_Chk_Delim01	;AN000;
  9138                                  
  9139 00001E91 803C20                  	cmp	byte [si],_$P_DBSP2 ; 20h ;AN000; 2nd byte of DBCS Space ?
  9140 00001E94 7507                    	jne	short _$P_Chk_Delim01	;AN000;
  9141                                  
  9142 00001E96 B020                    	mov	al,_$P_Space		;AN000;
  9143 00001E98 46                      	inc	si			;AN000; make si point to next character
  9144 00001E99 38C0                    	cmp	al,al			;AN000; Set ZF
  9145 00001E9B EB1E                    	jmp	short _$P_Chk_Delim_Exit ;AN000;
  9146                                  
  9147                                  _$P_Chk_Delim01: 			;AN000;
  9148 00001E9D 26807DFE01              	cmp	byte [es:di-_$P_PARMS_Blk.Num_Extra],_$P_I_Have_Delim 
  9149                                  					;AN000; delimiter character specified ?
  9150 00001EA2 7217                    	jb	short _$P_Chk_Delim_Exit ;AN000;
  9151                                  
  9152                                  	;xor	cx,cx			;AN000;
  9153 00001EA4 30ED                    	xor	ch,ch
  9154                                  	;mov	cl,[es:di+3]
  9155 00001EA6 268A4D03                	mov	cl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim] 
  9156                                  					;AN000; get length of delimiter list
  9157 00001EAA 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
  9158 00001EAC 740B                    	jz	short _$P_Chk_Delim_NZ 	;AN000;
  9159                                  
  9160 00001EAE BB0300                  	mov	bx,_$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
  9161                                  _$P_Chk_Delim_Loop:			;AN000;
  9162 00001EB1 43                      	inc	bx			;AN000;
  9163 00001EB2 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
  9164 00001EB5 7407                    	je	short _$P_Chk_Delim_Exit0 ;AN000;
  9165                                  
  9166 00001EB7 E2F8                    	loop	_$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
  9167                                  
  9168                                  _$P_Chk_Delim_NZ:			;AN000;
  9169 00001EB9 3C20                    	cmp	al,_$P_Space		;AN000; reset ZF
  9170                                  _$P_Chk_Delim_Exit:			;AN000;
  9171                                  _$P_ChkDfin:				;AN000;
  9172 00001EBB 59                      	pop	cx			;AN000;
  9173 00001EBC 5B                      	pop	bx			;AN000;
  9174 00001EBD C3                      	retn				;AN000;
  9175                                  
  9176                                  _$P_Chk_Delim_Exit0:			;AN000;
  9177 00001EBE 2EA2[6916]              	mov	[cs:_$P_Terminator],al ;AC034; keep terminated delimiter
  9178 00001EC2 2EF606[6F16]01          	test	byte [cs:_$P_Flags2],_$P_equ ;AN027;AC034;; if terminating a key=
  9179 00001EC8 7506                    	jnz	short _$P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
  9180                                  
  9181 00001ECA 2E800E[6F16]20          	or	byte [cs:_$P_Flags2],_$P_Extra 
  9182                                  					;AC034; flag terminated extra delimiter or comma
  9183                                  _$P_No_Set_Extra:			;AN027;
  9184 00001ED0 38C0                    	cmp	al,al			;AN000; set ZF
  9185 00001ED2 EBE7                    	jmp	short _$P_Chk_Delim_Exit ;AN000;
  9186                                  
  9187                                  
  9188                                  ;***********************************************************************
  9189                                  ; _$P_Chk_Switch;
  9190                                  ;
  9191                                  ; Function: Check if AL is the switch character not in first position of
  9192                                  ;	    _$P_STRING_BUF
  9193                                  ;
  9194                                  ; Input:    AL = character code
  9195                                  ;	    BX = current pointer within _$P_String_Buf
  9196                                  ;	    SI =>next char on command line (following the one in AL)
  9197                                  ;
  9198                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
  9199                                  ;		 position, and has no chance of being part of a date string,
  9200                                  ;		 i.e. should be treated as a delimiter.
  9201                                  
  9202                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
  9203                                  ;		 position, or is a slash but may be part of a date string, i.e.
  9204                                  ;		 should not be treated as a delimiter.
  9205                                  ;
  9206                                  ; Vars:  _$P_Terminator(W)
  9207                                  
  9208                                  ; Use:	 _$P_0099
  9209                                  ;***********************************************************************
  9210                                  
  9211                                  _$P_Chk_Switch:
  9212                                  	;lea	bp,[cs:_$P_STRING_BUF]	;AN020;AC034
  9213 00001ED4 8D2E[7816]              	lea	bp,[_$P_STRING_BUF]	; BP=OFFSET of _$P_String_Buf even in group addressing
  9214                                  ;	.IF <BX NE BP> THEN		;AN020;IF not first char THEN
  9215 00001ED8 39EB                    	cmp	bx,bp			;AN000;
  9216 00001EDA 740A                    	je	short _$P_STRUC_L2	;AN000;
  9217                                  
  9218                                  ;	    .IF <AL EQ _$P_Switch> THEN	;AN020;otherwise see if a slash
  9219 00001EDC 3C2F                    	cmp	al,_$P_Switch		;AN000;
  9220 00001EDE 7503                    	jne	short _$P_STRUC_L5 	;AN000;
  9221                                  
  9222 00001EE0 F9                      	stc				;AN020;not in first position and is slash
  9223 00001EE1 EB0E                    	jmp     short _$P_STRUC_L1	;AN000;
  9224                                  
  9225                                  _$P_STRUC_L5:				;AN000;
  9226 00001EE3 F8                      	CLC				;AN020;not a slash
  9227                                  ;	    .ENDIF			;AN020;
  9228                                  ;	.ELSE				;AN020;is first char in the buffer, ZF=0
  9229 00001EE4 EB0B                    	jmp	short _$P_STRUC_L1	;AN000;
  9230                                  
  9231                                  _$P_STRUC_L2:				;AN000;
  9232                                  ;	    .IF <AL EQ _$P_Switch> THEN	;AN020;
  9233 00001EE6 3C2F                    	cmp     al,_$P_Switch		;AN000;
  9234 00001EE8 7506                    	jne	short _$P_STRUC_L12	;AN000;
  9235                                  
  9236 00001EEA 2E800E[6F16]40          	or	byte [cs:_$P_Flags2],_$P_SW ;AN020;AC034;;could be valid switch, first char and is slash
  9237                                  ;	    .ENDIF			;AN020;
  9238                                  _$P_STRUC_L12:				;AN000;
  9239 00001EF0 F8                      	clc				;AN020;CF=0 indicating first char
  9240                                  ;	.ENDIF				;AN020;
  9241                                  _$P_STRUC_L1:				;AN000;
  9242 00001EF1 C3                      	retn				;AN000;
  9243                                  
  9244                                  ;**************************************************************************
  9245                                  ; _$P_Chk_DBCS:
  9246                                  ;
  9247                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
  9248                                  ;
  9249                                  ;  Input:
  9250                                  ;	  AL	= Code to be examineed
  9251                                  ;
  9252                                  ;  Output:
  9253                                  ;	  If CF is on then a lead byte of DBCS
  9254                                  ;
  9255                                  ; Use: INT 21h w/AH=63
  9256                                  ;
  9257                                  ; Vars:  _$P_DBCSEV_Seg(RW), _$P_DBCSEV_Off(RW)
  9258                                  ;***************************************************************************
  9259                                  
  9260                                  _$P_Chk_DBCS:
  9261 00001EF2 1E                      	push	ds			;AN000;
  9262 00001EF3 56                      	push	si			;AN000;
  9263 00001EF4 53                      	push	bx			;AN000; (tm11)
  9264                                  	
  9265 00001EF5 2E833E[6C16]00          	cmp	word [cs:_$P_DBCSEV_SEG],0 ;AC034; ALREADY SET ?
  9266 00001EFB 7527                    	jne	short _$P_DBCS00	;AN000;
  9267                                  
  9268 00001EFD 50                      	push	ax			;AN000;
  9269 00001EFE 1E                      	push	ds			;AN000; (tm11)
  9270 00001EFF 51                      	push	cx			;AN000;
  9271 00001F00 52                      	push	dx			;AN000;
  9272 00001F01 57                      	push	di			;AN000;
  9273 00001F02 55                      	push	bp			;AN000;
  9274 00001F03 06                      	push	es			;AN000;
  9275 00001F04 31F6                    	xor	si,si			;AN000;
  9276 00001F06 8EDE                    	mov	ds,si			;AN000;
  9277 00001F08 B80063                  	MOV	ax,_$P_DOS_GetEV ; 6300h ;AN000; GET DBCS EV CALL
  9278 00001F0B CD21                    	int	21h			;AN000;
  9279                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  9280 00001F0D 8CDB                    	mov	bx,ds			;AN000; (tm11)
  9281 00001F0F 09DB                    	or	bx,bx			;AN000; (tm11)
  9282 00001F11 07                      	pop	es			;AN000;
  9283 00001F12 5D                      	pop	bp			;AN000;
  9284 00001F13 5F                      	pop	di			;AN000;
  9285 00001F14 5A                      	pop	dx			;AN000;
  9286 00001F15 59                      	pop	cx			;AN000;
  9287 00001F16 1F                      	pop	ds			;AN000; (tm11)
  9288 00001F17 58                      	pop	ax			;AN000;
  9289 00001F18 7429                    	jz	short _$P_NON_DBCS	;AN000;
  9290                                  
  9291                                  _$P_DBCS02:				;AN000;
  9292 00001F1A 2E8936[6A16]            	mov	[cs:_$P_DBCSEV_OFF],si	;AC034; save EV offset
  9293 00001F1F 2E891E[6C16]            	mov	[cs:_$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
  9294                                  _$P_DBCS00:				;AN000;
  9295 00001F24 2E8B36[6A16]            	mov	si,[cs:_$P_DBCSEV_OFF]	;AC034; load EV offset
  9296 00001F29 2E8E1E[6C16]            	mov	ds,[cs:_$P_DBCSEV_SEG]	;AC034; and segment
  9297                                  
  9298                                  _$P_DBCS_LOOP:				;AN000;
  9299 00001F2E 833C00                  	cmp	word [si],0		;AN000; zero vector ?
  9300 00001F31 7410                    	je	short _$P_NON_DBCS	;AN000; then exit
  9301                                  
  9302 00001F33 3A04                    	cmp	al,[si] 		;AN000;
  9303 00001F35 7208                    	jb	short _$P_DBCS01	;AN000; Check if AL is in
  9304                                  
  9305 00001F37 3A4401                  	cmp	al,[si+1]		;AN000;   range of
  9306 00001F3A 7703                    	ja	short _$P_DBCS01	;AN000;      the vector
  9307                                  
  9308 00001F3C F9                      	stc				;AN000; if yes, indicate DBCS and exit
  9309 00001F3D EB05                    	jmp	short _$P_DBCS_EXIT	;AN000;
  9310                                  
  9311                                  _$P_DBCS01:				;AN000;
  9312 00001F3F 46                      	inc	si			;AC035; add '2' to
  9313 00001F40 46                      	inc	si			;AC035;  SI reg
  9314                                  					;AN000; get next vector
  9315 00001F41 EBEB                    	jmp	short _$P_DBCS_LOOP	;AN000; loop until zero vector found
  9316                                  
  9317                                  _$P_NON_DBCS:				;AN000;
  9318 00001F43 F8                      	clc				;AN000; indicate SBCS
  9319                                  _$P_DBCS_EXIT:				;AN000;
  9320 00001F44 5B                      	pop	bx			;AN000; (tm11)
  9321 00001F45 5E                      	pop	si			;AN000;
  9322 00001F46 1F                      	pop	ds			;AN000;
  9323 00001F47 C3                      	retn				;AN000;
  9324                                  
  9325                                  ; SYSCONF.ASM - MSDOS 6.0 - 1991
  9326                                  ; ======================================================================
  9327                                  ; 27/03/2019 - Retro DOS v4.0
  9328                                  
  9329                                  ;control block definitions for parser.
  9330                                  ;-----------------------------------------------------------------------
  9331                                  ; buffer = [n | n,m] {/e}
  9332                                  
  9333                                  ; 30/03/2019
  9334                                  
  9335                                  struc p_parms
  9336 00000000 ????                    	resw	1	; dw ?
  9337 00000002 ??                      	resb	1	; db 1	; an extra delimiter list
  9338 00000003 ??                      	resb	1	; db 1	; length is 1
  9339 00000004 ??                      	resb 	1	; db ';' ; delimiter
  9340                                  .size:
  9341                                  endstruc
  9342                                  
  9343                                  struc p_pos
  9344 00000000 ????                    	resw	1	; dw ?	; numeric value??
  9345 00000002 ????                    	resw	1	; dw ?	; function
  9346 00000004 ????                    	resw	1	; dw ?	; result value buffer
  9347                                  
  9348                                  ; note: by defining result_val before this structure, we could remove
  9349                                  ;  the "result_val" from every structure invocation
  9350                                  
  9351 00000006 ????                    	resw	1	; dw ?	; value list
  9352 00000008 ??                      	resb	1	; db 0	; no switches/keywords
  9353                                  .size:
  9354                                  endstruc
  9355                                  
  9356                                  struc	p_range
  9357 00000000 ??                      	resb	1	; db 1	; range definition
  9358 00000001 ??                      	resb 	1	; db 1	; 1 definition of range
  9359 00000002 ??                      	resb 	1	; db 1	; item tag for this range
  9360 00000003 ????????                	resd	1	; dd ?	; numeric min
  9361 00000007 ????????                	resd	1	; dd ?	; numeric max
  9362                                  .size:
  9363                                  endstruc
  9364                                  
  9365                                  ;-----------------------------------------------------------------------
  9366                                  
  9367                                  	; 26/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9368                                  	; (SYSINIT:1F48h)
  9369                                  
  9370                                  ; buffer = [n | n,m] {/e}
  9371                                  
  9372                                  ;buf_parms p_parms <buf_parmsx>
  9373                                  buf_parms: 
  9374 00001F48 [4D1F]                  	dw	buf_parmsx
  9375 00001F4A 01                      	db	1	; an extra delimiter list
  9376 00001F4B 01                      	db	1	; length is 1
  9377 00001F4C 3B                      	db	';'	; delimiter
  9378                                  
  9379                                  buf_parmsx:
  9380 00001F4D 0102[571F][6B1F]        	dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
  9381 00001F53 01                      	db	1			; one switch
  9382 00001F54 [7F1F]                  	dw	sw_x_ctrl
  9383 00001F56 00                      	db	0			; no keywords
  9384                                  
  9385                                  ;buf_pos1 p_pos <8000h,0,result_val,buf_range_1>  ; numeric
  9386                                  buf_pos1:
  9387 00001F57 0080                    	dw	8000h	; numeric value??
  9388 00001F59 0000                    	dw	0	; function
  9389 00001F5B [911F]                  	dw	result_val ; result value buffer	
  9390 00001F5D [601F]                  	dw	buf_range_1 ; value list
  9391 00001F5F 00                      	db	0  	; no switches/keywords
  9392                                  
  9393                                  ;buf_range_1 p_range <,,,1,99>		; M050
  9394                                  buf_range_1:
  9395 00001F60 01                      	db	1	; range definition
  9396 00001F61 01                      	db	1	; 1 definition of range
  9397 00001F62 01                      	db	1	; item tag for this range
  9398 00001F63 01000000                	dd	1	; numeric min
  9399 00001F67 63000000                	dd	99	; numeric max
  9400                                  
  9401                                  ;buf_pos2 p_pos <8001h,0,result_val,buf_range_2> ; optional num.
  9402                                  buf_pos2:
  9403 00001F6B 0180                    	dw	8001h
  9404 00001F6D 0000                    	dw	0
  9405 00001F6F [911F]                  	dw	result_val	
  9406 00001F71 [741F]                  	dw	buf_range_2
  9407 00001F73 00                      	db	0
  9408                                  
  9409                                  ;buf_range_2 p_range <,,,0,8>
  9410                                  buf_range_2:
  9411 00001F74 01                      	db	1
  9412 00001F75 01                      	db	1
  9413 00001F76 01                      	db	1
  9414 00001F77 00000000                	dd	0
  9415 00001F7B 08000000                	dd	8
  9416                                  
  9417                                  ;sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
  9418                                  sw_x_ctrl:
  9419 00001F7F 0000                    	dw	0
  9420 00001F81 0000                    	dw	0
  9421 00001F83 [911F]                  	dw	result_val	
  9422 00001F85 [901F]                  	dw	noval
  9423 00001F87 01                      	db	1	; 1 switch
  9424                                  	
  9425                                  switch_x:
  9426 00001F88 2F5800                  	db	'/X',0		; M016
  9427                                  
  9428                                  p_buffers:
  9429 00001F8B 0000                    	dw	0	; local variables
  9430                                  p_h_buffers:
  9431 00001F8D 0000                    	dw	0
  9432                                  	; 26/10/2022  (MSDOS 5.0 IO.SYS SYSINIT compatibility)
  9433                                  p_buffer_slash_x:
  9434 00001F8F 00                      	db	0 ; 31/03/2019
  9435                                  
  9436                                  ;-- common definitions -------------------------------------------------
  9437                                  
  9438 00001F90 00                      noval:	db	0
  9439                                  
  9440                                  result_val: 	;label	byte
  9441 00001F91 00                      	db	0		; type returned
  9442                                  result_val_itag:
  9443 00001F92 00                      	db	0		; item tag returned
  9444                                  result_val_swoff:
  9445 00001F93 0000                    	dw	0		; es:offset of the switch defined
  9446                                  rv_byte:	;label	byte
  9447 00001F95 00000000                rv_dword: dd	0		; value if number,or seg:offset to string.
  9448                                  
  9449                                  ;-----------------------------------------------------------------------
  9450                                  
  9451                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9452                                  	; (SYSINIT:1F99h)
  9453                                  
  9454                                  ; break = [ on | off ]
  9455                                  
  9456                                  ;brk_parms p_parms  <brk_parmsx>
  9457                                  brk_parms:
  9458 00001F99 [9E1F]                  	dw	brk_parmsx
  9459 00001F9B 01                      	db	1	; an extra delimiter list
  9460 00001F9C 01                      	db	1	; length is 1
  9461 00001F9D 3B                      	db	';'	; delimiter
  9462                                  
  9463                                  brk_parmsx:
  9464 00001F9E 0101[A41F]              	dw	101h,brk_pos	; min,max = 1 positional
  9465 00001FA2 00                      	db	0		; no switches
  9466 00001FA3 00                      	db	0		; no keywords
  9467                                  
  9468                                  ;brk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
  9469                                  brk_pos:
  9470 00001FA4 0020                    	dw	2000h
  9471 00001FA6 0000                    	dw	0
  9472 00001FA8 [911F]                  	dw	result_val	
  9473 00001FAA [AD1F]                  	dw	on_off_string
  9474 00001FAC 00                      	db	0
  9475                                  
  9476                                  on_off_string:	;label	byte
  9477 00001FAD 03                      	db	3		; signals that there is a string choice
  9478 00001FAE 00                      	db	0		; no range definition
  9479 00001FAF 00                      	db	0		; no numeric values choice
  9480 00001FB0 02                      	db	2		; 2 strings for choice
  9481 00001FB1 01                      	db	1		; the 1st string tag
  9482 00001FB2 [B71F]                  	dw	on_string
  9483 00001FB4 02                      	db	2		; the 2nd string tag
  9484 00001FB5 [BA1F]                  	dw	off_string
  9485                                  
  9486                                  on_string:
  9487 00001FB7 4F4E00                  	db	"ON",0
  9488                                  off_string:
  9489 00001FBA 4F464600                	db	"OFF",0
  9490                                  
  9491                                  p_ctrl_break:
  9492 00001FBE 00                      	db	0	; local variable
  9493                                  
  9494                                  ;-----------------------------------------------------------------------
  9495                                  
  9496                                  	; 27/10/2022
  9497                                  
  9498                                  ; country = n {m {path}}
  9499                                  ; or
  9500                                  ; country = n,,path
  9501                                  
  9502                                  ;cntry_parms p_parms <cntry_parmsx>
  9503                                  cntry_parms:
  9504 00001FBF [C41F]                  	dw	cntry_parmsx
  9505 00001FC1 01                      	db	1
  9506 00001FC2 01                      	db	1
  9507 00001FC3 3B                      	db	';'
  9508                                  	
  9509                                  cntry_parmsx:
  9510 00001FC4 0103[CE1F][E21F]-       	dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
  9510 00001FCA [EB1F]             
  9511 00001FCC 00                      	db	0		; no switches
  9512 00001FCD 00                      	db	0		; no keywords
  9513                                  
  9514                                  ;cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
  9515                                  cntry_pos1:
  9516 00001FCE 0080                    	dw	8000h
  9517 00001FD0 0000                    	dw	0
  9518 00001FD2 [911F]                  	dw	result_val	
  9519 00001FD4 [D71F]                  	dw	cc_range
  9520 00001FD6 00                      	db	0
  9521                                  
  9522                                  ;cc_range p_range <,,,1,999>
  9523                                  cc_range:
  9524 00001FD7 01                      	db	1
  9525 00001FD8 01                      	db	1
  9526 00001FD9 01                      	db	1
  9527 00001FDA 01000000                	dd	1
  9528 00001FDE E7030000                	dd	999
  9529                                  
  9530                                  ;cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
  9531                                  cntry_pos2:
  9532 00001FE2 0180                    	dw	8001h
  9533 00001FE4 0000                    	dw	0
  9534 00001FE6 [911F]                  	dw	result_val	
  9535 00001FE8 [D71F]                  	dw	cc_range
  9536 00001FEA 00                      	db	0
  9537                                  
  9538                                  ;cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec
  9539                                  cntry_pos3:
  9540 00001FEB 0102                    	dw	201h
  9541 00001FED 0000                    	dw	0
  9542 00001FEF [911F]                  	dw	result_val	
  9543 00001FF1 [901F]                  	dw	noval
  9544 00001FF3 00                      	db	0	
  9545                                  
  9546                                  p_cntry_code:
  9547 00001FF4 0000                    	dw	0	; local variable
  9548                                  p_code_page:
  9549 00001FF6 0000                    	dw	0	; local variable
  9550                                  
  9551                                  ;-----------------------------------------------------------------------
  9552                                  
  9553                                  	; 27/10/2022
  9554                                  
  9555                                  ; files = n
  9556                                  
  9557                                  ;files_parms p_parms <files_parmsx>
  9558                                  files_parms:
  9559 00001FF8 [FD1F]                  	dw	files_parmsx
  9560 00001FFA 01                      	db	1
  9561 00001FFB 01                      	db	1
  9562 00001FFC 3B                      	db	';'
  9563                                  
  9564                                  files_parmsx:
  9565 00001FFD 0101[0320]              	dw	101h,files_pos	; min,max 1 positional
  9566 00002001 00                      	db	0		; no switches
  9567 00002002 00                      	db	0		; no keywords
  9568                                  
  9569                                  ;files_pos p_pos <8000h,0,result_val,files_range,0> ; numeric value
  9570                                  files_pos:
  9571 00002003 0080                    	dw	8000h
  9572 00002005 0000                    	dw	0
  9573 00002007 [911F]                  	dw	result_val	
  9574 00002009 [0C20]                  	dw	files_range
  9575 0000200B 00                      	db	0
  9576                                  
  9577                                  ;files_range p_range <,,,8,255>
  9578                                  files_range:
  9579 0000200C 01                      	db	1
  9580 0000200D 01                      	db	1
  9581 0000200E 01                      	db	1
  9582 0000200F 08000000                	dd	8
  9583 00002013 FF000000                	dd	255
  9584                                  
  9585                                  p_files:
  9586 00002017 00                      	db	0		; local variable
  9587                                  
  9588                                  ;-----------------------------------------------------------------------
  9589                                  
  9590                                  	; 27/10/2022
  9591                                  
  9592                                  ; fcbs = n,m
  9593                                  
  9594                                  ;fcbs_parms p_parms <fcbs_parmsx>
  9595                                  fcbs_parms:
  9596 00002018 [1D20]                  	dw	fcbs_parmsx
  9597 0000201A 01                      	db	1
  9598 0000201B 01                      	db	1
  9599 0000201C 3B                      	db	';'
  9600                                  
  9601                                  fcbs_parmsx:
  9602 0000201D 0102[2520][3920]        	dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
  9603 00002023 00                      	db	0		; no switches
  9604 00002024 00                      	db	0		; no keywords
  9605                                  
  9606                                  ;fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range> ; numeric value
  9607                                  fcbs_pos_1:
  9608 00002025 0080                    	dw	8000h
  9609 00002027 0000                    	dw	0
  9610 00002029 [911F]                  	dw	result_val	
  9611 0000202B [2E20]                  	dw	fcbs_range
  9612 0000202D 00                      	db	0
  9613                                  
  9614                                  ;fcbs_range p_range <,,,1,255>
  9615                                  fcbs_range:
  9616 0000202E 01                      	db	1
  9617 0000202F 01                      	db	1
  9618 00002030 01                      	db	1
  9619 00002031 01000000                	dd	1
  9620 00002035 FF000000                	dd	255
  9621                                  
  9622                                  ;fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range> ; numeric value
  9623                                  fcbs_pos_2:
  9624 00002039 0080                    	dw	8000h
  9625 0000203B 0000                    	dw	0
  9626 0000203D [911F]                  	dw	result_val	
  9627 0000203F [4220]                  	dw	fcbs_keep_range
  9628 00002041 00                      	db	0
  9629                                  
  9630                                  ;fcbs_keep_range p_range <,,,0,255>
  9631                                  fcbs_keep_range:
  9632 00002042 01                      	db	1
  9633 00002043 01                      	db	1
  9634 00002044 01                      	db	1
  9635 00002045 00000000                	dd	0
  9636 00002049 FF000000                	dd	255
  9637                                  
  9638 0000204D 00                      p_fcbs:	db	0		; local variable
  9639 0000204E 00                      p_keep:	db	0		; local variable
  9640                                  
  9641                                  ;-----------------------------------------------------------------------
  9642                                  
  9643                                  	; 27/10/2022
  9644                                  
  9645                                  ; lastdrive = x
  9646                                  
  9647                                  ;ldrv_parms p_parms <ldrv_parmsx>
  9648                                  ldrv_parms:
  9649 0000204F [5420]                  	dw	ldrv_parmsx
  9650 00002051 01                      	db	1
  9651 00002052 01                      	db	1
  9652 00002053 3B                      	db	';'
  9653                                  
  9654                                  ldrv_parmsx:
  9655 00002054 0101[5A20]              	dw	101h,ldrv_pos	; min,max = 1 positional
  9656 00002058 00                      	db	0		; no switches
  9657 00002059 00                      	db	0		; no keywords
  9658                                  
  9659                                  ;ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
  9660                                  ldrv_pos:				    ; remove colon at end
  9661 0000205A 1001                    	dw	110h
  9662 0000205C 1000                    	dw	10h
  9663 0000205E [911F]                  	dw	result_val	
  9664 00002060 [901F]                  	dw	noval
  9665 00002062 00                      	db	0
  9666                                  	
  9667 00002063 00                      p_ldrv:	db	0		; local variable
  9668                                  
  9669                                  ;-----------------------------------------------------------------------
  9670                                  
  9671                                  	; 27/10/2022
  9672                                  
  9673                                  ; stacks = n,m
  9674                                  
  9675                                  ;stks_parms p_parms <stks_parmsx>
  9676                                  stks_parms:
  9677 00002064 [6920]                  	dw	stks_parmsx
  9678 00002066 01                      	db	1
  9679 00002067 01                      	db	1
  9680 00002068 3B                      	db	';'
  9681                                  
  9682                                  stks_parmsx:
  9683 00002069 0202[7120][8520]        	dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
  9684 0000206F 00                      	db	0		; no switches
  9685 00002070 00                      	db	0		; no keywords
  9686                                  
  9687                                  ;stks_pos_1 p_pos <8000h,0,result_val,stks_range> ; numeric value
  9688                                  stks_pos_1:
  9689 00002071 0080                    	dw	8000h
  9690 00002073 0000                    	dw	0
  9691 00002075 [911F]                  	dw	result_val	
  9692 00002077 [7A20]                  	dw	stks_range
  9693 00002079 00                      	db	0
  9694                                  
  9695                                  ;stks_range p_range <,,,0,64>
  9696                                  stks_range:
  9697 0000207A 01                      	db	1
  9698 0000207B 01                      	db	1
  9699 0000207C 01                      	db	1
  9700 0000207D 00000000                	dd	0
  9701 00002081 40000000                	dd	64
  9702                                  
  9703                                  ;stks_pos_2 p_pos <8000h,0,result_val,stk_size_range> ; numeric value
  9704                                  stks_pos_2:
  9705 00002085 0080                    	dw	8000h
  9706 00002087 0000                    	dw	0
  9707 00002089 [911F]                  	dw	result_val	
  9708 0000208B [8E20]                  	dw	stk_size_range
  9709 0000208D 00                      	db	0
  9710                                  
  9711                                  ;stk_size_range p_range <,,,0,512>
  9712                                  stk_size_range:
  9713 0000208E 01                      	db	1
  9714 0000208F 01                      	db	1
  9715 00002090 01                      	db	1
  9716 00002091 00000000                	dd	0
  9717 00002095 00020000                	dd	512	
  9718                                  
  9719                                  p_stack_count:
  9720 00002099 0000                    	dw	0	; local variable
  9721                                  p_stack_size:
  9722 0000209B 0000                    	dw	0	; local variable
  9723                                  
  9724                                  ;-----------------------------------------------------------------------
  9725                                  
  9726                                  	; 27/10/2022
  9727                                  
  9728                                  ; multitrack = [ on | off ]
  9729                                  
  9730                                  ;mtrk_parms p_parms <mtrk_parmsx>
  9731                                  mtrk_parms:
  9732 0000209D [A220]                  	dw	mtrk_parmsx
  9733 0000209F 01                      	db	1
  9734 000020A0 01                      	db	1
  9735 000020A1 3B                      	db	';'
  9736                                  
  9737                                  mtrk_parmsx:
  9738 000020A2 0101[A820]              	dw	101h,mtrk_pos	; min,max = 1 positional
  9739 000020A6 00                      	db	0		; no switches
  9740 000020A7 00                      	db	0		; no keywords
  9741                                  
  9742                                  ;mtrk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
  9743                                  mtrk_pos:
  9744 000020A8 0020                    	dw	2000h
  9745 000020AA 0000                    	dw	0
  9746 000020AC [911F]                  	dw	result_val	
  9747 000020AE [AD1F]                  	dw	on_off_string
  9748 000020B0 00                      	db	0
  9749                                  
  9750 000020B1 00                      p_mtrk:	db	0		; local variable
  9751                                  
  9752                                  ;-----------------------------------------------------------------------
  9753                                  
  9754                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9755                                  	; (SYSINIT:20B2h)
  9756                                  
  9757                                  ; switches=/k
  9758                                  
  9759                                  ;swit_parms p_parms <swit_parmsx>
  9760                                  swit_parms:
  9761 000020B2 [B720]                  	dw	swit_parmsx
  9762 000020B4 01                      	db	1
  9763 000020B5 01                      	db	1
  9764 000020B6 3B                      	db	';'
  9765                                  
  9766                                  swit_parmsx:
  9767 000020B7 0000                    	dw	0		; no positionals
  9768                                  	;db	5               ; # of switches
  9769                                  	; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
  9770 000020B9 03                      	db	3
  9771 000020BA [C120]                  	dw	swit_k_ctrl	; /k control
  9772                                  	;dw	swit_n_ctrl     ; /n control (for MULTI_CONFIG only)
  9773                                  	;dw	swit_f_ctrl     ; /f control (for MULTI_CONFIG only)
  9774 000020BC [CD20]                  	dw	swit_t_ctrl     ; /t control
  9775 000020BE [D920]                  	dw	swit_w_ctrl     ; /w control
  9776 000020C0 00                      	db	0		; no keywords
  9777                                  
  9778                                  ;swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
  9779                                  swit_k_ctrl:
  9780 000020C1 00000000[911F]-         	dw	0,0,result_val,noval
  9780 000020C7 [901F]             
  9781 000020C9 01                      	db	1
  9782 000020CA 2F4B00                  swit_k:	db	'/K',0
  9783                                  
  9784                                  ; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
  9785                                  ;
  9786                                  ;;swit_n_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
  9787                                  ;swit_n_ctrl:
  9788                                  ;	dw	0,0,result_val,noval
  9789                                  ;	db	1
  9790                                  ;swit_n: db	'/N',0
  9791                                  ;
  9792                                  ;;swit_f_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
  9793                                  ;swit_f_ctrl:
  9794                                  ;	dw	0,0,result_val,noval
  9795                                  ;	db	1
  9796                                  ;swit_f: db 	'/F',0
  9797                                  
  9798                                  	; 27/10/2022
  9799                                  
  9800                                  ;swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
  9801                                  swit_t_ctrl:
  9802 000020CD 00000000[911F]-         	dw	0,0,result_val,noval
  9802 000020D3 [901F]             
  9803 000020D5 01                      	db	1
  9804 000020D6 2F5400                  swit_t:	db	'/T',0			   ;				M059
  9805                                  ;swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
  9806                                  swit_w_ctrl:
  9807 000020D9 00000000[911F]-         	dw	0,0,result_val,noval
  9807 000020DF [901F]             
  9808 000020E1 01                      	db	1
  9809 000020E2 2F5700                  swit_w:	db	'/W',0			   ;				M063
  9810                                  
  9811                                  ;   There doesn't need to be p_swit_n or p_swit_f because /N and /F are
  9812                                  ;   acted upon during MULTI_CONFIG processing; we only needed entries
  9813                                  ;   in the above table to prevent the parsing code from complaining about them
  9814                                  
  9815 000020E5 00                      p_swit_k:	db     0	; local variable
  9816 000020E6 00                      p_swit_t:	db     0	; local variable			M059
  9817 000020E7 00                      p_swit_w:	db     0	; local variable			M063
  9818                                  
  9819                                  ;-----------------------------------------------------------------------
  9820                                  
  9821                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9822                                  	; (SYSINIT:20E8h)
  9823                                  
  9824                                  ; DOS = [ high | low ]
  9825                                  
  9826                                  ;dos_parms p_parms  <dos_parmsx>
  9827                                  dos_parms:
  9828 000020E8 [ED20]                  	dw	dos_parmsx
  9829 000020EA 01                      	db	1
  9830 000020EB 01                      	db	1
  9831 000020EC 3B                      	db	';'
  9832                                  dos_parmsx:
  9833 000020ED 01                      	db	1		; min parameters
  9834 000020EE 02                      	db	2		; max parameters
  9835 000020EF [F520]                  	dw	dos_pos		; 
  9836 000020F1 [F520]                  	dw	dos_pos		; 
  9837 000020F3 00                      	db	0		; no switches
  9838 000020F4 00                      	db	0		; no keywords
  9839                                  
  9840                                  ;dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
  9841                                  ;        p_pos	<2000h,0,result_val,dos_strings> ; simple string
  9842                                  dos_pos:
  9843 000020F5 00200000[911F]-         	dw	2000h,0,result_val,dos_strings
  9843 000020FB [0721]             
  9844 000020FD 00                      	db	0
  9845 000020FE 00200000[911F]-         	dw	2000h,0,result_val,dos_strings
  9845 00002104 [0721]             
  9846 00002106 00                      	db	0	
  9847                                  
  9848                                  dos_strings:	;label	byte
  9849 00002107 03                      	db	3		; signals that there is a string choice
  9850 00002108 00                      	db	0		; no range definition
  9851 00002109 00                      	db	0		; no numeric values choice
  9852 0000210A 04                      	db	4		; 4 strings for choice
  9853 0000210B 01                      	db	1		; the 1st string tag
  9854 0000210C [1721]                  	dw	hi_string
  9855 0000210E 02                      	db	2		; the 2nd string tag
  9856 0000210F [1C21]                  	dw	lo_string
  9857 00002111 03                      	db	3
  9858 00002112 [2021]                  	dw	umb_string
  9859 00002114 04                      	db	4
  9860 00002115 [2421]                  	dw	noumb_string
  9861                                  
  9862 00002117 4849474800              hi_string:	db	"HIGH",0
  9863 0000211C 4C4F5700                lo_string:	db	"LOW",0
  9864 00002120 554D4200                umb_string:	db	"UMB",0
  9865 00002124 4E4F554D4200            noumb_string:	db	"NOUMB",0
  9866                                  
  9867 0000212A 00                      p_dos_hi:	db	0	; local variable
  9868                                  				; BUGBUG : I dont know whether PARSER uses
  9869                                  				;          this variable or not
  9870                                  
  9871                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9872                                  
  9873                                  %if 0
  9874                                  
  9875                                  ;****************************************************************** RICHID ****
  9876                                  
  9877                                  ;include	highvar.inc	; devicehigh variables (used by loadhigh also)
  9878                                  
  9879                                  ; 30/03/2019 - Retro DOS v4.0
  9880                                  ;------------------------------------------------------------------------------
  9881                                  
  9882                                  ;   Module:   HIGHVAR.INC - Data common to LOADHIGH and DEVICEHIGH, res seg
  9883                                  ;
  9884                                  ;   Date:     May 14, 1992
  9885                                  ;
  9886                                  ;******************************************************************************
  9887                                  ;
  9888                                  ;   Modification log:
  9889                                  ;
  9890                                  ;     DATE    WHO      DESCRIPTION
  9891                                  ;   --------  -------  --------------------------------------------------------
  9892                                  ;   05/14/92  t-richj  Original
  9893                                  ;   06/21/92  t-richj  Final revisions before check-in
  9894                                  ;
  9895                                  ;******************************************************************************
  9896                                  ;
  9897                                  ; There are two primary definitions which need to be made, selectively, before
  9898                                  ; this include file should be used.  These are:
  9899                                  ;    HV_Extern - If this has been defined, variables for this module will be
  9900                                  ;                declared as external.  Otherwise, variables will be declared
  9901                                  ;                public, as well as defined, here.  LoadHigh declares HV_Extern
  9902                                  ;                in stub.asm and loadhi.asm, and does not declare it in
  9903                                  ;                rdata.asm... DeviceHigh does not declare HV_Extern anywhere
  9904                                  ;                (as only one module, sysconf.asm, includes this file).
  9905                                  ;    HV_LoadHigh - This should be defined when this module is going into
  9906                                  ;                  command.com, for LoadHigh.  All of loadhi.asm, stub.asm and
  9907                                  ;                  rdata.asm define this, while io.sys' sysconf.asm does not.
  9908                                  ;
  9909                                  ;******************************************************************************
  9910                                  
  9911                                  ; To keep track of which UMBs were specified on the DH/LH command lines, and
  9912                                  ; to keep track of the minimum sizes given for each, there're two arrays kept
  9913                                  ; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  9914                                  ; big.  16 should be around 14 too many for most users, so there's no expected
  9915                                  ; space problem (it's just such a nice round number, eh?).
  9916                                  
  9917                                  MAXUMB	equ	16
  9918                                  
  9919                                  ; Memory elements owned by the system are marked as PSP address 8 in both the
  9920                                  ; USA and Japan; Japanese systems also use 9 under more bizzarre conditions.
  9921                                  
  9922                                  FreePSPOwner	equ	0	; Free MCBs all have an owner PSP address of 0
  9923                                  SystemPSPOwner	equ	8
  9924                                  ;JapanPSPOwner	equ	9
  9925                                  
  9926                                  ; for LoadHigh and DeviceHigh:
  9927                                  ;
  9928                                  ;	fInHigh - Is set to 1 during HideUMBs(), and back to zero in
  9929                                  ;	          UnHideUMBs().
  9930                                  ;	fUmbTiny - Is set to 1 iff the user has specified /S on the command-
  9931                                  ;	           line.
  9932                                  ;	SegLoad - Segment address for first UMB specified; set automatically.
  9933                                  ;	UmbLoad - The load UMB number; for example, this is 3 if the user has
  9934                                  ;	          given a command-line like "/L:3,500;4"
  9935                                  ;	UmbUsed - An array of characters, each of which is 1 iff the UMB
  9936                                  ;	          matching its index number was specified on the command-line;
  9937                                  ;	          for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  9938                                  ;	          will be set to 1.  All others will be set to 0.
  9939                                  ;	UmbSize - An array of words, each of which is interpereted as a size
  9940                                  ;	          specified by the user for a UMB (in the above example, all
  9941                                  ;	          elements would be zero save UmbSize[3], which would be 500.
  9942                                  ;	fm_umb - Set to the old UMB link-state (0x80 or 0x00)
  9943                                  ;	fm_strat - Set to the old memory-allocation strategy (0$00000???)
  9944                                  ;	fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  9945                                  ;	           for details).
  9946                                  
  9947                                  fInHigh:  db	0
  9948                                  fUmbTiny: db	0
  9949                                  SegLoad:  dw	0
  9950                                  UmbLoad:  db	0
  9951                                  UmbUsed:  times MAXUMB db 0 ; times 16 db 0  ; db 16 dup(?)
  9952                                  UmbSize:  times MAXUMB dw 0 ; times 16 dw 0  ; dw 16 dup(?)
  9953                                  fm_umb:   db	0
  9954                                  fm_strat: db	0
  9955                                  fm_argc:  db	0	
  9956                                  
  9957                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  9958                                  ; UmbLoad is set to the UMB number given.
  9959                                  
  9960                                  UNSPECIFIED	equ	-1
  9961                                  
  9962                                  %endif
  9963                                  
  9964                                  ;****************************************************************** RICHID ****
  9965                                  
  9966                                  ; 30/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSCONF.ASM)
  9967                                  ; ((MSDOS 6.21 IO.SYS -> SYNINIT:22BAh))
  9968                                  
  9969                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
  9970                                  ; (SYSINIT:212Bh)	
  9971                                  
  9972                                  		;public	DevEntry
  9973                                  
  9974 0000212B 0000                    DevSize:	dw	0	; size of the device driver being loaded(paras)
  9975 0000212D 0000                    DevLoadAddr:	dw	0	; Mem addr where the device driver is 2 b loaded
  9976 0000212F 0000                    DevLoadEnd:	dw	0	; MaxAddr to which device can be loaded
  9977 00002131 00000000                DevEntry:	dd	0	; Entry point to the device driver
  9978 00002135 00000000                DevBrkAddr:	dd	0	; Break address of the device driver
  9979                                  ; 27/10/2022 
  9980                                  ;ConvLoad:	db	0	; Use conventional (dos 5 -style) InitDevLoad?
  9981                                  ;
  9982 00002139 00                      DevUMB:		db	0	; byte indicating whether to load DDs in UMBs
  9983 0000213A 0000                    DevUMBAddr:	dw	0	; cuurent UMB used fro loading devices (paras)
  9984 0000213C 0000                    DevUMBSize:	dw	0	; Size of the current UMB being used   (paras)
  9985 0000213E 0000                    DevUMBFree:	dw	0	; Start of free are in the current UMB (paras)
  9986                                  ;
  9987 00002140 00000000                DevXMSAddr:	dd	0
  9988                                  ;
  9989 00002144 0000                    DevExecAddr:	dw	0	; Device load address parameter to Exec call
  9990 00002146 0000                    DevExecReloc:	dw	0	; Device load relocation factor
  9991                                  ;
  9992 00002148 00                      DeviceHi:	db	0	; Flag indicating whther the current device
  9993                                  				;  is being loaded into UMB
  9994 00002149 0000                    DevSizeOption:	dw	0	; SIZE= option
  9995                                  ;
  9996 0000214B 00                      Int12Lied:	db	0	; did we trap int 12 ?
  9997 0000214C 0000                    OldInt12Mem:	dw	0	; value in 40:13h (int 12 ram)
  9998 0000214E 50524F544D414E24        ThreeComName:	db	'PROTMAN$'	; 3Com Device name
  9999                                  ;
 10000 00002156 00                      FirstUMBLinked:	db	0
 10001 00002157 0000                    DevDOSData:	dw	0	; segment of DOS Data
 10002 00002159 00000000                DevCmdLine:	dd	0	; Current Command line
 10003 0000215D 00                      DevSavedDelim:	db	0	; The delimiter which was replaced with null
 10004                                  				; to use the file name in the command line
 10005                                  ;
 10006                                  ;	ifdef	dblspace_hooks
 10007                                  ;MagicHomeFlag:	db	0	; set non-zero when MagicDrv is final placed
 10008                                  ;	endif
 10009                                  
 10010                                  ; ===========================================================================
 10011                                  
 10012                                  ; 31/03/2019 - Retro DOS v4.0
 10013                                  
 10014                                  ; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10015                                  ; (SYSINIT:215Eh)
 10016                                  
 10017                                  ;----------------------------------------------------------------------------
 10018                                  ;
 10019                                  ; procedure : doconf
 10020                                  ;
 10021                                  ;             Config file is parsed initially with this routine. For the
 10022                                  ;             Subsequent passes 'multi_pass' entry is used .
 10023                                  ;
 10024                                  ;----------------------------------------------------------------------------
 10025                                  
 10026                                  	; 27/10/2022
 10027                                  doconf:
 10028 0000215E 0E                      	push	cs
 10029 0000215F 1F                      	pop	ds
 10030                                  
 10031 00002160 B80037                  	mov	ax,3700h
 10032                                          ;mov	ax,(CHAR_OPER<<8)	; get switch character
 10033 00002163 CD21                    	int	21h
 10034 00002165 8816[AA02]              	mov	[command_line+1],dl	; set in default command line
 10035                                  
 10036                                  ; 27/10/2022
 10037                                  ;;ifdef	MULTI_CONFIG
 10038                                  ;	;mov	[command_line-1],dl     ; save default switchchar
 10039                                  ;	mov	[def_swchr],dl ; 31/03/2019 
 10040                                  ;;endif	;MULTI_CONFIG
 10041                                  
 10042 00002169 BA[1438]                	mov	dx,config ;'\CONFIG.SYS' ;now pointing to file description
 10043 0000216C B8003D                  	mov	ax,3D00h
 10044                                  	;mov	ax,OPEN<<8		;open file "config.sys"
 10045 0000216F F9                      	stc				;in case of int 24
 10046 00002170 CD21                    	int	21h			;function request
 10047 00002172 7306                    	jnc	short noprob		; brif opened okay
 10048                                  
 10049                                  ; 27/10/2022
 10050                                  ;;ifdef	MULTI_CONFIG
 10051                                  ;      	call	kbd_read		; we still want to give the guy
 10052                                  ;					; a chance to select clean boot!
 10053                                  ;;endif					; (ie, no autoexec.bat processing)
 10054 00002174 C606[4903]0B            	mov	byte [multi_pass_id],11	; set it to unreasonable number
 10055 00002179 C3                      	retn
 10056                                  noprob: 				;get file size (note < 64k!!)
 10057 0000217A 89C3                    	mov	bx,ax  ; File handle
 10058 0000217C 31C9                    	xor	cx,cx
 10059 0000217E 31D2                    	xor	dx,dx
 10060                                  	;mov	ax,4202h
 10061 00002180 B80242                  	mov	ax,(LSEEK<<8)|2
 10062 00002183 CD21                    	int	21h
 10063 00002185 A3[D203]                	mov	[count],ax
 10064                                  
 10065 00002188 31D2                    	xor	dx,dx
 10066                                  	;mov	ax,4200h
 10067 0000218A B80042                  	mov	ax,LSEEK<<8		;reset pointer to beginning of file
 10068 0000218D CD21                    	int	21h
 10069                                  
 10070                                  	;mov	dx,[ALLOCLIM]		;use current alloclim value
 10071                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10072 0000218F 8B16[A102]              	mov	dx,[top_of_cdss] 
 10073                                  
 10074 00002193 A1[D203]                	mov	ax,[count]
 10075 00002196 A3[4C03]                	mov	[config_size],ax	;save the size of config.sys file.
 10076 00002199 E8B4EF                  	call	ParaRound
 10077 0000219C 29C2                    	sub	dx,ax
 10078                                  
 10079                                  ; 27/10/2022
 10080                                  ;;ifdef	MULTI_CONFIG
 10081                                  ;;
 10082                                  ;;  The size of the CONFIG.SYS workspace (for recreating the in-memory
 10083                                  ;;  CONFIG.SYS image, and later for building the initial environment) need
 10084                                  ;;  not be any larger than CONFIG.SYS itself, EXCEPT for the fact that
 10085                                  ;;  we (may) add a variable to the environment that does not explicity appear
 10086                                  ;;  in CONFIG.SYS, and that variable is CONFIG (as in CONFIG=COMMON).
 10087                                  ;;  The default setting for CONFIG cannot result in more than 1 paragraph
 10088                                  ;;  of extra space, so here we account for it (the worst case of course is
 10089                                  ;;  when CONFIG.SYS is some very small size, like 0 -JTP)
 10090                                  ;;
 10091                                  ;       dec     dx                      ;reserve 1 additional paragraph
 10092                                  ;       mov     [config_wrkseg],dx      ;this is the segment to be used for
 10093                                  ;       sub     dx,ax                   ;rebuilding the config.sys memory image
 10094                                  ;;endif	;MULTI_CONFIG
 10095                                  
 10096 0000219E 83EA11                  	sub	dx,11h			;room for header
 10097                                  	
 10098                                  	;mov	[ALLOCLIM],dx		; config starts here. new alloclim value.
 10099                                  	;mov	[CONFBOT],dx
 10100                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10101 000021A1 8916[A102]              	mov	[top_of_cdss],dx
 10102 000021A5 E88DEA                  	call    TempCDS 
 10103 000021A8 2E8B16[A102]            	mov	dx,[cs:top_of_cdss]
 10104                                   
 10105 000021AD 8EDA                    	mov	ds,dx
 10106 000021AF 8EC2                    	mov	es,dx
 10107                                  
 10108 000021B1 31D2                    	xor	dx,dx
 10109 000021B3 2E8B0E[D203]            	mov	cx,[cs:count]
 10110 000021B8 B43F                    	mov	ah,3Fh
 10111                                  	;mov	ah,READ  ; 3Fh
 10112 000021BA F9                      	stc				;in case of int 24
 10113 000021BB CD21                    	int	21h			;function request
 10114 000021BD 9C                      	pushf
 10115                                  
 10116                                  ; find the eof mark in the file. if present,then trim length.
 10117                                  
 10118 000021BE 50                      	push	ax
 10119 000021BF 57                      	push	di
 10120 000021C0 51                      	push	cx
 10121 000021C1 B01A                    	mov	al,1Ah			; eof mark
 10122 000021C3 89D7                    	mov	di,dx			; point to buffer
 10123 000021C5 E305                    	jcxz	puteol			; no chars
 10124 000021C7 F2AE                    	repnz	scasb			; find end
 10125 000021C9 7501                    	jnz	short puteol		; none found and count exhausted
 10126                                  
 10127                                  ; we found a 1a. back up
 10128                                  
 10129 000021CB 4F                      	dec	di			; backup past 1Ah
 10130                                  
 10131                                  ;  just for the halibut,stick in an extra eol
 10132                                  
 10133                                  puteol:
 10134 000021CC B00D                    	mov	al,cr ; 0Dh
 10135 000021CE AA                      	stosb
 10136 000021CF B00A                    	mov	al,lf  ;0Ah
 10137 000021D1 AA                      	stosb
 10138 000021D2 29D7                    	sub	di,dx			; difference moved
 10139                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10140 000021D4 2E893E[D203]            	mov	[cs:count],di		; new count
 10141                                  	
 10142                                  	; 31/03/2019 - Retro DOS v4.0
 10143                                  	;push	cs
 10144                                  	;pop	ds
 10145                                  
 10146                                  	;mov	[count],di		; new count
 10147                                  
 10148 000021D9 59                      	pop	cx
 10149 000021DA 5F                      	pop	di
 10150 000021DB 58                      	pop	ax
 10151                                  
 10152                                  	; 27/10/2022
 10153 000021DC 0E                      	push	cs
 10154 000021DD 1F                      	pop	ds
 10155                                  
 10156 000021DE 50                      	push	ax
 10157                                  	;mov	ah,CLOSE
 10158 000021DF B43E                    	mov	ah,3Eh
 10159 000021E1 CD21                    	int	21h
 10160 000021E3 58                      	pop	ax
 10161 000021E4 9D                      	popf
 10162 000021E5 7204                    	jc	short conferr 		;if not we've got a problem
 10163 000021E7 39C1                    	cmp	cx,ax
 10164 000021E9 742C                    	jz	short getcom		;couldn't read the file
 10165                                  
 10166                                  conferr:
 10167 000021EB BA[1438]                	mov	dx,config		;want to print config error
 10168 000021EE E84015                  	call	badfil
 10169                                  endconv:
 10170 000021F1 C3                      	retn
 10171                                  
 10172                                  ;----------------------------------------------------------------------------
 10173                                  ;
 10174                                  ; entry : multi_pass
 10175                                  ;
 10176                                  ;             called to execute device=,install= commands
 10177                                  ;
 10178                                  ;----------------------------------------------------------------------------
 10179                                  
 10180                                  	; 27/10/2022
 10181                                  multi_pass:
 10182 000021F2 0E                      	push	cs
 10183 000021F3 1F                      	pop	ds
 10184                                  
 10185 000021F4 803E[4903]0A            	cmp	byte [multi_pass_id],10
 10186                                  ;jae_endconv:
 10187 000021F9 73F6                    	jae	short endconv 		; do nothing. just return.
 10188                                  
 10189                                  	;push	word [CONFBOT]
 10190                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10191 000021FB FF36[A102]              	push	word [top_of_cdss]
 10192 000021FF 07                      	pop	es			; es -> confbot
 10193                                  
 10194 00002200 8B36[D403]              	mov	si,[org_count]
 10195 00002204 8936[D203]              	mov	[count],si		; set count
 10196 00002208 31F6                    	xor	si,si ; 0
 10197 0000220A 8936[D603]                      mov     [chrptr],si		; reset chrptr
 10198 0000220E 8936[2B03]                      mov     [linecount],si		; reset linecount
 10199                                  
 10200 00002212 E83F08                  	call	getchr
 10201 00002215 EB06                    	jmp	short conflp
 10202                                  
 10203                                  getcom:
 10204 00002217 E81A10                          call    organize                ; organize the file
 10205 0000221A E83708                  	call	getchr
 10206                                  
 10207 0000221D 72D2                    conflp: jc	short endconv
 10208                                  
 10209 0000221F FF06[2B03]                      inc     word [linecount]	; increase linecount
 10210                                  
 10211 00002223 C606[5716]00            	mov	byte [multdeviceflag],0	; reset multdeviceflag.
 10212 00002228 C606[5A16]00            	mov	byte [setdevmarkflag],0	; reset setdevmarkflag.
 10213 0000222D 3C0A                    	cmp	al,lf			; linefeed?
 10214 0000222F 7418                    	je	short blank_line	;  then ignore this line.
 10215                                  
 10216                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10217                                  %if 0
 10218                                  
 10219                                  ;ifdef	MULTI_CONFIG
 10220                                  
 10221                                  ;   If this is a genuine CONFIG.SYS command, then there should be a line
 10222                                  ;   number immediately following it....
 10223                                  
 10224                                          mov     [config_cmd],al         ; save original command code
 10225                                  	;and	al,NOT CONFIG_OPTION_QUERY
 10226                                  	and	al,~CONFIG_OPTION_QUERY ; and al,7Fh
 10227                                          cmp     byte [config_multi],0	; is this a multi-config config.sys?
 10228                                          je      short not_final		; no, line number is not embedded
 10229                                  
 10230                                          push    ax                      ;
 10231                                          call    getchr                  ; ignore end-of-image errors,
 10232                                          mov     ah,al                   ; because if there's an error
 10233                                          call    getchr                  ; fetching the line number that's
 10234                                          xchg    al,ah                   ; supposed to be there, the next
 10235                                          mov     [linecount],ax          ; getchr call will get the same error
 10236                                          pop     ax
 10237                                  ;
 10238                                  ;   HACK: when 4DOS.COM is the shell and it doesn't have an environment from
 10239                                  ;   which to obtain its original program name, it grovels through all of
 10240                                  ;   memory to find the filename that was used to exec it; it wants to find
 10241                                  ;   the SHELL= line in the in-memory copy of CONFIG.SYS, and it knows that
 10242                                  ;   sysinit converts the SHELL= keyword to an 'S', so it expects to find an 'S'
 10243                                  ;   immediately before the filename, but since we are now storing line # info
 10244                                  ;   in the config.sys memory image, 4DOS fails to find the 'S' in the right
 10245                                  ;   spot.
 10246                                  ;
 10247                                  ;   So, on the final pass of CONFIG.SYS, copy the command code (eg, 'S')
 10248                                  ;   over the line number info, since we no longer need that info anyway. This
 10249                                  ;   relies on the fact that getchr leaves ES:SI pointing to the last byte
 10250                                  ;   retrieved.
 10251                                  ;
 10252                                          cmp     byte [multi_pass_id],2	; final pass?
 10253                                          jb	short not_final		; no
 10254                                         ;test    word [install_flag],have_install_cmd
 10255                                  	test    byte [install_flag],have_install_cmd ; 1
 10256                                          jz	short final		; no install cmds, so yes it is
 10257                                          cmp     byte [multi_pass_id],3	; final pass?
 10258                                          jb	short not_final		; no
 10259                                  final:                                  ;
 10260                                  	mov	[es:si],al		; save backward-compatible command code
 10261                                  not_final:                              ;
 10262                                  ;endif
 10263                                  
 10264                                  %endif
 10265                                  
 10266 00002231 88C4                    	mov	ah,al
 10267 00002233 E81E08                  	call	getchr
 10268 00002236 7318                    	jnc	short tryi
 10269                                  
 10270 00002238 803E[4903]02            	cmp	byte [multi_pass_id],2
 10271                                  	;jae	short jae_endconv	; do not show badop again for multi_pass.
 10272                                  	; 27/10/2022
 10273 0000223D 73B2                    	jnb	short endconv	
 10274 0000223F E9DA07                  	jmp	badop
 10275                                  
 10276 00002242 0E                      coff:	push	cs
 10277 00002243 1F                      	pop	ds
 10278 00002244 E82412                  	call	newline
 10279 00002247 EBD4                    	jmp	short conflp	; 13/05/2019
 10280                                  
 10281                                  blank_line:
 10282 00002249 E80808                  	call	getchr
 10283 0000224C EBCF                    	jmp	short conflp
 10284                                  
 10285                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10286                                  coff_p:
 10287 0000224E 0E                      	push	cs
 10288 0000224F 1F                      	pop	ds
 10289                                  
 10290                                  ;to handle install= commands,we are going to use multi-pass.
 10291                                  ;the first pass handles the other commands and only set install_flag when
 10292                                  ;it finds any install command. the second pass will only handle the
 10293                                  ;install= command.
 10294                                  
 10295                                  ;------------------------------------------------------------------------------
 10296                                  ;install command
 10297                                  ;------------------------------------------------------------------------------
 10298                                  
 10299                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10300                                  	; (SYSINIT:2250h)
 10301                                  
 10302                                  tryi:
 10303 00002250 803E[4903]00            	cmp	byte [multi_pass_id],0	; the initial pass for DOS=HI
 10304 00002255 7503                    	jne	short not_init_pass
 10305 00002257 E93201                  	jmp	multi_try_doshi
 10306                                  not_init_pass:
 10307                                  
 10308 0000225A 803E[4903]02            	cmp	byte [multi_pass_id],2	; the second pass was for ifs=
 10309                                          ;je	short multi_pass_coff2	; now it is NOPs
 10310                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10311 0000225F 7439                    	je	short multi_pass_coff	
 10312                                  					; This pass can be made use of if
 10313                                  					; we want do some config.sys process
 10314                                  					; after device drivers are loaded
 10315                                  					; and before install= commands
 10316                                  					; are processed
 10317                                  
 10318 00002261 803E[4903]03            	cmp	byte [multi_pass_id],3	; the third pass for install= ?
 10319 00002266 7411                    	je	short multi_try_i
 10320 00002268 80FC48                          cmp     ah, CONFIG_DOS  ; 'H'
 10321                                  	;je	short multi_pass_coff2
 10322                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10323 0000226B 742D                    	je	short multi_pass_coff	
 10324                                  
 10325                                  ;       make note of any INSTALL= or INSTALLHIGH= commands we find,
 10326                                  ;       but don't process them now.        
 10327                                          
 10328 0000226D 80FC49                          cmp     ah,CONFIG_INSTALL ; 'I'	; install= command?
 10329                                  	;jne	short precheck_installhigh ; the first pass is for normal operation.
 10330                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10331 00002270 752A                    	jne	short tryb	
 10332                                  	
 10333                                  	;or	word [install_flag],have_install_cmd ; set the flag
 10334 00002272 800E[4A03]01            	or	byte [install_flag],have_install_cmd ; 1
 10335                                  multi_pass_coff2:
 10336 00002277 EBC9                    	jmp	short coff ; 13/05/2019	; and handles the next command
 10337                                  
 10338                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10339                                  ;precheck_installhigh:
 10340                                  ;       cmp     ah,CONFIG_INSTALLHIGH ; 'W' ; signifier for INSTALLHIGH
 10341                                  ;       jne     short tryb		; carry on with normal processing
 10342                                  ;	;or	word [install_flag],have_install_cmd
 10343                                  ;	or	byte [install_flag],have_install_cmd ; 1
 10344                                  ;       jmp	short coff
 10345                                  
 10346                                  multi_try_i:
 10347 00002279 80FC49                          cmp     ah, CONFIG_INSTALL ; 'I' ; install= command?
 10348                                  	;jne	short multi_try_n	; no, check for installhigh
 10349                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10350 0000227C 7505                    	jne	short multi_pass_filter
 10351                                  
 10352                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10353                                  ;;ifdef	MULTI_CONFIG
 10354                                  ;       call    query_user              ; query the user if config_cmd
 10355                                  ;       jc	short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
 10356                                  ;;endif
 10357                                  
 10358 0000227E E84EEE                  	call	do_install_exec 	;install it.
 10359 00002281 EBBF                    	jmp	short coff		;to handle next install= command.
 10360                                  
 10361                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10362                                  %if 0
 10363                                  
 10364                                  multi_try_n:
 10365                                          cmp     ah,CONFIG_INSTALLHIGH   ; installhigh= command?
 10366                                          jne	short multi_pass_filter	; no. ignore this.
 10367                                  ;ifdef	MULTI_CONFIG
 10368                                          call    query_user              ; query the user if config_cmd
 10369                                          jc      short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
 10370                                  ;endif
 10371                                  
 10372                                  ;       The memory environment is in its normal DOS state, so do
 10373                                  ;       the standard calls to set the alloc strategy for loading high
 10374                                  
 10375                                  	mov	ax,(ALLOCOPER<<8)|0 ; 5800h
 10376                                  	int	21h			;get alloc strategy
 10377                                  	mov	bx,ax
 10378                                          push    bx                      ; save for the return
 10379                                  
 10380                                          or	bx,HIGH_FIRST  ; 80h	;set alloc to HighFirst
 10381                                  	mov	ax,(ALLOCOPER<<8)|1 ; 5801h
 10382                                  	int	21h			;set alloc strategy
 10383                                  
 10384                                  	mov     ax,(ALLOCOPER<<8)|2 ; 5802h
 10385                                          int     21h                     ; get link state
 10386                                          xor     ah,ah                   ; clear top byte
 10387                                          push    ax                      ; save for return
 10388                                  
 10389                                          mov	ax,(ALLOCOPER<<8)|3 ; 5803h
 10390                                  	mov	bx,1
 10391                                  	int	21h			;link in UMBs
 10392                                  
 10393                                  	call	do_install_exec 	;install it.
 10394                                  
 10395                                          mov     ax,(ALLOCOPER<<8)|3
 10396                                          pop     bx                      ; recover original link state
 10397                                          int     21h
 10398                                          pop     bx                      ; recover original alloc strategy
 10399                                          mov     ax,(ALLOCOPER<<8)|1
 10400                                          int     21h
 10401                                  
 10402                                  	jmp	coff			;to handle next install= command.
 10403                                  
 10404                                  %endif
 10405                                  
 10406                                  multi_pass_filter:
 10407 00002283 80FC59                          cmp     ah,CONFIG_COMMENT ; 'Y' ; comment?
 10408 00002286 740A                    	je	short multi_pass_adjust
 10409 00002288 80FC5A                          cmp     ah,CONFIG_UNKNOWN ; 'Z' ; bad command?
 10410 0000228B 7405                    	je	short multi_pass_adjust
 10411 0000228D 80FC30                          cmp     ah,CONFIG_REM  ; '0'   ; rem?
 10412 00002290 7508                    	jne	short multi_pass_coff 	; ignore the rest of the commands.
 10413                                  
 10414                                  multi_pass_adjust:			; these commands need to
 10415 00002292 FF0E[D603]              	dec	word [chrptr]		;  adjust chrptr,count
 10416 00002296 FF06[D203]              	inc	word [count]		;  for newline proc.
 10417                                  
 10418                                  multi_pass_coff:
 10419 0000229A EBA6                    	jmp	coff			; to handle next install= commands.
 10420                                  
 10421                                  ;------------------------------------------------------------------------------
 10422                                  ; buffer command
 10423                                  ;------------------------------------------------------------------------------
 10424                                  
 10425                                  ;******************************************************************************
 10426                                  ;									      *
 10427                                  ; function: parse the parameters of buffers= command.			      *
 10428                                  ;									      *
 10429                                  ; input :								      *
 10430                                  ;	es:si -> parameters in command line.				      *
 10431                                  ; output:								      *
 10432                                  ;	buffers set							      *
 10433                                  ;	buffer_slash_x	flag set if /x option chosen.			      *
 10434                                  ;	h_buffers set if secondary buffer cache specified.		      *
 10435                                  ;									      *
 10436                                  ; subroutines to be called:						      *
 10437                                  ;	sysinit_parse							      *
 10438                                  ; logic:								      *
 10439                                  ; {									      *
 10440                                  ;	set di points to buf_parms;  /*parse control definition*/	      *
 10441                                  ;	set dx,cx to 0; 						      *
 10442                                  ;	reset buffer_slash_x;						      *
 10443                                  ;	while (end of command line)					      *
 10444                                  ;	{ sysinit_parse;						      *
 10445                                  ;	  if (no error) then						      *
 10446                                  ;	       if (result_val._$P_synonym_ptr == slash_e) then /*not a switch *
 10447                                  ;		    buffer_slash_x = 1					      *
 10448                                  ;	       else if	 (cx == 1) then 	    /* first positional */    *
 10449                                  ;			  buffers = result_val._$P_picked_val;		      *
 10450                                  ;		    else  h_buffers = result_val._$P_picked_val; 	      *
 10451                                  ;	  else	{show error message;error exit} 			      *
 10452                                  ;	};								      *
 10453                                  ;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
 10454                                  ; };									      *
 10455                                  ;									      *
 10456                                  ;******************************************************************************
 10457                                  
 10458                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10459                                  	; (SYSINIT:229Ch)
 10460                                  
 10461                                  tryb:
 10462 0000229C 80FC42                          cmp     ah,CONFIG_BUFFERS ; 'B'
 10463 0000229F 755E                    	jne	short tryc
 10464                                  
 10465                                  
 10466                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10467                                  ;;ifdef	MULTI_CONFIG
 10468                                  ;       call    query_user              ; query the user if config_cmd
 10469                                  ;       jc      short tryc		; has the CONFIG_OPTION_QUERY bit set
 10470                                  ;;endif
 10471                                  
 10472                                  	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10473 000022A1 C606[8F1F]00            	mov	byte [p_buffer_slash_x],0 ; 31/03/2019
 10474                                  
 10475 000022A6 BF[481F]                	mov	di,buf_parms
 10476 000022A9 31C9                    	xor	cx,cx
 10477 000022AB 89CA                    	mov	dx,cx
 10478                                  do7:
 10479 000022AD E83907                  	call	sysinit_parse
 10480 000022B0 7305                    	jnc	short if7		; parse error,
 10481 000022B2 E87307                  	call	badparm_p		;   and show messages and end the search loop.
 10482 000022B5 EB45                    	jmp	short sr7
 10483                                  if7:
 10484 000022B7 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
 10485 000022BA 741C                    	je	short en7		;  then jmp to $endloop for semantic check
 10486                                  	;cmp	word [result_val_swoff],switch_x
 10487 000022BC 813E[931F][881F]        	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],switch_x
 10488 000022C2 7502                    	jne	short if11
 10489                                  
 10490                                  ;	mov	byte [p_buffer_slash_x],1 ; set the flag M016
 10491 000022C4 EB10                    	jmp	short en11
 10492                                  if11:
 10493                                  	;mov	ax,[rv_dword]
 10494 000022C6 A1[951F]                	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
 10495 000022C9 83F901                  	cmp	cx,1
 10496 000022CC 7505                    	jnz	short if13
 10497                                  
 10498 000022CE A3[8B1F]                	mov	[p_buffers],ax
 10499 000022D1 EB03                    	jmp	short en11
 10500                                  if13:
 10501 000022D3 A3[8D1F]                	mov	[p_h_buffers],ax
 10502                                  en11:
 10503 000022D6 EBD5                    	jmp	short do7
 10504                                  en7:
 10505 000022D8 833E[8B1F]63            	cmp	word [p_buffers],99
 10506 000022DD 760B                    	jbe	short if18
 10507                                  
 10508                                  ;	cmp	byte [p_buffer_slash_x],0 ; M016
 10509                                  ;	jne	short if18
 10510                                  
 10511 000022DF E84607                  	call	badparm_p
 10512 000022E2 C706[8D1F]0000          	mov	word [p_h_buffers],0
 10513 000022E8 EB12                    	jmp	short sr7
 10514                                  if18:
 10515 000022EA A1[8B1F]                	mov	ax,[p_buffers]	; we don't have any problem.
 10516 000022ED A3[9702]                	mov	[buffers],ax	; now,let's set it really.
 10517                                  
 10518 000022F0 A1[8D1F]                	mov	ax,[p_h_buffers]
 10519 000022F3 A3[9902]                	mov	[h_buffers],ax
 10520                                  
 10521                                  ;	mov	al,[p_buffer_slash_x]	; M016
 10522                                  ;	mov	[buffer_slash_x],al
 10523                                  
 10524 000022F6 A1[2B03]                	mov	ax,[linecount]
 10525 000022F9 A3[3503]                	mov	[buffer_linenum],ax ; save the line number for the future use.
 10526                                  sr7:
 10527 000022FC E943FF                  	jmp	coff
 10528                                  
 10529                                  ;------------------------------------------------------------------------------
 10530                                  ; break command
 10531                                  ;------------------------------------------------------------------------------
 10532                                  
 10533                                  ;****************************************************************************
 10534                                  ;									    *
 10535                                  ; function: parse the parameters of break = command.			    *
 10536                                  ;									    *
 10537                                  ; input :								    *
 10538                                  ;	es:si -> parameters in command line.				    *
 10539                                  ; output:								    *
 10540                                  ;	turn the control-c check on or off.				    *
 10541                                  ;									    *
 10542                                  ; subroutines to be called:						    *
 10543                                  ;	sysinit_parse							    *
 10544                                  ; logic:								    *
 10545                                  ; {									    *
 10546                                  ;	set di to brk_parms;						    *
 10547                                  ;	set dx,cx to 0; 						    *
 10548                                  ;	while (end of command line)					    *
 10549                                  ;	{ sysinit_parse;						    *
 10550                                  ;	  if (no error) then						    *
 10551                                  ;	       if (result_val._$P_item_tag == 1) then	  /*on		 */ *
 10552                                  ;		   set p_ctrl_break,on;					    *
 10553                                  ;	       else					  /*off 	 */ *
 10554                                  ;		   set p_ctrl_break,off;				    *
 10555                                  ;	  else {show message;error_exit};				    *
 10556                                  ;	};								    *
 10557                                  ;	if (no error) then						    *
 10558                                  ;	   dos function call to set ctrl_break check according to	    *
 10559                                  ; };									    *
 10560                                  ;									    *
 10561                                  ;****************************************************************************
 10562                                  
 10563                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10564                                  	; (SYSINIT:22FFh)
 10565                                  
 10566                                  tryc:
 10567 000022FF 80FC43                          cmp     ah,CONFIG_BREAK ; 'C'
 10568 00002302 7538                    	jne	short trym
 10569                                  
 10570                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10571                                  ;;ifdef MULTI_CONFIG
 10572                                  ;       call    query_user              ; query the user if config_cmd
 10573                                  ;       jc	short trym		; has the CONFIG_OPTION_QUERY bit set
 10574                                  ;;endif
 10575 00002304 BF[991F]                	mov	di,brk_parms
 10576 00002307 31C9                    	xor	cx,cx
 10577 00002309 89CA                    	mov	dx,cx
 10578                                  do22:
 10579 0000230B E8DB06                  	call	sysinit_parse
 10580 0000230E 7305                    	jnc	short if22		; parse error
 10581 00002310 E81507                  	call	badparm_p		;  show message and end the search loop.
 10582 00002313 EB24                    	jmp	short sr22
 10583                                  if22:
 10584 00002315 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 10585 00002318 7415                    	je	short en22		; then end the $endloop
 10586                                  
 10587                                  	;cmp	byte [result_val_itag],1
 10588 0000231A 803E[921F]01            	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
 10589 0000231F 7507                    	jne	short if26
 10590                                  
 10591 00002321 C606[BE1F]01            	mov	byte [p_ctrl_break],1	; turn it on
 10592 00002326 EB05                    	jmp	short en26
 10593                                  if26:
 10594 00002328 C606[BE1F]00            	mov	byte [p_ctrl_break],0	; turn it off
 10595                                  en26:
 10596 0000232D EBDC                    	jmp	short do22		; we actually set the ctrl break
 10597                                  en22:
 10598 0000232F B433                    	mov	ah,SET_CTRL_C_TRAPPING ; if we don't have any parse error.
 10599 00002331 B001                    	mov	al,1
 10600 00002333 8A16[BE1F]              	mov	dl,[p_ctrl_break]
 10601 00002337 CD21                    	int	21h
 10602                                  sr22:
 10603 00002339 E906FF                  	jmp	coff
 10604                                  
 10605                                  ;------------------------------------------------------------------------------
 10606                                  ; multitrack command
 10607                                  ;------------------------------------------------------------------------------
 10608                                  
 10609                                  ;******************************************************************************
 10610                                  ;									      *
 10611                                  ; function: parse the parameters of multitrack= command.		      *
 10612                                  ;									      *
 10613                                  ; input :								      *
 10614                                  ;	es:si -> parameters in command line.				      *
 10615                                  ; output:								      *
 10616                                  ;	turn multrk_flag on or off.					      *
 10617                                  ;									      *
 10618                                  ; subroutines to be called:						      *
 10619                                  ;	sysinit_parse							      *
 10620                                  ; logic:								      *
 10621                                  ; {									      *
 10622                                  ;	set di to brk_parms;						      *
 10623                                  ;	set dx,cx to 0; 						      *
 10624                                  ;	while (end of command line)					      *
 10625                                  ;	{ sysinit_parse;						      *
 10626                                  ;	  if (no error) then						      *
 10627                                  ;	       if (result_val._$P_item_tag == 1) then	  /*on		 */   *
 10628                                  ;		   set p_mtrk,on;					      *
 10629                                  ;	       else					  /*off 	 */   *
 10630                                  ;		   set p_mtrk,off;					      *
 10631                                  ;	  else {show message;error_exit};				      *
 10632                                  ;	};								      *
 10633                                  ;	if (no error) then						      *
 10634                                  ;	   dos function call to set multrk_flag according to p_mtrk.	      *
 10635                                  ;									      *
 10636                                  ; };									      *
 10637                                  ;									      *
 10638                                  ;******************************************************************************
 10639                                  
 10640                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10641                                  
 10642                                  trym:
 10643 0000233C 80FC4D                          cmp     ah,CONFIG_MULTITRACK  ; 'M'
 10644 0000233F 7571                    	jne	short tryu
 10645                                  
 10646                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10647                                  ;;ifdef	MULTI_CONFIG
 10648                                  ;       call    query_user      ; query the user if config_cmd
 10649                                  ;       jc      short tryu	; has the CONFIG_OPTION_QUERY bit set
 10650                                  ;;endif
 10651                                  
 10652 00002341 BF[9D20]                	mov	di,mtrk_parms
 10653 00002344 31C9                    	xor	cx,cx
 10654 00002346 89CA                    	mov	dx,cx
 10655                                  do31:
 10656 00002348 E89E06                  	call	sysinit_parse
 10657 0000234B 7305                    	jnc	short if31	; parse error
 10658 0000234D E8D806                  	call	badparm_p	;  show message and end the search loop.
 10659 00002350 EB37                    	jmp	short sr31
 10660                                  if31:
 10661 00002352 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 10662 00002355 7415                    	je	short en31	; then end the $endloop
 10663                                  
 10664                                  	;cmp	byte [result_val_itag],1
 10665 00002357 803E[921F]01            	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
 10666 0000235C 7507                    	jne	short if35
 10667                                  
 10668 0000235E C606[B120]01            	mov	byte [p_mtrk],1	; turn it on temporarily.
 10669 00002363 EB05                    	jmp	short en35
 10670                                  if35:
 10671 00002365 C606[B120]00            	mov	byte [p_mtrk],0	; turn it off temporarily.
 10672                                  en35:
 10673 0000236A EBDC                    	jmp	short do31	; we actually set the multrk_flag here
 10674                                  en31:
 10675 0000236C 1E                      	push	ds
 10676                                  	;;mov	ax,Bios_Data ; 70h
 10677                                  	;mov	ax,KERNEL_SEGMENT ; 70h
 10678                                  	; 21/10/2022
 10679 0000236D B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 10680 00002370 8ED8                    	mov	ds,ax
 10681                                  
 10682 00002372 2E803E[B120]00          	cmp	byte [cs:p_mtrk],0
 10683 00002378 7508                    	jne	short if39
 10684                                  
 10685 0000237A C7062F050100            	mov	word [multrk_flag],multrk_off2	; 0001h
 10686 00002380 EB06                    	jmp	short en39
 10687                                  if39:
 10688 00002382 C7062F058000            	mov	word [multrk_flag],multrk_on	; 0080h
 10689                                  en39:
 10690 00002388 1F                      	pop	ds
 10691                                  sr31:
 10692 00002389 E9B6FE                  	jmp	coff
 10693                                  
 10694                                  ;----------------------------------------------------------------------------
 10695                                  ; DOS=HIGH/LOW command
 10696                                  ;----------------------------------------------------------------------------
 10697                                  
 10698                                  	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10699                                  
 10700                                  multi_try_doshi:
 10701 0000238C 80FC48                          cmp     ah,CONFIG_DOS ; 'H'
 10702 0000238F 7403                    	je	short it_is_h
 10703                                  skip_it:
 10704 00002391 E9EFFE                  	jmp	multi_pass_filter
 10705                                  it_is_h:				; M003 - removed initing DevUMB
 10706                                  					;	 & runhigh
 10707                                  ; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10708                                  ;;ifdef	MULTI_CONFIG
 10709                                  ;       call    query_user              ; query the user if config_cmd
 10710                                  ;       jc      short skip_it		; has the CONFIG_OPTION_QUERY bit set
 10711                                  ;;endif
 10712 00002394 BF[E820]                	mov	di,dos_parms
 10713 00002397 31C9                    	xor	cx,cx
 10714 00002399 89CA                    	mov	dx,cx
 10715                                  h_do_parse:
 10716 0000239B E84B06                  	call	sysinit_parse
 10717 0000239E 7305                    	jnc	short h_parse_ok	; parse error
 10718                                  h_badparm:
 10719 000023A0 E88506                  	call	badparm_p		; show message and end the search loop.
 10720 000023A3 EB0A                    	jmp	short h_end
 10721                                  h_parse_ok:
 10722 000023A5 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 10723 000023A8 7405                    	je	short h_end		; then end the $endloop
 10724 000023AA E80807                  	call	ProcDOS
 10725 000023AD EBEC                    	jmp	short h_do_parse
 10726                                  h_end:
 10727 000023AF E990FE                  	jmp	coff
 10728                                  
 10729                                  ;-----------------------------------------------------------------------------
 10730                                  ; devicehigh command
 10731                                  ;-----------------------------------------------------------------------------
 10732                                  
 10733                                  	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10734                                  	
 10735                                  tryu:
 10736 000023B2 80FC55                          cmp     ah,CONFIG_DEVICEHIGH ; 'U'
 10737 000023B5 754A                    	jne	short tryd
 10738                                  
 10739                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10740                                  ;;ifdef	MULTI_CONFIG
 10741                                  ;       call    query_user              ; query the user if config_cmd
 10742                                  ;       jc	short tryd		; has the CONFIG_OPTION_QUERY bit set
 10743                                  ;;endif
 10744                                  
 10745                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10746                                  ;	call	InitVar
 10747                                  ;	call	ParseSize		; process the size= option
 10748                                  ;	;jnc	short tryu_0
 10749                                  	
 10750                                  	;jc	short tryu_1 ; 31/03/2019 - Retro DOS v4.0
 10751                                  
 10752                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10753 000023B7 2E8936[5D16]            	mov	[cs:badparm_off], si	; stash it there in case of an error
 10754 000023BC 2E8C06[5F16]            	mov	[cs:badparm_seg], es
 10755 000023C1 E89609                  	call	ParseSize
 10756 000023C4 7306                    	jnc	short tryu_2	; 28/10/2022
 10757 000023C6 E85F06                  	call	badparm_p
 10758 000023C9 E976FE                  	jmp	coff
 10759                                  
 10760                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10761                                  ;tryu_0:
 10762                                  ;	mov	ax,[cs:DevSizeOption]
 10763                                  ;	or	ax,ax
 10764                                  ;	jnz	short tryu_2
 10765                                  ;
 10766                                  ;	call	ParseVar
 10767                                  ;	jnc	short tryu_2
 10768                                  ;tryu_1:
 10769                                  ;	mov	[cs:badparm_off], si	; If ParseVar up there failed, then
 10770                                  ;	mov	[cs:badparm_seg], es	; ES:SI points to its problem area...
 10771                                  ;	call	badparm_p		; so all we have to do is choke and
 10772                                  ;	jmp	coff			; die, rather verbosely.
 10773                                  
 10774                                  tryu_2:	
 10775 000023CC 56                      	push	si
 10776 000023CD 06                      	push	es
 10777                                  tryu_3:
 10778 000023CE 268A04                  	mov	al,[es:si]
 10779 000023D1 3C0D                    	cmp	al,cr
 10780 000023D3 740C                    	je	short tryu_4
 10781 000023D5 3C0A                    	cmp	al,lf
 10782 000023D7 7408                    	je	short tryu_4
 10783 000023D9 E87410                  	call	delim
 10784 000023DC 7403                    	jz	short tryu_4
 10785 000023DE 46                      	inc	si
 10786 000023DF EBED                    	jmp	short tryu_3
 10787                                  tryu_4:	
 10788 000023E1 2EA2[5D21]              	mov	[cs:DevSavedDelim],al	; Save the delimiter before replacing
 10789                                  					;  it with null
 10790 000023E5 26C60400                	mov	byte [es:si],0
 10791 000023E9 07                      	pop	es
 10792 000023EA 5E                      	pop	si
 10793                                  
 10794                                  ;------------------------------------------------------------------------------
 10795                                  ; BEGIN PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
 10796                                  ;------------------------------------------------------------------------------
 10797                                  
 10798                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10799                                  ;
 10800                                  ;	call	UmbTest			; See if UMBs are around...
 10801                                  ;	jnc	short NrmTst		; ...yep. So do that normal thang.
 10802                                  ;
 10803                                  ;	mov	byte [cs:DeviceHi], 0	; ...nope... so load low.
 10804                                  ;	jmp	short LoadDevice
 10805                                  
 10806                                  ;------------------------------------------------------------------------------
 10807                                  ; END PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
 10808                                  ;------------------------------------------------------------------------------
 10809                                  
 10810 000023EB 2EC606[4821]00          NrmTst:	mov	byte [cs:DeviceHi],0
 10811 000023F1 2E803E[3921]00          	cmp	byte [cs:DevUMB],0	; do we support UMBs
 10812 000023F7 7423                    	je	short LoadDevice	; no, we don't
 10813 000023F9 2EC606[4821]01          	mov	byte [cs:DeviceHi],1
 10814 000023FF EB1B                    	jmp	short LoadDevice
 10815                                  
 10816                                  ;------------------------------------------------------------------------------
 10817                                  ; device command
 10818                                  ;------------------------------------------------------------------------------
 10819                                  
 10820                                  	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 10821                                  	; (SYSINIT:2401h)
 10822                                  
 10823                                  tryd:
 10824 00002401 80FC44                          cmp     ah,CONFIG_DEVICE ;  'D'
 10825 00002404 7403                    	je	short gotd
 10826                                  skip_it2:
 10827 00002406 E95A02                  	jmp	tryq
 10828                                  gotd:
 10829                                  
 10830                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10831                                  ;;ifdef	MULTI_CONFIG
 10832                                  ;       call    query_user              ; query the user if config_cmd
 10833                                  ;       jc	short skip_it2		; has the CONFIG_OPTION_QUERY bit set
 10834                                  ;;endif
 10835                                  
 10836 00002409 2EC606[4821]00          	mov	byte [cs:DeviceHi],0	; not to be loaded in UMB ;M007
 10837 0000240F 2EC706[4921]0000        	mov	word [cs:DevSizeOption],0
 10838 00002416 2EC606[5D21]20          	mov	byte [cs:DevSavedDelim],' ' ; In case of DEVICE= the null has to
 10839                                  					;  be replaced with a ' '
 10840                                  LoadDevice:                             ; device= or devicehigh= command.
 10841                                  	;28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)        
 10842                                  	;
 10843                                  	;push    cs
 10844                                          ;pop     ds
 10845                                  	;
 10846                                  	;mov	[bpb_addr],si		; pass the command line to the dvice
 10847                                  	;mov	[bpb_addr+2],es
 10848                                  	;
 10849                                  	;mov	[DevCmdLine],si		; save it for ourself
 10850                                  	;mov	[DevCmdLine+2],es
 10851                                  	;
 10852                                  	;mov	byte [driver_units],0	; clear total block units for driver	
 10853                                  
 10854 0000241C 8CCB                    	mov	bx,cs
 10855 0000241E 8EDB                    	mov	ds,bx
 10856                                  
 10857 00002420 2E8936[F803]            	mov	[cs:bpb_addr],si	; pass the command line to the dvice
 10858 00002425 2E8C06[FA03]            	mov	[cs:bpb_addr+2],es
 10859                                  	
 10860 0000242A 2E8936[5921]            	mov	[cs:DevCmdLine],si	; save it for ourself
 10861 0000242F 2E8C06[5B21]            	mov	[cs:DevCmdLine+2],es	
 10862                                  
 10863 00002434 E85C10                  	call	round
 10864                                  	
 10865 00002437 E82808                  	call	SizeDevice
 10866 0000243A 7218                    	jc	short BadFile
 10867                                  
 10868                                  ; - Begin DeviceHigh primary logic changes ------------------------------------
 10869                                  
 10870                                  ; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10871                                  ;
 10872                                  ;	mov	byte [ConvLoad],1	; Doesn't matter if DeviceHi==0
 10873                                  ;
 10874                                  ;	mov	al,[DeviceHi]		; If not using upper memory,
 10875                                  ;	or	byte [DeviceHi],0	; Skip all this and go on to
 10876                                  ;	jz	short DevConvLoad	; the actual load.
 10877                                  ;
 10878                                  ;	;call	GetLoadUMB		; Returns first UMB spec'ed in AX
 10879                                  ;	mov	al,[UmbLoad]	; 19/04/2019 - Retro DOS v4.0
 10880                                  ;
 10881                                  ;	cmp	al,-1			; If umb0 not specified, it's old style
 10882                                  ;	jz	short DevConvLoad	; so load high even if SIZE= is smaller
 10883                                  ;
 10884                                  ;	dec	byte [ConvLoad] ; 0 	; They specified /L, so use new loader
 10885                                  ;
 10886                                  ;	call	GetLoadSize		; Returns size of first UMB specified
 10887                                  ;	or	ax,ax
 10888                                  ;	jz	short tryd_1		; If size1 not specified, nada to do:
 10889                                  ;
 10890                                  ;	cmp	ax,[DevSize]		; /L:...,Size < DevSize?
 10891                                  ;	jge	short DevConvLoad
 10892                                  ;
 10893                                  ;tryd_1: mov	ax,[DevSize]		; Size < DevSize, so write DevSize as
 10894                                  ;	call	StoLoadSize		; minsize for load UMB.
 10895                                  
 10896                                  ; - End DeviceHigh primary logic changes --------------------------------------
 10897                                  
 10898                                  DevConvLoad:
 10899                                  	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10900 0000243C E82007                  	call	InitDevLoad
 10901                                  
 10902                                  	;mov	ax,[DevLoadAddr]
 10903                                  	;add	ax,[DevSize]
 10904                                  	;jc	short NoMem
 10905                                  	;cmp	[DevLoadEnd],ax
 10906                                  	;jae	short LoadDev
 10907                                  
 10908 0000243F 2EA1[2D21]              	mov	ax,[cs:DevLoadAddr]
 10909 00002443 2E0306[2B21]            	add	ax,[cs:DevSize]
 10910 00002448 7207                    	jc	short NoMem
 10911 0000244A 2E3906[2F21]            	cmp	[cs:DevLoadEnd],ax
 10912 0000244F 7312                    	jae	short LoadDev
 10913                                  
 10914                                  NoMem:
 10915 00002451 E98110                  	jmp	mem_err
 10916                                  
 10917                                  BadFile:
 10918                                  	;28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10919                                  	;call	RetFromUM		; Does nothing if didn't call HideUMBs
 10920                                  	;cmp    byte [es:si],' '
 10921                                          ;jae	short tryd_2
 10922 00002454 26803C0D                	cmp	byte [es:si],0Dh	; cr
 10923 00002458 7503                            jne	short tryd_2
 10924 0000245A E9BF05                  	jmp	badop
 10925                                  tryd_2:
 10926 0000245D E8D512                  	call	badload
 10927 00002460 E9DFFD                  	jmp	coff
 10928                                  
 10929                                  LoadDev:
 10930 00002463 06                      	push	es
 10931 00002464 1F                      	pop	ds
 10932                                  
 10933 00002465 89F2                    	mov	dx,si			;ds:dx points to file name
 10934 00002467 E84708                  	call	ExecDev			; load device driver using exec call
 10935                                  badldreset:
 10936 0000246A 1E                      	push	ds
 10937 0000246B 07                      	pop	es			;es:si back to config.sys
 10938 0000246C 0E                      	push	cs
 10939 0000246D 1F                      	pop	ds			;ds back to sysinit
 10940 0000246E 72E4                    	jc	short BadFile
 10941                                  goodld:
 10942 00002470 06                      	push	es
 10943 00002471 56                      	push	si
 10944 00002472 E85908                  	call	RemoveNull
 10945 00002475 06                      	push	es
 10946 00002476 56                      	push	si
 10947                                  
 10948 00002477 0E                      	push	cs
 10949 00002478 07                      	pop	es
 10950                                  
 10951 00002479 1E                      	push	ds
 10952 0000247A 56                      	push	si
 10953                                  
 10954 0000247B 2EC536[3121]            	lds	si,[cs:DevEntry]	; peeks the header attribute
 10955                                  	
 10956                                  	;test	word [si+4],8000h
 10957 00002480 F744040080              	test	word [si+SYSDEV.ATT],DEVTYP ;block device driver?
 10958 00002485 7511                    	jnz	short got_device_com_cont   ;no.
 10959                                  
 10960 00002487 2EC536[6B02]            	lds	si,[cs:DOSINFO]		; ds:si -> sys_var
 10961                                  	;cmp	byte [si+32],26
 10962 0000248C 807C201A                	cmp	byte [si+SYSI_NUMIO],26	; no more than 26 drive number
 10963 00002490 7206                    	jb	short got_device_com_cont
 10964                                  
 10965 00002492 5E                      	pop	si
 10966 00002493 1F                      	pop	ds
 10967                                  
 10968 00002494 5E                      	pop	si			;clear the stack
 10969 00002495 07                      	pop	es
 10970                                  
 10971                                  	;28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 10972                                  	;call	RetFromUM		; Do this before we leave
 10973                                  
 10974 00002496 EB5F                    	jmp	short badnumblock
 10975                                  
 10976                                  got_device_com_cont:
 10977 00002498 5E                      	pop	si
 10978 00002499 1F                      	pop	ds
 10979                                  
 10980 0000249A E84306                  	call	LieInt12Mem
 10981 0000249D E8AD06                  	call	UpdatePDB		; update the PSP:2 value M020
 10982                                  
 10983 000024A0 2E803E[5716]00          	cmp	byte [cs:multdeviceflag],0 ; Pass limit only for the 1st device
 10984                                  					;  driver in the file ; M027
 10985 000024A6 7511                    	jne	short skip_pass_limit	;		      ; M027
 10986                                  
 10987 000024A8 2EC706[F403]0000        	mov	word [cs:break_addr],0	; pass the limit to the DD
 10988 000024AF 2E8B1E[2F21]            	mov	bx,[cs:DevLoadEnd]
 10989 000024B4 2E891E[F603]            	mov	word [cs:break_addr+2],bx
 10990                                  
 10991                                  skip_pass_limit:
 10992                                  ;	Note: sysi_numio (in DOS DATA) currently reflects the REAL
 10993                                  ;	number of installed devices (including DblSpace drives) where
 10994                                  ;	"drivenumber" is the number that the next block device will
 10995                                  ;	be assigned to. Because some naughty device drivers (like
 10996                                  ;	interlnk) look at the internal DOS variable instead of the
 10997                                  ;	value we pass it, we'll temporarily stick our value into
 10998                                  ;	DOS DATA while we're initializing the device drivers.
 10999                                  ;
 11000                                  ;	Note that this will make it impossible for this device
 11001                                  ;	driver to access the DblSpace drive letters, whether
 11002                                  ;	they are swapped-hosts or unswapped compressed drives,
 11003                                  ;	during its initialization phase.
 11004                                  
 11005                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11006                                  	;push	ds
 11007                                  	;lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
 11008                                  	;
 11009                                  	;mov	al,[cs:drivenumber]	; temporarily use this next drv value
 11010                                  	;mov	[cs:devdrivenum],al	; pass drive number in packet to driver
 11011                                  	;mov	ah,al
 11012                                  	;
 11013                                  	;xchg	ax,[bx+SYSI_NUMIO]	; swap with existing values
 11014                                  	;pop	ds
 11015                                  	;
 11016                                  	;push	ax			; save real sysi_numio/ncds in ax
 11017                                  
 11018                                  	; 29/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 11019                                  	; (SYSINIT:24B9h)
 11020                                  
 11021 000024B9 BB0600                  	mov	bx,SYSDEV.STRAT ; 6
 11022 000024BC E82110                  	call	calldev 		;   calldev (sdevstrat);
 11023 000024BF BB0800                  	mov	bx,SYSDEV.INT ; 8
 11024 000024C2 E81B10                  	call	calldev 		;   calldev (sdevint);
 11025                                  
 11026                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11027                                  	;pop	ax			; get real sysi_numio value
 11028                                  	;push	ds
 11029                                  	;lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
 11030                                  	;mov	[bx+SYSI_NUMIO],ax	; swap with existing values
 11031                                  	;pop	ds
 11032                                  
 11033 000024C5 E84F06                  	call	TrueInt12Mem
 11034                                  
 11035 000024C8 2EA1[F403]              	mov	ax,[cs:break_addr]	; move break addr from the req packet
 11036 000024CC 2EA3[3521]              	mov	[cs:DevBrkAddr],ax
 11037 000024D0 2EA1[F603]              	mov	ax,[cs:break_addr+2]
 11038 000024D4 2EA3[3721]              	mov	[cs:DevBrkAddr+2],ax
 11039                                  
 11040                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11041                                  	;call	RetFromUM		; There we go... all done.
 11042                                  
 11043 000024D8 2E803E[3921]00          	cmp	byte [cs:DevUMB],0
 11044 000024DE 7403                    	je	short tryd_3
 11045 000024E0 E82709                  	call	AllocUMB
 11046                                  tryd_3:
 11047                                  
 11048                                  ;ifndef ROMDOS
 11049                                  ;------ If we are waiting to be moved into hma lets try it now !!!
 11050                                  
 11051 000024E3 2E803E[6A02]FF          	cmp	byte [cs:runhigh],0FFh
 11052 000024E9 7503                    	jne	short tryd_4
 11053                                  
 11054 000024EB E83CE4                  	call	TryToMovDOSHi		; move DOS into HMA if reqd
 11055                                  tryd_4:
 11056                                  ;endif ; ROMDOS
 11057                                  
 11058 000024EE 5E                      	pop	si
 11059 000024EF 1F                      	pop	ds
 11060 000024F0 C60400                  	mov	byte [si],0		; *p = 0;
 11061                                  
 11062 000024F3 0E                      	push	cs
 11063 000024F4 1F                      	pop	ds
 11064                                  
 11065 000024F5 EB21                    	jmp	short was_device_com
 11066                                  
 11067                                  ;----------------------------------------------------------------------------
 11068                                  
 11069                                  ;02/04/2019 - Retro DOS v4.0
 11070                                  
 11071                                  badnumblock:
 11072 000024F7 0E                      	push	cs
 11073 000024F8 1F                      	pop	ds
 11074 000024F9 BA[683C]                	mov	dx,badblock
 11075 000024FC E86012                  	call	print
 11076                                  
 11077                                  ;------ fall thru -----------------------------------------------------------
 11078                                  
 11079                                  erase_dev_do:				; modified to show message "error in config.sys..."
 11080                                  	
 11081                                  	;call	CheckDoubleSpace ; MSDOS 6.21 IO.SYS SYSINIT:27BBh
 11082                                  	
 11083 000024FF 5E                      	pop	si
 11084 00002500 07                      	pop	es
 11085                                  
 11086 00002501 0E                      	push	cs
 11087 00002502 1F                      	pop	ds
 11088                                  
 11089                                  skip1_resetmemhi:
 11090 00002503 2E833E[FD03]00          	cmp	word [cs:configmsgflag],0
 11091 00002509 740A                    	je	short no_error_line_msg
 11092                                  
 11093 0000250B E86C05                  	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
 11094 0000250E 2EC706[FD03]0000        	mov	word [cs:configmsgflag],0 ;set the default value again.
 11095                                  
 11096                                  no_error_line_msg:
 11097 00002515 E92AFD                  	jmp	coff
 11098                                  
 11099                                  ;----------------------------------------------------------------------------
 11100                                  
 11101                                  was_device_com:
 11102 00002518 2EA1[3721]              	mov	ax,[cs:DevBrkAddr+2] 	; 13/05/2019
 11103 0000251C 2E3B06[2F21]            	cmp	ax,[cs:DevLoadEnd]
 11104 00002521 7605                    	jbe	short breakok
 11105                                  
 11106 00002523 5E                      	pop	si
 11107 00002524 07                      	pop	es
 11108 00002525 E92CFF                  	jmp	BadFile
 11109                                  
 11110                                  breakok:
 11111 00002528 2EC516[3121]            	lds	dx,[cs:DevEntry]	;set ds:dx to header
 11112 0000252D 89D6                    	mov	si,dx
 11113                                  
 11114 0000252F 2EC43E[6B02]            	les	di,[cs:DOSINFO] 	;es:di point to dos info
 11115                                  	;mov	ax,[si+4]
 11116 00002534 8B4404                  	mov	ax,[si+SYSDEV.ATT]	;get attributes
 11117 00002537 A90080                  	test	ax,DEVTYP ; 8000h	;test if block dev
 11118 0000253A 7428                    	jz	short isblock
 11119                                  
 11120                                  ;------ lets deal with character devices
 11121                                  
 11122 0000253C 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],for_devmark ; 2
 11123 00002542 E8BE07                  	call	DevSetBreak		; go ahead and alloc mem for device
 11124                                  jc_edd:
 11125 00002545 72B8                    	jc	short erase_dev_do	;device driver's init routine failed.
 11126                                  
 11127 00002547 A90100                  	test	ax,ISCIN ; 1		;is it a console in?
 11128 0000254A 7408                    	jz	short tryclk
 11129                                  
 11130 0000254C 2689550C                	mov	[es:di+SYSI_CON],dx   ; es:di+12
 11131 00002550 268C5D0E                	mov	[es:di+SYSI_CON+2],ds ; es:di+14
 11132                                  tryclk: 
 11133 00002554 A90800                  	test	ax,ISCLOCK ; 8		;is it a clock device?
 11134 00002557 7408                    	jz	short golink
 11135                                  
 11136 00002559 26895508                	mov	[es:di+SYSI_CLOCK],dx	; es:di+8
 11137 0000255D 268C5D0A                	mov	[es:di+SYSI_CLOCK+2],ds ; es:di+10
 11138                                  golink: 
 11139 00002561 E9B000                  	jmp	linkit
 11140                                  
 11141                                  ;------ deal with block device drivers
 11142                                  
 11143                                  isblock:
 11144 00002564 2EA0[F303]              	mov	al,[cs:unitcount]	;if no units found,erase the device
 11145 00002568 08C0                    	or	al,al
 11146 0000256A 7493                    	jz	short erase_dev_do
 11147                                  	;mov	[si+10],al
 11148 0000256C 88440A                  	mov	[si+SYSDEV.NAME],al	; number of units in name field
 11149                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11150                                  	;add	[cs:driver_units],al	; keep total for all drivers in file
 11151                                  perdrv:
 11152 0000256F 98                      	cbw				; warning no device > 127 units
 11153 00002570 89C1                    	mov	cx,ax
 11154 00002572 88E6                    	mov	dh,ah
 11155                                  	;mov	dl,[es:di+32]
 11156 00002574 268A5520                	mov	dl,[es:di+SYSI_NUMIO]	;get number of devices
 11157 00002578 88D4                    	mov	ah,dl
 11158 0000257A 00C4                    	add	ah,al			; check for too many devices
 11159 0000257C 80FC1A                  	cmp	ah,26			; 'A' - 'Z' is 26 devices
 11160 0000257F 7603                    	jbe	short ok_block
 11161 00002581 E973FF                  	jmp	badnumblock
 11162                                  
 11163                                  ok_block:
 11164 00002584 2E800E[5A16]02          	or	byte [cs:setdevmarkflag],for_devmark ; 2
 11165 0000258A E87607                  	call	DevSetBreak		; alloc the device
 11166 0000258D 72B6                    	jc	short jc_edd
 11167 0000258F 26004520                	add	[es:di+SYSI_NUMIO],al	; update the amount
 11168                                  
 11169 00002593 2E0006[FC03]            	add	[cs:drivenumber],al	; remember amount for next device
 11170 00002598 2EC51E[F803]            	lds	bx,[cs:bpb_addr]	; point to bpb array
 11171                                  perunit:
 11172 0000259D 2EC42E[6B02]            	les	bp,[cs:DOSINFO]
 11173                                  	;les	bp,[es:bp+SYSI_DPB]	; get first dpb
 11174                                  	;les	bp,[es:bp]
 11175                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11176 000025A2 26C46E00                	les	bp,[es:bp+0]		; [es:bp+SYSI_DPB]
 11177                                  scandpb:
 11178                                  	;cmp	word [es:bp+25],-1
 11179 000025A6 26837E19FF              	cmp	word [es:bp+DPB.NEXT_DPB],-1
 11180 000025AB 7406                    	je	short foundpb
 11181                                  	;les	bp,[es:bp+25]
 11182 000025AD 26C46E19                	les	bp,[es:bp+DPB.NEXT_DPB]
 11183 000025B1 EBF3                    	jmp	short scandpb
 11184                                  foundpb:
 11185 000025B3 2EA1[3521]              	mov	ax,[cs:DevBrkAddr]
 11186 000025B7 26894619                	mov	[es:bp+DPB.NEXT_DPB],ax
 11187 000025BB 2EA1[3721]              	mov	ax,[cs:DevBrkAddr+2]
 11188 000025BF 2689461B                	mov	[es:bp+DPB.NEXT_DPB+2],ax
 11189                                  
 11190 000025C3 2EC42E[3521]            	les	bp,[cs:DevBrkAddr]
 11191 000025C8 2E8306[3521]21          	add	word [cs:DevBrkAddr],DPBSIZ ; 33
 11192                                  
 11193 000025CE E81007                  	call	RoundBreakAddr
 11194                                  
 11195 000025D1 26C74619FFFF            	mov	word [es:bp+DPB.NEXT_DPB],-1
 11196 000025D7 26C64618FF              	mov	byte [es:bp+DPB.FIRST_ACCESS],-1
 11197                                  
 11198 000025DC 8B37                    	mov	si,[bx] 		;ds:si points to bpb
 11199 000025DE 43                      	inc	bx
 11200 000025DF 43                      	inc	bx			;point to next guy
 11201                                  	;;mov	[es:bp+DPB.DRIVE],dx
 11202                                  	;mov	[es:bp],dx ; 13/05/2019
 11203                                  	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11204 000025E0 26895600                	mov	[es:bp+0],dx		; [es:bp+DPB.DRIVE]
 11205                                  	
 11206 000025E4 B453                    	mov	ah,SETDPB ; 53h		;hidden system call
 11207 000025E6 CD21                    	int	21h
 11208                                  			; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
 11209                                  			; DS:SI -> BPB (BIOS Parameter Block)
 11210                                  			; ES:BP -> buffer for DOS Drive Parameter Block
 11211                                  
 11212                                  	;mov	ax,[es:bp+2]
 11213 000025E8 268B4602                	mov	ax,[es:bp+DPB.SECTOR_SIZE]
 11214 000025EC 06                      	push	es
 11215 000025ED 2EC43E[6B02]            	les	di,[cs:DOSINFO] 	;es:di point to dos info
 11216                                  	;cmp	ax,[es:di+10h]
 11217 000025F2 263B4510                	cmp	ax,[es:di+SYSI_MAXSEC]
 11218 000025F6 07                      	pop	es
 11219                                  	;jna	short iblk_1
 11220                                  	;jmp	short bad_bpb_size_sector
 11221                                  	; 29/10/2022
 11222 000025F7 775C                    	ja	short bad_bpb_size_sector
 11223                                  iblk_1:
 11224 000025F9 1E                      	push	ds
 11225 000025FA 52                      	push	dx
 11226                                  
 11227 000025FB 2EC516[3121]            	lds	dx,[cs:DevEntry]
 11228                                  	;mov	[es:bp+13h],dx
 11229 00002600 26895613                	mov	[es:bp+DPB.DRIVER_ADDR],dx
 11230                                  	;mov	[es:bp+15h],ds
 11231 00002604 268C5E15                	mov	[es:bp+DPB.DRIVER_ADDR+2],ds
 11232                                  
 11233 00002608 5A                      	pop	dx
 11234 00002609 1F                      	pop	ds
 11235                                  
 11236 0000260A 42                      	inc	dx
 11237 0000260B FEC6                    	inc	dh
 11238 0000260D E28E                    	loop	perunit
 11239                                  
 11240 0000260F 0E                      	push	cs
 11241 00002610 1F                      	pop	ds
 11242                                  
 11243 00002611 E821E6                  	call	TempCDS 		; set cds for new drives
 11244                                  linkit:
 11245 00002614 2EC43E[6B02]            	les	di,[cs:DOSINFO] 	;es:di = dos table
 11246 00002619 268B4D22                	mov	cx,[es:di+SYSI_DEV]	;dx:cx = head of list
 11247 0000261D 268B5524                	mov	dx,[es:di+SYSI_DEV+2]
 11248                                  
 11249 00002621 2EC536[3121]            	lds	si,[cs:DevEntry]	;ds:si = device location
 11250 00002626 26897522                	mov	[es:di+SYSI_DEV],si	;set head of list in dos
 11251 0000262A 268C5D24                	mov	[es:di+SYSI_DEV+2],ds
 11252 0000262E 8B04                    	mov	ax,[si]			;get pointer to next device
 11253 00002630 2EA3[3121]              	mov	[cs:DevEntry],ax	;and save it
 11254                                  
 11255 00002634 890C                    	mov	[si],cx			;link in the driver
 11256 00002636 895402                  	mov	[si+2],dx
 11257                                  enddev:
 11258 00002639 5E                      	pop	si
 11259 0000263A 07                      	pop	es
 11260 0000263B 40                      	inc	ax			;ax = ffff (no more devs if yes)?
 11261 0000263C 740B                    	jz	short coffj3
 11262                                  
 11263 0000263E 2EFE06[5716]            	inc	byte [cs:multdeviceflag] ; possibly multiple device driver.
 11264 00002643 E8E206                  	call	DevBreak		; M009
 11265                                  	; 03/04/2019 - Retro DOS v4.0
 11266                                  	; MSDOS 6.21 IO.SYS - SYSINIT:290Dh
 11267 00002646 E927FE                  	jmp	goodld			; otherwise pretend we loaded it in
 11268                                  coffj3: 
 11269 00002649 2EC606[5716]00          	mov	byte [cs:multdeviceflag],0 ; reset the flag
 11270 0000264F E8D606                  	call	DevBreak
 11271                                  	
 11272                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS compatibility)
 11273                                  	;call	CheckProtmanArena	; adjust alloclim if Protman$ just
 11274                                  ;					;  created a bogus arena to try
 11275                                  ;					;  to protect some of its resident-
 11276                                  ;					;  init code.
 11277                                  	;call	CheckDoubleSpace
 11278 00002652 E9EDFB                  	jmp	coff
 11279                                  
 11280                                  ;----------------------------------------------------------------------------
 11281                                  
 11282                                  ;CheckDoubleSpace:
 11283                                  ;;;;	ifdef	dblspace_hooks
 11284                                  ;
 11285                                  ;;	Now check for two special MagicDrv cases:
 11286                                  ;;
 11287                                  ;;       a) the last driver load was MagicDrv final placement:
 11288                                  ;;	   -> add number of MagicDrv reserved drives to drivenumber
 11289                                  ;;
 11290                                  ;;       b) MagicDrv is currently in temporary home:
 11291                                  ;;          -> call it to give it a chance to mount and shuffle drives
 11292                                  ;
 11293                                  ;	cmp	byte [cs:MagicHomeFlag],0 ; already home?
 11294                                  ;	jnz	short no_more_magic_calls ;  nothing more to do if so
 11295                                  ;
 11296                                  ;;	Now inquire of driver whether it is present, and final located
 11297                                  ;
 11298                                  ;	mov	ax,multMagicdrv ; 4A11h
 11299                                  ;	mov	bx,MD_VERSION ; 0
 11300                                  ;	int	2fh			; ch = number of MagicDrv drive letters
 11301                                  ;	or	ax,ax			; is it there?
 11302                                  ;	jnz	short no_more_magic_calls ; done if not
 11303                                  ;
 11304                                  ;	test	dx,8000h		; is it final placed?
 11305                                  ;	jnz	short magic_not_yet_home ;  skip if not
 11306                                  ;
 11307                                  ;;	Okay, now the driver is final placed!  Set the flag so we
 11308                                  ;;	don't keep checking it, and add its number of drive letters
 11309                                  ;;	to drivenumber.
 11310                                  ;
 11311                                  ;	mov	byte [cs:MagicHomeFlag],0ffh ; set the flag!
 11312                                  ;	add	[cs:drivenumber],ch	; add number of MagicDrv volumes to
 11313                                  ;;					;  the drive number we'll pass to the
 11314                                  ;;					;  next loadable block device.
 11315                                  ;
 11316                                  ;	jmp	short no_more_magic_calls ; and finished.
 11317                                  ;
 11318                                  ;magic_not_yet_home:
 11319                                  ;	push	es
 11320                                  ;	push	si
 11321                                  ;
 11322                                  ;	mov	cx,[cs:memhi]		; pass it a work buffer
 11323                                  ;	mov	dx,[cs:ALLOCLIM]	;   address in cx (segment)
 11324                                  ;	sub	dx,cx			;   for len dx (paragraphs)
 11325                                  ;
 11326                                  ;	mov	bx,2
 11327                                  ;	mov	al,[cs:driver_units]	; shuffle magicdrives and new drives
 11328                                  ;;					;   by this many units
 11329                                  ;
 11330                                  ;;BUGBUG 29-Oct-1992 bens Take this 55h out after Beta 4
 11331                                  ;	mov	ah,55h			; backdoor won't shuffle unless it
 11332                                  ;;					;  sees this, to prevent bad things
 11333                                  ;;					;  from happening if people run the
 11334                                  ;;					;  new driver with an old BIOS
 11335                                  ;	call	far [cs:MagicBackdoor]
 11336                                  ;
 11337                                  ;	pop	si
 11338                                  ;	pop	es
 11339                                  ;
 11340                                  ;no_more_magic_calls:
 11341                                  ;
 11342                                  ;;;;	endif
 11343                                  ;	retn
 11344                                  
 11345                                  ; 03/04/2019 - Retro DOS v4.0
 11346                                  
 11347                                  bad_bpb_size_sector:
 11348 00002655 5E                      	pop	si
 11349 00002656 07                      	pop	es
 11350 00002657 BA[8A3B]                	mov	dx,badsiz_pre
 11351 0000265A BB[683B]                	mov	bx,crlfm
 11352 0000265D E8DB10                  	call	prnerr
 11353                                  
 11354 00002660 E9DFFB                  	jmp	coff
 11355                                  
 11356                                  ;------------------------------------------------------------------------------
 11357                                  ; country command
 11358                                  ;      the syntax is:
 11359                                  ;	country=country id {,codepage {,path}}
 11360                                  ;	country=country id {,,path}	:default codepage id in dos
 11361                                  ;------------------------------------------------------------------------------
 11362                                  
 11363                                  	; 30/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 11364                                  	; (SYSINIT:2663h)
 11365                                  tryq:
 11366 00002663 80FC51                          cmp     ah,CONFIG_COUNTRY ; 'Q'
 11367 00002666 7403                    	je	short tryq_cont
 11368                                  skip_it3:
 11369 00002668 E92301                  	jmp	tryf
 11370                                  tryq_cont:
 11371                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11372                                  ;;ifdef	MULTI_CONFIG
 11373                                  ;       call    query_user		; query the user if config_cmd
 11374                                  ;       jc      short skip_it3		; has the CONFIG_OPTION_QUERY bit set
 11375                                  ;;endif
 11376 0000266B 2EC606[2038]00          	mov	byte [cs:cntry_drv],0	; reset the drive,path to default value.
 11377 00002671 2EC706[F61F]0000        	mov	word [cs:p_code_page],0
 11378 00002678 BF[BF1F]                	mov	di,cntry_parms
 11379 0000267B 31C9                    	xor	cx,cx
 11380 0000267D 89CA                    	mov	dx,cx
 11381                                  do52:
 11382 0000267F E86703                  	call	sysinit_parse
 11383 00002682 730C                    	jnc	short if52		; parse error,check error code and
 11384                                  
 11385 00002684 E8F300                  	call	cntry_error		; show message and end the search loop.
 11386 00002687 2EC706[F41F]FFFF        	mov	word [cs:p_cntry_code],-1 ; signals that parse error.
 11387 0000268E EB39                    	jmp	short sr52
 11388                                  if52:
 11389 00002690 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
 11390 00002693 7434                    	jz	short sr52		; then end the search loop
 11391                                  
 11392                                  	;cmp	byte [cs:result_val+_$P_Result_Blk.Type],_$P_number ; numeric?
 11393 00002695 2E803E[911F]01          	cmp	byte [cs:result_val],_$P_Number
 11394 0000269B 7515                    	jnz	short if56
 11395                                  
 11396                                  	;mov	ax,[cs:rw_dword]
 11397 0000269D 2EA1[951F]              	mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
 11398 000026A1 83F901                  	cmp	cx,1
 11399 000026A4 7506                    	jne	short if57
 11400                                  
 11401 000026A6 2EA3[F41F]              	mov	[cs:p_cntry_code],ax
 11402                                  	
 11403                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11404 000026AA EB04                    	jmp	short en57
 11405                                  	;jmp	short en56
 11406                                  
 11407                                  if57:
 11408 000026AC 2EA3[F61F]              	mov	[cs:p_code_page],ax
 11409                                  en57:
 11410 000026B0 EB15                    	jmp	short en56		; path entered
 11411                                  
 11412                                  if56:
 11413 000026B2 1E                      	push	ds
 11414 000026B3 06                      	push	es
 11415 000026B4 56                      	push	si
 11416 000026B5 57                      	push	di
 11417                                  
 11418 000026B6 0E                      	push	cs
 11419 000026B7 07                      	pop	es
 11420                                  
 11421 000026B8 2EC536[951F]            	lds	si,[cs:rv_dword]	; move the path to known place.
 11422 000026BD BF[2038]                	mov	di,cntry_drv
 11423 000026C0 E86610                  	call	move_asciiz
 11424                                  
 11425 000026C3 5F                      	pop	di
 11426 000026C4 5E                      	pop	si
 11427 000026C5 07                      	pop	es
 11428 000026C6 1F                      	pop	ds
 11429                                  
 11430                                  en56:
 11431 000026C7 EBB6                    	jmp	short do52
 11432                                  
 11433                                  sr52:
 11434 000026C9 2E833E[F41F]FF          	cmp	word [cs:p_cntry_code],-1	; had a parse error?
 11435 000026CF 750A                    	jne	short tryq_open
 11436 000026D1 E96EFB                  	jmp	coff
 11437                                  
 11438                                  tryqbad:				;"invalid country code or code page"
 11439 000026D4 F9                      	stc
 11440 000026D5 BA[D13B]                	mov     dx,badcountry
 11441 000026D8 E98200                  	jmp     tryqchkerr
 11442                                  
 11443                                  tryq_open:
 11444 000026DB 2E803E[2038]00          	cmp	byte [cs:cntry_drv],0
 11445 000026E1 7405                    	je	short tryq_def
 11446 000026E3 BA[2038]                	mov	dx,cntry_drv
 11447 000026E6 EB03                    	jmp	short tryq_openit
 11448                                  
 11449                                  tryq_def:
 11450 000026E8 BA[2238]                	mov	dx,cntry_root
 11451                                  tryq_openit:
 11452 000026EB B8003D                  	mov	ax,3D00h		;open a file
 11453 000026EE F9                      	stc
 11454 000026EF CD21                    	int	21h
 11455 000026F1 7249                    	jc	short tryqfilebad	;open failure
 11456                                  
 11457 000026F3 2EA3[D803]              	mov	[cs:cntryfilehandle],ax	;save file handle
 11458 000026F7 89C3                    	mov	bx,ax
 11459 000026F9 2EA1[F41F]              	mov	ax,[cs:p_cntry_code]
 11460 000026FD 2E8B16[F61F]            	mov	dx,[cs:p_code_page]	; now,ax=country id,bx=filehandle
 11461 00002702 2E8B0E[E003]            	mov	cx,[cs:memhi]
 11462 00002707 81C18001                	add	cx,384			; need 6k buffer to handle country.sys
 11463                                  					; M023
 11464 0000270B 2E3B0E[A302]            	cmp	cx,[cs:ALLOCLIM]
 11465 00002710 7748                    	ja	short tryqmemory	;cannot allocate the buffer for country.sys
 11466                                  
 11467 00002712 BE[2038]                	mov	si,cntry_drv		;ds:si -> cntry_drv
 11468 00002715 803C00                  	cmp	byte [si],0 		;default path?
 11469 00002718 7502                    	jne	short tryq_set_for_dos
 11470                                  
 11471 0000271A 46                      	inc	si
 11472 0000271B 46                      	inc	si			;ds:si -> cntry_root
 11473                                  
 11474                                  tryq_set_for_dos:
 11475 0000271C 2EC43E[7702]            	les	di,[cs:sysi_country]	;es:di -> country info tab in dos
 11476 00002721 57                      	push	di			;save di
 11477                                  	;add	di,8
 11478 00002722 83C708                  	add	di,country_cdpg_info.ccPath_CountrySys ; 8
 11479 00002725 E80110                  	call	move_asciiz		;set the path to country.sys in dos.
 11480 00002728 5F                      	pop	di			;es:di -> country info tab again.
 11481                                  
 11482 00002729 2E8B0E[E003]            	mov	cx,[cs:memhi]
 11483 0000272E 8ED9                    	mov	ds,cx
 11484 00002730 31F6                    	xor	si,si			;ds:si -> 2k buffer to be used.
 11485 00002732 E8370E                  	call	setdoscountryinfo	;now do the job!!!
 11486 00002735 7326                    	jnc	short tryqchkerr	;read error or could not find country,code page combination
 11487                                  
 11488 00002737 83F9FF                  	cmp	cx,-1			;could not find matching country_id,code page?
 11489 0000273A 7498                    	je	short tryqbad 		;then "invalid country code or code page"
 11490                                  
 11491                                  tryqfilebad:
 11492 0000273C 0E                      	push	cs
 11493 0000273D 07                      	pop	es
 11494 0000273E 2E803E[2038]00          	cmp	byte [cs:cntry_drv],0	;is the default file used?
 11495 00002744 7405                    	je	short tryqdefbad
 11496                                  
 11497 00002746 BE[2038]                	mov	si,cntry_drv
 11498 00002749 EB03                    	jmp	short tryqbadload
 11499                                  
 11500                                  tryqdefbad:				;default file has been used.
 11501 0000274B BE[2238]                	mov	si,cntry_root		;es:si -> \country.sys in sysinit_seg
 11502                                  tryqbadload:
 11503 0000274E E8E40F                  	call	badload 		;ds will be restored to sysinit_seg
 11504                                  	;mov	cx,[cs:CONFBOT]
 11505                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11506 00002751 2E8B0E[A102]            	mov	cx,[cs:top_of_cdss]
 11507 00002756 8EC1                    	mov	es,cx			;restore es -> confbot.
 11508 00002758 EB14                    	jmp	short coffj4
 11509                                  
 11510                                  tryqmemory:
 11511 0000275A BA[143C]                	mov	dx,insufmemory
 11512                                  tryqchkerr:
 11513                                  	;mov	cx,[cs:CONFBOT]
 11514                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11515 0000275D 2E8B0E[A102]            	mov	cx,[cs:top_of_cdss]
 11516 00002762 8EC1                    	mov	es,cx			;restore es -> confbot seg
 11517 00002764 0E                      	push	cs
 11518 00002765 1F                      	pop	ds			;restore ds to sysinit_seg
 11519 00002766 7306                    	jnc	short coffj4		;if no error,then exit
 11520                                  
 11521 00002768 E8F40F                  	call	print			;else show error message
 11522 0000276B E80C03                  	call	error_line
 11523                                  coffj4:
 11524 0000276E 2E8B1E[D803]            	mov	bx,[cs:cntryfilehandle]
 11525 00002773 B43E                    	mov	ah,3Eh
 11526 00002775 CD21                    	int	21h			;close a file. don't care even if it fails.
 11527 00002777 E9C8FA                  	jmp	coff
 11528                                  
 11529                                  ;--------------------------------------------
 11530                                  
 11531                                  cntry_error:
 11532                                  
 11533                                  ;function: show "invalid country code or code page" messages,or
 11534                                  ;		"error in country command" depending on the error code
 11535                                  ;		in ax returned by sysparse;
 11536                                  ;in:	ax - error code
 11537                                  ;	ds - sysinitseg
 11538                                  ;	es - confbot
 11539                                  ;out:	show message.  dx destroyed.
 11540                                  
 11541 0000277A 83F806                  	cmp	ax,_$P_Out_Of_Range ; 6
 11542 0000277D 7505                    	jne	short if64
 11543 0000277F BA[D13B]                	mov	dx,badcountry		;"invalid country code or code page"
 11544 00002782 EB03                    	jmp	short en64
 11545                                  
 11546                                  if64:
 11547 00002784 BA[F73B]                	mov	dx,badcountrycom	;"error in contry command"
 11548                                  en64:
 11549 00002787 E8D50F                  	call	print
 11550 0000278A E8ED02                  	call	error_line
 11551 0000278D C3                      	retn
 11552                                  
 11553                                  ;------------------------------------------------------------------------------
 11554                                  ; files command
 11555                                  ;------------------------------------------------------------------------------
 11556                                  
 11557                                  ;******************************************************************************
 11558                                  ; function: parse the parameters of files= command.			      *
 11559                                  ;									      *
 11560                                  ; input :								      *
 11561                                  ;	es:si -> parameters in command line.				      *
 11562                                  ; output:								      *
 11563                                  ;	variable files set.						      *
 11564                                  ;									      *
 11565                                  ; subroutines to be called:						      *
 11566                                  ;	sysinit_parse							      *
 11567                                  ; logic:								      *
 11568                                  ; {									      *
 11569                                  ;	set di points to files_parms;					      *
 11570                                  ;	set dx,cx to 0; 						      *
 11571                                  ;	while (end of command line)					      *
 11572                                  ;	{ sysinit_parse;						      *
 11573                                  ;	  if (no error) then						      *
 11574                                  ;	     files = result_val._$P_picked_val				      *
 11575                                  ;	  else								      *
 11576                                  ;	     error exit;						      *
 11577                                  ;	};								      *
 11578                                  ; };									      *
 11579                                  ;									      *
 11580                                  ;******************************************************************************
 11581                                  
 11582                                  tryf:
 11583 0000278E 80FC46                          cmp     ah,CONFIG_FILES ;  'F'
 11584 00002791 752B                    	jne	short tryl
 11585                                  
 11586                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11587                                  ;;ifdef	MULTI_CONFIG
 11588                                  ;       call    query_user              ; query the user if config_cmd
 11589                                  ;       jc      short tryl		; has the CONFIG_OPTION_QUERY bit set
 11590                                  ;;endif
 11591                                  
 11592 00002793 BF[F81F]                	mov	di,files_parms
 11593 00002796 31C9                    	xor	cx,cx
 11594 00002798 89CA                    	mov	dx,cx
 11595                                  do67:
 11596 0000279A E84C02                  	call	sysinit_parse
 11597 0000279D 7305                    	jnc	short if67		; parse error
 11598 0000279F E88602                  	call	badparm_p		;   and show messages and end the search loop.
 11599 000027A2 EB17                    	jmp	short sr67
 11600                                  if67:
 11601 000027A4 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 11602 000027A7 740A                    	je	short en67		; then end the $endloop
 11603                                  	;mov	al,[cs:rv_dword]
 11604 000027A9 2EA0[951F]              	mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
 11605 000027AD 2EA2[1720]              	mov	[cs:p_files],al		; save it temporarily
 11606 000027B1 EBE7                    	jmp	short do67
 11607                                  en67:
 11608 000027B3 2EA0[1720]              	mov	al,[cs:p_files]
 11609 000027B7 2EA2[9D02]              	mov	[cs:FILES],al		; no error. really set the value now.
 11610                                  sr67:
 11611 000027BB E984FA                  	jmp	coff
 11612                                  
 11613                                  ; 04/04/2019 - Retro DOS v4.0
 11614                                  
 11615                                  ;------------------------------------------------------------------------------
 11616                                  ; lastdrive command
 11617                                  ;------------------------------------------------------------------------------
 11618                                  
 11619                                  ;******************************************************************************
 11620                                  ; function: parse the parameters of lastdrive= command. 		      *
 11621                                  ;									      *
 11622                                  ; input :								      *
 11623                                  ;	es:si -> parameters in command line.				      *
 11624                                  ; output:								      *
 11625                                  ;	set the variable num_cds.					      *
 11626                                  ;									      *
 11627                                  ; subroutines to be called:						      *
 11628                                  ;	sysinit_parse							      *
 11629                                  ; logic:								      *
 11630                                  ; {									      *
 11631                                  ;	set di points to ldrv_parms;					      *
 11632                                  ;	set dx,cx to 0; 						      *
 11633                                  ;	while (end of command line)					      *
 11634                                  ;	{ sysinit_parse;						      *
 11635                                  ;	  if (no error) then						      *
 11636                                  ;	     set num_cds to the returned value; 			      *
 11637                                  ;	  else	/*error exit*/						      *
 11638                                  ;	     error exit;						      *
 11639                                  ;	};								      *
 11640                                  ; };									      *
 11641                                  ;									      *
 11642                                  ;******************************************************************************
 11643                                  
 11644                                  tryl:
 11645 000027BE 80FC4C                          cmp     ah,CONFIG_LASTDRIVE ; 'L'
 11646 000027C1 752B                    	jne	short tryp
 11647                                  
 11648                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11649                                  ;;ifdef	MULTI_CONFIG
 11650                                  ;       call    query_user      ; query the user if config_cmd
 11651                                  ;       jc	short tryp	; has the CONFIG_OPTION_QUERY bit set
 11652                                  ;;endif
 11653                                  
 11654 000027C3 BF[4F20]                	mov	di,ldrv_parms
 11655 000027C6 31C9                    	xor	cx,cx
 11656 000027C8 89CA                    	mov	dx,cx
 11657                                  do73:
 11658 000027CA E81C02                  	call	sysinit_parse
 11659 000027CD 7305                    	jnc	short if73	; parse error
 11660 000027CF E85602                  	call	badparm_p	;   and show messages and end the search loop.
 11661 000027D2 EB17                    	jmp	short sr73
 11662                                  if73:
 11663 000027D4 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 11664 000027D7 740A                    	je	short en73	; then end the $endloop
 11665                                  	;mov	al,[cs:rv_dword]
 11666 000027D9 2EA0[951F]              	mov	al,[cs:rv_byte]	; pick up the drive number
 11667 000027DD 2EA2[6320]              	mov	[cs:p_ldrv],al	; save it temporarily
 11668 000027E1 EBE7                    	jmp	short do73
 11669                                  en73:
 11670 000027E3 2EA0[6320]              	mov	al,[cs:p_ldrv]
 11671 000027E7 2EA2[A002]              	mov	[cs:NUM_CDS],al	; no error. really set the value now.
 11672                                  sr73:
 11673 000027EB E954FA                  	jmp	coff
 11674                                  
 11675                                  ;--------------------------------------------------------------------------
 11676                                  ; setting drive parameters
 11677                                  ;--------------------------------------------------------------------------
 11678                                  
 11679                                  tryp:
 11680 000027EE 80FC50                          cmp     ah,CONFIG_DRIVPARM ; 'P'
 11681 000027F1 7513                    	jne	short tryk
 11682                                  
 11683                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11684                                  ;;ifdef	MULTI_CONFIG
 11685                                  ;       call    query_user      ; query the user if config_cmd
 11686                                  ;       jc      short tryk	; has the CONFIG_OPTION_QUERY bit set
 11687                                  ;;endif
 11688                                  
 11689 000027F3 E8B608                  	call	parseline
 11690 000027F6 720B                    	jc	short trypbad
 11691 000027F8 E85A08                  	call	setparms
 11692 000027FB E89208                  	call	diddleback
 11693                                  
 11694                                  ; No error check here, because setparms and diddleback have no error 
 11695                                  ; returns, and setparms as coded now can return with carry set. 
 11696                                  ;       jc	short trypbad
 11697                                  
 11698                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11699 000027FE 7203                    	jc	short trypbad
 11700                                  
 11701 00002800 E93FFA                  	jmp	coff
 11702                                  trypbad:
 11703 00002803 E91602                  	jmp	badop
 11704                                  
 11705                                  ;--------------------------------------------------------------------------
 11706                                  ; setting internal stack parameters
 11707                                  ; stacks=m,n where
 11708                                  ;	m is the number of stacks (range 8 to 64,default 9)
 11709                                  ;	n is the stack size (range 32 to 512 bytes,default 128)
 11710                                  ; j.k. 5/5/86: stacks=0,0 implies no stack installation.
 11711                                  ;	any combinations that are not within the specified limits will
 11712                                  ;	result in "unrecognized command" error.
 11713                                  ;--------------------------------------------------------------------------
 11714                                  
 11715                                  ;**************************************************************************
 11716                                  ;									  *
 11717                                  ; function: parse the parameters of stacks= command.			  *
 11718                                  ;	    the minimum value for "number of stacks" and "stack size" is  *
 11719                                  ;	    8 and 32 each.  in the definition of sysparse value list,they *
 11720                                  ;	    are set to 0.  this is for accepting the exceptional case of  *
 11721                                  ;	    stacks=0,0 case (,which means do not install the stack.)	  *
 11722                                  ;	    so,after sysparse is done,we have to check if the entered	  *
 11723                                  ;	    values (stack_count,stack_size) are within the actual range,  *
 11724                                  ;	    (or if "0,0" pair has been entered.)			  *
 11725                                  ; input :								  *
 11726                                  ;	es:si -> parameters in command line.				  *
 11727                                  ; output:								  *
 11728                                  ;	set the variables stack_count,stack_size.			  *
 11729                                  ;									  *
 11730                                  ; subroutines to be called:						  *
 11731                                  ;	sysinit_parse							  *
 11732                                  ; logic:								  *
 11733                                  ; {									  *
 11734                                  ;	set di points to stks_parms;					  *
 11735                                  ;	set dx,cx to 0; 						  *
 11736                                  ;	while (end of command line)					  *
 11737                                  ;	{ sysinit_parse;						  *
 11738                                  ;	  if (no error) then						  *
 11739                                  ;	     { if (cx == 1) then /* first positional = stack count */	  *
 11740                                  ;		   p_stack_count = result_val._$P_picked_val;		  *
 11741                                  ;	       if (cx == 2) then /* second positional = stack size */	  *
 11742                                  ;		   p_stack_size = result_val._$P_picked_val;		  *
 11743                                  ;	     }								  *
 11744                                  ;	  else	/*error exit*/						  *
 11745                                  ;	     error exit;						  *
 11746                                  ;	};								  *
 11747                                  ;	here check p_stack_count,p_stack_size if it meets the condition;  *
 11748                                  ;	if o.k.,then set stack_count,stack_size;			  *
 11749                                  ;	 else error_exit;						  *
 11750                                  ; };									  *
 11751                                  ;**************************************************************************
 11752                                  
 11753                                  tryk:
 11754                                          ;if      stacksw
 11755                                  
 11756 00002806 80FC4B                          cmp     ah,CONFIG_STACKS ; 'K'
 11757 00002809 7403                    	je	short do_tryk
 11758                                  skip_it4:
 11759 0000280B E9A400                  	jmp	trys
 11760                                  do_tryk:
 11761                                  
 11762                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11763                                  ;;ifdef	MULTI_CONFIG
 11764                                  ;       call    query_user              ; query the user if config_cmd
 11765                                  ;       jc	short skip_it4		; has the CONFIG_OPTION_QUERY bit set
 11766                                  ;;endif
 11767                                  
 11768 0000280E BF[6420]                	mov	di,stks_parms
 11769 00002811 31C9                    	xor	cx,cx
 11770 00002813 89CA                    	mov	dx,cx
 11771                                  do79:
 11772 00002815 E8D101                  	call	sysinit_parse
 11773 00002818 730C                    	jnc	short if79		; parse error
 11774                                  
 11775 0000281A BA[833C]                	mov	dx,badstack		; "invalid stack parameter"
 11776 0000281D E83F0F                  	call	print			;  and show messages and end the search loop.
 11777 00002820 E85702                  	call	error_line
 11778 00002823 E98900                  	jmp	sr79
 11779                                  if79:
 11780 00002826 83F8FF                  	cmp	ax,_$P_RC_EOL		; end of line?
 11781 00002829 7415                    	je	short en79		; then end the $endloop
 11782                                  
 11783                                  	;mov	ax,[cs:rv_dword]
 11784 0000282B 2EA1[951F]              	mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
 11785 0000282F 83F901                  	cmp	cx,1
 11786 00002832 7506                    	jne	short if83
 11787                                  
 11788 00002834 2EA3[9920]              	mov	[cs:p_stack_count],ax
 11789 00002838 EB04                    	jmp	short en83
 11790                                  if83:
 11791 0000283A 2EA3[9B20]              	mov	[cs:p_stack_size],ax
 11792                                  en83:
 11793 0000283E EBD5                    	jmp	short do79
 11794                                  en79:
 11795 00002840 2E833E[9920]00          	cmp	word [cs:p_stack_count],0
 11796 00002846 7419                    	je	short if87
 11797                                  
 11798 00002848 2E833E[9920]08          	cmp	word [cs:p_stack_count],mincount ; 8
 11799 0000284E 7208                    	jb	short ll88
 11800 00002850 2E833E[9B20]20          	cmp	word [cs:p_stack_size],minsize ; 32
 11801 00002856 7307                    	jnb	short if88
 11802                                  ll88:
 11803 00002858 2EC706[9920]FFFF        	mov	word [cs:p_stack_count],-1 ; invalid
 11804                                  if88:
 11805 0000285F EB0F                    	jmp	short en87
 11806                                  if87:
 11807 00002861 2E833E[9B20]00          	cmp	word [cs:p_stack_size],0
 11808 00002867 7407                    	je	short en87
 11809 00002869 2EC706[9920]FFFF        	mov	word [cs:p_stack_count],-1 ; invalid
 11810                                  en87:
 11811 00002870 2E833E[9920]FF          	cmp	word [cs:p_stack_count],-1 ; invalid?
 11812 00002876 7520                    	jne	short if94
 11813                                  
 11814 00002878 2EC706[8A02]0900        	mov	word [cs:stack_count],defaultcount ; 9
 11815                                  					; reset to default value.
 11816 0000287F 2EC706[8C02]8000        	mov	word [cs:stack_size],defaultsize ; 128
 11817 00002886 2EC706[8E02]0000        	mov	word [cs:stack_addr],0
 11818                                  
 11819 0000288D BA[833C]                	mov	dx,badstack
 11820 00002890 E8CC0E                  	call	print
 11821 00002893 E8E401                  	call	error_line
 11822 00002896 EB17                    	jmp	short sr79
 11823                                  if94:
 11824 00002898 2EA1[9920]              	mov	ax,[cs:p_stack_count]
 11825 0000289C 2EA3[8A02]              	mov	[cs:stack_count],ax
 11826 000028A0 2EA1[9B20]              	mov	ax,[cs:p_stack_size]
 11827 000028A4 2EA3[8C02]              	mov	[cs:stack_size],ax
 11828 000028A8 2EC706[8E02]FFFF        	mov	word [cs:stack_addr],-1	; stacks= been accepted.
 11829                                  sr79:
 11830 000028AF E990F9                  	jmp	coff
 11831                                  
 11832                                  	;endif
 11833                                  
 11834                                  ;------------------------------------------------------------------------
 11835                                  ; shell command
 11836                                  ;------------------------------------------------------------------------
 11837                                  
 11838                                  trys:
 11839 000028B2 80FC53                          cmp     ah,CONFIG_SHELL ; 'S'
 11840 000028B5 753E                    	jne	short tryx
 11841                                  
 11842                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11843                                  ;;ifdef	MULTI_CONFIG
 11844                                  ;       call    query_user              ; query the user if config_cmd
 11845                                  ;       jc	short tryx		; has the CONFIG_OPTION_QUERY bit set
 11846                                  ;       mov	byte [cs:newcmd],1
 11847                                  ;;endif
 11848                                  
 11849                                  	;mov	word [cs:command_line],0 ; zap length,first byte of command-line
 11850                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11851 000028B7 2EC606[AA02]00          	mov	byte [cs:command_line+1],0
 11852                                  
 11853 000028BD BF[6E38]                        mov     di,commnd+1		; we already have the first char
 11854 000028C0 8845FF                          mov     [di-1],al               ; of the new shell in AL, save it now
 11855                                  storeshell:
 11856 000028C3 E88E01                  	call	getchr
 11857 000028C6 08C0                            or      al,al                   ; this is the normal case: "organize"
 11858 000028C8 7419                            jz	short getshparms	; put a ZERO right after the filename
 11859                                  
 11860 000028CA 3C20                            cmp     al," "                  ; this may happen if there are no args
 11861 000028CC 7205                            jb	short endofshell	; I suppose...
 11862 000028CE 8805                    	mov	[di],al
 11863 000028D0 47                      	inc	di
 11864                                          ;cmp    di,commnd+63		; this makes sure we don't overflow
 11865                                          ;jb	short storeshell	; commnd (the filename)
 11866                                          ;jmp	short endofshell
 11867                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11868 000028D1 EBF0                    	jmp	short storeshell
 11869                                  
 11870                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11871                                  ;getshparms:
 11872                                  ;	mov     byte [di],0		; zero-terminate the filename
 11873                                  ;	mov     di,command_line+1	; prepare to process the command-line
 11874                                  ;
 11875                                  ;parmloop:
 11876                                  ;	call	getchr
 11877                                  ;	cmp	al," "
 11878                                  ;	jb	short endofparms
 11879                                  ;	mov	[di],al
 11880                                  ;	inc	di
 11881                                  ;	cmp     di,command_line+126
 11882                                  ;	jb	short parmloop
 11883                                  ;endofparms:
 11884                                  ;	mov     cx,di
 11885                                  ;	sub     cx,command_line+1
 11886                                  ;	mov     [cs:command_line],cl
 11887                                  ;
 11888                                  ;endofshell:
 11889                                  ;	mov     byte [di],0		; zero-terminate the filename (or
 11890                                  ;					; the command-line as the case may be)
 11891                                  ;skipline:
 11892                                  ;       cmp     al,lf	; 0Ah		; the safest way to eat the rest of
 11893                                  ;       je	short endofline		; the line: watch for ever-present LF
 11894                                  ;call	getchr
 11895                                  ;       jnc	short skipline		; keep it up as long as there are chars
 11896                                  ;
 11897                                  ;endofline:
 11898                                  ;       jmp     conflp
 11899                                  
 11900                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11901                                  endofshell:
 11902 000028D3 C60500                       	mov     byte [di],0		; zero-terminate the filename (or
 11903                                  					; the command-line as the case may be)
 11904 000028D6 E87B01                  	call	getchr
 11905                                  skipline:
 11906 000028D9 3C0A                    	cmp     al,lf	; 0Ah		; the safest way to eat the rest of
 11907 000028DB 7403                    	je	short endofline		; the line: watch for ever-present LF
 11908 000028DD E87401                  	call	getchr
 11909                                  endofline:
 11910 000028E0 E93AF9                  	jmp     conflp
 11911                                  
 11912                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11913                                  getshparms:
 11914 000028E3 C60500                  	mov     byte [di],0		; zero-terminate the filename
 11915 000028E6 BF[AA02]                	mov     di,command_line+1	; prepare to process the command-line
 11916                                  parmloop:
 11917 000028E9 E86801                  	call	getchr
 11918 000028EC 3C20                    	cmp	al," " ; 20h
 11919 000028EE 72E3                    	jb	short endofshell
 11920 000028F0 8805                    	mov	[di],al
 11921 000028F2 47                      	inc	di
 11922 000028F3 EBF4                    	jmp	short parmloop
 11923                                  
 11924                                  ;------------------------------------------------------------------------
 11925                                  ; fcbs command
 11926                                  ;------------------------------------------------------------------------
 11927                                  
 11928                                  ;************************************************************************
 11929                                  ; function: parse the parameters of fcbs= command.			*
 11930                                  ;									*
 11931                                  ; input :								*
 11932                                  ;	es:si -> parameters in command line.				*
 11933                                  ; output:								*
 11934                                  ;	set the variables fcbs,keep.					*
 11935                                  ;									*
 11936                                  ; subroutines to be called:						*
 11937                                  ;	sysinit_parse							*
 11938                                  ; logic:								*
 11939                                  ; {									*
 11940                                  ;	set di points to fcbs_parms;					*
 11941                                  ;	set dx,cx to 0; 						*
 11942                                  ;	while (end of command line)					*
 11943                                  ;	{ sysparse;							*
 11944                                  ;	  if (no error) then						*
 11945                                  ;	     { if (cx == 1) then /* first positional = fcbs */		*
 11946                                  ;		   fcbs = result_val._$P_picked_val;			*
 11947                                  ;	       if (cx == 2) then /* second positional = keep */ 	*
 11948                                  ;		   keep = result_val._$P_picked_val;			*
 11949                                  ;	     }								*
 11950                                  ;	  else	/*error exit*/						*
 11951                                  ;	     error exit;						*
 11952                                  ;	};								*
 11953                                  ; };									*
 11954                                  ;************************************************************************
 11955                                  
 11956                                  tryx:
 11957 000028F5 80FC58                          cmp     ah,CONFIG_FCBS  ; 'X'
 11958                                          ;jne	short try1
 11959                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11960 000028F8 753C                    	jne	short tryy	; comment command
 11961                                  
 11962                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 11963                                  ;;ifdef	MULTI_CONFIG
 11964                                  ;       call    query_user      ; query the user if config_cmd
 11965                                  ;       jc	short try1	; has the CONFIG_OPTION_QUERY bit set
 11966                                  ;;endif
 11967                                  
 11968 000028FA BF[1820]                	mov	di,fcbs_parms
 11969 000028FD 31C9                    	xor	cx,cx
 11970 000028FF 89CA                    	mov	dx,cx
 11971                                  do98:
 11972 00002901 E8E500                  	call	sysinit_parse
 11973 00002904 7305                            jnc	short if98	; parse error
 11974 00002906 E81F01                          call    badparm_p       ;  and show messages and end the search loop.
 11975 00002909 EB28                    	jmp	short sr98
 11976                                  if98:
 11977 0000290B 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 11978 0000290E 7415                    	je	short en98	; then end the $endloop
 11979                                  
 11980                                  	;mov	al,[cs:rv_dword]
 11981 00002910 2EA0[951F]              	mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
 11982 00002914 83F901                  	cmp	cx,1		; the first positional?
 11983 00002917 7506                    	jne	short if102
 11984 00002919 2EA2[4D20]              	mov	[cs:p_fcbs],al
 11985 0000291D EB04                    	jmp	short en102
 11986                                  
 11987                                  if102:
 11988 0000291F 2EA2[4E20]              	mov	[cs:p_keep],al
 11989                                  en102:
 11990 00002923 EBDC                    	jmp	short do98
 11991                                  
 11992                                  en98:
 11993 00002925 2EA0[4D20]              	mov	al,[cs:p_fcbs]	 ; M017
 11994 00002929 2EA2[9E02]              	mov	[cs:FCBS],al	 ; M017
 11995 0000292D 2EC606[9F02]00          	mov	byte [cs:KEEP],0 ; M017
 11996                                  sr98:
 11997 00002933 E90CF9                  	jmp	coff
 11998                                  
 11999                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12000                                  ;-------------------------------------------------------------------------
 12001                                  ; comment= do nothing. just decrease chrptr,and increase count for correct
 12002                                  ;		line number
 12003                                  ;-------------------------------------------------------------------------
 12004                                  
 12005                                  tryy:
 12006 00002936 80FC59                  	cmp     ah,CONFIG_COMMENT ; 'Y'
 12007 00002939 750D                    	jne	short try0
 12008                                  
 12009                                  donothing:
 12010                                  	;dec	word [chrptr]
 12011                                  	;inc	word [count]
 12012                                  	; 02/11/2022
 12013 0000293B 2EFF0E[D603]            	dec	word [cs:chrptr]
 12014 00002940 2EFF06[D203]            	inc	word [cs:count]
 12015 00002945 E9FAF8                  	jmp	coff
 12016                                  
 12017                                  ;------------------------------------------------------------------------
 12018                                  ; rem command
 12019                                  ;------------------------------------------------------------------------
 12020                                  
 12021                                  try0:				; do nothing with this line.
 12022 00002948 80FC30                  	cmp     ah,CONFIG_REM ; '0'
 12023 0000294B 74EE                    	je	short donothing
 12024                                  
 12025                                  ; 07/04/2019 - Retro DOS v4.0
 12026                                  
 12027                                  ;-----------------------------------------------------------------------
 12028                                  ; switches command
 12029                                  ;-----------------------------------------------------------------------
 12030                                  
 12031                                  ;***********************************************************************
 12032                                  ;								       *
 12033                                  ; function: parse the option switches specified.		       *
 12034                                  ; note - this command is intended for the future use also.	       *
 12035                                  ; when we need to set system data flag,use this command.	       *
 12036                                  ;								       *
 12037                                  ; input :							       *
 12038                                  ;	es:si -> parameters in command line.			       *
 12039                                  ; output:							       *
 12040                                  ;	p_swit_k set if /k option chosen.			       *
 12041                                  ;								       *
 12042                                  ; subroutines to be called:					       *
 12043                                  ;	sysinit_parse						       *
 12044                                  ; logic:							       *
 12045                                  ; {								       *
 12046                                  ;	set di points to swit_parms;  /*parse control definition*/     *
 12047                                  ;	set dx,cx to 0; 					       *
 12048                                  ;	while (end of command line)				       *
 12049                                  ;	{ sysinit_parse;					       *
 12050                                  ;	  if (no error) then					       *
 12051                                  ;	       if (result_val._$P_synonym_ptr == swit_k) then	       *
 12052                                  ;		    p_swit_k = 1				       *
 12053                                  ;	       endif						       *
 12054                                  ;	  else {show error message;error exit}			       *
 12055                                  ;	};							       *
 12056                                  ; };								       *
 12057                                  ;								       *
 12058                                  ;***********************************************************************
 12059                                  
 12060                                  SUPPRESS_WINA20	EQU 00000010b	; M025 ; (DOSSYM.INC, MSDOS 6.0)
 12061                                  
 12062                                  try1:
 12063 0000294D 80FC31                          cmp     ah,CONFIG_SWITCHES ; '1'
 12064 00002950 7403                    	je	short do_try1	; switches= command entered?
 12065                                  skip_it5:
 12066                                  	;jmp	tryv
 12067                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12068 00002952 E98200                  	jmp	tryz
 12069                                  
 12070                                  do_try1:
 12071                                  
 12072                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12073                                  ;;ifdef	MULTI_CONFIG
 12074                                  ;       call    query_user      ; query the user if config_cmd
 12075                                  ;       jc	short skip_it5	; has the CONFIG_OPTION_QUERY bit set
 12076                                  ;;endif
 12077                                  
 12078 00002955 BF[B220]                	mov	di,swit_parms
 12079 00002958 31C9                    	xor	cx,cx
 12080 0000295A 89CA                    	mov	dx,cx
 12081                                  do110:
 12082 0000295C E88A00                  	call	sysinit_parse
 12083 0000295F 7305                    	jnc	short if110	; parse error
 12084 00002961 E8C400                  	call	badparm_p	;  and show messages and end the search loop.
 12085 00002964 EB6E                    	jmp	short sr110
 12086                                  
 12087                                  if110:
 12088 00002966 83F8FF                  	cmp	ax,_$P_RC_EOL	; end of line?
 12089 00002969 7433                    	je	short en110	; then jmp to $endloop for semantic check
 12090                                  
 12091                                  	;cmp	word [cs:result_val_swoff],swit_k
 12092 0000296B 2E813E[931F][CA20]      	cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_k 
 12093 00002972 7508                    	jne	short if115	;				;M059
 12094 00002974 2EC606[E520]01          	mov	byte [cs:p_swit_k],1	; set the flag
 12095 0000297A EBE0                    	jmp	short do110
 12096                                  if115:								;M059
 12097                                  	;cmp	word [cs:result_val_swoff],swit_t
 12098 0000297C 2E813E[931F][D620]      	cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_t	;M059
 12099 00002983 7508                    	jne	short if116					;M059 M063
 12100 00002985 2EC606[E620]01          	mov	byte [cs:p_swit_t],1				;M059
 12101 0000298B EBCF                    	jmp	short do110					;M059
 12102                                  if116:
 12103                                  	;cmp	word [cs:result_val_swoff],swit_w
 12104 0000298D 2E813E[931F][E220]      	cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_w	;M063
 12105 00002994 75C6                    	jne	short do110					;M063
 12106 00002996 2EC606[E720]01          	mov	byte [cs:p_swit_w],1				;M063
 12107 0000299C EBBE                    	jmp	short do110					;M063
 12108                                  en110:
 12109 0000299E 2E803E[E520]01          	cmp	byte [cs:p_swit_k],1	; if /k entered,
 12110 000029A4 1E                      	push	ds
 12111                                  	;;mov	ax,Bios_Data
 12112                                  	;mov	ax,KERNEL_SEGMENT ; 0070h
 12113                                  	; 21/10/2022
 12114 000029A5 B87000                  	mov	ax,DOSBIODATASEG ; 0070h
 12115 000029A8 8ED8                    	mov	ds,ax
 12116 000029AA 750A                    	jne	short if117
 12117 000029AC C606E50400              	mov	byte [keyrd_func],0 ; 4E5h ; use the conventional keyboard functions
 12118 000029B1 C606E60401              	mov	byte [keysts_func],1 ; 4E6h (for MSDOS 6.21 IO.SYS)
 12119                                  if117:
 12120 000029B6 2EA0[E620]              	mov	al,[cs:p_swit_t]				;M059
 12121 000029BA A2F204                  	mov	[t_switch],al	; 4F2h (for MSDOS 6.21 IO.SYS)	;M059
 12122                                  
 12123 000029BD 2E803E[E720]00          	cmp	byte [cs:p_swit_w],0				;M063
 12124 000029C3 740E                    	je	short skip_dos_flag				;M063
 12125 000029C5 06                      	push	es
 12126 000029C6 53                      	push	bx
 12127 000029C7 B452                    	mov	ah,GET_IN_VARS ; 52h				;M063
 12128 000029C9 CD21                    	int	21h						;M063
 12129                                  			; DOS - 2+ internal - GET LIST OF LISTS
 12130                                  			; Return: ES:BX -> DOS list of lists
 12131                                  	;or	bytes [es:86h],2
 12132 000029CB 26800E860002            	or	byte [es:DOS_FLAG_OFFSET],SUPPRESS_WINA20 ; 2	;M063
 12133 000029D1 5B                      	pop	bx
 12134 000029D2 07                      	pop	es
 12135                                  skip_dos_flag:							;M063
 12136 000029D3 1F                      	pop	ds
 12137                                  sr110:
 12138 000029D4 E96BF8                  	jmp	coff
 12139                                  
 12140                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12141                                  ;
 12142                                  ;tryv:
 12143                                  ;
 12144                                  ;;ifdef	MULTI_CONFIG
 12145                                  ;;------------------------------------------------------------------------
 12146                                  ;; set command (as in "set var=value<cr/lf>")
 12147                                  ;;------------------------------------------------------------------------
 12148                                  ;
 12149                                  ;       cmp     ah,CONFIG_SET  ; 'V'
 12150                                  ;       jne	short tryn
 12151                                  ;       call    query_user      ; query the user if config_cmd
 12152                                  ;       jc	short tryn 	; has the CONFIG_OPTION_QUERY bit set
 12153                                  ;       call    copy_envvar     ; copy var at ES:SI to "config_wrkseg"
 12154                                  ;       jnc	short sr110	; no error
 12155                                  ;err:    
 12156                                  ;	call    error_line      ; whoops, display error in line XXX
 12157                                  ;       jmp     short sr110     ; jump to coff (to skip to next line)
 12158                                  ;
 12159                                  ;;------------------------------------------------------------------------
 12160                                  ;; numlock command (as in "numlock=on|off")
 12161                                  ;;------------------------------------------------------------------------
 12162                                  ;tryn:
 12163                                  ;       cmp     ah,CONFIG_NUMLOCK  ;'N'
 12164                                  ;       jne	short tryy            ;
 12165                                  ;       call    query_user      ; query thye user if config_cmd
 12166                                  ;       jc	short tryy	; has the CONFIG_OPTION_QUERY bit set
 12167                                  ;       call    set_numlock
 12168                                  ;       jc	short err
 12169                                  ;       jmp	short sr110	; all done
 12170                                  ;
 12171                                  ;;endif	;MULTI_CONFIG
 12172                                  
 12173                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12174                                  ;;-------------------------------------------------------------------------
 12175                                  ;; comment= do nothing. just decrese chrptr,and increase count for correct
 12176                                  ;;		line number
 12177                                  ;;-------------------------------------------------------------------------
 12178                                  ;
 12179                                  ;tryy:
 12180                                  ;       cmp     ah,CONFIG_COMMENT ; 'Y'
 12181                                  ;	jne	short try0
 12182                                  ;donothing:
 12183                                  ;	dec	word [chrptr]
 12184                                  ;	inc	word [count]
 12185                                  ;	jmp	coff
 12186                                  ;
 12187                                  ;;------------------------------------------------------------------------
 12188                                  ;; rem command
 12189                                  ;;------------------------------------------------------------------------
 12190                                  ;
 12191                                  ;try0:				;do nothing with this line.
 12192                                  ;	cmp     ah,CONFIG_REM ; '0'
 12193                                  ;	je	short donothing
 12194                                  
 12195                                  ; 30/10/2022
 12196                                  ; (MSSOS 5.0 IO.SYS - SYSINIT:29D7h)
 12197                                  
 12198                                  ;------------------------------------------------------------------------
 12199                                  ; bogus command
 12200                                  ;------------------------------------------------------------------------
 12201                                  
 12202                                  tryz:
 12203 000029D7 80FCFF                          cmp     ah,0FFh		;null command? (BUGBUG - who sets FFh anyway?)
 12204                                  	;je	short donothing
 12205                                  	; 02/11/2022
 12206 000029DA 740A                    	je	short tryz_donothing
 12207                                  
 12208 000029DC FF0E[D603]              	dec	word [chrptr]
 12209 000029E0 FF06[D203]              	inc	word [count]
 12210 000029E4 EB36                    	jmp	short badop
 12211                                  
 12212                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 12213                                  tryz_donothing:
 12214 000029E6 E952FF                  	jmp	donothing
 12215                                  
 12216                                  ; 07/04/2019 - Retro DOS v4.0
 12217                                  
 12218                                  ;------------------------------------------------------------------------------
 12219                                  
 12220                                  ; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12221                                  ;
 12222                                  ;
 12223                                  ;;***	CheckProtmanArena -- special hack for adjusting alloclim with Protman$
 12224                                  ;;
 12225                                  ;;	adjusts alloclim if Protman$ reduced our arena through a manual hack.
 12226                                  ;
 12227                                  ;CheckProtmanArena:
 12228                                  ;	push	es
 12229                                  ;	mov	ax,[cs:area]	; get our arena header
 12230                                  ;	dec	ax
 12231                                  ;	mov	es,ax
 12232                                  ;	add	ax,[es:3]	; find end of arena
 12233                                  ;	inc	ax
 12234                                  ;	cmp	ax,[cs:ALLOCLIM] ; is it less than alloclim?
 12235                                  ;	ja	short CheckProtmanDone
 12236                                  ;
 12237                                  ;	mov	[cs:ALLOCLIM],ax ; reduce alloclim then
 12238                                  ;CheckProtmanDone:
 12239                                  ;	pop	es
 12240                                  ;	retn
 12241                                  
 12242                                  ;------------------------------------------------------------------------------
 12243                                  
 12244                                  sysinit_parse:
 12245                                  
 12246                                  ;------------------------------------------------------------------------------
 12247                                  ;set up registers for sysparse
 12248                                  ;in)	es:si -> command line in confbot
 12249                                  ;	di -> offset of the parse control definition.
 12250                                  ;
 12251                                  ;out)	calls sysparse.
 12252                                  ;	carry will set if parse error.
 12253                                  ;	*** the caller should check the eol condition by looking at ax
 12254                                  ;	*** after each call.
 12255                                  ;	*** if no parameters are found,then ax will contain a error code.
 12256                                  ;	*** if the caller needs to look at the synomym@ of the result,
 12257                                  ;	***  the caller should use cs:@ instead of es:@.
 12258                                  ;	cx register should be set to 0 at the first time the caller calls this
 12259                                  ;	 procedure.
 12260                                  ;	ax - exit code
 12261                                  ;	bl - terminated delimeter code
 12262                                  ;	cx - new positional ordinal
 12263                                  ;	si - set to pase scanned operand
 12264                                  ;	dx - selected result buffer
 12265                                  ;------------------------------------------------------------------------------
 12266                                  
 12267                                  	; 24/10/2022
 12268 000029E9 06                      	push	es			;save es,ds
 12269 000029EA 1E                      	push	ds
 12270                                  
 12271 000029EB 06                      	push	es
 12272 000029EC 1F                      	pop	ds			;now ds:si -> command line
 12273                                  
 12274 000029ED 0E                      	push	cs
 12275 000029EE 07                      	pop	es			;now es:di -> control definition
 12276                                  
 12277 000029EF 2E8C1E[5F16]            	mov	[cs:badparm_seg],ds	;save the pointer to the parm
 12278 000029F4 2E8936[5D16]            	mov	[cs:badparm_off],si	; we are about to parse for badparm msg.
 12279 000029F9 BA0000                  	mov	dx,0
 12280 000029FC E808ED                  	call	SysParse
 12281 000029FF 83F800                  	cmp	ax,_$P_No_Error	; 0	;no error
 12282                                  
 12283                                  ;**cas note:  when zero true after cmp, carry clear
 12284                                  
 12285 00002A02 7405                    	je	short ll4
 12286                                  	; 24/10/2022 (MSDOS 5.0 IO.SYS compatibility, SYSINIT:2A02h)
 12287                                  	;je	short en4
 12288 00002A04 83F8FF                  	cmp	ax,_$P_RC_EOL ; 0FFFFh	;or the end of line?
 12289 00002A07 7503                    	jne	short if4
 12290                                  ll4:
 12291 00002A09 F8                      	clc
 12292 00002A0A EB01                    	jmp	short en4
 12293                                  if4:
 12294                                  	; 24/10/2022
 12295 00002A0C F9                      	stc
 12296                                  en4:
 12297 00002A0D 1F                      	pop	ds
 12298 00002A0E 07                      	pop	es
 12299 00002A0F C3                      	retn
 12300                                  
 12301                                  ;----------------------------------------------------------------------------
 12302                                  ;
 12303                                  ; procedure : badop_p
 12304                                  ;
 12305                                  ;             same thing as badop,but will make sure to set ds register back
 12306                                  ;             to sysinitseg and return back to the caller.
 12307                                  ;
 12308                                  ;----------------------------------------------------------------------------
 12309                                  
 12310                                  badop_p:
 12311 00002A10 0E                      	push	cs
 12312 00002A11 1F                      	pop	ds		;set ds to configsys seg.
 12313 00002A12 BA[443B]                	mov	dx,badopm
 12314 00002A15 E8470D                  	call	print
 12315 00002A18 E85F00                          call    error_line
 12316 00002A1B C3                      	retn
 12317                                  
 12318                                  ;----------------------------------------------------------------------------
 12319                                  ;
 12320                                  ; label : badop
 12321                                  ;
 12322                                  ;----------------------------------------------------------------------------
 12323                                  
 12324                                  badop:	
 12325 00002A1C BA[443B]                	mov	dx,badopm	;want to print command error "unrecognized command..."
 12326 00002A1F E83D0D                  	call	print
 12327 00002A22 E85500                  	call	error_line	;show "error in config.sys ..." .
 12328 00002A25 E91AF8                  	jmp	coff
 12329                                  
 12330                                  ;----------------------------------------------------------------------------
 12331                                  ;
 12332                                  ; procedure : badparm_p
 12333                                  ;
 12334                                  ;             show "bad command or parameters - xxxxxx"
 12335                                  ;             in badparm_seg,badparm_off -> xxxxx
 12336                                  ;
 12337                                  ;----------------------------------------------------------------------------
 12338                                  
 12339                                  	; 24/10/2022
 12340                                  badparm_p:
 12341 00002A28 1E                      	push	ds
 12342 00002A29 52                      	push	dx
 12343 00002A2A 56                      	push	si
 12344                                  
 12345 00002A2B 0E                      	push	cs
 12346 00002A2C 1F                      	pop	ds
 12347                                  
 12348 00002A2D BA[6B3B]                	mov	dx,badparm
 12349 00002A30 E82C0D                  	call	print			;"bad command or parameters - "
 12350 00002A33 C536[5D16]              	lds	si,[badparm_ptr]
 12351                                  
 12352                                  ;	print "xxxx" until cr.
 12353                                  
 12354                                  do1:
 12355 00002A37 8A14                    	mov	dl,[si]			; get next character
 12356 00002A39 80FA0D                  	cmp	dl,cr ; 0Dh		; is a carriage return?
 12357 00002A3C 7407                    	je	short en1			; exit loop if so
 12358                                  
 12359 00002A3E B402                    	mov	ah,2 ; STD_CON_OUTPUT	; function 2
 12360 00002A40 CD21                    	int	21h			; display character
 12361 00002A42 46                      	inc	si			; next character
 12362 00002A43 EBF2                    	jmp	short do1
 12363                                  en1:
 12364 00002A45 0E                      	push	cs
 12365 00002A46 1F                      	pop	ds
 12366                                  
 12367 00002A47 BA[683B]                	mov	dx,crlfm
 12368 00002A4A E8120D                  	call	print
 12369 00002A4D E82A00                  	call	error_line
 12370                                  
 12371 00002A50 5E                      	pop	si
 12372 00002A51 5A                      	pop	dx
 12373 00002A52 1F                      	pop	ds
 12374                                  badparmp_ret:
 12375 00002A53 C3                      	retn
 12376                                  
 12377                                  ;----------------------------------------------------------------------------
 12378                                  ;
 12379                                  ; procedure : getchr
 12380                                  ;
 12381                                  ;----------------------------------------------------------------------------
 12382                                  
 12383                                  	; 24/10/2022
 12384                                  getchr:
 12385 00002A54 51                      	push	cx
 12386 00002A55 8B0E[D203]              	mov	cx,[count]
 12387 00002A59 E312                    	jcxz	nochar
 12388                                  
 12389 00002A5B 8B36[D603]              	mov	si,[chrptr]
 12390 00002A5F 268A04                  	mov	al,[es:si]
 12391 00002A62 FF0E[D203]              	dec	word [count]
 12392 00002A66 FF06[D603]              	inc	word [chrptr]
 12393 00002A6A F8                      	clc
 12394                                  get_ret:
 12395 00002A6B 59                      	pop	cx
 12396 00002A6C C3                      	retn
 12397                                  nochar: 
 12398 00002A6D F9                      	stc
 12399 00002A6E EBFB                    	jmp	short get_ret
 12400                                  
 12401                                  ;----------------------------------------------------------------------------
 12402                                  ;
 12403                                  ; procedure : incorrect_order
 12404                                  ;
 12405                                  ;             show "incorrect order in config.sys ..." message.
 12406                                  ;
 12407                                  ;----------------------------------------------------------------------------
 12408                                  
 12409                                  incorrect_order:
 12410 00002A70 BA[A03C]                	mov	dx,badorder
 12411 00002A73 E8E90C                  	call	print
 12412 00002A76 E80D00                  	call	showlinenum
 12413 00002A79 C3                      	retn
 12414                                  
 12415                                  ;----------------------------------------------------------------------------
 12416                                  ;
 12417                                  ; procedure : error_line
 12418                                  ;
 12419                                  ;             show "error in config.sys ..." message.
 12420                                  ;
 12421                                  ;----------------------------------------------------------------------------
 12422                                  
 12423                                  	; 24/10/2022
 12424                                  error_line:
 12425 00002A7A 0E                      	push	cs
 12426 00002A7B 1F                      	pop	ds
 12427 00002A7C BA[C63C]                	mov	dx,errorcmd
 12428 00002A7F E8DD0C                  	call	print
 12429 00002A82 E80100                  	call	showlinenum
 12430 00002A85 C3                      	retn
 12431                                  
 12432                                  ;----------------------------------------------------------------------------
 12433                                  ;
 12434                                  ; procedure : showlinenum
 12435                                  ;
 12436                                  ; convert the binary linecount to decimal ascii string in showcount
 12437                                  ;and display showcount at the current curser position.
 12438                                  ;in.) linecount
 12439                                  ;
 12440                                  ;out) the number is printed.
 12441                                  ;
 12442                                  ;----------------------------------------------------------------------------
 12443                                  
 12444                                  	; 24/10/2022
 12445                                  showlinenum:
 12446 00002A86 06                      	push	es
 12447 00002A87 1E                      	push	ds
 12448 00002A88 57                      	push	di
 12449                                  
 12450 00002A89 0E                      	push	cs
 12451 00002A8A 07                      	pop	es		; es=cs
 12452                                  
 12453 00002A8B 0E                      	push	cs
 12454 00002A8C 1F                      	pop	ds
 12455                                  
 12456 00002A8D BF[3103]                	mov	di,showcount+4	; di -> the least significant decimal field.
 12457 00002A90 B90A00                  	mov	cx,10		; decimal divide factor
 12458 00002A93 2EA1[2B03]              	mov	ax,[cs:linecount]
 12459                                  sln_loop:
 12460 00002A97 83F80A                  	cmp	ax,10		; < 10?
 12461 00002A9A 720C                    	jb	short sln_last
 12462                                  
 12463 00002A9C 31D2                    	xor	dx,dx
 12464 00002A9E F7F1                    	div	cx
 12465 00002AA0 80CA30                  	or	dl,30h		; add "0" (= 30h) to make it an ascii.
 12466 00002AA3 8815                    	mov	[di],dl
 12467 00002AA5 4F                      	dec	di
 12468 00002AA6 EBEF                    	jmp	short sln_loop
 12469                                  
 12470                                  sln_last:
 12471 00002AA8 0C30                    	or	al,30h	; "0"
 12472 00002AAA 8805                    	mov	[di],al
 12473 00002AAC 89FA                    	mov	dx,di
 12474 00002AAE E8AE0C                  	call	print		; show it.
 12475 00002AB1 5F                      	pop	di
 12476 00002AB2 1F                      	pop	ds
 12477 00002AB3 07                      	pop	es
 12478 00002AB4 C3                      	retn
 12479                                  
 12480                                  ; 07/04/2019 - Retro DOS v4.0
 12481                                  ; (MSDOS 6.21 IO.SYS, SYSINIT:2E44h)
 12482                                  
 12483                                  ;----------------------------------------------------------------------------
 12484                                  ;
 12485                                  ; procedure : ProcDOS
 12486                                  ;
 12487                                  ;	Process the result of DOS= parsing
 12488                                  ;
 12489                                  ;	result_val._$P_item_tag	= 1 for DOS=HIGH
 12490                                  ;				= 2 for DOS=LOW
 12491                                  ;				= 3 for DOS=UMB
 12492                                  ;				= 4 for DOS=NOUMB
 12493                                  ;----------------------------------------------------------------------------
 12494                                  
 12495                                  	; 01/11/2022 - Retro DOS v4.0 (Modififed MSDOS 5.0 IO.SYS)
 12496                                  	; (SYTSINIT:2AB5h)
 12497                                  ProcDOS:
 12498 00002AB5 30E4                    	xor	ah,ah
 12499                                  	;mov	al,[cs:result_val_itag]
 12500 00002AB7 2EA0[921F]              	mov	al,[cs:result_val+_$P_Result_Blk.Item_Tag]
 12501 00002ABB 48                      	dec	ax
 12502 00002ABC 741B                    	jz	short pd_hi
 12503 00002ABE 48                      	dec	ax
 12504 00002ABF 7411                    	jz	short pd_lo
 12505 00002AC1 48                      	dec	ax
 12506 00002AC2 7407                    	jz	short pd_umb
 12507 00002AC4 2EC606[3921]00          	mov	byte [cs:DevUMB],0
 12508 00002ACA C3                      	retn
 12509                                  pd_umb:
 12510 00002ACB 2EC606[3921]FF          	mov	byte [cs:DevUMB],0FFh
 12511 00002AD1 C3                      	retn
 12512                                  pd_lo:
 12513 00002AD2 2EC606[6A02]00          	mov	byte [cs:runhigh],0
 12514 00002AD8 C3                      	retn
 12515                                  pd_hi:
 12516 00002AD9 2EC606[6A02]FF          	mov	byte [cs:runhigh],0FFh
 12517 00002ADF C3                      	retn
 12518                                  
 12519                                  ;----------------------------------------------------------------------------
 12520                                  ;
 12521                                  ; procedure : LieInt12Mem
 12522                                  ;
 12523                                  ;	Input : DevEntry points to Device Start address (offset == 0)
 12524                                  ;		alloclim set to the limit of low memory.
 12525                                  ;
 12526                                  ;	Output : none
 12527                                  ;
 12528                                  ;	Changes the ROM BIOS variable which stores the total low memory
 12529                                  ;	If a 3com device driver (any character device with name 'PROTMAN$')
 12530                                  ;	is being loaded alloclim is converted into Ks and stored in 40:13h
 12531                                  ;	Else if a device driver being loaded into UMB the DevLoadEnd is
 12532                                  ;	converted into Ks and stored in 40:13h
 12533                                  ;
 12534                                  ;----------------------------------------------------------------------------
 12535                                  
 12536                                  LieInt12Mem:
 12537 00002AE0 2EA1[A302]              	mov	ax,[cs:ALLOCLIM]	; lie INT 12 as alloclim
 12538                                  					; assuming that it is 3Com
 12539 00002AE4 E84D00                  	call	IsIt3Com		; Is it 3Com driver?
 12540 00002AE7 740C                    	jz	short lim_set		; yes, lie to him differently
 12541                                  	; 13/05/2019
 12542 00002AE9 2E803E[4821]00          	cmp	byte [cs:DeviceHi],0	; Is the DD being loaded in UMB
 12543 00002AEF 7407                    	je	short limx		; no, don't lie
 12544 00002AF1 2EA1[2F21]              	mov	ax,[cs:DevLoadEnd]	; lie INT 12 as end of UMB
 12545                                  lim_set:
 12546                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12547 00002AF5 E80100                  	call	SetInt12Mem
 12548                                  limx:
 12549 00002AF8 C3                      	retn
 12550                                  
 12551                                  ;----------------------------------------------------------------------------
 12552                                  ;
 12553                                  ; procedure : SetInt12Mem
 12554                                  ;
 12555                                  ;	Input : AX = Memory size to be set (in paras)
 12556                                  ;	Output : none
 12557                                  ;
 12558                                  ;	Sets the variable 40:13 to the memory size passed in AX
 12559                                  ;	It saves the old value in 40:13 in OldInt12Mem,
 12560                                  ;	It also sets a flag Int12Lied to 0ffh, which is checked before
 12561                                  ;	restoring the value of 40:13
 12562                                  ;
 12563                                  ;----------------------------------------------------------------------------
 12564                                  
 12565                                  	; 01/11/2022
 12566                                  SetInt12Mem:
 12567 00002AF9 1E                      	push	ds
 12568 00002AFA BB4000                  	mov	bx,40h
 12569 00002AFD 8EDB                    	mov	ds,bx			; ROM BIOS Data Segment
 12570 00002AFF 8B1E1300                	mov	bx,[13h]		; INT 12 memory variable
 12571 00002B03 2E891E[4C21]            	mov	[cs:OldInt12Mem],bx	; save it
 12572 00002B08 B106                    	mov	cl,6
 12573 00002B0A D3E8                    	shr	ax,cl			; convert paras into Ks
 12574 00002B0C A31300                  	mov	[13h],ax		; Lie
 12575 00002B0F 2EC606[4B21]FF          	mov	byte [cs:Int12Lied],0FFh ; mark that we are lying
 12576 00002B15 1F                      	pop	ds
 12577                                  ;limx:
 12578 00002B16 C3                      	retn
 12579                                  
 12580                                  ;----------------------------------------------------------------------------
 12581                                  ;
 12582                                  ; procedure : TrueInt12Mem
 12583                                  ;
 12584                                  ;	Input : Int12Lied = 0 if we are not lying currently
 12585                                  ;			  = 0ffh if we are lying
 12586                                  ;		OldInt12Mem = Saved value of 40:13h
 12587                                  ;
 12588                                  ;	Output : none
 12589                                  ;
 12590                                  ;	Resets the INT 12 Memory variable if we were lying about int 12
 12591                                  ;	and resets the flag which indicates that we were lying
 12592                                  ;
 12593                                  ;----------------------------------------------------------------------------
 12594                                  
 12595                                  TrueInt12Mem:
 12596 00002B17 2E803E[4B21]00          	cmp	byte [cs:Int12Lied],0	; were we lying so far?
 12597                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS, SYS.INIT:2B1Dh)
 12598                                  	;mov	byte [cs:Int12Lied],0	; reset it anyway
 12599 00002B1D 7414                    	je	short timx		; no, we weren't
 12600 00002B1F 2EC606[4B21]00          	mov	byte [cs:Int12Lied],0
 12601 00002B25 1E                      	push	ds
 12602 00002B26 B84000                  	mov	ax,40h
 12603 00002B29 8ED8                    	mov	ds,ax
 12604 00002B2B 2EA1[4C21]              	mov	ax,[cs:OldInt12Mem]
 12605 00002B2F A31300                  	mov	[13h],ax		; restore INT 12 memory
 12606 00002B32 1F                      	pop	ds
 12607                                  timx:
 12608 00002B33 C3                      	retn
 12609                                  
 12610                                  ;----------------------------------------------------------------------------
 12611                                  ;
 12612                                  ; procedure : IsIt3Com?
 12613                                  ;
 12614                                  ;	Input : DevEntry = Seg:0 of device driver
 12615                                  ;	Output : Zero flag set if device name is 'PROTMAN$'
 12616                                  ;		 else Zero flag is reset
 12617                                  ;
 12618                                  ;----------------------------------------------------------------------------
 12619                                  
 12620                                  IsIt3Com:
 12621 00002B34 1E                      	push	ds
 12622 00002B35 06                      	push	es
 12623 00002B36 56                      	push	si
 12624 00002B37 2EC536[3121]            	lds	si,[cs:DevEntry]	; ptr to device header
 12625 00002B3C 83C60A                  	add	si,SYSDEV.NAME ; 10 	; ptr device name
 12626 00002B3F 0E                      	push	cs
 12627 00002B40 07                      	pop	es
 12628 00002B41 BF[4E21]                	mov	di,ThreeComName
 12629 00002B44 B90800                  	mov	cx,8			; name length
 12630 00002B47 F3A6                    	rep	cmpsb
 12631 00002B49 5E                      	pop	si
 12632 00002B4A 07                      	pop	es
 12633 00002B4B 1F                      	pop	ds
 12634 00002B4C C3                      	retn
 12635                                  
 12636                                  ;M020 : BEGIN
 12637                                  ;----------------------------------------------------------------------------
 12638                                  
 12639                                  UpdatePDB:
 12640 00002B4D 1E                      	push	ds
 12641 00002B4E B462                    	mov	ah,62h
 12642 00002B50 CD21                    	int	21h	; DOS - 3+ - GET PSP ADDRESS
 12643 00002B52 8EDB                    	mov	ds,bx
 12644 00002B54 2E8B1E[A302]            	mov	bx,[cs:ALLOCLIM]
 12645                                  	;mov	[2],bx
 12646 00002B59 891E0200                	mov	[PDB.BLOCK_LEN],bx
 12647 00002B5D 1F                      	pop	ds
 12648 00002B5E C3                      	retn
 12649                                  
 12650                                  ; M020 : END
 12651                                  
 12652                                  ;----------------------------------------------------------------------------
 12653                                  
 12654                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 12655                                  
 12656                                  %if 0
 12657                                  
 12658                                  ;include highload.inc	; Routines for devicehigh parsing, control of HIDDEN
 12659                                  ;include highexit.inc	; umb's, etc
 12660                                  
 12661                                  ; ----------------------------------------------------------------------
 12662                                  ; HIGHLOAD.INC (MSDOS 6.0 - 1991) 	
 12663                                  ; ----------------------------------------------------------------------
 12664                                  ; 07/04/2019 - Retro DOS v4.0
 12665                                  
 12666                                  ;******************************************************************************
 12667                                  ;
 12668                                  ; This file contains routines needed to parse and implement user-given
 12669                                  ; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
 12670                                  ; and Parsevar() are used to parse this data and place it in encoded form into
 12671                                  ; the variables in highvar.inc, for use by the rest of the routines.
 12672                                  ;
 12673                                  ; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
 12674                                  ;    DEVICEHIGH SIZE=hhhhhh module opts
 12675                                  ; Or, DeviceHigh and LoadHigh accept any of the following:
 12676                                  ;    DH/LH module opts
 12677                                  ;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
 12678                                  ;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
 12679                                  ; The initial UMB,SIZE pair designates the module's load address; the remainder
 12680                                  ; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
 12681                                  ; available during the load.
 12682                                  ;
 12683                                  ; When an actual load is ready to be performed, a call to HideUMBs() will
 12684                                  ; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
 12685                                  ; upper-memory block which was not specified by the user... in addition, if
 12686                                  ; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
 12687                                  ; elements in that umb SAVE the lower-half of the newly-shrunken one are also
 12688                                  ; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
 12689                                  ; free any UMBs so allocated.
 12690                                  ;
 12691                                  ; When a device driver loads, there is the additional problem of allocating its
 12692                                  ; initial load site; this should be restricted to the first UMB specified on
 12693                                  ; the command-line. The function FreezeUM temporarily allocates all remaining
 12694                                  ; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
 12695                                  ; UMB. Then the initial allocation may be made, and a call to UnFreeze will
 12696                                  ; return any so-allocated memory elements to FREE, for the true load. Note
 12697                                  ; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
 12698                                  ;
 12699                                  ;******************************************************************************
 12700                                  
 12701                                  SWTCH	equ	'/'		; Switch character
 12702                                  
 12703                                  DOS_CHECK_STRATEGY  equ	5800h	; Int 21h, Func 58h, Svc 0 = check alloc strat
 12704                                  DOS_SET_STRATEGY    equ	5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
 12705                                  DOS_CHECK_UMBLINK   equ	5802h	; Int 21h, Func 58h, Svc 2 = check link state
 12706                                  DOS_GET_UMBLINK	    equ 5802h ; 20/04/2019
 12707                                  DOS_SET_UMBLINK     equ	5803h	; Int 21h, Func 58h, Svc 3 = set link state
 12708                                  DOS_GET_DOS_LISTS   equ	  52h	; Int 21h, Func 52h = return list of lists
 12709                                  DOS_UMB_HEAD        equ	  8Ch	; Offset from ES (after func52h) to get UMBHead
 12710                                  
 12711                                  CR	equ	0Dh		; Carriage Return
 12712                                  LF	equ	0Ah		; Line Feed
 12713                                  TAB	equ	09h		; Tab character (^I)
 12714                                  
 12715                                  ; -----------------------------------------------------------------------------
 12716                                  ;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
 12717                                  ; -----------------------------------------------------------------------------
 12718                                  ; ENTRY:       None
 12719                                  ; EXIT:        Variables listed in highvar.inc are initialized
 12720                                  ; ERROR EXIT:  None
 12721                                  ; USES:        Flags, variables in highvar.inc
 12722                                  ; -----------------------------------------------------------------------------
 12723                                  ; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
 12724                                  ; are largely ignored, but it is initialized nonetheless.
 12725                                  ; -----------------------------------------------------------------------------
 12726                                  
 12727                                  InitVar:
 12728                                  	;pushreg <ax, cx, di, es>
 12729                                  	push	ax
 12730                                  	push	cx
 12731                                  	push	di
 12732                                  	push	es
 12733                                  
 12734                                  	;dataseg es			;Point ES into appropriate data segment
 12735                                  	push	cs
 12736                                  	pop	es
 12737                                  
 12738                                  	xor	ax,ax
 12739                                  	mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
 12740                                  	mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
 12741                                  	mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
 12742                                  	mov	byte [es:UmbLoad],UNSPECIFIED ; 0FFh
 12743                                  					;Later is the # of the 1st spec'd UMB
 12744                                  	mov	[es:fm_argc], al	;Start with zero args having been read
 12745                                  
 12746                                  	cld
 12747                                  
 12748                                  	mov	cx,MAXUMB ; 16		;For each entry
 12749                                  	mov	di,UmbUsed		;on the UmbUsed array,
 12750                                  	rep	stosb			;	Store 0
 12751                                  
 12752                                  	mov	cx,MAXUMB ; 16		;Okay... for each entry
 12753                                  	mov	di,UmbSize		;on the UmbSize array,
 12754                                  	rep	stosw			;	Store 0
 12755                                  
 12756                                  	;normseg es			; Return ES
 12757                                  
 12758                                  	;popreg	<es, di, cx, ax>
 12759                                  	pop	es
 12760                                  	pop	di
 12761                                  	pop	cx
 12762                                  	pop	ax	 	
 12763                                  
 12764                                  	retn
 12765                                  
 12766                                  ; -----------------------------------------------------------------------------
 12767                                  ;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
 12768                                  ; -----------------------------------------------------------------------------
 12769                                  ; ENTRY   : None
 12770                                  ; EXIT    : None
 12771                                  ; ERROR   : None
 12772                                  ; USES    : Flags, fm_umb, fm_strat
 12773                                  ; -----------------------------------------------------------------------------
 12774                                  
 12775                                  FixMem:
 12776                                  	push	ax
 12777                                  	push	bx
 12778                                  	push	cx
 12779                                  	push	dx
 12780                                  	push	es
 12781                                  
 12782                                  	call	fm_link		; Link in UMBs
 12783                                  
 12784                                  	call	UmbHead		; Get first upper-memory MCB address (0x9FFF)
 12785                                  	jc	short fmX	; (if couldn't get it, leave now).
 12786                                  
 12787                                  	mov	es,ax		; It returns in AX, so move it to ES.
 12788                                  
 12789                                  ; - Walk MCB Chain ------------------------------------------------------------
 12790                                  
 12791                                  	xor	dx,dx		; We're keeping the address of the last MCB
 12792                                  	mov 	cx,dx		; in CX... and the last owner
 12793                                  	inc	dx		; in dx as we go through the loop:
 12794                                  
 12795                                  ; ------------------------------------------
 12796                                  ; FM10--DX  = last MCB's owner's PSP address
 12797                                  ;       CX  = last MCB's address (segment)
 12798                                  ; ------------------------------------------
 12799                                  
 12800                                  fm10:	mov	al,[es:ARENA.SIGNATURE] ; if 'Z', don't repeat loop
 12801                                  	mov	bx,[es:ARENA.OWNER]	; if not zero, do nothing
 12802                                  	or	bx,dx			; dx was owner of previous MCB
 12803                                  	jnz	short fm30		; If not both zero, don't cat.
 12804                                  
 12805                                  	; - Coalesce memory blocks at ES:00 and CX:00 -------------------------
 12806                                  
 12807                                  fm20:	mov	bx,[es:ARENA.SIZE]	; Grab this block's Size,
 12808                                  	mov	es,cx			; Go back to prev MCB's address
 12809                                  	mov	[es:ARENA.SIGNATURE],al ; & move the SECOND sig here
 12810                                  
 12811                                  	add	bx,[es:ARENA.SIZE]	; Size += first MCB's size
 12812                                  	add	bx,1			; And add one for the header
 12813                                  	mov	[es:ARENA.SIZE],bx	; Write the size
 12814                                  
 12815                                  	; ---------------------------------------------------------------------
 12816                                  
 12817                                  fm30:	mov	cx,es			; Put this address on the stack
 12818                                  	mov	dx,[es:ARENA.OWNER]	; And remember its owner
 12819                                  
 12820                                  	mov	bx,es			; Move to the next MCB
 12821                                  	add	bx,[es:ARENA.SIZE]
 12822                                  	inc	bx
 12823                                  	mov	es,bx
 12824                                  
 12825                                  	;cmp	al,'Z'
 12826                                  	cmp	al,arena_signature_end
 12827                                  	jne	short fm10		; If signature != 'Z', there are more.
 12828                                  fmX:	
 12829                                  	call	fm_unlink		; Unlink UMBs
 12830                                  
 12831                                  	pop	es
 12832                                  	pop	dx
 12833                                  	pop	cx
 12834                                  	pop	bx
 12835                                  	pop	ax
 12836                                  
 12837                                  	retn
 12838                                  
 12839                                  ; -----------------------------------------------------------------------------
 12840                                  ;*** fm_link - links UMBs not already linked in
 12841                                  ; -----------------------------------------------------------------------------
 12842                                  ; ENTRY:    None
 12843                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 12844                                  ; ERROR:    None
 12845                                  ; USES:     AX, BX, fm_umb
 12846                                  ; -----------------------------------------------------------------------------
 12847                                  
 12848                                  fm_link:
 12849                                  	mov	ax,DOS_CHECK_UMBLINK ; 5802h
 12850                                  	int	21h			; Current link-state is now in al
 12851                                  
 12852                                  	;putdata fm_umb,al		; So store it in fm_umb for later
 12853                                  	;
 12854                                  	;push	es
 12855                                  	;push	cs
 12856                                  	;pop	es
 12857                                  	;mov	[es:fm_umb],al
 12858                                  	;pop	es
 12859                                  	
 12860                                  	mov	[cs:fm_umb],al
 12861                                  
 12862                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 12863                                  	mov	bx,1
 12864                                  	int	21h
 12865                                  	retn
 12866                                  
 12867                                  ; -----------------------------------------------------------------------------
 12868                                  ;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
 12869                                  ; -----------------------------------------------------------------------------
 12870                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 12871                                  ; EXIT:     None
 12872                                  ; ERROR:    None
 12873                                  ; USES:     AX, BX
 12874                                  ; -----------------------------------------------------------------------------
 12875                                  
 12876                                  fm_unlink:
 12877                                  	xor	bx,bx
 12878                                  	
 12879                                  	;getdata bl,fm_umb		; fm_umb already has the old link-state
 12880                                  	;
 12881                                  	;push	ds
 12882                                  	;push	cs
 12883                                  	;pop	ds
 12884                                  	;mov	bl,[fm_umb]	
 12885                                  	;pop	ds
 12886                                  	
 12887                                  	mov	bl,[cs:fm_umb]
 12888                                  
 12889                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 12890                                  	int	21h			; so just use that, and call int 21h
 12891                                  	retn
 12892                                  
 12893                                  ; 08/04/2019 - Retro DOS v4.0
 12894                                  
 12895                                  ; -----------------------------------------------------------------------------
 12896                                  ;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 12897                                  ; laid out in highvar.inc
 12898                                  ; -----------------------------------------------------------------------------
 12899                                  ; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
 12900                                  ; EXIT:     ES:SI points to first character in child program name
 12901                                  ; ERROR:    ES:SI points to character which caused error, carry set, AX == code
 12902                                  ; USES:     ES:SI, AX, flags, variables in highvar.inc
 12903                                  ; -----------------------------------------------------------------------------
 12904                                  ; Error codes (in AX if carry set on return):
 12905                                  ;
 12906                                  PV_InvArg	equ	1	; Invalid argument passed
 12907                                  PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
 12908                                  PV_InvSwt	equ	3	; Unrecognized switch passed
 12909                                  ;
 12910                                  ; This routine exects ES:SI to point to a string much like the following:
 12911                                  ;    "/S/L:1,200;2 module options"
 12912                                  ; Optionally, the string can begin with whitespace; neither /S nor /L is
 12913                                  ; required, though that's what this routine is supposed to parse.
 12914                                  ;
 12915                                  optS		equ	'S'	; /S
 12916                                  optL		equ	'L'	; /L:...
 12917                                  ;
 12918                                  ; -----------------------------------------------------------------------------
 12919                                  ; LoadHigh has a list of arguments, returned by cparse, which is used to create
 12920                                  ; a command-line for spawning a child process. For a typical LH command, say,
 12921                                  ;     lh /l:1,1000;2 print/d:lpt2
 12922                                  ; the arguments would look like (one per line):
 12923                                  ;     lh
 12924                                  ;     /l
 12925                                  ;     1
 12926                                  ;     1000
 12927                                  ;     2
 12928                                  ;     print
 12929                                  ;     /d
 12930                                  ;     :lpt2
 12931                                  ; In short, if "print" were, say, "43", there'd be no way to determine which
 12932                                  ; arg was the filename. So, inside this routine, we keep a running counter
 12933                                  ; of the number of arguments LH will need to skip in order to get to the
 12934                                  ; program name. The "lh" is implicit--it'll always have to skip that. So if
 12935                                  ; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
 12936                                  ; for:
 12937                                  ;    Each /L
 12938                                  ;    Each /S (there should be only one)
 12939                                  ;    Each UMB number (they follow ":" or ";")
 12940                                  ;    Each UMB size   (they follow ",")
 12941                                  ; So, in the above example, fm_argc would be 4-- and LH would skip right to
 12942                                  ; "print".  Note that InitVar initializes fm_argc to zero.
 12943                                  ; -----------------------------------------------------------------------------
 12944                                  
 12945                                  ParseVar:
 12946                                  	;pushreg <di, ds, es>
 12947                                  	push	di
 12948                                  	push	ds
 12949                                  	push	es
 12950                                  
 12951                                  	push	es		; Make DS:SI point to it, as well as ES:SI
 12952                                  	pop	ds		; (regardless if we're in devhigh or loadhigh)
 12953                                  	cld
 12954                                  
 12955                                  ; ------------------------------------------------
 12956                                  ; PV10--ES:SI = any whitespace on the command-line
 12957                                  ; ------------------------------------------------
 12958                                  
 12959                                  pv10:	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
 12960                                  	call	isWhite
 12961                                  	jz	short pv10	;       ES:SI==" /L..."--keep eating.
 12962                                  	;cmp	al,'/'
 12963                                  	cmp	al,SWTCH
 12964                                  	je	short pv20	;       ES:SI=="/L..."--go process a switch
 12965                                  
 12966                                  	dec	si		; Backup--it's now "odule options", and we need
 12967                                  	clc			; that "m" we just read (or whatever it is).
 12968                                  	jmp	short pvX	; Then return with carry clear == we're done.
 12969                                  
 12970                                  pv20:	lodsb			; Just read 'S' or 'L', hopefully
 12971                                  	;toUpper al		; So we make it upper-case, and...
 12972                                  	and	al,0DFh
 12973                                  	;cmp	al,'S'
 12974                                  	cmp	al,optS		; just read 'S'?
 12975                                  	jne	short pv30
 12976                                  
 12977                                  	;call	incArgc		; If it's /S, it's another arg for LH to skip.
 12978                                  	inc	byte [cs:fm_argc] ; 19/04/2019
 12979                                  
 12980                                  	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
 12981                                  	;
 12982                                  	;push	es
 12983                                  	;push	cs
 12984                                  	;pop	es
 12985                                  	;mov	[es:fUmbTiny],1	
 12986                                  	;pop	es
 12987                                  
 12988                                  	mov	byte [cs:fUmbTiny],1
 12989                                  
 12990                                  	jmp	short pv10	; possibly even "/L...".
 12991                                  
 12992                                  pv30:	;cmp	al,'L'
 12993                                  	cmp	al,optL		; If it's not 'L' either, then 'tis a bad
 12994                                  	jne	short pvE1		; switch!
 12995                                  
 12996                                  	;call	incArgc		; If it's /L, it's another arg for LH to skip.
 12997                                  	inc	byte [cs:fm_argc] ; 19/04/2019
 12998                                  
 12999                                  	call	parseL
 13000                                  	jnc	short pv10	; If no carry, go back and look for more
 13001                                  
 13002                                  	dec	si		; Else, back up and exit.
 13003                                  	jmp	short pvErr	; AX has already been set by parseL
 13004                                  
 13005                                  pvE1:	;mov	ax,3
 13006                                  	mov	ax,PV_InvSwt	; Unrecognized switch passed
 13007                                  pvErr:	dec	si
 13008                                  	dec	si
 13009                                  	stc
 13010                                  pvX:	;popreg	<es, ds, di>
 13011                                  	pop	es
 13012                                  	pop	ds
 13013                                  	pop	di
 13014                                  	retn
 13015                                  
 13016                                  ; -----------------------------------------------------------------------------
 13017                                  ;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 13018                                  ; -----------------------------------------------------------------------------
 13019                                  ; ENTRY:    ES:SI points to colon
 13020                                  ; EXIT:     ES:SI points to first character not parsed
 13021                                  ; ERROR:    Carry set; rewind three characters and return (see ParseVar)
 13022                                  ; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
 13023                                  ; -----------------------------------------------------------------------------
 13024                                  ; If the string here is terminated with anything other than whitespace or a
 13025                                  ; switchchar (perhaps it's /S or another /L:... ), then we return with carry
 13026                                  ; set, indicating that they've screwed up the syntax.  The 3-character rewind
 13027                                  ; makes sure the app /L: is reported as being the culprit.
 13028                                  ; -----------------------------------------------------------------------------
 13029                                  
 13030                                  parseL:
 13031                                  	lodsb
 13032                                  	cmp	al,':'		; Make sure they did /L:
 13033                                  	jne	short plE1	; If they didn't, return with carry set.
 13034                                  
 13035                                  ; ------------------------------------------
 13036                                  ; PL10--ES:SI = a UMB number, after /L: or ;
 13037                                  ; ------------------------------------------
 13038                                  
 13039                                  pl10:	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
 13040                                  	jc	short plE2	; And error if it's a bad number.
 13041                                  	call	convUMB		; Convert any address to a UMB number
 13042                                  
 13043                                  	mov	cl,al		; Remember the UMB number
 13044                                  	call	stowUMB		; Mark this UMB # as used;
 13045                                  	jc	short plE2	; If it was already marked, it'll error
 13046                                  
 13047                                  	;call	incArgc		; Each UMB number is another arg for LH to skip
 13048                                  	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0
 13049                                  
 13050                                  	lodsb
 13051                                  	cmp	al,';'		; Did "umb;" ?
 13052                                  	je	short pl10	; Yep: go back and get another UMB.
 13053                                  
 13054                                  	call	isWhite		; Did "umb " ?
 13055                                  	jz	short plX	; Yep: return (it'll go back to whitespace)
 13056                                  
 13057                                  	call	isEOL		; Did "umb" ?
 13058                                  	jz	short plSwX	; If so, backup and exit like everything's ok
 13059                                  
 13060                                  	;cmp	al,'/'
 13061                                  	cmp	al,SWTCH 	; Did "umb/" ? (as in, "/L:1,100;2/S")
 13062                                  	je	short plSwX	; If so, back up ES:SI one character and return
 13063                                  
 13064                                  	cmp	al,','		; Did "umb," ?
 13065                                  	jne	short plE1	; Just what the heck DID they do? Return error.
 13066                                  
 13067                                  ; --- Read a size -------------------------------------------------------------
 13068                                  
 13069                                  	call	GetXNum		; Stop on "size;" or "size " or anything else
 13070                                  	jc	short plE1	; And error if it's a bad size.
 13071                                  
 13072                                  	call	toPara		; Convert from bytes to paragraphs
 13073                                  
 13074                                  	call	stowSiz		; CL still has the UMB number for this routine
 13075                                  
 13076                                  	;call	incArgc		; Each UMB size is another arg for LH to skip
 13077                                  	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0
 13078                                  
 13079                                  	lodsb
 13080                                  	cmp	al,';'		; They did "umb,size;", so get another UMB.
 13081                                  	je	short pl10	;
 13082                                  
 13083                                  	call	isWhite		; Did it end with whitespace?
 13084                                  	jz	short plX	; If so, we're done here--go back.
 13085                                  
 13086                                  	call	isEOL		; Did they do "umb,size" and end??? (stupid)
 13087                                  	jz	short plSwX	; If so, backup and exit like everything's ok
 13088                                  
 13089                                  	;cmp	al,'/'
 13090                                  	cmp	al,SWTCH	; Did they do "umb,size/" ?
 13091                                  	je	short plSwX	; If so, again, we're done here.
 13092                                  
 13093                                  plE1:	;mov	ax,1
 13094                                  	mov	ax,PV_InvArg	; If not, we don't know WHAT they did...
 13095                                  	dec	si
 13096                                  	stc
 13097                                  	retn
 13098                                  
 13099                                  plE2:	;mov	ax,2
 13100                                  	mov	ax,PV_BadUMB	; In this case, they've specified a UMB twice
 13101                                  	stc
 13102                                  	retn
 13103                                  plSwX:	
 13104                                  	dec	si		; If we hit a '/' character, back up one char
 13105                                  				; so the whitespace checker will see it too.
 13106                                  plX:	clc			; Then just return with carry clear, so
 13107                                  	retn			; ParseVar will go about its business.
 13108                                  
 13109                                  ; -----------------------------------------------------------------------------
 13110                                  ;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
 13111                                  ; -----------------------------------------------------------------------------
 13112                                  ; ENTRY:    None
 13113                                  ; EXIT:     None
 13114                                  ; ERROR:    None
 13115                                  ; USES:     fm_argc, flags
 13116                                  ; -----------------------------------------------------------------------------
 13117                                  
 13118                                  ;incArgc:
 13119                                  	;push	ax
 13120                                  
 13121                                  	;;getdata al, fm_argc	; Obtain previous value of fm_argc,
 13122                                  
 13123                                  	;mov	al,[cs:fm_argc]
 13124                                  
 13125                                  	;inc	al		; Increment it,
 13126                                  
 13127                                  	;;putdata fm_argc, al	; And store it right back.
 13128                                  
 13129                                  	;mov	[cs:fm_argc],al
 13130                                  
 13131                                  	;pop	ax
 13132                                  	;retn
 13133                                  
 13134                                  ; -----------------------------------------------------------------------------
 13135                                  ;*** isEOL - returns with ZF set if AL contains CR or LF, or 0
 13136                                  ; -----------------------------------------------------------------------------
 13137                                  ; ENTRY:    AL contains character to test
 13138                                  ; EXIT:     ZF set iff AL contains CR or LF, or 0
 13139                                  ; ERROR:    None
 13140                                  ; USES:     ZF
 13141                                  ; -----------------------------------------------------------------------------
 13142                                  
 13143                                  isEOL:
 13144                                  	cmp	al,0		; Null-terminator
 13145                                  	je	short ieX
 13146                                  	cmp	al,CR ; 0Dh	; Carriage Return
 13147                                  	je	short ieX
 13148                                  	cmp	al,LF ; 0Ah	; LineFeed
 13149                                  ieX:	
 13150                                  	retn
 13151                                  
 13152                                  ; -----------------------------------------------------------------------------
 13153                                  ;*** isWhite - returns with ZF set if AL contains whitespace (or "=")
 13154                                  ; -----------------------------------------------------------------------------
 13155                                  ; ENTRY:    AL contains character to test
 13156                                  ; EXIT:     ZF set iff AL contains space, tab, or equals
 13157                                  ; ERROR:    None
 13158                                  ; USES:     ZF
 13159                                  ; -----------------------------------------------------------------------------
 13160                                  
 13161                                  isWhite:
 13162                                  	cmp	al,' '		; Space
 13163                                  	je	short iwX
 13164                                  	cmp	al,'='		; Equals (treat as whitespace)
 13165                                  	je	short iwX
 13166                                  	cmp	al,tab ; 9	; Tab
 13167                                  iwX:	
 13168                                  	retn
 13169                                  
 13170                                  ; -----------------------------------------------------------------------------
 13171                                  ;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
 13172                                  ; -----------------------------------------------------------------------------
 13173                                  ; ENTRY:    AL contains UMB number
 13174                                  ; EXIT:     None
 13175                                  ; ERROR:    None
 13176                                  ; USES:     Flags, variables in highvar.inc
 13177                                  ; -----------------------------------------------------------------------------
 13178                                  
 13179                                  unMarkUMB:
 13180                                  	push	ax
 13181                                  	push	bx
 13182                                  	push	di
 13183                                  	push	es
 13184                                  
 13185                                  	push	cs
 13186                                  	pop	es
 13187                                  
 13188                                  	xor	ah,ah
 13189                                  	mov	bx,ax
 13190                                  
 13191                                  	; 19/04/2019
 13192                                  	
 13193                                  	;mov	byte [es:bx+UmbUsed],0
 13194                                  	mov	[es:bx+UmbUsed],ah ; 0
 13195                                  
 13196                                  	cmp	[es:UmbLoad],al
 13197                                  	jne	short umu10
 13198                                  
 13199                                  	;mov	[es:UmbLoad],0	; If unmarked the load UMB, load into convent.
 13200                                  	mov	[es:UmbLoad],ah ; 0
 13201                                  umu10:	
 13202                                  	pop	es
 13203                                  	pop	di
 13204                                  	pop	bx
 13205                                  	pop	ax
 13206                                  	retn
 13207                                  
 13208                                  ; -----------------------------------------------------------------------------
 13209                                  ;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
 13210                                  ;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
 13211                                  ; listed in the /L:... chain. If it's the first one specified, it sets UmbLoad
 13212                                  ; to that UMB #... and in any case, it marks the UMB as specified.
 13213                                  ; -----------------------------------------------------------------------------
 13214                                  ; ENTRY:    AL contains UMB number, as specified by the user
 13215                                  ; EXIT:     None
 13216                                  ; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
 13217                                  ; USES:     AX, Flags, variables in highvar.inc
 13218                                  ; -----------------------------------------------------------------------------
 13219                                  
 13220                                  stowUMB:
 13221                                  	cmp	al,MAXUMB ; 16
 13222                                  	jb	short su10
 13223                                  	stc
 13224                                  	retn			; Ooops-- UMB>=MAXUMB
 13225                                  su10:	
 13226                                  	push	bx
 13227                                  	push	di
 13228                                  	push	si
 13229                                  	push	ds
 13230                                  	push	es
 13231                                  	push	cs
 13232                                  	pop	es
 13233                                  	push	cs
 13234                                  	pop	ds
 13235                                  	
 13236                                  	;cmp	byte [UmbLoad],0FFh
 13237                                  	cmp	byte [UmbLoad],UNSPECIFIED ; If this, we haven't been here before
 13238                                  	jne	short su20
 13239                                  	mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
 13240                                  su20:	
 13241                                  	or	al,al		; If they gave UMB 0, there's really nothing
 13242                                  	jz	short su30	; that we should do here.
 13243                                  
 13244                                  	mov	bl,al
 13245                                  	xor	bh,bh
 13246                                  	mov	ax,1		; Now, AX = 1, and BX = UMB Number
 13247                                  
 13248                                  	xchg	[es:bx+UmbUsed],al
 13249                                  
 13250                                  	or	al,al		; If it was already 1, then al==1... and that
 13251                                  	jz	short su30	; means an error.
 13252                                  
 13253                                  	stc			; OOOPS!  This one's been used before.  :(
 13254                                  su30:	
 13255                                  	pop	es
 13256                                  	pop	ds
 13257                                  	pop	si
 13258                                  	pop	di
 13259                                  	pop	bx
 13260                                  	retn
 13261                                  
 13262                                  ; -----------------------------------------------------------------------------
 13263                                  ;*** stowSiz - marks a given UMB as having a given minimum size
 13264                                  ; -----------------------------------------------------------------------------
 13265                                  ; ENTRY:    CL contains UMB number, AX contains size
 13266                                  ; EXIT:     None
 13267                                  ; ERROR:    None
 13268                                  ; USES:     AX, DX, Flags, variables in highvar.inc
 13269                                  ; -----------------------------------------------------------------------------
 13270                                  
 13271                                  ; 13/05/2019
 13272                                  
 13273                                  stowSiz:
 13274                                  	push	bx
 13275                                  	;push	di ; ?
 13276                                  	push	es
 13277                                  
 13278                                  	push	cs
 13279                                  	pop	es	
 13280                                  
 13281                                  	mov	bl,cl			; Now bl==UMB number, AX==size
 13282                                  	mov	bh,0			;     bx==UMB number, AX==size
 13283                                  	shl	bl,1			;     bx==offset into array, AX=size
 13284                                  	mov	[es:bx+UmbSize],ax	; Store the size
 13285                                  	
 13286                                  	pop	es
 13287                                  	;pop	di ; ?
 13288                                  	pop	bx
 13289                                  
 13290                                  	retn
 13291                                  
 13292                                  ; -----------------------------------------------------------------------------
 13293                                  ;*** toDigit - converts a character-digit to its binary counterpart
 13294                                  ;            -- verifies that CL contains a valid character-digit; if so, it
 13295                                  ; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).
 13296                                  ; A-F are considered valid iff gnradix is 16.
 13297                                  ; -----------------------------------------------------------------------------
 13298                                  ; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
 13299                                  ; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
 13300                                  ; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
 13301                                  ; USES:     CL, Flags
 13302                                  ; -----------------------------------------------------------------------------
 13303                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 13304                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 13305                                  ; will be 10 or 16.
 13306                                  ; -----------------------------------------------------------------------------
 13307                                  
 13308                                  gnradix:
 13309                                  	dw	0		; Must be a word--16x16 multiplication
 13310                                  
 13311                                  toDigit:
 13312                                  	cmp	word [cs:gnradix],16
 13313                                  	jne	short td20	; Don't check hex digits if radix isn't 16
 13314                                  
 13315                                  toDigit_hex:
 13316                                  	cmp	cl,'a'	; 61h
 13317                                  	jb	short td10
 13318                                  	cmp	cl,'f'	; 66h
 13319                                  	ja	short tdE	; Nothing valid above 'z' at all...
 13320                                  	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
 13321                                  	;clc			; <- CLC is implicit from last SUB
 13322                                  	retn
 13323                                  td10:	
 13324                                  	cmp	cl,'A'  ; 41h
 13325                                  	jb	short td20	; Below 'A'?  Not a letter...
 13326                                  	cmp	cl,'F'	; 46h
 13327                                  	ja	short tdE	; Above 'F'?  Not a digit.
 13328                                  	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
 13329                                  	;clc			; <- CLC is implicit from last SUB
 13330                                  	retn
 13331                                  toDigit_dec:
 13332                                  td20:	
 13333                                  	cmp	cl,'0'		; If less than zero,
 13334                                  	;jb	short tdE	; Done.
 13335                                  	jb	short tdEr ; 08/04/2019
 13336                                  	cmp	cl,'9'		; Or, if greater than nine,
 13337                                  	ja	short tdE	; Done.
 13338                                  	sub	cl,'0'	; 30h	; Okay--make '0'==0 and return.
 13339                                  	;clc			; <- CLC is implicit from last SUB
 13340                                  	retn
 13341                                  tdE:	
 13342                                  	stc
 13343                                  tdEr:		; 08/04/2019 - Retro DOS v4.0	
 13344                                  	retn
 13345                                  
 13346                                  ; -----------------------------------------------------------------------------
 13347                                  ;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 13348                                  ; -----------------------------------------------------------------------------
 13349                                  ; ENTRY:    ES:SI points to an ascii string to scan
 13350                                  ; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
 13351                                  ; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
 13352                                  ; USES:     ES:SI, DX, AX, Flags, gnradix
 13353                                  ; -----------------------------------------------------------------------------
 13354                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 13355                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 13356                                  ; will be 10 or 16.
 13357                                  ; -----------------------------------------------------------------------------
 13358                                  
 13359                                  ; 08/04/2019 - Retro DOS v4.0
 13360                                  
 13361                                  GetXNum:
 13362                                  	;pushreg <bx, cx, ds>
 13363                                  	push	bx
 13364                                  	push	cx
 13365                                  	push	ds
 13366                                  
 13367                                  	cld
 13368                                  	xor	ax,ax
 13369                                  	xor	bx,bx
 13370                                  	xor	cx,cx
 13371                                  	xor	dx,dx			; Start with 0 (makes sense)
 13372                                  
 13373                                  	mov	word [cs:gnradix],10	; And default to a radix of 10 (dec)
 13374                                  
 13375                                  	mov	cl,[es:si]		; Now AX=0, BX=0, CH=0/CL=char, DX=0
 13376                                  	;call	toDigit
 13377                                  	call	toDigit_dec
 13378                                  	jc	short gxnE		; If it's not a digit, leave now.
 13379                                  
 13380                                  	or	cl,cl
 13381                                  	jnz	short gxn20		; Doesn't have '0x'
 13382                                  	mov	cl,[es:si+1]
 13383                                  	cmp	cl,'x'			; Either 'x'...
 13384                                  	je	short gxn10
 13385                                  	cmp	cl,'X'			; ...or 'X' means it's hexadecimal
 13386                                  	jne	short gxn20
 13387                                  
 13388                                  gxn10:	
 13389                                  	mov	word [cs:gnradix], 16
 13390                                  	inc	si			; Since we read "0x", march over it.
 13391                                  	inc	si
 13392                                  
 13393                                  ; ------------------------------------------------------
 13394                                  ; GXN20--ES:SI = a digit in a number; if not, we're done
 13395                                  ;        DX:AX = current total
 13396                                  ;        BX    = 0
 13397                                  ;        CH    = 0
 13398                                  ; ------------------------------------------------------
 13399                                  
 13400                                  gxn20:	
 13401                                  	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
 13402                                  	inc	si
 13403                                  
 13404                                  	call	toDigit		; Accepts only valid digits, A-F -> 10-16
 13405                                  	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.
 13406                                  
 13407                                  	call	mul32		; Multiply DX:AX by gnradix
 13408                                  	jc	short gxnX	; (if it's too big, error out)
 13409                                  
 13410                                  	add	ax,cx		; Add the digit
 13411                                  	adc	dx,bx		; (BX is 0!)--Adds 1 iff last add wrapped
 13412                                  	;jc	short gxnX	; If _that_ wrapped, it's too big.
 13413                                  	;jmp	short gxn20
 13414                                  	jnc	short gxn20
 13415                                  gxnE:	
 13416                                  	;stc			; In this case, we need to set the carry
 13417                                  	jmp	short gxnX	; and leave--there were no digits given.
 13418                                  gxnQ:	
 13419                                  	dec	si		; Don't read in the offensive character.
 13420                                  	clc			; And clear carry, so they know it's okay.
 13421                                  gxnX:	
 13422                                  	pop	ds
 13423                                  	pop	cx
 13424                                  	pop	bx
 13425                                  	retn
 13426                                  
 13427                                  ; -----------------------------------------------------------------------------
 13428                                  ;*** mul32 - multiplies the number in DX:AX by gnradix
 13429                                  ; -----------------------------------------------------------------------------
 13430                                  ; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
 13431                                  ; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
 13432                                  ; ERROR:   Carry set if number was too large
 13433                                  ; USES:    Flags, AX, DX
 13434                                  ; -----------------------------------------------------------------------------
 13435                                  
 13436                                  mul32:
 13437                                  	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
 13438                                  	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
 13439                                  	mul	word [cs:gnradix] ; DX=?, AX=new:hi, TOS=old:lo, BX=0
 13440                                  	jc	short m32E	; Too big?
 13441                                  
 13442                                  	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
 13443                                  	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig, BX=0
 13444                                  
 13445                                  	xchg	dx,bx		; DX=0, AX=old:lo, TOS=orig, BX=new:hi
 13446                                  	mul	word [cs:gnradix] ; DX=carry,  AX=new:lo, TOS=orig, BX=new:hi
 13447                                  	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
 13448                                  	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
 13449                                  	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=0
 13450                                  	retn
 13451                                  m32E:	
 13452                                  	pop	ax
 13453                                  	retn
 13454                                  
 13455                                  ; -----------------------------------------------------------------------------
 13456                                  ;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
 13457                                  ; -----------------------------------------------------------------------------
 13458                                  ; ENTRY:   DX:AX = the number to be divided
 13459                                  ; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
 13460                                  ; ERROR:   None
 13461                                  ; USES:    Flags, AX, DX
 13462                                  ; -----------------------------------------------------------------------------
 13463                                  ; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
 13464                                  ;       can't ensure a 386 host machine. Sorry.
 13465                                  ; -----------------------------------------------------------------------------
 13466                                  
 13467                                  toPara:
 13468                                  	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
 13469                                  
 13470                                  	mov	cl,4		;
 13471                                  	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
 13472                                  	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
 13473                                  	mov	cl,12
 13474                                  	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
 13475                                  	or	ax,dx		;    AX=hhhh LLLL llll llll
 13476                                  
 13477                                  	pop	cx
 13478                                  	retn
 13479                                  
 13480                                  ; -----------------------------------------------------------------------------
 13481                                  ;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
 13482                                  ; -----------------------------------------------------------------------------
 13483                                  ; ENTRY:  Nothing
 13484                                  ; EXIT:   AX contains 0x9FFF for most systems
 13485                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 13486                                  ; USES:   Flags, AX
 13487                                  ; -----------------------------------------------------------------------------
 13488                                  ; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
 13489                                  ; to be precise, before a UMB provider is around. In this event, the pointer
 13490                                  ; is always set to 0xFFFF; it changes once a provider is around. On most
 13491                                  ; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
 13492                                  ; -----------------------------------------------------------------------------
 13493                                  
 13494                                  UmbHead:
 13495                                  	; 13/05/2019 (because of callers, pushs & pops are not needed here)
 13496                                  
 13497                                  	;push	si ; ?
 13498                                  	;push	ds ; ? 
 13499                                  	;push	es
 13500                                  	;push	bx ; *	
 13501                                  
 13502                                  	; 09/04/2019
 13503                                  	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)
 13504                                  
 13505                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 13506                                  	int	21h
 13507                                  
 13508                                  	mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
 13509                                  	cmp	ax,0FFFFh
 13510                                  	je	short uhE		; If it's 0xFFFF, it's an error...
 13511                                  
 13512                                  	clc				; Else, it isn't (CLC done by prev cmp)
 13513                                  	jmp	short uhX
 13514                                  uhE:	
 13515                                  	stc
 13516                                  uhX:	
 13517                                  	;pop	bx ; *
 13518                                  	;pop	es
 13519                                  	;pop	ds ; ?
 13520                                  	;pop	si ; ?
 13521                                  	retn
 13522                                  
 13523                                  ; -----------------------------------------------------------------------------
 13524                                  ;*** isSysMCB - sets ZF if ES points to an MCB owned by "SC" + (8 or 9)
 13525                                  ; -----------------------------------------------------------------------------
 13526                                  ; ENTRY:  ES:0 should point to a valid MCB
 13527                                  ; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
 13528                                  ; USES:   Flags
 13529                                  ; -----------------------------------------------------------------------------
 13530                                  
 13531                                  isSysMCB:
 13532                                  	;push	ax
 13533                                  
 13534                                  	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
 13535                                  	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
 13536                                  	;je	short ism10
 13537                                  	;cmp	ax,JapanPSPOwner	; 9 (for Japan) is valid
 13538                                  	;;je	short ism10
 13539                                  	;;jmp	short ismX		; Anything else isn't.
 13540                                  	;jne	short ismX
 13541                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; 8  ; 09/04/2019
 13542                                  	jne	short ismX 
 13543                                  ism10:	
 13544                                  	;mov	ax,[es:ARENA.NAME]	; Check the name...
 13545                                  	;cmp	ax,'SC' ; 4353h
 13546                                  	cmp	word [es:ARENA.NAME],'SC'
 13547                                  ismX:	
 13548                                  	;pop	ax
 13549                                  	retn
 13550                                  
 13551                                  ; 09/04/2019 - Retro DOS v4.0
 13552                                  
 13553                                  ; -----------------------------------------------------------------------------
 13554                                  ;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
 13555                                  ; -----------------------------------------------------------------------------
 13556                                  ; ENTRY:  AX contains a segment address
 13557                                  ; EXIT:   AX will contain the UMB number which contains the address (0==conv)
 13558                                  ; ERROR:  If the address is above UM Range, AX will return as FFFF.
 13559                                  ; USES:   Flags, AX
 13560                                  ; -----------------------------------------------------------------------------
 13561                                  ; An address in the following areas is treated as:
 13562                                  ;    0      <-> umbhead (0x9FFF)          = Conventional memory
 13563                                  ;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
 13564                                  ;      ...
 13565                                  ;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
 13566                                  ; -----------------------------------------------------------------------------
 13567                                  
 13568                                  AddrToUmb:
 13569                                  	push	cx
 13570                                  	push	dx
 13571                                  	push	es
 13572                                  
 13573                                  	mov	dx,ax		; DX = address to search for
 13574                                  
 13575                                  	call	UmbHead		; AX = first segment
 13576                                  	jc	short atuE	; If it couldn't get it, error out.
 13577                                  
 13578                                  	mov	es,ax		; ES = first UMB segment
 13579                                  	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)
 13580                                  
 13581                                  ; ----------------------------------------
 13582                                  ; ATU10--ES - Current MCB address
 13583                                  ;        DX - Address given for conversion
 13584                                  ;        CX - Current UMB #
 13585                                  ; ----------------------------------------
 13586                                  
 13587                                  atu10:	mov	ax,es
 13588                                          cmp	ax,dx		; Present segment >= given segment?
 13589                                  	jae	short atuX	; Yep--done.
 13590                                  
 13591                                  	call	isSysMCB	; Returns with ZF set if this is a system MCB
 13592                                  	jnz	short atu20
 13593                                  
 13594                                  	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
 13595                                  atu20:	
 13596                                  	mov	al,[es:ARENA.SIGNATURE]
 13597                                  	cmp	al,arena_signature_end  ; 'Z'
 13598                                  	je	short atu30		; 'Z' means this was the last MCB... that's it.
 13599                                  
 13600                                  	;NextMCB es, ax
 13601                                  
 13602                                  	mov     ax,es
 13603                                  	;add	ax,[es:3]
 13604                                  	add     ax,[es:ARENA.SIZE]
 13605                                  	inc     ax
 13606                                  	mov     es,ax
 13607                                  	
 13608                                  	jmp	short atu10
 13609                                  
 13610                                  ; -----------------------------------------------------------------------------
 13611                                  ; if we get to atu30, they specified a number that was past the last MCB.
 13612                                  ; make sure it's not _inside_ that MCB before we return an error condition.
 13613                                  ; -----------------------------------------------------------------------------
 13614                                  
 13615                                  atu30:	
 13616                                  	mov	ax,es
 13617                                  	add	ax,[es:ARENA.SIZE]
 13618                                  	cmp	ax,dx		; Present >= given?
 13619                                  	jae	short atuX	; Yep! It _was_ inside.
 13620                                  atuE:	
 13621                                  	xor	cx,cx		; Else, fall through with UMB # == -1
 13622                                  	dec	cx		; (that makes it return 0xFFFF and sets CF)
 13623                                  atuX:	
 13624                                  	mov	ax, cx		; Return the UMB number in AX
 13625                                  	
 13626                                  	pop	es	
 13627                                  	pop	dx
 13628                                  	pop	cx
 13629                                  	retn
 13630                                  
 13631                                  ; -----------------------------------------------------------------------------
 13632                                  ;*** convUMB - checks after GetXNum to convert an address to a UMB number
 13633                                  ;            -- if GetXNum read a hex number, we interperete that as a segment
 13634                                  ; address rather than a UMB number... and use that address to look up a UMB.
 13635                                  ; This routine checks for that condition and calls AddrToUmb if necessary.
 13636                                  ; -----------------------------------------------------------------------------
 13637                                  ; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
 13638                                  ; EXIT:   AX will contain a UMB number
 13639                                  ; ERROR:  None
 13640                                  ; USES:   Flags, AX
 13641                                  ; -----------------------------------------------------------------------------
 13642                                  
 13643                                  convUMB:
 13644                                  	cmp	word [cs:gnradix],16
 13645                                  	jne	short cu10	; If it didn't read in hex, it's not an address
 13646                                  	call	AddrToUmb	; Else, convert the address to a UMB number
 13647                                  	cmp	ax,0FFFFh
 13648                                  	jne	short cu10
 13649                                  	inc	ax		; If too high, ignore it (make it conventional)
 13650                                  cu10:	
 13651                                  	retn
 13652                                  
 13653                                  ; -----------------------------------------------------------------------------
 13654                                  ;*** setUMBs - links umbs and sets allocation strategy for a load
 13655                                  ;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
 13656                                  ; of the usual HIGH_FIRST.  See the code.
 13657                                  ; -----------------------------------------------------------------------------
 13658                                  ; ENTRY:  None
 13659                                  ; EXIT:   None
 13660                                  ; ERROR:  None
 13661                                  ; USES:   Flags, fm_umb, fm_strat
 13662                                  ; -----------------------------------------------------------------------------
 13663                                  
 13664                                  setUMBs:
 13665                                  	push	ax
 13666                                  	push	bx
 13667                                  	call	fm_link
 13668                                  	pop	bx
 13669                                  	pop	ax
 13670                                  	retn
 13671                                  
 13672                                  ; -----------------------------------------------------------------------------
 13673                                  ;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
 13674                                  ; -----------------------------------------------------------------------------
 13675                                  ; ENTRY:  None
 13676                                  ; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
 13677                                  ;         Carry set if UMB0 not specified (_NOT_ an error)
 13678                                  ; ERROR:  None
 13679                                  ; USES:   Flags, fm_strat, fm_umb
 13680                                  ; -----------------------------------------------------------------------------
 13681                                  ; We want to set the memory strategy to LOW_FIRST if the user specified a
 13682                                  ; load UMB, and it is 0.  That 0 can be either from the user having _specified_
 13683                                  ; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
 13684                                  ; such that the load UMB is too small, and shouldn't be used.
 13685                                  ; -----------------------------------------------------------------------------
 13686                                  
 13687                                  loadLow:
 13688                                  	;push	ds
 13689                                  	;push	cs		; Point DS into appropriate data segment
 13690                                  	;pop	ds	
 13691                                  
 13692                                  	;mov	al,[UmbLoad]
 13693                                  	mov	al,[cs:UmbLoad]
 13694                                  	cmp	al,UNSPECIFIED ; 0FFh, -1
 13695                                  	jne	short ll10
 13696                                  
 13697                                  	stc
 13698                                  ll15:
 13699                                  	mov	al,1		; Return with AL==1 && STC if no UMBs specified
 13700                                  	;stc
 13701                                  	;jmp	short llX
 13702                                  	retn
 13703                                  ll10:	
 13704                                  	or	al,al		; AL=the load UMB: Is it == 0?
 13705                                  	;jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit
 13706                                  
 13707                                  	jnz	short ll15	; 09/04/2019 - Retro DOS v4.0
 13708                                  	retn
 13709                                  
 13710                                  	;mov	al,1
 13711                                  	;clc
 13712                                  ;llX:
 13713                                  	;pop	ds		; Return DS to where it was
 13714                                  	;retn
 13715                                  
 13716                                  ; -----------------------------------------------------------------------------
 13717                                  ;*** HideUMBs - links UMBs and hides upper-memory as appropriate
 13718                                  ; -----------------------------------------------------------------------------
 13719                                  ; ENTRY:  None
 13720                                  ; EXIT:   None
 13721                                  ; ERROR:  None
 13722                                  ; USES:   Flags, fm_strat, fm_umb
 13723                                  ; -----------------------------------------------------------------------------
 13724                                  
 13725                                  HideUMBs:
 13726                                  	push	ax
 13727                                  	push	cx
 13728                                  	push	ds
 13729                                  	push	es
 13730                                  
 13731                                  	call	UmbTest		; See if we REALLY linked in anything...
 13732                                  	jc	short husX	; ...if not, there's nothing for us to do.
 13733                                  
 13734                                  	call	FixMem		; Concatenate adjacent free MCBs in upper mem
 13735                                  	call	setUMBs		; Link UMBs and set memory-allocation strategy
 13736                                  
 13737                                  	;putdata fInHigh,1	; Remember that we're now running high
 13738                                  	mov	byte [cs:fInHigh],1
 13739                                  
 13740                                  	;call	GetLoadUMB	; See if they gave us a list to leave free
 13741                                  	mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0
 13742                                  
 13743                                  	cmp	al,UNSPECIFIED	; If they didn't,
 13744                                  	je	short husX	; then we shouldn't do this loop:
 13745                                  
 13746                                  	xor	cx,cx
 13747                                  
 13748                                  ; -----------------------------------------------
 13749                                  ; HUS10-CX - UMB number (after inc, 1==first UMB)
 13750                                  ; -----------------------------------------------
 13751                                  
 13752                                  hus10:	inc	cx		; For each UMB:
 13753                                  	cmp	cx,MAXUMB ; 16
 13754                                  	jae	short hus20
 13755                                  
 13756                                  	mov	al,cl		; (stopping as soon as we're outside of the
 13757                                  	push	es
 13758                                  	call	findUMB		; valid range of UMBs)
 13759                                  	pop	es		; push/pop: trash what findumb finds.  :-)
 13760                                  	jc	short hus20
 13761                                  
 13762                                  	call	_hideUMB_	; hide what we need to hide.
 13763                                  
 13764                                  	jmp	short hus10
 13765                                  hus20:	
 13766                                  	;call	GetLoadUMB	; Now check if they offered /L:0
 13767                                  	mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0	
 13768                                  
 13769                                  	or	al,al		; --Is the load UMB 0? (-1==unspecified)
 13770                                  	jnz	short husX	; If not, we're done.
 13771                                  
 13772                                  	call	hl_unlink	; If so, however, fix UMBs and strategy.
 13773                                  husX:	
 13774                                  	pop	es
 13775                                  	pop	ds
 13776                                  	pop	cx
 13777                                  	pop	ax
 13778                                  	retn
 13779                                  
 13780                                  ; -----------------------------------------------------------------------------
 13781                                  ;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
 13782                                  ; -----------------------------------------------------------------------------
 13783                                  ; ENTRY:  None
 13784                                  ; EXIT:   AL == load UMB
 13785                                  ; ERROR:  None
 13786                                  ; USES:   Flags, AX
 13787                                  ; -----------------------------------------------------------------------------
 13788                                  
 13789                                  ;GetLoadUMB:
 13790                                  ;	;getdata al, UmbLoad
 13791                                  ;	push	ds
 13792                                  ;	push	cs
 13793                                  ;	pop	ds
 13794                                  ;	mov	al,[UmLoad]
 13795                                  ;	pop	ds
 13796                                  ;	retn
 13797                                  
 13798                                  ; -----------------------------------------------------------------------------
 13799                                  ;*** GetLoadSize - Returns the load UMB minimum size (0 if not specified)
 13800                                  ; -----------------------------------------------------------------------------
 13801                                  ; ENTRY:  None
 13802                                  ; EXIT:   AX == load UMB minimum size
 13803                                  ; ERROR:  None
 13804                                  ; USES:   Flags, AX
 13805                                  ; -----------------------------------------------------------------------------
 13806                                  
 13807                                  GetLoadSize:
 13808                                  	; 09/04/2019 - Retro DOS v4.0
 13809                                  	mov	al,[cs:UmbLoad]
 13810                                  	jmp	short GetSize
 13811                                  
 13812                                  	;push	bx
 13813                                  	;;push	si
 13814                                  	;push	ds
 13815                                  	;push	cs
 13816                                  	;pop	ds
 13817                                  
 13818                                  	;mov	al,[UmbLoad]
 13819                                  
 13820                                  	;xor	ah,ah			;    ax==UMB
 13821                                  	;mov	bx,UmbSize		;    bx==array
 13822                                  	;shl	al,1	                ;    ax==offset
 13823                                  	;;add	ax,bx			;    ax==element index
 13824                                  	;;mov	si,ax			; ds:si==element index
 13825                                  
 13826                                  	;;lodsw				;    ax==size
 13827                                  
 13828                                  	;add	bx,ax
 13829                                  	;mov	ax,[bx]
 13830                                  
 13831                                  	;pop	ds
 13832                                  	;;pop	si
 13833                                  	;pop	bx
 13834                                  	;retn
 13835                                  
 13836                                  ; -----------------------------------------------------------------------------
 13837                                  ;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
 13838                                  ; -----------------------------------------------------------------------------
 13839                                  ; ENTRY:  AL == a UMB number
 13840                                  ; EXIT:   AX == UMB minimum size, as specified by the user
 13841                                  ; ERROR:  None
 13842                                  ; USES:   Flags, AX
 13843                                  ; -----------------------------------------------------------------------------
 13844                                  
 13845                                  GetSize:
 13846                                  	; 09/04/2019 - Retro DOS v4.0
 13847                                  
 13848                                  	push	bx
 13849                                  	;push	si
 13850                                  	;push	ds
 13851                                  	;push	cs
 13852                                  	;pop	ds
 13853                                  
 13854                                  	xor	ah,ah			;    ax==UMB
 13855                                  	mov	bx,UmbSize		;    bx==array
 13856                                  	shl	al,1	                ;    ax==offset
 13857                                  	;add	ax,bx			;    ax==element index
 13858                                  	;mov	si,ax			; ds:si==element index
 13859                                  
 13860                                  	;lodsw				;    ax==size
 13861                                  
 13862                                  	add	bx,ax
 13863                                  	;mov	ax,[bx]
 13864                                  	mov	ax,[cs:bx]
 13865                                  
 13866                                  	;pop	ds
 13867                                  	;pop	si
 13868                                  	pop	bx
 13869                                  	retn
 13870                                  
 13871                                  ; -----------------------------------------------------------------------------
 13872                                  ;*** StoLoadUMB - Overrides the load UMB number with what's in AL
 13873                                  ; -----------------------------------------------------------------------------
 13874                                  ; ENTRY:   AL == new load UMB
 13875                                  ; EXIT:    None
 13876                                  ; ERROR:   None
 13877                                  ; USES:    Flags, AX
 13878                                  ; -----------------------------------------------------------------------------
 13879                                  ; CAUTION: Should only be used if /L:... was used.  Logically, that is the only
 13880                                  ;          time you would ever need this, so that's okay.
 13881                                  ; -----------------------------------------------------------------------------
 13882                                  
 13883                                  ;StoLoadUMB:
 13884                                  ;	;putdata UmbLoad, al
 13885                                  ;	push	es
 13886                                  ;	push	cs
 13887                                  ;	pop	es
 13888                                  ;	mov	[es:UmbLoad],al
 13889                                  ;	pop	es
 13890                                  ;	retn
 13891                                  
 13892                                  ; -----------------------------------------------------------------------------
 13893                                  ;*** StoLoadSize - Overrides the load UMB minimum size with what's in AX
 13894                                  ; -----------------------------------------------------------------------------
 13895                                  ; ENTRY:  AL == new load size
 13896                                  ; EXIT:   None
 13897                                  ; ERROR:  None
 13898                                  ; USES:   Flags, AX
 13899                                  ; -----------------------------------------------------------------------------
 13900                                  
 13901                                  StoLoadSize:
 13902                                  	push	dx
 13903                                  
 13904                                  	;getdata dl, UmbLoad		; Put UMB# in DL and size in AX
 13905                                  	;
 13906                                  	;push	ds
 13907                                  	;push	cs
 13908                                  	;pop	ds
 13909                                  	;mov	dl,[UmbLoad]
 13910                                  	;pop	ds	
 13911                                  
 13912                                  	mov	dl,[cs:UmbLoad]
 13913                                  
 13914                                  	cmp	dl,UNSPECIFIED ; 0FFh
 13915                                  	je	short sls10
 13916                                  
 13917                                  	call	stowSiz			; We've got a function to do just this
 13918                                  sls10:	
 13919                                  	pop	dx
 13920                                  	retn
 13921                                  
 13922                                  ; -----------------------------------------------------------------------------
 13923                                  ;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
 13924                                  ; -----------------------------------------------------------------------------
 13925                                  ; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
 13926                                  ; EXIT:     None; free elements in UMB marked as hidden
 13927                                  ; ERROR:    None
 13928                                  ; USES:     Flags
 13929                                  ; -----------------------------------------------------------------------------
 13930                                  
 13931                                  hideUMB:
 13932                                  	push	ax
 13933                                  	push	es
 13934                                  
 13935                                  	call	findUMB		; Returns with carry if err, else ES == MCB
 13936                                  	jc	short huX
 13937                                  
 13938                                  ; ------------------------------------------------
 13939                                  ; HU10--ES - MCB inside UMB; if it's a system MCB,
 13940                                  ;            we're not in the same UMB, so exit.
 13941                                  ; ------------------------------------------------
 13942                                  
 13943                                  hu10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 13944                                  	jz	short huX	; If it is, we've finished the UMB.
 13945                                  	;call	isFreeMCB	; Returns with ZF set if owner is 0
 13946                                  	or	word [es:ARENA.OWNER],0
 13947                                  	jnz	short hu20
 13948                                  
 13949                                  	call	hideMCB
 13950                                  hu20:	
 13951                                  	mov	al,[es:ARENA.SIGNATURE]
 13952                                  	cmp	al,arena_signature_end  ;'Z'
 13953                                  	jz	short huX	; 'Z' means this was the last MCB... that's it.
 13954                                  
 13955                                  	;NextMCB es, ax		; Go on forward.
 13956                                  	mov     ax,es
 13957                                  	;add	ax,[es:3]
 13958                                  	add     ax,[es:ARENA.SIZE]
 13959                                  	inc     ax
 13960                                  	mov     es,ax
 13961                                  
 13962                                  	jmp	short hu10
 13963                                  huX:	
 13964                                  	pop	es
 13965                                  	pop	ax
 13966                                  	retn
 13967                                  
 13968                                  ; -----------------------------------------------------------------------------
 13969                                  ;*** isTiny - returns with ZF set if user didn't specify /S
 13970                                  ; -----------------------------------------------------------------------------
 13971                                  ; ENTRY:    None
 13972                                  ; EXIT:     ZF set if user DIDN'T specify /S
 13973                                  ; ERROR:    None
 13974                                  ; USES:     Flags
 13975                                  ; -----------------------------------------------------------------------------
 13976                                  
 13977                                  isTiny:
 13978                                  	push	ax
 13979                                  
 13980                                  	;getdata al, fUmbTiny
 13981                                  	;
 13982                                  	;push	ds
 13983                                  	;push	cs
 13984                                  	;pop	ds
 13985                                  	;mov	al,[fUmbTiny]
 13986                                  	;pop	ds
 13987                                  
 13988                                  	mov	al,[cs:fUmbTiny]		
 13989                                  
 13990                                  	or	al,al
 13991                                  	pop	ax
 13992                                  	retn
 13993                                  
 13994                                  ; -----------------------------------------------------------------------------
 13995                                  ;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
 13996                                  ; -----------------------------------------------------------------------------
 13997                                  ; ENTRY:    ES:0 should point to an MCB
 13998                                  ; EXIT:     ZF set if MCB is free, else !ZF
 13999                                  ; ERROR:    None
 14000                                  ; USES:     Flags
 14001                                  ; -----------------------------------------------------------------------------
 14002                                  
 14003                                  ;isFreeMCB:
 14004                                  ;	or	word [es:ARENA.OWNER],0
 14005                                  ;	retn
 14006                                  
 14007                                  ; -----------------------------------------------------------------------------
 14008                                  ;*** hideMCB - marks as HIDDEN the MCB at ES:0
 14009                                  ; -----------------------------------------------------------------------------
 14010                                  ; ENTRY:    ES:0 should point to an MCB
 14011                                  ; EXIT:     None; MCB marked as HIDDEN
 14012                                  ; ERROR:    None
 14013                                  ; USES:     None
 14014                                  ; -----------------------------------------------------------------------------
 14015                                  
 14016                                  hideMCB:
 14017                                  	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
 14018                                  	mov	word [es:ARENA.NAME+0], 'HI' ; 4948h
 14019                                  	mov	word [es:ARENA.NAME+2], 'DD' ; 4444h
 14020                                  	mov	word [es:ARENA.NAME+4], 'EN' ; 4E45h
 14021                                  	mov	word [es:ARENA.NAME+6], '  ' ; 2020h	
 14022                                  	retn
 14023                                  
 14024                                  ; -----------------------------------------------------------------------------
 14025                                  ;*** unHideMCB - marks as FREE the MCB at ES:0
 14026                                  ; -----------------------------------------------------------------------------
 14027                                  ; ENTRY:    ES:0 should point to an MCB
 14028                                  ; EXIT:     None; MCB marked as FREE
 14029                                  ; ERROR:    None
 14030                                  ; USES:     None
 14031                                  ; -----------------------------------------------------------------------------
 14032                                  
 14033                                  unHideMCB:
 14034                                  	push	ax
 14035                                  	mov	word [es:ARENA.OWNER],FreePSPOwner ; 0
 14036                                  	mov	ax,'  ' ; 2020h
 14037                                  	mov	[es:ARENA.NAME+0],ax
 14038                                  	mov	[es:ARENA.NAME+2],ax
 14039                                  	mov	[es:ARENA.NAME+4],ax
 14040                                  	mov	[es:ARENA.NAME+6],ax
 14041                                  	pop	ax
 14042                                  	retn
 14043                                  
 14044                                  ; -----------------------------------------------------------------------------
 14045                                  ;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
 14046                                  ;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
 14047                                  ; -----------------------------------------------------------------------------
 14048                                  ; ENTRY:    AL should be to a valid UMB number
 14049                                  ; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
 14050                                  ; ERROR:    Carry set if couldn't reach UMB (too high)
 14051                                  ; USES:     Flags, ES
 14052                                  ; -----------------------------------------------------------------------------
 14053                                  
 14054                                  findUMB:
 14055                                  	push	ax
 14056                                  	push	cx
 14057                                  	push	dx
 14058                                  
 14059                                  	xor	ah,ah		; Zap ah, so al==ax
 14060                                  
 14061                                  	mov	dx,ax		; Store the to-be-found UMB number in DX
 14062                                  
 14063                                  	call	UmbHead		; Returns first UMB segment in AX
 14064                                  	mov	es,ax
 14065                                  	xor	cx,cx		; Pretend we're on UMB 0 for now...
 14066                                  
 14067                                  ; ---------------------------------------------
 14068                                  ; FU10--CX - This UMB number; 0 == conventional
 14069                                  ;       DX - The UMB number they're looking for
 14070                                  ;       ES - The current MCB address
 14071                                  ; ---------------------------------------------
 14072                                  
 14073                                  fu10:	
 14074                                  	cmp	cx,dx		; If CX==DX, we've found the UMB we're
 14075                                  	je	short fuX	; searching for--so exit.
 14076                                  
 14077                                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 14078                                  	jnz	short fu20
 14079                                  
 14080                                  	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 14081                                  fu20:	
 14082                                  	mov	al,[es:ARENA.SIGNATURE]
 14083                                  	cmp	al,arena_signature_end ; 'Z'
 14084                                  	je	short fuE	; 'Z' means this was the last MCB... that's it.
 14085                                  
 14086                                  	;NextMCB es, ax		; Go on forward.
 14087                                  	mov     ax,es
 14088                                  	;add	ax,[es:3]
 14089                                  	add     ax,[es:ARENA.SIZE]
 14090                                  	inc     ax
 14091                                  	mov     es,ax
 14092                                  
 14093                                  	jmp	short fu10
 14094                                  fuE:	
 14095                                  	stc
 14096                                  fuX:
 14097                                  	pop	dx
 14098                                  	pop	cx
 14099                                  	pop	ax		; The address is already in ES.
 14100                                  	retn
 14101                                  
 14102                                  ; -----------------------------------------------------------------------------
 14103                                  ;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
 14104                                  ; -----------------------------------------------------------------------------
 14105                                  ; ENTRY:    AL should be to a valid UMB number
 14106                                  ; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
 14107                                  ; ERROR:    Carry set if couldn't reach UMB (0 or too high)
 14108                                  ; USES:     Flags, ES
 14109                                  ; -----------------------------------------------------------------------------
 14110                                  
 14111                                  BigFree:
 14112                                  	push	bx
 14113                                  	push	cx
 14114                                  
 14115                                  	call	findUMB			; Returns with CF if err, else ES==MCB
 14116                                  	jc	short bfX		; (would be "jc bfE"; it just does stc)
 14117                                  
 14118                                  	xor	bx,bx			; Segment address of largest free MCB
 14119                                  	xor	cx,cx			; Size of largest free MCB
 14120                                  
 14121                                  ; ---------------------------------------------
 14122                                  ; BF10--ES - Current MCB address
 14123                                  ;       BX - Address of largest free MCB so far
 14124                                  ;       CX - Size of largest free MCB so far
 14125                                  ; ---------------------------------------------
 14126                                  
 14127                                  bf10:	
 14128                                  	call	isSysMCB		; If we've left the MCB, we're done.
 14129                                  	jz	short bf30
 14130                                  
 14131                                  	;call	isFreeMCB		; Returns with ZF set if owner is 0
 14132                                  	or	word [es:ARENA.OWNER],0
 14133                                  	jnz	short bf20
 14134                                  
 14135                                  	mov	ax,[es:ARENA.SIZE]
 14136                                  	;cmp	cx,[es:ARENA.SIZE]	; Compare sizes...
 14137                                  	cmp	cx,ax
 14138                                  	jg	short bf20		; Unless we're bigger,
 14139                                  
 14140                                  	mov	bx,es			; Store this new element's address,
 14141                                  	;mov	cx,[es:ARENA.SIZE]	; and its size.
 14142                                  	mov	cx,ax
 14143                                  
 14144                                  bf20:	mov	al,[es:ARENA.SIGNATURE]
 14145                                  	cmp	al,arena_signature_end	; 'Z'
 14146                                  	jz	short bf30		; 'Z' means this was the last MCB.
 14147                                  
 14148                                  	;NextMCB es,ax		; Go on forward.
 14149                                  	mov     ax,es
 14150                                  	;add	ax,[es:3]
 14151                                  	add     ax,[es:ARENA.SIZE]
 14152                                  	inc     ax
 14153                                  	mov     es,ax
 14154                                  
 14155                                  	jmp	short bf10
 14156                                  
 14157                                  bf30:	mov	es,bx			; Return the address
 14158                                  	mov	ax,cx			; Return the size
 14159                                  	or	bx,bx
 14160                                  	jnz	short bfX		; (if size==0, there's nothing free)
 14161                                  bfE:	
 14162                                  	stc
 14163                                  bfX:
 14164                                  	pop	cx
 14165                                  	pop	bx
 14166                                  	retn
 14167                                  
 14168                                  ; -----------------------------------------------------------------------------
 14169                                  ;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 14170                                  ; -----------------------------------------------------------------------------
 14171                                  ; ENTRY:    AL should be to a valid UMB number
 14172                                  ; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
 14173                                  ; ERROR:    None
 14174                                  ; USES:     Flags
 14175                                  ; -----------------------------------------------------------------------------
 14176                                  
 14177                                  isSpecified:
 14178                                  	push	ax
 14179                                  
 14180                                  	xor	bh,bh
 14181                                  	mov	bl,al
 14182                                  
 14183                                  	;getdata al, DS:UmbUsed[bx]
 14184                                  	;
 14185                                  	;push	ds
 14186                                  	;push	cs
 14187                                  	;pop	ds
 14188                                  	;mov	al,[bx+UmbUsed]
 14189                                  	;pop	ds
 14190                                  	
 14191                                  	mov	al,[cs:bx+UmbUsed]
 14192                                  	or	al,al			; Sets ZF if al==0 (ie, if unspecified)
 14193                                  
 14194                                  	pop	ax
 14195                                  	retn
 14196                                  
 14197                                  ; -----------------------------------------------------------------------------
 14198                                  ;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
 14199                                  ; -----------------------------------------------------------------------------
 14200                                  ; ENTRY:    AX == new size, ES:0 == current MCB
 14201                                  ; EXIT:     None; MCB broken if carry clear
 14202                                  ; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
 14203                                  ; USES:     Flags
 14204                                  ; -----------------------------------------------------------------------------
 14205                                  ; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
 14206                                  ; the specified new size, the split is useless; if it's only 0x10 bytes, that
 14207                                  ; 0x10 will be used to make a header that mentions a 0-byte free space, and
 14208                                  ; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
 14209                                  ; minimum for performing a split.
 14210                                  ; -----------------------------------------------------------------------------
 14211                                  
 14212                                  MIN_SPLIT_SIZE	equ	20h
 14213                                  
 14214                                  shrinkMCB:
 14215                                  	;pushreg <bx, cx, es>
 14216                                  	push	bx
 14217                                  	push	cx
 14218                                  	push	es
 14219                                  
 14220                                  	mov	bx,ax			; Move things around... and
 14221                                  	mov	ax,es			; save this one for later.
 14222                                  
 14223                                  	mov	cx,[es:ARENA.SIZE]
 14224                                  	sub	cx,MIN_SPLIT_SIZE ; 32
 14225                                  	cmp	bx,cx			; {New size} vs {Current Size-20h}
 14226                                  	ja	short smE		; if wanted_size > cur-20h, abort.
 14227                                  
 14228                                  	mov	dl,[es:ARENA.SIGNATURE]
 14229                                  	mov	cx,[es:ARENA.SIZE]
 14230                                  
 14231                                  	mov	[es:ARENA.SIZE],bx
 14232                                  	mov	byte [es:ARENA.SIGNATURE],'M'
 14233                                  
 14234                                  	add	ax,bx
 14235                                  	inc	ax
 14236                                  	mov	es,ax			; Move to new arena area
 14237                                  
 14238                                  	mov	ax,cx
 14239                                  	sub	ax,bx
 14240                                  	dec	ax			; And prepare the new size
 14241                                  
 14242                                  	mov	[es:ARENA.SIGNATURE],dl
 14243                                  	mov	word [es:ARENA.OWNER],0
 14244                                  	mov	[es:ARENA.SIZE],ax
 14245                                  	mov	ax,'  ' ; 2020h
 14246                                  	mov	[es:ARENA.NAME+0],ax
 14247                                  	mov	[es:ARENA.NAME+2],ax
 14248                                  	mov	[es:ARENA.NAME+4],ax
 14249                                  	mov	[es:ARENA.NAME+6],ax
 14250                                  
 14251                                  	clc
 14252                                  	jmp	short smX
 14253                                  smE:	
 14254                                  	stc
 14255                                  smX:	
 14256                                  	;popreg	<es, cx, bx>
 14257                                  	pop	es
 14258                                  	pop	cx
 14259                                  	pop	bx
 14260                                  	retn
 14261                                  
 14262                                  ; -----------------------------------------------------------------------------
 14263                                  ;*** hideUMB? - hides as appropriate the UMB in CL
 14264                                  ; -----------------------------------------------------------------------------
 14265                                  ; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
 14266                                  ; EXIT:     None; UMB is hidden as necessary
 14267                                  ; ERROR:    None
 14268                                  ; USES:     Flags, AX, CX
 14269                                  ; -----------------------------------------------------------------------------
 14270                                  ; PRIMARY LOGIC:
 14271                                  ;
 14272                                  ; If the UMB is specified in the DH/LH statement, then:
 14273                                  ;    If the largest free segment is too small (check specified size), then:
 14274                                  ;       Pretend it wasn't ever specified, and fall out of this IF.
 14275                                  ;    Else, if largest free segment is LARGER than specified size, then:
 14276                                  ;       If /S was given on the command-line, then:
 14277                                  ;          Break that element into two pieces
 14278                                  ;          Set a flag that we're shrinking
 14279                                  ;       Endif
 14280                                  ;    Endif
 14281                                  ; Endif
 14282                                  ; If the UMB is NOT specified (or was removed by the above):
 14283                                  ;    Hide all free elements in the UMB
 14284                                  ;    If the flag that we're shrinking was set, then:
 14285                                  ;       UN-hide the lower portion of the shrunken UMB
 14286                                  ;    ENDIF
 14287                                  ; ENDIF
 14288                                  ; -----------------------------------------------------------------------------
 14289                                  
 14290                                  _hideUMB_:
 14291                                  	push	bx
 14292                                  	push	dx
 14293                                  	push	es
 14294                                  
 14295                                  	mov	al,cl
 14296                                  	call	isSpecified	; Returns ZF set if al's umb was NOT specified
 14297                                  	jz	short hu_20
 14298                                  
 14299                                  	mov	al,cl		; Retrieve the size of the largest
 14300                                  	call	BigFree		; free element in AX; put its address in ES
 14301                                  	jc	short hu_20	; Oops. Errors mean skip this part.
 14302                                  
 14303                                  	push	ax		; TOS==size of BigFree in UMB (popped as BX)
 14304                                  	mov	al,cl		; Retrieve the user's specified
 14305                                  	call	GetSize		; minimum size for this umb (into AX)
 14306                                  	pop	bx		; Now BX==BigFree, AX==Specified Size
 14307                                  
 14308                                  	or	ax,ax		; If they didn't specify one,
 14309                                  	jz	short hu_20	; Skip over all this.
 14310                                  
 14311                                  	cmp	ax,bx		; Ah... if (specified > max free)
 14312                                  	jbe	short hu_10
 14313                                  
 14314                                  	mov	al,cl		;   Then mark that UMB as unused. Nya nya.
 14315                                  	call	unMarkUMB
 14316                                  	jmp	short hu_20
 14317                                  hu_10:	
 14318                                  	call	isTiny		; Returns ZF clear if user specified /S
 14319                                  	jz	short hu_20
 14320                                  
 14321                                  	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
 14322                                  	jc	short hu_20	; Ah... if didn't shrink after all, skip this:
 14323                                  
 14324                                  	mov	dx,es
 14325                                  	jmp	short hu_30	; Skip the spec check.. we wanna hide this one.
 14326                                  
 14327                                  hu_20:	mov	ax,cx
 14328                                  	call	isSpecified	; If they specified this UMB, we're done...
 14329                                  	jnz	short hu_X	; so leave.
 14330                                  
 14331                                  	xor	dx,dx
 14332                                  hu_30:	
 14333                                  	mov	al,cl
 14334                                  
 14335                                  	call	hideUMB		; Hides everything in UMB #al
 14336                                  
 14337                                  	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
 14338                                  	jz	short hu_X	; So we should leave.
 14339                                  
 14340                                  	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
 14341                                  	call	unHideMCB	; Un-hides the lower portion of that MCB.
 14342                                  hu_X:	
 14343                                  	pop	es
 14344                                  	pop	dx
 14345                                  	pop	bx
 14346                                  	retn
 14347                                  
 14348                                  ; -----------------------------------------------------------------------------
 14349                                  ;*** UnFreeze - Marks FROZEN elements as FREE
 14350                                  ; -----------------------------------------------------------------------------
 14351                                  ; Entry:  None
 14352                                  ; Exit:   None; all 8+FROZEN elements are marked as FREE, from any UMB.
 14353                                  ; Error:  None
 14354                                  ; Uses:   Flags
 14355                                  ; -----------------------------------------------------------------------------
 14356                                  
 14357                                  UnFreeze:
 14358                                  	push	ax
 14359                                  	push	es
 14360                                  
 14361                                  	call	UmbHead		; Returns with carry if err, else ES == MCB
 14362                                  	jc	short ufX
 14363                                  
 14364                                  	mov	es,ax
 14365                                  
 14366                                  ; ------------------------------
 14367                                  ; UF10--ES - Current MCB address
 14368                                  ; ------------------------------
 14369                                  
 14370                                  uf10:	call	isFrozMCB	; Returns with ZF set if MCB is FROZEN
 14371                                  	jnz	short uf20
 14372                                  	call	unHideMCB
 14373                                  uf20:	
 14374                                  	mov	al,[es:ARENA.SIGNATURE]
 14375                                  
 14376                                  	cmp	al,arena_signature_end ; 'Z'
 14377                                  	jz	short ufX	; 'Z' means this was the last MCB... that's it.
 14378                                  
 14379                                  	;NextMCB es, ax		; Go on forward.
 14380                                  	mov     ax,es
 14381                                  	;add	ax,[es:3]
 14382                                  	add     ax,[es:ARENA.SIZE]
 14383                                  	inc     ax
 14384                                  	mov     es,ax
 14385                                  
 14386                                  	jmp	short uf10
 14387                                  ufX:	
 14388                                  	pop	es
 14389                                  	pop	ax
 14390                                  	retn
 14391                                  
 14392                                  ; -----------------------------------------------------------------------------
 14393                                  ;*** isFrozMCB - returns with ZF set if current MCB (ES:0) is FROZEN
 14394                                  ; -----------------------------------------------------------------------------
 14395                                  ; ENTRY:    ES:0 should point to an MCB
 14396                                  ; EXIT:     ZF set if MCB is frozen, else !ZF
 14397                                  ; ERROR:    None
 14398                                  ; USES:     Flags
 14399                                  ; -----------------------------------------------------------------------------
 14400                                  
 14401                                  isFrozMCB:
 14402                                  	;push	ax
 14403                                  
 14404                                  	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
 14405                                  	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
 14406                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner
 14407                                  	jne	short ifmX
 14408                                  
 14409                                  	;mov	ax,[es:ARENA.NAME+0]
 14410                                  	;cmp	ax,'FR' ; 5246h
 14411                                  	cmp	word [es:ARENA.NAME+0],'FR'
 14412                                  	jne	short ifmX
 14413                                  	;mov	ax,[es:ARENA.NAME+2]
 14414                                  	;cmp	ax,'OZ' ; 5A4Fh
 14415                                  	cmp	word [es:ARENA.NAME+2],'OZ'
 14416                                  	jne	short ifmX
 14417                                  	;mov	ax,[es:ARENA.NAME+4]
 14418                                  	;cmp	ax,'EN' ; 4E45h
 14419                                  	cmp	word [es:ARENA.NAME+4],'EN'
 14420                                  	jne	short ifmX
 14421                                  	;mov	ax,[es:ARENA.NAME+6]
 14422                                  	;cmp	ax,'  ' ; 2020h
 14423                                  	cmp	word [es:ARENA.NAME+6],'  '
 14424                                  ifmX:	
 14425                                  	;pop	ax
 14426                                  	retn
 14427                                  
 14428                                  ; -----------------------------------------------------------------------------
 14429                                  ;*** frezMCB - marks as 8+FROZEN the MCB at ES:0
 14430                                  ; -----------------------------------------------------------------------------
 14431                                  ; ENTRY:    ES:0 should point to an MCB
 14432                                  ; EXIT:     None; MCB frozen
 14433                                  ; ERROR:    None
 14434                                  ; USES:     None
 14435                                  ; -----------------------------------------------------------------------------
 14436                                  
 14437                                  frezMCB:
 14438                                  	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
 14439                                  	mov	word [es:ARENA.NAME+0],'FR'
 14440                                  	mov	word [es:ARENA.NAME+2],'OZ'
 14441                                  	mov	word [es:ARENA.NAME+4],'EN'
 14442                                  	mov	word [es:ARENA.NAME+6],'  '
 14443                                  	retn
 14444                                  
 14445                                  ; -----------------------------------------------------------------------------
 14446                                  ;*** FreezeUM - Marks FROZEN all UM elements now FREE, save those in load UMB
 14447                                  ; -----------------------------------------------------------------------------
 14448                                  ; Entry:  None
 14449                                  ; Exit:   None; all free elements not in load UMB marked as 8+FROZEN
 14450                                  ; Error:  None
 14451                                  ; Uses:   Flags
 14452                                  ; -----------------------------------------------------------------------------
 14453                                  
 14454                                  FreezeUM:
 14455                                  	push	ax
 14456                                  	push	cx
 14457                                  	push	dx
 14458                                  	push	es
 14459                                  
 14460                                  	;call	GetLoadUMB
 14461                                  	mov	al,[cs:UmbLoad] ; 19/04/2019 - Retro DOS v4.0
 14462                                  
 14463                                  	xor	ah,ah		; Zap ah, so al==ax
 14464                                  	mov	dx,ax		; Store the load UMB in DX, so we can skip it
 14465                                  
 14466                                  	call	UmbHead		; Returns first UMB segment in AX
 14467                                  	mov	es,ax
 14468                                  	xor	cx,cx		; Pretend we're on UMB 0 for now...
 14469                                  
 14470                                  ; -----------------------------------------
 14471                                  ; FUM10--ES - Current MCB address
 14472                                  ;        CX - Current UMB number
 14473                                  ;        DX - UMB number to skip (load UMB)
 14474                                  ; -----------------------------------------
 14475                                  
 14476                                  fum10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 14477                                  	jnz	short fum20
 14478                                  
 14479                                  	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 14480                                  fum20:	
 14481                                  	cmp	cx,dx		; If this is the load UMB, we don't want to
 14482                                  	je	short fum30	; freeze anything... so skip that section.
 14483                                  
 14484                                  	;call	isFreeMCB	; Oh.  If it's not free, we can't freeze it
 14485                                  	or	word [es:ARENA.OWNER],0
 14486                                  	jnz	short fum30	; either.
 14487                                  
 14488                                  	call	frezMCB
 14489                                  fum30:	
 14490                                  	mov	al,[es:ARENA.SIGNATURE]
 14491                                  	cmp	al,arena_signature_end ; 'Z'
 14492                                  	je	short fumX	; 'Z' means this was the last MCB... that's it.
 14493                                  
 14494                                  	;NextMCB es, ax		; Go on forward.
 14495                                  	mov     ax,es
 14496                                  	;add	ax,[es:3]
 14497                                  	add     ax,[es:ARENA.SIZE]
 14498                                  	inc     ax
 14499                                  	mov     es,ax
 14500                                  	
 14501                                  	jmp	short fum10
 14502                                  
 14503                                  fumX:	pop	es
 14504                                  	pop	dx
 14505                                  	pop	cx
 14506                                  	pop	ax
 14507                                  	retn
 14508                                  
 14509                                  ; -----------------------------------------------------------------------------
 14510                                  ;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
 14511                                  ; -----------------------------------------------------------------------------
 14512                                  ; ENTRY:    None
 14513                                  ; EXIT:     Carry is clear if UMBs are available, or set if they are not
 14514                                  ; ERROR:    None
 14515                                  ; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
 14516                                  ; -----------------------------------------------------------------------------
 14517                                  
 14518                                  UmbTest:
 14519                                  	push	ax
 14520                                  	push	bx
 14521                                  	push	ds
 14522                                  	push	es
 14523                                  
 14524                                  	call	fm_link			; Link in UMBs (if not already linked)
 14525                                  	call	WalkMem			; Check to see if they're really linked
 14526                                  	pushf				; And remember what we found out
 14527                                  	call	fm_unlink		; Unlink UMBs (if WE have linked 'em)
 14528                                  	popf				; And restore what we found out.
 14529                                  
 14530                                  	pop	es
 14531                                  	pop	ds
 14532                                  	pop	bx
 14533                                  	pop	ax
 14534                                  	retn
 14535                                  
 14536                                  ; -----------------------------------------------------------------------------
 14537                                  ;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
 14538                                  ; -----------------------------------------------------------------------------
 14539                                  ; ENTRY:    None
 14540                                  ; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
 14541                                  ; ERROR:    None
 14542                                  ; USES:     Flags
 14543                                  ; -----------------------------------------------------------------------------
 14544                                  
 14545                                  WalkMem:
 14546                                  	push	ax ; ?
 14547                                  	push	bx ; ?
 14548                                  	push	es ; ? no need to save contents of these registers ?
 14549                                  		   	
 14550                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 14551                                  	int	21h
 14552                                  
 14553                                  	mov	ax,[es:bx-2]
 14554                                  	mov	es,ax
 14555                                  
 14556                                  ; ------------------------------
 14557                                  ; UM10: ES = Current MCB pointer
 14558                                  ; ------------------------------
 14559                                  
 14560                                  um10:	mov	al,[es:ARENA.SIGNATURE]
 14561                                  	cmp	al,arena_signature_end ;  'Z'
 14562                                  	je	short um20		; If signature == 'Z', hay no more.
 14563                                  
 14564                                  	;NextMCB es, bx			; Move to the next MCB
 14565                                  
 14566                                  	mov     bx,es
 14567                                  	;add	bx,[es:3]
 14568                                  	add     bx,[es:ARENA.SIZE]
 14569                                  	inc     bx
 14570                                  	mov     es,bx
 14571                                  		
 14572                                  	jmp	short um10		; And restart the loop.
 14573                                  um20:	
 14574                                  	mov	ax,es
 14575                                  
 14576                                  	cmp	ax,9FFFh		; This sets CF iff ax < 9FFF.
 14577                                  
 14578                                  	pop	es ; ?
 14579                                  	pop	bx ; ?
 14580                                  	pop	ax ; ?
 14581                                  	retn
 14582                                  
 14583                                  ; -----------------------------------------------------------------------------
 14584                                  ;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
 14585                                  ; -----------------------------------------------------------------------------
 14586                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 14587                                  ; EXIT:     None
 14588                                  ; ERROR:    None
 14589                                  ; USES:     AX, BX
 14590                                  ; -----------------------------------------------------------------------------
 14591                                  
 14592                                  hl_unlink:
 14593                                  	xor	bh,bh
 14594                                  
 14595                                  	;getdata bl,fm_umb		; Restore original link-state
 14596                                  	;
 14597                                  	;push	ds
 14598                                  	;push	cs
 14599                                  	;pop	ds
 14600                                  	;mov	bl,[fm_umb]
 14601                                  	;pop	ds
 14602                                  
 14603                                  	mov	bl,[cs:fm_umb]
 14604                                  
 14605                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 14606                                  	int	21h
 14607                                  	retn
 14608                                  
 14609                                  ; ----------------------------------------------------------------------
 14610                                  ; HIGHEXIT.INC (MSDOS 6.0 - 1991) 	
 14611                                  ; ----------------------------------------------------------------------
 14612                                  ; 09/04/2019 - Retro DOS v4.0
 14613                                  
 14614                                  ;   Module:   HIGHEXIT.INC - Code executed after LoadHigh or DeviceHigh
 14615                                  ;   Date:     May 14, 1992
 14616                                  
 14617                                  ;   Modification log:
 14618                                  ;
 14619                                  ;     DATE    WHO      DESCRIPTION
 14620                                  ;   --------  -------  --------------------------------------------------------
 14621                                  ;   05/14/92  t-richj  Original
 14622                                  ;   06/21/92  t-richj  Final revisions before check-in
 14623                                  
 14624                                  UMB_HeadIdx	equ	8Ch	; Offset from ES (after func52h) to get UMBHead
 14625                                  
 14626                                  ; -----------------------------------------------------------------------------
 14627                                  ;*** UnHideUMBs - Marks HIDDEN elements as FREE
 14628                                  ; -----------------------------------------------------------------------------
 14629                                  ; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
 14630                                  ;               very little to do, as no elelments will be marked as HIDDEN.
 14631                                  ; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
 14632                                  ; ERROR:  None
 14633                                  ; USES:   fInHigh (from highvar.inc), carry flag
 14634                                  ; -----------------------------------------------------------------------------
 14635                                  
 14636                                  UnHideUMBs:
 14637                                  	push	ax		; Save ax for what we're about to do
 14638                                  
 14639                                  ; -----------------------------------------------------------------------------
 14640                                  ; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
 14641                                  ;    length of time. Those six constitute a check of whether or not we should
 14642                                  ;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
 14643                                  ;    will destroy the current link-state and memory-allocation strategy after
 14644                                  ;    every command execution.
 14645                                  ; -----------------------------------------------------------------------------
 14646                                  
 14647                                  	;getdata al,fInHigh	; Get InHigh from data segment
 14648                                  	;
 14649                                  	;push	ds
 14650                                  	;push	cs
 14651                                  	;pop	ds
 14652                                  	;mov	al,[fInHigh]
 14653                                  	;pop	ds	
 14654                                  
 14655                                  	mov	al,[cs:fInHigh]
 14656                                  
 14657                                  	or	al,al
 14658                                  	jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
 14659                                  
 14660                                  	pop	ax		; then there's nothing to do here... so
 14661                                  	stc			; restore everything and return. Just like
 14662                                  	retn			; that.
 14663                                  uhu10:	
 14664                                  	call	linkumb		; Make sure UMBs are linked in.
 14665                                  	call	FreeUMBs
 14666                                  
 14667                                  	;putdata fInHigh,0	; We're leaving, so update fInHigh.
 14668                                  	;
 14669                                  	;push	es
 14670                                  	;push	cs
 14671                                  	;pop	es
 14672                                  	;mov	byte [es:fInHigh],0
 14673                                  	;pop	ds	
 14674                                  
 14675                                  	mov	byte [cs:fInHigh],0	
 14676                                  
 14677                                  	call	he_unlink	; Unlink UMBs
 14678                                  
 14679                                  	pop	ax
 14680                                  	clc
 14681                                  	retn
 14682                                  
 14683                                  ; -----------------------------------------------------------------------------
 14684                                  ;*** he_unlink - unlinks UMBs if fm_umb is set to 0
 14685                                  ; -----------------------------------------------------------------------------
 14686                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 14687                                  ; EXIT:     None
 14688                                  ; ERROR:    None
 14689                                  ; USES:     AX, BX
 14690                                  ; -----------------------------------------------------------------------------
 14691                                  
 14692                                  he_unlink:
 14693                                  	xor	bh, bh
 14694                                  
 14695                                  	;getdata bl, fm_umb	; Restore original link-state
 14696                                  	mov	bl,[cs:fm_umb]	
 14697                                  
 14698                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 14699                                  	int	21h
 14700                                  	retn
 14701                                  
 14702                                  ; -----------------------------------------------------------------------------
 14703                                  ;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
 14704                                  ; -----------------------------------------------------------------------------
 14705                                  ; ENTRY:    None
 14706                                  ; EXIT:     None; HIDDEN memory elements returned to FREE
 14707                                  ; ERROR:    None (ignore CF)
 14708                                  ; USES:     Flags
 14709                                  ; -----------------------------------------------------------------------------
 14710                                  
 14711                                  FreeUMBs:
 14712                                  	push	ax
 14713                                  	push	es
 14714                                  
 14715                                  	call	HeadUmb		; Returns with carry if err, else ES == MCB
 14716                                  	jc	short fusX
 14717                                  
 14718                                  	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
 14719                                  fus10:	
 14720                                  	call	isHideMCB	; Returns with ZF set if owner is 0
 14721                                  	jnz	short fus20
 14722                                  	call	freeMCB
 14723                                  fus20:	   
 14724                                  	mov	al,[es:ARENA.SIGNATURE]
 14725                                  	cmp	al,arena_signature_end ; 'Z'
 14726                                  	jz	short fusX	; That means this was the last MCB--that's it.
 14727                                  
 14728                                  	mov	ax,es
 14729                                  	add	ax,[es:ARENA.SIZE]
 14730                                  	inc	ax
 14731                                  	mov	es,ax		; Go on forward.
 14732                                  
 14733                                  	jmp	short fus10
 14734                                  fusX:	
 14735                                  	pop	es
 14736                                  	pop	ax
 14737                                  	retn
 14738                                  
 14739                                  ; -----------------------------------------------------------------------------
 14740                                  ;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
 14741                                  ; -----------------------------------------------------------------------------
 14742                                  ; ENTRY:    ES:0 should point to an MCB
 14743                                  ; EXIT:     ZF set if MCB is hidden, else !ZF
 14744                                  ; ERROR:    None
 14745                                  ; USES:     Flags
 14746                                  ; -----------------------------------------------------------------------------
 14747                                  
 14748                                  isHideMCB:
 14749                                  	;push	ax
 14750                                  
 14751                                  	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; If the owner's SYSTEM
 14752                                  	jne	short ihm_x				; then check for HIDDEN
 14753                                  
 14754                                  	;mov	ax,[es:ARENA.NAME]
 14755                                  	;cmp	ax,'HI' ; 4948h
 14756                                  	cmp	word [es:ARENA.NAME+0],'HI'
 14757                                  	jne	short ihm_x
 14758                                  	;mov	ax,[es:ARENA.NAME+2]
 14759                                  	;cmp	ax,'DD' ; 4444h
 14760                                  	cmp	word [es:ARENA.NAME+2],'DD'
 14761                                  	jne	short ihm_x
 14762                                  	;mov	ax,[es:ARENA.NAME+4]
 14763                                  	;cmp	ax,'EN' ; 4E45h
 14764                                  	cmp	word [es:ARENA.NAME+4],'EN'
 14765                                  	jne	short ihm_x
 14766                                  	;mov	ax,[es:ARENA.NAME+6]
 14767                                  	;cmp	ax,'  ' ; 2020h
 14768                                  	cmp	word [es:ARENA.NAME+6],'  '
 14769                                  ihm_x:	
 14770                                  	;pop	ax
 14771                                  	retn
 14772                                  
 14773                                  ; -----------------------------------------------------------------------------
 14774                                  ;*** freeMCB - marks as free the MCB at ES:0
 14775                                  ; -----------------------------------------------------------------------------
 14776                                  ; ENTRY:    ES:0 should point to an MCB
 14777                                  ; EXIT:     None; MCB free'd
 14778                                  ; ERROR:    None
 14779                                  ; USES:     AX
 14780                                  ; -----------------------------------------------------------------------------
 14781                                  
 14782                                  freeMCB:
 14783                                  	mov	word [es:ARENA.OWNER],0
 14784                                  	mov	ax,'  '
 14785                                  	mov	[es:ARENA.NAME+0],ax
 14786                                  	mov	[es:ARENA.NAME+2],ax
 14787                                  	mov	[es:ARENA.NAME+4],ax
 14788                                  	mov	[es:ARENA.NAME+6],ax
 14789                                  	retn
 14790                                  
 14791                                  ; -----------------------------------------------------------------------------
 14792                                  ;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
 14793                                  ; -----------------------------------------------------------------------------
 14794                                  ; ENTRY:  Nothing
 14795                                  ; EXIT:   AX contains 0x9FFF for most systems
 14796                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 14797                                  ; USES:   Flags, AX
 14798                                  ; -----------------------------------------------------------------------------
 14799                                  
 14800                                  HeadUmb:
 14801                                  	; 13/05/2019
 14802                                  
 14803                                  	;push	si ; ?
 14804                                  	;push	ds ; ?
 14805                                  	;push	es
 14806                                  	;push	bx ; *
 14807                                  
 14808                                  	; 09/04/2019
 14809                                  	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)
 14810                                  
 14811                                  	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
 14812                                  	int	21h
 14813                                  			; DOS - 2+ internal - GET LIST OF LISTS
 14814                                  			; Return: ES:BX -> DOS list of lists
 14815                                  	;mov	ax,[es:8Ch]
 14816                                  	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008C
 14817                                  	cmp	ax,0FFFFh
 14818                                  	;je	short xhu_e		; If it's 0xFFFF, it's an error...
 14819                                  
 14820                                  	;clc				; Else, it isn't.
 14821                                  	;jmp	short xhu_x
 14822                                  xhu_e:	
 14823                                  	;stc
 14824                                  	cmc	; 09/04/2019 - Retro DOS v4.0 ; *
 14825                                  xhu_x:	
 14826                                  	;pop	bx ; *
 14827                                  	;pop	es	
 14828                                  	;pop	ds ; ?
 14829                                  	;pop	si ; ?
 14830                                  	retn
 14831                                  
 14832                                  ; -----------------------------------------------------------------------------
 14833                                  ;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
 14834                                  ; -----------------------------------------------------------------------------
 14835                                  ; ENTRY:    None
 14836                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 14837                                  ; ERROR:    None
 14838                                  ; USES:     AX, BX, fm_umb
 14839                                  ; -----------------------------------------------------------------------------
 14840                                  
 14841                                  linkumb:
 14842                                  	mov	ax,DOS_GET_UMBLINK ; 5802h
 14843                                  	int	21h			; Current link-state is now in al
 14844                                  
 14845                                  	or	al,al			; BUGBUG: proper check?
 14846                                  	jnz	short lumbX		; Jumps if UMBs already linked in
 14847                                  
 14848                                  	mov	ax,DOS_SET_UMBLINK ; 5803h
 14849                                  	mov	bx,1
 14850                                  	int	21h
 14851                                  lumbX:
 14852                                  	retn
 14853                                  
 14854                                  %endif
 14855                                  
 14856                                  ; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 14857                                  ; (SYSINIT:2B5Fh)
 14858                                  
 14859                                  ; ----------------------------------------------------------------------
 14860                                  ; SYSCONF.ASM (MSDOS 6.0 - 1991) 	
 14861                                  ; ----------------------------------------------------------------------
 14862                                  ; 09/04/2019 - Retro DOS v4.0
 14863                                  
 14864                                  ;----------------------------------------------------------------------------
 14865                                  ;
 14866                                  ; procedure : InitDevLoad
 14867                                  ;
 14868                                  ;	Input : DeviceHi = 0 indicates load DD in low memory
 14869                                  ;			 = 1 indicates load in UMB:
 14870                                  ;		           ConvLoad = 0 indicates a new-style load (see below)
 14871                                  ;		                    = 1 indicates a DOS 5-style load
 14872                                  ;		DevSize  = Size of the device driver file in paras
 14873                                  ;
 14874                                  ;	Output : none
 14875                                  ;
 14876                                  ;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
 14877                                  ;	Also sets up a header for the Device driver entry for mem utility
 14878                                  ;
 14879                                  ;----------------------------------------------------------------------------
 14880                                  ; For a "new-style load", we break off the current DevEntry and link the umbs
 14881                                  ; as we see fit, using HideUMBs (and UnHideUMBs at exit, though _it_ decides
 14882                                  ; whether it's entitled to do anything). HideUMBs uses the chart built by
 14883                                  ; ParseVar to determine which UMBs to leave FREE, and which not.
 14884                                  ;----------------------------------------------------------------------------
 14885                                  
 14886                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 14887                                  InitDevLoad:
 14888 00002B5F 2E803E[4821]00          	cmp	byte [cs:DeviceHi],0	; Are we loading in UMB ?
 14889                                  	;je	short InitForLo		; no, init for lo mem
 14890 00002B65 7423                    	je	short initforlo_x ; 09/04/2019
 14891                                  
 14892                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 14893                                  ;	cmp	byte [cs:ConvLoad],1	; Are we loading as per DOS 5?
 14894                                  ;	je	short InitForConv
 14895                                  ;
 14896                                  ;; There are two stages to preparing upper-memory; first, we mark as 8+HIDDEN
 14897                                  ;; any areas not specified on the /L:... chain. Second, we mark as 8+FROZEN
 14898                                  ;; any areas left in upper-memory, except for elements in the load UMB...
 14899                                  ;; we then malloc space as per Dos-5 style, and mark as free any spaces which
 14900                                  ;; are 8+FROZEN (but leave 8+HIDDEN still hidden). The load is performed,
 14901                                  ;; and UnHideUMBs later on marks all 8+HIDDEN as free.
 14902                                  ;
 14903                                  ;	call	ShrinkUMB		; Stop using the old device arena
 14904                                  ;
 14905                                  ;	call	HideUMBs		; Mark up the UM area as we see fit
 14906                                  ;	call	FreezeUM		; Hide everything BUT the load area
 14907                                  ;	call	GetUMBForDev		; And grab that load area as needed
 14908                                  ;	pushf
 14909                                  ;	call	UnFreeze		; Then unhide everything frozen
 14910                                  ;	popf
 14911                                  ;
 14912                                  ;	jc	short InitForLo		; (if carry, it's loading low)
 14913                                  ;
 14914                                  ;	jmp	short InitForHi
 14915                                  
 14916                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 14917                                  	; (SYSINIT:2B67h)
 14918                                  InitForConv:
 14919 00002B67 E84100                  	call	SpaceInUMB		; Do we have space left in the
 14920                                  					;  current UMB ?
 14921 00002B6A 7308                    	jnc	short InitForHi		; yes, we have
 14922 00002B6C E88A04                  	call	ShrinkUMB		; shrink the current UMB in use
 14923 00002B6F E85400                  	call	GetUMBForDev		; else try to allocate new UMB
 14924 00002B72 7210                    	jc	short InitForLo		; we didn't succeed, so load
 14925                                  					;  in low memory
 14926                                  InitForHi:
 14927 00002B74 2EA1[3E21]              	mov	ax,[cs:DevUMBFree]	; get Para addr of free mem
 14928 00002B78 2E8B16[3A21]            	mov	dx,[cs:DevUMBAddr]	; UMB start addr
 14929 00002B7D 2E0316[3C21]            	add	dx,[cs:DevUMBSize]	; DX = UMB End addr
 14930 00002B82 EB0F                    	jmp	short idl1
 14931                                  
 14932                                  InitForLo:
 14933 00002B84 2EC606[4821]00          	mov	byte [cs:DeviceHi],0	; in case we failed to load
 14934                                  initforlo_x:
 14935                                  					;  into UMB indicate that
 14936                                  					;  we are loading low
 14937 00002B8A 2EA1[E003]              	mov	ax,[cs:memhi]		; AX = start of Low memory
 14938 00002B8E 2E8B16[A302]            	mov	dx,[cs:ALLOCLIM]	; DX = End of Low memory
 14939                                  
 14940                                  idl1:
 14941 00002B93 E87D00                  	call	DevSetMark		; setup a sub-arena for DD
 14942 00002B96 2EA3[2D21]              	mov	[cs:DevLoadAddr],ax	; init the Device load address
 14943                                  
 14944 00002B9A 2E8916[2F21]            	mov	[cs:DevLoadEnd],dx	; init the limit of the block
 14945 00002B9F 2EC706[3121]0000        	mov	word [cs:DevEntry],0	; init Entry point to DD
 14946 00002BA6 2EA3[3321]              	mov	[cs:DevEntry+2],ax
 14947 00002BAA C3                      	retn
 14948                                  
 14949                                  ;----------------------------------------------------------------------------
 14950                                  ;
 14951                                  ; procedure : SpaceInUMB?
 14952                                  ;
 14953                                  ;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
 14954                                  ;	Output : Carry set if no space in UMB
 14955                                  ;		 Carry clear if Space is available for the device in
 14956                                  ;		   current UMB
 14957                                  ;
 14958                                  ;----------------------------------------------------------------------------
 14959                                  
 14960                                  SpaceInUMB:
 14961 00002BAB 2EA1[3C21]              	mov	ax,[cs:DevUMBSize]
 14962 00002BAF 2E0306[3A21]            	add	ax,[cs:DevUMBAddr]	; End of UMB
 14963 00002BB4 2E2B06[3E21]            	sub	ax,[cs:DevUMBFree]	; - Free = Remaining space
 14964 00002BB9 09C0                    	or	ax,ax			; Nospace ?
 14965 00002BBB 7502                    	jnz	short spcinumb1
 14966 00002BBD F9                      	stc
 14967 00002BBE C3                      	retn
 14968                                  spcinumb1:
 14969 00002BBF 48                      	dec	ax			; space for sub-arena
 14970 00002BC0 2E3B06[2B21]            	cmp	ax,[cs:DevSize]		; do we have space ?
 14971 00002BC5 C3                      	retn
 14972                                  
 14973                                  ;----------------------------------------------------------------------------
 14974                                  ;
 14975                                  ; procedure : PrepareMark
 14976                                  ;
 14977                                  ;	Input : AX==Address of MCB (not addr of free space), BX==Size
 14978                                  ;	Output : None; MCB marked appropriately and DevUMB* set as needed.
 14979                                  ;
 14980                                  ;----------------------------------------------------------------------------
 14981                                  
 14982                                  ;	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 14983                                  ;
 14984                                  ;PrepareMark:
 14985                                  ;	push	ds
 14986                                  ;	mov	ds,ax
 14987                                  ;	mov	word [ARENA.OWNER],8
 14988                                  ;	mov	word [ARENA.NAME],'SD' ; 4453h
 14989                                  ;	pop	ds
 14990                                  ;
 14991                                  ;	inc	ax
 14992                                  ;	mov	[cs:DevUMBAddr],ax
 14993                                  ;	mov	[cs:DevUMBFree],ax
 14994                                  ;	mov	[cs:DevUMBSize],bx	; update the UMB Variables
 14995                                  ;	retn
 14996                                  
 14997                                  ;----------------------------------------------------------------------------
 14998                                  ;
 14999                                  ; procedure : GetUMBForDev
 15000                                  ;
 15001                                  ;	Input : DevSize
 15002                                  ;	Output : Carry set if couldn't allocate a UMB to fit the
 15003                                  ;		 the device.
 15004                                  ;		 If success carry clear
 15005                                  ;
 15006                                  ;	Allocates the biggest UMB for loading devices and updates
 15007                                  ;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
 15008                                  ;	UMB.
 15009                                  ;
 15010                                  ;	This routine relies on the fact that all of the low memory
 15011                                  ;	is allocated, and any DOS alloc calls should return memory
 15012                                  ;	from the UMB pool.
 15013                                  ;
 15014                                  ;----------------------------------------------------------------------------
 15015                                  
 15016                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15017                                  	; (SYSINIT:2BC6h)
 15018                                  
 15019                                  GetUMBForDev:
 15020 00002BC6 BBFFFF                  	mov	bx,0FFFFh
 15021 00002BC9 B80048                  	mov	ax,4800h
 15022 00002BCC CD21                    	int	21h
 15023                                  		; DOS - 2+ - ALLOCATE MEMORY
 15024                                  		; BX = number of 16-byte paragraphs desired
 15025                                  
 15026 00002BCE 09DB                    	or	bx,bx
 15027 00002BD0 7431                    	jz	short gufd_err
 15028                                  
 15029 00002BD2 4B                      	dec	bx
 15030 00002BD3 2E391E[2B21]            	cmp	[cs:DevSize],bx
 15031 00002BD8 7729                    	ja	short gufd_err
 15032 00002BDA 43                      	inc	bx
 15033                                  
 15034 00002BDB B80048                  	mov	ax,4800h
 15035 00002BDE CD21                    	int	21h
 15036 00002BE0 7221                    	jc	short gufd_err
 15037                                  
 15038                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15039                                  	;dec	ax
 15040                                  	;call	PrepareMark
 15041                                  	;
 15042                                  PrepareMark:
 15043 00002BE2 1E                      	push	ds
 15044 00002BE3 48                      	dec	ax
 15045 00002BE4 8ED8                    	mov	ds,ax
 15046 00002BE6 C70601000800            	mov	word [ARENA.OWNER],8
 15047 00002BEC C70608005344            	mov	word [ARENA.NAME],'SD' ; 4453h
 15048 00002BF2 40                      	inc	ax
 15049 00002BF3 1F                      	pop	ds
 15050 00002BF4 2E891E[3C21]            	mov	[cs:DevUMBSize],bx	; update the UMB Variables
 15051 00002BF9 2EA3[3A21]              	mov	[cs:DevUMBAddr],ax
 15052 00002BFD 2EA3[3E21]              	mov	[cs:DevUMBFree],ax
 15053                                  	;
 15054 00002C01 F8                      	clc				; mark no error
 15055 00002C02 C3                      	retn
 15056                                  gufd_err:
 15057 00002C03 31C0                    	xor	ax,ax ; 0
 15058 00002C05 2EA3[3C21]              	mov	[cs:DevUMBSize],ax	; erase the previous values
 15059 00002C09 2EA3[3A21]              	mov	[cs:DevUMBAddr],ax
 15060 00002C0D 2EA3[3E21]              	mov	[cs:DevUMBFree],ax
 15061 00002C11 F9                      	stc
 15062 00002C12 C3                      	retn
 15063                                  
 15064                                  ;----------------------------------------------------------------------------
 15065                                  ;
 15066                                  ; procedure : DevSetMark
 15067                                  ;
 15068                                  ;	Input : AX - Free segment were device is going to be loaded
 15069                                  ;	Output : AX - Segment at which device can be loaded (AX=AX+1)
 15070                                  ;
 15071                                  ;	Creates a sub-arena for the device driver
 15072                                  ;	puts 'D' marker in the sub-arena
 15073                                  ;	Put the owner of the sub-arena as (AX+1)
 15074                                  ;	Copies the file name into sub-arena name field
 15075                                  ;
 15076                                  ;	Size field of the sub-arena will be set only at succesful
 15077                                  ;	completion of Device load.
 15078                                  ;
 15079                                  ;----------------------------------------------------------------------------
 15080                                  
 15081                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15082                                  	; (SYSINIT:2C13h)
 15083                                  
 15084                                  DevSetMark:
 15085 00002C13 06                      	push	es
 15086 00002C14 57                      	push	di
 15087 00002C15 1E                      	push	ds
 15088 00002C16 56                      	push	si
 15089 00002C17 8EC0                    	mov	es,ax
 15090 00002C19 26C606000044            	mov	byte [es:devmark.id],devmark_device ; 'D'
 15091 00002C1F 40                      	inc	ax
 15092 00002C20 26A30100                	mov	[es:devmark.seg],ax
 15093                                  
 15094                                  ;-------------- Copy file name
 15095                                  
 15096 00002C24 50                      	push	ax			; save load addr
 15097 00002C25 2EC536[F803]            	lds	si,[cs:bpb_addr]	; command line is still there
 15098                                  
 15099 00002C2A 89F7                    	mov	di,si
 15100 00002C2C FC                      	cld
 15101                                  dsm_again:
 15102 00002C2D AC                      	lodsb
 15103 00002C2E 3C3A                    	cmp	al,':'
 15104 00002C30 7504                    	jne	short isit_slash
 15105 00002C32 89F7                    	mov	di,si
 15106 00002C34 EBF7                    	jmp	short dsm_again
 15107                                  isit_slash:
 15108 00002C36 3C5C                    	cmp	al, '\'
 15109 00002C38 7504                    	jne	short isit_null
 15110 00002C3A 89F7                    	mov	di,si
 15111 00002C3C EBEF                    	jmp	short dsm_again
 15112                                  isit_null:
 15113 00002C3E 08C0                    	or	al,al
 15114 00002C40 75EB                    	jnz	short dsm_again
 15115 00002C42 89FE                    	mov	si,di
 15116                                  
 15117 00002C44 BF0800                  	mov	di,devmark.filename ; 8
 15118 00002C47 B90800                  	mov	cx,8			; maximum 8 characters
 15119                                  dsm_next_char:
 15120 00002C4A AC                      	lodsb
 15121 00002C4B 08C0                    	or	al, al
 15122 00002C4D 7407                    	jz	short blankout
 15123 00002C4F 3C2E                    	cmp	al, '.'
 15124 00002C51 7403                    	je	short blankout
 15125 00002C53 AA                      	stosb
 15126 00002C54 E2F4                    	loop	dsm_next_char
 15127                                  blankout:
 15128 00002C56 E304                    	jcxz	dsm_exit
 15129 00002C58 B020                    	mov	al, ' '
 15130 00002C5A F3AA                    	rep	stosb			; blank out the rest
 15131                                  dsm_exit:
 15132 00002C5C 58                      	pop	ax			; restore load addr
 15133 00002C5D 5E                      	pop	si
 15134 00002C5E 1F                      	pop	ds
 15135 00002C5F 5F                      	pop	di
 15136 00002C60 07                      	pop	es
 15137 00002C61 C3                      	retn
 15138                                  
 15139                                  ;----------------------------------------------------------------------------
 15140                                  ;
 15141                                  ; procedure : SizeDevice
 15142                                  ;
 15143                                  ;	Input : ES:SI - points to device file to be sized
 15144                                  ;
 15145                                  ;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
 15146                                  ;
 15147                                  ;	Calculates the size of the device file in paras and stores it
 15148                                  ;	in DevSize
 15149                                  ;
 15150                                  ;----------------------------------------------------------------------------
 15151                                  
 15152                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15153                                  SizeDevice:
 15154                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15155                                  	;push	ds
 15156 00002C62 06                      	push	es
 15157 00002C63 1F                      	pop	ds
 15158 00002C64 89F2                    	mov	dx,si			; ds:dx -> file name
 15159 00002C66 B8003D                  	mov	ax,3D00h		; open
 15160 00002C69 CD21                    	int	21h
 15161 00002C6B 7243                    	jc	short sd_err		; open failed
 15162                                  
 15163 00002C6D 89C3                    	mov	bx,ax			; BX - file handle
 15164 00002C6F B80242                  	mov	ax,4202h		; seek
 15165 00002C72 31C9                    	xor	cx,cx
 15166 00002C74 89CA                    	mov	dx,cx			; to end of file
 15167 00002C76 CD21                    	int	21h
 15168 00002C78 722F                    	jc	short sd_close		; did seek fail (impossible)
 15169 00002C7A 83C00F                  	add	ax,15			; para convert
 15170 00002C7D 83D200                  	adc	dx,0
 15171 00002C80 F7C2F0FF                	test	dx,0FFF0h		; size > 0ffff paras ?
 15172 00002C84 7409                    	jz	short szdev1		; no
 15173 00002C86 2EC706[2B21]FFFF        	mov	word [cs:DevSize],0FFFFh ; invalid device size
 15174                                  					; assuming that we fail later
 15175 00002C8D EB1A                    	jmp	short sd_close
 15176                                  szdev1:
 15177 00002C8F B104                    	mov	cl,4			; convert it to paras
 15178 00002C91 D3E8                    	shr	ax,cl
 15179 00002C93 B10C                    	mov	cl,12
 15180 00002C95 D3E2                    	shl	dx,cl
 15181 00002C97 09D0                    	or	ax,dx
 15182                                  	;
 15183                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15184 00002C99 2E3B06[4921]            	cmp     ax, [cs:DevSizeOption]
 15185 00002C9E 7704                    	ja      short szdev2
 15186 00002CA0 2EA1[4921]              	mov     ax, [cs:DevSizeOption]
 15187                                  szdev2:
 15188                                  	;
 15189 00002CA4 2EA3[2B21]              	mov	[cs:DevSize],ax		; save file size
 15190                                  
 15191                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15192 00002CA8 F8                      	clc
 15193                                  sd_close:
 15194 00002CA9 9C                      	pushf				; let close not spoil our
 15195                                  					;  carry flag
 15196 00002CAA B8003E                  	mov	ax,3E00h		; close
 15197 00002CAD CD21                    	int	21h			; we are not checking for err
 15198 00002CAF 9D                      	popf
 15199                                  sd_err:
 15200                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15201                                  	;pop     ds
 15202 00002CB0 C3                      	retn
 15203                                  
 15204                                  ;----------------------------------------------------------------------------
 15205                                  ;
 15206                                  ; procedure : ExecDev
 15207                                  ;
 15208                                  ;	Input : ds:dx -> device to be executed
 15209                                  ;		DevLoadAddr - contains where device has to be loaded
 15210                                  ;
 15211                                  ;	Output : Carry if error
 15212                                  ;		 Carry clear if no error
 15213                                  ;
 15214                                  ;	Loads a device driver using the 4b03h function call
 15215                                  ;
 15216                                  ;----------------------------------------------------------------------------
 15217                                  
 15218                                  	; 01/11/2022
 15219                                  ExecDev:
 15220 00002CB1 2E8B1E[2D21]            	mov	bx,[cs:DevLoadAddr]
 15221 00002CB6 2E891E[4421]            	mov	[cs:DevExecAddr],bx	; Load the parameter block
 15222                                  					;  block for exec with
 15223                                  					;  Load address
 15224 00002CBB 2E891E[4621]            	mov	[cs:DevExecReloc],bx
 15225 00002CC0 8CCB                    	mov	bx,cs
 15226 00002CC2 8EC3                    	mov	es,bx
 15227 00002CC4 BB[4421]                	mov	bx,DevExecAddr		;es:bx points to parameters
 15228 00002CC7 B003                    	mov	al,3	; (load program only)
 15229 00002CC9 B44B                    	mov	ah,EXEC ; 4Bh
 15230 00002CCB CD21                    	int	21h			;load in the device driver
 15231                                   		; DOS - 2+ - LOAD OR EXECUTE (EXEC)
 15232                                  		; DS:DX -> ASCIZ filename
 15233                                  		; ES:BX -> parameter block
 15234                                  		; AL = subfunction 
 15235 00002CCD C3                      	retn
 15236                                  
 15237                                  ;----------------------------------------------------------------------------
 15238                                  ;
 15239                                  ; procedure : RetFromUM
 15240                                  ;
 15241                                  ;	Input : None
 15242                                  ;	Output : ConvLoad set if didn't previously call HideUMBs
 15243                                  ;		 ConvLoad clear if did.
 15244                                  ;
 15245                                  ;	Prepares memory for more devices after returning from loading one
 15246                                  ;	using the DOS 6 options (/L:... etc).
 15247                                  ;
 15248                                  ;----------------------------------------------------------------------------
 15249                                  
 15250                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15251                                  ;RetFromUM:
 15252                                  ;	pushf
 15253                                  ;	mov	byte [cs:ConvLoad],1
 15254                                  ;	call	UnHideUMBs
 15255                                  ;	jc	short rfUM1		; Skip this if didn't HideUMBs
 15256                                  ;	mov	byte [cs:ConvLoad],0
 15257                                  ;rfUM1:	
 15258                                  ;	popf
 15259                                  ;	retn
 15260                                  
 15261                                  ;----------------------------------------------------------------------------
 15262                                  ;
 15263                                  ; procedure : RemoveNull
 15264                                  ;
 15265                                  ;	Input : ES:SI points to a null terminated string
 15266                                  ;
 15267                                  ;	Output : none
 15268                                  ;
 15269                                  ;	Replaces the null at the end of a string with blank
 15270                                  ;
 15271                                  ;----------------------------------------------------------------------------
 15272                                  
 15273                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15274                                  	; (SYSINIT:2CCEh)
 15275                                  RemoveNull:
 15276                                  rn_next:
 15277 00002CCE 268A1C                  	mov	bl,[es:si]
 15278 00002CD1 08DB                    	or	bl,bl			; null ?
 15279 00002CD3 7403                    	jz	short rn_gotnull
 15280 00002CD5 46                      	inc	si			; advance the pointer
 15281 00002CD6 EBF6                    	jmp	short rn_next
 15282                                  rn_gotnull:
 15283 00002CD8 2E8A1E[5D21]            	mov	bl,[cs:DevSavedDelim]
 15284 00002CDD 26881C                  	mov	[es:si],bl		; replace null with blank
 15285                                  	; 02/11/2022
 15286                                  ;rba_ok: ; 10/04/2019
 15287 00002CE0 C3                      	retn
 15288                                  
 15289                                  ;----------------------------------------------------------------------------
 15290                                  ;
 15291                                  ; procedure : RoundBreakAddr
 15292                                  ;
 15293                                  ;	Input : DevBrkAddr
 15294                                  ;	Output : DevBrkAddr
 15295                                  ;
 15296                                  ;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
 15297                                  ;
 15298                                  ;----------------------------------------------------------------------------
 15299                                  
 15300                                  RoundBreakAddr:
 15301 00002CE1 2EA1[3521]              	mov	ax,[cs:DevBrkAddr]
 15302 00002CE5 E868E4                  	call	ParaRound
 15303 00002CE8 2E0106[3721]            	add	[cs:DevBrkAddr+2],ax
 15304 00002CED 2EC706[3521]0000        	mov	word [cs:DevBrkAddr],0
 15305 00002CF4 2EA1[2F21]              	mov	ax,[cs:DevLoadEnd]
 15306 00002CF8 2E3906[3721]            	cmp	[cs:DevBrkAddr+2],ax
 15307 00002CFD 7603                    	jbe	short rba_ok
 15308 00002CFF E9D307                  	jmp	mem_err
 15309                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15310                                  rba_ok:
 15311 00002D02 C3                      	retn
 15312                                  
 15313                                  ;----------------------------------------------------------------------------
 15314                                  ;
 15315                                  ; procedure : DevSetBreak
 15316                                  ;
 15317                                  ;	Input : DevBrkAddr
 15318                                  ;	Output : Carry set if Device returned Init failed
 15319                                  ;		 Else carry clear
 15320                                  ;
 15321                                  ;----------------------------------------------------------------------------
 15322                                  
 15323                                  DevSetBreak:
 15324 00002D03 50                      	push	ax
 15325                                  
 15326 00002D04 2EA1[3721]              	mov	ax,[cs:DevBrkAddr+2]	 ;remove the init code
 15327 00002D08 2E803E[5716]00          	cmp	byte [cs:multdeviceflag],0
 15328 00002D0E 750F                    	jne	short set_break_continue ;do not check it.
 15329 00002D10 2E3B06[2D21]            	cmp	ax,[cs:DevLoadAddr]
 15330 00002D15 7508                    	jne	short set_break_continue ;if not same, then o.k.
 15331                                  
 15332 00002D17 2E833E[3521]00          	cmp	word [cs:DevBrkAddr],0
 15333 00002D1D 7406                    	je	short break_failed	;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0
 15334                                  
 15335                                  set_break_continue:
 15336 00002D1F E8BFFF                  	call	RoundBreakAddr
 15337 00002D22 58                      	pop	ax
 15338 00002D23 F8                      	clc
 15339 00002D24 C3                      	retn
 15340                                  break_failed:
 15341 00002D25 58                      	pop	ax
 15342 00002D26 F9                      	stc
 15343 00002D27 C3                      	retn
 15344                                  
 15345                                  ;----------------------------------------------------------------------------
 15346                                  ;
 15347                                  ; procedure : DevBreak
 15348                                  ;
 15349                                  ;	Input : DevLoadAddr & DevBrkAddr
 15350                                  ;	Output : none
 15351                                  ;
 15352                                  ;	Marks a succesful install of a device driver
 15353                                  ;	Sets device size field in sub-arena &
 15354                                  ;	Updates Free ptr in UMB or adjusts memhi
 15355                                  ;
 15356                                  ;----------------------------------------------------------------------------
 15357                                  
 15358                                  DevBreak:
 15359 00002D28 1E                      	push	ds
 15360 00002D29 2EA1[2D21]              	mov	ax,[cs:DevLoadAddr]
 15361 00002D2D 2E8B1E[3721]            	mov	bx,[cs:DevBrkAddr+2]
 15362 00002D32 48                      	dec	ax			; seg of sub-arena
 15363 00002D33 8ED8                    	mov	ds,ax
 15364 00002D35 40                      	inc	ax			; Back to Device segment
 15365 00002D36 29D8                    	sub	ax,bx
 15366 00002D38 F7D8                    	neg	ax			; size of device in paras
 15367 00002D3A A30300                  	mov	[devmark.size],ax	; store it in sub-arena
 15368 00002D3D 2E803E[4821]00          	cmp	byte [cs:DeviceHi],0
 15369 00002D43 7407                    	je	short db_lo
 15370 00002D45 2E891E[3E21]            	mov	[cs:DevUMBFree],bx	; update Free ptr in UMB
 15371 00002D4A EB0C                    	jmp	short db_exit
 15372                                  db_lo:
 15373 00002D4C 2E891E[E003]            	mov	[cs:memhi],bx
 15374 00002D51 2EC706[DE03]0000        	mov	word [cs:memlo],0
 15375                                  db_exit:
 15376 00002D58 1F                      	pop	ds
 15377 00002D59 C3                      	retn
 15378                                  
 15379                                  ; 10/04/2019 - Retro DOS v4.0
 15380                                  
 15381                                  ;----------------------------------------------------------------------------
 15382                                  ;
 15383                                  ; procedure : ParseSize
 15384                                  ;
 15385                                  ;	Parses the command line for SIZE= command
 15386                                  ;
 15387                                  ;	ES:SI = command line to parsed
 15388                                  ;
 15389                                  ;	returns ptr to command line after SIZE= option in ES:SI
 15390                                  ;	updates the DevSizeOption variable with value supplied
 15391                                  ;	in SIZE=option
 15392                                  ;	Returns carry if the SIZE option was invalid
 15393                                  ;
 15394                                  ;----------------------------------------------------------------------------
 15395                                  
 15396                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15397                                  	; (SYSINIT:2D5Ah)
 15398                                  ParseSize:
 15399                                  	;push	bx
 15400                                  	;mov	bx,si
 15401                                  
 15402 00002D5A 2EC706[4921]0000        	mov	word [cs:DevSizeOption],0 ; init the value
 15403 00002D61 2E8936[5921]            	mov	[cs:DevCmdLine],si
 15404 00002D66 2E8C06[5B21]            	mov	[cs:DevCmdLine+2],es
 15405 00002D6B E82B00                  	call	SkipDelim
 15406 00002D6E 26813C5349              	cmp	word [es:si],'SI' ; 4953h
 15407 00002D73 7520                    	jne	short ps_no_size
 15408 00002D75 26817C025A45            	cmp	word [es:si+2],'ZE' ; 455Ah
 15409 00002D7B 7518                    	jne	short ps_no_size
 15410 00002D7D 268A4404                	mov	al,[es:si+4]
 15411 00002D81 E8CC06                  	call	delim
 15412 00002D84 750F                    	jne	short ps_no_size
 15413 00002D86 83C605                  	add	si,5
 15414 00002D89 E81900                  	call	GetHexNum
 15415 00002D8C 7209                    	jc	short ps_err
 15416 00002D8E 2EA3[4921]              	mov	[cs:DevSizeOption],ax
 15417 00002D92 E80400                  	call	SkipDelim
 15418                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15419                                  	;mov	bx,si
 15420                                  ps_no_size:	
 15421                                  	;mov	si,bx
 15422                                  	;pop	bx
 15423 00002D95 F8                      	clc
 15424                                  	;retn
 15425                                  	; 02/11/2022
 15426 00002D96 C3                      	retn
 15427                                  ps_err:
 15428                                  	; 02/11/2022
 15429                                  	;pop	bx
 15430                                  	;stc
 15431                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15432 00002D97 F9                      	stc
 15433                                  ;sd_ret: ; 12/04/2019
 15434 00002D98 C3                      	retn
 15435                                  
 15436                                  ; 12/04/2019 - Retro DOS v4.0
 15437                                  
 15438                                  ;----------------------------------------------------------------------------
 15439                                  ;
 15440                                  ; procedure : SkipDelim
 15441                                  ;
 15442                                  ;	Skips delimiters in the string pointed to by ES:SI
 15443                                  ;	Returns ptr to first non-delimiter character in ES:SI
 15444                                  ;
 15445                                  ;----------------------------------------------------------------------------
 15446                                  	
 15447                                  	; 01/11/2022
 15448                                  SkipDelim:
 15449                                  sd_next_char:
 15450 00002D99 268A04                  	mov	al,[es:si]
 15451 00002D9C E8B106                  	call	delim
 15452 00002D9F 7503                    	jnz	short sd_ret
 15453 00002DA1 46                      	inc	si
 15454 00002DA2 EBF5                    	jmp	short sd_next_char ; 01/11/2022
 15455                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15456                                  sd_ret:
 15457 00002DA4 C3                      	retn
 15458                                  
 15459                                  ;----------------------------------------------------------------------------
 15460                                  ;
 15461                                  ; procedure : GetHexNum
 15462                                  ;
 15463                                  ;	Converts an ascii string terminated by a delimiter into binary.
 15464                                  ;	Assumes that the ES:SI points to a Hexadecimal string
 15465                                  ;
 15466                                  ;	Returns in AX the number number of paras equivalent to the
 15467                                  ;	hex number of bytes specified by the hexadecimal string.
 15468                                  ;
 15469                                  ;	Returns carry in case it encountered a non-hex character or
 15470                                  ;	if it encountered crlf
 15471                                  ;
 15472                                  ;----------------------------------------------------------------------------
 15473                                  
 15474                                  ; 13/05/2019
 15475                                  
 15476                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15477                                  	; (SYSINIT:2DA5h)
 15478                                  GetHexNum:
 15479 00002DA5 31C0                    	xor	ax, ax
 15480 00002DA7 31D2                    	xor	dx, dx
 15481                                  ghn_next:
 15482 00002DA9 268A1C                  	mov	bl,[es:si]
 15483 00002DAC 80FB0D                  	cmp	bl,cr  ; 0Dh
 15484 00002DAF 7439                    	je	short ghn_err
 15485 00002DB1 80FB0A                  	cmp	bl,lf  ; 0Ah
 15486 00002DB4 7434                    	je	short ghn_err
 15487 00002DB6 50                      	push	ax
 15488 00002DB7 88D8                    	mov	al,bl
 15489 00002DB9 E89406                  	call	delim
 15490 00002DBC 58                      	pop	ax
 15491 00002DBD 7413                    	jz	short ghn_into_paras
 15492 00002DBF E82A00                  	call	GetNibble
 15493 00002DC2 7226                    	jc	short ghn_err
 15494 00002DC4 B90400                  	mov	cx,4
 15495                                  ghn_shift1:
 15496 00002DC7 D1E0                    	shl	ax,1
 15497 00002DC9 D1D2                    	rcl	dx,1
 15498 00002DCB E2FA                    	loop	ghn_shift1
 15499 00002DCD 08D8                    	or	al,bl
 15500 00002DCF 46                      	inc	si
 15501 00002DD0 EBD7                    	jmp	short ghn_next
 15502                                  ghn_into_paras:
 15503 00002DD2 83C00F                  	add	ax,15
 15504 00002DD5 83D200                  	adc	dx,0
 15505 00002DD8 F7C2F0FF                	test	dx,0FFF0h
 15506 00002DDC 750C                    	jnz	short ghn_err
 15507 00002DDE B90400                  	mov	cx,4
 15508                                  ghn_shift2:
 15509 00002DE1 F8                      	clc
 15510 00002DE2 D1DA                    	rcr	dx,1
 15511 00002DE4 D1D8                    	rcr	ax,1
 15512 00002DE6 E2F9                    	loop	ghn_shift2
 15513 00002DE8 F8                      	clc
 15514 00002DE9 C3                      	retn
 15515                                  ghn_err:
 15516 00002DEA F9                      	stc
 15517 00002DEB C3                      	retn
 15518                                  
 15519                                  ;----------------------------------------------------------------------------
 15520                                  ;
 15521                                  ; procedure : GetNibble
 15522                                  ;
 15523                                  ;	Convert one nibble (hex digit) in BL into binary
 15524                                  ;
 15525                                  ;	Retruns binary value in BL
 15526                                  ;
 15527                                  ;	Returns carry if BL contains non-hex digit
 15528                                  ;
 15529                                  ;----------------------------------------------------------------------------
 15530                                  
 15531                                  GetNibble:
 15532 00002DEC 80FB30                  	cmp	bl,'0'
 15533 00002DEF 7217                    	jb	short gnib_err
 15534 00002DF1 80FB39                  	cmp	bl,'9'
 15535 00002DF4 7704                    	ja	short is_it_hex
 15536 00002DF6 80EB30                  	sub	bl,'0'		; clc
 15537 00002DF9 C3                      	retn
 15538                                  is_it_hex:
 15539 00002DFA 80FB41                  	cmp	bl,'A'
 15540 00002DFD 7209                    	jb	short gnib_err
 15541 00002DFF 80FB46                  	cmp	bl,'F'
 15542 00002E02 7704                    	ja	gnib_err
 15543 00002E04 80EB37                  	sub	bl,'A'- 10	; clc
 15544 00002E07 C3                      	retn
 15545                                  gnib_err:
 15546 00002E08 F9                      	stc
 15547 00002E09 C3                      	retn
 15548                                  
 15549                                  ;============================================================================
 15550                                  
 15551                                  ; 12/04/2019 - Retro DOS v4.0
 15552                                  
 15553                                  ; umb.inc (MSDOS 6.0, 1991)
 15554                                  DOS_ARENA	equ 24h		; offset of arena_head var in DOS data segm.
 15555                                  UMB_ARENA	equ 8Ch		; offset of umb_head in DOS data
 15556                                  
 15557                                  XMM_REQUEST_UMB	equ 10h
 15558                                  XMM_RELEASE_UMB	equ 11h
 15559                                  
 15560                                  ;----------------------------------------------------------------------------
 15561                                  ;
 15562                                  ; procedure : AllocUMB
 15563                                  ;
 15564                                  ;	Allocate all UMBs and link it to DOS arena chain
 15565                                  ;
 15566                                  ;----------------------------------------------------------------------------
 15567                                  
 15568                                  AllocUMB:
 15569 00002E0A E81000                  	call	InitAllocUMB		; link in the first UMB
 15570 00002E0D 720D                    	jc	short au_exit		; quit on error
 15571                                  au_next:
 15572 00002E0F E83F00                  	call	umb_allocate		; allocate
 15573 00002E12 7205                    	jc	short au_coalesce
 15574 00002E14 E85B00                  	call	umb_insert		; & insert till no UMBs
 15575 00002E17 EBF6                    	jmp	short au_next
 15576                                  au_coalesce:
 15577 00002E19 E81501                  	call	umb_coalesce		; coalesce all UMBs
 15578                                  au_exit:
 15579 00002E1C C3                      	retn
 15580                                  
 15581                                  ;----------------------------------------------------------------------------
 15582                                  ;
 15583                                  ; procedure : InitAllocUMB
 15584                                  ;
 15585                                  ;----------------------------------------------------------------------------
 15586                                  
 15587                                  InitAllocUMB:
 15588 00002E1D E85CDC                  	call	IsXMSLoaded
 15589 00002E20 752D                    	jnz	short iau_err		; quit on no XMS driver
 15590 00002E22 B452                    	mov	ah,52h
 15591 00002E24 CD21                    	int	21h			; get DOS DATA seg
 15592 00002E26 2E8C06[5721]            	mov	[cs:DevDOSData],es	; & save it for later
 15593 00002E2B B81043                  	mov	ax,4310h
 15594 00002E2E CD2F                    	int	2Fh
 15595 00002E30 2E891E[4021]            	mov	[cs:DevXMSAddr],bx	; get XMS driver address
 15596 00002E35 2E8C06[4221]            	mov	[cs:DevXMSAddr+2],es
 15597 00002E3A 2E803E[5621]00          	cmp	byte [cs:FirstUMBLinked],0 ; have we already linked a UMB?
 15598 00002E40 750B                    	jne	short ia_1		; quit if we already did it
 15599 00002E42 E83C01                  	call	LinkFirstUMB		; else link the first UMB
 15600 00002E45 7208                    	jc	short iau_err
 15601 00002E47 2EC606[5621]FF          	mov	byte [cs:FirstUMBLinked],0FFh ; mark that 1st UMB linked
 15602                                  ia_1:
 15603 00002E4D F8                      	clc
 15604 00002E4E C3                      	retn
 15605                                  iau_err:
 15606 00002E4F F9                      	stc
 15607 00002E50 C3                      	retn
 15608                                  
 15609                                  ;-------------------------------------------------------------------------
 15610                                  ;
 15611                                  ; Procedure Name	: umb_allocate
 15612                                  ;
 15613                                  ; Inputs		: DS = data
 15614                                  ;
 15615                                  ; Outputs		: if UMB available
 15616                                  ;				Allocates the largest available UMB and 
 15617                                  ;			  	BX = segment of allocated block
 15618                                  ;				DX = size of allocated block
 15619                                  ;				NC
 15620                                  ;			  else 
 15621                                  ;				CY
 15622                                  ;
 15623                                  ; Uses			: BX, DX
 15624                                  ;
 15625                                  ;-------------------------------------------------------------------------
 15626                                  
 15627                                  umb_allocate:
 15628 00002E51 50                      	push	ax
 15629 00002E52 B410                    	mov	ah,XMM_REQUEST_UMB ; 16
 15630 00002E54 BAFFFF                  	mov	dx,0FFFFh		; try to allocate largest
 15631                                  					;   possible
 15632 00002E57 2EFF1E[4021]            	call	far [cs:DevXMSAddr]
 15633                                  					; dx now contains the size of
 15634                                  					; the largest UMB
 15635 00002E5C 09D2                    	or	dx,dx
 15636 00002E5E 740F                    	jz	short ua_err
 15637                                  	
 15638 00002E60 B410                    	mov	ah,XMM_REQUEST_UMB ; 16
 15639 00002E62 2EFF1E[4021]            	call	far [cs:DevXMSAddr]
 15640                                  
 15641 00002E67 83F801                  	cmp	ax,1			; Q: was the reqst successful
 15642 00002E6A 7503                    	jne	short ua_err		; N: error
 15643                                  	;clc
 15644                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15645 00002E6C F8                      	clc 
 15646                                  ua_done:
 15647 00002E6D 58                      	pop	ax
 15648 00002E6E C3                      	retn		
 15649                                  ua_err:
 15650 00002E6F F9                      	stc
 15651 00002E70 EBFB                    	jmp	short ua_done
 15652                                  
 15653                                  ;---------------------------------------------------------------------------
 15654                                  ;
 15655                                  ; Procedure Name	: umb_insert
 15656                                  ;
 15657                                  ; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
 15658                                  ;			: BX = seg address of UMB to be linked in
 15659                                  ;			: DX = size of UMB to be linked in paras
 15660                                  ;			; DS = data
 15661                                  ;
 15662                                  ; Outputs		: links the UMB into the arena chain
 15663                                  ;
 15664                                  ; Uses			: AX, CX, ES, DX, BX
 15665                                  ;
 15666                                  ;---------------------------------------------------------------------------
 15667                                  
 15668                                  umb_insert:
 15669 00002E72 1E                      	push	ds
 15670                                  
 15671 00002E73 2E8E1E[5721]            	mov	ds,[cs:DevDOSData]
 15672                                  	;mov	ds,[8Ch]
 15673 00002E78 8E1E8C00                	mov	ds,[UMB_ARENA]		; es = UMB_HEAD
 15674 00002E7C 8CD8                    	mov	ax,ds
 15675 00002E7E 8EC0                    	mov	es,ax
 15676                                  ui_next:
 15677 00002E80 39D8                    	cmp	ax,bx			; Q: is current block above
 15678                                  					;    new block
 15679 00002E82 770F                    	ja	short ui_insert		; Y: insert it
 15680                                  					; Q: is current block the
 15681                                  					;    last
 15682 00002E84 26803E00005A            	cmp	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
 15683 00002E8A 745C                    	je	short ui_append		; Y: append new block to chain
 15684                                  					; N: get next block
 15685 00002E8C 8ED8                    	mov	ds,ax			; M005
 15686                                  	;call	get_next		; ax = es = next block
 15687 00002E8E E8E300                  	call	_get_next_ ; 13/04/2019 - Retro DOS v4.0
 15688 00002E91 EBED                    	jmp	short ui_next
 15689                                  
 15690                                  ui_insert:
 15691 00002E93 8CD9                    	mov	cx,ds			; ds = previous arena
 15692 00002E95 41                      	inc	cx			; top of previous block
 15693                                  
 15694 00002E96 29D9                    	sub	cx,bx
 15695 00002E98 F7D9                    	neg	cx			; cx = size of used block
 15696                                  	;mov	byte [0],'M'
 15697 00002E9A C60600004D              	mov	byte [ARENA.SIGNATURE],arena_signature_normal ; 'M'
 15698                                  	;mov	word [1],8
 15699 00002E9F C70601000800            	mov	word [ARENA.OWNER],8	; mark as system owned
 15700                                  	;mov	[3],cx
 15701 00002EA5 890E0300                	mov	[ARENA.SIZE],cx	
 15702                                  	;mov	word [8],4353h ; 'SC'
 15703 00002EA9 C70608005343            	mov	word [ARENA.NAME],'SC' ; 4353h
 15704                                  
 15705                                  ; prepare the arena at start of new block
 15706                                  
 15707 00002EAF 8EC3                    	mov	es,bx
 15708 00002EB1 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 15709 00002EB7 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system ; 0
 15710                                  					; mark as free
 15711 00002EBE 83EA02                  	sub	dx,2			; make room for arena at
 15712                                  					; start & end of new block
 15713 00002EC1 2689160300              	mov	[es:ARENA.SIZE],dx
 15714                                  
 15715                                  ; prepare arena at end of new block
 15716                                  	
 15717 00002EC6 01D3                    	add	bx,dx
 15718 00002EC8 43                      	inc	bx
 15719 00002EC9 8EC3                    	mov	es,bx			; es=arena at top of new block
 15720 00002ECB 43                      	inc	bx			; bx=top of new block
 15721                                  
 15722                                  					; ax contains arena just above
 15723                                  					; this block
 15724 00002ECC 29D8                    	sub	ax,bx			; ax = size of used block
 15725                                  	
 15726 00002ECE 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 15727 00002ED4 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 15728 00002EDB 26A30300                	mov	[es:ARENA.SIZE],ax	
 15729 00002EDF 26C70608005343          	mov	word [es:ARENA.NAME],'SC' ; 4353h
 15730                                  
 15731 00002EE6 EB47                    	jmp	short ui_done
 15732                                  
 15733                                  ui_append:
 15734                                  					; es = arena of last block	
 15735 00002EE8 2603060300              	add	ax,[es:ARENA.SIZE]	; ax=top of last block-1 para
 15736 00002EED 26832E030001            	sub	word [es:ARENA.SIZE],1	; reflect the space we are
 15737                                  					; going to rsrv on top of this 
 15738                                  					; block for the next arena.
 15739                                  	; 13/05/2019
 15740 00002EF3 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 15741                                  
 15742 00002EF9 89C1                    	mov	cx,ax			; cx=top of prev block-1
 15743 00002EFB 40                      	inc	ax
 15744 00002EFC 29D8                    	sub	ax,bx			; ax=top of prev block - 
 15745                                  					;    seg. address of new block
 15746 00002EFE F7D8                    	neg	ax
 15747                                  
 15748 00002F00 8EC1                    	mov	es,cx			; ds = arena of unused block
 15749                                  
 15750 00002F02 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
 15751 00002F08 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 15752 00002F0F 26A30300                	mov	[es:ARENA.SIZE],ax	
 15753 00002F13 26C70608005343          	mov	word [es:ARENA.NAME],'SC'
 15754                                  
 15755                                  ; prepare the arena at start of new block
 15756 00002F1A 8EC3                    	mov	es,bx
 15757 00002F1C 26C60600005A            	mov	byte [es:ARENA.SIGNATURE],arena_signature_end
 15758 00002F22 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system
 15759                                  					; mark as free
 15760 00002F29 4A                      	dec	dx			; make room for arena
 15761 00002F2A 2689160300              	mov	[es:ARENA.SIZE],dx	
 15762                                  ui_done:
 15763 00002F2F 1F                      	pop	ds
 15764 00002F30 C3                      	retn
 15765                                  
 15766                                  ; 13/04/2019 - Retro DOS v4.0
 15767                                  
 15768                                  ;----------------------------------------------------------------------------
 15769                                  ;
 15770                                  ;**	umb_coalesce - Combine free blocks ahead with current block
 15771                                  ;
 15772                                  ;	Coalesce adds the block following the argument to the argument block,
 15773                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 15774                                  ;	some callers (such as $setblock) use it to join a free block to it's
 15775                                  ;	preceeding allocated block.
 15776                                  ;
 15777                                  ;	EXIT	'C' clear if OK
 15778                                  ;		  (ds) unchanged, this block updated
 15779                                  ;		  (ax) = address of next block, IFF not at end
 15780                                  ;		'C' set if arena trashed
 15781                                  ;	USES	cx, di, ds, es
 15782                                  ;
 15783                                  ;----------------------------------------------------------------------------
 15784                                  
 15785                                  umb_coalesce:
 15786 00002F31 31FF                    	xor	di, di
 15787                                  
 15788 00002F33 2E8E06[5721]            	mov	es,[cs:DevDOSData]
 15789 00002F38 268E068C00              	mov	es,[es:UMB_ARENA]	; es = UMB_HEAD
 15790                                  uc_nextfree:
 15791 00002F3D 8CC0                    	mov	ax,es
 15792 00002F3F 8ED8                    	mov	ds,ax
 15793                                  	;cmp	[es:1],di
 15794 00002F41 26393E0100              	cmp	[es:ARENA.OWNER],di	; Q: is current arena free
 15795 00002F46 7407                    	je	short uc_again		; Y: try to coalesce with next block
 15796                                  					; N: get next arena
 15797 00002F48 E82200                  	call	get_next		; es, ax = next arena
 15798 00002F4B 721F                    	jc	short uc_done
 15799 00002F4D EBEE                    	jmp	short uc_nextfree
 15800                                  uc_again:
 15801 00002F4F E81B00                  	call	get_next		; ES, AX <- next block
 15802 00002F52 7218                    	jc	short uc_done
 15803                                  uc_check:
 15804 00002F54 26393E0100              	cmp     [es:ARENA.OWNER],di	; Q: is arena free
 15805 00002F59 75E2                    	jne	short uc_nextfree	; N: get next free arena
 15806                                  					; Y: coalesce
 15807 00002F5B 268B0E0300              	mov     cx,[es:ARENA.SIZE]      ; cx <- next block size
 15808 00002F60 41                      	inc     cx                      ; cx <- cx + 1 (for header size)
 15809                                  	;add	[3],cx
 15810 00002F61 010E0300                	add     [ARENA.SIZE],cx		; current size <- current size + cx
 15811 00002F65 268A0D                  	mov     cl,[es:di]              ; move up signature
 15812 00002F68 880D                    	mov     [di],cl
 15813 00002F6A EBE3                    	jmp     short uc_again		; try again
 15814                                  uc_done:
 15815 00002F6C C3                      	retn
 15816                                  
 15817                                  ;----------------------------------------------------------------------------
 15818                                  ;
 15819                                  ;**	get_next - Find Next item in Arena
 15820                                  ;
 15821                                  ;	ENTRY	dS - pointer to block head
 15822                                  ;	EXIT	AX,ES - pointers to next head
 15823                                  ;		'C' set if arena damaged
 15824                                  ;
 15825                                  ;----------------------------------------------------------------------------
 15826                                  
 15827                                  	; 01/11/2022
 15828                                  get_next:
 15829 00002F6D 803E00005A              	cmp	byte [0],arena_signature_end ; 'Z'
 15830 00002F72 740B                    	je	short gn_err
 15831                                  _get_next_:
 15832 00002F74 8CD8                    	mov     ax,ds                   ; ax=current block
 15833 00002F76 03060300                	add     ax,[ARENA.SIZE]		; ax=ax + current block length
 15834 00002F7A 40                      	inc     ax                      ; remember that header!
 15835 00002F7B 8EC0                    	mov	es,ax
 15836                                  	;clc
 15837                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15838 00002F7D F8                      	clc
 15839 00002F7E C3                      	retn
 15840                                  gn_err:
 15841 00002F7F F9                      	stc
 15842 00002F80 C3                      	retn
 15843                                  
 15844                                  ;----------------------------------------------------------------------------
 15845                                  ;
 15846                                  ; procedure : LinkFirstUMB
 15847                                  ;
 15848                                  ;----------------------------------------------------------------------------
 15849                                  
 15850                                  	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 15851                                  	; (SYSINIT:2F81h)
 15852                                  LinkFirstUMB:
 15853 00002F81 E8CDFE                  	call	umb_allocate
 15854 00002F84 7271                    	jc	short lfu_err
 15855                                  
 15856                                  ; bx = segment of allocated UMB
 15857                                  ; dx = size of UMB
 15858                                  
 15859 00002F86 CD12                    	int	12h			; ax = size of memory
 15860 00002F88 B106                    	mov	cl,6
 15861 00002F8A D3E0                    	shl	ax,cl			; ax = size in paragraphs
 15862                                  
 15863 00002F8C 89C1                    	mov	cx,ax			; cx = size in paras
 15864 00002F8E 29D8                    	sub	ax,bx			; ax = - size of unused block
 15865                                  
 15866 00002F90 F7D8                    	neg	ax
 15867                                  
 15868 00002F92 83E901                  	sub	cx,1			; cx = first umb_arena
 15869 00002F95 8EC1                    	mov	es,cx			; es = first umb_arena
 15870                                  	
 15871 00002F97 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 15872 00002F9D 26C70601000800          	mov	word [es:ARENA.OWNER],8	; mark as system owned
 15873                                  					
 15874 00002FA4 26A30300                	mov	[es:ARENA.SIZE],ax	
 15875 00002FA8 26C70608005343          	mov	word [es:ARENA.NAME],'SC' ; 4353h
 15876                                  
 15877                                  ; put in the arena for the first UMB
 15878                                  
 15879 00002FAF 8EC3                    	mov	es,bx			; es has first free umb seg
 15880 00002FB1 26C60600005A            	mov	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
 15881 00002FB7 26C70601000000          	mov	word [es:ARENA.OWNER],arena_owner_system ; 0	
 15882                                  					; mark as free 
 15883 00002FBE 4A                      	dec	dx			; make room for arena
 15884 00002FBF 2689160300              	mov	[es:ARENA.SIZE],dx	
 15885                                  
 15886 00002FC4 2E8E06[5721]            	mov	es,[cs:DevDOSData]
 15887 00002FC9 BF8C00                  	mov	di,UMB_ARENA ; 8Ch
 15888 00002FCC 26890D                  	mov	[es:di],cx		; initialize umb_head in DOS
 15889                                  					;  data segment with the arena
 15890                                  					;  just below Top of Mem
 15891                                  
 15892                                  ; we must now scan the arena chain and update the size of the last arena
 15893                                  
 15894 00002FCF BF2400                  	mov	di,DOS_ARENA ; 24h
 15895 00002FD2 268E05                  	mov	es,[es:di]		; es = start arena
 15896 00002FD5 31FF                    	xor	di,di
 15897                                  scan_next:
 15898 00002FD7 26803D5A                	cmp	byte [es:di],arena_signature_end  ; 'Z'
 15899 00002FDB 740C                    	je	short got_last
 15900                                  	
 15901 00002FDD 8CC0                    	mov	ax,es
 15902 00002FDF 2603060300              	add	ax,[es:ARENA.SIZE]
 15903 00002FE4 40                      	inc	ax
 15904 00002FE5 8EC0                    	mov	es,ax
 15905 00002FE7 EBEE                    	jmp	short scan_next
 15906                                  got_last:
 15907 00002FE9 26832E030001            	sub	word [es:ARENA.SIZE],1
 15908 00002FEF 26C60600004D            	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
 15909                                  	;clc
 15910                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15911 00002FF5 F8                      	clc
 15912 00002FF6 C3                      	retn
 15913                                  lfu_err:
 15914                                  	;stc
 15915                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 15916 00002FF7 F9                      	stc
 15917 00002FF8 C3                      	retn
 15918                                  
 15919                                  ;----------------------------------------------------------------------------
 15920                                  ;
 15921                                  ; procedure : ShrinkUMB
 15922                                  ;
 15923                                  ;	Shrinks the current UMB in use, so that the unused portions
 15924                                  ;	of the UMB is given back to the DOS free mem pool
 15925                                  ;
 15926                                  ;----------------------------------------------------------------------------
 15927                                  
 15928                                  ShrinkUMB:
 15929 00002FF9 2E833E[3A21]00          	cmp	word [cs:DevUMBAddr],0
 15930 00002FFF 7424                    	je	short su_exit
 15931 00003001 06                      	push	es
 15932 00003002 53                      	push	bx
 15933 00003003 2E8B1E[3E21]            	mov	bx,[cs:DevUMBFree]
 15934 00003008 2E2B1E[3A21]            	sub	bx,[cs:DevUMBAddr]
 15935 0000300D 2E8E06[3A21]            	mov	es,[cs:DevUMBAddr]
 15936 00003012 B8004A                  	mov	ax,4A00h
 15937 00003015 CD21                    	int	21h
 15938                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 15939                                  		; ES = segment address of block to change
 15940                                  		; BX = new size in paragraphs
 15941 00003017 8CC0                    	mov	ax,es
 15942 00003019 48                      	dec	ax
 15943 0000301A 8EC0                    	mov	es,ax
 15944 0000301C 26C70601000800          	mov	word [es:ARENA.OWNER],8
 15945 00003023 5B                      	pop	bx
 15946 00003024 07                      	pop	es
 15947                                  su_exit:
 15948 00003025 C3                      	retn
 15949                                  
 15950                                  ;----------------------------------------------------------------------------
 15951                                  ;
 15952                                  ; procedure : UnlinkUMB
 15953                                  ;
 15954                                  ;	Unlinks the UMBs from the DOS arena chain
 15955                                  ;
 15956                                  ;----------------------------------------------------------------------------
 15957                                  
 15958                                  UnlinkUMB:
 15959 00003026 1E                      	push	ds
 15960 00003027 06                      	push	es
 15961 00003028 2E803E[5621]00          	cmp	byte [cs:FirstUMBLinked],0
 15962 0000302E 7421                    	je	short ulu_x		; nothing to unlink
 15963 00003030 2E8E06[5721]            	mov	es,[cs:DevDOSData]	; get DOS data seg
 15964 00003035 268E1E2400              	mov	ds,[es:DOS_ARENA]
 15965 0000303A 268B3E8C00              	mov	di,[es:UMB_ARENA]
 15966                                  ulu_next:
 15967 0000303F E82BFF                  	call	get_next
 15968 00003042 720D                    	jc	short ulu_x
 15969 00003044 39C7                    	cmp	di,ax			; is the next one UMB ?
 15970 00003046 7404                    	je	short ulu_found
 15971 00003048 8ED8                    	mov	ds,ax
 15972 0000304A EBF3                    	jmp	short ulu_next
 15973                                  ulu_found:
 15974                                  	;mov	byte [0],'Z'
 15975 0000304C C60600005A              	mov     byte [ARENA.SIGNATURE],arena_signature_end ; 'Z'
 15976                                  ulu_x:
 15977 00003051 07                      	pop	es
 15978 00003052 1F                      	pop	ds
 15979 00003053 C3                      	retn
 15980                                  
 15981                                  ; ----------------------------------------------------------------------
 15982                                  ; SYSINIT2.ASM - MSDOS 6.0 - 1991
 15983                                  ; ----------------------------------------------------------------------
 15984                                  ; 14/04/2019 - Retro DOS v4.0
 15985                                  
 15986                                  ; Multiple configuration block support  Created 16-Mar-1992 by JeffPar
 15987                                  ;
 15988                                  ; Summary:
 15989                                  ;
 15990                                  ;   The procedure "organize" crunches the in-memory copy of config.sys
 15991                                  ;   into lines delimited by CR/LF (sometimes no CR, but *always* an LF)
 15992                                  ;   with the leading "keyword=" replaced by single character codes (eg, B
 15993                                  ;   for BUFFERS, D for DEVICE, Z for any unrecognized keyword); see comtab
 15994                                  ;   and/or config.inc for the full list.
 15995                                  ;
 15996                                  ;   [blockname] and INCLUDE are the major syntactical additions for multi-
 15997                                  ;   configuration support. blockname is either MENU, which contains one
 15998                                  ;   or more MENUITEM lines, an optional MENUDEFAULT (which includes optional
 15999                                  ;   time-out), or any user-defined keyword, such as NETWORK, CD-ROM, etc.
 16000                                  ;   INCLUDE allows the current block to name another block for inclusion
 16001                                  ;   during the processing phase of CONFIG.SYS. An INCLUDE is only honored
 16002                                  ;   once, precluding nasty infinite-loop scenarios. If blocks are present
 16003                                  ;   without a MENU block, then only lines inside COMMON blocks are processed.
 16004                                  ;
 16005                                  ; Example:
 16006                                  ;
 16007                                  ;   [menu]
 16008                                  ;   menuitem=misc,Miscellaneous
 16009                                  ;   menuitem=network,Network Configuration
 16010                                  ;   menudefault=network,15
 16011                                  ;
 16012                                  ;   [network]
 16013                                  ;   include misc
 16014                                  ;   device=foo
 16015                                  ;
 16016                                  ;   [misc]
 16017                                  ;   device=bar
 16018                                  ;   include alternate
 16019                                  ;
 16020                                  ;   [alternate]
 16021                                  ;   device=tar
 16022                                  ;
 16023                                  ;
 16024                                  ;   When the menu is displayed
 16025                                  ;
 16026                                  ;    1. Miscellaneous
 16027                                  ;    2. Network Configuration
 16028                                  ;
 16029                                  ;   #2 is highlighted as the default option, and will be automatically
 16030                                  ;   selected after 15 seconds. It will invoke the following lines in the
 16031                                  ;   following order:
 16032                                  ;
 16033                                  ;       DEVICE=BAR
 16034                                  ;       DEVICE=TAR
 16035                                  ;       DEVICE=FOO
 16036                                  ;
 16037                                  
 16038                                  ;MULTI_CONFIG equ 1
 16039                                  
 16040                                  ; the following depend on the positions of the various letters in switchlist
 16041                                  
 16042                                  switchnum	equ 11111000b ; 0F8h	; which switches require number
 16043                                  
 16044                                  flagec35	equ 00000100b ; 4	; electrically compatible 3.5 inch disk drive
 16045                                  flagdrive	equ 00001000b ; 8 
 16046                                  flagcyln	equ 00010000b ; 16
 16047                                  flagseclim	equ 00100000b ; 32
 16048                                  flagheads	equ 01000000b ; 64
 16049                                  flagff		equ 10000000b ; 128
 16050                                  
 16051                                  ;----------------------------------------------------------------------------
 16052                                  ; 19/04/2019 - Retro DOS v4.0
 16053                                  
 16054                                  ; MSDOS 6.21 IO.SYS - SYSINIT:3E78h
 16055                                  
 16056                                  ; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 16057                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3054h
 16058                                  
 16059 00003054 00                      insert_blank:	db 	0
 16060                                  
 16061                                  ;----------------------------------------------------------------------------
 16062                                  ;
 16063                                  ; procedure : setparms
 16064                                  ;
 16065                                  ; the following set of routines is used to parse the drivparm = command in
 16066                                  ; the config.sys file to change the default drive parameters.
 16067                                  ;
 16068                                  ;----------------------------------------------------------------------------
 16069                                  
 16070                                  setparms:
 16071 00003055 1E                      	push	ds
 16072 00003056 50                      	push	ax
 16073 00003057 53                      	push	bx
 16074 00003058 51                      	push	cx
 16075 00003059 52                      	push	dx
 16076                                  
 16077 0000305A 0E                      	push	cs
 16078 0000305B 1F                      	pop	ds
 16079                                  
 16080 0000305C 31DB                    	xor	bx,bx
 16081 0000305E 8A1E[A63A]              	mov	bl,[drive]
 16082 00003062 FEC3                    	inc	bl			; get it correct for ioctl call
 16083                                  					; (1=a,2=b...)
 16084 00003064 BA[7E39]                	mov	dx,deviceparameters
 16085 00003067 B444                    	mov	ah,IOCTL ; 44h
 16086 00003069 B00D                    	mov	al,GENERIC_IOCTL ; 0Dh
 16087 0000306B B508                    	mov	ch,RAWIO ; 8
 16088 0000306D B140                    	mov	cl,SET_DEVICE_PARAMETERS ; 40h
 16089 0000306F CD21                    	int	21h
 16090                                  
 16091                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16092                                  ;
 16093                                  ;	;;mov	ax,Bios_Data		; get Bios_Data segment
 16094                                  ;	;mov	ax,KERNEL_SEGMENT ; 70h
 16095                                  ;	; 21/10/2022
 16096                                  ;	mov	ax,DOSBIODATASEG ; 0070h	
 16097                                  ;	mov	ds,ax			; set Bios_Data segment
 16098                                  ;
 16099                                  ;	test	word [cs:switches],flagec35 ; 4
 16100                                  ;	jz	short not_ec35
 16101                                  
 16102                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16103                                  	;test	byte [switches],flagec35 
 16104 00003071 F706[A73A]0400          	test	word [switches],flagec35 ; 4
 16105 00003077 7411                    	jz	short eot_ok
 16106                                  
 16107                                  	;mov	cl,[cs:drive]		; which drive was this for?
 16108                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16109 00003079 8A0E[A63A]              	mov	cl,[drive]
 16110 0000307D B87000                  	mov	ax,DOSBIODATASEG ; 0070h	
 16111 00003080 8ED8                    	mov	ds,ax	
 16112                                  
 16113 00003082 B001                    	mov	al,1			; assume drive 0
 16114 00003084 D2E0                    	shl	al,cl			; set proper bit depending on drive
 16115                                  	;or	[531h],al ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EACh)
 16116 00003086 08063105                	or	[ec35_flag],al		; set the bit in the permanent flags
 16117                                  
 16118                                  
 16119                                  ; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16120                                  ;
 16121                                  ;not_ec35:
 16122                                  ;;	Now adjust the BIOS's EOT variable if our new drive has more
 16123                                  ;;	sectors per track than any old ones.
 16124                                  ;
 16125                                  ;	;mov	al,[cs:deviceparameters+20]
 16126                                  ;	mov	al,[cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
 16127                                  ;	;cmp	al,[12Ch] ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EB4h)
 16128                                  ;	cmp	al,[EOT]
 16129                                  ;	jbe	short eot_ok
 16130                                  ;	mov	[EOT],al
 16131                                  
 16132                                  eot_ok:
 16133 0000308A 5A                      	pop	dx			; fix up all the registers
 16134 0000308B 59                      	pop	cx
 16135 0000308C 5B                      	pop	bx
 16136 0000308D 58                      	pop	ax
 16137 0000308E 1F                      	pop	ds ; 13/05/2019
 16138 0000308F C3                      	retn
 16139                                  
 16140                                  ;----------------------------------------------------------------------------
 16141                                  ;
 16142                                  ; procedure : diddleback
 16143                                  ;
 16144                                  ; replace default values for further drivparm commands
 16145                                  ;
 16146                                  ;----------------------------------------------------------------------------
 16147                                  
 16148                                  diddleback:
 16149 00003090 1E                      	push	ds
 16150 00003091 0E                      	push	cs
 16151 00003092 1F                      	pop	ds
 16152                                  	;mov	word [deviceparameters+4],80
 16153 00003093 C706[8239]5000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
 16154                                  	;mov	byte [deviceparameters+1],2
 16155 00003099 C606[7F39]02            	mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB ; 2
 16156                                  	;mov	word [deviceparameters+2],0
 16157 0000309E C706[8039]0000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
 16158 000030A4 C706[A73A]0000          	mov	word [switches],0	    ; zero all switches
 16159 000030AA 1F                      	pop	ds
 16160 000030AB C3                      	retn
 16161                                  
 16162                                  
 16163                                  ; 15/04/2019 - Retro DOS v4.0
 16164                                  
 16165                                  ;----------------------------------------------------------------------------
 16166                                  ;
 16167                                  ; procedure : parseline
 16168                                  ;
 16169                                  ; entry point is parseline. al contains the first character in command line.
 16170                                  ;
 16171                                  ;----------------------------------------------------------------------------
 16172                                  
 16173                                  	; 01/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 16174                                  	; (SYSINIT:30ACh)
 16175                                  parseline:
 16176 000030AC 1E                      	push	ds
 16177                                  
 16178 000030AD 0E                      	push	cs
 16179 000030AE 1F                      	pop	ds
 16180                                  
 16181                                  nextswtch:
 16182 000030AF 3C0D                    	cmp	al,cr			; carriage return?
 16183 000030B1 7421                    	je	short done_line
 16184 000030B3 3C0A                    	cmp	al,lf			; linefeed?
 16185 000030B5 743D                    	je	short put_back		; put it back and done
 16186                                  
 16187                                  ; anything less or equal to a space is ignored.
 16188                                  
 16189 000030B7 3C20                    	cmp	al,' '                  ; space?
 16190 000030B9 7610                    	jbe	short getnext		; skip over space
 16191 000030BB 3C2F                    	cmp	al,'/'
 16192 000030BD 7403                    	je	short getparm
 16193 000030BF F9                      	stc				; mark error invalid-character-in-input
 16194 000030C0 EB30                    	jmp	short exitpl
 16195                                  
 16196                                  getparm:
 16197 000030C2 E83900                  	call	check_switch
 16198 000030C5 891E[A73A]              	mov	[switches],bx		; save switches read so far
 16199 000030C9 7207                    	jc	short swterr
 16200                                  getnext:
 16201 000030CB E886F9                  	call	getchr
 16202 000030CE 7204                    	jc	short done_line
 16203 000030D0 EBDD                    	jmp	short nextswtch
 16204                                  swterr:
 16205 000030D2 EB1E                    	jmp	short exitpl		; exit if error
 16206                                  
 16207                                  done_line:
 16208 000030D4 F706[A73A]0800          	test	word [switches],flagdrive ; 8 ; see if drive specified
 16209 000030DA 7503                    	jnz	short okay
 16210 000030DC F9                      	stc				; mark error no-drive-specified
 16211 000030DD EB13                    	jmp	short exitpl
 16212                                  
 16213                                  okay:
 16214 000030DF A1[A73A]                	mov	ax,[switches]
 16215 000030E2 83E003                  	and	ax,0003h	    ; get flag bits for changeline and non-rem
 16216 000030E5 A3[8039]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
 16217 000030E8 C706[A439]0000          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
 16218                                  	;clc			    ; everything is fine
 16219                                  	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16220 000030EE F8                      	clc
 16221 000030EF E89F00                  	call	setdeviceparameters
 16222                                  exitpl:
 16223 000030F2 1F                      	pop	ds
 16224 000030F3 C3                      	retn
 16225                                  put_back:
 16226 000030F4 FF06[D203]              	inc	word [count]		; one more char to scan
 16227 000030F8 FF0E[D603]              	dec	word [chrptr]		; back up over linefeed
 16228 000030FC EBD6                    	jmp	short done_line
 16229                                  
 16230                                  ;----------------------------------------------------------------------------
 16231                                  ;
 16232                                  ; procedure : check_switch
 16233                                  ;
 16234                                  ; processes a switch in the input. it ensures that the switch is valid, and
 16235                                  ; gets the number, if any required, following the switch. the switch and the
 16236                                  ; number *must* be separated by a colon. carry is set if there is any kind of
 16237                                  ; error.
 16238                                  ;
 16239                                  ;----------------------------------------------------------------------------
 16240                                  
 16241                                  check_switch:
 16242 000030FE E853F9                  	call	getchr
 16243                                  	;jc	short err_check
 16244 00003101 7252                    	jc	short err_chk
 16245 00003103 24DF                            and     al,0DFh                 ; convert it to upper case
 16246 00003105 3C41                    	cmp	al,'A'
 16247                                  	;jb	short err_check
 16248 00003107 724C                    	jb	short err_chk ; 15/04/2019 - Retro DOS v4.0
 16249 00003109 3C5A                    	cmp	al,'Z'
 16250 0000310B 7747                    	ja	short err_check
 16251                                  
 16252 0000310D 06                      	push	es
 16253                                  
 16254 0000310E 0E                      	push	cs
 16255 0000310F 07                      	pop	es
 16256                                  
 16257 00003110 8A0E[3A3B]              	mov	cl,[switchlist]		; get number of valid switches
 16258 00003114 B500                    	mov	ch,0
 16259 00003116 BF[3B3B]                	mov	di,1+switchlist		; point to string of valid switches
 16260 00003119 F2AE                    	repne	scasb
 16261                                  
 16262 0000311B 07                      	pop	es
 16263 0000311C 7536                    	jnz	short err_check
 16264                                  
 16265 0000311E B80100                  	mov	ax,1
 16266 00003121 D3E0                    	shl	ax,cl			; set bit to indicate switch
 16267 00003123 8B1E[A73A]              	mov	bx,[switches]		; get switches so far
 16268 00003127 09C3                    	or	bx,ax			; save this with other switches
 16269 00003129 89C1                    	mov	cx,ax
 16270 0000312B A9F800                  	test	ax,switchnum ; 0F8h	; test against switches that require number to follow
 16271 0000312E 7420                    	jz	short done_swtch
 16272                                  
 16273 00003130 E821F9                  	call	getchr
 16274 00003133 721D                    	jc	short err_swtch
 16275                                  
 16276 00003135 3C3A                    	cmp	al,':'
 16277 00003137 7519                    	jne	short err_swtch
 16278                                  
 16279 00003139 E818F9                  	call	getchr
 16280 0000313C 53                      	push	bx			; preserve switches
 16281                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16282 0000313D 2EC606[2A03]20          	mov	byte [cs:sepchr],' '	; allow space separators
 16283                                  	;mov	byte [sepchr],' '
 16284 00003143 E8C903                  	call	getnum
 16285 00003146 2EC606[2A03]00          	mov	byte [cs:sepchr],0
 16286                                  	;mov	byte [sepchr],0
 16287 0000314C 5B                      	pop	bx			; restore switches
 16288                                  
 16289                                  ; because getnum does not consider carriage-return or line-feed as ok, we do
 16290                                  ; not check for carry set here. if there is an error, it will be detected
 16291                                  ; further on (hopefully).
 16292                                  
 16293 0000314D E80600                  	call	process_num
 16294                                  
 16295                                  done_swtch:
 16296                                  	;clc
 16297                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16298 00003150 F8                      	clc
 16299 00003151 C3                      	retn
 16300                                  
 16301                                  err_swtch:
 16302 00003152 31CB                    	xor	bx,cx			; remove this switch from the records
 16303                                  err_check:
 16304 00003154 F9                      	stc
 16305                                  err_chk:
 16306 00003155 C3                      	retn
 16307                                  
 16308                                  ;----------------------------------------------------------------------------
 16309                                  ;
 16310                                  ; procedure : process_num
 16311                                  ;
 16312                                  ; this routine takes the switch just input, and the number following (if any),
 16313                                  ; and sets the value in the appropriate variable. if the number input is zero
 16314                                  ; then it does nothing - it assumes the default value that is present in the
 16315                                  ; variable at the beginning. zero is ok for form factor and drive, however.
 16316                                  ;
 16317                                  ;----------------------------------------------------------------------------
 16318                                  
 16319                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 16320                                  	; (SYSINIT:3156h)
 16321                                  process_num:
 16322 00003156 850E[A73A]              	test	[switches],cx		; if this switch has been done before,
 16323 0000315A 7533                    	jnz	short done_ret		; ignore this one.
 16324 0000315C F7C10800                	test	cx,flagdrive ; 8
 16325 00003160 7405                    	jz	short try_f
 16326 00003162 A2[A63A]                	mov	byte [drive],al
 16327                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16328 00003165 EB28                    	jmp	short done_ret
 16329                                  	;retn	; 13/05/2019
 16330                                  try_f:
 16331 00003167 F7C18000                	test	cx,flagff ; 80h
 16332 0000316B 7405                    	jz	short try_t
 16333                                  
 16334                                  ; ensure that we do not get bogus form factors that are not supported
 16335                                  
 16336                                  	;mov	[deviceparameters+1],al
 16337 0000316D A2[7F39]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],al
 16338                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16339 00003170 EB1D                    	jmp	short done_ret
 16340                                  	;retn	; 13/05/2019
 16341                                  try_t:
 16342 00003172 09C0                    	or	ax,ax
 16343 00003174 7419                    	jz	short done_ret		; if number entered was 0, assume default value
 16344 00003176 F7C11000                	test	cx,flagcyln ; 10h
 16345 0000317A 7405                    	jz	short try_s
 16346                                  
 16347                                  	;mov	[deviceparameters+4],ax
 16348 0000317C A3[8239]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],ax
 16349                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16350 0000317F EB0E                    	jmp	short done_ret
 16351                                  	;retn	; 13/05/2019
 16352                                  try_s:
 16353 00003181 F7C12000                	test	cx,flagseclim ; 20h
 16354 00003185 7405                    	jz	short try_h
 16355 00003187 A3[A43A]                	mov	[slim],ax
 16356                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16357 0000318A EB03                    	jmp	short done_ret
 16358                                  	;retn	; 13/05/2019
 16359                                  
 16360                                  ; must be for number of heads
 16361                                  
 16362                                  try_h:
 16363 0000318C A3[A23A]                	mov	[hlim],ax
 16364                                  done_ret:
 16365                                  	;clc
 16366                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16367 0000318F F8                      	clc
 16368 00003190 C3                      	retn
 16369                                  
 16370                                  ;	M047 -- Begin modifications (too numerous to mark specifically)
 16371                                  
 16372                                  ;----------------------------------------------------------------------------
 16373                                  ;
 16374                                  ; procedure : setdeviceparameters
 16375                                  ;
 16376                                  ; setdeviceparameters sets up the recommended bpb in each bds in the
 16377                                  ; system based on the form factor. it is assumed that the bpbs for the
 16378                                  ; various form factors are present in the bpbtable. for hard files,
 16379                                  ; the recommended bpb is the same as the bpb on the drive.
 16380                                  ; no attempt is made to preserve registers since we are going to jump to
 16381                                  ; sysinit straight after this routine.
 16382                                  ;
 16383                                  ;	if we return carry, the DRIVPARM will be aborted, but presently
 16384                                  ;	  we always return no carry
 16385                                  ;
 16386                                  ;	note:  there is a routine by the same name in msdioctl.asm
 16387                                  ;
 16388                                  ;----------------------------------------------------------------------------
 16389                                  
 16390                                  ; 15/04/2019 - Retro DOS v4.0
 16391                                  
 16392                                  	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 16393                                  setdeviceparameters:
 16394 00003191 06                      	push	es
 16395                                  
 16396 00003192 0E                      	push	cs
 16397 00003193 07                      	pop	es
 16398                                  
 16399 00003194 31DB                    	xor	bx,bx
 16400 00003196 8A1E[7F39]              	mov	bl,[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
 16401 0000319A 80FB00                  	cmp	bl,DEV_5INCH ; 0
 16402 0000319D 7506                    	jne	short got_80
 16403                                  
 16404 0000319F C706[8239]2800          	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
 16405                                  							; 48 tpi=40 cyl
 16406                                  got_80:
 16407 000031A5 D1E3                    	shl	bx,1			; get index into bpb table
 16408 000031A7 8BB7[263B]              	mov	si,[bpbtable+bx]	; get address of bpb
 16409                                  
 16410                                  	;mov	di,deviceparameters+7	
 16411                                  	; 02/11/2022
 16412 000031AB BF[8539]                	mov	di,deviceparameters+A_DEVICEPARAMETERS.DP_BPB ; es:di -> bpb
 16413 000031AE B91F00                  	mov	cx,A_BPB.size ; 31
 16414 000031B1 FC                      	cld
 16415                                  	;repe	movsb
 16416                                  	; 02/11/2022
 16417 000031B2 F3A4                    	rep	movsb
 16418                                  
 16419 000031B4 07                      	pop	es
 16420                                  
 16421 000031B5 F706[A73A]2000          	test	word [switches],flagseclim ; 20h
 16422 000031BB 7406                    	jz	short see_heads
 16423                                  
 16424 000031BD A1[A43A]                	mov	ax,[slim]
 16425                                  	;mov	[deviceparameters+20],ax
 16426 000031C0 A3[9239]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],ax
 16427                                  
 16428                                  see_heads:
 16429 000031C3 F706[A73A]4000          	test	word [switches],flagheads ; 40h
 16430 000031C9 7406                    	jz	short heads_not_altered
 16431                                  
 16432 000031CB A1[A23A]                	mov	ax,[hlim]
 16433                                  	;mov	[deviceparameters+22],ax	
 16434 000031CE A3[9439]                	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax
 16435                                  
 16436                                  heads_not_altered:
 16437                                  
 16438                                  ; set up correct media descriptor byte and sectors/cluster
 16439                                  ;   sectors/cluster is always 2 except for any one sided disk or 1.44M
 16440                                  
 16441                                  	;mov	byte [deviceparameters+9],2
 16442                                  	; 02/11/2022
 16443 000031D1 C606[8739]02            	mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],2
 16444 000031D6 B3F0                    	mov	bl,0F0h			; get default mediabyte
 16445                                  
 16446                                  ;	preload the mediadescriptor from the bpb into bh for convenient access
 16447                                  
 16448                                  	;mov	bh,[deviceparameters+17]
 16449                                  	; 02/11/2022
 16450 000031D8 8A3E[8F39]              	mov	bh,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
 16451                                  
 16452 000031DC 833E[9439]02            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],2 ; >2 heads?
 16453 000031E1 773D                    	ja	short got_correct_mediad ; just use default if heads>2
 16454                                  
 16455 000031E3 7524                    	jne	short only_one_head	; one head, do one head stuff
 16456                                  
 16457                                  ;	two head drives will use the mediadescriptor from the bpb
 16458                                  
 16459 000031E5 88FB                    	mov	bl,bh			; get mediadescriptor from bpb
 16460                                  
 16461                                  ;	two sided drives have two special cases to look for. One is
 16462                                  ;	   a 320K diskette (40 tracks, 8 secs per track). It uses
 16463                                  ;	   a mediaid of 0fch. The other is 1.44M, which uses only
 16464                                  ;	   one sector/cluster.
 16465                                  
 16466                                  ;	any drive with 18secs/trk, 2 heads, 80 tracks, will be assumed
 16467                                  ;	   to be a 1.44M and use only 1 sector per cluster. Any other
 16468                                  ;	   type of 2 headed drive is all set.
 16469                                  
 16470 000031E7 833E[9239]12            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],18
 16471 000031EC 7509                    	jne	short not_144m
 16472 000031EE 833E[8239]50            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
 16473 000031F3 7502                    	jne	short not_144m
 16474                                  
 16475                                  ;	We've got cyl=80, heads=2, secpertrack=18. Set cluster size to 1.
 16476                                  
 16477 000031F5 EB24                    	jmp	short got_one_secperclus_drive
 16478                                  
 16479                                  ;	check for 320K
 16480                                  
 16481                                  not_144m:
 16482 000031F7 833E[8239]28            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
 16483 000031FC 7522                    	jne	short got_correct_mediad
 16484 000031FE 833E[9239]08            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
 16485 00003203 751B                    	jne	short got_correct_mediad
 16486                                  
 16487 00003205 B3FC                    	mov	bl,0FCh
 16488 00003207 EB17                    	jmp	short got_correct_mediad
 16489                                  
 16490                                  only_one_head:
 16491                                  
 16492                                  ;	if we don't have a 360K drive, then just go use 0f0h as media descr.
 16493                                  
 16494 00003209 803E[7F39]00            	cmp	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH ; 0
 16495 0000320E 740B                    	je	short got_one_secperclus_drive
 16496                                  
 16497                                  ;	single sided 360K drive uses either 0fch or 0feh, depending on
 16498                                  ;	  whether sectorspertrack is 8 or 9. For our purposes, anything
 16499                                  ;	  besides 8 will be considered 0fch
 16500                                  
 16501 00003210 B3FC                    	mov	bl,0FCh			; single sided 9 sector media id
 16502 00003212 833E[9239]08            	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
 16503 00003217 7502                    	jne	got_one_secperclus_drive ; okay if anything besides 8
 16504                                  
 16505 00003219 B3FE                    	mov	bl,0FEh			; 160K mediaid
 16506                                  
 16507                                  ;	we've either got a one sided drive, or a 1.44M drive
 16508                                  ;	  either case we'll use 1 sector per cluster instead of 2
 16509                                  
 16510                                  got_one_secperclus_drive:
 16511 0000321B C606[8739]01            	mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],1
 16512                                  
 16513                                  got_correct_mediad:
 16514 00003220 881E[8F39]              	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR],bl
 16515                                  
 16516                                  ;	 Calculate the correct number of Total Sectors on medium
 16517                                  
 16518 00003224 A1[8239]                	mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
 16519 00003227 F726[9439]              	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
 16520 0000322B F726[9239]              	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
 16521 0000322F A3[8D39]                	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS],ax
 16522 00003232 F8                      	clc				; we currently return no errors
 16523                                  
 16524 00003233 C3                      	retn
 16525                                  
 16526                                  ;	M047 -- end rewritten routine
 16527                                  
 16528                                  ;----------------------------------------------------------------------------
 16529                                  ;
 16530                                  ; procedure : organize
 16531                                  ;
 16532                                  ;----------------------------------------------------------------------------
 16533                                  
 16534                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 16535                                  	; (SYSINIT:3234h)
 16536                                  
 16537                                  organize:
 16538 00003234 2E8B0E[D203]            	mov	cx,[cs:count]
 16539 00003239 E32A                    	jcxz	nochar1
 16540                                  
 16541                                  ;ifndef	MULTI_CONFIG
 16542                                  ;
 16543                                  ;;   In MULTI_CONFIG, we map to upper case on a line-by-line basis,
 16544                                  ;;   because we the case of values in SET commands preserved
 16545                                  ;
 16546                                  ;	call	mapcase
 16547                                  ;endif
 16548                                  
 16549                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16550 0000323B E83A02                  	call	mapcase
 16551                                  
 16552 0000323E 31F6                    	xor	si,si
 16553 00003240 89F7                    	mov	di,si
 16554 00003242 31C0                    	xor	ax,ax
 16555 00003244 2EC606[CC03]00          	mov	byte [cs:com_level],0
 16556                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
 16557                                  	;mov	[cs:com_level],al
 16558                                  org1:
 16559 0000324A E8C801                  	call	skip_comment
 16560 0000324D 740D                    	jz	short end_commd_line	; found a comment string and skipped.
 16561 0000324F E8A801                  	call	get2			; not a comment string. then get a char.
 16562 00003252 3C0A                    	cmp	al,lf ; 0Ah
 16563 00003254 7406                    	je	short end_commd_line	; starts with a blank line.
 16564 00003256 3C20                    	cmp	al,' ' ; 20h
 16565 00003258 76F0                    	jbe	short org1		; skip leading control characters
 16566 0000325A EB0B                    	jmp	short findit
 16567                                  
 16568                                  end_commd_line:
 16569 0000325C AA                      	stosb				; store line feed char in buffer for the linecount.
 16570 0000325D 2EC606[CC03]00          	mov	byte [cs:com_level], 0	; reset the command level.
 16571 00003263 EBE5                    	jmp	short org1
 16572                                  
 16573                                  nochar1:
 16574 00003265 F9                      	stc
 16575 00003266 C3                      	retn
 16576                                  
 16577                                  findit:
 16578 00003267 51                      	push	cx
 16579 00003268 56                      	push	si
 16580 00003269 57                      	push	di
 16581 0000326A 89F5                    	mov	bp,si
 16582 0000326C 4D                      	dec	bp
 16583 0000326D BE[ED38]                        mov     si,comtab		; prepare to search command table
 16584 00003270 B500                    	mov	ch,0
 16585                                  findcom:
 16586 00003272 89EF                    	mov	di,bp
 16587 00003274 8A0C                    	mov	cl,[si]
 16588 00003276 46                      	inc	si
 16589 00003277 E324                    	jcxz	nocom
 16590                                  
 16591                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16592                                  
 16593                                  ;ifdef	MULTI_CONFIG
 16594                                  ;
 16595                                  ;;   Simplify future parsing by collapsing ";" onto "REM", and at the same
 16596                                  ;;   time skip the upcoming delimiter test (since ";" need not be followed by
 16597                                  ;;   anything in particular)
 16598                                  ;
 16599                                  ;       cmp     byte [es:di],CONFIG_SEMICOLON  ; ';'
 16600                                  ;       je	short semicolon
 16601                                  ;loopcom:
 16602                                  ;       mov     al,[es:di]
 16603                                  ;       inc     di
 16604                                  ;       and     al,~20h ; 0DFh		; force upper case
 16605                                  ;       inc     si                      ; compare to byte @es:di
 16606                                  ;       cmp     al,[si-1]
 16607                                  ;       loope   loopcom
 16608                                  ;;else
 16609                                  ;;	repe	cmpsb
 16610                                  ;endif
 16611                                  	; 02/11/2022
 16612 00003279 F3A6                    	repe	cmpsb
 16613                                  
 16614 0000327B 9F                      	lahf
 16615 0000327C 01CE                            add     si,cx                   ; bump to next position without affecting flags
 16616 0000327E 9E                      	sahf
 16617 0000327F AC                              lodsb                           ; get indicator letter
 16618 00003280 75F0                    	jnz	short findcom
 16619 00003282 26803D0D                        cmp     byte [es:di],cr		; the next char might be cr,lf
 16620 00003286 7410                    	je	short gotcom0 		; such as in "rem",cr,lf case.
 16621 00003288 26803D0A                	cmp	byte [es:di],lf
 16622 0000328C 740A                    	je	short gotcom0
 16623                                  
 16624                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16625                                  ;
 16626                                  ;;ifdef	MULTI_CONFIG
 16627                                  ;
 16628                                  ;;   Skip the delimiter test for the BEGIN identifier (it doesn't have one).
 16629                                  ;
 16630                                  ;       cmp     al,CONFIG_BEGIN  ; '['
 16631                                  ;       je	short gotcom0
 16632                                  ;;endif
 16633                                  ;	push	ax
 16634                                  ;       mov     al,[es:di]		; now the next char. should be a delim.
 16635                                  ;
 16636                                  ;;ifdef	MULTI_CONFIG
 16637                                  ;
 16638                                  ;;   If keyword is *immediately* followed by a question mark (?), then
 16639                                  ;;   set the high bit of the ASCII command code (CONFIG_OPTION_QUERY) that is
 16640                                  ;;   stored in the CONFIG.SYS memory image.
 16641                                  ;
 16642                                  ;       cmp     al,'?'                  ; explicit interactive command?
 16643                                  ;       jne	short no_query		; no
 16644                                  ;       pop     ax                      ; yes, so retrieve the original code
 16645                                  ;       or      al,CONFIG_OPTION_QUERY  ; and set the QUERY bit
 16646                                  ;       jmp     short gotcom0           ;
 16647                                  ;semicolon:
 16648                                  ;       mov     al,CONFIG_REM
 16649                                  ;       jmp     short gotcom0
 16650                                  ;no_query:
 16651                                  ;;endif  ;MULTI_CONFIG
 16652                                  
 16653                                  	; 02/11/2022
 16654 0000328E 50                      	push	ax
 16655 0000328F 268A05                  	mov	al,[es:di]		; now the next char. should be a delim.
 16656                                  
 16657 00003292 E8BB01                  	call	delim
 16658                                  no_delim:
 16659 00003295 58                      	pop	ax
 16660 00003296 75DA                    	jnz	short findcom
 16661                                  gotcom0:
 16662 00003298 5F                      	pop	di
 16663 00003299 5E                      	pop	si
 16664 0000329A 59                      	pop	cx
 16665 0000329B EB0F                    	jmp	short gotcom
 16666                                  nocom:
 16667 0000329D 5F                      	pop	di
 16668 0000329E 5E                      	pop	si
 16669 0000329F 59                      	pop	cx
 16670 000032A0 B05A                            mov     al,CONFIG_UNKNOWN  ; 'Z'
 16671 000032A2 AA                      	stosb				; save indicator char.
 16672                                  _skipline:
 16673 000032A3 E85401                  	call	get2
 16674 000032A6 3C0A                    	cmp	al,lf ; 0Ah		; skip this bad command line
 16675 000032A8 75F9                            jne     short _skipline
 16676 000032AA EBB0                    	jmp	short end_commd_line	; handle next command line
 16677                                  gotcom:
 16678 000032AC AA                              stosb                           ; save indicator char in buffer
 16679                                  
 16680                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16681                                  ;;ifdef	MULTI_CONFIG
 16682                                  ;
 16683                                  ;;   Don't pollute "cmd_indicator" with the CONFIG_OPTION_QUERY bit though;
 16684                                  ;;   it screws up the direct comparisons below.
 16685                                  ;
 16686                                  ;       and     al,~CONFIG_OPTION_QUERY ; 7Fh
 16687                                  ;;endif
 16688                                  ;	mov	[cs:cmd_indicator],al	; save it for the future use.
 16689                                  ;
 16690                                  ;;ifdef	MULTI_CONFIG
 16691                                  ;
 16692                                  ;;   There is no whitespace/delimiter between the "begin block" character
 16693                                  ;;   ([) and the name of block (eg, [menu]), therefore skip this delimiter
 16694                                  ;;   skipping code
 16695                                  ;
 16696                                  ;       cmp     al,CONFIG_BEGIN
 16697                                  ;       je	short org31
 16698                                  ;       cmp     al,CONFIG_SUBMENU ; 'O'
 16699                                  ;       je      short no_mapcase
 16700                                  ;       cmp     al,CONFIG_MENUITEM ; 'E'
 16701                                  ;       je      short no_mapcase
 16702                                  ;       cmp     al,CONFIG_MENUDEFAULT ; 'A'
 16703                                  ;       je      short no_mapcase
 16704                                  ;       cmp     al,CONFIG_INCLUDE ; 'J'
 16705                                  ;       je      short no_mapcase
 16706                                  ;       call    mapcase                 ; map case of rest of line to UPPER
 16707                                  ;no_mapcase:
 16708                                  ;;endif
 16709                                  
 16710                                  	; 02/11/2022
 16711 000032AD 2EA2[D003]              	mov	[cs:cmd_indicator],al	; save it for the future use.
 16712                                  org2:	
 16713 000032B1 E84601                  	call    get2                    ; skip the command name until delimiter
 16714 000032B4 3C0A                            cmp     al,lf
 16715 000032B6 740B                    	je	short org21
 16716 000032B8 3C0D                    	cmp	al,cr
 16717 000032BA 7407                    	je	short org21
 16718                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16719                                  	;cmp	al, '/'			; T-RICHJ: Added to allow DEVHIGH/L:...
 16720                                  	;je	short org21		; T-RICHJ: to be parsed properly.
 16721                                  
 16722 000032BC E89101                  	call	delim
 16723 000032BF 75F0                            jnz	short org2
 16724 000032C1 EB02                    	jmp	short org3
 16725                                  org21:					;if cr or lf then
 16726 000032C3 4E                      	dec	si			; undo si, cx register
 16727 000032C4 41                      	inc	cx			;  and continue
 16728                                  org3:	
 16729 000032C5 2E803E[D003]59          	cmp	byte [cs:cmd_indicator],CONFIG_COMMENT ; 'Y'
 16730 000032CB 745A                    	je	short get_cmt_token
 16731                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16732                                          ;cmp     byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
 16733                                  	;je	short org_file
 16734 000032CD 2E803E[D003]49                  cmp     byte [cs:cmd_indicator],CONFIG_INSTALL ; 'I'
 16735 000032D3 742C                    	je	short org_file
 16736                                          ;cmp	byte [cs:cmd_indicator],CONFIG_INSTALLHIGH ; 'W'
 16737                                          ;je	short org_file
 16738                                  	; 02/11/2022
 16739 000032D5 2E803E[D003]44          	cmp     byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
 16740 000032DB 7424                    	je	short org_file
 16741 000032DD 2E803E[D003]53                  cmp     byte [cs:cmd_indicator],CONFIG_SHELL ; 'S'
 16742 000032E3 741C                    	je	short org_file
 16743 000032E5 2E803E[D003]31                  cmp	byte [cs:cmd_indicator],CONFIG_SWITCHES ; '1'
 16744 000032EB 7403                    	je	short org_switch
 16745                                  org31:
 16746 000032ED E99900                  	jmp	org4
 16747                                  
 16748                                  org_switch:
 16749 000032F0 E82201                  	call	skip_comment
 16750 000032F3 7476                    	jz	short end_commd_line_brdg
 16751                                  
 16752 000032F5 E80201                  	call	get2
 16753 000032F8 E85D01                  	call	org_delim
 16754 000032FB 74F3                    	jz	short org_switch
 16755                                  
 16756 000032FD AA                      	stosb
 16757 000032FE E99700                  	jmp	org5
 16758                                  
 16759                                  org_file:			; get the filename and put 0 at end
 16760 00003301 E81101                  	call	skip_comment
 16761 00003304 7468                    	jz	short org_put_zero
 16762                                  
 16763 00003306 E8F100                  	call	get2		; not a comment
 16764 00003309 E84401                  	call	delim
 16765 0000330C 74F3                    	jz	short org_file	; skip the possible delimiters
 16766                                  
 16767 0000330E AA                      	stosb			; copy the first non delim char found in buffer
 16768                                  
 16769                                  org_copy_file:
 16770 0000330F E80301                  	call	skip_comment	; comment char in the filename?
 16771 00003312 745A                    	jz	short org_put_zero ; then stop copying filename at that point
 16772                                  
 16773 00003314 E8E300                  	call	get2
 16774 00003317 3C2F                    	cmp	al,'/'		; a switch char? (device=filename/xxx)
 16775 00003319 745B                    	je	short end_file_slash ; this will be the special case.
 16776                                  
 16777 0000331B AA                      	stosb			; save the char. in buffer
 16778 0000331C E83101                  	call	delim
 16779 0000331F 745D                    	jz	short end_copy_file
 16780                                  
 16781 00003321 3C20                    	cmp	al, ' '
 16782 00003323 77EA                    	ja	short org_copy_file ; keep copying
 16783 00003325 EB57                    	jmp	short end_copy_file ; otherwise, assume end of the filename.
 16784                                  
 16785                                  get_cmt_token:			; get the token. just max. 2 char.
 16786 00003327 E8D000                  	call	get2
 16787 0000332A 3C20                    	cmp	al,' '		; skip white spaces or "=" char.
 16788 0000332C 74F9                    	je	short get_cmt_token ; (we are allowing the other special
 16789 0000332E 3C09                    	cmp	al,tab ; 9 	;  characters can used for comment id.
 16790 00003330 74F5                    	je	short get_cmt_token ;  character.)
 16791 00003332 3C3D                    	cmp	al,'='		; = is special in this case.
 16792 00003334 74F1                    	je	short get_cmt_token
 16793 00003336 3C0D                    	cmp	al,cr
 16794 00003338 742A                    	je	short get_cmt_end ; cannot accept the carriage return
 16795 0000333A 3C0A                    	cmp	al,lf
 16796 0000333C 7426                    	je	short get_cmt_end
 16797                                  
 16798 0000333E 2EA2[CE03]              	mov	[cs:cmmt1],al	; store it
 16799 00003342 2EC606[CD03]01          	mov	byte [cs:cmmt],1 ; 1 char. so far.
 16800 00003348 E8AF00                  	call	get2
 16801 0000334B 3C20                    	cmp	al,' ' ; 20h
 16802 0000334D 7415                    	je	short get_cmt_end
 16803 0000334F 3C09                    	cmp	al,tab ; 9
 16804 00003351 7411                    	je	short get_cmt_end
 16805 00003353 3C0D                    	cmp	al,cr  ; 0Dh
 16806 00003355 740D                    	je	short get_cmt_end
 16807 00003357 3C0A                    	cmp	al,lf  ; 0Ah
 16808 00003359 7410                    	je	short end_commd_line_brdg
 16809                                  
 16810 0000335B 2EA2[CF03]              	mov	[cs:cmmt2],al
 16811 0000335F 2EFE06[CD03]            	inc	byte [cs:cmmt]
 16812                                  
 16813                                  get_cmt_end:
 16814 00003364 E89300                  	call	get2
 16815 00003367 3C0A                    	cmp	al,lf
 16816 00003369 75F9                    	jne	short get_cmt_end	; skip it.
 16817                                  end_commd_line_brdg: 
 16818 0000336B E9EEFE                  	jmp	end_commd_line 		; else jmp to end_commd_line
 16819                                  
 16820                                  org_put_zero:				; make the filename in front of
 16821 0000336E 26C60500                	mov	byte [es:di],0		;  the comment string to be an asciiz.
 16822 00003372 47                      	inc	di
 16823 00003373 E9E6FE                  	jmp	end_commd_line		;  (maybe null if device=/*)
 16824                                  
 16825                                  end_file_slash: 			; al = "/" option char.
 16826 00003376 26C60500                	mov	byte [es:di],0		; make a filename an asciiz
 16827 0000337A 47                      	inc	di			; and
 16828 0000337B AA                      	stosb				; store "/" after that.
 16829 0000337C EB1A                    	jmp	short org5		; continue with the rest of the line
 16830                                  
 16831                                  end_copy_file:
 16832 0000337E 26C645FF00              	mov	byte [es:di-1],0	; make it an asciiz and handle the next char.
 16833 00003383 3C0A                    	cmp	al,lf
 16834 00003385 74E4                    	je	short end_commd_line_brdg
 16835 00003387 EB0F                    	jmp	short org5
 16836                                  
 16837                                  org4:					; org4 skips all delimiters after the command name except for '/'
 16838 00003389 E88900                  	call	skip_comment
 16839 0000338C 74DD                    	jz	short end_commd_line_brdg
 16840                                  
 16841 0000338E E86900                  	call	get2
 16842 00003391 E8C400                  	call	org_delim		; skip delimiters except '/' (mrw 4/88)
 16843 00003394 74F3                    	jz	short org4
 16844 00003396 EB08                    	jmp	short org51
 16845                                  
 16846                                  org5:					; rest of the line
 16847 00003398 E87A00                  	call	skip_comment		; comment?
 16848 0000339B 74CE                    	jz	short end_commd_line_brdg
 16849 0000339D E85A00                  	call	get2			; not a comment.
 16850                                  
 16851                                  org51:
 16852 000033A0 AA                      	stosb				; copy the character
 16853 000033A1 3C22                    	cmp	al,'"' 	; 22h		; a quote ?
 16854 000033A3 743E                    	je	short at_quote
 16855 000033A5 3C20                    	cmp	al,' '  ; 20h
 16856 000033A7 77EF                    	ja	short org5
 16857                                  					; M051 - Start
 16858                                  
 16859 000033A9 2E803E[D003]55                  cmp	byte [cs:cmd_indicator],CONFIG_DEVICEHIGH ; Q: is this devicehigh
 16860 000033AF 7515                    	jne	short not_dh		; N: 
 16861 000033B1 3C0A                    	cmp	al,lf			; Q: is this line feed
 16862 000033B3 7417                    	je	short org_dhlf		; Y: stuff a blank before the lf
 16863 000033B5 3C0D                    	cmp	al,cr			; Q: is this a cr
 16864 000033B7 75DF                    	jne	short org5		; N: 
 16865 000033B9 26C645FF20              	mov	byte [es:di-1],' '	; overwrite cr with blank
 16866 000033BE AA                      	stosb				; put cr after blank
 16867 000033BF 2EFE06[5430]            	inc	byte [cs:insert_blank]	; indicate that blank has been 
 16868                                  					; inserted
 16869 000033C4 EBD2                    	jmp	short org5
 16870                                  not_dh:					; M051 - End
 16871                                  
 16872 000033C6 3C0A                    	cmp	al,lf			; line feed?
 16873 000033C8 7410                    	je	short org1_brdg		; handles the next command line.
 16874 000033CA EBCC                    	jmp	short org5		; handles next char in this line.
 16875                                  
 16876                                  org_dhlf:				; M051 - Start
 16877 000033CC 2E803E[5430]01          	cmp	byte [cs:insert_blank],1 ; Q:has a blank already been inserted
 16878 000033D2 7406                    	je	short org1_brdg		; Y:
 16879 000033D4 26C645FF20              	mov	byte [es:di-1],' '	; overwrite lf with blank
 16880 000033D9 AA                      	stosb				; put lf after blank
 16881                                  					; M051 - End
 16882                                  org1_brdg: 
 16883 000033DA 2EC606[5430]00          	mov	byte [cs:insert_blank],0 ; M051: clear blank indicator for 
 16884                                  					; M051: devicehigh
 16885 000033E0 E967FE                  	jmp	org1
 16886                                  
 16887                                  at_quote:
 16888 000033E3 2E803E[CC03]00          	cmp	byte [cs:com_level],0
 16889 000033E9 7408                    	je	short up_level
 16890 000033EB 2EC606[CC03]00          	mov	byte [cs:com_level],0	; reset it.
 16891 000033F1 EBA5                    	jmp	short org5
 16892                                  
 16893                                  up_level:
 16894 000033F3 2EFE06[CC03]            	inc	byte [cs:com_level]	; set it.
 16895 000033F8 EB9E                    	jmp	short org5
 16896                                  
 16897                                  ;----------------------------------------------------------------------------
 16898                                  ;
 16899                                  ; procedure : get2
 16900                                  ;
 16901                                  ;----------------------------------------------------------------------------
 16902                                  
 16903                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 16904                                  	; (SYSINIT:33FAh)
 16905                                  get2:
 16906 000033FA E306                    	jcxz	noget
 16907                                  	;
 16908                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16909                                  	;;lods	byte ptr es:[si]
 16910                                  	;es	
 16911                                  	;lodsb
 16912 000033FC 268A04                  	mov	al, [es:si]
 16913 000033FF 46                      	inc	si
 16914                                  	;
 16915 00003400 49                      	dec	cx
 16916 00003401 C3                      	retn
 16917                                  noget:
 16918 00003402 59                      	pop	cx
 16919 00003403 2E893E[D203]            	mov	[cs:count],di ; 13/05/2019
 16920 00003408 2E893E[D403]            	mov	[cs:org_count],di
 16921 0000340D 31F6                    	xor	si,si
 16922 0000340F 2E8936[D603]            	mov	[cs:chrptr],si
 16923                                  
 16924                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16925                                  ;;ifndef MULTI_CONFIG
 16926                                  ;;	retn
 16927                                  ;;else
 16928                                  ;
 16929                                  ;;   This was the rather kludgy way out of procedure "organize", but instead
 16930                                  ;;   of returning to doconf, we now want to check config.sys BEGIN/END blocks
 16931                                  ;;   and the new boot menu stuff...
 16932                                  ;
 16933                                  ;	mov     cx,di
 16934                                  ;	jmp     menu_check
 16935                                  ;;endif
 16936                                  
 16937                                  	; 02/11/2022
 16938 00003414 C3                      	retn
 16939                                  
 16940                                  ;----------------------------------------------------------------------------
 16941                                  ;
 16942                                  ; procedure : skip_comment
 16943                                  ;
 16944                                  ;skip the commented string until lf, if current es:si-> a comment string.
 16945                                  ;in) es:si-> string
 16946                                  ;	 cx -> length.
 16947                                  ;out) zero flag not set if not found a comment string.
 16948                                  ;	  zero flag set if found a comment string and skipped it. al will contain
 16949                                  ;	  the line feed character at this moment when return.
 16950                                  ;	  ax register destroyed.
 16951                                  ;	  if found, si, cx register adjusted accordingly.
 16952                                  ;
 16953                                  ;----------------------------------------------------------------------------
 16954                                  
 16955                                  skip_comment:
 16956 00003415 E3EB                    	jcxz	noget		; get out of the organize routine.
 16957 00003417 2E803E[CC03]00          	cmp	byte [cs:com_level],0 ; only check it if parameter level is 0.
 16958 0000341D 7530                    	jne	short no_commt	;  (not inside quotations)
 16959                                  
 16960 0000341F 2E803E[CD03]01          	cmp	byte [cs:cmmt],1
 16961 00003425 7228                    	jb	short no_commt
 16962                                  
 16963 00003427 268A04                  	mov	al,[es:si]
 16964 0000342A 2E3806[CE03]            	cmp	[cs:cmmt1],al
 16965 0000342F 751E                    	jne	short no_commt
 16966                                  
 16967 00003431 2E803E[CD03]02          	cmp	byte [cs:cmmt],2
 16968 00003437 750B                    	jne	short skip_cmmt
 16969                                  
 16970 00003439 268A4401                	mov	al,[es:si+1]
 16971 0000343D 2E3806[CF03]            	cmp	[cs:cmmt2],al
 16972 00003442 750B                    	jne	short no_commt
 16973                                  skip_cmmt:
 16974 00003444 E3BC                    	jcxz	noget		; get out of organize routine.
 16975 00003446 268A04                  	mov	al,[es:si]
 16976 00003449 46                      	inc	si
 16977 0000344A 49                      	dec	cx
 16978 0000344B 3C0A                    	cmp	al,lf		; line feed?
 16979 0000344D 75F5                    	jne	short skip_cmmt
 16980                                  no_commt:
 16981 0000344F C3                      	retn
 16982                                  
 16983                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 16984                                  %if 0
 16985                                  
 16986                                  ;ifdef	MULTI_CONFIG
 16987                                  
 16988                                  ;----------------------------------------------------------------------------
 16989                                  ;
 16990                                  ;   kbd_read: wait for keystroke
 16991                                  ;
 16992                                  ;   INPUT
 16993                                  ;       DS == CS == sysinitseg
 16994                                  ;
 16995                                  ;   OUTPUT
 16996                                  ;       Carry SET to clean boot, CLEAR otherwise
 16997                                  ;
 16998                                  ;   OTHER REGS USED
 16999                                  ;       All
 17000                                  ;
 17001                                  ;   HISTORY
 17002                                  ;       Created 16-Nov-1992 by JeffPar
 17003                                  ;
 17004                                  ;----------------------------------------------------------------------------
 17005                                  
 17006                                  kbd_read:
 17007                                          test    byte [bDisableUI],2
 17008                                          jnz     short kbd_nodelay
 17009                                  
 17010                                          push    ds              ; the bios timer tick count is incremented
 17011                                          sub     ax,ax           ; 18.2 times per second;
 17012                                          mov     ds,ax           ; watch the timer tick count for 37 transitions
 17013                                  	;mov	dx,[046Ch]	; get initial value
 17014                                  kbd_loop:
 17015                                          mov     ah,1            ;
 17016                                          int     16h             ; peek the keyboard
 17017                                          jnz	short kbd_loopdone ; something's there, get out
 17018                                          mov     ah,2            ; peek the shift states
 17019                                          int     16h             ;
 17020                                          test    al,03h          ; either right or left shift key bits set?
 17021                                          jnz	short kbd_loopdone ; yes
 17022                                          mov     ax,[046Ch]	;
 17023                                  	;sub	ax,dx           ; get difference
 17024                                  	; 15/04/2019 - Retro DOS v4.0
 17025                                  	sub	ax,[cs:_timer_lw_] ; MSDOS 6.21 IO.SYS - SYSINIT:42E5h        
 17026                                  
 17027                                  	cmp     al,37           ; reached limit?
 17028                                          jb	short kbd_loop	; not yet
 17029                                  kbd_loopdone:
 17030                                          pop     ds              ; delay complete!
 17031                                  kbd_nodelay:
 17032                                          sub     bx,bx           ; assume clean boot
 17033                                          mov     ah,2            ; peek the shift states
 17034                                          int     16h             ;
 17035                                          test    al,03h          ; either right or left shift key bits set?
 17036                                          jz      short kbd_notshift ; no
 17037                                          inc     bx              ; yes
 17038                                          inc     bx
 17039                                  	; MSDOS 6.21 IO.SYS - SYSINIT:4301h
 17040                                  	or	byte [bQueryOpt],4
 17041                                  kbd_notshift:                   ;
 17042                                          mov     ah,1            ; peek the keyboard
 17043                                          int     16h             ;
 17044                                          jz	short kbd_test	; no key present
 17045                                          or      al,al           ; is it a function key?
 17046                                          jnz	short kbd_test	; no
 17047                                  
 17048                                  	; MSDOS 6.21 IO.SYS - SYSINIT:430Bh
 17049                                          cmp     ah,62h          ; CTRL F5
 17050                                          je	short kbd_cfg_bypass
 17051                                  	
 17052                                          cmp     ah,3Fh          ; F5 function key?
 17053                                          jne	short kbd_notf5	; no
 17054                                  kbd_cfg_bypass:
 17055                                          mov     dx,_$CleanMsg
 17056                                          call    print
 17057                                  	; MSDOS 6.21 IO.SYS - SYSINIT:431Bh
 17058                                  	or	byte [bQueryOpt],4           ;
 17059                                          jmp     short kbd_eat   ; yes, clean boot selected
 17060                                  kbd_notf5:
 17061                                  	; MSDOS 6.21 IO.SYS - SYSINIT:4322h
 17062                                          cmp     ah,65h          ; CTRL F8
 17063                                          je	short kbd_cfg_confirm
 17064                                  
 17065                                          cmp     ah,42h          ; F8 function key?
 17066                                          jne	short kbd_exit	; no
 17067                                  kbd_cfg_confirm:
 17068                                          mov     dx,_$InterMsg
 17069                                          call    print           ;
 17070                                          mov     bl,1            ; yes, interactive-boot option enabled
 17071                                          mov     [bQueryOpt],bl  ; change default setting
 17072                                  kbd_eat:                        ;
 17073                                          mov     ah,0            ;
 17074                                          int     16h             ; eat the key we assumed was a signal
 17075                                          mov	byte [secElapsed],-1
 17076                                          or      bx,bx           ;
 17077                                          jz	short kbd_clean	;
 17078                                  kbd_test:                       ;
 17079                                          cmp     bl,2            ;
 17080                                          jb	short kbd_exit	;
 17081                                  kbd_clean:                      ;
 17082                                          call    disable_autoexec; yes, tell COMMAND to skip autoexec.bat
 17083                                          stc                     ; set carry to indicate abort
 17084                                          retn			;
 17085                                  kbd_exit:                       ;
 17086                                          clc                     ; clear carry to indicate success
 17087                                          retn			;
 17088                                  
 17089                                  ;----------------------------------------------------------------------------
 17090                                  ;
 17091                                  ;   set_numlock: set numlock LED
 17092                                  ;
 17093                                  ;   INPUT
 17094                                  ;       ES:SI -> numlock setting (ie, "ON" or "OFF")
 17095                                  ;
 17096                                  ;   OUTPUT
 17097                                  ;       None
 17098                                  ;
 17099                                  ;   OTHER REGS USED
 17100                                  ;       None
 17101                                  ;
 17102                                  ;   HISTORY
 17103                                  ;       Created 16-Nov-1992 by JeffPar
 17104                                  ;
 17105                                  ;----------------------------------------------------------------------------
 17106                                  
 17107                                  set_numlock:
 17108                                          push    ax
 17109                                          push    ds
 17110                                          sub     ax,ax
 17111                                          mov     ds,ax
 17112                                          mov     ax,[es:si]      ; get 1st 2 bytes of value (ON or OF)
 17113                                          cmp     ax,[cs:OnOff+2]	; should we turn it off?
 17114                                          jne	short not_off	; no
 17115                                          and     byte [0417h],~20h ; 0DFh
 17116                                          jmp     short set_done
 17117                                  not_off:
 17118                                          cmp     ax,[cs:OnOff]	; should we turn it on?
 17119                                          stc
 17120                                          jne	short set_done	; no
 17121                                          or      byte [0417h],20h
 17122                                  set_done:
 17123                                          pop     ds
 17124                                          pop     ax
 17125                                          retn
 17126                                  
 17127                                  ; 16/04/2019 - Retro DOS v4.0
 17128                                  
 17129                                  ;----------------------------------------------------------------------------
 17130                                  ;
 17131                                  ;   menu_check:  check for presence of menu (and other) configuration blocks
 17132                                  ;
 17133                                  ;   INPUT
 17134                                  ;       CX == "organized" config.sys memory image length
 17135                                  ;    ES:SI -> "organized" config.sys memory image
 17136                                  ;       DS == CS == sysinitseg
 17137                                  ;
 17138                                  ;   OUTPUT
 17139                                  ;       Same as above;  the idea is that menu_check simply transforms
 17140                                  ;       a block-structured config.sys image into a conventional image,
 17141                                  ;       based on the user's block selection and any other boot-time options
 17142                                  ;       the user may have employed...
 17143                                  ;
 17144                                  ;   OTHER REGS USED
 17145                                  ;       All
 17146                                  ;
 17147                                  ;   NOTES
 17148                                  ;       [count] and [org_count] are set to the new config.sys image length
 17149                                  ;
 17150                                  ;   HISTORY
 17151                                  ;       Created 16-Mar-1992 by JeffPar
 17152                                  ;
 17153                                  ;----------------------------------------------------------------------------
 17154                                  
 17155                                  menu_check:
 17156                                  
 17157                                  ;   Search for SWITCHES, determine if /N or /F are present;  if so, then
 17158                                  ;   disable clean/interactive boot options
 17159                                  
 17160                                          push    cx              ;
 17161                                          push    si              ;
 17162                                          sub     bx,bx           ; remains ZERO until first block
 17163                                  swchk_loop:                     ;
 17164                                          call    get_char        ; get first char of current line
 17165                                          jc	short swchk_end	; hit eof
 17166                                          cmp     al,CONFIG_BEGIN ;
 17167                                          jne	short swchk_next1 ;
 17168                                          inc     bx              ; remember that we've seen a block
 17169                                          jmp     short swchk_nextline
 17170                                  swchk_next1:                    ;
 17171                                          cmp     al,CONFIG_NUMLOCK
 17172                                          jne	short swchk_next2 ;
 17173                                          or      bx,bx           ; only do NUMLOCK commands that exist
 17174                                          jnz	short swchk_nextline ; before the first block
 17175                                          call    set_numlock     ; REM it out so we don't act on it later, too
 17176                                          mov     byte [es:si-1],CONFIG_REM
 17177                                          jmp     short swchk_nextline
 17178                                  swchk_next2:                    ;
 17179                                          cmp     al,CONFIG_SWITCHES
 17180                                          jne	short swchk_nextline ; this line ain't it
 17181                                  swchk_scan:                     ;
 17182                                          call    get_char        ; look for /N or /F
 17183                                  swchk_scan1:                    ;
 17184                                          cmp     al,LF           ; end of line?
 17185                                          je	short swchk_nextline ; yes
 17186                                          cmp     al,'/'          ; switch-char?
 17187                                          jne	short swchk_scan ; no
 17188                                          call    get_char        ;
 17189                                          and     al,~20h ; 0DFh	; convert to upper case
 17190                                          cmp     al,[swit_n+1]
 17191                                          jne	short swchk_scan2 ; no
 17192                                          or      byte [bDisableUI],1
 17193                                          jmp	short swchk_scan ; continue looking for switches of interest
 17194                                  swchk_scan2:                    ;
 17195                                          cmp     al,[swit_f+1]
 17196                                          jne	short swchk_scan1 ; no
 17197                                          or      byte [bDisableUI],2
 17198                                          jmp     short swchk_scan ; continue looking for switches of interest
 17199                                  swchk_nextline:                 ;
 17200                                          call    skip_opt_line   ;
 17201                                          jmp     short swchk_loop ;
 17202                                  swchk_end:                      ;
 17203                                          pop     si              ;
 17204                                          pop     cx              ;
 17205                                  
 17206                                  ;   Do the keyboard tests for clean/interactive boot now, but only if
 17207                                  ;   the DisableUI flag is still clear
 17208                                  
 17209                                          test    byte [bDisableUI],1
 17210                                          jnz	short menu_search
 17211                                  ;
 17212                                  ;   Wait for 2 seconds first, UNLESS the /F bit was set in bDisableUI, or
 17213                                  ;   there is anything at all in the keyboard buffer
 17214                                  ;
 17215                                          call    kbd_read
 17216                                          jnc	short menu_search
 17217                                          jmp	menu_abort
 17218                                  
 17219                                  ;   Search for MENU block;  it is allowed to be anywhere in config.sys
 17220                                  
 17221                                  menu_search:
 17222                                          sub     bx,bx           ; if no MENU, default to zero for no_selection
 17223                                          mov     di,szMenu	;
 17224                                          call    find_block      ; find the MENU block
 17225                                          jnc	short menu_found ;
 17226                                          mov     byte [szBoot],0
 17227                                          jmp	no_selection ; not found
 17228                                  
 17229                                  ;   Process the requested menu color(s)
 17230                                  
 17231                                  menu_color:
 17232                                          push    cx              ;
 17233                                          push    dx              ;
 17234                                          mov     dx,0007h        ; default color setting
 17235                                          call    get_number	; get first number
 17236                                          and     bl,0Fh		; first # is foreground color (for low nibble)
 17237                                          mov     ch,bl           ; save it in CH
 17238                                          and     dl,0F0h         ;
 17239                                          or      dl,bl           ;
 17240                                          call    delim           ; did we hit a delimiter
 17241                                          jne	short check_color ; no, all done
 17242                                          call    get_number	; get next number
 17243                                          and     bl,0Fh		; second # is background color (for high nibble)
 17244                                          mov     dh,bl           ; save it in DH
 17245                                          and     dl,0Fh		;
 17246                                          mov     cl,4            ;
 17247                                          shl     bl,cl           ;
 17248                                          or      dl,bl           ;
 17249                                  check_color:                    ;
 17250                                          cmp     ch,dh           ; are foreground/background the same?
 17251                                          jne	short set_color	; no
 17252                                          xor     dl,08h          ; yes, so modify the fgnd intensity
 17253                                  set_color:
 17254                                          mov     [bMenuColor],dl ;
 17255                                          pop     dx              ;
 17256                                          pop     cx              ;
 17257                                          jmp	menu_nextitem
 17258                                  
 17259                                  ;   Back to our regularly scheduled program (the COLOR and other goop
 17260                                  ;   above is there simply to alleviate short jump problems)
 17261                                  
 17262                                  menu_found:
 17263                                          mov     byte [bDefBlock],1
 17264                                          mov     word [offDefBlock],0
 17265                                          mov     byte [secTimeOut],-1
 17266                                          and     byte [bQueryOpt],~2 ; 0FDh
 17267                                  
 17268                                          call    skip_opt_line   ; skip to next line
 17269                                          sub     dx,dx           ; initialize total block count (0 => none yet)
 17270                                  
 17271                                  ;   Process the menu block now
 17272                                  
 17273                                  menu_process:
 17274                                          call    get_char        ; get first char of current line
 17275                                          jc	short to_menu_getdefault ; could happen if menu block at end (rare)
 17276                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 17277                                          cmp     al,CONFIG_BEGIN ; BEGIN implies END
 17278                                          je	short to_menu_getdefault
 17279                                          cmp     al,CONFIG_SUBMENU
 17280                                          je	short menu_item	; go process sub-menu
 17281                                          cmp     al,CONFIG_MENUITEM
 17282                                          je	short menu_item	; go process menu item
 17283                                          cmp     al,CONFIG_MENUDEFAULT
 17284                                          je	short menu_default ; go process menu default
 17285                                          cmp     al,CONFIG_MENUCOLOR
 17286                                          je	short menu_color ; go process menu color
 17287                                          cmp     al,CONFIG_NUMLOCK
 17288                                          je	short menu_numlock ;
 17289                                          cmp     al,CONFIG_REM   ; allow remarks in menu block
 17290                                          je	short menu_nextitem ;
 17291                                          call    any_delim       ; allow blank lines and such
 17292                                          je	short menu_nextitem ;
 17293                                          stc                     ;
 17294                                          call    print_error     ; non-MENU command!
 17295                                          jmp     short menu_nextitem
 17296                                  menu_numlock:
 17297                                          call    set_numlock
 17298                                          jmp     short menu_nextitem
 17299                                  to_menu_getdefault:
 17300                                          jmp     short menu_getdefault
 17301                                  
 17302                                  ;   Save the offset of the default block name, we'll need it later
 17303                                  
 17304                                  menu_default:
 17305                                          mov     [offDefBlock],si; save address of default block name
 17306                                          cmp     byte [secElapsed],0
 17307                                          jne	short timeout_skip ; secElapsed is only zero for the FIRST menu,
 17308                                          call    skip_token      ; and for subsequent menus IF nothing was typed;
 17309                                          jc	short menu_nextitem ; secElapsed becomes -1 forever as soon as
 17310                                          call    skip_delim      ; something is typed
 17311                                          jc	short menu_nextitem ;
 17312                                          mov     si,bx           ;
 17313                                          call    get_number      ; get number (of seconds for timeout)
 17314                                          cmp     bl,90           ; limit it to a reasonable number
 17315                                          jb	short timeout_ok ; (besides, 99 is the largest # my simple
 17316                                          mov     bl,90           ;  display function can handle)
 17317                                  timeout_ok:                     ;
 17318                                          mov     [secTimeOut],bl ;
 17319                                  timeout_skip:
 17320                                          jmp     short menu_nextitem
 17321                                  
 17322                                  ;   Verify that this is a valid menu item by searching for the named block
 17323                                  
 17324                                  menu_item:
 17325                                          cmp     dl,MAX_MULTI_CONFIG ; have we reached the max # of items yet?
 17326                                          jae	short menu_nextitem ;
 17327                                          mov     di,si           ; DS:DI -> block name to search for
 17328                                          call    srch_block      ;
 17329                                          je	short menu_itemfound ;
 17330                                          stc                     ;
 17331                                          call    print_error     ; print error and pause
 17332                                          jmp     short menu_nextitem ; if not found, ignore this menu item
 17333                                  
 17334                                  ;   srch_block, having succeeded, returns DI -> past the token that it
 17335                                  ;   just matched, which in this case should be a descriptive string; ES:SI
 17336                                  ;   and CX are unmodified
 17337                                  
 17338                                  menu_itemfound:
 17339                                          inc     dx              ; otherwise, increment total block count
 17340                                          mov     bx,dx           ; and use it to index the arrays of offsets
 17341                                          mov	[abBlockType+bx],al
 17342                                          add     bx,bx           ; of recorded block names and descriptions
 17343                                  
 17344                                  ;   There should be a description immediately following the block name on
 17345                                  ;   MENUITEM line; failing that, we'll just use the block name as the
 17346                                  ;   description...
 17347                                  
 17348                                          mov     [aoffBlockName+bx],si
 17349                                          mov     [aoffBlockDesc+bx],si
 17350                                          mov     di,bx           ; skip_delim modifies BX, so stash it in DI
 17351                                          call    skip_token      ;
 17352                                          jc	short menu_nextitem ; hit eol/eof
 17353                                          call    skip_delim      ;
 17354                                          jc	short menu_nextitem ; hit eol/eof
 17355                                          xchg    bx,di           ;
 17356                                          mov     [aoffBlockDesc+bx],di
 17357                                  
 17358                                  menu_nextitem:
 17359                                          call    skip_opt_line   ;
 17360                                          jmp     menu_process    ; go back for more lines
 17361                                  
 17362                                  ;   Display menu items now, after determining which one is default
 17363                                  
 17364                                  menu_getdefault:
 17365                                          or      dl,dl           ; where there any valid blocks at all?
 17366                                          jnz	short menu_valid ; yes
 17367                                          sub     bx,bx           ; no, so force autoselect of 0
 17368                                          jmp     menu_autoselect ; (meaning: process common blocks only)
 17369                                  menu_valid:
 17370                                          sub     bx,bx           ;
 17371                                          mov     [bMaxBlock],dl  ; first, record how many blocks we found
 17372                                          mov     di,[offDefBlock];
 17373                                          or      di,di           ; does a default block exist?
 17374                                          jz	short menu_nodefault ; no
 17375                                          inc     bx              ; yes, walk name table, looking for default
 17376                                  menu_chkdefault:
 17377                                          push    bx              ;
 17378                                          add     bx,bx           ;
 17379                                          mov     si,[aoffBlockName+bx]
 17380                                          mov     cx,128          ; arbitrary maximum length of a name
 17381                                          push    ds              ;
 17382                                          push    es              ;
 17383                                          pop     ds              ;
 17384                                          call    comp_names      ; is this block the same as the default?
 17385                                          pop     ds              ;
 17386                                          pop     bx              ;
 17387                                          je	short menu_setdefault ; yes
 17388                                          inc     bx              ;
 17389                                          cmp     bl,[bMaxBlock]  ; all done searching?
 17390                                          jbe	short menu_chkdefault ; not yet
 17391                                  menu_nodefault:
 17392                                          mov     bl,1            ; if no default, force default to #1
 17393                                  menu_setdefault:
 17394                                          mov     [bDefBlock],bl  ; yes, this will be the initial current block
 17395                                  
 17396                                  ;   If the timeout was explicitly set to 0 (or technically, anything that
 17397                                  ;   failed to resolve to a number, like "NONE" or "EAT POTATOES"), then we're
 17398                                  ;   supposed to skip menu display and run with the specified default block;
 17399                                  ;   however, if the user hit Enter prior to boot, thereby requesting fully
 17400                                  ;   INTERACTIVE boot, then we shall display the menu block anyway (though still
 17401                                  ;   with no timeout)
 17402                                  
 17403                                          cmp     byte [secTimeOut],0 ; is timeout zero? (ie, assume default)
 17404                                          jne	short menu_display ; no
 17405                                          test    byte [bQueryOpt],1 ; yes, but was INTERACTIVE requested?
 17406                                          jnz	short menu_display ; yes, so *don't* assume default after all
 17407                                          jmp     not_topmenu	;
 17408                                  
 17409                                  ;   Reset the mode, so that we know screen is clean and cursor is home
 17410                                  
 17411                                  menu_display:
 17412                                          mov     ah,0Fh          ; get current video mode
 17413                                          int     10h             ;
 17414                                          mov     ah,00h          ; just re-select that mode
 17415                                          int     10h             ;
 17416                                          push    es              ;
 17417                                          mov     ax,40h          ; reach down into the ROM BIOS data area
 17418                                          mov     es,ax           ; and save the current (default) video page
 17419                                          mov     ax,[es:004Eh]   ; start address and page #, in case the
 17420                                          mov     [wCRTStart],ax  ; undocumented QUIET option was enabled
 17421                                          mov     al,[es:0062h]   ;
 17422                                          mov     [bCRTPage],al   ;
 17423                                          mov     ax,[bMenuPage]	; select new page for menu
 17424                                          int     10h             ;
 17425                                          mov     ax,0600h        ; clear entire screen
 17426                                          mov     bh,[bMenuColor] ; using this color
 17427                                          sub     cx,cx           ; upper left row/col
 17428                                          ;mov	dl,[es:CRT_Cols] 
 17429                                          mov	dl,[es:4Ah]
 17430                                  	dec     dl              ;
 17431                                          ;mov	dh,[es:CRT_Rows];
 17432                                          mov	dh,[es:84h]
 17433                                  	or      dh,dh           ; # of rows valid?
 17434                                          jnz	short menu_clear ; hopefully
 17435                                          mov     dh,[bLastRow]   ; no, use a default
 17436                                  menu_clear:
 17437                                          int     10h             ; clear the screen using the req. attribute
 17438                                          pop     es              ;
 17439                                          mov     [bLastRow],dh   ; save DH
 17440                                          mov     dx,_$MenuHeader
 17441                                          call    print           ; cursor now on row 3 (numbered from 0)
 17442                                  
 17443                                          test    byte [bDisableUI],1
 17444                                          jnz     short menu_nostatus
 17445                                          mov     bh,[bMenuPage]  ;
 17446                                          mov     dh,[bLastRow]   ; restore DH
 17447                                          mov     dl,0            ; print the status line on row DH, col 0,
 17448                                          mov     ah,02h          ; now that we can trash the cursor position
 17449                                          int     10h             ;
 17450                                          mov     dx,_$StatusLine
 17451                                          call    print           ;
 17452                                          mov     ah,3            ; get cursor position
 17453                                          int     10h             ;
 17454                                          sub     dl,2            ;
 17455                                          mov     [bLastCol],dl   ; save column where status char will go
 17456                                  
 17457                                  menu_nostatus:
 17458                                          mov     bx,1            ; now prepare to display all the menu items
 17459                                  menu_disploop:
 17460                                          call    print_item	; print item #BL
 17461                                          inc     bx              ; why "inc bx"?  because it's a 1-byte opcode
 17462                                          cmp     bl,[bMaxBlock]  ; all done?
 17463                                          jbe	short menu_disploop ; not yet
 17464                                  
 17465                                  ;   Set cursor position to just below the menu items
 17466                                  
 17467                                          mov     dl,0            ; select column
 17468                                          mov     dh,bl           ;
 17469                                          add     dh,4            ; select row below menu
 17470                                          mov     bh,[bMenuPage]  ;
 17471                                          mov     ah,02h          ; set cursor position beneath the block list
 17472                                          int     10h             ;
 17473                                  
 17474                                          mov     dx,_$MenuPrmpt
 17475                                          call    print           ;
 17476                                          call    select_item     ; make a selection, return # in BX
 17477                                          mov     dx,crlfm	
 17478                                          call    print           ;
 17479                                          push    word [bDisableUI]
 17480                                          or      byte [bDisableUI],1
 17481                                          call    show_status     ; clear the status line now
 17482                                          pop     word [bDisableUI]
 17483                                  
 17484                                  ;   Now begins the "re-organization" process...
 17485                                  
 17486                                  menu_autoselect:
 17487                                          cmp     bx,-1           ; clean boot requested?
 17488                                          jne	short normal_boot ; no
 17489                                          call    disable_autoexec; basically, add a /D to the command.com line
 17490                                  menu_abort:
 17491                                          sub     cx,cx           ; then immediately exit with 0 config.sys image
 17492                                          jmp	menu_exit	;
 17493                                  
 17494                                  normal_boot:
 17495                                          cmp     bx,-2           ; back to top-level menu?
 17496                                          jne	short not_topmenu ; no
 17497                                          mov     cx,[count]      ; yes, start all over
 17498                                          sub     si,si           ;
 17499                                          jmp     menu_search
 17500                                  
 17501                                  not_topmenu:
 17502                                          cmp     byte [abBlockType+bx],CONFIG_SUBMENU
 17503                                          jne	short not_submenu
 17504                                          add     bx,bx           ;
 17505                                          mov     di,[aoffBlockName+bx]
 17506                                          call    srch_block      ; THIS CANNOT FAIL!
 17507                                          mov     si,di           ;
 17508                                          mov     cx,bx           ; ES:SI and CX are ready for another round
 17509                                          jmp     menu_found
 17510                                  
 17511                                  not_submenu:
 17512                                          add     bx,bx           ; get BX -> name of selected block
 17513                                          mov     bx,[aoffBlockName+bx]
 17514                                  
 17515                                  ;   BX should now either be ZERO (meaning no block has been selected) or
 17516                                  ;   the offset relative to ES of the block name to be processed (along with
 17517                                  ;   all the "common" lines of course)
 17518                                  
 17519                                  no_selection:
 17520                                          mov     [offDefBlock],bx; save selection
 17521                                          mov     cx,[count]      ; reset ES:SI and CX for reprocessing
 17522                                          sub     si,si           ;
 17523                                          push    ds              ;
 17524                                          mov     ds,[config_wrkseg]; this is where we'll store new config.sys image
 17525                                          sub     di,di           ;
 17526                                  
 17527                                  ;   ES:SI-> config.sys, DS:DI -> new config.sys workspace
 17528                                  ;
 17529                                  ;   Work our way through the config.sys image again, this time copying
 17530                                  ;   all lines that are (A) "common" lines outside any block or (B) lines
 17531                                  ;   within the requested block.  Lines inside INCLUDEd blocks are transparently
 17532                                  ;   copied by copy_block in a recursive fashion;  the amount of recursion is
 17533                                  ;   limited by the fact INCLUDE statements are REMed by copy_block as they are
 17534                                  ;   processed and by the number of unique INCLUDE stmts in config.sys...
 17535                                  ;
 17536                                  ;   BUGBUG 20-Mar-1992 JeffPar: If we can figure out the lower bound of the
 17537                                  ;   stack we're running on, then we should check it inside copy_block
 17538                                  
 17539                                  copyblock_loop:
 17540                                          push    bx              ; save selected block name
 17541                                          call    copy_block      ; process (named or common) block
 17542                                          pop     bx              ;
 17543                                          jc	short move_config ; hit eof
 17544                                  
 17545                                  ;   copy_block can only return for two reasons:  it hit eof or a new block
 17546                                  
 17547                                  copyblock_begin:
 17548                                          push    ax              ;
 17549                                          push    cx              ;
 17550                                          push    si              ;
 17551                                          push    di              ; always do "common" blocks
 17552                                          mov     di,szCommon
 17553                                          push    ds              ;
 17554                                          push    cs              ;
 17555                                          pop     ds              ;
 17556                                          call    comp_names      ;
 17557                                          pop     ds              ;
 17558                                          pop     di              ;
 17559                                          pop     si              ;
 17560                                          pop     cx              ;
 17561                                          pop     ax              ;
 17562                                          je	short copyblock_check
 17563                                          or      bx,bx           ; is there a block name to check?
 17564                                          jz	short copyblock_skip ; no
 17565                                          push    di              ;
 17566                                          mov     di,bx           ; check block against given block name
 17567                                          push    ds              ;
 17568                                          push    es              ;
 17569                                          pop     ds              ;
 17570                                          call    comp_names      ; is this the block we really want to do?
 17571                                          pop     ds              ;
 17572                                          pop     di              ;
 17573                                  copyblock_check:
 17574                                          jc	short move_config ; hit eof
 17575                                          jne	short copyblock_skip  ;
 17576                                          call    skip_opt_line   ;
 17577                                          jmp	short copyblock_loop 
 17578                                  
 17579                                  copyblock_skip:                 ;
 17580                                          call    skip_opt_line   ; this ain't the block we wanted, so skip it
 17581                                          call    get_char        ;
 17582                                          jc	short move_config ; hit eof
 17583                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 17584                                          cmp     al,CONFIG_BEGIN ;
 17585                                          je	short copyblock_begin
 17586                                          jmp     short copyblock_skip ; anything else is just skipped
 17587                                  ;
 17588                                  ;   To create as little risk to the rest of SysInit as little as possible,
 17589                                  ;   and to free the workspace at "config_wrkseg" for creating an environment,
 17590                                  ;   copy the new config.sys image to "confbot"
 17591                                  ;
 17592                                  move_config:
 17593                                          mov     cx,di           ; now copy workspace at DS:DI to "confbot"
 17594                                          push    cx              ;
 17595                                  ;
 17596                                  ;   But first, copy the CONFIG=<configuration><0> string to the workspace,
 17597                                  ;   since the configuration name only currently exists in the "confbot" area
 17598                                  ;
 17599                                   	;mov	cx,7
 17600                                  	mov     cx,szMenu-szBoot-1
 17601                                          mov     si,szBoot	; first copy the CONFIG= part
 17602                                          inc     di              ; skip a byte, in case absolutely nothing
 17603                                                                  ; was copied to the workspace, because we always
 17604                                                                  ; zero the first byte of the workspace (below)
 17605                                  copy_boot: 
 17606                                  	;lods    byte ptr cs:[si];
 17607                                          cs
 17608                                  	lodsb
 17609                                  	mov     [di],al         ;
 17610                                          inc     di              ;
 17611                                          loop    copy_boot       ;
 17612                                  
 17613                                          push    es              ; then copy the configuration name
 17614                                          mov     cx,128-7        ; put an upper limit on the name, to be safe
 17615                                          mov     si,[cs:offDefBlock]; ES:SI -> default block name
 17616                                          or      si,si           ; valid?
 17617                                          jnz	short l1	; yes
 17618                                          push    cs              ;
 17619                                          pop     es              ;
 17620                                          mov     si,szCommon
 17621                                  l1:     mov     al,[es:si]      ;
 17622                                          call    any_delim       ;
 17623                                          je	short l2	;
 17624                                          mov     [di],al         ;
 17625                                          inc     si              ;
 17626                                          inc     di              ;
 17627                                          loop    l1              ;
 17628                                  l2:     mov     byte [di],lf	; terminate the configuration string
 17629                                          pop     es              ;
 17630                                  
 17631                                  ;   Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
 17632                                  
 17633                                          sub     di,di           ;
 17634                                          mov     [cs:config_envlen],di
 17635                                          sub     si,si           ;
 17636                                          pop     cx              ; recover the size of "config_wrkseg"
 17637                                  
 17638                                          push    cx              ;
 17639                                          rep     movsb           ; moved!
 17640                                          pop     cx              ;
 17641                                          mov     ax,ds           ;
 17642                                          pop     ds              ;
 17643                                  
 17644                                  ;   Now that the config_wrkseg is available once again, we shall
 17645                                  ;   use it to create an environment. The first thing to go in will be
 17646                                  ;   the "CONFIG=configuration" thing. It is also important to zero
 17647                                  ;   the first byte of the workspace, so that copy_envvar knows the buffer
 17648                                  ;   is empty.
 17649                                  
 17650                                          push    es              ;
 17651                                          mov     es,ax           ;
 17652                                          inc     si              ; ES:SI -> "CONFIG=configuration"
 17653                                          mov     byte [es:0],0	;empty the environment block
 17654                                          call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
 17655                                          pop     es
 17656                                  
 17657                                  ;   Before returning, restore the default video page setting but do NOT
 17658                                  ;   do it using INT 10h's Set Active Page function, because if the menu was
 17659                                  ;   displayed on a different page, then it's because we don't want to see
 17660                                  ;   all the device driver/TSR goop (which goes to the default page)
 17661                                  
 17662                                  menu_done:
 17663                                          cmp     byte [bMenuPage],0
 17664                                          je	short menu_exit	;
 17665                                          push    es              ;
 17666                                          mov     ax,40h          ;
 17667                                          mov     es,ax           ;
 17668                                          mov     ax,[wCRTStart]  ;
 17669                                          mov     [es:004Eh],ax   ;
 17670                                          mov     al,[bCRTPage]   ;
 17671                                          mov     [es:0062h],al   ;
 17672                                          pop     es              ;
 17673                                  menu_exit:
 17674                                          mov     [count],cx      ; set new counts
 17675                                          mov     [org_count],cx  ;
 17676                                          sub     si,si           ; always return ES:SI pointing to config.sys
 17677                                          retn
 17678                                  
 17679                                  ;----------------------------------------------------------------------------
 17680                                  ;
 17681                                  ;   copy_envvar:  copy the envvar at ES:SI to "config_wrkseg"
 17682                                  ;
 17683                                  ;   INPUT
 17684                                  ;    ES:SI -> environment variable (in the form "var=string<cr/lf>")
 17685                                  ;
 17686                                  ;   OUTPUT
 17687                                  ;       config_envlen (ie, where to put next envvar) updated appropriately
 17688                                  ;       carry set if error (eg, missing =); clear otherwise
 17689                                  ;
 17690                                  ;   OTHER REGS USED
 17691                                  ;       None
 17692                                  ;
 17693                                  ;   NOTES
 17694                                  ;       None
 17695                                  ;
 17696                                  ;   HISTORY
 17697                                  ;       Created 29-Mar-1992 by JeffPar
 17698                                  ;
 17699                                  ;----------------------------------------------------------------------------
 17700                                  
 17701                                  copy_envvar:
 17702                                          push    cx              ;
 17703                                          push    si              ;
 17704                                          push    ds              ;
 17705                                          push    es              ;
 17706                                          push    es              ;
 17707                                          mov     es,[config_wrkseg] ; ES:DI to point to next available byte
 17708                                          pop     ds                 ; DS:SI to point to envvar
 17709                                  
 17710                                  ;   Have to calculate the length of the variable name (and if we hit
 17711                                  ;   the end of the line before we hit '=', then it's curtains for this
 17712                                  ;   config.sys line)
 17713                                  ;
 17714                                  ;   The check for NULL is important because copy_envvar is also used to copy
 17715                                  ;   the initial CONFIG= setting, which will have been zapped by a NULL if no
 17716                                  ;   menu block existed (in order to prevent the creation of an environment)
 17717                                  
 17718                                          sub     cx,cx           ;
 17719                                  copy_varlen:                    ;
 17720                                          lodsb                   ;
 17721                                          or      al,al           ; NULL?
 17722                                          stc                     ;
 17723                                          jz	short copy_envexit ; yes, abort
 17724                                          cmp     al,cr          ;
 17725                                          stc                     ;
 17726                                          je	short copy_envexit
 17727                                          cmp     al,lf          ;
 17728                                          stc                     ;
 17729                                          je	short copy_envexit
 17730                                          inc     cx              ;
 17731                                          cmp     al,'='          ;
 17732                                          jne	short copy_varlen
 17733                                          mov     al,0            ;
 17734                                          mov     ah,[si]         ; save char after '='
 17735                                          sub     si,cx           ; back up to given varname
 17736                                          dec     cx              ; CX == # of bytes in varname
 17737                                          sub     di,di           ; start looking for DS:SI at ES:0
 17738                                  copy_varsrch:
 17739                                          cmp     byte [es:di],al
 17740                                          je	short copy_envprep ; search failed, just copy var
 17741                                          mov     bx,di           ; ES:BX -> start of this varname
 17742                                          push    cx              ;
 17743                                          push    si              ;
 17744                                          repe    cmpsb           ;
 17745                                          pop     si              ;
 17746                                          pop     cx              ;
 17747                                          jne	short copy_varnext ; no match, skip to next varname
 17748                                          cmp     byte [es:di],'='
 17749                                          jne     short copy_varnext ; no match, there's more characters
 17750                                  
 17751                                  ;   Previous occurrence of variable has been found; determine the
 17752                                  ;   entire length and then destroy it
 17753                                  
 17754                                          mov     cx,-1           ;
 17755                                          repne   scasb           ; guaranteed to get null (since we put it there)
 17756                                          push    si              ;
 17757                                          mov     si,di           ;
 17758                                          mov     di,bx           ;
 17759                                          mov     cx,[cs:config_envlen]
 17760                                          sub     cx,si           ; destroy variable now
 17761                                  	;rep movs byte ptr es:[di],byte ptr es:[si]
 17762                                  	;;db 0F3h,26h,0A4h ; MSDOS 6.21 IO:SYS - SYSINIT:4724h
 17763                                  
 17764                                  	rep	; 0F3h
 17765                                  	es	; 26h
 17766                                  	movsb	; 0A4h
 17767                                  
 17768                                  	pop     si
 17769                                  copy_envprep:
 17770                                          cmp     ah,cr          ; if there is nothing after the '='
 17771                                          je	short copy_envdel ; then just exit with variable deleted
 17772                                          cmp     ah,lf           ;
 17773                                          je	short copy_envdel
 17774                                          jmp     short copy_envloop
 17775                                  
 17776                                  copy_varnext:                   ;
 17777                                          push    cx              ;
 17778                                          mov     cx,-1           ;
 17779                                          repne   scasb           ;
 17780                                          pop     cx              ;
 17781                                          jmp	short copy_varsrch
 17782                                  
 17783                                  copy_envloop:                   ;
 17784                                          lodsb                   ;
 17785                                          cmp     al,cr           ;
 17786                                          je	short copy_envdone
 17787                                          cmp     al,lf           ;
 17788                                          je	short copy_envdone
 17789                                          stosb                   ;
 17790                                          jmp     short copy_envloop
 17791                                  
 17792                                  copy_envdone:                   ;
 17793                                          sub     al,al           ; do SUB to clear carry as well
 17794                                          stosb                   ; always null-terminate these puppies
 17795                                  copy_envdel:                    ;
 17796                                          mov     [es:di],al      ; and stick another null to terminate the env.
 17797                                          mov     [cs:config_envlen],di
 17798                                  
 17799                                  copy_envexit:                   ;
 17800                                          pop     es              ;
 17801                                          pop     ds              ;
 17802                                          pop     si              ;
 17803                                          pop     cx              ;
 17804                                          retn
 17805                                  
 17806                                  ;----------------------------------------------------------------------------
 17807                                  ;
 17808                                  ;   copy_block:  copy the current block to the new config.sys workspace
 17809                                  ;
 17810                                  ;   INPUT
 17811                                  ;       CX == remaining bytes in "organized" config.sys memory image
 17812                                  ;    ES:SI -> remaining bytes in "organized" config.sys memory image
 17813                                  ;    DS:DI -> new config.sys workspace (equal in size to the original
 17814                                  ;             config.sys image) where the current block is to be copied
 17815                                  ;
 17816                                  ;   OUTPUT
 17817                                  ;       Same as above
 17818                                  ;       AL also equals the last character read from the organized image
 17819                                  ;
 17820                                  ;   OTHER REGS USED
 17821                                  ;       All
 17822                                  ;
 17823                                  ;   NOTES
 17824                                  ;       None
 17825                                  ;
 17826                                  ;   HISTORY
 17827                                  ;       Created 16-Mar-1992 by JeffPar
 17828                                  ;
 17829                                  ;----------------------------------------------------------------------------
 17830                                  
 17831                                  copy_block:
 17832                                          call    get_char        ; check for include
 17833                                          jc	short copy_done	;
 17834                                  	and     al,~CONFIG_OPTION_QUERY ; 7Fh
 17835                                  	cmp     al,CONFIG_BEGIN ; another BEGIN implies END as well
 17836                                          je	short copy_done ;
 17837                                  
 17838                                          cmp     al,CONFIG_INCLUDE ; 'J'
 17839                                          mov     al,ah           ; AL == the original line code
 17840                                          jne	short copy_line	; not an "include" line
 17841                                  
 17842                                  ;   We have hit an "INCLUDE" line; first, REM out the line so that we
 17843                                  ;   never try to include the block again (no infinite include loops please),
 17844                                  ;   then search for the named block and call copy_block again.
 17845                                  
 17846                                          mov     byte [es:si-1],CONFIG_REM ; '0'
 17847                                          push    di              ;
 17848                                  
 17849                                          mov     di,szMenu
 17850                                          call    comp_names_safe ; don't allow INCLUDE MENU
 17851                                          je	short copy_skip	;
 17852                                  
 17853                                          mov     di,szCommon
 17854                                          call    comp_names_safe ; don't allow INCLUDE COMMON
 17855                                          je	short copy_skip	;
 17856                                  
 17857                                          mov     di,si           ; try to find the block
 17858                                          call    srch_block      ;
 17859                                          mov     dx,di           ;
 17860                                          pop     di              ;
 17861                                          jne	short copy_error ; no such block
 17862                                          push    cx              ;
 17863                                          mov     cx,bx           ;
 17864                                          push    si              ;
 17865                                          dec     dx              ;
 17866                                          mov     si,dx           ;
 17867                                          call    skip_line       ; skip the rest of the "block name" line
 17868                                          call    copy_block      ; and copy in the rest of that block
 17869                                          pop     si              ;
 17870                                          pop     cx              ;
 17871                                          sub     al,al           ; force skip_opt_line to skip...
 17872                                          jmp     short copy_nextline
 17873                                  
 17874                                  copy_skip:
 17875                                          pop     di
 17876                                  copy_error:
 17877                                          clc                     ;
 17878                                          call    print_error     ; note that carry is clear, no pause
 17879                                          jmp     short copy_nextline
 17880                                  
 17881                                  ;   Copy the line at ES:SI to the current location at DS:DI
 17882                                  
 17883                                  copy_line:
 17884                                          mov     [di],al         ;
 17885                                          inc     di              ;
 17886                                          cmp     al,' '          ; is this is a "real" line with a "real" code?
 17887                                          jb	short copy_nextline ; no
 17888                                          cmp     byte [cs:config_multi],0
 17889                                          je	short copy_loop	; not a multi-config config.sys, don't embed #s
 17890                                          call    get_linenum	; BX == line # of line @ES:SI
 17891                                          mov     [di],bx         ; stash it immediately following the line code
 17892                                          inc     di              ;
 17893                                          inc     di              ;
 17894                                          jmp     short copy_next ;
 17895                                  copy_loop:                      ;
 17896                                          call    get_char        ;
 17897                                          jc	short copy_done ; end of file
 17898                                          mov     [di],al         ;
 17899                                          inc     di              ;
 17900                                  copy_next:
 17901                                          cmp     al,lf ; 0Ah	; done with line?
 17902                                          jne	short copy_loop	; nope
 17903                                  
 17904                                  copy_nextline:
 17905                                          call    skip_opt_line   ;
 17906                                          jmp     short copy_block ;
 17907                                  copy_done:
 17908                                          retn
 17909                                  
 17910                                  ;----------------------------------------------------------------------------
 17911                                  ;
 17912                                  ;   get_linenum:  return line # (in BX) of current line (@ES:SI)
 17913                                  ;
 17914                                  ;   INPUT
 17915                                  ;    ES:SI -> some line in the config.sys memory image
 17916                                  ;
 17917                                  ;   OUTPUT
 17918                                  ;       BX == line # (relative to 1)
 17919                                  ;
 17920                                  ;   OTHER REGS USED
 17921                                  ;       DX
 17922                                  ;
 17923                                  ;   NOTES
 17924                                  ;       None
 17925                                  ;
 17926                                  ;   HISTORY
 17927                                  ;       Created 16-Mar-1992 by JeffPar
 17928                                  ;
 17929                                  ;----------------------------------------------------------------------------
 17930                                  
 17931                                  get_linenum:
 17932                                          push    ax              ;
 17933                                          sub     bx,bx           ; BX == line # (to be returned)
 17934                                          push    cx              ;
 17935                                          mov     dx,si           ; DX == the offset we're looking for
 17936                                          push    si              ;
 17937                                          mov     cx,[cs:count]   ;
 17938                                          sub     si,si           ; prepare to scan entire file
 17939                                  get_linenum_loop:               ;
 17940                                          call    skip_line       ;
 17941                                          jc	short get_linenum_done
 17942                                          inc     bx              ;
 17943                                          cmp     si,dx           ; have we exceeded the desired offset yet?
 17944                                          jb	short get_linenum_loop ; no
 17945                                  get_linenum_done:               ;
 17946                                          pop     si              ;
 17947                                          pop     cx              ;
 17948                                          pop     ax              ;
 17949                                          retn
 17950                                  
 17951                                  ;----------------------------------------------------------------------------
 17952                                  ;
 17953                                  ;   srch_block:  searches entire config.sys for block name @ES:DI
 17954                                  ;
 17955                                  ;   INPUT
 17956                                  ;       ES -> config.sys image
 17957                                  ;    ES:DI -> block name to find
 17958                                  ;
 17959                                  ;   OUTPUT
 17960                                  ;       ZF flag set, if found
 17961                                  ;    ES:DI -> just past the name in the block heading, if found
 17962                                  ;       BX == # bytes remaining from that point, if found
 17963                                  ;
 17964                                  ;   OTHER REGS USED
 17965                                  ;       None
 17966                                  ;
 17967                                  ;   NOTES
 17968                                  ;       This differs from "find_block" in that it searches the ENTIRE
 17969                                  ;       config.sys image, not merely the remaining portion, and that it
 17970                                  ;       takes a pointer to block name that is *elsewhere* in the image
 17971                                  ;       (ie, ES) as opposed to some string constant in our own segment (DS).
 17972                                  ;
 17973                                  ;   HISTORY
 17974                                  ;       Created 16-Mar-1992 by JeffPar
 17975                                  ;
 17976                                  ;----------------------------------------------------------------------------
 17977                                  
 17978                                  srch_block:	          ; returns BX -> named block in CONFIG.SYS
 17979                                          push    ax              ;
 17980                                          push    cx              ;
 17981                                          mov     cx,[cs:count]   ;
 17982                                          push    si              ;
 17983                                          sub     si,si           ;
 17984                                          push    ds              ;
 17985                                          push    es              ;
 17986                                          pop     ds              ;
 17987                                          call    find_block      ;
 17988                                          mov     di,si           ;
 17989                                          mov     bx,cx           ;
 17990                                          pop     ds              ;
 17991                                          pop     si              ;
 17992                                          pop     cx              ;
 17993                                          pop     ax              ;
 17994                                  find_exit: ; 16/04/2019
 17995                                          retn			;
 17996                                  
 17997                                  ;----------------------------------------------------------------------------
 17998                                  ;
 17999                                  ;   find_block:  searches rest of config.sys for block name @DS:DI
 18000                                  ;
 18001                                  ;   INPUT
 18002                                  ;    DS:DI -> block name to find
 18003                                  ;    ES:SI -> remainder of config.sys image
 18004                                  ;       CX == remaining size of config.sys image
 18005                                  ;
 18006                                  ;   OUTPUT
 18007                                  ;       ZF flag set, if found (also, CF set if EOF)
 18008                                  ;    ES:SI -> where the search stopped (at end of block name or EOF)
 18009                                  ;       CX == # bytes remaining from that point
 18010                                  ;
 18011                                  ;   OTHER REGS USED
 18012                                  ;       AX
 18013                                  ;
 18014                                  ;   NOTES
 18015                                  ;       This differs from "srch_block" in that it searches only the
 18016                                  ;       remaining portion of the config.sys image and leaves SI and CX
 18017                                  ;       pointing to where the search left off, and that it takes a pointer
 18018                                  ;       to search string in our own segment (DS:DI instead of ES:DI).
 18019                                  ;
 18020                                  ;   HISTORY
 18021                                  ;       Created 16-Mar-1992 by JeffPar
 18022                                  ;
 18023                                  ;----------------------------------------------------------------------------
 18024                                  
 18025                                  find_block:
 18026                                          call    get_char        ; get line code
 18027                                          jc	short find_exit	; end of file
 18028                                          and     al,~CONFIG_OPTION_QUERY
 18029                                          cmp     al,CONFIG_BEGIN ; beginning of a block?
 18030                                          je	short check_line ; no
 18031                                          cmp     al,CONFIG_INCLUDE
 18032                                          jne	short next_line	;
 18033                                          or	byte [cs:config_multi],1
 18034                                          jmp     short next_line ;
 18035                                  check_line:
 18036                                          or      byte [cs:config_multi],1
 18037                                          call    comp_names      ; compare block names
 18038                                          jbe	short find_exit	; end of file, or names matched
 18039                                  next_line:
 18040                                          call    skip_opt_line   ; no, so skip to next line
 18041                                          jmp	short find_block  ;
 18042                                  ;find_exit:
 18043                                  ;	retn
 18044                                  
 18045                                  ;----------------------------------------------------------------------------
 18046                                  ;
 18047                                  ;   comp_names:  compares keyword @DS:DI to position in config.sys @ES:SI
 18048                                  ;
 18049                                  ;   INPUT
 18050                                  ;    DS:DI -> keyword to compare
 18051                                  ;    ES:SI -> position in config.sys
 18052                                  ;       CX == remaining bytes in config.sys
 18053                                  ;
 18054                                  ;   OUTPUT
 18055                                  ;       ZF flag set, if match (also, CF set if EOF)
 18056                                  ;    ES:SI -> where the comparison stopped (at end of block name or EOF)
 18057                                  ;       CX == # bytes remaining from that point
 18058                                  ;
 18059                                  ;   OTHER REGS USED
 18060                                  ;       AX
 18061                                  ;
 18062                                  ;   NOTES
 18063                                  ;       None
 18064                                  ;
 18065                                  ;   HISTORY
 18066                                  ;       Created 16-Mar-1992 by JeffPar
 18067                                  ;
 18068                                  ;----------------------------------------------------------------------------
 18069                                  
 18070                                  comp_names:
 18071                                          push    di              ;
 18072                                  comp_loop:                      ;
 18073                                          call    get_char        ;
 18074                                          jc	short comp_exit	;
 18075                                          call    any_delim       ; is next character a delimiter?
 18076                                          mov     ah,[di]         ; (get next character we're supposed to match)
 18077                                          je	short comp_almost ; yes, it *could* be a match
 18078                                          inc     di              ;
 18079                                          and     ax,~2020h ; 0DFDFh 
 18080                                  				; BUGBUG -- assumes both names are alphanumeric -JTP
 18081                                          cmp     al,ah           ; match?
 18082                                          je	short comp_loop ; yes, keep looking at the characters
 18083                                          clc                     ; prevent erroneous eof indication: clear carry
 18084                                  comp_exit:                      ;
 18085                                          pop     di              ;
 18086                                          retn			;
 18087                                  comp_almost:                    ;
 18088                                          xchg    al,ah           ; we don't know for sure if it's a match
 18089                                          call    any_delim       ; until we verify that the second string has
 18090                                          xchg    al,ah           ; been exhausted also...
 18091                                          jmp     comp_exit       ; if we are, this call to any_delim will tell...
 18092                                  
 18093                                  ;----------------------------------------------------------------------------
 18094                                  
 18095                                  comp_names_safe:
 18096                                          push    ax
 18097                                          push    cx
 18098                                          push	si
 18099                                          push    ds
 18100                                          push    cs
 18101                                          pop     ds
 18102                                          call    comp_names
 18103                                          pop     ds
 18104                                  	pop	si
 18105                                          pop     cx
 18106                                          pop     ax
 18107                                          retn
 18108                                  
 18109                                  ;----------------------------------------------------------------------------
 18110                                  ;
 18111                                  ;   print_item:  display menu item #BL
 18112                                  ;
 18113                                  ;   INPUT
 18114                                  ;       BL == menu item # to display
 18115                                  ;
 18116                                  ;   OUTPUT
 18117                                  ;       Menu item displayed, with appropriate highlighting if BL == bDefBlock
 18118                                  ;
 18119                                  ;   OTHER REGS USED
 18120                                  ;       None
 18121                                  ;
 18122                                  ;   NOTES
 18123                                  ;       This function saves/restores the current cursor position, so you
 18124                                  ;       needn't worry about it.
 18125                                  ;
 18126                                  ;   HISTORY
 18127                                  ;       Created 16-Mar-1992 by JeffPar
 18128                                  ;
 18129                                  ;----------------------------------------------------------------------------
 18130                                  
 18131                                  print_item:		; prints menu item #BL (1 to N)
 18132                                          push    ax              ;
 18133                                          push    bx              ;
 18134                                          push    cx              ;
 18135                                          push    dx              ;
 18136                                          push    si              ;
 18137                                          mov     ah,03h          ; get cursor position
 18138                                          mov     bh,[bMenuPage]  ; always page zero
 18139                                          int     10h             ; DH/DL = row/column
 18140                                          push    dx              ; save it
 18141                                          mov     ah,02h          ; set cursor position
 18142                                          mov     dh,bl           ;
 18143                                          add     dh,3            ;
 18144                                          mov     dl,5            ;
 18145                                          int     10h             ; set cursor position for correct row/col
 18146                                          mov     al,bl           ;
 18147                                          add     al,'0'          ; convert menu item # to ASCII digit
 18148                                          mov     ah,[bMenuColor] ; normal attribute
 18149                                          cmp     bl,[bDefBlock]  ; are we printing the current block?
 18150                                          jne	short print_other ; no
 18151                                          or      ah,70h          ; yes, set bgnd color to white
 18152                                          mov     ch,ah           ;
 18153                                          mov     cl,4            ;
 18154                                          rol     ch,cl           ;
 18155                                          cmp     ch,ah           ; are fgnd/bgnd the same?
 18156                                          jne	short print_other ; no
 18157                                          xor     ah,08h          ; yes, so modify the fgnd intensity
 18158                                  print_other:                    ;
 18159                                          mov     bh,0            ;
 18160                                          add     bx,bx           ;
 18161                                          mov     di,[aoffBlockDesc+bx]
 18162                                          mov     bl,ah           ; put the attribute in the correct register now
 18163                                          mov     bh,[bMenuPage]  ; get correct video page #
 18164                                          mov     ah,09h          ; write char/attr
 18165                                          mov     cx,1            ;
 18166                                          int     10h             ;
 18167                                          inc     dl              ; increment column
 18168                                          mov     ah,02h          ;
 18169                                          int     10h             ;
 18170                                          ;mov	ax,0900h+'.'    ;
 18171                                          mov	ax,092Eh
 18172                                  	int     10h             ; display '.'
 18173                                          inc     dl              ; increment column
 18174                                          mov     ah,02h          ;
 18175                                          int     10h             ;
 18176                                          ;mov	ax,0900h+' '    ;
 18177                                          mov	ax,0920h
 18178                                  	int     10h             ; display ' '
 18179                                          inc     dl              ; increment column
 18180                                          mov     ah,02h          ;
 18181                                          int     10h             ;
 18182                                          push    es              ;
 18183                                  print_loop:                     ;
 18184                                          mov     al,[es:di]	; get a character of the description
 18185                                          inc     di              ;
 18186                                          cmp     al,TAB ; 9	; substitute spaces for tabs
 18187                                          jne	short print_nontab ;
 18188                                          mov     al,' '          ;
 18189                                  print_nontab:                   ;
 18190                                          cmp     al,' '          ;
 18191                                          jb	short print_done ; stop at the 1st character < space
 18192                                          cmp     al,'$'          ;
 18193                                          je	short print_done ; also stop on $
 18194                                          mov     ah,09h          ; display function #
 18195                                          int     10h             ;
 18196                                          inc     dl              ; increment column
 18197                                          cmp     dl,78           ; far enough?
 18198                                          jae	short print_done ; yes
 18199                                          mov     ah,02h          ;
 18200                                          int     10h             ;
 18201                                          jmp     print_loop      ;
 18202                                  print_done:                     ;
 18203                                          pop     es              ;
 18204                                          pop     dx              ;
 18205                                          mov     ah,02h          ;
 18206                                          int     10h             ; restore previous row/col
 18207                                          pop     si              ;
 18208                                          pop     dx              ;
 18209                                          pop     cx              ;
 18210                                          pop     bx              ;
 18211                                          pop     ax              ;
 18212                                          retn			;
 18213                                  
 18214                                  ;----------------------------------------------------------------------------
 18215                                  ;
 18216                                  ;   select_item:  wait for user to select menu item, with time-out
 18217                                  ;
 18218                                  ;   INPUT
 18219                                  ;       None
 18220                                  ;
 18221                                  ;   OUTPUT
 18222                                  ;       BX == menu item # (1-N), or -1 for clean boot
 18223                                  ;       Selected menu item highlighted
 18224                                  ;       Cursor positioned beneath menu, ready for tty-style output now
 18225                                  ;
 18226                                  ;   OTHER REGS USED
 18227                                  ;       None
 18228                                  ;
 18229                                  ;   NOTES
 18230                                  ;       None
 18231                                  ;
 18232                                  ;   HISTORY
 18233                                  ;       Created 16-Mar-1992 by JeffPar
 18234                                  ;
 18235                                  ;----------------------------------------------------------------------------
 18236                                  
 18237                                  select_item:		; returns digit value in BX (trashes AX/CX/DX)
 18238                                          mov     bl,[bDefBlock]  ; BL will be the default block #
 18239                                          mov     al,bl           ;
 18240                                          call    disp_num        ;
 18241                                          call    show_status     ; display current interactive status
 18242                                          cmp     byte [secTimeOut],-1
 18243                                          je	short input_key	; no time-out, just go to input
 18244                                          mov     ah,GET_TIME ; 2Ch
 18245                                          int     21h             ;
 18246                                          mov     bh,dh           ; BH = initial # of seconds
 18247                                  check_time:
 18248                                          mov     al,[secTimeOut] ;
 18249                                          sub     al,[secElapsed] ;
 18250                                          jae	short show_time	;
 18251                                          or      byte [bQueryOpt],2  ; disable all further prompting
 18252                                          mov     byte [secElapsed],0
 18253                                          jmp	select_done	; time's up!
 18254                                  show_time:
 18255                                          push    bx              ;
 18256                                          mov     bl,al           ; save # in BL
 18257                                          mov     bh,[bMenuPage]  ;
 18258                                          mov     ah,03h          ; get cursor position
 18259                                          int     10h             ;
 18260                                          push    dx              ;
 18261                                  	add	dl,8		; move cursor to the right
 18262                                          mov     ah,02h          ; set cursor position
 18263                                          int     10h             ;
 18264                                          mov     dx,_$TimeOut
 18265                                          call    print           ; print the "Time remaining: " prompt
 18266                                          mov     al,bl           ; recover # from BL
 18267                                          cbw                     ; this works because AL is always <= 90
 18268                                          mov     cl,10           ;
 18269                                          div     cl              ; AL = tens digit, AH = ones digit
 18270                                          mov     cl,ah           ;
 18271                                          add     al,'0'          ;
 18272                                          mov     ah,0Eh          ;
 18273                                          int     10h             ; write TTY tens digit
 18274                                          mov     al,cl           ;
 18275                                          add     al,'0'          ;
 18276                                          mov     ah,0Eh          ;
 18277                                          int     10h             ; write TTY ones digit
 18278                                          pop     dx
 18279                                          mov     ah,02h          ; set cursor position back to where it was
 18280                                          int     10h             ;
 18281                                          pop     bx              ;
 18282                                  input_key:
 18283                                          mov     ah,RAW_CON_IO ; 6
 18284                                          mov     dl,0FFh         ; input request
 18285                                          int     21h             ;
 18286                                          jnz	short got_key	;
 18287                                          cmp     byte [secTimeOut],-1; is there a time-out?
 18288                                          je	short input_key	; no, just go back to input
 18289                                          mov     ah,GET_TIME     ;
 18290                                          int     21h             ; DH = seconds
 18291                                          mov     ah,dh           ;
 18292                                          sub     dh,bh           ; should generally be zero or one
 18293                                          mov     bh,ah           ;
 18294                                          jnc	short got_time	;
 18295                                          mov     dh,1            ; it wrapped back to zero, so assume one
 18296                                  got_time:
 18297                                          or      dh,dh           ; any change?
 18298                                          jz	short input_key	; no
 18299                                          add     [secElapsed],dh ;
 18300                                          jmp	short check_time ;
 18301                                  got_key:
 18302                                          push    ax              ;
 18303                                          mov     ax,-1           ; zap both secTimeOut and secElapsed
 18304                                          xchg    [secTimeOut],ax
 18305                                          cmp     al,-1           ; was time-out already disabled?
 18306                                          je	short timeout_disabled ; yes
 18307                                          push    bx              ; let's disable # seconds display
 18308                                          mov     ax,0A20h        ; write multiple spaces
 18309                                          mov     bx,[bMenuColor]
 18310                                          mov     cx,80           ; 80 of them, to be safe
 18311                                          int     10h             ; to completely obliterate # seconds display
 18312                                          pop     bx   		;
 18313                                  
 18314                                  timeout_disabled:
 18315                                          pop     ax              ;
 18316                                          or      al,al           ; extended key pressed?
 18317                                          jnz	short normal_key ; no
 18318                                          int     21h             ; get the next part of the key then
 18319                                          jz	short input_key	; hmmm, what happened to the second part?
 18320                                  
 18321                                          cmp     al,48h          ; up arrow?
 18322                                          jne	short not_up	; no
 18323                                          cmp     bl,1            ; are we as up as up can get?
 18324                                          jbe	short input_key	; yes, ignore it
 18325                                          dec     byte [bDefBlock] ;
 18326                                          call    print_item      ; re-print the current item
 18327                                          dec     bl              ; and then print the new current item
 18328                                          jmp     short print1
 18329                                  not_up:
 18330                                          cmp     al,50h          ; down arrow?
 18331                                          jne	short not_down	; no
 18332                                          cmp     bl,[bMaxBlock]  ; are we as down as down can get?
 18333                                          jae	short to_input_key ; yes, ignore it
 18334                                          inc     byte [bDefBlock] ;
 18335                                          call    print_item      ; re-print the current item
 18336                                          inc     bx              ; and then print the new current item
 18337                                  print1: 
 18338                                  	mov     al,bl           ;
 18339                                  print2: 
 18340                                  	call    print_item      ;
 18341                                          call    disp_num        ;
 18342                                  to_input_key:
 18343                                          jmp     input_key       ;
 18344                                  not_down:
 18345                                          test    byte [bDisableUI],1
 18346                                          jnz	short to_input_key ; don't allow F8 or F5
 18347                                          cmp     al,42h          ; F8 function key?
 18348                                          jne	short not_f8	; no
 18349                                          xor     byte [bQueryOpt],1
 18350                                          call    show_status     ;
 18351                                          jmp     input_key	;
 18352                                  not_f8:
 18353                                          cmp     al,3Fh          ; F5 function key?
 18354                                          jne	short to_input_key ; no
 18355                                          mov     bx,-1           ; special return code (-1) indicating clean boot
 18356                                          mov     al,' '          ; don't want to display anything really;
 18357                                          jmp     short disp_input; just want to display the cr/lf sequence...
 18358                                  
 18359                                  normal_key:
 18360                                          cmp     al,0Dh          ; Enter?
 18361                                          je	short select_done ; yes
 18362                                          cmp     al,08h          ; backspace?
 18363                                          jne	short not_backspace ; no
 18364                                          mov     bx,-2 ; 0FFFEh	; yes, special return code
 18365                                          retn			;
 18366                                  not_backspace:
 18367                                          sub     al,'0'          ; is greater than '0'?
 18368                                          jbe	short to_input_key ; no
 18369                                          cmp     al,[bMaxBlock]  ; is less than or equal to the maximum digit?
 18370                                          ja	short to_input_key ; no
 18371                                          mov	[bDefBlock],al  ;
 18372                                          call    print_item      ; redisplay the current selection
 18373                                          mov     bl,al           ; set new selection
 18374                                          jmp	short print2
 18375                                  
 18376                                  select_done:
 18377                                          mov     bh,0            ; return a full 16-bit value (for indexing)
 18378                                          mov     al,bl           ;
 18379                                          add     al,'0'          ; convert it into a digit, then display it
 18380                                  
 18381                                  	; fall into disp_input
 18382                                  
 18383                                  ; 16/04/2019 - Retro DOS v4.0
 18384                                  
 18385                                  ;----------------------------------------------------------------------------
 18386                                  ;
 18387                                  ;   disp_input:  display a single character + cr/lf
 18388                                  ;
 18389                                  ;   INPUT
 18390                                  ;       AL == character to display
 18391                                  ;
 18392                                  ;   OUTPUT
 18393                                  ;       None
 18394                                  ;
 18395                                  ;   OTHER REGS USED
 18396                                  ;       None
 18397                                  ;
 18398                                  ;   NOTES
 18399                                  ;       This function is used not only for the menu input selection but
 18400                                  ;       also for the interactive line prompting (the y/n/a thing).
 18401                                  ;
 18402                                  ;   HISTORY
 18403                                  ;       Created 16-Mar-1992 by JeffPar
 18404                                  ;
 18405                                  ;----------------------------------------------------------------------------
 18406                                  
 18407                                  disp_input:
 18408                                          push    ax
 18409                                          cmp     al,' '
 18410                                          jae	short disp_ok
 18411                                          mov     al,' '
 18412                                  disp_ok:
 18413                                          mov     dl,al
 18414                                          mov     ah,STD_CON_OUTPUT ; 2
 18415                                          int     21h
 18416                                          mov     dx,crlfm
 18417                                          call    print
 18418                                          pop     ax
 18419                                          retn
 18420                                  
 18421                                  ;----------------------------------------------------------------------------
 18422                                  
 18423                                  disp_num:
 18424                                          push    bx
 18425                                          add     al,'0'
 18426                                          mov     ah,0Ah
 18427                                          mov     bx,[bMenuColor]
 18428                                          mov     cx,1
 18429                                          int     10h
 18430                                          pop     bx
 18431                                          retn
 18432                                  
 18433                                  ;----------------------------------------------------------------------------
 18434                                  ;
 18435                                  ;   show_status:  display current interactive mode setting (on/off/none)
 18436                                  ;
 18437                                  ;   INPUT
 18438                                  ;       None
 18439                                  ;
 18440                                  ;   OUTPUT
 18441                                  ;       None
 18442                                  ;
 18443                                  ;   OTHER REGS USED
 18444                                  ;       None
 18445                                  ;
 18446                                  ;   NOTES
 18447                                  ;       None
 18448                                  ;
 18449                                  ;   HISTORY
 18450                                  ;       Created 16-Mar-1992 by JeffPar
 18451                                  ;
 18452                                  ;----------------------------------------------------------------------------
 18453                                  
 18454                                  show_status:
 18455                                          push    bx              ; BL = video page #
 18456                                          mov     bx,[bMenuColor]
 18457                                          mov     ah,03h          ; get cursor position
 18458                                          int     10h             ;
 18459                                          push    dx              ; save it
 18460                                          mov     ah,02h          ; set cursor position
 18461                                          mov     dx,[bLastCol]   ; set correct row/col
 18462                                          test    byte [bDisableUI],1
 18463                                          jz	short show_onoff ; just show on/off
 18464                                          mov     dl,0            ;
 18465                                          int     10h             ;
 18466                                          mov     ax,0A20h        ; write multiple spaces
 18467                                          mov     cx,80           ; 80 of them, to be exact
 18468                                          int     10h             ; to obliterate the status line
 18469                                          jmp     short show_done ;
 18470                                  show_onoff: 
 18471                                          int     10h
 18472                                  		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
 18473                                  		; AL = character, BH = display page - alpha mode
 18474                                  		; BL = color of character (graphics mode, PCjr only)
 18475                                  		; CX = number of times to write character
 18476                                  
 18477                                          mov     al,[_$NO]	; assume OFF
 18478                                          cmp     byte [bQueryOpt],1 ; is interactive mode on?
 18479                                          jne	short show_noton ; no
 18480                                          mov     al,[_$YES]	; yes
 18481                                  show_noton:                     ;
 18482                                          mov     ah,0Eh          ; write TTY
 18483                                          int     10h             ;
 18484                                  show_done:                      ;
 18485                                          pop     dx              ;
 18486                                          mov     ah,02h          ;
 18487                                          int     10h             ; restore original cursor position
 18488                                          pop     bx              ;
 18489                                          retn			;
 18490                                  
 18491                                  ; 16/04/2019 - Retro DOS v4.0
 18492                                  
 18493                                  ;----------------------------------------------------------------------------
 18494                                  ;
 18495                                  ;   skip_token: advances ES:SI/CX past the current token
 18496                                  ;
 18497                                  ;   INPUT
 18498                                  ;    ES:SI -> position in config.sys
 18499                                  ;       CX == remaining bytes in config.sys
 18500                                  ;
 18501                                  ;   OUTPUT
 18502                                  ;       CF set if EOL/EOF hit
 18503                                  ;       AL == 1st char of delimiter
 18504                                  ;    ES:SI -> just past the delimiter
 18505                                  ;       CX == # bytes remaining from that point
 18506                                  ;
 18507                                  ;   OTHER REGS USED
 18508                                  ;       AX
 18509                                  ;
 18510                                  ;   NOTES
 18511                                  ;       None
 18512                                  ;
 18513                                  ;   HISTORY
 18514                                  ;       Created 16-Mar-1992 by JeffPar
 18515                                  ;
 18516                                  ;----------------------------------------------------------------------------
 18517                                  
 18518                                  skip_token:
 18519                                          call    get_char
 18520                                          jc	short skip_token_done
 18521                                          call    any_delim
 18522                                          jne	short skip_token
 18523                                  skip_check_eol:
 18524                                          cmp     al,cr ; 0Dh
 18525                                          je	short skip_token_eol
 18526                                          cmp     al,lf ; 0Ah
 18527                                          je	short skip_token_eol
 18528                                          clc
 18529                                          ;jmp	short skip_token_done
 18530                                  	retn
 18531                                  skip_token_eol:
 18532                                          stc
 18533                                  skip_token_done:
 18534                                          retn
 18535                                  
 18536                                  ;----------------------------------------------------------------------------
 18537                                  ;
 18538                                  ;   skip_delim: advances ES:SI/CX past the current delimiter
 18539                                  ;
 18540                                  ;   INPUT
 18541                                  ;    ES:SI -> position in config.sys
 18542                                  ;       CX == remaining bytes in config.sys
 18543                                  ;
 18544                                  ;   OUTPUT
 18545                                  ;       CF set if EOF hit
 18546                                  ;       AL == 1st char of token
 18547                                  ;    ES:SI -> just past the token
 18548                                  ;       CX == # bytes remaining from that point
 18549                                  ;    ES:BX -> new token (since ES:SI is already pointing 1 byte past token)
 18550                                  ;
 18551                                  ;   OTHER REGS USED
 18552                                  ;       AX
 18553                                  ;
 18554                                  ;   NOTES
 18555                                  ;       None
 18556                                  ;
 18557                                  ;   HISTORY
 18558                                  ;       Created 16-Mar-1992 by JeffPar
 18559                                  ;
 18560                                  ;----------------------------------------------------------------------------
 18561                                  
 18562                                  skip_delim:       ; returns carry set if eol/eof
 18563                                          call    get_char        ;
 18564                                          lea     bx,[si-1]       ; also returns BX -> next token
 18565                                          jc	short skip_token_done ;
 18566                                          call    delim           ;
 18567                                          je	short skip_delim ;
 18568                                          jmp	short skip_check_eol  ; 13/05/2019
 18569                                  
 18570                                  ;----------------------------------------------------------------------------
 18571                                  ;
 18572                                  ;   skip_opt_line: same as skip_line provided AL != LF
 18573                                  ;
 18574                                  ;   INPUT
 18575                                  ;       AL == last character read
 18576                                  ;    ES:SI -> position in config.sys
 18577                                  ;       CX == remaining bytes in config.sys
 18578                                  ;
 18579                                  ;   OUTPUT
 18580                                  ;       CF set if EOF hit
 18581                                  ;       AL == 1st char of new line
 18582                                  ;    ES:SI -> just past 1st char of new line
 18583                                  ;       CX == # bytes remaining from that point
 18584                                  ;
 18585                                  ;   OTHER REGS USED
 18586                                  ;       AX
 18587                                  ;
 18588                                  ;   NOTES
 18589                                  ;       In other words, the purpose here is to skip to the next line,
 18590                                  ;       unless ES:SI is already sitting at the front of the next line (which
 18591                                  ;       it would be if the last character fetched -- AL -- was a linefeed)
 18592                                  ;
 18593                                  ;   HISTORY
 18594                                  ;       Created 16-Mar-1992 by JeffPar
 18595                                  ;
 18596                                  ;----------------------------------------------------------------------------
 18597                                  
 18598                                  skip_opt_line:
 18599                                          cmp     al,lf ; 0Ah
 18600                                          je	short skip_line_done
 18601                                       
 18602                                  	; fall into skip_line
 18603                                  
 18604                                  ;----------------------------------------------------------------------------
 18605                                  ;
 18606                                  ;   skip_line: skip to the next line
 18607                                  ;
 18608                                  ;   INPUT
 18609                                  ;    ES:SI -> position in config.sys
 18610                                  ;       CX == remaining bytes in config.sys
 18611                                  ;
 18612                                  ;   OUTPUT
 18613                                  ;       CF set if EOF hit
 18614                                  ;    ES:SI -> just past 1st char of new line
 18615                                  ;       CX == # bytes remaining from that point
 18616                                  ;
 18617                                  ;   OTHER REGS USED
 18618                                  ;       AX
 18619                                  ;
 18620                                  ;   NOTES
 18621                                  ;       None
 18622                                  ;
 18623                                  ;   HISTORY
 18624                                  ;       Created 16-Mar-1992 by JeffPar
 18625                                  ;
 18626                                  ;----------------------------------------------------------------------------
 18627                                  
 18628                                  skip_line:
 18629                                          call    get_char
 18630                                          jc	short skip_line_done
 18631                                          cmp     al,lf ; 0Ah
 18632                                          jne	short skip_line
 18633                                  skip_line_done:
 18634                                          retn
 18635                                  
 18636                                  ;----------------------------------------------------------------------------
 18637                                  ;
 18638                                  ;   get_number: return binary equivalent of numeric string
 18639                                  ;
 18640                                  ;   INPUT
 18641                                  ;    ES:SI -> position in config.sys
 18642                                  ;       CX == remaining bytes in config.sys
 18643                                  ;
 18644                                  ;   OUTPUT
 18645                                  ;       AL == non-digit encountered
 18646                                  ;       BX == binary #
 18647                                  ;    ES:SI -> just past 1st non-digit
 18648                                  ;       CX == # bytes remaining from that point
 18649                                  ;
 18650                                  ;   OTHER REGS USED
 18651                                  ;       AX
 18652                                  ;
 18653                                  ;   NOTES
 18654                                  ;       None
 18655                                  ;
 18656                                  ;   HISTORY
 18657                                  ;       Created 16-Mar-1992 by JeffPar
 18658                                  ;
 18659                                  ;----------------------------------------------------------------------------
 18660                                  
 18661                                  ; 13/05/2019
 18662                                  
 18663                                  get_number:
 18664                                          sub     bx,bx           ; BX = result
 18665                                  num_loop:
 18666                                          call    get_char        ;
 18667                                          jc	short num_done	;
 18668                                          cmp     al,'0'          ; convert to value
 18669                                          jb	short num_done	; no more number
 18670                                          cmp     al,'9'          ;
 18671                                          ja	short num_done	;
 18672                                          push    ax              ;
 18673                                          mov     ax,10           ;
 18674                                          push    dx              ;
 18675                                          mul     bx              ;
 18676                                          pop     dx              ;
 18677                                          mov     bx,ax           ;
 18678                                          pop     ax              ;
 18679                                          sub     al,'0'          ;
 18680                                          cbw                     ;
 18681                                          add     bx,ax           ;
 18682                                          jmp	short num_loop	;
 18683                                  num_done:
 18684                                          retn
 18685                                  
 18686                                  ;----------------------------------------------------------------------------
 18687                                  ;
 18688                                  ;   get_char:  return next character, advance ES:SI, and decrement CX
 18689                                  ;
 18690                                  ;   INPUT
 18691                                  ;    ES:SI -> position in config.sys
 18692                                  ;       CX == remaining bytes in config.sys
 18693                                  ;
 18694                                  ;   OUTPUT
 18695                                  ;       AL == next character
 18696                                  ;    ES:SI -> just past next character
 18697                                  ;       CX == # bytes remaining from that point
 18698                                  ;
 18699                                  ;   OTHER REGS USED
 18700                                  ;       AX
 18701                                  ;
 18702                                  ;   NOTES
 18703                                  ;       None
 18704                                  ;
 18705                                  ;   HISTORY
 18706                                  ;       Created 16-Mar-1992 by JeffPar
 18707                                  ;
 18708                                  ;----------------------------------------------------------------------------
 18709                                  
 18710                                  get_char:
 18711                                          sub     cx,1            ; use SUB to set carry,zero
 18712                                          jb	short get_fail	; out of data
 18713                                          ;lods	byte ptrf es:[si] ;
 18714                                  	es	
 18715                                  	lodsb
 18716                                          mov     ah,al           ;
 18717                                          retn			;
 18718                                  get_fail:                       ; restore CX to zero
 18719                                          mov     cx,0            ; leave carry set, zero not set
 18720                                  nearby_ret:
 18721                                          retn
 18722                                  
 18723                                  ;----------------------------------------------------------------------------
 18724                                  ;
 18725                                  ;   query_user: ask user whether to execute current config.sys command
 18726                                  ;
 18727                                  ;   INPUT
 18728                                  ;       AL == current command code
 18729                                  ;    ES:SI -> current command line in config.sys
 18730                                  ;    config_cmd == current command code, but with QUERY bit intact
 18731                                  ;                  (00h used to generate "Process AUTOEXEC.BAT" prompt)
 18732                                  ;
 18733                                  ;   OUTPUT
 18734                                  ;       CF set if command should be ignored (it is also REM'ed out)
 18735                                  ;
 18736                                  ;   OTHER REGS USED
 18737                                  ;       BX, CX, DX, DI
 18738                                  ;
 18739                                  ;   NOTES
 18740                                  ;       None
 18741                                  ;
 18742                                  ;   HISTORY
 18743                                  ;       Created 16-Mar-1992 by JeffPar
 18744                                  ;
 18745                                  ;----------------------------------------------------------------------------
 18746                                  
 18747                                  query_user:
 18748                                          test    byte  [bQueryOpt],4	; answer no to everything?
 18749                                          jz	short qu_1		;
 18750                                          jmp	skip_all		;
 18751                                  qu_1:
 18752                                  	test    byte [bQueryOpt],2	; answer yes to everything?
 18753                                          jnz	short nearby_ret	; yes (and return carry clear!)
 18754                                          push    ax                      ;
 18755                                          mov     al,[config_cmd]         ;
 18756                                          test    byte [bQueryOpt],1	; query every command?
 18757                                          jnz	short query_all		; yes
 18758                                          test    al,CONFIG_OPTION_QUERY  ;
 18759                                          jnz	short query_all		;
 18760                                          jmp	do_cmd			;
 18761                                  query_all:
 18762                                  
 18763                                  ;   Search for the command code (AL) in "comtab", and then print
 18764                                  ;   out the corresponding keyword, followed by the rest of the actual
 18765                                  ;   line pointed to by ES:SI
 18766                                  
 18767                                          push    si                      ; save pointer to rest of CONFIG.SYS line
 18768                                          mov     dx,_$AutoPrmpt    	;
 18769                                          and     al,~CONFIG_OPTION_QUERY ; 7Fh
 18770                                          jz	short generic_prompt	; config_cmd must have been 0
 18771                                  
 18772                                          mov     dh,al                   ; save config_cmd in DH
 18773                                          sub     bx,bx                   ;
 18774                                          mov     di,comtab		;
 18775                                  find_match:                             ;
 18776                                          mov     bl,[di]                 ; get size of current keyword
 18777                                          or      bl,bl                   ;
 18778                                          jz	short line_print	; end of table
 18779                                          inc     di                      ;
 18780                                          cmp     al,[di+bx]              ; match?
 18781                                          je	short cmd_match		; yes
 18782                                          lea     di,[di+bx+1]            ; otherwise, skip this command code
 18783                                  	; 13/05/2019	
 18784                                          jmp	short find_match	; loop
 18785                                  cmd_match:                              ;
 18786                                          mov     cl,[di-1]               ;
 18787                                          mov     ch,0                    ;
 18788                                          mov     ah,STD_CON_OUTPUT ; 2
 18789                                  cmd_print:                              ;
 18790                                          mov     al,[di]                 ;
 18791                                          inc     di                      ;
 18792                                          mov     dl,al                   ;
 18793                                          int     21h                     ;
 18794                                          loop    cmd_print               ;
 18795                                          mov     dl,'='                  ;
 18796                                          cmp     dh,CONFIG_SET  ; 'V'    ; for SET commands, don't display a '='
 18797                                          jne	short cmd_notset	;
 18798                                          mov     dl,' '                  ;
 18799                                  cmd_notset:
 18800                                          int     21h                     ; '=' looks funny on SET commands
 18801                                  line_print:                             ;
 18802                                  	;lods	byte ptr es:[si]        ;
 18803                                          es
 18804                                  	lodsb
 18805                                  	or      al,al                   ;
 18806                                          jnz	short non_null		;
 18807                                          mov     al,' '                  ;
 18808                                  non_null:                               ;
 18809                                          cmp     al,' '                  ; control code?
 18810                                          jb	short prompt_user	; yes, assume end of line
 18811                                          jne	short non_space		;
 18812                                          cmp     byte [es:si],' '	;
 18813                                          jb	short prompt_user	;
 18814                                  non_space:                              ;
 18815                                          mov     dl,al                   ;
 18816                                          mov     ah,STD_CON_OUTPUT ; 2	;
 18817                                          int     21h                     ;
 18818                                          jmp	short line_print	;
 18819                                  prompt_user:                            ;
 18820                                          mov     dx,_$InterPrmpt		;
 18821                                  
 18822                                  generic_prompt:
 18823                                          call    print                   ;
 18824                                  input_loop:                             ;
 18825                                          mov     ah,0                    ; read a key
 18826                                          int     16h                     ;
 18827                                          or      al,al                   ; is it a function key?
 18828                                          jnz	short not_func		; no
 18829                                          cmp     ah,3Fh                  ; F5 function key?
 18830                                          jne	short input_loop	; no
 18831                                          mov     al,[_$NO]                  ;
 18832                                          or      byte [bQueryOpt],4	; no more queries
 18833                                          jmp     short legal_char        ;
 18834                                  not_func:
 18835                                          and     al,~20h ; 0DFh		; converting to upper case
 18836                                          cmp     al,[_$NO]		; verify character is legal
 18837                                          je	short legal_char	;
 18838                                          cmp     al,[_$YES]		;
 18839                                          je	short legal_char	;
 18840                                          cmp     byte [config_cmd],0	;
 18841                                          je	short input_loop	; don't allow Esc on this query
 18842                                          cmp     al,1Bh                  ; Esc?
 18843                                          jne	short input_loop	;
 18844                                          or      byte [bQueryOpt],2	; no more interactive boot prompts
 18845                                          mov     al,[_$YES]
 18846                                  legal_char:                             ;
 18847                                          call    disp_input              ;
 18848                                          pop     si                      ; restore pointer to rest of CONFIG.SYS line
 18849                                  
 18850                                          cmp     al,[_$NO]		; process line?
 18851                                          je	short skip_cmd		; no
 18852                                  do_cmd:
 18853                                          pop     ax                      ;
 18854                                          clc                             ; just do the command
 18855                                          retn
 18856                                  
 18857                                  skip_cmd:
 18858                                          pop     ax                      ;
 18859                                  skip_all:
 18860                                          mov     ah,CONFIG_REM ; '0'	; fake out the rest of sysinit's processing
 18861                                          stc
 18862                                          retn
 18863                                  
 18864                                  ;----------------------------------------------------------------------------
 18865                                  ;
 18866                                  ;   print_error: displays multi-config error conditions
 18867                                  ;
 18868                                  ;   INPUT
 18869                                  ;    Carry set to pause, clear to not
 18870                                  ;    ES:SI -> current command line in config.sys
 18871                                  ;
 18872                                  ;   OUTPUT
 18873                                  ;       None
 18874                                  ;
 18875                                  ;   OTHER REGS USED
 18876                                  ;       None
 18877                                  ;
 18878                                  ;   NOTES
 18879                                  ;       None
 18880                                  ;
 18881                                  ;   HISTORY
 18882                                  ;       Created 16-Mar-1992 by JeffPar
 18883                                  ;
 18884                                  ;----------------------------------------------------------------------------
 18885                                  
 18886                                  print_error:
 18887                                          push    ax
 18888                                          push    bx
 18889                                          push    cx
 18890                                          push    dx
 18891                                          push    ds
 18892                                          push    cs
 18893                                          pop     ds
 18894                                          pushf
 18895                                          call    get_linenum
 18896                                          mov     [linecount],bx
 18897                                          call    error_line
 18898                                          popf
 18899                                          jnc	short pe_ret
 18900                                          mov     dx,_$PauseMsg
 18901                                          call    print
 18902                                          mov     ax,0C07h		; flush input buffer, then wait for key
 18903                                          int     21h			; wait for a key
 18904                                          or      al,al			; extended key?
 18905                                          jnz	short pe_1		; no
 18906                                          mov     ah,07h			; yes
 18907                                          int     21h			; eat it too
 18908                                  pe_1:     
 18909                                  	mov     dx,crlfm
 18910                                          call    print
 18911                                  pe_ret: 
 18912                                  	pop     ds
 18913                                          pop     dx
 18914                                          pop     cx
 18915                                          pop     bx
 18916                                          pop     ax
 18917                                  	retn
 18918                                  
 18919                                  ;----------------------------------------------------------------------------
 18920                                  
 18921                                  ;   This function is very simple:  it merely prepends a "/D" to the
 18922                                  ;   command-line for the shell;  this (undocumented) switch disables
 18923                                  ;   AUTOEXEC.BAT processing and the date/time prompt that is usually
 18924                                  ;   displayed when there's no AUTOEXEC.BAT.
 18925                                  
 18926                                  disable_autoexec:
 18927                                  	; MSDOS 6.21 IO.SYS -  SYSINIT:4BE2h
 18928                                  	; 17/04/2019 - Retro DOS v4.0
 18929                                  
 18930                                  	test	byte [bQueryOpt],4
 18931                                  	jz	short disable_exit
 18932                                  	test	byte [dae_flag],1
 18933                                  	jnz	short disable_exit
 18934                                  	or	byte [dae_flag],1
 18935                                          ;or	byte [bQueryOpt],2 ; MSDOS 6.0 
 18936                                  	or      word [bQueryOpt],102h	; [bDefBlock] = 1
 18937                                  	mov     dx,'D ' ; 2044h
 18938                                  dae_1:
 18939                                          ;mov	al,[def_swchr]
 18940                                  	mov     al,[command_line-1]     ; get default switchchar
 18941                                          or      al,al                   ; anything there?
 18942                                          jz	short disable_exit	; no, disable_autoexec already called
 18943                                          mov     bl,[command_line]       ;
 18944                                          mov     bh,0                    ; BX == command-line length
 18945                                          mov     cx,bx                   ;
 18946                                          add     bl,3                    ;
 18947                                          cmp     bl,126                  ;
 18948                                          ja	short disable_exit	;
 18949                                          mov     [command_line],bl       ; update length
 18950                                          add     bx,command_line+1	; make sure we move the NULL too
 18951                                          inc     cx                      ; (just for consistency sake)
 18952                                  disable_loop:                           ;
 18953                                          mov     ah,[bx-3]               ;
 18954                                          mov     [bx],ah                 ;
 18955                                          dec     bx                      ;
 18956                                          loop    disable_loop            ;
 18957                                          mov     [bx-2],al               ;
 18958                                  	;mov	word [bx-1],'D ' ; 2044h ; /D is stuffed into place now
 18959                                  	mov	[bx-1],dx  ; MSDOS 6.21 IO.SYS - SYSINIT:4C29h		
 18960                                          ;mov	byte [command_line-1],0 ;
 18961                                  disable_exit:                           ;
 18962                                          retn
 18963                                  
 18964                                  CheckQueryOpt:	; MSDOS 6.21 IO.YSYS - SYSINIT:4C2Dh
 18965                                  	cmp     byte [bQueryOpt],1
 18966                                  	jnz     short disable_exit
 18967                                  	test	byte [dae_flag],2
 18968                                  	jnz     short disable_exit
 18969                                  	or      byte [dae_flag],2
 18970                                  	mov     dx,' Y'
 18971                                  	jmp     short dae_1
 18972                                  
 18973                                  ;endif  ;MULTI_CONFIG
 18974                                  
 18975                                  %endif	; 02/11/2022
 18976                                  
 18977                                  
 18978                                  ; 19/04/2019 - Retro DOS v4.0
 18979                                  
 18980                                  ;----------------------------------------------------------------------------
 18981                                  ;
 18982                                  ; procedure : delim
 18983                                  ;
 18984                                  ;----------------------------------------------------------------------------
 18985                                  
 18986                                  ;	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 18987                                  ;
 18988                                  ;;ifdef	MULTI_CONFIG
 18989                                  ;
 18990                                  ;any_delim:
 18991                                  ;       cmp     al,cr
 18992                                  ;       je	short delim_ret
 18993                                  ;       cmp     al,lf
 18994                                  ;       je	short delim_ret
 18995                                  ;       cmp     al,'['
 18996                                  ;       je	short delim_ret
 18997                                  ;       cmp     al,']'
 18998                                  ;       je	short delim_ret
 18999                                  ;
 19000                                  ;;endif  ;MULTI_CONFIG
 19001                                  
 19002                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 19003                                  	; (SYSINIT:3450h)	
 19004                                  delim:
 19005 00003450 3C2F                    	cmp	al,'/'		; ibm will assume "/" as an delimeter.
 19006 00003452 7416                    	je	short delim_ret
 19007                                  
 19008 00003454 3C00                    	cmp	al,0		; special case for sysinit!!!
 19009 00003456 7412                    	je	short delim_ret
 19010                                  
 19011                                  org_delim:			; used by organize routine except for getting
 19012 00003458 3C20                    	cmp	al,' '          ; the filename.
 19013 0000345A 740E                    	je	short delim_ret
 19014 0000345C 3C09                            cmp     al,tab ; 9
 19015 0000345E 740A                    	je	short delim_ret
 19016 00003460 3C3D                    	cmp	al,'='
 19017 00003462 7406                    	je	short delim_ret
 19018 00003464 3C2C                    	cmp	al,','
 19019 00003466 7402                    	je	short delim_ret
 19020 00003468 3C3B                    	cmp	al,';'
 19021                                  
 19022                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19023                                  ;;ifdef	MULTI_CONFIG
 19024                                  ;;   Make sure there's no chance of a false EOF indication
 19025                                  ;	clc
 19026                                  ;;endif
 19027                                  
 19028                                  	; 02/11/2022
 19029                                  delim_ret:
 19030 0000346A C3                      	retn
 19031                                  
 19032                                  ;----------------------------------------------------------------------------
 19033                                  ;
 19034                                  ; procedure : newline
 19035                                  ;
 19036                                  ;  newline returns with first character of next line
 19037                                  ;
 19038                                  ;----------------------------------------------------------------------------
 19039                                  
 19040                                  newline:
 19041 0000346B E8E6F5                  	call	getchr			;skip non-control characters
 19042 0000346E 7207                    	jc	short nl_ret
 19043 00003470 3C0A                    	cmp	al,lf			;look for line feed
 19044 00003472 75F7                    	jne	short newline
 19045 00003474 E8DDF5                  	call	getchr
 19046                                  nl_ret:
 19047 00003477 C3                      	retn
 19048                                  
 19049                                  ;----------------------------------------------------------------------------
 19050                                  ; 
 19051                                  ; procedure : mapcase
 19052                                  ;
 19053                                  ;----------------------------------------------------------------------------
 19054                                  
 19055                                  	; 02/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
 19056                                  mapcase:
 19057 00003478 51                      	push	cx
 19058 00003479 56                      	push	si
 19059 0000347A 1E                      	push	ds
 19060                                  
 19061 0000347B 06                      	push	es
 19062 0000347C 1F                      	pop	ds
 19063                                  
 19064                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19065                                  ;;ifdef	MULTI_CONFIG
 19066                                  ;
 19067                                  ;	mov	bl,al                   ; same cmd code this line
 19068                                  ;;else
 19069                                  ;;	xor	si,si
 19070                                  ;;endif
 19071                                  	; 02/11/2022
 19072 0000347D 31F6                    	xor	si, si
 19073                                  
 19074                                  convloop:
 19075 0000347F AC                      	lodsb
 19076 00003480 3C61                    	cmp	al,'a'
 19077 00003482 7209                    	jb	short noconv
 19078 00003484 3C7A                    	cmp	al,'z'
 19079 00003486 7705                    	ja	short noconv
 19080 00003488 2C20                    	sub	al,20h
 19081 0000348A 8844FF                  	mov	[si-1],al
 19082                                  noconv:
 19083                                  
 19084                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19085                                  ;;ifdef	MULTI_CONFIG
 19086                                  ;;
 19087                                  ;;   When MULTI_CONFIG enabled, "mapcase" is used to map everything to
 19088                                  ;;   upper-case a line at a time, after we've been able to figure out whether
 19089                                  ;;   the line is a SET command or not (since we don't want to upper-case
 19090                                  ;;   anything after the "=" in a SET)
 19091                                  ;;
 19092                                  ;       cmp     bl,CONFIG_SET  ; 'V'	; preserve case for part of the line?
 19093                                  ;       jne	short check_eol		; no, just check for end-of-line
 19094                                  ;       cmp     al,'='                  ; separator between SET var and value?
 19095                                  ;       je	short convdone		; yes
 19096                                  ;check_eol:
 19097                                  ;       cmp     al,cr
 19098                                  ;       je	short convdone
 19099                                  ;       cmp     al,lf
 19100                                  ;       je	short convdone
 19101                                  ;;endif
 19102                                  	
 19103                                  	; 02/11/2022
 19104 0000348D E2F0                    	loop	convloop
 19105                                  convdone:
 19106 0000348F 1F                      	pop	ds
 19107 00003490 5E                      	pop	si
 19108 00003491 59                      	pop	cx
 19109 00003492 C3                      	retn
 19110                                  
 19111                                  ;----------------------------------------------------------------------------
 19112                                  ;
 19113                                  ; procedure : round
 19114                                  ;
 19115                                  ; round the values in memlo and memhi to paragraph boundary.
 19116                                  ; perform bounds check.
 19117                                  ;
 19118                                  ;----------------------------------------------------------------------------
 19119                                  
 19120                                  round:
 19121 00003493 50                      	push	ax
 19122 00003494 2EA1[DE03]              	mov	ax,[cs:memlo]
 19123                                  
 19124 00003498 E8B5DC                  	call	ParaRound		; para round up
 19125                                  
 19126 0000349B 2E0106[E003]            	add	[cs:memhi],ax
 19127 000034A0 2EC706[DE03]0000        	mov	word [cs:memlo],0
 19128 000034A7 2EA1[E003]              	mov	ax,[cs:memhi]		; ax = new memhi
 19129 000034AB 2E3B06[A302]            	cmp	ax,[cs:ALLOCLIM]	; if new memhi >= alloclim, error
 19130 000034B0 7323                    	jae	short mem_err
 19131 000034B2 2EF606[5A16]02          	test	byte [cs:setdevmarkflag],for_devmark ; 2
 19132 000034B8 7418                    	jz	short skip_set_devmarksize
 19133 000034BA 06                      	push	es
 19134 000034BB 56                      	push	si
 19135 000034BC 2E8B36[5816]            	mov	si,[cs:devmark_addr]
 19136 000034C1 8EC6                    	mov	es,si
 19137 000034C3 29F0                    	sub	ax,si
 19138 000034C5 48                      	dec	ax
 19139                                  	;mov	[es:3],ax
 19140 000034C6 26A30300                	mov	[es:devmark.size],ax	; paragraph
 19141 000034CA 2E8026[5A16]FD          	and	byte [cs:setdevmarkflag],not_for_devmark ; 0FDh
 19142 000034D0 5E                      	pop	si
 19143 000034D1 07                      	pop	es
 19144                                  skip_set_devmarksize:
 19145 000034D2 58                      	pop	ax
 19146                                  	; 02/11/2022
 19147 000034D3 F8                      	clc	; ? (not needed here)	; clear carry
 19148 000034D4 C3                      	retn
 19149                                  
 19150                                  ;----------------------------------------------------------------------------
 19151                                  
 19152                                  mem_err:
 19153 000034D5 BA[413C]                	mov	dx,badmem
 19154 000034D8 0E                      	push	cs
 19155 000034D9 1F                      	pop	ds
 19156 000034DA E88202                  	call	print
 19157 000034DD E9B9D3                  	jmp	stall
 19158                                  
 19159                                  ;----------------------------------------------------------------------------
 19160                                  ;
 19161                                  ; procedure : calldev
 19162                                  ;
 19163                                  ;----------------------------------------------------------------------------
 19164                                  
 19165                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 19166                                  	; (SYSINIT:34E0h)
 19167                                  calldev:
 19168 000034E0 2E8E1E[3321]            	mov	ds,[cs:DevEntry+2]
 19169 000034E5 2E031E[3121]            	add	bx,[cs:DevEntry]	; do a little relocation
 19170 000034EA 8B07                    	mov	ax,[bx]
 19171                                  
 19172 000034EC 2EFF36[3121]            	push	word [cs:DevEntry]
 19173 000034F1 2EA3[3121]              	mov	word [cs:DevEntry],ax
 19174 000034F5 BB[E603]                	mov	bx,packet
 19175 000034F8 2EFF1E[3121]            	call	far [cs:DevEntry]
 19176 000034FD 2E8F06[3121]            	pop	word [cs:DevEntry]
 19177 00003502 C3                      	retn
 19178                                  
 19179                                  ;----------------------------------------------------------------------------
 19180                                  ;
 19181                                  ; procedure : todigit
 19182                                  ;
 19183                                  ;----------------------------------------------------------------------------
 19184                                  
 19185                                  todigit:
 19186 00003503 2C30                    	sub	al,'0'
 19187 00003505 7206                    	jb	short notdig
 19188                                  	;jb	short notdig2 ; 02/11/2022
 19189 00003507 3C09                    	cmp	al,9
 19190 00003509 7702                    	ja	short notdig
 19191 0000350B F8                      	clc
 19192 0000350C C3                      	retn
 19193                                  notdig:
 19194 0000350D F9                      	stc
 19195                                  ;notdig2:
 19196 0000350E C3                      	retn
 19197                                  
 19198                                  ;----------------------------------------------------------------------------
 19199                                  ;
 19200                                  ; procedure : getnum
 19201                                  ;
 19202                                  ; getnum parses a decimal number.
 19203                                  ; returns it in ax, sets zero flag if ax = 0 (may be considered an
 19204                                  ; error), if number is bad carry is set, zero is set, ax=0.
 19205                                  ;
 19206                                  ;----------------------------------------------------------------------------
 19207                                  
 19208                                  getnum:
 19209 0000350F 53                      	push	bx
 19210 00003510 31DB                    	xor	bx,bx			; running count is zero
 19211                                  b2:
 19212 00003512 E8EEFF                  	call	todigit 		; do we have a digit ?
 19213 00003515 724A                    	jc	short badnum		; no, bomb
 19214                                  
 19215 00003517 93                      	xchg	ax,bx			; put total in ax
 19216 00003518 53                      	push	bx			; save digit (0 to 9)
 19217 00003519 BB0A00                  	mov	bx,10			; base of arithmetic
 19218 0000351C F7E3                    	mul	bx			; shift by one decimal digit
 19219 0000351E 5B                      	pop	bx			; get back digit (0 to 9)
 19220 0000351F 00D8                    	add	al,bl			; get total
 19221 00003521 80D400                  	adc	ah,0			; make that 16 bits
 19222 00003524 723B                    	jc	short badnum		; too big a number
 19223                                  
 19224 00003526 93                      	xchg	ax,bx			; stash total
 19225                                  
 19226 00003527 E82AF5                  	call	getchr			;get next digit
 19227 0000352A 722F                    	jc	short b1		; no more characters
 19228 0000352C 3C20                    	cmp	al,' ' 			; space?
 19229 0000352E 7421                    	je	short b15		; then end of digits
 19230 00003530 3C2C                    	cmp	al,',' 			; ',' is a seperator!!!
 19231 00003532 741D                    	je	short b15		; then end of digits.
 19232 00003534 3C09                    	cmp	al, tab ; 9		; tab
 19233 00003536 7419                    	je	short b15
 19234 00003538 2E3A06[2A03]            	cmp	al,[cs:sepchr]		; allow 0 or special separators
 19235 0000353D 7412                    	je	short b15
 19236 0000353F 3C2F                    	cmp	al,'/'			; see if another switch follows
 19237                                  	;nop				; cas - remnant of old bad code
 19238                                  	;nop
 19239                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19240 00003541 90                      	nop
 19241 00003542 90                      	nop
 19242 00003543 740C                    	je	short b15
 19243 00003545 3C0A                    	cmp	al,lf			; line-feed?
 19244 00003547 7408                    	je	short b15
 19245 00003549 3C0D                    	cmp	al,cr			; carriage return?
 19246 0000354B 7404                    	je	short b15
 19247 0000354D 08C0                    	or	al,al			; end of line separator?
 19248 0000354F 75C1                    	jnz	short b2		; no, try as a valid char...
 19249                                  b15:
 19250 00003551 2EFF06[D203]            	inc	word [cs:count]		; one more character to s...
 19251 00003556 2EFF0E[D603]            	dec	word [cs:chrptr]	; back up over separator
 19252                                  b1:
 19253 0000355B 89D8                    	mov	ax,bx			; get proper count
 19254 0000355D 09C0                    	or	ax,ax			; clears carry, sets zero accordingly
 19255 0000355F 5B                      	pop	bx
 19256 00003560 C3                      	retn
 19257                                  badnum:
 19258                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19259 00003561 2EC606[2A03]00          	mov	byte [cs:sepchr],0
 19260 00003567 31C0                    	xor	ax,ax			; set zero flag, and ax = 0
 19261                                  	;mov	[cs:sepchr],al ; 0
 19262 00003569 5B                      	pop	bx
 19263 0000356A F9                      	stc				; and carry set
 19264 0000356B C3                      	retn
 19265                                  
 19266                                  ;****************************************************************************
 19267                                  
 19268                                  setdoscountryinfo:
 19269                                  
 19270                                  ;----------------------------------------------------------------------------
 19271                                  ;input: es:di -> pointer to dos_country_cdpg_info
 19272                                  ;	ds:0  -> buffer.
 19273                                  ;	si = 0
 19274                                  ;	ax = country id
 19275                                  ;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
 19276                                  ;	bx = file handle
 19277                                  ;	this routine can handle maximum 438 country_data entries.
 19278                                  ;
 19279                                  ;output: dos_country_cdpg_info set.
 19280                                  ;	 carry set if any file read failure or wrong information in the file.
 19281                                  ;	 carry set and cx = -1 if cannot find the matching country_id, 
 19282                                  ;	 codepage_id in the file.
 19283                                  ;----------------------------------------------------------------------------
 19284                                  
 19285 0000356C 57                      	push	di
 19286 0000356D 50                      	push	ax
 19287 0000356E 52                      	push	dx
 19288                                  
 19289 0000356F 31C9                    	xor	cx,cx
 19290 00003571 31D2                    	xor	dx,dx
 19291 00003573 B80002                  	mov	ax,512			;read 512 bytes
 19292 00003576 E85001                  	call	readincontrolbuffer	;read the file header
 19293 00003579 724D                    	jc	short setdosdata_fail
 19294                                  
 19295 0000357B 06                      	push	es
 19296 0000357C 56                      	push	si
 19297                                  
 19298 0000357D 0E                      	push	cs
 19299 0000357E 07                      	pop	es
 19300                                  
 19301 0000357F BF[6338]                	mov	di,country_file_signature ; db 0FFh,'COUNTRY'
 19302 00003582 B90800                  	mov	cx,8			;length of the signature
 19303 00003585 F3A6                    	repz	cmpsb
 19304                                  
 19305 00003587 5E                      	pop	si
 19306 00003588 07                      	pop	es
 19307 00003589 753D                    	jnz	short setdosdata_fail 	;signature mismatch
 19308                                  
 19309 0000358B 83C612                  	add	si,18			;si -> county info type
 19310 0000358E 803C01                  	cmp	byte [si],1		;only accept type 1 (currently only 1 header type)
 19311 00003591 7535                    	jne	short setdosdata_fail 	;cannot proceed. error return
 19312                                  
 19313 00003593 46                      	inc	si			;si -> file offset
 19314 00003594 8B14                    	mov	dx,[si]			;get the info file offset.
 19315 00003596 8B4C02                  	mov	cx,[si+2]
 19316 00003599 B80018                  	mov	ax,6144			;read 6144 bytes.
 19317 0000359C E82A01                  	call	readincontrolbuffer	;read info
 19318 0000359F 7227                    	jc	short setdosdata_fail
 19319                                  
 19320 000035A1 8B0C                    	mov	cx,[si]			;get the # of country, codepage combination entries
 19321 000035A3 81F9B601                	cmp	cx, 438			;cannot handle more than 438 entries.
 19322 000035A7 771F                    	ja	short setdosdata_fail
 19323                                  
 19324 000035A9 46                      	inc	si
 19325 000035AA 46                      	inc	si			;si -> entry information packet
 19326 000035AB 5A                      	pop	dx			;restore code page id
 19327 000035AC 58                      	pop	ax			;restore country id
 19328 000035AD 5F                      	pop	di
 19329                                  
 19330                                  setdoscntry_find:			;search for desired country_id,codepage_id.
 19331 000035AE 3B4402                  	cmp	ax,[si+2]		;compare country_id
 19332 000035B1 750A                    	jne	short setdoscntry_next
 19333                                  
 19334 000035B3 83FA00                  	cmp	dx,0			;no user specified code page ?
 19335 000035B6 7415                    	je	short setdoscntry_any_codepage ;then no need to match code page id.
 19336 000035B8 3B5404                  	cmp	dx,[si+4]		;compare code page id
 19337 000035BB 7413                    	je	short setdoscntry_got_it
 19338                                  
 19339                                  setdoscntry_next:
 19340 000035BD 0334                    	add	si,[si]			;next entry
 19341 000035BF 46                      	inc	si
 19342 000035C0 46                      	inc	si			;take a word for size of entry itself
 19343 000035C1 E2EB                    	loop	setdoscntry_find
 19344                                  
 19345 000035C3 B9FFFF                  	mov	cx,-1			;signals that bad country id entered.
 19346                                  setdoscntry_fail:
 19347 000035C6 F9                      	stc
 19348 000035C7 C3                      	retn
 19349                                  
 19350                                  setdosdata_fail:
 19351 000035C8 5E                      	pop	si
 19352 000035C9 59                      	pop	cx
 19353 000035CA 5F                      	pop	di
 19354 000035CB EBF9                    	jmp	short setdoscntry_fail
 19355                                  
 19356                                  setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
 19357 000035CD 8B5404                  	mov	dx,[si+4]
 19358                                  
 19359                                  setdoscntry_got_it:			;found the matching entry
 19360 000035D0 2E8916[6B38]            	mov	[cs:cntrycodepage_id],dx ;save code page id for this country.
 19361 000035D5 8B540A                  	mov	dx,[si+10]		;get the file offset of country data
 19362 000035D8 8B4C0C                  	mov	cx,[si+12]
 19363 000035DB B80002                  	mov	ax,512 			;read 512 bytes
 19364 000035DE E8E800                  	call	readincontrolbuffer
 19365 000035E1 72E3                    	jc	short setdoscntry_fail
 19366                                  
 19367 000035E3 8B0C                    	mov	cx,[si]			;get the number of entries to handle.
 19368 000035E5 46                      	inc	si
 19369 000035E6 46                      	inc	si			;si -> first entry
 19370                                  
 19371                                  setdoscntry_data:
 19372 000035E7 57                      	push	di			;es:di -> dos_country_cdpg_info
 19373 000035E8 51                      	push	cx			;save # of entry left
 19374 000035E9 56                      	push	si			;si -> current entry in control buffer
 19375                                  
 19376 000035EA 8A4402                  	mov	al,[si+2]		;get data entry id
 19377 000035ED E8AB00                  	call	getcountrydestination	;get the address of destination in es:di
 19378 000035F0 727D                    	jc	short setdoscntry_data_next ;no matching data entry id in dos
 19379                                  
 19380 000035F2 8B5404                  	mov	dx,[si+4]		;get offset of data
 19381 000035F5 8B4C06                  	mov	cx,[si+6]
 19382 000035F8 B80042                  	mov	ax,4200h
 19383 000035FB F9                      	stc
 19384 000035FC CD21                    	int	21h			;move pointer
 19385 000035FE 72C8                    	jc	short setdosdata_fail
 19386                                  
 19387 00003600 BA0002                  	mov	dx,512			;start of data buffer
 19388 00003603 B91400                  	mov	cx,20			;read 20 bytes only. we only need to
 19389 00003606 B43F                    	mov	ah,3Fh			;look at the length of the data in the file.
 19390 00003608 F9                      	stc
 19391 00003609 CD21                    	int	21h			;read the country.sys data
 19392 0000360B 72BB                    	jc	short setdosdata_fail 	;read failure
 19393                                  
 19394 0000360D 39C8                    	cmp	ax,cx
 19395 0000360F 75B7                    	jne	short setdosdata_fail ; 13/05/2019
 19396                                  
 19397 00003611 8B5404                  	mov	dx,[si+4]		;get offset of data again.
 19398 00003614 8B4C06                  	mov	cx,[si+6]
 19399 00003617 B80042                  	mov	ax,4200h
 19400 0000361A F9                      	stc
 19401 0000361B CD21                    	int	21h			;move pointer back again
 19402 0000361D 72A9                    	jc	short setdosdata_fail
 19403                                  
 19404 0000361F 56                      	push	si
 19405 00003620 BE0802                  	mov	si,(512+8)		;get length of the data from the file
 19406 00003623 8B0C                    	mov	cx,[si]
 19407 00003625 5E                      	pop	si
 19408 00003626 BA0002                  	mov	dx,512			;start of data buffer
 19409 00003629 83C10A                  	add	cx,10			;signature + a word for the length itself
 19410 0000362C B43F                    	mov	ah,3Fh			;read the data from the file.
 19411 0000362E F9                      	stc
 19412 0000362F CD21                    	int	21h
 19413 00003631 7295                    	jc	short setdosdata_fail
 19414                                  
 19415 00003633 39C8                    	cmp	ax,cx
 19416 00003635 7591                    	jne	short setdosdata_fail
 19417                                  
 19418 00003637 8A4402                  	mov	al,[si+2]		;save data id for future use.
 19419 0000363A BE0802                  	mov	si,(512+8)		;si-> data buffer + id tag field
 19420 0000363D 8B0C                    	mov	cx,[si]			;get the length of the file
 19421 0000363F 41                      	inc	cx			;take care of a word for lenght of tab
 19422 00003640 41                      	inc	cx			;itself.
 19423 00003641 81F9F805                	cmp	cx,(2048-512-8)	; 1528	;fit into the buffer?
 19424 00003645 7781                    	ja	short setdosdata_fail
 19425                                  
 19426                                  	;if	bugfix
 19427 00003647 E83600                  	call	setdbcs_before_copy
 19428                                  	;endif
 19429                                  
 19430 0000364A 3C01                    	cmp	al,SetCountryInfo ; 1	;is the data for setcountryinfo table?
 19431 0000364C 7512                    	jne	short setdoscntry_mov 	;no, don't worry
 19432                                  
 19433 0000364E 26FF7518                	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]  
 19434                                  	;push	word [es:di+24]		;cannot destroy ccmono_ptr address. save them.
 19435 00003652 26FF751A                	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2] 
 19436                                  	;push	word [es:di+26]		;at this time di -> cccountryinfolen
 19437                                  	
 19438 00003656 57                      	push	di			;save di
 19439                                  
 19440 00003657 50                      	push	ax
 19441 00003658 2EA1[6B38]              	mov	ax,[cs:cntrycodepage_id] ;do not use the code page info in country_info
 19442 0000365C 894404                  	mov	[si+4],ax		;use the saved one for this !!!!
 19443 0000365F 58                      	pop	ax
 19444                                  
 19445                                  setdoscntry_mov:
 19446 00003660 F3A4                    	rep	movsb			;copy the table into dos
 19447 00003662 3C01                    	cmp	al,SetCountryInfo	;was the ccmono_ptr saved?
 19448 00003664 7509                    	jne	short setdoscntry_data_next
 19449                                  
 19450 00003666 5F                      	pop	di			;restore di
 19451 00003667 268F451A                	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
 19452                                  	;pop	word [es:di+26]		;restore
 19453 0000366B 268F4518                	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen] 
 19454                                  	;pop	word [es:di+24]
 19455                                  
 19456                                  setdoscntry_data_next:
 19457 0000366F 5E                      	pop	si			;restore control buffer pointer
 19458 00003670 59                      	pop	cx			;restore # of entries left
 19459 00003671 5F                      	pop	di			;restore pointer to dso_country_cdpg
 19460 00003672 0334                    	add	si,[si]			;try to get the next entry
 19461 00003674 46                      	inc	si
 19462 00003675 46                      	inc	si			;take a word of entry length itself
 19463 00003676 49                      	dec	cx
 19464 00003677 83F900                  	cmp	cx,0
 19465 0000367A 7403                    	je	short setdoscntry_ok
 19466 0000367C E968FF                  	jmp	setdoscntry_data
 19467                                  
 19468                                  setdoscntry_ok:
 19469 0000367F C3                      	retn
 19470                                  
 19471                                  ;----------------------------------------------------------------------------
 19472                                  
 19473                                  	;if	bugfix
 19474                                  
 19475                                  setdbcs_before_copy:
 19476 00003680 3C07                    	cmp	al,SetDBCS ; 7		; dbcs vector set?
 19477 00003682 7516                    	jne	short sdbcsbc		; jump if not
 19478 00003684 26833D00                	cmp	word [es:di],0		; zero byte data block?
 19479 00003688 7410                    	je	short sdbcsbc		; jump if so
 19480                                  
 19481 0000368A 57                      	push	di
 19482 0000368B 50                      	push	ax
 19483 0000368C 51                      	push	cx
 19484 0000368D 268B0D                  	mov	cx,[es:di]		; load block length
 19485 00003690 83C702                  	add	di,2			; points actual data
 19486 00003693 30C0                    	xor	al,al			; fill bytes
 19487 00003695 F3AA                    	rep	stosb			; clear data block
 19488 00003697 59                      	pop	cx
 19489 00003698 58                      	pop	ax
 19490 00003699 5F                      	pop	di
 19491                                  sdbcsbc:
 19492 0000369A C3                      	retn
 19493                                  
 19494                                  	;endif
 19495                                  
 19496                                  ;----------------------------------------------------------------------------
 19497                                  
 19498                                  getcountrydestination:
 19499                                  
 19500                                  ;get the destination address in the dos country info table.
 19501                                  ;input: al - data id
 19502                                  ;	es:di -> dos_country_cdpg_info
 19503                                  ;on return:
 19504                                  ;	es:di -> destination address of the matching data id
 19505                                  ;	carry set if no matching data id found in dos.
 19506                                  
 19507 0000369B 51                      	push	cx
 19508                                  	;add	di,74
 19509 0000369C 83C74A                  	add	di,country_cdpg_info.ccNumber_of_entries	
 19510                                  					;skip the reserved area, syscodepage etc.
 19511 0000369F 268B0D                  	mov	cx,[es:di]		;get the number of entries
 19512 000036A2 47                      	inc	di
 19513 000036A3 47                      	inc	di			;si -> the first start entry id
 19514                                  
 19515                                  getcntrydest:
 19516 000036A4 263805                  	cmp	byte [es:di],al
 19517 000036A7 7413                    	je	short getcntrydest_ok
 19518 000036A9 26803D01                	cmp	byte [es:di],SetCountryInfo ;was it setcountryinfo entry?
 19519 000036AD 7405                    	je	short getcntrydest_1
 19520                                  
 19521 000036AF 83C705                  	add	di,5			;next data id
 19522 000036B2 EB03                    	jmp	short getcntrydest_loop
 19523                                  
 19524                                  getcntrydest_1:
 19525                                  	;add	di,41
 19526 000036B4 83C729                  	add	di,NEW_COUNTRY_SIZE+3	;next data id
 19527                                  getcntrydest_loop:
 19528 000036B7 E2EB                    	loop	getcntrydest
 19529 000036B9 F9                      	stc
 19530 000036BA EB0B                    	jmp	short getcntrydest_exit
 19531                                  
 19532                                  getcntrydest_ok:
 19533 000036BC 3C01                    	cmp	al,SetCountryInfo ; 1	;select country info?
 19534 000036BE 7503                    	jne	short getcntrydest_ok1
 19535                                  
 19536 000036C0 47                      	inc	di			;now di -> cccountryinfolen
 19537 000036C1 EB04                    	jmp	short getcntrydest_exit
 19538                                  
 19539                                  getcntrydest_ok1:
 19540 000036C3 26C47D01                	les	di,[es:di+1]		;get the destination in es:di
 19541                                  
 19542                                  getcntrydest_exit:
 19543 000036C7 59                      	pop	cx
 19544 000036C8 C3                      	retn
 19545                                  
 19546                                  ;----------------------------------------------------------------------------
 19547                                  
 19548                                  readincontrolbuffer:
 19549                                  
 19550                                  ;move file pointer to cx:dx
 19551                                  ;read ax bytes into the control buffer. (should be less than 2 kb)
 19552                                  ;si will be set to 0 hence ds:si points to the control buffer.
 19553                                  ;entry:  cx,dx offset from the start of the file where the read/write pointer
 19554                                  ;	 be moved.
 19555                                  ;	 ax - # of bytes to read
 19556                                  ;	 bx - file handle
 19557                                  ;	 ds - buffer seg.
 19558                                  ;return: the control data information is read into ds:0 - ds:0200.
 19559                                  ;	 cx,dx value destroyed.
 19560                                  ;	 carry set if error in reading file.
 19561                                  
 19562 000036C9 50                      	push	ax			;# of bytes to read
 19563 000036CA B80042                  	mov	ax,4200h
 19564 000036CD F9                      	stc
 19565 000036CE CD21                    	int	21h			;move pointer
 19566 000036D0 59                      	pop	cx			;# of bytes to read
 19567 000036D1 7209                    	jc	short ricb_exit
 19568                                  
 19569 000036D3 31D2                    	xor	dx,dx			;ds:dx -> control buffer
 19570 000036D5 31F6                    	xor	si,si
 19571 000036D7 B43F                    	mov	ah,3Fh			;read into the buffer
 19572 000036D9 F9                      	stc
 19573 000036DA CD21                    	int	21h			;should be less than 1024 bytes.
 19574                                  ricb_exit:
 19575 000036DC C3                      	retn
 19576                                  
 19577                                  ;----------------------------------------------------------------------------
 19578                                  
 19579                                  set_country_path:
 19580                                  
 19581                                  ;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
 19582                                  ;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
 19583                                  ;     assumes current directory is the root directory.
 19584                                  ;out: ds:di -> full path (cntry_drv).
 19585                                  ;     set the cntry_drv string from the country=,,path command.
 19586                                  ;     ds, es, si value saved.
 19587                                  
 19588 000036DD 56                      	push	si
 19589                                  
 19590 000036DE 1E                      	push	ds			;switch ds, es
 19591 000036DF 06                      	push	es
 19592 000036E0 1F                      	pop	ds
 19593 000036E1 07                      	pop	es			;now ds -> confbot, es -> sysinitseg
 19594                                  
 19595 000036E2 E82E00                  	call	chk_drive_letter	;current ds:[si] is a drive letter?
 19596 000036E5 7206                    	jc	short scp_default_drv 	;no, use current default drive.
 19597                                  
 19598 000036E7 8A04                    	mov	al,[si]
 19599 000036E9 46                      	inc	si
 19600 000036EA 46                      	inc	si			;si -> next char after ":"
 19601 000036EB EB06                    	jmp	short scp_setdrv
 19602                                  
 19603                                  scp_default_drv:
 19604 000036ED B419                    	mov	ah,19h
 19605 000036EF CD21                    	int	21h
 19606 000036F1 0441                    	add	al,"A"			;convert it to a character.
 19607                                  
 19608                                  scp_setdrv:
 19609 000036F3 2EA2[2038]              	mov	[cs:cntry_drv],al	;set the drive letter.
 19610 000036F7 BF[2338]                	mov	di,cntry_path
 19611 000036FA 8A04                    	mov	al,[si]
 19612 000036FC 3C5C                    	cmp	al, "\"
 19613 000036FE 7406                    	je	short scp_root_dir
 19614                                  
 19615 00003700 3C2F                    	cmp	al,"/"			;let's accept "/" as an directory delim
 19616 00003702 7402                    	je	short scp_root_dir
 19617                                  
 19618 00003704 EB01                    	jmp	short scp_path
 19619                                  
 19620                                  scp_root_dir:
 19621 00003706 4F                      	dec	di			;di -> cntry_root
 19622                                  scp_path:
 19623 00003707 E81F00                  	call	move_asciiz		;copy it
 19624                                  
 19625 0000370A BF[2038]                	mov	di,cntry_drv
 19626                                  scpath_exit:
 19627                                  
 19628 0000370D 1E                      	push	ds			;switch ds, es
 19629 0000370E 06                      	push	es
 19630 0000370F 1F                      	pop	ds
 19631 00003710 07                      	pop	es			;ds, es value restored
 19632                                  
 19633 00003711 5E                      	pop	si
 19634 00003712 C3                      	retn
 19635                                  
 19636                                  ;----------------------------------------------------------------------------
 19637                                  
 19638                                  chk_drive_letter:
 19639                                  
 19640                                  ;check if ds:[si] is a drive letter followed by ":".
 19641                                  ;assume that every alpha character is already converted to upper case.
 19642                                  ;carry set if not.
 19643                                  
 19644 00003713 50                      	push	ax
 19645 00003714 803C41                  	cmp	byte [si],"A"
 19646                                  	;jb	short cdletter_no
 19647 00003717 720E                    	jb	short cdletter_exit
 19648 00003719 803C5A                  	cmp	byte [si],"Z"
 19649 0000371C 7708                    	ja	short cdletter_no
 19650 0000371E 807C013A                	cmp	byte [si+1],":"
 19651 00003722 7502                    	jne	short cdletter_no
 19652                                  
 19653 00003724 EB01                    	jmp	short cdletter_exit
 19654                                  
 19655                                  cdletter_no:
 19656 00003726 F9                      	stc
 19657                                  cdletter_exit:
 19658 00003727 58                      	pop	ax
 19659 00003728 C3                      	retn
 19660                                  
 19661                                  ;----------------------------------------------------------------------------
 19662                                  
 19663                                  move_asciiz:
 19664                                  
 19665                                  ;in: ds:si -> source es:di -> target
 19666                                  ;out: copy the string until 0.
 19667                                  ;assumes there exists a 0.
 19668                                  
 19669                                  masciiz_loop:
 19670 00003729 A4                      	movsb
 19671 0000372A 807CFF00                	cmp	byte [si-1],0	;was it 0?
 19672 0000372E 75F9                    	jne	short masciiz_loop
 19673 00003730 C3                      	retn
 19674                                  
 19675                                  ;----------------------------------------------------------------------------
 19676                                  
 19677                                  ;	ds:dx points to string to output (asciz)
 19678                                  ;
 19679                                  ;	prints <badld_pre> <string> <badld_post>
 19680                                  
 19681                                  badfil:
 19682 00003731 0E                      	push	cs
 19683 00003732 07                      	pop	es
 19684                                  
 19685 00003733 89D6                    	mov	si,dx
 19686                                  badload:
 19687 00003735 BA[AB3B]                	mov	dx,badld_pre	; want to print config error
 19688 00003738 BB[683B]                	mov	bx,crlfm
 19689                                  
 19690                                  prnerr:
 19691 0000373B 0E                      	push	cs
 19692 0000373C 1F                      	pop	ds
 19693 0000373D E81F00                  	call	print
 19694                                  prn1:
 19695 00003740 268A14                  	mov	dl,[es:si]
 19696 00003743 08D2                    	or	dl,dl
 19697 00003745 7407                    	jz	short prn2
 19698 00003747 B402                    	mov	ah,STD_CON_OUTPUT ; 2 
 19699 00003749 CD21                    	int	21h
 19700 0000374B 46                      	inc	si
 19701 0000374C EBF2                    	jmp	short prn1
 19702                                  prn2:
 19703 0000374E 89DA                    	mov	dx,bx
 19704 00003750 E80C00                  	call	print
 19705                                  
 19706 00003753 2E803E[D103]01          	cmp	byte [cs:donotshownum],1 ; suppress line number when handling command.com
 19707 00003759 7403                    	je	short prnexit
 19708 0000375B E81CF3                  	call	error_line
 19709                                  prnexit:
 19710 0000375E C3                      	retn
 19711                                  
 19712                                  ;----------------------------------------------------------------------------
 19713                                  
 19714                                  print:
 19715 0000375F B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9
 19716 00003761 CD21                    	int	21h
 19717 00003763 C3                      	retn
 19718                                  
 19719                                  ;----------------------------------------------------------------------------
 19720                                  
 19721                                  ;  open device pointed to by dx, al has access code
 19722                                  ;   if unable to open do a device open null device instead
 19723                                  
 19724                                  	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
 19725                                  	; (SYSINIT:3764h)
 19726                                  open_dev:
 19727 00003764 E81C00                  	call	open_file
 19728 00003767 7307                    	jnc	short open_dev3
 19729                                  
 19730                                  open_dev1:
 19731 00003769 BA[0438]                	mov	dx,nuldev
 19732 0000376C E81400                  	call	open_file
 19733                                  of_retn:
 19734 0000376F C3                      	retn
 19735                                  
 19736                                  open_dev3:
 19737 00003770 89C3                    	mov	bx,ax			; handle from open to bx
 19738                                  	;;xor	ax,ax			; get device info
 19739                                  	;;mov	ah,IOCTL ; 44h
 19740                                  	;mov	ax,(IOCTL<<8) ; 13/05/2019
 19741                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19742 00003772 31C0                    	xor	ax,ax
 19743 00003774 B444                    	mov	ah,44h	; IOCTL
 19744                                  
 19745 00003776 CD21                    	int	21h
 19746                                  
 19747 00003778 F6C280                  	test	dl,10000000b ; 80h
 19748 0000377B 75F2                    	jnz	short of_retn
 19749                                  
 19750 0000377D B43E                    	mov	ah,CLOSE ; 3Eh
 19751 0000377F CD21                    	int	21h
 19752 00003781 EBE6                    	jmp	short open_dev1
 19753                                  
 19754                                  ;----------------------------------------------------------------------------
 19755                                  
 19756                                  open_file:
 19757 00003783 B43D                    	mov	ah,OPEN	; 3Dh
 19758 00003785 F9                      	stc
 19759 00003786 CD21                    	int	21h
 19760 00003788 C3                      	retn
 19761                                  
 19762                                  ;----------------------------------------------------------------------------
 19763                                  
 19764                                  ; test int24. return back to dos with the fake user response of "fail"
 19765                                  
 19766                                  int24:
 19767 00003789 B003                    	mov	al,3			; fail the system call
 19768 0000378B CF                      	iret				; return back to dos.
 19769                                  
 19770                                  ; 19/04/2019 - Retro DOS v4.0
 19771                                  
 19772                                  ;----------------------------------------------------------------------------
 19773                                  ; DATA
 19774                                  ;----------------------------------------------------------------------------
 19775                                  
 19776                                  ;include copyrigh.inc			; copyright statement
 19777                                  
 19778                                  ; MSDOS 6.21 IO.SYS - SYSINIT:4FA3h
 19779                                  
 19780                                  ;MsDosVersion6Copyr:
 19781                                  ;	db	'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp '
 19782                                  ;	db	'Licensed Material - Property of Microsoft All rights reserved '
 19783                                  
 19784                                  ; 22/10/2022
 19785                                  ; MSDOS 5.0 IO.SYS - SYSINIT:378Ch
 19786                                  
 19787                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19788                                  MsDosVersion5Copyr:
 19789 0000378C 4D5320444F53205665-     	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
 19789 00003795 7273696F6E20352E30-
 19789 0000379E 3020284329436F7079-
 19789 000037A7 726967687420313938-
 19789 000037B0 312D31393931204D69-
 19789 000037B9 63726F736F66742043-
 19789 000037C2 6F727020           
 19790 000037C6 4C6963656E73656420-     	db	'Licensed Material - Property of Microsoft All rights reserved '
 19790 000037CF 4D6174657269616C20-
 19790 000037D8 2D2050726F70657274-
 19790 000037E1 79206F66204D696372-
 19790 000037EA 6F736F667420416C6C-
 19790 000037F3 207269676874732072-
 19790 000037FC 6573657276656420   
 19791                                  
 19792                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19793                                  ; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19794                                  ; 20/04/2019 - Retro DOS v4.0
 19795                                  ;BOOTMES:
 19796                                  ;	db      13
 19797                                  ;	db      10
 19798                                  ;	db      "MS-DOS version "
 19799                                  ;	db      MAJOR_VERSION + "0"
 19800                                  ;	db      "."
 19801                                  ;	db      (MINOR_VERSION / 10) + "0"
 19802                                  ;	db      (MINOR_VERSION % 10) + "0"
 19803                                  ;	db      13,10
 19804                                  ;	;db	"Copyright 1981-1993 Microsoft Corp.",13,10,"$"
 19805                                  ;	; 22/10/2022
 19806                                  ;	db	"Copyright 1981-1991 Microsoft Corp.",13,10,"$"
 19807                                  ;	;
 19808                                  ;	db	0
 19809                                  
 19810 00003804 4E554C00                nuldev:	db	"NUL",0
 19811 00003808 434F4E00                condev:	db	"CON",0
 19812 0000380C 41555800                auxdev:	db	"AUX",0
 19813 00003810 50524E00                prndev:	db	"PRN",0
 19814                                  
 19815                                  ;IFDEF	CONFIGPROC
 19816 00003814 5C434F4E4649472E53-     config:	db	"\CONFIG.SYS",0
 19816 0000381D 595300             
 19817                                  
 19818 00003820 413A                    cntry_drv:  db	"A:"
 19819 00003822 5C                      cntry_root: db	"\"
 19820 00003823 434F554E5452592E53-     cntry_path: db	"COUNTRY.SYS",0
 19820 0000382C 595300             
 19821                                  	    ;db	52 dup (0)
 19822 0000382F 00<rep 34h>             	    times 52 db 0	
 19823                                  
 19824                                  country_file_signature:
 19825 00003863 FF434F554E545259        	db	0FFh,'COUNTRY'
 19826                                  
 19827                                  cntrycodepage_id: 
 19828 0000386B 0000                    	dw	0 	
 19829                                  
 19830                                  ;ENDIF ; CONFIGPROC
 19831                                  
 19832                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19833                                  ;;ifdef	MULTI_CONFIG
 19834                                  ;newcmd:  db	0			; non-zero if non-std shell specified
 19835                                  ;tmplate: db	64                      ; must precede commnd
 19836                                  ;;endif
 19837                                  	; 02/11/2022
 19838                                  	;db	12                      ; size of commnd line (excl. null)
 19839                                  
 19840 0000386D 5C434F4D4D414E442E-     commnd:	db	"\COMMAND.COM",0
 19840 00003876 434F4D00           
 19841                                  	;db	51 dup (0)
 19842 0000387A 00<rep 33h>             	times	51 db 0
 19843                                  ;endif
 19844                                  
 19845                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19846                                  ;;ifdef	MULTI_CONFIG
 19847                                  ;commnd2: db 	"\COMMAND.COM",0	; alternate commands to exec,
 19848                                  ;	 db	2,"/P",0 		; followed by their respective alternate
 19849                                  ;commnd3: db	"\MSDOS\COMMAND.COM",0	; command lines
 19850                                  ;	 db	11,"A:\MSDOS /P",0 	;(the drive letter are dynamically replaced)
 19851                                  ;commnd4: db	"\DOS\COMMAND.COM",0 	;
 19852                                  ;	 db	9,"A:\DOS /P",0		;
 19853                                  ;def_swchr:	
 19854                                  ;	 db	0			; default switchchar (referenced as command_line-1)
 19855                                  ;;endif
 19856                                  
 19857                                  	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19858                                  ;command_line:
 19859                                  ;	db	2,"/P"			; default command.com args
 19860                                  ;	;db	125 dup (0)
 19861                                  ;	times	125 db 0
 19862                                  
 19863                                  pathstring:
 19864                                  	;db	64 dup (0)
 19865 000038AD 00<rep 40h>             	times	64 db 0
 19866                                  
 19867                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19868                                  %if 0
 19869                                  
 19870                                  dae_flag:
 19871                                  	db	0 ; MSDOS 6.21 IO.SYS - SYSINIT:51D2h 	
 19872                                  
 19873                                  ;ifdef	MULTI_CONFIG
 19874                                  
 19875                                  MAX_MULTI_CONFIG equ 10
 19876                                  
 19877                                  ;   Beware of byte pairs accessed as words (see all "KEEP AFTER" notes below)
 19878                                  
 19879                                  bMenuColor:	db      07h ;1Fh        ; default fgnd/bgnd color
 19880                                  bMenuPage:	db      0               ; menu video page (KEEP AFTER bMenuColor)
 19881                                  		db      5               ; video page function # (KEEP AFTER bMenuPage)
 19882                                  bLastCol:	db      0               ; ending column on status line
 19883                                  bLastRow:	db      24              ; row # of status line (KEEP AFTER bLastCol)
 19884                                  bDisableUI:	db      0               ; 1=disable clean/interactive
 19885                                                                          ; 2=disable default 2-second delay
 19886                                  bCRTPage:	db      0               ; value saved from BIOS data area
 19887                                  wCRTStart:	dw      0               ; value saved from BIOS data area
 19888                                  bQueryOpt:	db      0               ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
 19889                                  bDefBlock:	db      1               ; default block #
 19890                                  bMaxBlock:	db      0               ; maxmimum block #
 19891                                  offDefBlock:	dw      0               ; offset of name of default block (if any)
 19892                                  secTimeOut:	db      -1              ; # of seconds for timeout (-1 == indefinite)
 19893                                  secElapsed:	db      0               ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
 19894                                  abBlockType:	times MAX_MULTI_CONFIG+1 db 0 ; array of block types
 19895                                  aoffBlockName:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block names
 19896                                  aoffBlockDesc:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block descriptions
 19897                                  
 19898                                  szBoot:		db      "CONFIG=",0
 19899                                  szMenu:		db      "MENU",0
 19900                                  szCommon:	db      "COMMON",0
 19901                                  
 19902                                  ;endif	;MULTI_CONFIG
 19903                                  
 19904                                  comtab:	 ; label byte
 19905                                  
 19906                                  ;            cmd len    command         cmd code
 19907                                  ;            -------    -------         --------
 19908                                  
 19909                                  ;ifdef MULTI_CONFIG
 19910                                          db      1,      "[",            CONFIG_BEGIN
 19911                                  ;endif
 19912                                          db      5,      "BREAK",        CONFIG_BREAK
 19913                                          db      7,      "BUFFERS",      CONFIG_BUFFERS
 19914                                          db      7,      "COMMENT",      CONFIG_COMMENT
 19915                                          db      7,      "COUNTRY",      CONFIG_COUNTRY
 19916                                          db      6,      "DEVICE",       CONFIG_DEVICE
 19917                                          db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
 19918                                          db      3,      "DOS",          CONFIG_DOS
 19919                                          db      8,      "DRIVPARM",     CONFIG_DRIVPARM
 19920                                          db      4,      "FCBS",         CONFIG_FCBS
 19921                                          db      5,      "FILES",        CONFIG_FILES
 19922                                  ;ifdef MULTI_CONFIG
 19923                                          db      7,      "INCLUDE",      CONFIG_INCLUDE
 19924                                  ;endif
 19925                                          db      7,      "INSTALL",      CONFIG_INSTALL
 19926                                          db      11,     "INSTALLHIGH",  CONFIG_INSTALLHIGH
 19927                                          db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
 19928                                  ;ifdef MULTI_CONFIG
 19929                                          db      7,      "SUBMENU",      CONFIG_SUBMENU
 19930                                          db      9,      "MENUCOLOR",    CONFIG_MENUCOLOR
 19931                                          db      11,     "MENUDEFAULT",  CONFIG_MENUDEFAULT
 19932                                          db      8,      "MENUITEM",     CONFIG_MENUITEM
 19933                                  ;endif
 19934                                          db      10,     "MULTITRACK",   CONFIG_MULTITRACK
 19935                                  ;ifdef MULTI_CONFIG
 19936                                          db      7,      "NUMLOCK",      CONFIG_NUMLOCK
 19937                                  ;endif
 19938                                          db      3,      "REM",          CONFIG_REM
 19939                                  ;ifdef MULTI_CONFIG
 19940                                          db      3,      "SET",          CONFIG_SET
 19941                                  ;endif
 19942                                          db      5,      "SHELL",        CONFIG_SHELL
 19943                                  ;if    STACKSW
 19944                                          db      6,      "STACKS",       CONFIG_STACKS
 19945                                  ;endif
 19946                                          db      8,      "SWITCHES",     CONFIG_SWITCHES
 19947                                  	db	0
 19948                                  %endif
 19949                                  
 19950                                  comtab:
 19951                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 19952                                  	; (SYSINIT:38EDh)
 19953 000038ED 074255464645525342      	db      7,      "BUFFERS",      CONFIG_BUFFERS
 19954 000038F6 05425245414B43          	db      5,      "BREAK",        CONFIG_BREAK
 19955 000038FD 0644455649434544        	db      6,      "DEVICE",       CONFIG_DEVICE
 19956 00003905 0A4445564943454849-     	db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
 19956 0000390E 474855             
 19957 00003911 0546494C455346          	db      5,      "FILES",        CONFIG_FILES
 19958 00003918 044643425358            	db      4,      "FCBS",         CONFIG_FCBS
 19959 0000391E 094C41535444524956-     	db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
 19959 00003927 454C               
 19960 00003929 0A4D554C5449545241-     	db      10,     "MULTITRACK",   CONFIG_MULTITRACK
 19960 00003932 434B4D             
 19961 00003935 08445249565041524D-     	db      8,      "DRIVPARM",     CONFIG_DRIVPARM
 19961 0000393E 50                 
 19962 0000393F 06535441434B534B        	db      6,      "STACKS",       CONFIG_STACKS
 19963 00003947 07434F554E54525951      	db      7,      "COUNTRY",      CONFIG_COUNTRY
 19964 00003950 055348454C4C53          	db      5,      "SHELL",        CONFIG_SHELL
 19965 00003957 07494E5354414C4C49      	db      7,      "INSTALL",      CONFIG_INSTALL
 19966 00003960 07434F4D4D454E5459      	db      7,      "COMMENT",      CONFIG_COMMENT
 19967 00003969 0352454D30              	db      3,      "REM",          CONFIG_REM
 19968 0000396E 085357495443484553-     	db      8,      "SWITCHES",     CONFIG_SWITCHES
 19968 00003977 31                 
 19969 00003978 03444F5348              	db      3,      "DOS",          CONFIG_DOS
 19970 0000397D 00                      	db	0
 19971                                  
 19972                                  deviceparameters:	
 19973                                  	; A_DEVICEPARAMETERS <0,dev_3inch720kb,0,80>
 19974                                  devp.specialfunc:	; deviceparameters +
 19975 0000397E 00                      	db	0	; A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS
 19976                                  devp.devtype:
 19977 0000397F 02                      	db	2	; A_DEVICEPARAMETERS.DP_DEVICETYPE
 19978                                  devp.devattr:
 19979 00003980 0000                    	dw	0	; A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES
 19980                                  devp.cylinders:
 19981 00003982 5000                    	dw	80	; A_DEVICEPARAMETERS.DP_CYLINDERS
 19982                                  
 19983 00003984 00<rep 11Eh>            	times	286	db 0
 19984                                  	
 19985 00003AA2 0200                    hlim:	dw	2
 19986 00003AA4 0900                    slim:	dw	9
 19987                                  
 19988 00003AA6 00                      drive:	db	0
 19989                                  
 19990                                  switches:
 19991 00003AA7 0000                    	dw	0
 19992                                  
 19993                                  ; the following are the recommended bpbs for the media that
 19994                                  ; we know of so far.
 19995                                  
 19996                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 19997                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3AA9h
 19998                                  
 19999                                  ; 48 tpi diskettes
 20000                                  
 20001 00003AA9 0002                    bpb48t	dw	512
 20002 00003AAB 02                      	db	2
 20003 00003AAC 0100                    	dw	1
 20004 00003AAE 02                      	db	2
 20005 00003AAF 7000                    	dw	112
 20006 00003AB1 D002                    	dw	2*9*40 ; 720
 20007 00003AB3 FD                      	db	0FDh
 20008 00003AB4 0200                    	dw	2
 20009 00003AB6 0900                    	dw	9
 20010 00003AB8 0200                    	dw	2
 20011 00003ABA 00000000                	dd	0
 20012 00003ABE 00000000                        dd      0
 20013                                  
 20014                                  ; 96tpi diskettes
 20015                                  
 20016 00003AC2 0002                    bpb96t:	dw	512
 20017 00003AC4 01                      	db	1
 20018 00003AC5 0100                    	dw	1
 20019 00003AC7 02                      	db	2
 20020 00003AC8 E000                    	dw	224
 20021 00003ACA 6009                    	dw	2*15*80 ; 2400
 20022 00003ACC F9                      	db	0F9h
 20023 00003ACD 0700                    	dw	7
 20024 00003ACF 0F00                    	dw	15
 20025 00003AD1 0200                    	dw	2
 20026 00003AD3 00000000                	dd	0
 20027 00003AD7 00000000                        dd      0
 20028                                  
 20029                                  ; 3 1/2 inch diskette bpb
 20030                                  
 20031 00003ADB 0002                    bpb35:	dw	512
 20032 00003ADD 02                      	db	2
 20033 00003ADE 0100                    	dw	1
 20034 00003AE0 02                      	db	2
 20035 00003AE1 7000                    	dw	112
 20036 00003AE3 A005                    	dw	2*9*80 ; 1440
 20037 00003AE5 F9                      	db	0F9h
 20038 00003AE6 0300                    	dw	3
 20039 00003AE8 0900                    	dw	9
 20040 00003AEA 0200                    	dw	2
 20041 00003AEC 00000000                	dd	0
 20042 00003AF0 00000000                        dd      0
 20043                                        
 20044 00003AF4 0002                    bpb35h:	dw	512
 20045 00003AF6 01                      	db	1
 20046 00003AF7 0100                    	dw	1
 20047 00003AF9 02                      	db	2
 20048 00003AFA E000                    	dw	224
 20049 00003AFC 400B                    	dw	2*18*80 ; 2880
 20050 00003AFE F0                      	db	0F0h
 20051 00003AFF 0900                    	dw	9
 20052 00003B01 1200                    	dw	18
 20053 00003B03 0200                    	dw	2
 20054 00003B05 00000000                	dd	0
 20055 00003B09 00000000                        dd      0
 20056                                  
 20057                                  ; m037 - BEGIN
 20058                                  
 20059 00003B0D 0002                    bpb288:	dw	512
 20060 00003B0F 02                      	db	2
 20061 00003B10 0100                    	dw	1
 20062 00003B12 02                      	db	2
 20063 00003B13 F000                    	dw	240
 20064 00003B15 8016                    	dw	2*36*80 ; 5760
 20065 00003B17 F0                      	db	0F0h
 20066 00003B18 0900                    	dw	9
 20067 00003B1A 2400                    	dw	36
 20068 00003B1C 0200                    	dw	2
 20069 00003B1E 00000000                	dd	0
 20070 00003B22 00000000                        dd      0
 20071                                  
 20072                                  ; m037 - END
 20073                                  
 20074                                  ; 12/05/2019
 20075                                  
 20076                                  align 2
 20077                                  
 20078                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20079                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3B26h
 20080                                  
 20081 00003B26 [A93A]                  bpbtable:   dw	    bpb48t		; 48tpi drives
 20082 00003B28 [C23A]                  	    dw	    bpb96t		; 96tpi drives
 20083 00003B2A [DB3A]                  	    dw	    bpb35		; 3.5" drives
 20084                                  ; the following are not supported, so default to 3.5" media layout
 20085 00003B2C [DB3A]                  	    dw	    bpb35		; not used - 8" drives
 20086 00003B2E [DB3A]                  	    dw	    bpb35		; not used - 8" drives
 20087 00003B30 [DB3A]                  	    dw	    bpb35		; not used - hard files
 20088 00003B32 [DB3A]                  	    dw	    bpb35		; not used - tape drives
 20089 00003B34 [F43A]                  	    dw	    bpb35h		; 3-1/2" 1.44mb drive
 20090 00003B36 [DB3A]                  	    dw	    bpb35		; ERIMO				m037
 20091 00003B38 [0D3B]                  	    dw	    bpb288		; 2.88 MB diskette drives	m037
 20092                                  
 20093                                  switchlist: 
 20094 00003B3A 08464853544449434E      	db	8,"FHSTDICN"	     ; preserve the positions of n and c.
 20095                                  
 20096                                  ;----------------------------------------------------------------------------
 20097                                  ; Messages
 20098                                  ;----------------------------------------------------------------------------
 20099                                  
 20100                                  ; 19/04/2019 - Retro DOS v4.0
 20101                                  
 20102                                  ; MSDOS 6.21 IO.SYS - SYSINIT:54D1h
 20103                                  
 20104 00003B43 00                      	db 	0
 20105                                  
 20106                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20107                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3B44h
 20108                                  
 20109                                  badopm:
 20110 00003B44 0D0A                    	db	0Dh,0Ah 
 20111 00003B46 556E7265636F676E69-     	db	'Unrecognized command in CONFIG.SYS'
 20111 00003B4F 7A656420636F6D6D61-
 20111 00003B58 6E6420696E20434F4E-
 20111 00003B61 4649472E535953     
 20112                                  crlfm:
 20113 00003B68 0D0A24                  	db	0Dh,0Ah,'$'
 20114                                  badparm:
 20115 00003B6B 0D0A                    	db	0Dh,0Ah
 20116 00003B6D 42616420636F6D6D61-     	db	'Bad command or parameters - $'
 20116 00003B76 6E64206F7220706172-
 20116 00003B7F 616D6574657273202D-
 20116 00003B88 2024               
 20117                                  badsiz_pre:
 20118 00003B8A 0D0A                    	db	0Dh,0Ah
 20119 00003B8C 536563746F72207369-     	db	'Sector size too large in file $'
 20119 00003B95 7A6520746F6F206C61-
 20119 00003B9E 72676520696E206669-
 20119 00003BA7 6C652024           
 20120                                  badld_pre:
 20121 00003BAB 0D0A                    	db	0Dh,0Ah
 20122 00003BAD 426164206F72206D69-     	db	'Bad or missing $'
 20122 00003BB6 7373696E672024     
 20123                                  badcom:
 20124 00003BBD 436F6D6D616E642049-     	db	'Command Interpreter',0
 20124 00003BC6 6E7465727072657465-
 20124 00003BCF 7200               
 20125                                  badcountry:
 20126 00003BD1 0D0A                    	db	0Dh,0Ah
 20127 00003BD3 496E76616C69642063-     	db	'Invalid country code or code page',0Dh,0Ah,'$'
 20127 00003BDC 6F756E74727920636F-
 20127 00003BE5 6465206F7220636F64-
 20127 00003BEE 6520706167650D0A24 
 20128                                  badcountrycom:
 20129 00003BF7 0D0A                    	db	0Dh,0Ah
 20130 00003BF9 4572726F7220696E20-     	db	'Error in COUNTRY command',0Dh,0Ah,'$'
 20130 00003C02 434F554E5452592063-
 20130 00003C0B 6F6D6D616E640D0A24 
 20131                                  insufmemory:
 20132 00003C14 0D0A                    	db	0Dh,0Ah
 20133 00003C16 496E73756666696369-     	db	'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
 20133 00003C1F 656E74206D656D6F72-
 20133 00003C28 7920666F7220434F55-
 20133 00003C31 4E5452592E53595320-
 20133 00003C3A 66696C650D0A24     
 20134                                  badmem:
 20135 00003C41 0D0A                    	db	0Dh,0Ah
 20136 00003C43 436F6E666967757261-     	db	'Configuration too large for memory',0Dh,0Ah,'$'
 20136 00003C4C 74696F6E20746F6F20-
 20136 00003C55 6C6172676520666F72-
 20136 00003C5E 206D656D6F72790D0A-
 20136 00003C67 24                 
 20137                                  badblock:
 20138 00003C68 0D0A                    	db	0Dh,0Ah
 20139 00003C6A 546F6F206D616E7920-     	db	'Too many block devices',0Dh,0Ah,'$'
 20139 00003C73 626C6F636B20646576-
 20139 00003C7C 696365730D0A24     
 20140                                  badstack:
 20141 00003C83 0D0A                    	db	0Dh,0Ah
 20142 00003C85 496E76616C69642053-     	db	'Invalid STACK parameters',0Dh,0Ah,'$'
 20142 00003C8E 5441434B2070617261-
 20142 00003C97 6D65746572730D0A24 
 20143                                  badorder:
 20144 00003CA0 0D0A                    	db	0Dh,0Ah
 20145 00003CA2 496E636F7272656374-     	db	'Incorrect order in CONFIG.SYS line $'
 20145 00003CAB 206F7264657220696E-
 20145 00003CB4 20434F4E4649472E53-
 20145 00003CBD 5953206C696E652024 
 20146                                  errorcmd:
 20147 00003CC6 4572726F7220696E20-     	db	'Error in CONFIG.SYS line $'
 20147 00003CCF 434F4E4649472E5359-
 20147 00003CD8 53206C696E652024   
 20148                                  
 20149                                  ; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 20150                                  %if 0
 20151                                  
 20152                                  OnOff:	db	'ON'
 20153                                  OnOff2:	db	'OFF'
 20154                                  
 20155                                  StartMsg:
 20156                                  	db	'Starting MS-DOS...',0Dh,0Ah
 20157                                  	db	0Ah,0
 20158                                  _$PauseMsg:
 20159                                  	db	'Press any key to continue . . .',0Dh,0Ah,'$'
 20160                                  _$CleanMsg:
 20161                                  	db	'MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah,'$'
 20162                                  _$InterMsg:
 20163                                  	db	'MS-DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah,'$'
 20164                                  _$MenuHeader:
 20165                                  	db	0Dh,0Ah
 20166                                  	db	'  MS-DOS 6.2 Startup Menu',0Dh,0Ah
 20167                                  	db	'  =======================',0Dh,0Ah,'$'
 20168                                  _$MenuPrmpt:
 20169                                  	db	'  Enter a choice: $'
 20170                                  _$StatusLine:
 20171                                  	db	'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS'
 20172                                  	db	'and AUTOEXEC.BAT [ ]$'
 20173                                  _$InterPrmpt:
 20174                                  	db	' [Y,N]?$'
 20175                                  _$YES:	db	'YES$'
 20176                                  _$NO:	db	'NO $'
 20177                                  _$TimeOut:
 20178                                  	db	'Time remaining: $'
 20179                                  badcomprmpt:
 20180                                  	db	'Enter correct name of Command Interpreter (eg, C:\COMMAND.COM)'
 20181                                  	db	0Dh,0Ah,'$'
 20182                                  _$AutoPrmpt:
 20183                                  	db	'Process AUTOEXEC.BAT [Y,N]?$'
 20184                                  
 20185                                  %endif
 20186                                  
 20187                                  ; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
 20188                                  ; MSDOS 5.0 IO.SYS - SYSINIT:3CE0h
 20189                                  
 20190                                  TooManyDrivesMsg:
 20191 00003CE0 5741524E494E472120-     	db	'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$'
 20191 00003CE9 4C6F676963616C2064-
 20191 00003CF2 726976657320706173-
 20191 00003CFB 74205A3A2065786973-
 20191 00003D04 7420616E642077696C-
 20191 00003D0D 6C2062652069676E6F-
 20191 00003D16 7265640D0A24       
 20192                                  
 20193                                  ;MSDOS 6.21 IO.SYS - SYSINIT:587Ch
 20194                                  	;db	'Wrong DBLSPACE.BIN version',0Dh,0Ah,'$'
 20195                                  	;db	7 dup(0)
 20196                                  
 20197                                  	;times	7 db 0
 20198                                  	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
 20199                                  ;MSDOS 5.0 IO.SYS - SYSINIT:3D1Ch
 20200 00003D1C 00<rep 4h>              	times 4 db 0
 20201                                  
 20202                                  ;MSDOS 6.21 IO.SYS - SYSINIT:5899h
 20203                                  
 20204                                  ;----------------------------------------------------------------------------
 20205                                  ; 20/04/2019 - Retro DOS v4.0
 20206                                  
 20207                                  bss_start:
 20208                                  
 20209                                  ABSOLUTE bss_start
 20210                                  
 20211                                  alignb 16
 20212                                  
 20213                                  SI_end:  ; SI_end equ $
 20214                                  
 20215                                  ;----------------------------------------------------------------------------
 20216                                  
 20217                                  ;sysinitseg	ends
 20218                                  
 20219                                  ; ****************************************************************************
