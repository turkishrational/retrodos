; ****************************************************************************
; MSLOADS5.S (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
; ----------------------------------------------------------------------------
; Last Update: 20/12/2022 (Modified IO.SYS loader)  ((Previous: 20/10/2022))
; ----------------------------------------------------------------------------
; Beginning: 21/10/2022 (Retro DOS 4.0)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.11 (2.15) 
; ----------------------------------------------------------------------------
;	   ((nasm msload5.s -l msload5.lst -o MSLOAD5.BIN -Z error.txt)) 
; ----------------------------------------------------------------------------
; Converted to NASM source code from disassembled MSDOS 5.0 (IO.SYS) MSLOAD
; code by Erdogan Tan (disassembly: 18/09/2022, Converted source: 21/10/2022) 
; ----------------------------------------------------------------------------

; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h

;		.386
;		.model flat

; ===========================================================================

; 09/12/2022
; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output

; ===========================================================================
;	NOTE: The boot loader should be verifying that the first
;	  block of io.sys is, in fact, at cluster 2. This would be saving
;	  a whole lot of time during system debugging.
;
;============================================================================
;
;     for dos 4.00, msload program has been changed to allow:
;	  1. 32 bit calculation,
;	  2. reading a fat sector when needed, instead of reading the whole
;	     fat sectors at once. this will make the boot time faster,
;	     and eliminate the memory size limitation problem,
;	  3. solving the limitation of the file size (29 kb) of io.sys0,
;	  4. adding the boot error message. show the same boot error message
;	     and do the same behavior when the read operation of io.sys
;	     fails as the msboot program, since msload program is the
;	     extention of msboot program.
;
; ===========================================================================

;
;----------------------------------------------------------------------------
;
; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
;		SYSINIT & transient portion of COMMAND.COM
;
;----------------------------------------------------------------------------
		
		[ORG 0]			; segment 0x0070h

START$:
		jmp	SaveInputValuess
; 20/12/2022
; 09/12/2022
; ---------------------------------------------------------------------------
SysVersion:	dw 5			; expected_version	
MyStacks:	db 256 dup(0)		; local stack
NumHeads:	dw 0			; ...
ClusterSize:	db 2 dup(0)		; ...
StartSecL:	dw 0			; ...
StartSecH:	dw 0			; ...
TempH:		dw 0			; for 32 bit calculation
TempCluster:	db 2 dup(0)		; temporary place for cluster number
LastFatSector:	db 2 dup(0FFh)		; fat sec # start from 1st FAT entry
SectorCount:	dw 0			; ...
SecPerFat:	dw 0			; ...
HiddenSectorsL:	dw 0			; ...
HiddenSectorsH:	dw 0			; ...
BytesPerSec:	dw 0			; ...
ReservSectors:	db 2 dup(0)		; ...
CurrentCluster:	db 2 dup(0)		; ...
NextBioLocation: db 2 dup(0)		; ...
FirstSectorL:	dw 0			; ...
FirstSectorH:	dw 0			; ...
TotalSectorsL:	dw 0			; max. number of sectors
TotalSectorsH:	dw 0			; ...
SecPerTrack:	db 2 dup(0)		; ...
BootDrive:	db 0			; ...
Fatsize:	db 0			; ...
MediaByte:	db 0			; ...
EndOfFile:	db 0			; ...
OrgDasdPtr:	db 4 dup(0)		; ...
FatSegment:	db 2 dup(0)		; ...
SecPerCluster:	db 0			; ...
; ---------------------------------------------------------------------------

; SaveInputValuess
; ---------------------------------------------------------------------------
; INPUT:     none
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector (low) on disk (0-based)
;   ds:si = original rom bios diskette parameter table.
;
; if an extended boot record, then ax will be the first data sector
; high word. save ax and set FirstSectorH according to ax if it is an
; extended boot record.
;
;   ax = first data sector (high) on disk ;
; OUTPUT:
;
;   bx = first data sector on disk
;
;   MediaByte = input ch
;   BootDrive = input dl
;   FirstSectorL = input bx
;   FirstSectorH = input AX, if an extended boot record.;j.k.
;   TotalSectorsL = maximum sector number in this media ;j.k.
;   TotalSectorsH = high word of the above
;   HiddenSectorsL = hidden secotrs
;   HiddenSectorsH
;   ReservSectors = reserved sectors
;   SecPerTrack = sectors/track
;   NumHeads = heads/cylinder
;
;   ds = 0
;   AX,DX,SI destroyed
;
; calls:     none
; ---------------------------------------------------------------------------
;FUNCTION:
; save input information and bpb informations from the boot record.
; ---------------------------------------------------------------------------

Sec9 equ 522h
; 20/12/2022	
DskAddr	equ 1Eh*4 ; 7Eh
StackPtr equ MyStacks+(NumHeads-MyStacks)

SaveInputValuess:			; ...
		mov	[cs:FirstSectorL], bx
		mov	[cs:MediaByte], ch
		mov	[cs:BootDrive], dl
		mov	[cs:OrgDasdPtr], si
		push	ds
		pop	word [cs:OrgDasdPtr+2]
		xor	cx, cx		; segment 0 (obviously)
		mov	ds, cx		; ZERO
		push	es
		mov	es, cx
		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
		;mov	ds, [DskAddr+2]	; DS:SI -> current table
		; 20/12/2022
		mov	si, Sec9
		mov	di, si
		xchg	si, [DskAddr]
		xchg	cx, [DskAddr+2]
		mov	ds, cx
		;mov	di, Sec9	; 522h  ; ES:DI -> new table
		mov	cx, 11			; taken from ibmboot.asm
		cld
		rep movsb		; copy table
		;push	es
		;pop	ds		; ds = 0
		; 20/12/2022
		mov	ds, cx ; 0
		;mov	word [DskAddr], Sec9 ; 522h
		;mov	[DskAddr+2], ds	; point disk parm vector to new table
		pop	es
		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
		mov	[cs:BytesPerSec], cx
		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
		mov	[cs:SecPerCluster], cl
		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
		mov	[cs:SecPerTrack], cx
		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
		mov	[cs:NumHeads], cx
		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
		mov	[cs:SecPerFat], cx
		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
		mov	[cs:ReservSectors], cx
		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
		mov	[cs:HiddenSectorsL], cx
		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
		mov	[cs:TotalSectorsL], cx

		; First of all, check if it the boot record is an extended one.
		; This is just a safe guard in case some user just "copy" the
		; 4.00 iosys.com to a media with a conventional boot record.

		cmp	byte [7C26h], 29h ; ext_boot_signature
		jnz	short relocate
		mov	[cs:FirstSectorH], ax ; ax = first data sector (high) on disk
		mov	ax, [7C1Eh]
		mov	[cs:HiddenSectorsH], ax
		; 10/12/2022
		or	cx, cx
		;cmp	cx, 0		; cx set already before (=totalsectors)
		jnz	short relocate
		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
		mov	[cs:TotalSectorsL], ax
		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
		mov	[cs:TotalSectorsH], ax

; Relocate
; -------------------------------------------------------------------------
;
; NOTES:
;
;   Relocates the loader code to top-of-memory.
;
; INPUT:     none
;
; OUTPUT:    code and data relocated.
;	     AX,CX,SI,DI destroyed
;
; calls:     none
; -------------------------------------------------------------------------
;
; Determine the number of paragraphs (16 byte blocks) of memory.
; this involves invoking the memory size determination interrupt,
; which returns the number of 1k blocks of memory, and then
; converting this to the number of paragraphs.
; Find out whether RPL code is present at top of memory and modify the
; available amount of memory in AX
; leave the number of paragraphs of memory in ax.
;
; -------------------------------------------------------------------------
; copy code from start to top of memory.
;
; the length to copy is EndOfLoader
;
; jump to relocated code
; -------------------------------------------------------------------------

relocate:				; ...
		cld
		xor	si, si
		mov	di, si
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; Memory size in paragraphs

;------ Check if an RPL program is present at TOM and do not tromp over it

		; 10/12/2022
		; dx = 0
		;xor	bx, bx
		;mov	ds, bx		; ZERO
		
		;mov	bx, [DskAddr+44h] ; 2Fh*4 (Int 2Fh)
		;mov	ds, [DskAddr+46h] ; 2Fh*4+2
		; 10/12/2022
		mov	bx, [2Fh*4]	; (Int 2Fh)
		mov	ds, [2Fh*4+2]		

		;cmp	word ptr [bx+3], 'PR'
		; 09/12/2022
		cmp	word [bx+3], 'RP' ; 'RPL'
		jnz	short Skip_RPL
		cmp	byte [bx+5], 'L'
		jnz	short Skip_RPL
		mov	dx, ax		; get TOM into DX
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		mov	ax, dx
Skip_RPL:				; ...
		mov	cl, 4
		mov	dx, [cs:BytesPerSec]
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	[cs:FatSegment], ax ; This will be used for fat sector
		mov	dx, EndOfLoader
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	es, ax		; ES:DI -> place be relocated.

		push	cs
		pop	ds		; DS:si -> sourc
		mov	cx, EndOfLoader
		rep movsb
		push	es
		mov	ax, SetupStack
		push	ax		; Massage stack for destin of CS:IP
		retf
; ---------------------------------------------------------------------------

; Start of relocated code
;----------------------------------------------------------------------------
;
; Move the stack to just under the boot record and relocation area (0:7c00h)
;

SetupStack:				; ...
		mov	ax, cs		; Start	of relocated code
		mov	ss, ax
		;mov	sp, NumHeads	; StackPtr offset
		; 20/12/2022
		mov	sp, StackPtr	; StackPtr offset

; FindClusterSize
; ---------------------------------------------------------------------------
;
; INPUT:     bpb information in loaded boot record at 0:7c00h
;
; OUTPUT:
;
;	ds = 0
;	ax = bytes/cluster
;	bx = sectors/cluster
;	si destroyed
; calls:     none
;----------------------------------------------------------------------------
;
; get bytes/sector from bpb
;
; get sectors/cluster from bpb
;
; bytes/cluster = bytes/sector * sector/cluster
; ---------------------------------------------------------------------------

FindClusterSize:

;for the time being just ASSUME the boot record is valid and the bpb is there.

		xor	ax, ax
		mov	ds, ax
		mov	ax, [7C0Bh]	; get bpb bytes/sector
		xor	bx, bx
		mov	bl, [7C0Dh]	; get sectors/cluster
		mul	bx
		mov	[cs:ClusterSize], ax

; CalcFatSize
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
;   to find out what system id byte is.
;
; INPUT:
;
; OUTPUT:
;
;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
;   all other registers destroyed
;
; ---------------------------------------------------------------------------

CalcFatSize:
		mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
		mov	dx, [cs:TotalSectorsH]
		mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
		sub	ax, [cs:ReservSectors]
		sbb	dx, 0		; DX:AX	= Total	avail sectors
		mov	bx, [cs:SecPerFat]
		shl	bx, 1		; (Assume 2 FATs)
		sub	ax, bx
		sbb	dx, 0
		mov	bx, [7C11h]	; Root directory entry count
		mov	cl, 4
		shr	bx, cl		; BX = Total directory sectors
		sub	ax, bx
		sbb	dx, 0		; DX:AX	= Sectors in data area
		xor	cx, cx
		mov	cl, [7C0Dh]	; Sectors per cluster
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx
		mov	[cs:TempH], ax	; AX = Total number of clusters
		pop	ax
		div	cx
		cmp	ax, 4086	; 4096-10
		jb	short ReadInFirstClusters ; 12 bit FAT
		mov	byte [cs:Fatsize], 4 ; FAT_16_BIT

; ReadInFirstClusters
; ---------------------------------------------------------------------------
;
; NOTES: read the start of the clusters that covers at least IbmLoadSize
;	 fully.  for example, if sector/cluster = 2, and IbmLoadSize=3
;	 then we are going to re-read the second cluster to fully cover
;	 msload program in the cluster boundary.
;
; INPUT:
;   IbmLoadSize - make sure this value is the same as the one in
;		  msboot program when you build the new version!!!!!
;
;   SecPerCluster
;   ClusterSize
;   FirstSectorL
;   FirstSectorH
;
; OUTPUT: msload program is fully covered in a cluster boundary.
;	  ax = # of clusters we read in so far.
;
; calls:     ReadSectors
; logic:
;	ax; dx = IbmLoadSize / # of sector in a cluster.
;	if dx = 0 then ok. (msload is in a cluster boundary.)
;      else		   (has to read (ax+1)th cluster to cover msload)
;	read (ax+1)th cluster into the address after the clusters we
;	read in so far.
; ---------------------------------------------------------------------------

; 09/12/2022
; BiosStart equ 51Ah ; AX = IO.SYS starting cluster
; IbmLoadSize equ 3  ; AX = Number sectors in MSLOAD
; BiosOffset equ 700h ; Address where loader was read in
	
ReadInFirstClusters:
		;mov	ax, [BioSStart]	; ...
		mov	ax, [51Ah]	; IO.SYS First Cluster
		dec	ax		; Root dir buffer at 500h (segment=0)
					; IO.SYS first cluster ptr at 51Ah
		dec	ax		; AX = word [51Ah] - 2
		mov	[cs:CurrentCluster], ax ;  Initialize to this cluster
		;mov	ax, IbmLoadSize
		mov	ax, 3		; Load the 3rd and other IO.SYS	sectors
		div	byte [cs:SecPerCluster]
					; AL = total cluster read in
					; AH = remaining sectors in last cluster
		; 10/12/2022
		and	ah, ah
		;cmp	ah, 0
		jz	short SetNextClusterNum	; next cluster
		xor	ah, ah
		push	ax		; AX = total clusters in the loader
					; already read in
		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
		mov	cx, [cs:FirstSectorH]
		mov	[cs:StartSecH], cx
		mul	byte [cs:SecPerCluster]
		add	[cs:StartSecL], ax ; Add number of sectors already loaded
		adc	word [cs:StartSecH], 0 ; to start sector
		;mov	ax, [BiosStart]
		mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
		dec	ax
		dec	ax
		xor	bx, bx
		mov	bl, [cs:SecPerCluster]
		mul	bx		; DX:AX = logical start sector
		add	[cs:StartSecL], ax
		adc	[cs:StartSecH], dx
					; abs start sector for next read of
					; the rest of the last loader cluster
		pop	ax
		push	ax
		mul	word [cs:ClusterSize]
		;mov	di, BiosOffset
		mov	di, 700h	; IO.SYS offset	(segment = 0)
		add	di, ax
		xor	ax, ax
		mov	es, ax		; ES = segment 0
		mov	al, [cs:SecPerCluster]
					; Read in the entire last cluster
		mov	[cs:SectorCount], ax
		call	ReadSectors
		pop	ax		; AX = total clust read	by boot	loader
		inc	ax		; AX = total clust read	in now
SetNextClusterNum:			; ...
		inc	ax		; AX = total clusters read in based 2
		add	[cs:CurrentCluster], ax
		dec	ax		; CurrentCluster = Last	cluster	read
					; AX = number of clusters loaded

; SaveLoadedBios
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   Determine how much of iosys was loaded in when the loader was loaded
;   by the boot record (only the portion that is guaranteed to be contiguous)
;
; INPUT:
;   AX:Total cluster already read in (loader & bios)
;   CS:CurrentCluster = number of clusters used for loader+2
;
; OUTPUT:
;	ES = 70h
;	DI = next offset to load iosys code
;	AX,BX,CX,DX,SI destroyed
;
;	CS:NextBioLocation = di on output
;	CS:last_cluster = last cluster loaded
;
; calls:     none
;
; ---------------------------------------------------------------------------
;
; Multiply cluster * cluster size in bytes to get total loaded for msload
;
; Subtract total_loaded - (EndOfLoader) to get loaded io.sys in last cluster
;
; Relocate this piece of iosys down to 70:0
;
; ---------------------------------------------------------------------------

SaveLoadedBios:
		push	ds
		mul	word [cs:ClusterSize]
					; Get total bytes loaded by
					; this is always < 64k, so
					; lower 16 bits ok

		sub	ax, EndOfLoader ; (OFFSET EndOfLoader)-(OFFSET Start)
		mov	cx, ax
		mov	ax, 70h		; Segment at 70h
		mov	ds, ax
		mov	es, ax
		mov	si, EndOfLoader ; EndOfLoader
		xor	di, di
		rep movsb		; Relocate this code to 0070h:0000h
		mov	[cs:NextBioLocation], di
		pop	ds		; Save where location for next read

; GetContigClusters
; ---------------------------------------------------------------------------
;
; NOTES: go find clusters as long as they are contiguous
;
;
; INPUT:
;   CS:NextBioLocation
;   CS:
;
; OUTPUT:
;
; calls: GetNextFatEntry
; ---------------------------------------------------------------------------
;
;Set CS:SectorCount to sectors per cluster
;
;Call GetNextFatEntry to get next cluster in file
;
;Call check_for_eof
;
;if (nc returned)
;
;   {call GetNextFatEntry
;
;    if (new cluster is contig to old cluster)
;	{add sectors per cluster to CS:SectorCount
;
;	 call check_for_eof
;
;	 if (nc returned)
;
; ---------------------------------------------------------------------------

; 09/12/2022
; END_OF_FILE equ 0FFh
; DosLoadSeg equ 70h

GetContigClusters:			; ...
		xor	ah, ah
		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
		push	word [cs:SectorCount]
		call	GetNextFatEntry		; Returns next cluster to read in AX	
		pop	word [cs:SectorCount]
		mov	word [cs:CurrentCluster], ax ; Update the last one found
		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
		jz	short GoToBioInit
		xor	dx, dx
		;sub	ax, 2			; Zero base the cluster
		; 10/12/2022
		dec	ax
		dec	ax
		xor	ch, ch
		mov	cl, [cs:SecPerCluster]
		mul	cx			; How many sectors (before next cluster) 
		add	ax, [cs:FirstSectorL]	; See where the data sector starts
		adc	dx, [cs:FirstSectorH]
		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
		mov	[cs:StartSecH], dx
		mov	di, [cs:NextBioLocation] ; Get where to put code
		push	word [cs:SectorCount]	; Save how many sectors
		;mov	ax, DosLoadSeg
		mov	ax, 70h
		mov	es, ax
		call	ReadSectors
		pop	ax			; Get back total sectors read in
		mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
		add	[cs:NextBioLocation], ax ; Point to where to load next	
		jmp	short GetContigClusters
; ---------------------------------------------------------------------------

; GoToBiosInit
; ---------------------------------------------------------------------------
;
; NOTES:
;
;  Set up required registers for iosys, then jump to it (70:0)
;
; INPUT:     none
;
;   CS:MediaByte = media byte
;   CS:BootDrive = int 13 drive number we booted from
;   CS:FirstSectorL = first data sector on disk (low) (0-based)
;   CS:FirstSectorH = first data sector on disk (high)
;
; OUTPUT:
;
;   required by msinit
;   DL = int 13 drive number we booted from
;   CH = media byte
;   BX = first data sector on disk (0-based)
;   AX = first data sector on disk (high)
;   DI = sectors/fat for the boot media.
;
; calls:     none
; ---------------------------------------------------------------------------
;
; set up registers for msinit then do far jmp
;
; ---------------------------------------------------------------------------

GoToBioInit:				; ...
		mov	ch, [cs:MediaByte] ; Restore regs required for msint
		mov	dl, [cs:BootDrive] ; Physical drv number we booted from.
		mov	bx, [cs:FirstSectorL] ; BX:AX = first data sector of disk
		mov	ax, [cs:FirstSectorH]
		jmp	70h:0	; Far jump to IoSysAddr	(DOSBIOS)

; =============== S U B	R O U T	I N E =======================================

; ReadSectors
; ---------------------------------------------------------------------------
; notES:
;
;  read in the CS:SectorCount number of sectors at ES:di
;
;
; INPUT:
;
;   DI = OFFSET of start of read
;   ES = segment of read
;   CS:SectorCount = number of sectors to read
;   CS:StartSecL = starting sector (low)
;   CS:StartSecH = starting sector (high)
;   following is bpb info that must be setup prior to call
;   CS:NumHeads
;   CS:number_of_sectors
;   CS:BootDrive
;   CS:SecPerTrack
;
; OUTPUT:
;
;   AX,BX,CX,DX,SI,DI destroyed
; ---------------------------------------------------------------------------
; divide start sector by sectors per track
; the remainder is the actual sector number, 0 based
;
; increment actual sector number to get 1 based
;
; the quotient is the number of tracks - divide by heads to get the cyl
;
; the remainder is actual head, the quotient is cylinder
;
; figure the number of sectors in that track, set al to this
;
; do the read
;
; if error, do reset, then redo the int 13h
;
; if successful read, subtract # sectors read from SectorCount, add to logical
; sector, add #sectors read * BytesPerSec to bx;
;
; if SectorCount <> 0 do next read
; ---------------------------------------------------------------------------

ReadSectors:
DoDivide:					; ...
		mov	cx, 5			; 5 retries

		; Convert a logical sector into track/sector/head. AX has the
		; logical sector number
TryRead:					; ...
		push	cx
		mov	ax, [cs:StartSecL]	; Get starting sector
		mov	dx, [cs:StartSecH]
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	word [cs:SecPerTrack]	
		mov	[cs:TempH], ax
		pop	ax
		div	word [cs:SecPerTrack]	; [TempH]:ax = track,
						; dx = sector number
		mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
						; read in this track
		sub	bx, dx
		mov	si, bx
		cmp	[cs:SectorCount], si	; Is possible sectors in track more
		jnb	short GotLength		; than what we need to read?
		mov	si, [cs:SectorCount]	; Yes, only read what we need to
GotLength:				; ...
		;inc	dl			; Sector numbers are 1-based
		; 18/12/2022
		inc	dx
		mov	bl, dl			; Start sector in BL
		mov	dx, [cs:TempH]		; DX:AX = Track
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	word [cs:NumHeads]	; Start cyl in AX, head in dl
		mov	[cs:TempH], ax
		pop	ax
		div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head

			; At this moment, we assume that TempH = 0,
			; ax <= 1024, dx <= 255

		mov	dh, dl
		
		mov	cl, 6
		shl	ah, cl			; Shift cyl high bits up
		or	ah, bl			; Mix in with sector bits
		mov	ch, al			; Setup cyl low
		mov	cl, ah			; Setup cyl/high - sector
		mov	bx, di			; Get back OFFSET
		mov	dl, [cs:BootDrive]	; Get drive
		mov	ax, si			; Get number of sectors to read (al)
		mov	ah, 2			; Read sectors
		push	ax
		push	di

			; Issue one read request. ES:BX have the transfer address,
			; AL is the number of sectors.	

		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	di
		pop	ax
		pop	cx		; Get retry count back
		jnb	short ReadOk
		mov	bx, di		; Get offset
		xor	ah, ah
		push	cx
		mov	dl, [cs:BootDrive]
		push	di
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		pop	di
		pop	cx
		dec	cx
		jz	short ReadError
		jmp	TryRead
; ---------------------------------------------------------------------------

ReadError:				; ...
		jmp	ErrorOut
; ---------------------------------------------------------------------------

ReadOk:					; ...
		xor	ah, ah		; Mask out read command, just get # read
		sub	[cs:SectorCount], ax ; Bump number down
		jz	short EndRead
		add	[cs:StartSecL], ax	; Where to start next time
		adc	word [cs:StartSecH], 0
		;xor	bx, bx			; Get number sectors read
		;mov	bl, al
		; 10/12/2022
		mov	bx, ax
		mov	ax, [cs:BytesPerSec]	; Bytes per sector
		mul	bx			; Get total bytes read	
		add	di, ax			; Add it to OFFSET
		;jmp	DoDivide	; 09/12/2022
		jmp	ReadSectors
; ---------------------------------------------------------------------------
	
EndRead:				; ...
		retn

; =============== S U B	R O U T	I N E =======================================

; GetNextFatEntry
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   given the last cluster found, this will return the next cluster of
;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
;   of iosys has been loaded, and control is passed to goto_iosys
;   msload can handle maximum fat area size of 128 kb.
;
; INPUT:
;
;    CS:CurrentCluster
;    CS:FatSize
;
; OUTPUT:
;
;   CS:CurrentCluster (updated)
;
; calls:  GetFatSector
; ---------------------------------------------------------------------------
; get CurrentCluster
;
; if (16 bit fat)
;    {if (CurrentCluster = fff8 - ffff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by multiply cluster by 2}
;
; else
;    {if (CurrentCluster = ff8 - fff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by	- multiply cluster by 3
;
;	 rotate right to divide by 2
;
;	 if (cy set - means odd number)
;	    {shr 4 times to keep high twelve bits}
;
;	 else
;	    {and with 0fffh to keep low 12 bits}
;	}
;    }
;
; ---------------------------------------------------------------------------

; 09/12/2022
; FAT_12_BIT equ 1
; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh

GetNextFatEntry:			; ...
		push	es
		mov	ax, [cs:FatSegment]
		mov	es, ax		; ES-> FAT area segment
		; 09/12/2022
		;mov	byte [cs:EndOfFile], END_OF_FILE
		mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
		mov	ax, [cs:CurrentCluster] ; Get last cluster
		;cmp	byte [cs:FatSize], FAT_12_BIT
		cmp	byte [cs:Fatsize], 1
		jnz	short Got16Bit
		mov	si, ax
		shr	ax, 1
		add	si, ax		 ; SI = AX * 1.5 = AX + AX/2
		push	dx
		xor	dx, dx
		call	GetFatSector
		pop	dx
		jnz	short ClusterOk
		mov	al, [es:bx]
		mov	[cs:TempCluster], al
		inc	si
		push	dx
		xor	dx, dx
		call	GetFatSector	; Read next fat sector
		pop	dx
		mov	al, [es:0]
		mov	[cs:TempCluster+1], al
		mov	ax, [cs:TempCluster]
		jmp	short EvenOdd
; ---------------------------------------------------------------------------

ClusterOk:				; ...
		mov	ax, [es:bx]
EvenOdd:	
		; 10/12/2022		; ...
		test	byte [cs:CurrentCluster], 1 ; 09/12/2022
		;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
		jnz	short OddResult		; If not zero it was odd
		and	ax, 0FFFh		; Keep low 12 bits
		jmp	short TestEOF
; ---------------------------------------------------------------------------

OddResult:				; ...
		mov	cl, 4			; Keep high 12 bits for odd
		shr	ax, cl
TestEOF:				; ...
		cmp	ax, 0FF8h		; Is it last cluster?
		jnb	short GotClusterDone	; Yep, all done here
		jmp	short NotLastCluster
; ---------------------------------------------------------------------------

Got16Bit:				; ...
		push	dx
		xor	dx, dx
		shl	ax, 1			; Multiply cluster by 2
		adc	dx, 0
		mov	si, ax			; Get the final buffer OFFSET
		call	GetFatSector
		pop	dx
		mov	ax, [es:bx]
		cmp	ax, 0FFF8h
		jnb	short GotClusterDone
NotLastCluster:				; ...
		;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
		mov	byte [cs:EndOfFile], 0	; Assume not last cluster

GotClusterDone:				; ...
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

; GetFatSector
; ---------------------------------------------------------------------------
;function: find and read the corresponding fat sector into ES:0
;
;in). SI = offset value (starting from fat entry 0) of fat entry to find.
;     ES = fat sector segment
;     CS:BytesPerSec
;
;out). corresponding fat sector read in.
;      BX = offset value of the corresponding fat entry in the fat sector.
;      CX destroyed.
;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
;      starts at the last byte of the fat sector.  in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value.	(this will only happen with the 12 bit fat).
;
; ---------------------------------------------------------------------------

GetFatSector:				; ...
		push	ax
		push	si
		push	di
		mov	ax, si
		mov	cx, [cs:BytesPerSec]
		div	cx			; AX = Sector number, DX = Offset
		cmp	ax, [cs:LastFatSector]	; The same fat sector?
		jz	short SplitChk		; Don't need to read it again.
		mov	[cs:LastFatSector], ax
		push	dx
		xor	dx, dx
		add	ax, [cs:HiddenSectorsL]
		adc	dx, [cs:HiddenSectorsH]
		add	ax, [cs:ReservSectors]
		adc	dx, 0
		mov	[cs:StartSecL], ax
		mov	[cs:StartSecH], dx	; Set up for ReadSectors
					; ...
		mov	word [cs:SectorCount], 1 ; 1 sector
		xor	di, di
		call	ReadSectors
		pop	dx
		mov	cx, [cs:BytesPerSec]
SplitChk:				; ...
		dec	cx			; CX = SECTOR SIZE - 1
		cmp	dx, cx			; If last byte of sector, splitted entry.
		mov	bx, dx			; set bx to dx
		pop	di
		pop	si
		pop	ax
EndWrite:		; 10/12/2022
		retn

; ---------------------------------------------------------------------------

ErrorOut:				; ...
		push	cs
		pop	ds
		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
		call	WriteTTY

		; Wait for a keypress on the keyboard.
		; Use the bios keyboard interrupt.

		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character

		; We have to restore the address of the original rom disk
		; parameter table to the location at [0:DskAddr]. The address
		; of this original table has been saved previously in
		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
		; has been restored we can reboot by invoking the bootstrap
		; loader bios interrupt.

		xor	bx, bx
		mov	ds, bx
		les	bx, [OrgDasdPtr]
		mov	si, DskAddr	; (Int 1Eh)
		mov	[si], bx	; restore offset		
		mov	[si+2], es	; restore segment
		int	19h		; reboot

; =============== S U B	R O U T	I N E =======================================

; WriteTTY
; ---------------------------------------------------------------------------
; in) DS:si -> asciiz string.
;
; WriteTTY the character in al to the screen.
; use video service 'write teletype to active page' (ROM_TTY)
; use normal character attribute
; ---------------------------------------------------------------------------

WriteTTY:				; ...
		lodsb
		or	al, al
		jz	short EndWrite
		;mov	AH, ROM_TTY	; 09/12/2022
		mov	ah, 0Eh
		mov	bl, 7		; "normal" attribute
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short WriteTTY
; ---------------------------------------------------------------------------

; 10/12/2022	
;EndWrite:				; ...
;		retn

; ---------------------------------------------------------------------------

; 09/12/2022
;include msbio.cl1

		; 20/12/2022
		; 18/12/2022
		;db 0	; (word alignment)
NonSystemDiskMsg:
		db 0Dh,0Ah		; ...
		db 'Non-System disk or disk error',0Dh,0Ah
		db 'Replace and press any key when ready',0Dh,0Ah,0
EndOfLoader:
		;dw 01A1h	; 10/12/2022

; ---------------------------------------------------------------------------
