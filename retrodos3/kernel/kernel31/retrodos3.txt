     1                                  ; ****************************************************************************
     2                                  ; RETRODOS.SYS (MSDOS 3.3 Kernel) - RETRO DOS v3.1 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 10/07/2024 (BugFix) - (Previous: 22/01/2024)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 25/05/2018 (Retro DOS 3.0), 29/06/2019 (Retro DOS 3.1)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.14  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm retrodos.asm -l retrodos.txt -o MSDOS.SYS)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; This assembly file has three parts: (BIOS+SYSINIT+KERNEL in one kernel file)
    13                                  ; 1a) IBMBIO.COM (IO.SYS) part from beginning to '%incbin MSDOS.BIN'
    14                                  ; 1b) SYSINIT part (at the end of IBMBIO.COM/IO.SYS) as '%incbin SYSINIT.BIN'
    15                                  ; 2) MSDOS.SYS (MSDOS 3.3 Kernel) as included binary file (MSDOS.BIN).
    16                                  ; source : 'retrodos.s' (main), 'sysinit.s' (included), 'msdos.s' (included)	
    17                                  ;
    18                                  ; (Note: RETRO DOS 3.0 boot sector code will load 'MSDOS.SYS' at 1000h:0000h)
    19                                  ; (Original MSDOS 3.3 IBMBIO.COM loads/runs its own init code at 0070h:0000h)
    20                                  
    21                                  ;=============================================================================
    22                                  ; Modified from 'retrodos3.s', Retro DOS v3.0 Kernel Source code
    23                                  ; by Erdogan Tan, 20/05/2019
    24                                  ;=============================================================================
    25                                  
    26                                  ; MSBIO (IO.SYS 3.3) source files:
    27                                  ; 	MSBIO1.ASM,MSCON.ASM,MSAUX.ASM,MSLPT.ASM,MSCLOCK.ASM,MSDISK.ASM
    28                                  ;	MSBIO2.ASM,MSHARD.ASM,MSINIT.ASM 
    29                                  ;	SYINIT1.ASM,SYSCONF.ASM,SYSINIT2.ASM,SYSIMES.ASM
    30                                  
    31                                  ;=============================================================================
    32                                  ; MSBIO
    33                                  ;=============================================================================
    34                                  ;msbio1+mscon+msaux+mslpt+msclock+msdisk+
    35                                  ;msbio2+mshard+msinit+sysinit1+sysconf+sysinit2+sysimes,
    36                                  ;msbio
    37                                  
    38                                  SECTOR_SIZE     equ     0200h		; size of a sector
    39                                  PAUSE_KEY       equ     7200h		; scancode + charcode of PAUSE key
    40                                  KEYBUF_NEXT     equ     041Ah		; next character in keyboard buffer
    41                                  KEYBUF_FREE     equ     041Ch		; next free slot in keyboard buffer
    42                                  KEYBUF          equ     041Eh		; keyboard buffer data
    43                                  LOGICAL_DRIVE   equ     0504h		; linear address of logical drive byte
    44                                  ;DOS_SEGMENT	equ     00BFh ; v1.1	; segment in which DOS will run
    45                                  DOS_SEGMENT	equ     00C4h		; Retro DOS v1.0 - 13/02/2018
    46                                  BIO_SEGMENT     equ     0060h		; segment in which BIO is running
    47                                  
    48                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "DISKPRM.INC" - 24/07/1987)
    49                                  ; The following structure defines the disk parameter table
    50                                  ; pointed to by Interrupt vector 1EH (location 0:78H)
    51                                  
    52                                  struc	DISK_PARMS
    53 00000000 ??                      .DISK_SPECIFY_1:  resb	1
    54 00000001 ??                      .DISK_SPECIFY_2:  resb	1
    55 00000002 ??                      .DISK_MOTOR_WAIT: resb  1	; Wait till motor off
    56 00000003 ??                      .DISK_SECTOR_SIZ: resb 	1	; Bytes/Sector (2 = 512)
    57 00000004 ??                      .DISK_EOT:	  resb  1	; Sectors per track (MAX)
    58 00000005 ??                      .DISK_RW_GAP:	  resb  1	; Read Write Gap
    59 00000006 ??                      .DISK_DTL:	  resb	1
    60 00000007 ??                      .DISK_FORMT_GAP:  resb  1	; Format Gap Length
    61 00000008 ??                      .DISK_FILL:	  resb  1	; Format Fill Byte
    62 00000009 ??                      .DISK_HEAD_STTL:  resb  1	; Head Settle Time (MSec)
    63 0000000A ??                      .DISK_MOTOR_STRT: resb  1	; Motor start delay
    64                                  .size:
    65                                  endstruc
    66                                  
    67                                  ROMStatus	equ	1
    68                                  ROMRead 	equ	2
    69                                  ROMWrite	equ	3
    70                                  ROMVerify	equ	4
    71                                  ROMFormat	equ	5  
    72                                  
    73                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "MSBDS.INC" - 24/07/1987)
    74                                  ; -------------------------------------------------------------------------
    75                                  ;  BDS is the Bios Data Structure.
    76                                  ;
    77                                  ;  There is one BDS for each logical drive in the system.  All the BDS's
    78                                  ;  are linked together in a list with the pointer to the first BDS being
    79                                  ;  found in START_BDS.	The BDS hold various values important to the disk
    80                                  ;  drive.  For example there is a field for last time accesses.  As actions
    81                                  ;  take place in the system the BDS are update to reflect the actions.
    82                                  ;  For example is there is a read to a disk the last access field for the
    83                                  ;  BDS for that drive is update to the current time.
    84                                  ;
    85                                  ; Values for various flags in BDS.Flags.
    86                                  ;
    87                                  
    88                                  fNon_Removable	    equ     01H 	;For non-removable media
    89                                  fChangeline	    equ     02H 	;If changeline supported on drive
    90                                  RETURN_FAKE_BPB     equ     04H 	; When set, don't do a build BPB
    91                                  					; just return the fake one
    92                                  GOOD_TRACKLAYOUT    equ     08H 	; The track layout has no funny sectors
    93                                  fI_Am_Mult	    equ     10H 	;If more than one logical for this physical
    94                                  fI_Own_Physical     equ     20H 	;Signify logical owner of this physical
    95                                  fChanged	    equ     40H 	;Indicates media changed
    96                                  SET_DASD_true	    equ     80H 	; Set DASD before next format
    97                                  fChanged_By_Format  equ    100h
    98                                  
    99                                  ;
   100                                  ; Various form factors to describe media
   101                                  ;
   102                                  
   103                                  ff48tpi 	    equ     0
   104                                  ff96tpi 	    equ     1
   105                                  ffSmall 	    equ     2
   106                                  ffHardFile	    equ     5
   107                                  ffOther 	    equ     7
   108                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
   109                                  ff288		    equ     9	; 2.88 MB drive
   110                                  ; Retro DOS v2.0 feature only !
   111                                  ff144		    equ	   10	; 1.44 MB drive			
   112                                  
   113                                  struc	BDS	; BDS_Type
   114 00000000 ????????                .Link:		resd 1		; Link to next BDS
   115 00000004 ??                      .DriveNum:	resb 1		; Physical drive number
   116 00000005 ??                      .DriveLet:	resb 1		; DOS drive number
   117 00000006 ????                    .BytePerSec:	resw 1		; number of bytes/sec
   118 00000008 ??                      .SecPerClus:	resb 1		; sec per allocation unit
   119 00000009 ????                    .RESSEC:	resw 1		; number of reserved sectors
   120 0000000B ??                      .cFAT:		resb 1		; number of fats
   121 0000000C ????                    .cDir:		resw 1		; number of directory entries
   122 0000000E ????                    .DRVLIM:	resw 1		; number of sectors on medium
   123 00000010 ??                      .Mediad:	resb 1		; media descriptor byte
   124 00000011 ????                    .cSecFat: 	resw 1		; number of sectors/fat
   125 00000013 ????                    .SECLIM:	resw 1		; sectors per track
   126 00000015 ????                    .HDLIM:		resw 1		; max number of heads
   127 00000017 ????                    .HIDSEC:	resw 1		; number of hidden sectors
   128 00000019 ??                      .FatSiz:	resb 1		; flags...
   129 0000001A ????                    .Opcnt:		resw 1		; Open ref. count
   130 0000001C <res Ch>                .Volid:		resb 12		; volume ID of medium
   131 00000028 ??                      .FormFactor:	resb 1		; form factor index
   132 00000029 ????                    .Flags:		resw 1		; various flags
   133 0000002B ????                    .cCyln:		resw 1		; max number of cylinders
   134 0000002D ????                    .RBytePerSec:	resw 1		; Recommended BPB
   135 0000002F ??                      .RSecPerClus:	resb 1
   136 00000030 ????                    .RRESSEC: 	resw 1
   137 00000032 ??                      .RcFAT:		resb 1
   138 00000033 ????                    .RcDir:		resw 1
   139 00000035 ????                    .RDRVLIM: 	resw 1
   140 00000037 ??                      .Rmediad: 	resb 1
   141 00000038 ????                    .RcSecFat:	resw 1
   142 0000003A ????                    .RSECLIM: 	resw 1
   143 0000003C ????                    .RHDLIM:	resw 1
   144 0000003E ????                    .RHIDSEC: 	resw 1
   145 00000040 ????                    .RHHIDSEC:	resw 1
   146 00000042 ????????                .RLOGSEC: 	resd 1
   147 00000046 ????????????            .Reserve: 	resb 6		; Reserved for future
   148 0000004C ??                      .Track:		resb 1		; last track accessed on drive
   149 0000004D ????                    .TIM_LO:	resw 1		; Time of last access. Keep
   150 0000004F ????                    .TIM_HI:	resw 1		; these contiguous.
   151                                  .size: ; 81 bytes ; 02/08/2019
   152                                  endstruc
   153                                  
   154                                  BPBSize	equ	BDS.Track - BDS.RBytePerSec 
   155                                  				; size in bytes of RecBPB area in the BDS
   156                                  
   157                                  ; 23/03/2018
   158                                  
   159                                  ;STATIC REQUEST HEADER (DEVSYM.INC, MSDOS 6.0, 1991)
   160                                  STRUC SRHEAD
   161 00000000 ??                      .REQLEN:	resb 1		;LENGTH IN BYTES OF REQUEST BLOCK
   162 00000001 ??                      .REQUNIT:	resb 1		;DEVICE UNIT NUMBER
   163 00000002 ??                      .REQFUNC:	resb 1		;TYPE OF REQUEST
   164 00000003 ????                    .REQSTAT:	resw 1		;STATUS WORD
   165 00000005 ????????????????        	       	resb 8		;RESERVED FOR QUEUE LINKS
   166                                  .size:
   167                                  endstruc
   168                                  
   169                                  ; GENERIC IOCTL REQUEST STRUCTURE (DEVSYM.INC, MSDOS 6.0, 1991)
   170                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
   171                                  ;
   172                                  struc IOCTL_REQ
   173                                  	       ;DB    (SIZE SRHEAD) DUP(?)
   174 00000000 <res Dh>                		resb SRHEAD.size	
   175                                  			    	; GENERIC IOCTL ADDITION.
   176 0000000D ??                      .MAJORFUNCTION:	resb 1		;FUNCTION CODE
   177 0000000E ??                      .MINORFUNCTION:	resb 1		;FUNCTION CATEGORY
   178 0000000F ????                    .REG_SI:	resw 1
   179 00000011 ????                    .REG_DI:	resw 1
   180 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
   181                                  endstruc
   182                                  
   183                                  ; GENERIC IOCTL CATEGORY CODES  (IOCTL.INC, MSDOS 6.0, 1991)
   184                                  IOC_OTHER	EQU	0	; Other device control J.K. 4/29/86
   185                                  IOC_SE		EQU	1	; SERIAL DEVICE CONTROL
   186                                  IOC_TC		EQU	2	; TERMINAL CONTROL
   187                                  IOC_SC		EQU	3	; SCREEN CONTROL
   188                                  IOC_KC		EQU	4	; KEYBOARD CONTROL
   189                                  IOC_PC		EQU	5	; PRINTER CONTROL
   190                                  IOC_DC		EQU	8	; DISK CONTROL (SAME AS RAWIO)
   191                                  
   192                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
   193                                  GEN_IOCTL_WRT_TRK   EQU   40H
   194                                  GEN_IOCTL_RD_TRK    EQU   60H
   195                                  GEN_IOCTL_FN_TST    EQU   20H	; USED TO DIFF. BET READS AND WRTS
   196                                  
   197                                  ;struc A_RETRYCOUNT  ; (IOCTL.INC, MSDOS 6.0, 1991)
   198                                  ;.RC_COUNT:	resw 	1
   199                                  ;endstruc
   200                                  
   201                                  ; 27/03/2018 - DEVSYM.INC - MSDOS 3.3 - 24/07/1987
   202                                  
   203                                  ;
   204                                  ; ATTRIBUTE BIT MASKS
   205                                  ;
   206                                  ; CHARACTER DEVICES:
   207                                  ;
   208                                  ; BIT 15 -> MUST BE 1
   209                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   210                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
   211                                  ;     12 -> UNUSED
   212                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
   213                                  ;     10 -> MUST BE 0
   214                                  ;      9 -> MUST BE 0
   215                                  ;      8 -> UNUSED
   216                                  ;      7 -> UNUSED
   217                                  ;      6 -> UNUSED
   218                                  ;      5 -> UNUSED
   219                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
   220                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
   221                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
   222                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
   223                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
   224                                  ;
   225                                  ; BLOCK DEVICES:
   226                                  ;
   227                                  ; BIT 15 -> MUST BE 0
   228                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   229                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
   230                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
   231                                  ;	    THE SAME PLACE.
   232                                  ;     12 -> UNUSED
   233                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
   234                                  ;     10 -> MUST BE 0
   235                                  ;      9 -> MUST BE 0
   236                                  ;      8 -> UNUSED
   237                                  ;      7 -> UNUSED
   238                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
   239                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
   240                                  ;      5 -> UNUSED
   241                                  ;      4 -> UNUSED
   242                                  ;      3 -> UNUSED
   243                                  ;      2 -> UNUSED
   244                                  ;      1 -> UNUSED
   245                                  ;      0 -> UNUSED
   246                                  ;
   247                                  
   248                                  DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   249                                  CHARDEV        EQU   8000H
   250                                  DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
   251                                  ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
   252                                  				    ;  COMP MEDIA.
   253                                  OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
   254                                  ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
   255                                  				    ;  NOT.  CURRENTLY BLOCK ONLY.
   256                                  DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
   257                                  				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
   258                                  				    ;  ENTRY POINTS, 0 IF NOT
   259                                  
   260                                  EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
   261                                  				    ;  THIS BIT IS RESERVED FOR FUTURE USE
   262                                  				    ;  TO EXTEND THE DEVICE HEADER BEYOND
   263                                  				    ;  ITS CURRENT FORM.
   264                                  
   265                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
   266                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
   267                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
   268                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
   269                                  
   270                                  DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
   271                                  				    ;DEVICE SUPPORTS SET/GET MAP OF
   272                                  				    ;LOGICAL DRIVES, AND SUPPORTS
   273                                  				    ;GENERIC IOCTL CALLS.
   274                                  				    ;FOR CHARACTER DEVICES, THIS
   275                                  				    ;DEVICE SUPPORTS GENERIC IOCTL.
   276                                  				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
   277                                  ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
   278                                  ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
   279                                  ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
   280                                  ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
   281                                  ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
   282                                  
   283                                  
   284                                  ; 19/03/2018
   285                                  
   286                                  ;*********************************************************************
   287                                  ;	BDS structure for mini disk
   288                                  ;*********************************************************************	  
   289                                  									  
   290                                  struc	BDSM	; BDSM_type
   291 00000000 ????                    .mLink:		resw	1 ; DW -1		;Link to next structure   
   292 00000002 ????                    		resw	1 ; DW ?
   293 00000004 ??                      .mDriveNum:	resb	1 ; DB 80h		;Int 13 Drive Number	  
   294 00000005 ??                      .mDriveLet:	resb	1 ; DB 3		;Logical Drive Number	  
   295 00000006 ????                    .mBytePerSec:	resw 	1 ; DW 512
   296 00000008 ??                      .mSecPerClus:	resb	1 ; DB 1		;Sectors/allocation unit  
   297 00000009 ????                    .mRESSEC:	resw	1 ; DW 1		;Reserved sectors for DOS 
   298 0000000B ??                      .mcFAT:		resb	1 ; DB 2		;No. of allocation tables 
   299 0000000C ????                    .mcDIR:		resw	1 ; DW 16		;Number of directory entries
   300 0000000E ????                    .mDRVLIM:	resw 	1 ; DW 0		;Num of sectors (at 512 bytes each)
   301 00000010 ??                      .mMediad:	resb	1 ; DB 11111000b	;Media descriptor	  
   302 00000011 ????                    .mcSecFat:	resw 	1 ; DW 1		;Number of FAT sectors	  
   303 00000013 ????                    .mSECLIM:	resw 	1 ; DW 0		;Sector limit		  
   304 00000015 ????                    .mHDLIM:	resw	1 ; DW 0		;Head limit		  
   305 00000017 ????                    .mHIDSEC:	resw 	1 ; DW 0		;Hidden sector count	  
   306 00000019 ??                      .mFatSiz:	resb 	1 ; DB 0		;TRUE => bigfat 	  
   307 0000001A ????                    .mOPCNT:	resw	1 ; DW 0		;Open Ref. Count	  
   308 0000001C <res Bh>                .mVOLID:	resb   11 ; DB "NO NAME    "    ;Volume ID for this disk  
   309 00000027 ??                      		resb 	1 ; DB 0		;ASCIZII for "NO NAME    "
   310 00000028 ??                      .mFormFactor:	resb 	1 ; DB 3		;Form Factor		  
   311 00000029 ????                    .mFLAGS:	resw	1 ; DW 0020H		;Various Flags		  
   312 0000002B ????                    .mcCyln:	resw	1 ; DW 40		;max number of cylinders  
   313 0000002D <res 1Fh>               .mRecBPB:	resb   31 ; DB 31 DUP (0) 	;Recommended BPB for drive
   314 0000004C ??                      .mTrack:	resb	1 ; DB -1						  
   315 0000004D ????                    .isMini:	resw	1 ; DW 1		;Overlapping TIM_LOH	  
   316 0000004F ????                    .Hidden_Trks:	resw 	1 ; DW 0		;Overlapping TIM_HIH	  
   317                                  									  
   318                                  ;.TIM_LOH:	resw	1 ; DW -1		;Keep these two contiguous (?)   
   319                                  ;.TIM_HIH:	resw	1 ; DW -1
   320                                  .size:	; 81 bytes ; 02/08/2019						  
   321                                  
   322                                  endstruc
   323                                  
   324                                  ; 27/05/2018 - Retro DOS v3.0 
   325                                  ; [MSDOS 3.3, MSDISK.ASM]
   326                                  
   327                                  struc INT13FRAME
   328 00000000 ????                    .oldbp:	resw 1
   329 00000002 ????                    .oldax:	resw 1
   330 00000004 ????                    .oldbx:	resw 1
   331 00000006 ????                    .oldcx:	resw 1
   332 00000008 ????                    .olddx:	resw 1
   333 0000000A ????????                .olddd:	resd 1
   334 0000000E ????                    .oldf:	resw 1
   335                                  .size:
   336                                  endstruc
   337                                  
   338                                  ; 02/06/2018 - Retro DOS v3.0
   339                                  ; [MSDOS 3.3, BIOSTRUC.INC]
   340                                  
   341                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   342 00000000 ????                    .bios_SD_leng:		resw 1				  
   343 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   344                                  .bios_SD_scnd_modelbyte: 
   345 00000003 ??                      			resb 1					  
   346 00000004 ??                      			resb 1					  
   347 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   348 00000006 ????????                			resb 4					  
   349                                  endstruc
   350                                  							  
   351                                  ;******************************************************************************
   352                                  Max_mini_dsk_num equ	23		; Max # of mini disk bios can support
   353                                  
   354                                  
   355                                  KERNEL_SEGMENT	equ 0070h  ; Retro DOS v2.0 - 17/03/2018
   356                                  
   357                                  ;-----------------------------------------------------------------------------
   358                                  ; Start of code
   359                                  ;-----------------------------------------------------------------------------
   360                                  
   361                                          	[ORG 0]			; segment 0x0060
   362                                  
   363                                  ;-----------------------------------------------------------------------------
   364                                  ; MSDATA.INC - MSDOS 3.3 BIOS - 24/07/1987
   365                                  ;-----------------------------------------------------------------------------
   366                                  ; 21/03/2018 - Retro DOS v2.0
   367                                  
   368                                  START$:
   369 00000000 E91D2A                  		JMP	INIT		; START$ patch by init to point to
   370                                  					; hdrive BPB
   371                                  
   372                                  SYS_INIT_START EQU SYSINIT_START - START$
   373                                  KERNEL_BYTES EQU END_OF_KERNEL - START$
   374                                  MSDOS_BIN_ADDR EQU MSDOS_BIN_OFFSET - START$  ; 26/09/2019
   375                                  
   376                                  ; Retro DOS v2.0
   377                                  ;%define SYSINITSEG SYS_INIT_START >> 4 ; 26/03/2018
   378                                  ;%define MSDOS_BIN_SEGMENT MSDOS_BIN_ADDRESS >> 4 ; 26/03/2018 
   379                                  ;%define KERNEL_SIZE KERNEL_BYTES >> 1  ; 26/03/2018
   380                                  
   381                                  ; Retro DOS v4.0 - v3.1
   382                                  ;%define SYSINIT_SEG (KERNEL_SEGMENT+(SYS_INIT_START >> 4)) ; 11/05/2019
   383                                  %define MSDOS_BIN_SEGMENT (KERNEL_SEGMENT+(MSDOS_BIN_ADDR >> 4)) ; 11/05/2019 
   384                                  %define KERNEL_SIZE (KERNEL_BYTES >> 1) ; 24/04/2019
   385                                  
   386                                  ; 29/06/2019 - Retro DOS v3.1
   387                                  
   388                                  ; Hard-wire the link to the next Int2f handler.
   389                                  ;;Rev 3.30 Modification
   390                                  		
   391                                  		;EVENB
   392 00000003 90                      align 2
   393                                  
   394                                  NEXT2F_13:
   395                                  		; 13/06/2018
   396 00000004 [FC19]                  		DW	INT2F_DISK		; MSBIO2.ASM
   397 00000006 7000                    		DW	KERNEL_SEGMENT
   398                                  
   399                                  ; This is a byte used for special key handling in the resident
   400                                  ; console device driver. It must be here so that it can be included
   401                                  ; in the WIN386 instance table (in INC\LMSTUB.ASM).
   402                                  
   403                                  ALTAH:
   404 00000008 00                      		DB	0		;Special key handling
   405                                  
   406                                  ; PTRSAV - pointer save
   407                                  ;
   408                                  ; This variable holds the pointer to the Request Header passed by a program
   409                                  ; wishing to use a device driver. When the strategy routine is called it
   410                                  ; puts the address of the Request header in this variable and returns.
   411                                  
   412                                  	;EVENB
   413 00000009 90                      align 2
   414                                  
   415                                  PTRSAV:
   416 0000000A 00000000                		DD	0
   417                                  
   418                                  AUXBUF:
   419 0000000E 00000000                		DB	0,0,0,0	; SET OF 1 BYTE BUFFERS FOR COM 1,2,3, AND 4
   420                                  
   421                                  
   422                                  ; 12/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987)
   423                                  
   424                                  	; EVENB
   425                                  ;align 2
   426                                  
   427                                  PrevOper:
   428 00000012 0000                    		DW	0	; Holds ROM DISK INT request (i.e. Register AX).
   429                                  Number_Of_Sec:
   430 00000014 00                      		DB	0	; Holds number of sectors to read on an ECC error
   431 00000015 90                      align 2
   432                                  
   433                                  ; AUXNUM holds the number of the printer or AUX device requested.  For
   434                                  ; example if printer 2 was called (PRN2$IN) AUXNUM is set to be one; with
   435                                  ; line printer 3 AUXNUM is set to 2.  With this set the printer device driver
   436                                  ; can tell which printer to command applies to.
   437                                  ;
   438                                  ; WARNING!!!  These are addressed together in GETDX
   439                                  
   440                                  
   441                                  	;EVENB
   442                                  
   443                                  AUXNUM:
   444 00000016 00                      		DB	0
   445 00000017 00                      		DB	0
   446                                  
   447                                  ;align 2
   448                                  ;*****************************************************************************
   449                                  
   450                                  res_dev_list:	; 27/12/2018 (MSDOS 6.0, MSBIO1.ASM)
   451                                  
   452                                  ; 30/04/2019 - Retro DOS v4.0
   453                                  
   454                                  ; 29/06/2019 - Retro DOS v3.1
   455                                  
   456                                  ;
   457                                  ; Device Header for the CON Device Driver
   458                                  ;
   459                                  
   460                                  	;EVENB
   461                                  
   462                                  ;align 2
   463                                  
   464                                  CONHeader:
   465                                  		;DD	AUXDEV2
   466 00000018 [2A00]                  		DW	AUXDEV2
   467 0000001A 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   468 0000001C 1380                    		DW	1000000000010011B	; Con in and con out + special
   469 0000001E [4A06]                  		DW	STRATEGY		; Strategy entry point
   470 00000020 [5506]                  		DW	CON$IN			; interrupt entry point
   471 00000022 434F4E2020202020        		DB	'CON     '              ; device name
   472                                  
   473                                  ;
   474                                  ; Device Header for device "AUX"
   475                                  ;
   476                                  
   477                                  	;EVENB
   478                                  ;align 2
   479                                  
   480                                  AUXDEV2:					;HEADER FOR DEVICE "AUX"
   481                                  		;DD	PRNDEV2
   482 0000002A [3C00]                  		DW	PRNDEV2
   483 0000002C 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   484 0000002E 0080                    		DW	1000000000000000B	; attribute word, character device
   485 00000030 [4A06]                  		DW	STRATEGY		; device strategy routine
   486 00000032 [5B06]                  		DW	AUX0$IN 		; device interrupt routine
   487 00000034 4155582020202020        		DB	'AUX     '              ; device name
   488                                  
   489                                  ;
   490                                  ; Device Header for device PRN
   491                                  ;
   492                                  
   493                                  	;EVENB
   494                                  ;align 2
   495                                  
   496                                  PRNDEV2:					 ;HEADER FOR DEVICE "PRN"
   497                                  		;DD	TIMDEV
   498 0000003C [4E00]                  		DW	TIMDEV
   499 0000003E 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   500 00000040 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   501 00000042 [4A06]                  		DW	STRATEGY
   502 00000044 [7606]                  		DW	PRN0$IN
   503 00000046 50524E2020202020        		DB	'PRN     '
   504                                  
   505                                  ;
   506                                  ; Device Header for device CLOCK$
   507                                  ;
   508                                  
   509                                  	;EVENB
   510                                  ;align 2
   511                                  
   512                                  TIMDEV:
   513                                  		;DD	DSKDEV
   514 0000004E [6000]                  		DW	DSKDEV
   515 00000050 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   516 00000052 0880                    		DW	1000000000001000B
   517 00000054 [4A06]                  		DW	STRATEGY
   518 00000056 [9C06]                  		DW	TIM$IN
   519 00000058 434C4F434B242020        		DB	'CLOCK$  '
   520                                  
   521                                  ;
   522                                  ; Device Header for disk devices
   523                                  ;
   524                                  ;	Device attribute bits:
   525                                  ;		Bit 6 - DOS 3.2 Bit
   526                                  ;
   527                                  
   528                                  	;EVENB
   529                                  ;align 2
   530                                  
   531                                  DSKDEV:
   532                                  		;DD	COM1DEV
   533 00000060 [7400]                  		DW	COM1DEV
   534 00000062 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   535 00000064 4008                    		DW	0000100001000000B	; DOS 3.2
   536 00000066 [4A06]                  		DW	STRATEGY		; strategy routine
   537 00000068 [A206]                  		DW	DSK$IN			; Interrupt entry point
   538                                  
   539                                  ;
   540                                  ; maximum number of drives
   541                                  ;
   542                                  
   543                                  DRVMAX:
   544 0000006A 04                      		DB	4
   545                                  
   546                                  ; 25/05/2018 - Retro DOS 3.0
   547 0000006B FE                      STEP_DRV:	DB	-2
   548 0000006C 00                      PHYS_DRV:	DB	0
   549                                  
   550                                  ; 11/06/2018 - Retro DOS 3.0
   551 0000006D 00                      fHave96:	db	0
   552 0000006E 00                      fHaveK09:	db	0
   553 0000006F 00                      Single:		db	0 ; 13/06/2018
   554 00000070 00                      fSetOwner:	db	0
   555 00000071 00                      NEW_ROM:	db	0
   556 00000072 6B6A                    Secrete_Code:	dw	'kj'		;Code for 3.30.
   557                                  
   558                                  ;
   559                                  ; Device Header for device "COM1"
   560                                  ;
   561                                  
   562                                  	;EVENB
   563                                  
   564                                  align 2
   565                                  
   566                                  COM1DEV:
   567                                  		;DD	LPT1DEV
   568 00000074 [8600]                  		DW	LPT1DEV
   569 00000076 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   570 00000078 0080                    		DW	1000000000000000B ; attribute word, character device
   571 0000007A [4A06]                  		DW	STRATEGY	; device strategy routine
   572 0000007C [5B06]                  		DW	AUX0$IN 	; device interrupt routine
   573 0000007E 434F4D3120202020        		DB	'COM1    '	; device name
   574                                  
   575                                  ;
   576                                  ; Device Header for device LPT1
   577                                  ;
   578                                  
   579                                  	;EVENB
   580                                  ;align 2
   581                                  
   582                                  LPT1DEV:
   583                                  		;DD	LPT2DEV
   584 00000086 [9800]                  		DW	LPT2DEV
   585 00000088 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   586 0000008A 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   587 0000008C [4A06]                  		DW	STRATEGY
   588 0000008E [7C06]                  		DW	PRN1$IN ; 03/08/2019
   589 00000090 4C50543120202020        		DB	'LPT1    '
   590                                  
   591                                  ;
   592                                  ; Device Header for device LPT2
   593                                  ;
   594                                  
   595                                  	;EVENB
   596                                  ;align 2
   597                                  LPT2DEV:
   598                                  		;DD	LPT3DEV
   599 00000098 [B200]                  		DW	LPT3DEV
   600 0000009A 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   601 0000009C 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   602 0000009E [4A06]                  		DW	STRATEGY
   603 000000A0 [8406]                  		DW	PRN2$IN ; 03/08/2019
   604 000000A2 4C50543220202020        		DB	'LPT2    '
   605                                  
   606                                  ; 11/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987) 
   607                                  
   608                                  	;EVENB
   609                                  align 2
   610                                  OLD13:
   611 000000AA 35393836                		db	'5986'		;Code for 3.30
   612                                  ORIG13:
   613 000000AE 32310000                		db	'21',0,0	;Code for 3.30
   614                                  
   615                                  ;
   616                                  ; Device Header for device LPT3
   617                                  ;
   618                                  
   619                                  	;EVENB
   620                                  ;align 2
   621                                  
   622                                  LPT3DEV:
   623                                  		;DD	COM2DEV
   624 000000B2 [C400]                  		DW	COM2DEV
   625 000000B4 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   626 000000B6 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   627 000000B8 [4A06]                  		DW	STRATEGY
   628 000000BA [8C06]                  		DW	PRN3$IN ; 03/08/2019
   629 000000BC 4C50543320202020        		DB	'LPT3    '
   630                                  
   631                                  		; 25/05/2018
   632                                  
   633                                  ;
   634                                  ; Device Header for device "COM2"
   635                                  ;
   636                                  
   637                                  	;EVENB
   638                                  
   639                                  ;align 2
   640                                  
   641                                  COM2DEV:
   642                                  		;DD	COM3DEV
   643 000000C4 [D600]                  		DW	COM3DEV
   644 000000C6 7000                    		DW	KERNEL_SEGMENT
   645 000000C8 0080                    		DW	1000000000000000B	; attribute word, character device
   646 000000CA [4A06]                  		DW	STRATEGY		; device strategy routine
   647 000000CC [6106]                  		DW	AUX1$IN 		; device interrupt routine
   648 000000CE 434F4D3220202020        		DB	'COM2    '              ; device name
   649                                  
   650                                  ;;Rev 3.30 Modification
   651                                  ;
   652                                  ; Device header for device "COM3"
   653                                  ;
   654                                  
   655                                  	;EVENB
   656                                  
   657                                  ;align 2 
   658                                  
   659                                  COM3DEV:
   660                                  		;DD	COM4DEV
   661 000000D6 [E800]                  		DW	COM4DEV
   662 000000D8 7000                    		DW	KERNEL_SEGMENT
   663 000000DA 0080                    		DW	1000000000000000b	; character device attribute
   664 000000DC [4A06]                  		DW	STRATEGY
   665 000000DE [6706]                  		DW	AUX2$IN			; com3 == aux2
   666 000000E0 434F4D3320202020        		DB	'COM3    '
   667                                  
   668                                  ;
   669                                  ; Device header for device "COM4"
   670                                  ;
   671                                  
   672                                  	;EVENB
   673                                  
   674                                  ;align 2 
   675                                  
   676                                  COM4DEV:
   677 000000E8 FFFF                    		DW	-1
   678 000000EA 7000                    		DW	KERNEL_SEGMENT
   679 000000EC 0080                    		DW	1000000000000000b	; character device attribute
   680 000000EE [4A06]                  		DW	STRATEGY
   681 000000F0 [6D06]                  		DW	AUX3$IN			; com4 == aux3
   682 000000F2 434F4D3420202020        		DB	'COM4    '
   683                                  
   684                                  ;
   685                                  ; Start of linked list of BDS's
   686                                  ;
   687                                  
   688                                  		;EVENB
   689                                  ;align 2
   690                                  
   691                                  START_BDS:
   692                                  		; 13/06/2018
   693 000000FA [3003]                         		Dw      BDS1			;START OF BDS LINKED LIST.
   694 000000FC 7000                    		DW	KERNEL_SEGMENT
   695                                  
   696                                  ; Some floppy drives do not have changeline support.  The result is a
   697                                  ; large amount of inefficiency in the code.  A media-check always returns
   698                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
   699                                  ; always discard any cached data.
   700                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
   701                                  ; The following three items are used to do this.  The logical door latch is
   702                                  ; based on the premise that it is not physically possible to change floppy
   703                                  ; disks in a drive in under two seconds (most people take about 10).  The
   704                                  ; logical door latch is implemented by saving the time of the last successful
   705                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
   706                                  ; current time is compared to the saved time.  If less than two seconds have
   707                                  ; passed then the value "No Change" is returned.  If more than two seconds
   708                                  ; have passed the value "Don't Know" is returned.
   709                                  ;    There is one complecation to this algorithm.  Some programs change the
   710                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
   711                                  ; This possibility is detected by counting the number of disk operations
   712                                  ; which occur without any time passing.  If this count exceeds the value of
   713                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
   714                                  ; Know".  The variable "AccessCount" is used to keep track of the number
   715                                  ; of disk operation which occur without the time changing.
   716                                  ;
   717                                  
   718                                  AccessCount:
   719 000000FE 00                      		DB	0		; number of times media check called
   720                                  TIM_DRV:
   721 000000FF FF                      		DB	-1		; time when last disk I/O was performed
   722                                  FlagBits:
   723 00000100 0000                    		DW	0		; Bits to set in flag field when doing
   724                                  					; a Set_Changed_DL
   725                                  MedByt:
   726 00000102 00                      		DB	0		; hold media byte from floppy
   727                                  
   728                                  ;		;EVENB
   729 00000103 90                      align 2
   730                                  		; 13/06/2018
   731                                  WRTVERIFY:
   732                                  RFLAG:
   733 00000104 02                      		DB	ROMRead		;2 for read, 3 for write
   734                                  VERIFY:
   735 00000105 00                      		DB	0		;1 if verify after write
   736                                  SECCNT:
   737 00000106 0000                    		DW	0
   738                                  HARDNUM:
   739 00000108 63                      		DB	99		;logical drive number of first hardfile	
   740                                  
   741                                  ;
   742                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
   743                                  ; have to be made to read the diskette.  Consequently a large head settle
   744                                  ; time was always used in the I/O operations.  To get around this problem
   745                                  ; we need to continually adjust the head settle time.  The following
   746                                  ; algorithm is used:
   747                                  ;
   748                                  ;   Get the current head settle value.
   749                                  ;   If it is 1, then
   750                                  ;	set slow = 15
   751                                  ;   else
   752                                  ;	set slow = value
   753                                  ;   ...
   754                                  ;   if we are seeking and writing then
   755                                  ;	use slow
   756                                  ;   else
   757                                  ;	use fast
   758                                  ;   ...
   759                                  ;   restore current head settle value
   760                                  ;
   761                                  
   762                                  MotorStartup:
   763 00000109 00                      		DB	0			; value from table
   764                                  SettleCurrent:
   765 0000010A 00                      		DB	0			; value from table
   766                                  SettleSlow:
   767 0000010B 00                      		DB	0			; slow settle value
   768                                  NextSpeed:
   769 0000010C 00                       		DB	0			; value of speed to be used
   770                                  Save_head_sttl:
   771 0000010D 00                      		DB	0			;used by READ_SECTOR routine
   772                                  EOT:
   773 0000010E 09                      		DB	9
   774                                  
   775                                  ; 11/06/2018
   776                                  
   777                                  ;
   778                                  ; pointer to Disk Parameter Table
   779                                  ;
   780                                  ;
   781                                  ;		;EVENB
   782 0000010F 90                      align 2
   783                                  DPT:
   784 00000110 00000000                		dd	0
   785                                  
   786                                  ; 13/06/2018
   787                                  ; 23/03/2018
   788                                  ;
   789                                  ; The following two sets of variables are used to hold values for
   790                                  ; disk I/O operations
   791                                  ; Keep the next two items contiguous - see IOCTL_Block for reason
   792                                  
   793                                  CURSEC:	
   794 00000114 00                      		DB	0			; current sector
   795                                  CURHD:
   796 00000115 00                      		DB	0			; current head
   797                                  CURTRK:
   798 00000116 0000                    		DW	0			; current track
   799                                  SPSAV:
   800 00000118 0000                    		DW	0			; save the stack pointer
   801                                  
   802                                  ;
   803                                  ; The following are used for IOCTL function calls
   804                                  ;
   805                                  
   806                                  ; 11/06/2018 - Retro DOS v3.0
   807                                  FORMT_EOT:
   808 0000011A 08                      		DB	8			; EOT used for format
   809                                  HDNUM:
   810 0000011B 00                      		DB	0			; Head number
   811                                  TRKNUM:
   812 0000011C 0000                    		DW	0			; Track being manipulated
   813                                  GAP_PATCH:
   814 0000011E 50                      		DB	50h			; Format gap patched into DPT
   815                                  
   816                                  ;
   817                                  ; Disk errors returned from the IBM rom
   818                                  ;
   819                                  
   820                                  ERRIN:
   821 0000011F 80                      		DB	80H			; no response
   822 00000120 40                      		DB	40H			; seek failure
   823 00000121 10                      		DB	10H			; bad CRC
   824 00000122 08                      		DB	8			; DMA overrun
   825 00000123 06                      		DB	6			; media change
   826 00000124 04                      		DB	4			; sector not found
   827 00000125 03                      		DB	3			; write attempt to write-protect disk
   828                                  LSTERR:
   829 00000126 00                      		DB	0			; all other errors
   830                                  
   831                                  ;
   832                                  ; returned error code corresponding to above errors
   833                                  ;
   834                                  
   835                                  ERROUT:
   836 00000127 02                      		DB	2			; no response
   837 00000128 06                      		DB	6			; seek failure
   838 00000129 04                      		DB	4			; bad CRC
   839 0000012A 04                      		DB	4			; DMA overrun
   840 0000012B 0F                      		DB	15			; invalid media change
   841 0000012C 08                      		DB	8			; sector not found
   842 0000012D 00                      		DB	0			; write attempt on write-protect disk
   843 0000012E 0C                      		DB	12			; general error
   844                                  
   845                                  NUMERR	EQU	ERROUT-ERRIN
   846                                  
   847 0000012F 90                      align 2
   848                                  
   849                                  ;-------------------------------------------------------------
   850                                  ;
   851                                  ; DiskSector is a 512 byte sector into which the boot sector
   852                                  ; is read. It is also used as read sector for DMA check for
   853                                  ; hard disk.
   854                                  
   855                                  DiskSector:
   856                                  		;db	11 dup(?)	   ; take care of 3 jump bytes plus OEM name.
   857 00000130 00<rep Bh>              		times	11 db 0
   858                                  BPB_In_Sector:
   859 0000013B 0000                    		dw	0
   860                                  SECPERCLUSINSECTOR:
   861 0000013D 00                      		db	0
   862 0000013E 0000                    		dw	0
   863 00000140 00                      		db	0
   864 00000141 0000                    		dw	0
   865 00000143 0000                    		dw	0
   866                                  MediaByte:
   867 00000145 00                      		db	0
   868 00000146 0000                    		dw	0
   869 00000148 0000                    		dw	0
   870 0000014A 0000                    		dw	0
   871 0000014C 0000                    		dw	0
   872 0000014E 00                      		db	0
   873                                  		;db	512-($-DiskSector) dup (?)
   874 0000014F 00<rep 1E1h>            		times	512-($-DiskSector) db 0
   875                                  
   876                                  ; 29/06/2019 - Retro DOS v3.1
   877                                  
   878                                  ; 25/05/2018 (04/04/2018)
   879                                  
   880                                  ;---------------------------------------------------------------------
   881                                  ;
   882                                  ;	The "BDS"'s contain information for each drive in the system.
   883                                  ;  There is one BDS for each logical drvie in the system.  The BDS's
   884                                  ;  are all linked together in a chain.	The BDS contain various values
   885                                  ;  important to the disk drive. Various values are updated whenever actions
   886                                  ;  are performed.  For example if a drive is read from the last time
   887                                  ;  accessed fields are updated to the current time.
   888                                  ;	Initial values:
   889                                  ;    *	Sectors/Alloc. unit in BPB initially set to -1 to signify that
   890                                  ;	the BPB has not been filled.
   891                                  ;    *	Link is set to -1 to signify end of list.
   892                                  ;    *	number of cylinders in MaxParms initialized to -1 to indicate
   893                                  ;	that the parameters have not been set.
   894                                  ;
   895                                  ;  START_BDS contains a pointer to the first BDS.  It is through this
   896                                  ;  pointer that routines find particular BDS (see SetDrive to see how
   897                                  ;  this is done).
   898                                  ;
   899                                  
   900                                  	;EVENB
   901                                  ;align 2
   902                                  
   903                                  BDS1:
   904                                  		;DD	BDS2			;LINK TO NEXT STRUCTURE
   905 00000330 [8203]                  		DW	BDS2
   906 00000332 7000                    		DW	KERNEL_SEGMENT  ; 28/03/2018
   907 00000334 00                      		DB	0			;ROM DISK INT Drive Number
   908 00000335 00                      		DB	0			;Logical Drive Letter
   909                                  FDRIVE1:
   910 00000336 0002                    		DW	512			;Physical sector size in bytes
   911 00000338 FF                      		DB	-1			;Sectors/allocation unit
   912 00000339 0100                    		DW	1			;Reserved sectors for DOS
   913 0000033B 02                      		DB	2			;No. allocation tables
   914 0000033C 4000                    		DW	64			;Number directory entries
   915 0000033E 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
   916 00000340 00                      		DB	00000000b		;Media descriptor, initially 00H.
   917 00000341 0200                    		DW	2			;Number of FAT sectors
   918 00000343 0900                    		DW	9			;Sector limit
   919 00000345 0100                    		DW	1			;Head limit
   920 00000347 0000                    		DW	0			;Hidden sector count
   921 00000349 00                      		DB	0			; TRUE => Large fats
   922                                  OPCNT1:
   923 0000034A 0000                    		DW	0			;Open Ref. Count
   924                                  VOLID1:
   925 0000034C 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
   925 00000355 202000             
   926 00000358 03                      		DB	3			;Form Factor
   927                                  FLAGS1:
   928 00000359 2000                    		DW	0020H			;Various Flags
   929                                  	;	DB	9 dup (0)		;Reserved for future use
   930 0000035B 2800                    		dw	40			; number of cylinders
   931                                  RecBPB1:
   932 0000035D 0002                    		DW	512			;Physical sector size in bytes
   933 0000035F 01                      		DB	1			;Sectors/allocation unit
   934 00000360 0100                    		DW	1			;Reserved sectors for DOS
   935 00000362 02                      		DB	2			;No. allocation tables
   936 00000363 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
   937 00000365 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
   938 00000367 F0                      		DB	0F0h			;Media descriptor, initially 00H.
   939 00000368 0200                    		DW	2			;Number of FAT sectors
   940 0000036A 0900                    		DW	9			;Sector limit
   941 0000036C 0200                    		DW	2			;HEAD LIMIT
   942 0000036E 0000                    		DW	0			;Hidden sector count
   943                                  		;DB	12 DUP (?)
   944 00000370 00<rep Ch>              		times	12 db 0
   945                                  TRACK1:
   946 0000037C FF                      		DB	-1			;Last track accessed on this drive
   947                                  TIM_LO1:
   948 0000037D FFFF                    		DW	-1			;Keep these two contiguous (?)
   949                                  TIM_HI1:
   950 0000037F FFFF                    		DW	-1
   951                                  
   952                                  	;EVENB
   953 00000381 90                      align 2
   954                                  BDS2:
   955                                  		;DD	BDS3			;LINK TO NEXT STRUCTURE
   956 00000382 [D403]                  		DW	BDS3
   957 00000384 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
   958 00000386 00                      		DB	0			;INT 13 DRIVE NUMBER
   959 00000387 00                      		DB	0			;Logical Drive Letter
   960                                  FDRIVE2:
   961 00000388 0002                    		DW	512			;Physical sector size in bytes
   962 0000038A FF                      		DB	-1			;Sectors/allocation unit
   963 0000038B 0100                    		DW	1			;Reserved sectors for DOS
   964 0000038D 02                      		DB	2			;No. allocation tables
   965 0000038E 4000                    		DW	64			;Number directory entries
   966 00000390 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
   967 00000392 00                      		DB	00000000b		;Media descriptor, initially 00H.
   968 00000393 0200                    		DW	2			;Number of FAT sectors
   969 00000395 0900                    		DW	9			;Sector limit
   970 00000397 0100                    		DW	1			;Head limit
   971 00000399 0000                    		DW	0			;Hidden sector count
   972 0000039B 00                      		DB	0			; TRUE => Large fats
   973                                  OPCNT2:
   974 0000039C 0000                    		DW	0			;Open Ref. Count
   975                                  VOLID2:
   976 0000039E 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
   976 000003A7 202000             
   977 000003AA 03                      		DB	3			;Form Factor
   978                                  FLAGS2:
   979 000003AB 2000                    		DW	0020H			;Various Flags
   980                                  	;	DB	9 dup (0)		;Reserved for future use
   981 000003AD 2800                    		dw	40			; number of cylinders
   982                                  RecBPB2:
   983 000003AF 0002                    		DW	512			;Physical sector size in bytes
   984 000003B1 01                      		DB	1			;Sectors/allocation unit
   985 000003B2 0100                    		DW	1			;Reserved sectors for DOS
   986 000003B4 02                      		DB	2			;No. allocation tables
   987 000003B5 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
   988 000003B7 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
   989 000003B9 F0                      		DB	0F0h			;Media descriptor, initially 00H.
   990 000003BA 0200                    		DW	2			;Number of FAT sectors
   991 000003BC 0900                    		DW	9			;Sector limit
   992 000003BE 0200                    		DW	2			;HEAD LIMIT
   993 000003C0 0000                    		DW	0			;Hidden sector count
   994                                  		;DB	12 DUP (?)
   995 000003C2 00<rep Ch>              		times	12 db 0
   996                                  TRACK2:
   997 000003CE FF                      		DB	-1			;Last track accessed on this drive
   998                                  TIM_LO2:
   999 000003CF FFFF                    		DW	-1			;Keep these two contiguous (?)
  1000                                  TIM_HI2:
  1001 000003D1 FFFF                    		DW	-1
  1002                                  
  1003                                  	;EVENB
  1004 000003D3 90                      align 2
  1005                                  BDS3:
  1006                                  		;DD	BDS4			;LINK TO NEXT STRUCTURE
  1007 000003D4 [2604]                  		DW	BDS4
  1008 000003D6 7000                    		DW	KERNEL_SEGMENT ; 28/03/2018
  1009 000003D8 00                      		DB	0			;INT 13 DRIVE NUMBER
  1010 000003D9 00                      		DB	0			;Logical Drive Letter
  1011                                  FDRIVE3:
  1012 000003DA 0002                    		DW	512			;Physical sector size in bytes
  1013 000003DC FF                      		DB	-1			;Sectors/allocation unit
  1014 000003DD 0100                    		DW	1			;Reserved sectors for DOS
  1015 000003DF 02                      		DB	2			;No. allocation tables
  1016 000003E0 4000                    		DW	64			;Number directory entries
  1017 000003E2 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1018 000003E4 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1019 000003E5 0200                    		DW	2			;Number of FAT sectors
  1020 000003E7 0900                    		DW	9			;Sector limit
  1021 000003E9 0100                    		DW	1			;Head limit
  1022 000003EB 0000                    		DW	0			;Hidden sector count
  1023 000003ED 00                      		DB	0			; TRUE => Large fats
  1024                                  OPCNT3:
  1025 000003EE 0000                    		DW	0			;Open Ref. Count
  1026                                  VOLID3:
  1027 000003F0 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1027 000003F9 202000             
  1028 000003FC 03                      		DB	3			;Form Factor
  1029                                  FLAGS3:
  1030 000003FD 2000                    		DW	0020H			;Various Flags
  1031                                  	;	DB	9 dup (0)		;Reserved for future use
  1032 000003FF 2800                    		dw	40			; number of cylinders
  1033                                  RecBPB3:
  1034 00000401 0002                    		DW	512			;Physical sector size in bytes
  1035 00000403 01                      		DB	1			;Sectors/allocation unit
  1036 00000404 0100                    		DW	1			;Reserved sectors for DOS
  1037 00000406 02                      		DB	2			;No. allocation tables
  1038 00000407 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1039 00000409 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1040 0000040B F0                      		DB	0F0h			;Media descriptor, initially 00H.
  1041 0000040C 0200                    		DW	2			;Number of FAT sectors
  1042 0000040E 0900                    		DW	9			;Sector limit
  1043 00000410 0200                    		DW	2			;HEAD LIMIT
  1044 00000412 0000                    		DW	0			;Hidden sector count
  1045                                  		;DB	12 DUP (?)
  1046 00000414 00<rep Ch>              		times	12 db 0	
  1047                                  TRACK3:
  1048 00000420 FF                      		DB	-1			;Last track accessed on this drive
  1049                                  TIM_LO3:
  1050 00000421 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1051                                  TIM_HI3:
  1052 00000423 FFFF                    		DW	-1
  1053                                  
  1054                                  	;EVENB
  1055 00000425 90                      align 2
  1056                                  BDS4:
  1057 00000426 FFFF                    		DW	-1			;Link to next structure
  1058                                  		;DW	Code
  1059 00000428 7000                    		DW	KERNEL_SEGMENT
  1060 0000042A 00                      		DB	0			;INT 13 DRIVE NUMBER
  1061 0000042B 00                      		DB	0			;Logical Drive Letter
  1062                                  FDRIVE4:
  1063 0000042C 0002                    		DW	512			;Physical sector size in bytes
  1064 0000042E FF                      		DB	-1			;Sectors/allocation unit
  1065 0000042F 0100                    		DW	1			;Reserved sectors for DOS
  1066 00000431 02                      		DB	2			;No. allocation tables
  1067 00000432 4000                    		DW	64			;Number directory entries
  1068 00000434 6801                    		DW	9*40			;Number sectors (at 512 bytes ea.)
  1069 00000436 00                      		DB	00000000b		;Media descriptor, initially 00H.
  1070 00000437 0200                    		DW	2			;Number of FAT sectors
  1071 00000439 0900                    		DW	9			;Sector limit
  1072 0000043B 0100                    		DW	1			;Head limit
  1073 0000043D 0000                    		DW	0			;Hidden sector count
  1074 0000043F 00                      		DB	0			; TRUE => Large fats
  1075                                  OPCNT4:
  1076 00000440 0000                    		DW	0			;Open Ref. Count
  1077                                  VOLID4:
  1078 00000442 4E4F204E414D452020-     		DB	"NO NAME    ",0         ;Volume ID for this disk
  1078 0000044B 202000             
  1079 0000044E 03                      		DB	3			;Form Factor
  1080                                  FLAGS4:
  1081 0000044F 2000                    		DW	0020H			;Various Flags
  1082                                  	;	DB	9 dup (0)		;Reserved for future use
  1083 00000451 2800                    		dw	40			; number of cylinders
  1084                                  ;;Rev 3.30 Modification
  1085                                  RECBPB4:
  1086 00000453 0002                    		DW	512			;BYTES PER SECTOR
  1087 00000455 01                      		DB	1			;SECTORS/ALLOCATION UNIT
  1088 00000456 0100                    		DW	1			;RESERVED SECTORS FOR DOS
  1089 00000458 02                      		DB	2			;NO. ALLOCATION TABLES
  1090 00000459 E000                    		DW	0E0H			;NUMBER DIRECTORY ENTRIES
  1091 0000045B 6801                    		DW	9*40			;NUMBER SECTORS (AT 512 BYTES EA.)
  1092 0000045D F0                      		DB	0F0H			;MEDIA DESCRIPTOR, INITIALLY F0H.
  1093 0000045E 0200                    		DW	2			;NUMBER OF FAT SECTORS
  1094 00000460 0900                    		DW	9			;SECTOR LIMIT
  1095 00000462 0200                    		DW	2			;HEAD LIMIT
  1096 00000464 0000                    		DW	0			;HIDDEN SECTOR COUNT
  1097                                  		;DB	12 DUP (?)
  1098 00000466 00<rep Ch>              		times	12 db 0
  1099                                  ;;End of Modification
  1100                                  TRACK4:
  1101 00000472 FF                      		DB	-1			;Last track accessed on this drive
  1102                                  TIM_LO4:
  1103 00000473 FFFF                    		DW	-1			;Keep these two contiguous (?)
  1104                                  TIM_HI4:
  1105 00000475 FFFF                    		DW	-1
  1106                                  
  1107                                  struc bpbType
  1108 00000000 ??                      .spf:	resb 	1
  1109 00000001 ??                      .spt:	resb 	1
  1110 00000002 ??                      .cdire:	resb 	1
  1111 00000003 ????                    .csec:	resw 	1
  1112 00000005 ??                      .spa:	resb	1
  1113 00000006 ??                      .chead:	resb	1
  1114                                  .size:
  1115                                  endstruc
  1116                                  
  1117                                  SM92:   ; bpbType
  1118 00000477 03                      		db	3	; .spf
  1119 00000478 09                      		db	9	; .spt
  1120 00000479 70                      		db	70h	; .cdire
  1121 0000047A A005                    		dw	2*9*80	; .csec
  1122 0000047C 02                      		db	2	; .spa	
  1123 0000047D 02                      		db	2	; .chead
  1124                                  
  1125                                  ;
  1126                                  ; The following variable can be modified via IOCTL sub-function 16. In this
  1127                                  ; way, the wait can be set to suit the speed of the particular printer being
  1128                                  ; used. One for each printer device.
  1129                                  ;
  1130                                  
  1131                                  PRINTDEV:
  1132 0000047E 00                      		DB	0		; Index into following array
  1133                                  
  1134                                  ;EVENB
  1135 0000047F 90                      align 2
  1136                                  
  1137                                  WAIT_COUNT:
  1138                                  		;DW	4 dup (50h)	; Array of Retry counts for printer
  1139 00000480 5000<rep 4h>            		times	4 dw 50h	 	
  1140                                  
  1141                                  ; DAYCNT is the number of days since 1-1-80.
  1142                                  ; Each time the clock is read it is necessary to check if another day has
  1143                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  1144                                  ; the time will be off by a day.
  1145                                  
  1146                                  ;EVENB
  1147                                  ;align 2
  1148                                  
  1149                                  DAYCNT:
  1150 00000488 0000                    		DW	0
  1151                                  
  1152                                  ;26/05/2018
  1153                                  
  1154                                  ; variables for real time clock setting
  1155                                  HaveCMOSClock:
  1156 0000048A 00                      		db	0	;set by MSINIT.
  1157                                  base_century:
  1158 0000048B 13                      		db	19
  1159                                  base_year:
  1160 0000048C 50                      		db	80
  1161                                  month_tab:
  1162 0000048D 1F1C1F1E1F1E1F1F1E-     		db	31,28,31,30,31,30,31,31,30,31,30,31
  1162 00000496 1F1E1F             
  1163                                  
  1164                                  ; The following are indirect intra-segment call addresses. The
  1165                                  ;procedures are defined in MSINIT for relocation. MSINIT will set these
  1166                                  ;address when the relocation is done.
  1167                                  	
  1168                                  BinToBCD:
  1169 00000499 0000                    		dw	0	;should point to Bin_To_BCD proc in MSINIT
  1170                                  
  1171                                  DaycntToDay:
  1172 0000049B 0000                    		dw	0	;should point to Daycnt_to_day in MSINIT
  1173                                  
  1174                                  
  1175                                  MAX_SECTORS_CURR_SUP	EQU	63	; CURRENT MAXIMUM SEC/TRK THAT	  ;3.30
  1176                                  					; WE SUPPORT (Was 40 in DOS 3.2)  ;3.30
  1177                                  ; 26/09/2019 - Retro DOS v3.1
  1178                                  A_SECTORTABLE_SIZE equ A_SECTORTABLE.size  ; = 4
  1179                                  
  1180                                  ;
  1181                                  ; TrackTable is an area for saving information passwd by the set device
  1182                                  ; parameter function for laster use my Read/Write/Format/Verify.
  1183                                  ;
  1184                                  ; Entries are 4-Tuples (C,H,R,N) where:
  1185                                  ;   C = Cylinder, H = Head, R = Sector, N = Bytes/Sector
  1186                                  ;
  1187                                  ; fixed for bug0016 - initialised table with values - sp
  1188                                  TrackTable:
  1189 0000049D 00000102                		db	0,0,1,2
  1190 000004A1 00000202                		db	0,0,2,2
  1191 000004A5 00000302                		db	0,0,3,2
  1192 000004A9 00000402                		db	0,0,4,2
  1193 000004AD 00000502                		db	0,0,5,2
  1194 000004B1 00000602                		db	0,0,6,2
  1195 000004B5 00000702                		db	0,0,7,2
  1196 000004B9 00000802                		db	0,0,8,2
  1197 000004BD 00000902                		db	0,0,9,2
  1198 000004C1 00000A02                		db	0,0,10,2
  1199 000004C5 00000B02                		db	0,0,11,2
  1200 000004C9 00000C02                		db	0,0,12,2
  1201 000004CD 00000D02                		db	0,0,13,2
  1202 000004D1 00000E02                		db	0,0,14,2
  1203 000004D5 00000F02                		db	0,0,15,2
  1204 000004D9 00001002                		db	0,0,16,2
  1205 000004DD 00001102                		db	0,0,17,2
  1206 000004E1 00001202                		db	0,0,18,2
  1207 000004E5 00<rep B4h>             		times (MAX_SECTORS_CURR_SUP*A_SECTORTABLE_SIZE)-($-TrackTable) db 0
  1208                                  
  1209                                  SectorsPerTrack:
  1210 00000599 0F00                    		dw      15
  1211                                  
  1212                                  ; This is a real ugly place to put this
  1213                                  ; it should really go in the BDS
  1214 0000059B 00                      mediaType:	db	0
  1215                                  
  1216                                  Media_Set_For_Format:
  1217 0000059C 00                      		db	0		; 1 if we have done an Int 13 Set Media
  1218                                  					; Type for Format call
  1219                                  ; Rev 3.30 *****************************************************************
  1220                                  Had_Format_Error:
  1221 0000059D 00                      		db	0		; 1 if the previous format operation
  1222                                  					; failed.
  1223                                  Dsk_time_out_Err	equ	80h	; Time out error (No media present).
  1224                                  Dsk_change_line_Err	equ	6h	; Change line error
  1225                                  Dsk_illegal_combination equ	0Ch	; Return code of ah=18h function.
  1226                                  ; Rev 3.30 *****************************************************************
  1227                                  
  1228                                  ;
  1229                                  ; TempDPT is a temporary place to hold a pointer to the original
  1230                                  ; Disk Parameter Table while DPT is made to point to a table returned
  1231                                  ; by a BIOS call.  A value of -1 indicateds no value has been saved.
  1232                                  ;
  1233                                  
  1234                                  TempDPT:
  1235 0000059E FFFFFFFF                		DD	-1
  1236                                  
  1237                                  MODEL_BYTE: 	
  1238 000005A2 FF                      		DB	0FFH		; MODEL BYTE. SET UP AT INIT TIME.
  1239                                  					; FF - PC-1, EXPANSION, OLD PC-2 
  1240                                  					; FE - NEWER PC-2 (64/256K PLANAR)
  1241                                  					; FD - 
  1242                                  					; FC - 
  1243                                  Secondary_Model_Byte:
  1244 000005A3 00                      		DB	0	
  1245                                  
  1246                                  ;-----------------------------------------------------------------------------
  1247                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  1248                                  ;-----------------------------------------------------------------------------
  1249                                  ; 29/05/2018 - Retro DOS v3.0
  1250                                  ; 25/03/2018 - Retro DOS v2.0 
  1251                                  
  1252                                  ;;Rev 3.30 modification ----------------------------
  1253                                  
  1254                                  INT19SEM:
  1255 000005A4 00                      		DB	0		; INDICATE THAT ALL INT 19
  1256                                  					; INITIALIZATION IS COMPLETE
  1257                                  
  1258                                  		;EVENB
  1259 000005A5 90<rep 3h>              align 4
  1260                                  
  1261                                  ORIG19:
  1262 000005A8 00000000                		dd	0
  1263                                  
  1264                                  	;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  1265                                  	;public	Int19OLD&AA
  1266                                  ;Int19OLD&AA	dd	-1		;Orignal hw int. vec for INT 19h.
  1267                                  	;ENDM
  1268                                  
  1269 000005AC FFFFFFFF                INT19OLD02:	dd	-1
  1270 000005B0 FFFFFFFF                INT19OLD08:	dd	-1
  1271 000005B4 FFFFFFFF                INT19OLD09:	dd	-1
  1272 000005B8 FFFFFFFF                INT19OLD0A:	dd	-1
  1273 000005BC FFFFFFFF                INT19OLD0B:	dd	-1
  1274 000005C0 FFFFFFFF                INT19OLD0C:	dd	-1
  1275 000005C4 FFFFFFFF                INT19OLD0D:	dd	-1
  1276 000005C8 FFFFFFFF                INT19OLD0E:	dd	-1
  1277 000005CC FFFFFFFF                INT19OLD70:	dd	-1	
  1278 000005D0 FFFFFFFF                INT19OLD72:	dd	-1
  1279 000005D4 FFFFFFFF                INT19OLD73:	dd	-1
  1280 000005D8 FFFFFFFF                INT19OLD74:	dd	-1
  1281 000005DC FFFFFFFF                INT19OLD76:	dd	-1
  1282 000005E0 FFFFFFFF                INT19OLD77:	dd	-1	
  1283                                  
  1284                                  		;EVENB
  1285                                  ;align 2
  1286                                  
  1287                                  DSKDRVS:	; 29/05/2018
  1288 000005E4 [3603]                  		DW	FDRIVE1
  1289 000005E6 [8803]                  		DW	FDRIVE2
  1290 000005E8 [DA03]                  		DW	FDRIVE3
  1291 000005EA [2C04]                  		DW	FDRIVE4
  1292                                  HDSKTAB:
  1293 000005EC [1C1B]                  		DW	HDRIVE
  1294 000005EE [6E1B]                  		DW	DRIVEX
  1295                                  
  1296                                  ;* Next area is reserved for mini disk BPB pointers *** 4/7/86
  1297                                  ;* Don't change this pos. Should be add. from DskDrvs *** 4/7/86
  1298                                  MINI_DISK_BPB_PTRS:	
  1299 000005F0 00<rep 28h>             		times 40 db 0 ;4/7/86 - mem res for Mini disk.
  1300                                  
  1301                                  	;EVENB
  1302                                  ;align 2
  1303                                  
  1304                                  INT_2F_NEXT:
  1305 00000618 00000000                		dd	0
  1306                                  RET_ADDR:
  1307 0000061C 00000000                		dd	0
  1308                                  
  1309                                  ;;End of modification ----------------------------
  1310                                  
  1311                                  ;----------------------------------------------------------------------------
  1312                                  
  1313                                  ; 01/06/2018 - Retro DOS v3.0
  1314                                  
  1315                                  ; End of support for multiple floppies with no logical drives
  1316                                  ; This is not 'special' any more because we now have the capability of
  1317                                  ; defining logical drives in CONFIG.SYS. We therefore keep the code for
  1318                                  ; swapping resident ALL the time.
  1319                                  
  1320                                  ;;Rev 3.30 modification ----------------------------
  1321                                  ;Variables for Dynamic Relocatable modules
  1322                                  ;These should be stay resident.
  1323                                  
  1324 00000620 00000000                INT6C_RET_ADDR:	DD	0	; ret add from INT 6C for P12 mach
  1325                                  
  1326                                  ;
  1327                                  ;   DATA STRUCTURES FOR REAL-TIME DATE AND TIME
  1328                                  ;
  1329                                  
  1330                                  BIN_DATE_TIME:
  1331 00000624 00                      	DB	0		; CENTURY (19 OR 20) OR HOURS (0-23)
  1332 00000625 00                      	DB	0		; YEAR IN CENTURY (0-99) OR MINUTES (0-59)
  1333 00000626 00                      	DB	0		; MONTH IN YEAR (1-12) OR SECONDS (0-59)
  1334 00000627 00                      	DB	0		; DAY IN MONTH (1-31)
  1335                                  MONTH_TABLE:
  1336 00000628 0000                    	DW	0		;MJB002 JANUARY
  1337 0000062A 1F00                    	DW	31		;MJB002 FEBRUARY
  1338 0000062C 3B00                    	DW	59		;MJB002
  1339 0000062E 5A00                    	DW	90		;MJB002
  1340 00000630 7800                    	DW	120		;MJB002
  1341 00000632 9700                    	DW	151		;MJB002
  1342 00000634 B500                    	DW	181		;MJB002
  1343 00000636 D400                    	DW	212		;MJB002
  1344 00000638 F300                    	DW	243		;MJB002
  1345 0000063A 1101                    	DW	273		;MJB002
  1346 0000063C 3001                    	DW	304		;MJB002
  1347 0000063E 4E01                    	DW	334		;MJB002
  1348                                  DAYCNT2:
  1349 00000640 0000                    	DW	0		;MJB002 TEMP FOR CNT OF DAYS SINCE 1-1-80
  1350                                  FEB29:
  1351 00000642 00                      	DB	0		;MJB002 FEBRUARY 29 IN A LEAP YEAR FLAG
  1352                                  
  1353                                  ;;End of modification ------------------------------
  1354                                  
  1355                                  ;----------------------------------------------------------------------------
  1356                                  ;
  1357                                  ;----------------------------------------------------------------------------
  1358                                  
  1359                                  ; 29/06/2019 - Retro DOS v3.1
  1360                                  
  1361                                  ;************************************************************************
  1362                                  ;*									*
  1363                                  ;*	cbreak - break key handling - simply set altah=3 and iret	*
  1364                                  ;*									*
  1365                                  ;************************************************************************
  1366                                  
  1367                                  CBREAK:
  1368 00000643 2EC606[0800]03          		mov	byte [cs:ALTAH],3
  1369                                  INTRET:
  1370 00000649 CF                      		iret
  1371                                  
  1372                                  ;************************************************************************
  1373                                  ;*									*
  1374                                  ;*	strategy - store es:bx (device driver request packet)		*
  1375                                  ;*		     away at [ptrsav] for next driver function call	*
  1376                                  ;*									*
  1377                                  ;************************************************************************
  1378                                  
  1379                                  STRATEGY:
  1380 0000064A 2E891E[0A00]            		mov	[CS:PTRSAV],BX
  1381 0000064F 2E8C06[0C00]            		mov	[CS:PTRSAV+2],ES
  1382 00000654 CB                      		retf					
  1383                                  
  1384                                  ;-----------------------------------------------------------------------------
  1385                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  1386                                  ;-----------------------------------------------------------------------------
  1387                                  ; 23/03/2018 - Retro DOS v2.0
  1388                                  
  1389                                  ; The next nine equ's describe the offset into the request header for
  1390                                  ; different information.  For example STATUS is in byte 3 of the request
  1391                                  ; header (starting count at zero).
  1392                                  
  1393                                  CMDLEN	equ	0		; length of this command
  1394                                  UNIT	equ	1		; sub unit specifier
  1395                                  CMD	equ	2		; command code
  1396                                  STATUS	equ	3		; status
  1397                                  MEDIA	equ	13		; media descriptor
  1398                                  TRANS	equ	14		; transfer address
  1399                                  COUNT	equ	18		; count of blocks or characters
  1400                                  START	equ	20		; first block to transfer
  1401                                  EXTRA	equ	22		; Usually pointer to Vol Id for error 15
  1402                                  
  1403                                  
  1404                                  ;------------------------------------------------------------------------------
  1405                                  ;
  1406                                  ;			Device entry point
  1407                                  ;
  1408                                  ; The following ten pieces of code are the interrupt entry points for the
  1409                                  ; default device drivers.  These small pieces of code have two jobs.
  1410                                  ;
  1411                                  ;	1) Make SI point to the beginning of the proper command jump  table.
  1412                                  ;	   SI must first be pushed to preserve original contents.
  1413                                  ;	2) If the call is an AUX or a printer save the number of the
  1414                                  ;	   request in AL.  AL is moved to AUXNUM below.
  1415                                  ;
  1416                                  ;------------------------------------------------------------------------------
  1417                                  
  1418                                  ; Con device:
  1419                                  
  1420                                  CON$IN:
  1421 00000655 56                      		PUSH	SI
  1422 00000656 BE[3E07]                		MOV	SI,CONTBL
  1423 00000659 EB4B                    		JMP	SHORT ENTRY
  1424                                  AUX0$IN:
  1425 0000065B 56                      		PUSH	SI
  1426 0000065C 50                      		PUSH	AX
  1427 0000065D 30C0                    		XOR	AL,AL
  1428 0000065F EB10                    		JMP	SHORT AUXENT
  1429                                  AUX1$IN:
  1430 00000661 56                      		PUSH	SI
  1431 00000662 50                      		PUSH	AX
  1432 00000663 B001                    		MOV	AL,1
  1433 00000665 EB0A                    		JMP	short AUXENT
  1434                                  
  1435                                  		; 25/05/2018
  1436                                  AUX2$IN:
  1437 00000667 56                      		PUSH	SI
  1438 00000668 50                      		PUSH	AX
  1439 00000669 B002                    		MOV	AL,2
  1440 0000066B EB04                    		JMP	short AUXENT
  1441                                  AUX3$IN:
  1442 0000066D 56                      		PUSH	SI
  1443 0000066E 50                      		PUSH	AX
  1444 0000066F B003                    		MOV	AL,3
  1445                                  		;JMP	short AUXENT
  1446                                  AUXENT:
  1447 00000671 BE[5607]                		MOV	SI,AUXTBL
  1448 00000674 EB31                    		JMP	SHORT ENTRY1
  1449                                  
  1450                                  PRN0$IN:
  1451 00000676 56                      		PUSH	SI
  1452 00000677 50                      		PUSH	AX
  1453 00000678 31C0                    		XOR	AX,AX
  1454 0000067A EB16                    		JMP	SHORT PRNENT
  1455                                  PRN1$IN:
  1456 0000067C 56                      		PUSH	SI
  1457 0000067D 50                      		PUSH	AX
  1458 0000067E 30C0                    		XOR	AL,AL
  1459 00000680 B401                    		MOV	AH,1
  1460 00000682 EB0E                    		JMP	SHORT PRNENT
  1461                                  PRN2$IN:
  1462 00000684 56                      		PUSH	SI
  1463 00000685 50                      		PUSH	AX
  1464 00000686 B001                    		MOV	AL,1
  1465 00000688 B402                    		MOV	AH,2
  1466 0000068A EB06                    		JMP	SHORT PRNENT
  1467                                  PRN3$IN:
  1468 0000068C 56                      		PUSH	SI
  1469 0000068D 50                      		PUSH	AX
  1470 0000068E B002                    		MOV	AL,2
  1471 00000690 B403                    		MOV	AH,3
  1472                                  PRNENT:
  1473 00000692 BE[8407]                		MOV	SI,PRNTBL
  1474 00000695 2E8826[7E04]            		MOV	[CS:PRINTDEV],AH
  1475 0000069A EB0B                    		JMP	SHORT ENTRY1
  1476                                  
  1477                                  TIM$IN:
  1478 0000069C 56                      		PUSH	SI
  1479 0000069D BE[6E07]                		MOV	SI,TIMTBL
  1480 000006A0 EB04                    		JMP	SHORT ENTRY
  1481                                  
  1482                                  DSK$IN:
  1483 000006A2 56                      		PUSH	SI
  1484 000006A3 BE[0A07]                		mov	SI,DSKTBL
  1485                                  
  1486                                  ;  This section is the prolog to all default device drivers. All registers
  1487                                  ; are saved, the registers are filled with information from the request header,
  1488                                  ; and the routine from the jump table is called. Error checking is done
  1489                                  ; to assure command code is valid. Before calling the routine in the
  1490                                  ; jump table the register are:
  1491                                  ;
  1492                                  ;	AH = Media Descriptor
  1493                                  ;	AL = Unit Code
  1494                                  ;	BX = offset to PTRSAV (request header is therefore at DS:BX)
  1495                                  ;	CX = count from request header
  1496                                  ;	DX = start sector
  1497                                  ;	ES:DI = transfer address
  1498                                  ;	SI = points to jump table
  1499                                  ;	DS = points to this segment
  1500                                  ;
  1501                                  ; Once the routine finishes its job it jumps back to one of the eight
  1502                                  ; pieces of code below labeled Exit Points.
  1503                                  
  1504                                  
  1505                                  ENTRY:
  1506 000006A6 50                      		push	AX
  1507                                  ENTRY1:
  1508 000006A7 51                      		push	CX			; save all registers
  1509 000006A8 52                      		push	DX
  1510 000006A9 57                      		push	DI
  1511 000006AA 55                      		push	BP
  1512 000006AB 1E                      		push	DS
  1513 000006AC 06                      		push	ES
  1514 000006AD 53                      		push	BX
  1515                                  
  1516 000006AE 2EA2[1600]              		mov	[CS:AUXNUM],AL		; save choice of AUX/PRN device
  1517                                  
  1518 000006B2 2EC51E[0A00]            		lds	BX,[CS:PTRSAV]		; get pointer to I/O packet
  1519                                  	
  1520 000006B7 8A4701                  		mov	AL,[BX+UNIT]		;AL = UNIT CODE
  1521 000006BA 8A670D                  		mov	AH,[BX+MEDIA]		;AH = MEDIA DESCRIP
  1522 000006BD 8B4F12                  		mov	CX,[BX+COUNT]		;CX = COUNT
  1523 000006C0 8B5714                  		mov	DX,[BX+START]		;DX = START SECTOR
  1524                                  
  1525 000006C3 97                      		xchg	DI,AX
  1526 000006C4 8A4702                  		mov	AL,[BX+CMD]
  1527                                  		; 11/04/2018 (25/05/2018)
  1528 000006C7 2E3A04                  		cmp	AL,[CS:SI]		; is command code a valid number?
  1529 000006CA 7713                    		ja	SHORT CMDERR		; no, jump to handle error
  1530                                  
  1531                                  		;XOR	AH,AH
  1532 000006CC 98                      		CBW				; note that AL <= 15 means OK
  1533 000006CD D1E0                    		shl	AX,1
  1534 000006CF 01C6                    		add	SI,AX			; get SI to point to address of routine
  1535                                  		
  1536 000006D1 97                      		xchg	AX,DI			; put proper value back into AX
  1537 000006D2 C47F0E                  		les	DI,[BX+TRANS]		; get ES:DI to point to transfer address
  1538 000006D5 0E                      		push	CS			; get DS equal to CS
  1539 000006D6 1F                      		pop	DS
  1540                                  
  1541 000006D7 FC                      		cld				; clear the direction flag
  1542                                  		; 25/05/2018
  1543 000006D8 FF6401                  		jmp	WORD [SI+1]		; go to the command
  1544                                  
  1545                                  ;=====================================================
  1546                                  ;=
  1547                                  ;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
  1548                                  ;=
  1549                                  ;=====================================================
  1550                                  
  1551                                  ;----------------------------------------------------------
  1552                                  ;
  1553                                  ;		Exit  Points
  1554                                  ;
  1555                                  ; All device driver call return through one of these eight
  1556                                  ; pieces of code.  The code set error and status conditions
  1557                                  ; and then restores the registers.
  1558                                  ;
  1559                                  ;----------------------------------------------------------
  1560                                  		
  1561                                  BUS$EXIT:				; device busy exit
  1562                                  
  1563 000006DB B403                    		mov	AH,00000011b		; set error code
  1564 000006DD EB19                    		jmp	SHORT ERR1
  1565                                  CMDERR:
  1566 000006DF B003                    		mov	AL,3			; unknown command error
  1567                                  ERR$CNT:
  1568 000006E1 2EC51E[0A00]            		lds	BX,[CS:PTRSAV]
  1569                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1570 000006E6 294F12                  		sub	[BX+COUNT],CX		;# of successful I/O's
  1571                                  ERR$EXIT:
  1572 000006E9 B481                    		mov	AH,10000001b		; mark error and return
  1573 000006EB EB0B                    		jmp	SHORT ERR1
  1574                                  
  1575                                  EXIT$ZER:
  1576                                  		;lds	BX,[CS:PTRSAV]
  1577 000006ED C51E[0A00]              		lds	BX,[PTRSAV]		; IBMDOS 3.3 (IBMBIO.COM)
  1578 000006F1 31C0                    		xor	AX,AX
  1579 000006F3 894712                  		mov	[BX+COUNT],AX		; indicate no character read
  1580                                  
  1581                                  EXIT:
  1582 000006F6 B401                    		mov	AH,00000001b
  1583                                  ERR1:
  1584 000006F8 2EC51E[0A00]            		lds	BX,[CS:PTRSAV]
  1585                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  1586 000006FD 894703                  		mov	[BX+STATUS],AX		; mark operation complete
  1587                                  
  1588 00000700 5B                      		pop	BX			; restore register and return
  1589 00000701 07                      		pop	ES
  1590 00000702 1F                      		pop	DS
  1591 00000703 5D                      		pop	BP
  1592 00000704 5F                      		pop	DI
  1593 00000705 5A                      		pop	DX
  1594 00000706 59                      		pop	CX
  1595 00000707 58                      		pop	AX
  1596 00000708 5E                      		pop	SI
  1597 00000709 CB                      		retf
  1598                                  
  1599                                  ;----------------------------------------------------------------------------
  1600                                  ;
  1601                                  ;		Command Jump Tables
  1602                                  ;
  1603                                  ;     These tables hold the entry points for the various service routines
  1604                                  ; for the different drivers.  The index in the table is the command code for
  1605                                  ; that funcion plus two.  For example the command code for Read (input) is 4,
  1606                                  ; The 6th (4 plus 2) entry in the table DSKTBL is DSK$READ - the command to
  1607                                  ; read a disk.	Commands which do not exist for a device are filled with
  1608                                  ; exit (e.g. MediaCheck for CONTBL).  The first entry in the table is the
  1609                                  ; largest command code implemented for that device.  This value is used
  1610                                  ; for error checking.  If new command codes are added then the first entry
  1611                                  ; in the table must be incremented.
  1612                                  ;
  1613                                  ;	BEWARE - These tables overlap somewhat! -c.p.
  1614                                  ;
  1615                                  ;----------------------------------------------------------------------------
  1616                                  
  1617                                  ;align 2
  1618                                  
  1619                                  		; 08/04/2018
  1620                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  1621                                  		; ((Disassembler: IDA Pro Free))
  1622                                  ;
  1623                                  ; Disk:
  1624                                  ;
  1625                                  		;nop
  1626                                  DSKTBL:
  1627 0000070A 18                      		DB	24		; This is the size of the table YUK!!!!
  1628 0000070B [271A]                  		DW	DSK$INIT	; code	0: INIT
  1629 0000070D [D30E]                  		DW	MEDIA$CHK	; code	1: Media Check
  1630 0000070F [840F]                  		DW	GET$BPB 	; code	2: BUILD BPB
  1631 00000711 [DF06]                  		DW	CMDERR		; code	3: IOCTL input
  1632 00000713 [6C11]                  		DW	DSK$READ	; code	4: INPUT
  1633 00000715 [DB06]                  		DW	BUS$EXIT	; code	5: NONDESTRUCITVE INPUT, NO WAIT
  1634 00000717 [F606]                  		DW	EXIT		; code	6: INPUT STATUS
  1635 00000719 [F606]                  		DW	EXIT		; code	7: INPUT FLUSH
  1636 0000071B [5A11]                  		DW	DSK$WRIT	; code	8: OUTPUT
  1637 0000071D [5111]                  		DW	DSK$WRITV	; code	9: OUTPUT with verify
  1638 0000071F [F606]                  		DW	EXIT		; code 10: OUTPUT STATUS
  1639 00000721 [F606]                  		DW	EXIT		; code 11: OUTPUT FLUSH
  1640 00000723 [DF06]                  		DW	CMDERR		; code 12: IOCTL output
  1641                                  TABLE_PATCH:
  1642 00000725 [BF1B]                  		DW	DSK$OPEN	; code 13: DEVICE OPEN
  1643 00000727 [C81B]                  		DW	DSK$CLOSE	; code 14: DEVICE CLOSE
  1644 00000729 [4111]                  		DW	DSK$REM 	; code 15: REMOVABLE MEDIA
  1645 0000072B [F606]                  		DW	EXIT
  1646 0000072D [F606]                  		DW	EXIT
  1647 0000072F [F606]                  		DW	EXIT
  1648 00000731 [5D14]                  		DW	GENERIC$IOCTL
  1649 00000733 [F606]                  		DW	EXIT
  1650 00000735 [F606]                  		DW	EXIT
  1651 00000737 [F606]                  		DW	EXIT
  1652 00000739 [9E18]                  		DW	IOCTL$GETOWN
  1653 0000073B [C018]                  		DW	IOCTL$SETOWN
  1654                                  ;
  1655                                  ; Console:
  1656                                  ;
  1657                                  		;nop
  1658 0000073D 00                      		db	0
  1659                                  CONTBL:
  1660 0000073E 0A                      		DB	10
  1661 0000073F [F606]                  		DW	EXIT
  1662 00000741 [F606]                  		DW	EXIT
  1663 00000743 [F606]                  		DW	EXIT
  1664 00000745 [DF06]                  		DW	CMDERR
  1665 00000747 [C10B]                  		DW	CON$READ
  1666 00000749 [EC0B]                  		DW	CON$RDND
  1667 0000074B [F606]                  		DW	EXIT
  1668 0000074D [320C]                  		DW	CON$FLSH
  1669 0000074F [4A0C]                  		DW	CON$WRIT
  1670 00000751 [4A0C]                  		DW	CON$WRIT
  1671 00000753 [F606]                  		DW	EXIT
  1672                                  ;
  1673                                  ; Auxilary:
  1674                                  ;
  1675                                  		;nop
  1676 00000755 00                      		db	0
  1677                                  AUXTBL:
  1678 00000756 0A                      		DB	10
  1679 00000757 [F606]                  		DW	EXIT
  1680 00000759 [F606]                  		DW	EXIT
  1681 0000075B [F606]                  		DW	EXIT
  1682 0000075D [DF06]                  		DW	CMDERR
  1683 0000075F [570C]                  		DW	AUX$READ
  1684 00000761 [7E0C]                  		DW	AUX$RDND
  1685 00000763 [F606]                  		DW	EXIT
  1686 00000765 [B70C]                  		DW	AUX$FLSH
  1687 00000767 [C00C]                  		DW	AUX$WRIT
  1688 00000769 [C00C]                  		DW	AUX$WRIT
  1689 0000076B [A00C]                  		DW	AUX$WRST
  1690                                  ;
  1691                                  ; Clock:
  1692                                  ;
  1693                                  		;nop
  1694 0000076D 00                      		db	0
  1695                                  TIMTBL:
  1696 0000076E 09                      		DB	9
  1697 0000076F [F606]                  		DW	EXIT
  1698 00000771 [F606]                  		DW	EXIT
  1699 00000773 [F606]                  		DW	EXIT
  1700 00000775 [DF06]                  		DW	CMDERR
  1701 00000777 [4E0E]                  		DW	TIM$READ
  1702 00000779 [DB06]                  		DW	BUS$EXIT
  1703 0000077B [F606]                  		DW	EXIT
  1704 0000077D [F606]                  		DW	EXIT
  1705 0000077F [AF0D]                  		DW	TIM$WRIT
  1706 00000781 [AF0D]                  		DW	TIM$WRIT
  1707                                  ;
  1708                                  ; Printer:
  1709                                  ;
  1710                                  		;nop
  1711 00000783 00                      		db	0
  1712                                  PRNTBL:
  1713 00000784 18                      		DB	24
  1714 00000785 [F606]                  		DW	EXIT			;INIT
  1715 00000787 [F606]                  		DW	EXIT
  1716 00000789 [F606]                  		DW	EXIT
  1717 0000078B [DF06]                  		DW	CMDERR
  1718 0000078D [ED06]                  		DW	EXIT$ZER		;INDICATE ZERO CHARS READ
  1719 0000078F [DB06]                  		DW	BUS$EXIT
  1720 00000791 [F606]                  		DW	EXIT
  1721 00000793 [F606]                  		DW	EXIT
  1722 00000795 [E40C]                  		DW	PRN$WRIT
  1723 00000797 [E40C]                  		DW	PRN$WRIT
  1724 00000799 [000D]                  		DW	PRN$STAT
  1725 0000079B [F606]                  		DW	EXIT
  1726 0000079D [F606]                  		DW	EXIT
  1727 0000079F [F606]                  		DW	EXIT
  1728 000007A1 [F606]                  		DW	EXIT
  1729 000007A3 [F606]                  		DW	EXIT
  1730 000007A5 [300D]                  		DW	PRN$TILBUSY
  1731 000007A7 [F606]                  		DW	EXIT
  1732 000007A9 [F606]                  		DW	EXIT
  1733 000007AB [760D]                  		DW	PRN$GENIOCTL
  1734 000007AD [F606]                  		DW	EXIT
  1735 000007AF [F606]                  		DW	EXIT
  1736 000007B1 [F606]                  		DW	EXIT
  1737 000007B3 [DF06]                  		DW	CMDERR
  1738 000007B5 [DF06]                  		DW	CMDERR
  1739                                  ;
  1740                                  ; Last drive accessed
  1741                                  ;
  1742                                  
  1743                                  		; 09/04/2018
  1744                                  ;MEDIACHK_DRV:  ;; 13/04/2018
  1745                                  ;		DB	0  ; 25/05/2018 
  1746                                  		
  1747                                  ;TIM_LO:
  1748                                  ;		Dw	0FFFFh
  1749                                  ;TIM_HI:
  1750                                  ;		Dw	0FFFFh
  1751                                  ;WRTVERIFY:
  1752                                  ;RFLAG:
  1753                                  ;		DB	ROMRead		;2 for read, 3 for write
  1754                                  ;VERIFY:
  1755                                  ;		DB	0		;1 if verify after write
  1756                                  ;Single:
  1757                                  ;		DB	0
  1758                                  ;CURSECBUF:
  1759                                  ;		DB	0
  1760                                  ;SECCNT:
  1761                                  ;		DW	0
  1762                                  ;HARDNUM:
  1763                                  ;		DB	99		;logical drive number of first hardfile	
  1764                                  ;DRVNUM:
  1765                                  ;		DB	0
  1766                                  ;CURHD:
  1767                                  ;		DB	0
  1768                                  ;CURSEC:
  1769                                  ;		DB	0
  1770                                  ;CURTRK:
  1771                                  ;		DW	0
  1772                                  ;SPSAV:
  1773                                  ;		DW	0
  1774                                  
  1775                                  ;-----------------------------------------------------------------------------
  1776                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  1777                                  ;-----------------------------------------------------------------------------
  1778                                  ; 23/03/2018 - Retro DOS v2.0
  1779                                  
  1780                                  ; 29/06/2019 - Retro DOS v3.1
  1781                                  
  1782                                  ;************************************************************************
  1783                                  ;*									*
  1784                                  ;*	outchr - this is our int 29h handler. it writes the		*
  1785                                  ;*	   character in al on the display using int 10h ttywrite	*
  1786                                  ;*									*
  1787                                  ;************************************************************************
  1788                                  
  1789                                  CHROUT	equ 29H
  1790                                  
  1791                                  OUTCHR:
  1792 000007B7 50                      		push	ax
  1793 000007B8 56                      		push	si
  1794 000007B9 57                      		push	di
  1795 000007BA 55                      		push	bp
  1796 000007BB 53                      		push	bx
  1797 000007BC B40E                    		mov	ah,0Eh	; set command to write a character
  1798 000007BE BB0700                  		mov	bx,7	; set foreground color
  1799 000007C1 CD10                    		int	10h	; call rom-bios
  1800 000007C3 5B                      		pop	bx
  1801 000007C4 5D                      		pop	bp
  1802 000007C5 5F                      		pop	di
  1803 000007C6 5E                      		pop	si
  1804 000007C7 58                      		pop	ax
  1805 000007C8 CF                      		iret
  1806                                  
  1807                                  ;----------------------------------------------
  1808                                  ;
  1809                                  ; Fill DX register with value in AUXNUM
  1810                                  ;
  1811                                  ;----------------------------------------------
  1812                                  
  1813                                  GETDX:
  1814                                  		; IBMDOS 2.1
  1815                                  		;mov	dl, [AUXNUM]
  1816                                  		;xor	dh,dh
  1817                                  
  1818                                  		; MSDOS 3.3
  1819 000007C9 2E8B16[1600]            		mov	DX,[CS:AUXNUM]
  1820 000007CE C3                      		retn
  1821                                  
  1822                                  ; 29/06/52019 - Retro DOS v3.1
  1823                                  
  1824                                  ;************************************************************************
  1825                                  ;*									*
  1826                                  ;*	block13 - our int13 hooker					*
  1827                                  ;*									*
  1828                                  ;************************************************************************
  1829                                  
  1830                                  ; 28/05/2018 - Retro DOS v3.0
  1831                                  
  1832                                  ; This is the true DISK INT handler. We parse the request to see if there is
  1833                                  ; a DMA violation. If so, depending on the function, we:
  1834                                  ;   READ/WRITE	Break the request into three pieces and move the middle one
  1835                                  ;	into our internal buffer.
  1836                                  ;   FORMAT	Copy the format table into the buffer
  1837                                  ;   VERIFY	Point the transfer address into the buffer
  1838                                  ;
  1839                                  ; This is the biggest bogosity of all. The IBM controller does NOT handle
  1840                                  ; operations that cross physical 64K boundaries. In these cases, we copy
  1841                                  ; the offending sector into the buffer below and do the I/O from there.
  1842                                  
  1843                                  ;;Rev 3.30 Modification -----------------------------------------
  1844                                  ;To handle the INT 13h, AH = 8 Problem.
  1845                                  ;Save Registers here.
  1846 000007CF 0000                    Save_AX:   DW  0
  1847 000007D1 0000                    Save_BX:   DW  0
  1848 000007D3 0000                    Save_CX:   DW  0
  1849 000007D5 0000                    Save_DX:   DW  0
  1850 000007D7 0000                    Save_DI:   DW  0
  1851 000007D9 0000                    Save_SI:   DW  0
  1852 000007DB 0000                    Save_BP:   DW  0
  1853 000007DD 0000                    Save_DS:   DW  0
  1854 000007DF 0000                    Save_ES:   DW  0
  1855 000007E1 0000                    Prev_DX:   DW  0
  1856 000007E3 0000                    Save_Flag: DW  0
  1857                                  ;;End of Modification -----------------------------------------
  1858                                  
  1859                                  ;
  1860                                  ; Block13:
  1861                                  ;
  1862                                  ;   Entry conditions:
  1863                                  ;	AH = function
  1864                                  ;	AL = number of sectors
  1865                                  ;	ES:BX = DMA address
  1866                                  ;	CX = packed track and sector
  1867                                  ;	DX = head and drive
  1868                                  ;   Output conditions:
  1869                                  ;	NO DMA violation.
  1870                                  ;
  1871                                  
  1872                                  Block13:
  1873                                  ;
  1874                                  ; Let the operation proceed.  If there is a DMA violation, then we do things.
  1875                                  ;
  1876 000007E5 2EA3[1200]              		mov	 [cs:PrevOper],AX	; save request
  1877 000007E9 9C                      		pushf				; preserve the flags
  1878 000007EA 80FC05                  		cmp	AH,ROMFormat		; format request?
  1879 000007ED 750A                    		jnz	short Not_Format	;    no, skip down
  1880                                  
  1881                                  	; Set changed by format bit for all logical drives using this physical drive
  1882                                  		;---------------------------------------------------------|
  1883                                  		; Warning: Do Not Change the following. 		  |
  1884                                  		; It gets patched in at INIT time			  |
  1885                                  Changed_Patch:
  1886 000007EF 2EC706[0001]4001        		mov	word [cs:FlagBits],fChanged_By_Format+fChanged
  1887 000007F6 E82015                  		call	Set_Changed_DL	; Indicate that media changed by format
  1888                                  		;							  |
  1889                                  		;---------------------------------------------------------|
  1890                                  
  1891                                  Not_Format:
  1892                                  ;;Rev 3.30 Modification -----------------------------------------
  1893 000007F9 80FC08                  		cmp	ah, 8			; Read Driver Parm ?
  1894 000007FC 7412                    		je	short Bus_Problem
  1895 000007FE 80FC15                  		cmp	ah, 15h
  1896 00000801 740D                    		je	short Bus_Problem
  1897 00000803 2EFF1E[AE00]            		CALL	far [CS:ORIG13]		; SIMULATE INT 13
  1898 00000808 7203                    		JC	short GOTERR13_br	; ERROR?
  1899                                  		;14/06/2018
  1900 0000080A CA0200                  		RETF	2			; NO, RETURN AND CLEAR FLAGS
  1901                                  
  1902                                  GOTERR13_br: 
  1903 0000080D E98000                  		jmp	GotErr13
  1904                                  
  1905                                  ;Some machines have a problem with Int 13h function=8
  1906                                  ;This function does not reset the common buses after the execution.
  1907                                  ;To solve this problem, when we detect AH=8h, then we will save the result
  1908                                  ;and will issue AH=1 (Read Status) call to reset the buses.
  1909                                  
  1910                                  Bus_Problem:
  1911 00000810 2E8916[E107]            		mov	[cs:Prev_DX], DX	;save orignal drive number
  1912 00000815 2EFF1E[AE00]            		call	far [CS:ORIG13]		;Do "Read drive parm"
  1913                                  
  1914 0000081A 2EA3[CF07]              		mov	[cs:Save_AX], AX	;Save registers,flag
  1915 0000081E 2E891E[D107]            		mov	[cs:Save_BX], BX
  1916 00000823 2E890E[D307]            		mov	[cs:Save_CX], CX
  1917 00000828 2E8916[D507]            		mov	[cs:Save_DX], DX
  1918 0000082D 2E893E[D707]            		mov	[cs:Save_DI], DI
  1919 00000832 2E8936[D907]            		mov	[cs:Save_SI], SI
  1920 00000837 2E892E[DB07]            		mov	[cs:Save_BP], BP
  1921 0000083C 2E8C1E[DD07]            		mov	[cs:Save_DS], DS
  1922 00000841 2E8C06[DF07]            		mov	[cs:Save_ES], ES
  1923 00000846 9C                      		pushf
  1924 00000847 2E8F06[E307]            		pop	word [cs:Save_Flag]
  1925                                  
  1926 0000084C 2E8B16[E107]            		mov	dx, [cs:Prev_DX]	;restore orignal drive
  1927 00000851 9C                      		pushf
  1928 00000852 B401                    		mov	ah, 1			;Read Status.
  1929 00000854 2EFF1E[AE00]            		call	far [CS:ORIG13]		;Reset the bus as a side effect
  1930                                  
  1931 00000859 2EA1[CF07]              		mov	AX, [cs:Save_AX]	;restore registers,flag
  1932 0000085D 2E8B1E[D107]            		mov	BX, [cs:Save_BX]
  1933 00000862 2E8B0E[D307]            		mov	CX, [cs:Save_CX]
  1934 00000867 2E8B16[D507]            		mov	DX, [cs:Save_DX]
  1935 0000086C 2E8B3E[D707]            		mov	DI, [cs:Save_DI]
  1936 00000871 2E8B36[D907]            		mov	SI, [cs:Save_SI]
  1937 00000876 2E8B2E[DB07]            		mov	BP, [cs:Save_BP]
  1938 0000087B 2E8E1E[DD07]            		mov	DS, [cs:Save_DS]
  1939 00000880 2E8E06[DF07]            		mov	ES, [cs:Save_ES]
  1940 00000885 2EFF36[E307]            		push	word [cs:Save_Flag]
  1941 0000088A 9D                      		popf
  1942 0000088B 7203                    		jc	short GotErr13		;AH=8 had been an error?
  1943                                  		;14/06/2018
  1944 0000088D CA0200                  		retf	2
  1945                                  ;
  1946                                  ; Some kind of error occurred.	See if it is DMA violation
  1947                                  ;
  1948                                  GotErr13:
  1949 00000890 9C                      		pushf
  1950 00000891 80FC09                  		cmp	AH, 09h			; is error DMA error code?
  1951 00000894 7502                    		JNZ	short CHECK_ECC
  1952 00000896 EB58                    		JMP	short GotDMAErr
  1953                                  CHECK_ECC:
  1954 00000898 80FC11                  		CMP	AH,11H
  1955 0000089B 7404                    		JZ	short OK11
  1956 0000089D 9D                      		POPF
  1957                                  		;14/06/2018
  1958 0000089E CA0200                  		RETF	2
  1959                                  ;
  1960                                  ; We have an error status 11h.	This indicates an ECC-corrected error.	Note
  1961                                  ; that this indicates that the data is PROBABLY correct but not CERTAINLY
  1962                                  ; correct. The ROMs on PC-1s and PC_XTs have a 'bug' in that if an ECC error
  1963                                  ; occurs for a multi-sector read, only the sectors up to the one where the
  1964                                  ; error occurred are read in. We have no way of knowing how many were read in
  1965                                  ; this case, so we redo the operation, reading one sector at a time. If we
  1966                                  ; get an ECC error on reading one sector, we ignore the error because the
  1967                                  ; sector has been read in.
  1968                                  ;
  1969                                  
  1970                                  OK11:
  1971                                  ;		popf			; restore flags
  1972                                  ;;Rev 3.30 Modification -----------------------------------------
  1973                                  ; Here, it is better reset the system. So, we are going to
  1974                                  ; call Orig13 again
  1975 000008A1 B400                    		mov	ah,0
  1976 000008A3 2EFF1E[AE00]            		call	far [CS:ORIG13]	;reset. Don't care about result
  1977                                  ;;End of Modification -----------------------------------------
  1978                                  
  1979 000008A8 2EA1[1200]              		mov	ax,[cs:PrevOper] ; Retrieve request
  1980                                  ;
  1981                                  ; This will provide a termination point.
  1982                                  ;
  1983 000008AC 3C01                    		cmp	AL,1		; If request for one sector, assume OK
  1984 000008AE 7505                    		jnz	short ECC_Err_Handle ; more than one sector -- jump down
  1985 000008B0 30E4                    		xor	AH,AH		; clear carry too!
  1986                                  		;14/06/2018
  1987 000008B2 CA0200                  		retf	2
  1988                                  
  1989                                  ECC_Err_Handle:
  1990 000008B5 53                      		push	bx
  1991 000008B6 51                      		push	cx
  1992 000008B7 52                      		push	dx
  1993 000008B8 2EA2[1400]              		mov	[cs:Number_Of_Sec],AL
  1994                                  Loop_ECC:
  1995 000008BC 2EA1[1200]              		mov	AX,[CS:PrevOper] ; set command to previos command
  1996 000008C0 B001                    		mov	AL,1		 ;     but request only one sector
  1997                                  ;
  1998                                  ; we do reads one sector at a time. this ensures that we will eventually
  1999                                  ; finish the request since ecc errors on 1 sector do read in that sector.
  2000                                  ;
  2001                                  ; we need  some "intelligence" in the ecc handler to handle reads
  2002                                  ; that attempt to read more sectors than are available on a particular
  2003                                  ; track.
  2004                                  ; we call check_wrap to set up the sector #, head # and cylinder # for
  2005                                  ; this request.
  2006                                  ; at this point, all registers are set up for the call to orig13, except
  2007                                  ; that there maybe a starting sector number that is bigger than the number
  2008                                  ; of sectors on a track.
  2009                                  ;
  2010 000008C2 E85D10                  		CALL	Check_Wrap	; see if wrapping around cylinder
  2011                                  
  2012 000008C5 9C                      		pushf			; save flags
  2013 000008C6 2EFF1E[AE00]            		call	far [CS:ORIG13]	; call original rom-bios code
  2014                                  ;;Rev 3.30 Modification ------------------------------------------------------
  2015 000008CB 730D                    		JNC	short OK11_Op
  2016 000008CD 80FC11                  		CMP	AH,11H		; ONLY ALLOW ECC ERRORS
  2017 000008D0 7517                    		JNZ	short OK11_EXIT_err ; Other error?
  2018 000008D2 B400                    		mov	ah,0		; ECC error. Reset it again.
  2019 000008D4 9C                      		pushf
  2020 000008D5 2EFF1E[AE00]            		call	far [CS:ORIG13]
  2021                                  OK11_Op:
  2022                                  					; adjust number of sectors for one read
  2023 000008DA 2EFE0E[1400]            		dec	byte [CS:Number_Of_Sec]	
  2024 000008DF 7409                    		jz	short OK11_Exit	; all done?
  2025 000008E1 FEC1                    		inc	CL		; advance sector number
  2026 000008E3 FEC7                    		inc	BH		; add 200H to address
  2027 000008E5 FEC7                    		inc	BH
  2028 000008E7 EBD3                    		jmp	short Loop_ECC	; and around for reading another sector
  2029                                  
  2030                                  OK11_EXIT_err:
  2031 000008E9 F9                      		stc			; Set carry bit again.
  2032                                  ;;End of Modification ------------------------------------------------------
  2033                                  
  2034                                  OK11_Exit:
  2035 000008EA 5A                      		pop	dx
  2036 000008EB 59                      		pop	cx
  2037 000008EC 5B                      		pop	bx
  2038                                  		;14/06/2018
  2039 000008ED CA0200                  		retf	2
  2040                                  
  2041                                  ;
  2042                                  ; we truly have a DMA violation.  Restore register AX and retry the
  2043                                  ; operation as best we can.
  2044                                  ;
  2045                                  GotDMAErr:
  2046 000008F0 58                      		pop	AX		; clean up stack
  2047 000008F1 2EA1[1200]              		mov	AX,[cs:PrevOper] ; restore command
  2048 000008F5 FB                      		sti			; restore interrupts
  2049 000008F6 80FC02                  		cmp	AH,ROMRead	; determine the command
  2050 000008F9 7266                    		jb	short IntDone
  2051 000008FB 80FC04                  		cmp	AH,ROMVerify
  2052 000008FE 7439                    		jz	short IntVerify
  2053 00000900 80FC05                  		cmp	AH,ROMFormat
  2054 00000903 7446                    		jz	short IntFormat
  2055 00000905 775A                    		ja	short IntDone
  2056                                  ;
  2057                                  ; We are doing a read/write call.  Check for DMA problems
  2058                                  ;
  2059 00000907 52                      		push	dx		; save registers we overwrite
  2060 00000908 51                      		push	cx
  2061 00000909 53                      		push	bx
  2062 0000090A 50                      		push	ax
  2063                                  
  2064 0000090B 55                      		push	BP
  2065 0000090C 89E5                    		mov	BP,SP
  2066 0000090E 8CC2                    		mov	DX,ES		; Check for 64k boundary error
  2067                                  
  2068 00000910 D1E2                    		shl	DX,1
  2069 00000912 D1E2                    		shl	DX,1
  2070 00000914 D1E2                    		shl	DX,1
  2071 00000916 D1E2                    		shl	DX,1		; Segment converted to absolute address
  2072                                  
  2073 00000918 01DA                    		add	DX,BX		; Combine with offset
  2074 0000091A 81C2FF01                		add	DX,511		; simulate a transfer
  2075                                  ;
  2076                                  ; If carry is set, then we are within 512 bytes of the end of the segment.
  2077                                  ; We skip the first transfer and perform the remaining buffering and transfer
  2078                                  ;
  2079 0000091E 7306                    		JNC	short NO_SKIP_FIRST
  2080 00000920 8A7609                  		mov	DH,[bp+INT13FRAME.olddx+1] ; set correct head number
  2081 00000923 E99A00                  		jmp	Buffer
  2082                                  
  2083                                  NO_SKIP_FIRST:
  2084                                  ;
  2085                                  ; DX is the physical 16 bits of start of transfer.  Compute remaining
  2086                                  ; sectors in segment.
  2087                                  ;
  2088 00000926 D0EE                    		shr	DH,1		; DH = number of sectors before address
  2089 00000928 B480                    		mov	AH,128		; AH = max number of sectors in segment
  2090 0000092A 28F4                    		sub	AH,DH
  2091                                  ;
  2092                                  ; AH is now the number of sectors that we can successfully write in this
  2093                                  ; segment.  If this number is above or equal to the requested number, then we
  2094                                  ; continue the operation as normal.  Otherwise, we break it into pieces.
  2095                                  ;
  2096 0000092C 38C4                    		cmp	AH,AL		; can we fit it in?
  2097 0000092E 7236                    		jb	short DoBlock	; no, perform blocking.
  2098                                  ;
  2099                                  ; Yes, the request fits.  Let it happen
  2100                                  ;
  2101 00000930 8A7609                  		MOV	DH,[BP+INT13FRAME.olddx+1] ; SET UP HEAD NUMBER
  2102 00000933 E8AD10                  		call	DoINT
  2103 00000936 E9F100                  		jmp	Bad13
  2104                                  ;
  2105                                  ; Verify the given sectors.  Place the buffer pointer into our space.
  2106                                  ;
  2107                                  IntVerify:
  2108 00000939 06                      		push	es
  2109 0000093A 53                      		push	bx
  2110 0000093B 0E                      		push	CS
  2111 0000093C 07                      		pop	ES
  2112                                  DoSimple:
  2113 0000093D BB[3001]                		mov	BX,DiskSector
  2114 00000940 9C                      		pushf
  2115 00000941 2EFF1E[AE00]            		call	far [CS:ORIG13]
  2116 00000946 5B                      		pop	bx
  2117 00000947 07                      		pop	es
  2118                                  		;14/06/2018
  2119 00000948 CA0200                  		retf	2
  2120                                  
  2121                                  ;
  2122                                  ; Format operation.  Copy the parameter table into memory
  2123                                  ;
  2124                                  IntFormat:
  2125 0000094B 06                      		push	es
  2126 0000094C 53                      		push	bx
  2127 0000094D 56                      		push	si
  2128 0000094E 57                      		push	di
  2129 0000094F 1E                      		push	ds
  2130 00000950 06                      		push	ES
  2131 00000951 0E                      		push	CS
  2132 00000952 07                      		pop	ES
  2133 00000953 1F                      		pop	DS
  2134 00000954 89DE                    		mov	SI,BX
  2135 00000956 BF[3001]                		mov	DI,DiskSector
  2136 00000959 E87E10                  		call	Move
  2137 0000095C 1F                      		pop	ds
  2138 0000095D 5F                      		pop	di
  2139 0000095E 5E                      		pop	si
  2140 0000095F EBDC                    		jmp	short DoSimple
  2141                                  ;
  2142                                  ; Inline continuation of operation
  2143                                  ;
  2144                                  IntDone:
  2145 00000961 2EFF2E[AE00]            		jmp	far [CS:ORIG13]
  2146                                  ;
  2147                                  ; We can't fit the request into the entire block.  Perform the operation on
  2148                                  ; the first block.
  2149                                  ;
  2150                                  ;
  2151                                  ; DoBlock is modified to correctly handle multi-sector disk I/O. 
  2152                                  ; Old DoBlock had added the number of sectors I/Oed (AH in Old DoBlock) after
  2153                                  ; the DoInt call to CL.  Observing only the lower 6 bits of CL(=max. 64) can
  2154                                  ; represent a starting sector, if AH was big, then CL would be clobbered.
  2155                                  ; By the way, we still are going to use CL for this purpose since Checkwrap
  2156                                  ; routine will use it as an input.  To prevent CL from being clobbered, a 
  2157                                  ; safe number of sectors should be calculated like "63 - # of sectors/track".
  2158                                  ; DoBlock will handle the first block of requested sectors within the
  2159                                  ; boundary of this safe value.
  2160                                  
  2161                                  ;Try to get the # of sectors/track from BDS via Rom drive number.
  2162                                  ;For any mini disks installed, here we have to pray that they have the
  2163                                  ;same # of sector/track as the main DOS partition disk drive.
  2164                                  
  2165                                  DoBlock:
  2166                                  ;;Rev 3.30 Modification ------------------------------------------------------
  2167                                  		;mov	dx,[bp+INT13FRAME] ;set head #
  2168 00000966 8B5608                  		mov	dx,[bp+INT13FRAME.olddx] ;set head # ; 17/07/2019
  2169 00000969 57                      		push	di					
  2170 0000096A 1E                      		push	ds					
  2171 0000096B 50                      		push	ax		;AH=# of sectors before DMA err
  2172                                  					;AL - User requeseted # of sectors
  2173 0000096C 2EC606[6C00]01          		mov	byte [CS:PHYS_DRV],1				
  2174 00000972 88D0                    		mov	al, dl							
  2175 00000974 E83205                  		call	SETDRIVE	;get BDS pointer for this DISK. 
  2176 00000977 58                      		pop	ax							
  2177 00000978 2EC606[6C00]00          		mov	byte [CS:PHYS_DRV],0				
  2178 0000097E F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;don't have to worry
  2179 00000983 7504                    		jnz	short DoBlockHard ;about floppies. They are track by
  2180                                  					;track operations	
  2181 00000985 88E0                    		mov	al, ah		;set al = ah for floppies
  2182 00000987 EB0F                    		jmp	short DoBlockCont			
  2183                                  DoBlockHard:					
  2184 00000989 51                      		push	cx				
  2185 0000098A 31C9                    		xor	cx, cx				
  2186 0000098C 8B4D13                  		mov	cx, [DI+BDS.SECLIM] ;# of sectors/track
  2187 0000098F B53F                    		mov	ch, 63						
  2188 00000991 28CD                    		sub	ch, cl						
  2189 00000993 88E8                    		mov	al, ch						
  2190 00000995 86E0                    		xchg	ah, al		;now ah - safe # of sectors
  2191                                  					;al - # of sectors before DMA err
  2192 00000997 59                      		pop	cx							
  2193                                  DoBlockCont:								
  2194 00000998 1F                      		pop	ds							
  2195 00000999 5F                      		pop	di							
  2196                                  DoBlockContinue:							
  2197 0000099A 38C4                    		cmp	ah, al		;if safe_# >= #_of_sectors_to_go_before DMA,
  2198 0000099C 7305                    		jae	short DoBlocklast ;then #_of_sectors_to_go as it is for DoInt.
  2199 0000099E 50                      		push	ax		;save AH, AL				
  2200 0000099F 88E0                    		mov	al, ah		;Otherwise, set al to ah to operate.
  2201                                  			;DoInt will set AH to a proper function in [BP.Oldax]	
  2202 000009A1 EB03                    		jmp	short DoBlockDoInt 
  2203                                  DoBlocklast:						
  2204 000009A3 88C4                    		mov	ah, al					
  2205 000009A5 50                      		push	ax		;save AH	
  2206                                  DoBlockDoInt:				;let AH=AL=# of sectors this shot
  2207 000009A6 E83A10                  		CALL	DoINT							 
  2208 000009A9 727F                    		JC	short Bad13	;something happened, bye!	 
  2209 000009AB 58                      		pop	ax
  2210                                  					;decrement by the successful operation							 
  2211 000009AC 286602                  		SUB	BYTE [BP+INT13FRAME.oldax], AH 	
  2212 000009AF 00E1                    		ADD	CL,AH		;advance sector number. Safety guaranteed.	
  2213 000009B1 00E7                    		ADD	BH,AH		;advance DMA address			
  2214 000009B3 00E7                    		ADD	BH,AH		;twice for 512 byte sectors.	
  2215 000009B5 38C4                    		cmp	ah, al		;check the previous value	
  2216 000009B7 7407                    		je	short Buffer	;if #_of_sectors_to_go < safe_#, 
  2217                                  					; then we are done already. 
  2218 000009B9 28E0                    		sub	al, ah		;otherwise, 
  2219                                  					; #_sector_to_go = #_of_sector_to_go - safe_#  
  2220 000009BB E8640F                  		call	Check_Wrap	;get new CX, DH for the next operation. 		  
  2221 000009BE EBDA                    		jmp	short DoBlockContinue ;handles next sectors left.			
  2222                                  ;;End of Modification ------------------------------------------------------
  2223                                  ;
  2224                                  Buffer:
  2225 000009C0 53                      		push	BX
  2226 000009C1 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  2227 000009C4 80FC03                  		cmp	AH,ROMWrite
  2228 000009C7 7525                    		jnz	short DoRead
  2229                                  ;
  2230                                  ; Copy the offending sector into local buffer
  2231                                  ;
  2232 000009C9 1E                      		push	ds
  2233 000009CA 06                      		push	es
  2234 000009CB 56                      		push	si
  2235 000009CC 57                      		push	di
  2236 000009CD 0E                      		push	CS		; exchange segment registers
  2237 000009CE 06                      		push	ES
  2238 000009CF 1F                      		pop	DS
  2239 000009D0 07                      		pop	ES
  2240 000009D1 BF[3001]                		mov	DI,DiskSector	; where to move
  2241 000009D4 57                      		push	DI		; save it
  2242 000009D5 89DE                    		mov	SI,BX		; source
  2243 000009D7 E80010                  		call	Move
  2244 000009DA 5B                      		pop	BX		; new transfer address
  2245 000009DB 5F                      		pop	di
  2246 000009DC 5E                      		pop	si
  2247 000009DD B001                    		mov	AL,1
  2248 000009DF 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  2249 000009E2 E83D0F                  		call	Check_Wrap	; check for head or cylinder wrap
  2250                                  ;
  2251                                  ;   AH is function
  2252                                  ;   AL is 1 for single sector transfer
  2253                                  ;   ES:BX is local transfer addres
  2254                                  ;   CX is track/sector number
  2255                                  ;   DX is head/drive number
  2256                                  ;   SI,DI unchanged
  2257                                  ;
  2258 000009E5 E8FB0F                  		CALL	DoINT
  2259 000009E8 07                      		pop	es
  2260 000009E9 1F                      		pop	ds
  2261 000009EA 723E                    		jc	short Bad13	; go clean up
  2262 000009EC EB26                    		jmp	SHORT DoTail
  2263                                  ;
  2264                                  ; Reading a sector.  Do INT first, then move things around
  2265                                  ;
  2266                                  DoRead:
  2267 000009EE 06                      		push	es
  2268 000009EF 53                      		push	bx
  2269 000009F0 0E                      		push	CS
  2270 000009F1 07                      		pop	ES
  2271 000009F2 BB[3001]                		mov	BX,DiskSector
  2272 000009F5 B001                    		mov	AL,1
  2273 000009F7 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  2274 000009FA E8250F                  		call	Check_Wrap	; check for head or cylinder wrap
  2275                                  ;
  2276                                  ;   AH = function
  2277                                  ;   AL = 1 for single sector
  2278                                  ;   ES:BX points to local buffer
  2279                                  ;   CX, DX are track/sector, head/drive
  2280                                  ;
  2281 000009FD E8E30F                  		CALL	DoINT
  2282 00000A00 5B                      		pop	bx
  2283 00000A01 07                      		pop	es
  2284 00000A02 7226                    		jc	short Bad13	; error => clean up
  2285 00000A04 1E                      		push	ds
  2286 00000A05 56                      		push	si
  2287 00000A06 57                      		push	di
  2288 00000A07 0E                      		push	CS
  2289 00000A08 1F                      		pop	DS
  2290 00000A09 89DF                    		mov	DI,BX
  2291 00000A0B BE[3001]                		mov	SI,DiskSector
  2292 00000A0E E8C90F                  		call	Move
  2293 00000A11 5F                      		pop	di
  2294 00000A12 5E                      		pop	si
  2295 00000A13 1F                      		pop	ds
  2296                                  ;
  2297                                  ; Note the fact that we've done 1 more sector
  2298                                  ;
  2299                                  DoTail:
  2300 00000A14 5B                      		pop	BX		; retrieve new DMA area
  2301 00000A15 80C702                  		add	BH,2		; advance over sector
  2302 00000A18 41                      		inc	CX
  2303 00000A19 8A4602                  		mov	AL,[BP+INT13FRAME.oldax]
  2304 00000A1C F8                      		clc
  2305 00000A1D FEC8                    		dec	AL
  2306 00000A1F 7409                    		jz	short Bad13	; no more I/O
  2307 00000A21 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  2308 00000A24 E8FB0E                  		call	Check_Wrap	; check for head or cylinder wrap
  2309 00000A27 E8B90F                  		call	DoINT
  2310                                  ;
  2311                                  ; We are done.	AX has the final code; we throw away what we got before
  2312                                  ;
  2313                                  Bad13:
  2314 00000A2A 89EC                    		mov	SP,BP
  2315 00000A2C 5D                      		pop	bp
  2316 00000A2D 5B                      		pop	bx
  2317 00000A2E 5B                      		pop	bx
  2318 00000A2F 59                      		pop	cx
  2319 00000A30 5A                      		pop	dx
  2320                                  		; 06/07/2018
  2321 00000A31 CA0200                  		retf	2
  2322                                  
  2323                                  ; 29/06/2019 - Retro DOS v3.1
  2324                                  
  2325                                  ;-----------------------------------------------------------------------------
  2326                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  2327                                  ;-----------------------------------------------------------------------------
  2328                                  ; 29/05/2018 - Retro DOS v3.0
  2329                                  ; 25/03/2018 - Retro DOS v2.0 
  2330                                  
  2331                                  ;  INT19
  2332                                  ;
  2333                                  ;	We "hook" the INT_REBOOT vector, because contrary to IBM documentation,
  2334                                  ;  it does NOT "bootstrap" the machine.  It leaves memory almost untouched.
  2335                                  ;  Since the BIOS_INIT code assumes that certain Interrupt Vectors point to
  2336                                  ;  the ROM_BIOS  we must "unhook" them before issuing the actual INT_REBOOT.
  2337                                  ;  Currently the following vectors need to be unhooked:
  2338                                  ;		  02,08,09,0A,0B,0C,0D,0E,70,72,73,74,75,76,77
  2339                                  ;
  2340                                  
  2341                                  INT19:
  2342 00000A34 31C0                    		xor	AX,AX		; get data segment to
  2343 00000A36 8ED8                    		mov	DS,AX		;   point to the vector table
  2344 00000A38 2EC43E[AA00]            		les	DI,[CS:OLD13]	; get ES to point to this segment
  2345 00000A3D 893E4C00                		mov	[13h*4],DI	; restore old int13 value
  2346 00000A41 8C064E00                		mov	[13h*4+2],ES
  2347                                  
  2348 00000A45 2E803E[A405]00          		cmp	byte [CS:INT19SEM], 0
  2349 00000A4B 7503                    		jnz	short int19vecs
  2350 00000A4D E96201                  		jmp	doint19
  2351                                  
  2352                                  ;Stacks code has changed these hardware interrupt vectors
  2353                                  ;STKINIT in SYSINIT1 will initialize Int19hOLDxx values.
  2354                                  
  2355                                  int19vecs:
  2356                                  
  2357                                  ;
  2358                                  ; we now need to unhook all the vector replace to prevent stack overflow
  2359                                  ;
  2360                                  
  2361                                  ;;Rev 3.30 modification ----------------------------
  2362                                  
  2363 00000A50 31C0                    		XOR	AX,AX
  2364 00000A52 8ED8                    		MOV	DS,AX
  2365                                  
  2366                                  		;IRP	AA,<02,08,09,0A,0B,0C,0D,0E,70,72,73,74,76,77>
  2367                                  
  2368                                  		;LES	DI,Int19OLD&AA
  2369                                  
  2370 00000A54 2EC43E[AC05]            		LES	DI,[CS:INT19OLD02] ; 15/06/2018
  2371                                  
  2372 00000A59 8CC0                    		mov	ax,es		; Put segment where we can compare it
  2373 00000A5B 83F8FF                  		cmp	ax,-1		; OPT 0ffffh is not likely
  2374                                  		;je	skip_int&AA	; OPT could get away without checking
  2375 00000A5E 740D                    		je	short skip_int02
  2376 00000A60 83FFFF                  		cmp	di,-1		; OPT offset here.
  2377                                  		;je	skip_int&AA
  2378 00000A63 7408                    		je	short skip_int02
  2379                                  
  2380                                  		;MOV	DS:[AA&H*4],DI
  2381 00000A65 893E0800                		mov	[02H*4],DI
  2382                                  		;MOV	DS:[AA&H*4+2],ES
  2383 00000A69 8C060A00                		mov	[02H*4+2],ES
  2384                                  	
  2385                                  ;skip_int&AA:
  2386                                  skip_int02:
  2387                                  		;ENDM
  2388                                  
  2389 00000A6D 2EC43E[B005]            		LES	DI,[CS:INT19OLD08]
  2390                                  
  2391 00000A72 8CC0                    		mov	ax,es
  2392 00000A74 83F8FF                  		cmp	ax,-1
  2393 00000A77 740D                    		je	short skip_int08
  2394 00000A79 83FFFF                  		cmp	di,-1
  2395 00000A7C 7408                    		je	short skip_int08
  2396                                  
  2397 00000A7E 893E2000                		mov	[08H*4],DI
  2398 00000A82 8C062200                		mov	[08H*4+2],ES
  2399                                  	
  2400                                  skip_int08:
  2401 00000A86 2EC43E[B405]            		LES	DI,[CS:INT19OLD09]
  2402                                  
  2403 00000A8B 8CC0                    		mov	ax,es
  2404 00000A8D 83F8FF                  		cmp	ax,-1
  2405 00000A90 740D                    		je	short skip_int09
  2406 00000A92 83FFFF                  		cmp	di,-1
  2407 00000A95 7408                    		je	short skip_int09
  2408                                  
  2409 00000A97 893E2400                		mov	[09H*4],DI
  2410 00000A9B 8C062600                		mov	[09H*4+2],ES
  2411                                  	
  2412                                  skip_int09:
  2413 00000A9F 2EC43E[B805]            		LES	DI,[CS:INT19OLD0A]
  2414                                  
  2415 00000AA4 8CC0                    		mov	ax,es
  2416 00000AA6 83F8FF                  		cmp	ax,-1
  2417 00000AA9 740D                    		je	short skip_int0A
  2418 00000AAB 83FFFF                  		cmp	di,-1
  2419 00000AAE 7408                    		je	short skip_int0A
  2420                                  
  2421 00000AB0 893E2800                		mov	[0AH*4],DI
  2422 00000AB4 8C062A00                		mov	[0AH*4+2],ES
  2423                                  	
  2424                                  skip_int0A:
  2425 00000AB8 2EC43E[BC05]            		LES	DI,[CS:INT19OLD0B]
  2426                                  
  2427 00000ABD 8CC0                    		mov	ax,es
  2428 00000ABF 83F8FF                  		cmp	ax,-1
  2429 00000AC2 740D                    		je	short skip_int0B
  2430 00000AC4 83FFFF                  		cmp	di,-1
  2431 00000AC7 7408                    		je	short skip_int0B
  2432                                  
  2433 00000AC9 893E2C00                		mov	[0BH*4],DI
  2434 00000ACD 8C062E00                		mov	[0BH*4+2],ES
  2435                                  	
  2436                                  skip_int0B:
  2437 00000AD1 2EC43E[C005]            		LES	DI,[CS:INT19OLD0C]
  2438                                  
  2439 00000AD6 8CC0                    		mov	ax,es
  2440 00000AD8 83F8FF                  		cmp	ax,-1
  2441 00000ADB 740D                    		je	short skip_int0C
  2442 00000ADD 83FFFF                  		cmp	di,-1
  2443 00000AE0 7408                    		je	short skip_int0C
  2444                                  
  2445 00000AE2 893E3000                		mov	[0CH*4],DI
  2446 00000AE6 8C063200                		mov	[0CH*4+2],ES
  2447                                  	
  2448                                  skip_int0C:
  2449 00000AEA 2EC43E[C405]            		LES	DI,[CS:INT19OLD0D]
  2450                                  
  2451 00000AEF 8CC0                    		mov	ax,es
  2452 00000AF1 83F8FF                  		cmp	ax,-1
  2453 00000AF4 740D                    		je	short skip_int0D
  2454 00000AF6 83FFFF                  		cmp	di,-1
  2455 00000AF9 7408                    		je	short skip_int0D
  2456                                  
  2457 00000AFB 893E3400                		mov	[0DH*4],DI
  2458 00000AFF 8C063600                		mov	[0DH*4+2],ES
  2459                                  	
  2460                                  skip_int0D:
  2461 00000B03 2EC43E[C805]            		LES	DI,[CS:INT19OLD0E]
  2462                                  
  2463 00000B08 8CC0                    		mov	ax,es
  2464 00000B0A 83F8FF                  		cmp	ax,-1
  2465 00000B0D 740D                    		je	short skip_int0E
  2466 00000B0F 83FFFF                  		cmp	di,-1
  2467 00000B12 7408                    		je	short skip_int0E
  2468                                  
  2469 00000B14 893E3800                		mov	[0EH*4],DI
  2470 00000B18 8C063A00                		mov	[0EH*4+2],ES
  2471                                  	
  2472                                  skip_int0E:
  2473 00000B1C 2EC43E[CC05]            		LES	DI,[CS:INT19OLD70]
  2474                                  
  2475 00000B21 8CC0                    		mov	ax,es
  2476 00000B23 83F8FF                  		cmp	ax,-1
  2477 00000B26 740D                    		je	short skip_int70
  2478 00000B28 83FFFF                  		cmp	di,-1
  2479 00000B2B 7408                    		je	short skip_int70
  2480                                  
  2481 00000B2D 893EC001                		mov	[70H*4],DI
  2482 00000B31 8C06C201                		mov	[70H*4+2],ES
  2483                                  	
  2484                                  skip_int70:
  2485 00000B35 2EC43E[D005]            		LES	DI,[CS:INT19OLD72]
  2486                                  
  2487 00000B3A 8CC0                    		mov	ax,es
  2488 00000B3C 83F8FF                  		cmp	ax,-1
  2489 00000B3F 740D                    		je	short skip_int72
  2490 00000B41 83FFFF                  		cmp	di,-1
  2491 00000B44 7408                    		je	short skip_int72
  2492                                  
  2493 00000B46 893EC801                		mov	[72H*4],DI
  2494 00000B4A 8C06CA01                		mov	[72H*4+2],ES
  2495                                  	
  2496                                  skip_int72:
  2497 00000B4E 2EC43E[D405]            		LES	DI,[CS:INT19OLD73]
  2498                                  
  2499 00000B53 8CC0                    		mov	ax,es
  2500 00000B55 83F8FF                  		cmp	ax,-1
  2501 00000B58 740D                    		je	short skip_int73
  2502 00000B5A 83FFFF                  		cmp	di,-1
  2503 00000B5D 7408                    		je	short skip_int73
  2504                                  
  2505 00000B5F 893ECC01                		mov	[73H*4],DI
  2506 00000B63 8C06CE01                		mov	[73H*4+2],ES
  2507                                  	
  2508                                  skip_int73:
  2509 00000B67 2EC43E[D805]            		LES	DI,[CS:INT19OLD74]
  2510                                  
  2511 00000B6C 8CC0                    		mov	ax,es
  2512 00000B6E 83F8FF                  		cmp	ax,-1
  2513 00000B71 740D                    		je	short skip_int74
  2514 00000B73 83FFFF                  		cmp	di,-1
  2515 00000B76 7408                    		je	short skip_int74
  2516                                  
  2517 00000B78 893ED001                		mov	[74H*4],DI
  2518 00000B7C 8C06D201                		mov	[74H*4+2],ES
  2519                                  	
  2520                                  skip_int74:
  2521 00000B80 2EC43E[DC05]            		LES	DI,[CS:INT19OLD76]
  2522                                  
  2523 00000B85 8CC0                    		mov	ax,es
  2524 00000B87 83F8FF                  		cmp	ax,-1
  2525 00000B8A 740D                    		je	short skip_int76
  2526 00000B8C 83FFFF                  		cmp	di,-1
  2527 00000B8F 7408                    		je	short skip_int76
  2528                                  
  2529 00000B91 893ED801                		mov	[76H*4],DI
  2530 00000B95 8C06DA01                		mov	[76H*4+2],ES
  2531                                  	
  2532                                  skip_int76:
  2533 00000B99 2EC43E[E005]            		LES	DI,[CS:INT19OLD77]
  2534                                  
  2535 00000B9E 8CC0                    		mov	ax,es
  2536 00000BA0 83F8FF                  		cmp	ax,-1
  2537 00000BA3 740D                    		je	short skip_int77
  2538 00000BA5 83FFFF                  		cmp	di,-1
  2539 00000BA8 7408                    		je	short skip_int77
  2540                                  
  2541 00000BAA 893EDC01                		mov	[77H*4],DI
  2542 00000BAE 8C06DE01                		mov	[77H*4+2],ES
  2543                                  	
  2544                                  skip_int77:
  2545                                  
  2546                                  ;;End of modification ----------------------------
  2547                                  
  2548                                  doint19:
  2549 00000BB2 2EC43E[A805]            		LES	DI,[CS:ORIG19]
  2550 00000BB7 893E6400                		MOV	[19h*4],DI
  2551 00000BBB 8C066600                		MOV	[19h*4+2],ES
  2552                                  
  2553 00000BBF CD19                    		INT	19h
  2554                                  
  2555                                  
  2556                                  ;-----------------------------------------------------------------------------
  2557                                  ; MSCON.ASM - MSDOS 3.3 - 24/07/1987
  2558                                  ;-----------------------------------------------------------------------------
  2559                                  ; 23/03/2018 - Retro DOS v2.0
  2560                                  
  2561                                  ;----------------------------------------------------------------
  2562                                  ;								:
  2563                                  ;	      CON - CONSOLE DEVICE DRIVER			:
  2564                                  ;								:
  2565                                  ;								:
  2566                                  ;   This file contains the Console Device Driver.  The		:
  2567                                  ; console device driver sends characters to the moniter and	:
  2568                                  ; gets characters from the keyboard.				:
  2569                                  ;								:
  2570                                  ;----------------------------------------------------------------
  2571                                  
  2572                                  
  2573                                  ;----------------------------------------------------------------
  2574                                  ;								:
  2575                                  ;		    Console read routine			:
  2576                                  ;								:
  2577                                  ;----------------------------------------------------------------
  2578                                  ;
  2579                                  
  2580                                  CON$READ:					; if CX is zero, no characters
  2581 00000BC1 E306                    		jcxz	CON$EXIT		;   to be read -- just exit
  2582                                  CON$LOOP:
  2583 00000BC3 E80600                  		call	CHRIN			; get char in AL
  2584 00000BC6 AA                      		stosb				; store char at ES:DI, specified buffer
  2585 00000BC7 E2FA                    		loop	CON$LOOP		; if CX is non-zero more char to read
  2586                                  CON$EXIT:
  2587                                  		;jmp	short EXIT		; all done, successful return
  2588 00000BC9 E92AFB                  		jmp	EXIT ; 26/09/2019 - Retro DOS v3.1
  2589                                  
  2590                                  ;----------------------------------------------------------------
  2591                                  ;								:
  2592                                  ;	    Input single character into AL			:
  2593                                  ;								:
  2594                                  ;----------------------------------------------------------------
  2595                                  CHRIN:
  2596                                  						; set command to read character
  2597 00000BCC 31C0                    		xor	AX, AX			;  and clear AL
  2598 00000BCE 8606[0800]              		xchg	AL,[ALTAH]		; get character & zero ALTAH
  2599 00000BD2 08C0                    		or	AL, AL			; see if buffer has a character
  2600 00000BD4 7515                    		jnz	short KEYRET		; if so - return this character
  2601                                  						; if not - read single character
  2602 00000BD6 CD16                    		int	16h			; call ROM-Bios keyboard routine
  2603                                  ALT10:
  2604 00000BD8 09C0                    		or	AX,AX			; Check for non-key after BREAK
  2605 00000BDA 74F0                    		jz	short CHRIN
  2606 00000BDC 3D0072                  		cmp	AX,7200h		; Check for CTRL-PRTSC
  2607 00000BDF 7502                    		jnz	short ALT15
  2608 00000BE1 B010                    		mov	AL,16			; indicate prtsc
  2609                                  ALT15:
  2610 00000BE3 08C0                    		or	AL,AL			; special case?
  2611 00000BE5 7504                    		jnz	short KEYRET		; no, return with character
  2612 00000BE7 8826[0800]              		mov	[ALTAH], AH		; yes, store special key
  2613                                  KEYRET:
  2614 00000BEB C3                      		RETN
  2615                                  
  2616                                  ;----------------------------------------------------------------
  2617                                  ;								:
  2618                                  ;	   Keyboard non destructive read, no wait		:
  2619                                  ;								:
  2620                                  ; If bit 10 is set by the DOS in the status word of the request :
  2621                                  ; packet, and there is no character in the input buffer, the	:
  2622                                  ; driver issues a system WAIT request to the ROM. On return	:
  2623                                  ; from the ROM, it returns a 'char-not-found' to the DOS.       :
  2624                                  ;								:
  2625                                  ;----------------------------------------------------------------
  2626                                  
  2627                                  		; 13/06/2018 (Retro DOS v3.0, IBMDOS 3.0, IBMBIO.COM) 
  2628                                  ;CONBUSJ:
  2629                                  ;		JMP	short CONBUS
  2630                                  
  2631                                  CON$RDND:
  2632 00000BEC A0[0800]                		mov	AL,[ALTAH]		; first see if there is a
  2633 00000BEF 08C0                    		or	AL,AL			; character in the buffer?
  2634                                  		;jz	short RD1		; with debugging code it is
  2635                                  		;jmp	short RDEXIT		; too far for conditional jump
  2636 00000BF1 7532                    		jnz	short RDEXIT
  2637                                  
  2638                                  RD1:				     		; set command to 'see if
  2639 00000BF3 B401                    		mov	AH, 1	     		; character available'
  2640 00000BF5 CD16                    		int	16h	     		; call ROM-BIOS keyboard routine
  2641 00000BF7 7402                    		jz	short nochr		; with debugging code it is
  2642 00000BF9 EB1B                    		jmp	short gotchr		; to far for conditional jump
  2643                                  nochr:
  2644 00000BFB 803E[6E00]00            		cmp	byte [fHaveK09], 0
  2645                                  		;jz	short CONBUSJ
  2646 00000C00 742D                    		jz	short CONBUS
  2647 00000C02 C51E[0A00]              		lds	bx,[PTRSAV]		; get pointer to request header
  2648 00000C06 F747030004              		test	word [bx+STATUS],0400h	; System WAIT enabled?
  2649                                  		;jz	short CONBUSJ 		; no, get out
  2650 00000C0B 7422                    		jz	short CONBUS
  2651                                  
  2652 00000C0D B80041                  		mov	AX, 4100h     		; set command for Wait on External
  2653                                  				      		; event and condition type to
  2654                                  				      		; any external event
  2655 00000C10 30DB                    		xor	BL,BL			; no timeout value
  2656 00000C12 CD15                    		int	15h	      		; call rom-bios sleep function
  2657 00000C14 EB19                    		jmp	short CONBUS		; after wait exit to con busy
  2658                                  
  2659                                  gotchr:
  2660 00000C16 09C0                    		or	AX, AX			; check for null after break
  2661 00000C18 7504                    		JNZ	short NOTBRK		; no, skip down
  2662                                  		;mov	ah, 0
  2663                                  ; note: AH is already zero, no need to set command
  2664 00000C1A CD16                    		int	16h			; yes, read the null
  2665 00000C1C EBCE                    		Jmp	short CON$RDND		; and get a real status
  2666                                  
  2667                                  NOTBRK:
  2668 00000C1E 3D0072                  		cmp	AX, 7200H		; check for ctrl-prtsc
  2669 00000C21 7502                    		jnz	short RDEXIT		; no
  2670 00000C23 B010                    		mov	AL, 16			; yes, indicate ctrl-prtsc
  2671                                  
  2672                                  RDEXIT:
  2673 00000C25 C51E[0A00]              		lds	BX, [PTRSAV]		; get pointer to request header
  2674 00000C29 88470D                  		mov	[BX+MEDIA], AL		; move character into req. header
  2675                                  EXVEC:
  2676 00000C2C E9C7FA                  		jmp	EXIT			; all done -- successful return
  2677                                  CONBUS:
  2678 00000C2F E9A9FA                  		Jmp	BUS$EXIT		; done -- con device is busy
  2679                                  
  2680                                  ;----------------------------------------------------------------
  2681                                  ;								:
  2682                                  ;		Keyboard flush routine				:
  2683                                  ;								:
  2684                                  ;----------------------------------------------------------------
  2685                                  
  2686                                  CON$FLSH:
  2687 00000C32 E80300                  		call	FLUSH
  2688 00000C35 E9BEFA                  		jmp	EXIT
  2689                                  
  2690                                  FLUSH:
  2691 00000C38 C606[0800]00            		mov	byte [ALTAH], 0	; clear out holding buffer
  2692                                  
  2693                                  FlLoop:
  2694                                  				 	; Is there a char there?
  2695 00000C3D B401                    		mov	AH, 1	 	; command code for check status
  2696 00000C3F CD16                    		int	16h	 	; call rom-bios keyboard routine
  2697                                  					; if z flag is set then no character
  2698 00000C41 7406                    		jz	short FlDone	; is ready, buffer is empty -- get out
  2699 00000C43 30E4                    		xor	AH, AH	 	; if zf is nof set, get character
  2700 00000C45 CD16                    		int	16h	 	; call rom-bios to get character
  2701 00000C47 EBF4                    		jmp	short FlLoop	; repeat until buffer is empty
  2702                                  FlDone:
  2703 00000C49 C3                      		retn
  2704                                  
  2705                                  ;----------------------------------------------------------------
  2706                                  ;								:
  2707                                  ;	       Console Write Routine				:
  2708                                  ;								:
  2709                                  ;----------------------------------------------------------------
  2710                                  	
  2711                                  CON$WRIT:
  2712 00000C4A E3E0                    		jcxz	EXVEC			; if CX is zero, get out
  2713                                  CON$LP:
  2714                                  		; 13/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM)
  2715 00000C4C 268A05                  		mov	AL,[ES:DI]		; get character
  2716 00000C4F 47                      		inc	DI			; point to next character
  2717 00000C50 CD29                    		int	CHROUT			; Output character
  2718 00000C52 E2F8                    		loop	CON$LP			; repeat until all through
  2719 00000C54 E99FFA                  		jmp	EXIT
  2720                                  
  2721                                  ;-----------------------------------------------------------------------------
  2722                                  ; MSAUX.ASM - MSDOS 3.3 - 24/07/1987
  2723                                  ;-----------------------------------------------------------------------------
  2724                                  ; 23/03/2018 - Retro DOS v2.0
  2725                                  
  2726                                  ;----------------------------------------------------------------
  2727                                  ;								:
  2728                                  ;	     A U X - AUXILARY DEVICE DRIVER			:
  2729                                  ;								:
  2730                                  ;								:
  2731                                  ;   This file contains the Auxilary Device Driver.  The 	:
  2732                                  ; auxilary driver handles calls to and from the RS-232 port.	:
  2733                                  ; Three devices uses this code: AUX, COM1, and COM2.  AUX and	:
  2734                                  ; COM1 talk to the zero RS-232 card and COM2 talks to the	:
  2735                                  ; 'one' RS-232 card.  The beginning of the interrupt entry      :
  2736                                  ; point for these devices sets the variable AUXNUM in the	:
  2737                                  ; msbio.asm module.  If the value is 0 the routines in this	:
  2738                                  ; file will talk to the the 'zero' card.  If the value in       :
  2739                                  ; AUXNUM is 1 the routines will talk to the 'one' card.         :
  2740                                  ; The procedure GETDX is called to put the value 0 or 1 in	:
  2741                                  ; the DX register depending on the value in AUXBUF.		:
  2742                                  ;								:
  2743                                  ;   The routines in this files are:				:
  2744                                  ;								:
  2745                                  ;	routine 		function			:
  2746                                  ;	------- 		--------			:
  2747                                  ;	AUX$READ		Read characters from the	:
  2748                                  ;				  specified device.		:
  2749                                  ;	AUX$RDND		Non-desrucrtive read with	:
  2750                                  ;				  no waiting.			:
  2751                                  ;	AUX$FLSH		Flush specified device input	:
  2752                                  ;				  buffer.			:
  2753                                  ;	AUX$WRIT		Write characters to the 	:
  2754                                  ;				  specified device.		:
  2755                                  ;	AUX$WRST		Get status of specified 	:
  2756                                  ;				  device			:
  2757                                  ;								:
  2758                                  ;  These routines are not called directly.  Call are made via	:
  2759                                  ; the strategy and interrupt entry point (see Device Header).	:
  2760                                  ;								:
  2761                                  ;  Data structure:						:
  2762                                  ;    The Aux Device has a two byte buffer called AUXBUF.  The	:
  2763                                  ;  first byte is for the zero card, the second byte is for the	:
  2764                                  ;  one card.  A zero value in the byte indicates the buffer is	:
  2765                                  ;  empty.  The routines use GETBX to get the address of the	:
  2766                                  ;  buffer.							:
  2767                                  ;								:
  2768                                  ;----------------------------------------------------------------
  2769                                  
  2770                                  ;		VALUES IN AH, REQUESTING FUNCTION OF INT 14H IN ROM BIOS
  2771                                  AUXFUNC_SEND	 EQU	1	;TRANSMIT
  2772                                  AUXFUNC_RECEIVE  EQU	2	;READ
  2773                                  AUXFUNC_STATUS	 EQU	3	;REQUEST STATUS
  2774                                  
  2775                                  ;		ERROR FLAGS, REPORTED BY INT 14H
  2776                                  
  2777                                  ;	 THESE FLAGS REPORTED IN AH:
  2778                                  FLAG_DATA_READY  EQU	01H	;DATA READY
  2779                                  FLAG_OVERRUN	 EQU	02H	;OVERRUN ERROR
  2780                                  FLAG_PARITY	 EQU	04H	;PARITY ERROR
  2781                                  FLAG_FRAME	 EQU	08H	;FRAMING ERROR
  2782                                  FLAG_BREAK	 EQU	10H	;BREAK DETECT
  2783                                  FLAG_TRANHOL_EMP EQU	20H	;TRANSMIT HOLDING REGISTER EMPTY
  2784                                  FLAG_TRANSHF_EMP EQU	40H	;TRANSMIT SHIFT REGISTER EMPTY
  2785                                  FLAG_TIMEOUT	 EQU	80H	;TIMEOUT
  2786                                  
  2787                                  ;	THESE FLAGS REPORTED IN AL:
  2788                                  FLAG_DELTA_CTS	 EQU	01H	;DELTA CLEAR TO SEND
  2789                                  FLAG_DELTA_DSR	 EQU	02H	;DELTA DATA SET READY
  2790                                  FLAG_TRAIL_RING  EQU	04H	;TRAILING EDGE RING INDICATOR
  2791                                  FLAG_DELTA_SIG	 EQU	08H	;DELTA RECEIVE LINE SIGNAL DETECT
  2792                                  FLAG_CTS	 EQU	10H	;CLEAR TO SEND
  2793                                  FLAG_DSR	 EQU	20H	;DATA SET READY
  2794                                  FLAG_RING	 EQU	40H	;RING INDICATOR
  2795                                  FLAG_REC_SIG	 EQU	80H	;RECEIVE LINE SIGNAL DETECT
  2796                                  
  2797                                  ;------------------------------------------------------------------
  2798                                  ;								  :
  2799                                  ;	Read zero or more characters from Auxilary Device	  :
  2800                                  ;								  :
  2801                                  ;	input:es:[di] points to area to receive aux data	  :
  2802                                  ;	      cx has number of bytes to be read 		  :
  2803                                  ;	      "auxnum" first byte has number of aux device (rel 0):
  2804                                  ;								  :
  2805                                  ;------------------------------------------------------------------
  2806                                  
  2807                                  AUX$READ:
  2808 00000C57 E311                    		jcxz	EXVEC2		; if no characters, get out
  2809 00000C59 E87E00                  		call	GETBX		; put address of AUXBUF in BX
  2810 00000C5C 31C0                    		xor	AX,AX		; clear AX register
  2811 00000C5E 8607                    		xchg	AL,[BX] 	; Get character , if any, from
  2812                                  					;   buffer and clear buffer
  2813 00000C60 08C0                    		or	AL,AL		; if AL is nonzero there was a
  2814                                  					;   character in the buffer
  2815 00000C62 7503                    		jnz	short AUX2	; if so skip AUXIN call
  2816                                  AUX1:					;
  2817 00000C64 E80600                  		call	AUXIN		; get character from port
  2818                                  AUX2:					;
  2819 00000C67 AA                      		stosb			; store character
  2820 00000C68 E2FA                    		loop	AUX1		; if more character, go around again
  2821                                  EXVEC2: 				;
  2822 00000C6A E989FA                  		jmp	EXIT		; all done, successful exit
  2823                                  
  2824                                  ;
  2825                                  ; AUXIN: make a call on ROM BIOS to read character from
  2826                                  ;	 the auxilary device, then do some error checking.
  2827                                  ;	 If an error occurs then AUXIN jumps to ERR$CNT and
  2828                                  ;	 does NOT return to where it was called from.
  2829                                  ;
  2830                                  
  2831                                  AUXIN:
  2832 00000C6D B402                    		mov	ah,AUXFUNC_RECEIVE
  2833 00000C6F E83F00                  		call	AUXOP
  2834                                  		 			;check for Frame, Parity, or Overrun errors
  2835                                  		 			;WARNING: these error bits are unpredictable 
  2836                                  		 			;         if timeout (bit 7) is set
  2837 00000C72 F6C40E                  		test	ah,FLAG_FRAME|FLAG_PARITY|FLAG_OVERRUN
  2838 00000C75 7406                    		jz	short AROK	;No error if all bits are clear
  2839                                  
  2840                                  		; 26/05/2018
  2841                                  		;Error getting character
  2842                                  		;add	sp,2		;Remove rtn address (near call)
  2843                                  		;xor	al,al
  2844                                  		;or	al,FLAG_REC_SIG | FLAG_DSR | FLAG_CTS
  2845                                  
  2846                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM)
  2847 00000C77 58                      		pop	ax
  2848 00000C78 B0B0                    		mov	al,FLAG_REC_SIG+FLAG_DSR+FLAG_CTS 
  2849                                  
  2850 00000C7A E964FA                  		jmp	ERR$CNT
  2851                                  AROK:
  2852 00000C7D C3                      		RETN			;CHAR JUST READ IS IN AL, STATUS IS IN AH
  2853                                  
  2854                                  ;----------------------------------------------------------------
  2855                                  ;								:
  2856                                  ;	Aux non-destructive read with no waiting		:
  2857                                  ;								:
  2858                                  ;	input: es:[di] points to area to receive aux data	:
  2859                                  ;								:
  2860                                  ;----------------------------------------------------------------
  2861                                  ;
  2862                                  
  2863                                  AUX$RDND:
  2864 00000C7E E85900                  		call	GETBX		; have BX point to AUXBUF
  2865 00000C81 8A07                    		mov	AL,[BX] 	; copy contents of buffer to AL
  2866 00000C83 08C0                    		or	AL,AL		; if AL is non-zero (char in buffer)
  2867 00000C85 7514                    		jnz	short AUXRDX	;   then return character
  2868 00000C87 E82500                  		call	AUXSTAT 	;   if not, get status of AUX device
  2869 00000C8A F6C401                  		TEST	AH,FLAG_DATA_READY ;TEST DATA READY
  2870 00000C8D 740E                    		jz	short AUXBUS	;   then device is busy (not ready)
  2871                                  
  2872 00000C8F A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  2873 00000C91 740A                    		jz	short AUXBUS	;   then device is busy (not ready)
  2874 00000C93 E8D7FF                  		call	AUXIN		;   else aux is ready, get character
  2875 00000C96 E84100                  		call	GETBX		; have bx point to AUXBUF
  2876 00000C99 8807                    		mov	[BX],AL 	; save character in buffer
  2877                                  AUXRDX: 				;
  2878 00000C9B EB88                    		jmp	RDEXIT		; return character
  2879                                  
  2880                                  AUXBUS: 				;
  2881 00000C9D E93BFA                  		Jmp	BUS$EXIT	; jump to device busy exit
  2882                                  
  2883                                  ;----------------------------------------------------------------
  2884                                  ;								:
  2885                                  ;		Aux Output Status				:
  2886                                  ;								:
  2887                                  ;----------------------------------------------------------------
  2888                                  
  2889                                  AUX$WRST:
  2890 00000CA0 E80C00                  		call	AUXSTAT 	; get status of AUX in AX
  2891                                  					; now test to see if device is busy
  2892                                  					; if this bit is not set,
  2893 00000CA3 A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  2894 00000CA5 74F6                    		jz	short AUXBUS	;   then device is busy (not ready)
  2895 00000CA7 F6C420                  		TEST	AH,FLAG_TRANHOL_EMP ;TEST TRANSMIT HOLD REG EMPTY
  2896 00000CAA 74F1                    		jz	short AUXBUS	;   then device is busy (not ready)
  2897 00000CAC E947FA                  		jmp	EXIT
  2898                                  
  2899                                  ;
  2900                                  ; AUXSTAT makes a call on the ROM-BIOS to determine the status
  2901                                  ;	  of the auxilary device
  2902                                  ;	  Outputs:
  2903                                  ;		AX is filled with status of port.
  2904                                  ;		DX is changes to specify which card - either 0, 1 (, 2, 3) ;ba
  2905                                  ;		NO other registers are modified
  2906                                  ;
  2907                                  
  2908                                  AUXSTAT:
  2909 00000CAF B403                    		mov	ah,AUXFUNC_STATUS
  2910                                  		;call	AUXOP
  2911                                  		;retn
  2912                                  AUXOP:					;AH=FUNCTION CODE
  2913                                  					;0=INIT, 1=SEND, 2=RECEIVE, 3=STATUS
  2914 00000CB1 E815FB                  		call	GETDX		; have DX point to proper card
  2915 00000CB4 CD14                    		int	14h		; call rom-bios for status
  2916 00000CB6 C3                      		retn
  2917                                  
  2918                                  ;----------------------------------------------------------------
  2919                                  ;								:
  2920                                  ;  Flush AUX Input buffer - set contents of AUXBUF to zero	:
  2921                                  ;								:
  2922                                  ;----------------------------------------------------------------
  2923                                  
  2924                                  AUX$FLSH:
  2925 00000CB7 E82000                  		call	GETBX		; get BX to point to AUXBUF
  2926 00000CBA C60700                  		mov	byte [BX],0	; zero out buffer
  2927 00000CBD E936FA                  		jmp	EXIT		; all done, successful return
  2928                                  	
  2929                                  ;----------------------------------------------------------------
  2930                                  ;								:
  2931                                  ;		Write to Auxilary Device			:
  2932                                  ;								:
  2933                                  ;----------------------------------------------------------------
  2934                                  
  2935                                  AUX$WRIT:
  2936 00000CC0 E3A8                    		jcxz	EXVEC2		; if CX is zero, no characters
  2937                                  				;   to be written, jump to exit
  2938                                  AUX$LOOP:
  2939 00000CC2 268A05                  		mov	AL,[ES:DI]	; get character to be written
  2940 00000CC5 47                      		inc	DI		; move DI pointer to next character
  2941 00000CC6 B401                    		MOV	AH,AUXFUNC_SEND ;VALUE=1, INDICATES A WRITE
  2942 00000CC8 E8E6FF                  		CALL	AUXOP		;SEND CHARACTER OVER AUX PORT
  2943                                  
  2944 00000CCB F6C480                  		TEST	AH,FLAG_TIMEOUT ;CHECK FOR ERROR
  2945 00000CCE 7405                    		jz	short AWOK	;   then no error
  2946 00000CD0 B00A                    		mov	AL,10		;   else indicate write fault
  2947 00000CD2 E90CFA                  		jmp	ERR$CNT 	; call error routines
  2948                                  
  2949                                  					; if CX is non-zero, still more
  2950                                  AWOK:
  2951 00000CD5 E2EB                    		loop	AUX$LOOP	; more characrter to print
  2952 00000CD7 E91CFA                  		jmp	EXIT		; all done, successful return
  2953                                  
  2954                                  ;
  2955                                  ;  GETBX puts the address of AUXBUF (the Auxilary Device buffer)
  2956                                  ;	 in BX.  After calling GETBX, a routine can get to AUXBUF
  2957                                  ;	 with [BX].
  2958                                  ;
  2959                                  ;  NOTE: The getdx routine is in msbio1 and looks like:
  2960                                  ;	mov	dx,word ptr cs:[auxnum]
  2961                                  ;
  2962                                  
  2963                                  GETBX:
  2964 00000CDA E8ECFA                  		call	GETDX
  2965 00000CDD 89D3                    		mov	BX,DX
  2966 00000CDF 81C3[0E00]              		add	BX,AUXBUF
  2967 00000CE3 C3                      		retn
  2968                                  
  2969                                  ;-----------------------------------------------------------------------------
  2970                                  ; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
  2971                                  ;-----------------------------------------------------------------------------
  2972                                  ; 23/03/2018 - Retro DOS v2.0
  2973                                  
  2974                                  ;----------------------------------------------------------------
  2975                                  ;								:
  2976                                  ;	P R N - PRINTER DEVICE					:
  2977                                  ;								:
  2978                                  ;								:
  2979                                  ;   This file contains the Printer Device Driver.  The		:
  2980                                  ; printer driver handles calls to the printers.  Four devices	:
  2981                                  ; use this code: PRN, LPT1, LPT2, and LPT3.  The beginning	:
  2982                                  ; of the interrupt entry point for these device sets the	:
  2983                                  ; variable AUXNUM in the msbio.asm module.  The number is	:
  2984                                  ; in AUXNUM dictates which device will to written to: 0 for	:
  2985                                  ; PRN and LPT1, 1 for LPT2, and 2 for LPT3.			:
  2986                                  ;								:
  2987                                  ;   The routines in this files are:				:
  2988                                  ;								:
  2989                                  ;	routine 		function			:
  2990                                  ;	------- 		--------			:
  2991                                  ;	PRN$WRIT		Write to printer device 	:
  2992                                  ;	PRN$STAT		Printer status routine		:
  2993                                  ;	PRN$TilBusy		Print spooler routine		:
  2994                                  ;	Prn$GenIOCTL		Generic IOCTL routine		:
  2995                                  ;								:
  2996                                  ;  These routines are not called directly.  Call are made via	:
  2997                                  ; the strategy and interrupt entry point (see Device Header).	:
  2998                                  ;								:
  2999                                  ;----------------------------------------------------------------
  3000                                  
  3001                                  ; IBM ROM STATUS BITS (I DON'T TRUST THEM, NEITHER SHOULD YOU)             
  3002                                  									   
  3003                                  NOTBUSYSTATUS	equ 10000000b		; NOT BUSY			   
  3004                                  ACKSTATUS	equ 01000000b		; ACKNOWLEDGE (FOR WHAT?)	   
  3005                                  NOPAPERSTATUS	equ 00100000b		; NO MORE PAPER 		   
  3006                                  SELECTEDSTATUS	equ 00010000b		; THE PRINTER SAID IT WAS SELECTED 
  3007                                  IOERRSTATUS	equ 00001000b		; SOME KINDA ERROR		   
  3008                                  RESERVED	equ 00000110b		; NOPS				   
  3009                                  TIMEOUTSTATUS	equ 00000001b		; TIME OUT.			   
  3010                                  									   
  3011                                  									   
  3012                                  ; WARNING!!! THE IBM ROM DOES NOT RETURN JUST ONE BIT. IT RETURNS A	   
  3013                                  ; WHOLE SLEW OF BITS, ONLY ONE OF WHICH IS CORRECT.			   
  3014                                  									   
  3015                                  ;----------------------------------------------------------------
  3016                                  ;								:
  3017                                  ;		WRITE TO PRINTER DEVICE 			:
  3018                                  ;								:
  3019                                  ;   CX has count of bytes to be printed 			:
  3020                                  ;   ES:DI point to source buffer contains characters		:
  3021                                  ;   AuxNum (in msbio.asm) has printer number			:
  3022                                  ;								:
  3023                                  ;----------------------------------------------------------------
  3024                                  						   
  3025                                  PRN$WRIT:
  3026 00000CE4 E310                    		jcxz	EXVEC3			; no chars to output, Get out
  3027                                  PRN$LOOP:
  3028 00000CE6 BB0200                  		mov	BX,2			; Initialize retry flag
  3029                                  PRN$out:
  3030 00000CE9 268A05                  		mov	AL,[ES:DI]		; Get a character into AL
  3031 00000CEC 47                      		inc	DI			; Point to next character
  3032 00000CED 30E4                    		XOR	AH,AH			; AH=0 => OUTPUT CHAR IN DL	   
  3033 00000CEF E82400                  		call	PRNOP			; print character
  3034 00000CF2 7505                    		jnz	short PrRetry 		; if error, try to print again
  3035 00000CF4 E2F0                    		loop	PRN$LOOP		; if more character, keep printing
  3036                                  EXVEC3:
  3037 00000CF6 E9FDF9                  		jmp	EXIT
  3038                                  
  3039                                  PrRetry:
  3040 00000CF9 4F                      		dec	DI			; undo the inc above...
  3041 00000CFA 4B                      		dec	BX			; Decrement retry count
  3042 00000CFB 75EC                    		jnz	short PRN$out 		; See if done with retrys
  3043                                  PMESSG:
  3044 00000CFD E9E1F9                  		JMP	ERR$CNT 		; if so return with the error
  3045                                  
  3046                                  ;----------------------------------------------------------------
  3047                                  ;								:
  3048                                  ;		PRINTER STATUS ROUTINE				:
  3049                                  ;								:
  3050                                  ;----------------------------------------------------------------
  3051                                  ;
  3052                                  						   
  3053                                  PRN$STAT:
  3054 00000D00 E81100                  		call	PRNSTAT 		; get the status
  3055 00000D03 75F8                    		jnz	short PMESSG		; if error jump to error routine
  3056 00000D05 B009                    		MOV	AL,9			; AGAIN, ASSUME OUT OF PAPER...    
  3057 00000D07 F6C420                  		TEST	AH,NOPAPERSTATUS					   
  3058 00000D0A 75F1                    		JNZ	short PMESSG
  3059 00000D0C F6C480                  		TEST	AH,NOTBUSYSTATUS					   
  3060 00000D0F 75E5                    		jnz	short EXVEC3		; if not busy return via EXVEC3
  3061 00000D11 E9C7F9                  		JMP	BUS$EXIT		; else busy, return to busy exit   
  3062                                  
  3063                                  ;
  3064                                  ;   PRNSTAT	get printer status
  3065                                  ;   PRNOP	print a character
  3066                                  ;
  3067                                  ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
  3068                                  ; printer routines.  The routines share code which calls on the bios and
  3069                                  ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
  3070                                  ; only by the value put into AH before the ROM-BIOS call.
  3071                                  ;
  3072                                  ;   INPUT	if PRNOP then character in AL
  3073                                  ;
  3074                                  ;   OUTPUT	- AL holds error code
  3075                                  ;		- AH status byte from printer
  3076                                  ;		- flag NZ if error
  3077                                  
  3078                                  PRNSTAT:						   
  3079 00000D14 B402                    		mov	AH,2			; set command for get status   *
  3080                                  PRNOP:
  3081 00000D16 E8B0FA                  		call	GETDX			; determine which printer      *
  3082 00000D19 CD17                    		int	17h			; call ROM-BIOS printer routine  *
  3083                                  
  3084 00000D1B F6C408                  		TEST	AH,IOERRSTATUS		; I/O ERROR?			   
  3085 00000D1E 740A                    		JZ	short CHECKNOTREADY	; NO, TRY NOT READY		   
  3086                                  									   
  3087                                  ; AT THIS POINT, WE KNOW WE HAVE AN ERROR. THE CONVERSE IS NOT TRUE.	   
  3088                                  									   
  3089 00000D20 B009                    		MOV	AL,9			; FIRST, ASSUME OUT OF PAPER	   
  3090 00000D22 F6C420                  		TEST	AH,NOPAPERSTATUS	; OUT OF PAPER SET?		   
  3091 00000D25 7502                    		JNZ	short RET1			; YES, ERROR IS SET
  3092 00000D27 FEC0                    		INC	AL			; INDICATE I/O ERROR		   
  3093                                  RET1:									   
  3094                                  									   
  3095                                  ; WE HAVE TRIAGED NOW FOR OUT OF PAPER AND IO ERR (IGNORING TIME-OUT)	   
  3096                                  									   
  3097 00000D29 C3                      		RETN				; RETURN WITH ERROR		   
  3098                                  									   
  3099                                  ; THE BITS SAID NO ERROR.  UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WOR  K
  3100                                  ; HERE. 								   
  3101                                  									   
  3102                                  CHECKNOTREADY:								   
  3103 00000D2A B002                    		MOV	AL,2			; ASSUME NOT-READY		   
  3104 00000D2C F6C401                  		TEST	AH,TIMEOUTSTATUS	; IS TIME-OUT SET?		   
  3105                                  						; IF NZ THEN ERROR, ELSE OK???	   
  3106                                  PRNOP2: 								   
  3107 00000D2F C3                      		RETN
  3108                                  
  3109                                  ;26/05/2018
  3110                                  
  3111                                  ;----------------------------------------------------------------
  3112                                  ;								:
  3113                                  ;		Output until Busy				:
  3114                                  ;								:
  3115                                  ; Output until busy.  This entry point is used EXCLUSIVELY by	:
  3116                                  ; the print spoolers.  Under no curcumstances should the device :
  3117                                  ; driver block waiting for the device to become ready.		:
  3118                                  ;								:
  3119                                  ;   Inputs:	CX has count of bytes to output.		:
  3120                                  ;		ES:DI points to source buffer			:
  3121                                  ;   Outputs:	Set the number of bytes transferred		:
  3122                                  ;		  appropriately.				:
  3123                                  ;								:
  3124                                  ;----------------------------------------------------------------
  3125                                  
  3126                                  PRN$TILBUSY:
  3127 00000D30 1E                      	push	DS			; save DS
  3128 00000D31 06                      	push	ES			; copy ES to DS
  3129 00000D32 1F                      	pop	DS
  3130 00000D33 89FE                    	mov	SI,DI			; everything is set for LODSB
  3131                                  PRN$TilBLoop:
  3132 00000D35 51                      	push	CX
  3133 00000D36 53                      	push	BX
  3134 00000D37 31DB                    	xor	BX,BX
  3135 00000D39 2E8A1E[7E04]            	mov	BL,[CS:PRINTDEV]
  3136 00000D3E D1E3                    	shl	BX,1
  3137 00000D40 2E8B8F[8004]            	mov	CX,[CS:BX+WAIT_COUNT]	; wait COUNT times to come ready
  3138 00000D45 5B                      	pop	BX
  3139                                  PRN$GetStat:
  3140 00000D46 E8CBFF                  	call	PRNSTAT 		; get status
  3141 00000D49 751E                    	jnz	short PRN$BPERR		; if error jump to error routine
  3142 00000D4B F6C480                  	TEST	AH,10000000B		; READY YET?
  3143 00000D4E E1F6                    	loopz	PRN$GetStat		; if busy keep trying
  3144 00000D50 59                      	pop	CX			; get original count
  3145 00000D51 7417                    	jz	short PRN$BErr		; still not ready => done
  3146 00000D53 AC                      	lodsb
  3147 00000D54 30E4                    	XOR	AH,AH
  3148 00000D56 E8BDFF                  	call	PRNOP			; print the character
  3149 00000D59 750F                    	jnz	short PRN$BErr		; error
  3150 00000D5B E2D8                    	loop	PRN$TilBLoop		; go for more
  3151                                  PRN$B:
  3152 00000D5D 1F                      	pop	DS			; recover DS
  3153 00000D5E 2EC51E[0A00]            	lds	BX,[CS:PTRSAV]		; get pointer to header
  3154                                  
  3155 00000D63 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  3156 00000D66 E98DF9                  	jmp	EXIT			; all done, successful return
  3157                                  
  3158                                  PRN$BPERR:
  3159 00000D69 59                      	pop	CX			; recover number of char left
  3160                                  PRN$BErr:
  3161 00000D6A 1F                      	pop	DS			; get pointer to header
  3162 00000D6B 2EC51E[0A00]            	lds	BX,[CS:PTRSAV]
  3163 00000D70 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  3164 00000D73 E973F9                  	jmp	ERR$EXIT		; jump to error exit
  3165                                  
  3166                                  ;
  3167                                  ; Prn$GenIOCTL:
  3168                                  ;
  3169                                  ; Manipulates the value in WAIT_COUNT depending on the value passed in the
  3170                                  ; Generic IOCTL packet.
  3171                                  ; It either sets or returns the current value for the retry count for the
  3172                                  ; device.
  3173                                  ;
  3174                                  
  3175                                  PRN$GENIOCTL:
  3176                                  
  3177 00000D76 C43E[0A00]              	les	di,[PTRSAV]
  3178 00000D7A 26807D0D05              	cmp	byte [es:di+IOCTL_REQ.MAJORFUNCTION],IOC_PC
  3179 00000D7F 7403                    	je	short PrnFunc_OK
  3180                                  PrnFuncErr:
  3181 00000D81 E95BF9                  	jmp	CMDERR
  3182                                  
  3183                                  PrnFunc_OK:
  3184 00000D84 268A450E                	mov	al,[es:di+IOCTL_REQ.MINORFUNCTION]
  3185 00000D88 26C47D13                	les	di,[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
  3186 00000D8C 31DB                    	xor	bx,bx
  3187 00000D8E 8A1E[7E04]              	mov	bl,[PRINTDEV]		; get index into retry counts
  3188 00000D92 D1E3                    	shl	bx,1
  3189 00000D94 8B8F[8004]              	mov	CX,[BX+WAIT_COUNT]	; pull out retry count for device
  3190 00000D98 3C65                    	cmp	al,GET_RETRY_COUNT
  3191 00000D9A 7407                    	jz	short PrnGetCount
  3192 00000D9C 3C45                    	cmp	al,SET_RETRY_COUNT
  3193 00000D9E 75E1                    	jnz	short PrnFuncErr
  3194 00000DA0 268B0D                  	mov	cx,[es:di+A_RETRYCOUNT.RC_COUNT]  ; A_RETRYCOUNT.RC_COUNT = 0 
  3195                                  PrnGetCount:
  3196 00000DA3 898F[8004]              	mov	[BX+WAIT_COUNT],CX	; place "new" retry count
  3197 00000DA7 26890D                  	mov	[es:di+A_RETRYCOUNT.RC_COUNT],cx ; return current retry count
  3198 00000DAA E949F9                  	jmp	EXIT
  3199                                  
  3200                                  ;-----------------------------------------------------------------------------
  3201                                  ; MSCLOCK.ASM - MSDOS 3.3 - 24/07/1987
  3202                                  ;-----------------------------------------------------------------------------
  3203                                  ; 23/03/2018 - Retro DOS v2.0
  3204                                  
  3205                                  ;----------------------------------------				  
  3206                                  ;	CMOS EQUATES FOR THIS SYSTEM	:  ; 26/03/2018 - CMOSEQU.INC, 1987
  3207                                  ;-----------------------------------------------------------------------------
  3208                                  CMOS_PORT	EQU	070H		; I/O ADDRESS OF CMOS ADDRESS PORT	 
  3209                                  CMOS_DATA	EQU	071H		; I/O ADDRESS OF CMOS DATA PORT 	 
  3210                                  NMI		EQU	10000000B	; DISABLE NMI INTERRUPTS MASK - 	 
  3211                                  					;  HIGH BIT OF CMOS LOCATION ADDRESS
  3212                                  ;---------- CMOS TABLE LOCATION ADDRESS'S ## --------------------------------- 
  3213                                  CMOS_SECONDS	EQU	000H		; SECONDS				 
  3214                                  CMOS_SEC_ALARM	EQU	001H		; SECONDS ALARM  ## NOTE:  ALL LOCATIONS 
  3215                                  CMOS_MINUTES	EQU	002H		; MINUTES	      | IN THE CMOS AREA 
  3216                                  CMOS_MIN_ALARM	EQU	003H		; MINUTES ALARM       | ARE IBM USE ONLY 
  3217                                  CMOS_HOURS	EQU	004H		; HOURS 	      | AND  SUBJECT  TO 
  3218                                  CMOS_HR_ALARM	EQU	005H		; HOURS ALARM	      | CHANGE. ONLY THE 
  3219                                  CMOS_DAY_WEEK	EQU	006H		; DAY OF THE WEEK     | POST & BIOS CODE 
  3220                                  CMOS_DAY_MONTH	EQU	007H		; DAY OF THE MONTH    | SHOULD	DIRECTLY 
  3221                                  CMOS_MONTH	EQU	008H		; MONTH 	      | ACCESS LOCATIONS 
  3222                                  CMOS_YEAR	EQU	009H		; YEAR (TWO DIGITS)   | IN CMOS STORAGE. 
  3223                                  CMOS_REG_A	EQU	00AH		; STATUS REGISTER A   '----------------- 
  3224                                  CMOS_REG_B	EQU	00BH		; STATUS REGISTER B  ALARM		 
  3225                                  CMOS_REG_C	EQU	00CH		; STATUS REGISTER C  FLAGS		 
  3226                                  CMOS_REG_D	EQU	00DH		; STATUS REGISTER D  BATTERY		 
  3227                                  CMOS_DIAG	EQU	00EH		; POST DIAGNOSTIC STATUS RESULTS BYTE	 
  3228                                  CMOS_SHUT_DOWN	EQU	00FH		; SHUTDOWN STATUS COMMAND BYTE		 
  3229                                  CMOS_DISKETTE	EQU	010H		; DISKETTE DRIVE TYPE BYTE	      ;  
  3230                                  ;		EQU	011H		; - RESERVED			      ;C 
  3231                                  CMOS_DISK	EQU	012H		; FIXED DISK TYPE BYTE		      ;H 
  3232                                  ;		EQU	013H		; - RESERVED			      ;E 
  3233                                  CMOS_EQUIP	EQU	014H		; EQUIPMENT WORD LOW BYTE	      ;C 
  3234                                  CMOS_B_M_S_LO	EQU	015H		; BASE MEMORY SIZE - LOW BYTE (X1024) ;K 
  3235                                  CMOS_B_M_S_HI	EQU	016H		; BASE MEMORY SIZE - HIGH BYTE	      ;S 
  3236                                  CMOS_E_M_S_LO	EQU	017H		; EXPANSION MEMORY SIZE - LOW BYTE    ;U 
  3237                                  CMOS_E_M_S_HI	EQU	018H		; EXPANSION MEMORY SIZE - HIGH BYTE   ;M 
  3238                                  CMOS_DISK_1	EQU	019H		; FIXED DISK TYPE - DRIVE C EXTENSION ;E 
  3239                                  CMOS_DISK_2	EQU	01AH		; FIXED DISK TYPE - DRIVE D EXTENSION ;D 
  3240                                  ;		EQU	01BH		; - 1BH THROUGH 2DH - RESERVED	      ;  
  3241                                  CMOS_CKSUM_HI	EQU	02EH		; CMOS CHECKSUM - HIGH BYTE	      ;* 
  3242                                  CMOS_CKSUM_LO	EQU	02FH		; CMOS CHECKSUM - LOW BYTE	      ;* 
  3243                                  CMOS_U_M_S_LO	EQU	030H		; USABLE MEMORY ABOVE 1 MEG - LOW BYTE	 
  3244                                  CMOS_U_M_S_HI	EQU	031H		; USABLE MEMORY ABOVE 1 MEG - HIGH BYTE  
  3245                                  CMOS_CENTURY	EQU	032H		; DATE CENTURY BYTE (BCD)		 
  3246                                  CMOS_INFO128	EQU	033H		; 128KB INFORMATION STATUS FLAG BYTE	 
  3247                                  ;		EQU	034H		; - 34H THROUGH 3FH - RESERVED
  3248                                  
  3249                                  ;----------------------------------------------------------------
  3250                                  ;								:
  3251                                  ;		    CLOCK DEVICE DRIVER 			:
  3252                                  ;								:
  3253                                  ;								:
  3254                                  ;   This file contains the Clock Device Driver. 		:
  3255                                  ;								:
  3256                                  ;   The routines in this files are:				:
  3257                                  ;								:
  3258                                  ;	routine 		function			:
  3259                                  ;	------- 		--------			:
  3260                                  ;	TIM$WRIT		Set the current time		:
  3261                                  ;	TIM$READ		Read the current time		:
  3262                                  ;	Time_To_Ticks		Convert time to corresponding	:
  3263                                  ;				  number of clock ticks 	:
  3264                                  ;								:
  3265                                  ; The clock ticks at the rate of:				:
  3266                                  ;								:
  3267                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  3268                                  ; See each routine for information on the use.			:
  3269                                  ;								:
  3270                                  ;----------------------------------------------------------------
  3271                                  
  3272                                  
  3273                                  
  3274                                  ;********************************************************************
  3275                                  ; Indirect call address of TIME_TO_TICKS procedure.
  3276                                  ;This will be used by the relocatable portable suspend/resume code.
  3277                                  
  3278                                  TimeToTicks:
  3279 00000DAD [090E]                  		dw	TIME_TO_TICKS
  3280                                  
  3281                                  ;--------------------------------------------------------------------
  3282                                  ;
  3283                                  ; Settime sets the current time
  3284                                  ;
  3285                                  ; On entry ES:[DI] has the current time:
  3286                                  ;
  3287                                  ;	number of days since 1-1-80	(WORD)
  3288                                  ;	minutes (0-59)			(BYTE)
  3289                                  ;	hours (0-23)			(BYTE)
  3290                                  ;	hundredths of seconds (0-99)	(BYTE)
  3291                                  ;	seconds (0-59)			(BYTE)
  3292                                  ;
  3293                                  ; Each number has been checked for the correct range.
  3294                                  ;
  3295                                  
  3296                                  TIM$WRIT:
  3297 00000DAF 268B05                  		mov	AX,[ES:DI]
  3298 00000DB2 50                      		push	AX		;DAYCNT. We need to set this at the very
  3299                                  					;  end to avoid tick windows.
  3300                                  		
  3301                                  		;11/06/2018
  3302                                  		;26/05/2018
  3303                                  
  3304                                  		;;Rev 3.30 Modification
  3305 00000DB3 803E[8A04]00            		cmp	byte [HaveCMOSClock], 0
  3306 00000DB8 7426                    		je	short No_CMOS_1
  3307 00000DBA 268A4503                		mov	al,[es:di+3]		;get binary hours
  3308 00000DBE FF16[9904]              		call	word [BinToBCD]		;convert to BCD
  3309 00000DC2 88C5                    		mov	ch,al			;CH = BCD hours
  3310 00000DC4 268A4502                		mov	al,[es:di+2]		;get binary minutes
  3311 00000DC8 FF16[9904]              		call	word [BinToBCD]		;convert to BCD
  3312 00000DCC 88C1                    		mov	cl,al			;CL = BCD minutes
  3313 00000DCE 268A4505                		mov	al,[es:di+5]		;get binary seconds
  3314 00000DD2 FF16[9904]              		call	word [BinToBCD]		;convert to BCD
  3315 00000DD6 88C6                    		mov	dh,al			;DH = BCD seconds
  3316 00000DD8 B200                    		mov	dl,0			;DL = 0 (ST) or 1 (DST)
  3317 00000DDA FA                      		cli				;turn off timer
  3318 00000DDB B403                    		mov	ah,03h			;set RTC time
  3319 00000DDD CD1A                    		int	1Ah			;call rom bios clock routine
  3320 00000DDF FB                      		sti
  3321                                  		;;End of Modification
  3322                                  No_CMOS_1:
  3323 00000DE0 268B4D02                		mov	CX,[ES:DI+2]
  3324 00000DE4 268B5504                		mov	DX,[ES:DI+4]
  3325                                  		;;Rev 3.30 Modification
  3326 00000DE8 E81E00                  		call	TIME_TO_TICKS		; convert time to ticks
  3327                                  						;CX:DX now has time in ticks
  3328 00000DEB FA                      		cli				; Turn off timer
  3329 00000DEC B401                    		mov	AH, 1			; command is set time in clock
  3330 00000DEE CD1A                    		int	1Ah			; call rom-bios clock routines
  3331 00000DF0 8F06[8804]              		pop	word [DAYCNT]
  3332 00000DF4 FB                      		sti
  3333                                  		;CMOS clock -------------------------------------
  3334 00000DF5 803E[8A04]00            		cmp	byte [HaveCMOSClock], 0
  3335 00000DFA 740A                    		je	short No_CMOS_2
  3336                                  		; 13/06/2018
  3337 00000DFC FF16[9B04]              		call	word [DaycntToDay]	; convert to BCD format
  3338 00000E00 FA                      		cli				; Turn off timer
  3339 00000E01 B405                    		mov	AH,05h			; set RTC date
  3340 00000E03 CD1A                    		int	1Ah			; call rom-bios clock routines
  3341 00000E05 FB                      		sti
  3342                                  		;------------------------------------------------
  3343                                  No_CMOS_2:
  3344 00000E06 E9EDF8                  		jmp	EXIT
  3345                                  		;;End of Modification
  3346                                  
  3347                                  ;
  3348                                  ; convert time to ticks
  3349                                  ; input : time in CX and DX
  3350                                  ; ticks returned in CX:DX
  3351                                  ;
  3352                                  
  3353                                  TIME_TO_TICKS:
  3354                                  		; first convert from Hour,min,sec,hund. to
  3355                                  		; total number of 100th of seconds
  3356 00000E09 B03C                    		mov	AL,60
  3357 00000E0B F6E5                    		mul	CH		;Hours to minutes
  3358 00000E0D B500                    		mov	CH,0
  3359 00000E0F 01C8                    		add	AX,CX		;Total minutes
  3360 00000E11 B97017                  		mov	CX,6000 	;60*100
  3361 00000E14 89D3                    		mov	BX,DX		;Get out of the way of the multiply
  3362 00000E16 F7E1                    		mul	CX		;Convert to 1/100 sec
  3363 00000E18 89C1                    		mov	CX,AX
  3364 00000E1A B064                    		mov	AL,100
  3365 00000E1C F6E7                    		mul	BH		;Convert seconds to 1/100 sec
  3366 00000E1E 01C1                    		add	CX,AX		;Combine seconds with hours and min.
  3367 00000E20 83D200                  		adc	DX,0		;Ripple carry
  3368 00000E23 B700                    		mov	BH,0
  3369 00000E25 01D9                    		add	CX,BX		;Combine 1/100 sec
  3370 00000E27 83D200                  		adc	DX,0
  3371                                  
  3372                                  		;;Rev 3.30 Modification
  3373                                  		;DX:CX IS TIME IN 1/100 SEC
  3374 00000E2A 92                      		XCHG	AX,DX
  3375 00000E2B 91                      		XCHG	AX,CX		;NOW TIME IS IN CX:AX
  3376 00000E2C BB0BE9                  		MOV	BX,59659
  3377 00000E2F F7E3                    		MUL	BX		;MULTIPLY LOW HALF
  3378 00000E31 87D1                    		XCHG	DX,CX
  3379 00000E33 92                      		XCHG	AX,DX		;CX->AX, AX->DX, DX->CX
  3380 00000E34 F7E3                    		MUL	BX		;MULTIPLY HIGH HALF
  3381 00000E36 01C8                    		ADD	AX,CX		;COMBINE OVERLAPPING PRODUCTS
  3382 00000E38 83D200                  		ADC	DX,0
  3383 00000E3B 92                      		XCHG	AX,DX		;AX:DX=TIME*59659
  3384 00000E3C BB0500                  		MOV	BX,5
  3385 00000E3F F6F3                    		DIV	BL		;DIVIDE HIGH HALF BY 5
  3386 00000E41 88C1                    		MOV	CL,AL
  3387 00000E43 B500                    		MOV	CH,0
  3388 00000E45 88E0                    		MOV	AL,AH		;REMAINDER OF DIVIDE-BY-5
  3389 00000E47 98                      		CBW
  3390 00000E48 92                      		XCHG	AX,DX		;USE IT TO EXTEND LOW HALF
  3391 00000E49 F7F3                    		DIV	BX		;DIVIDE LOW HALF BY 5
  3392 00000E4B 89C2                    		MOV	DX,AX
  3393                                  			; CX:DX is now number of ticks in time
  3394 00000E4D C3                      		retn
  3395                                  
  3396                                  ;
  3397                                  ; Gettime reads date and time
  3398                                  ; and returns the following information:
  3399                                  ;
  3400                                  ;	ES:[DI]  =count of days since 1-1-80
  3401                                  ;	ES:[DI+2]=hours
  3402                                  ;	ES:[DI+3]=minutes
  3403                                  ;	ES:[DI+4]=seconds
  3404                                  ;	ES:[DI+5]=hundredths of seconds
  3405                                  ;
  3406                                  
  3407                                  TIM$READ:				; read the clock
  3408 00000E4E 30E4                    		xor	AH, AH		; set command to read clock
  3409 00000E50 CD1A                    		int	1Ah		; call rom-bios to get time
  3410                                  
  3411 00000E52 08C0                    		or	al,al		; check for a new day
  3412 00000E54 7404                    		jz	short noroll1 	; if al=0 then don't reset day count
  3413 00000E56 FF06[8804]              		INC	word [DAYCNT]	; CATCH ROLLOVE
  3414                                  noroll1:
  3415 00000E5A 8B36[8804]              		MOV	SI,[DAYCNT]
  3416                                  
  3417                                  ;
  3418                                  ; we now need to convert the time in tick to the time in 100th of
  3419                                  ; seconds.  The relation between tick and seconds is:
  3420                                  ;
  3421                                  ;		 65536 seconds
  3422                                  ;	       ----------------
  3423                                  ;		1,193,180 tick
  3424                                  ;
  3425                                  ; To get to 100th of second we need to multiply by 100. The equation is:
  3426                                  ;
  3427                                  ;	Ticks from clock  * 65536 * 100
  3428                                  ;      ---------------------------------  = time in 100th of seconds
  3429                                  ;		1,193,180
  3430                                  ;
  3431                                  ; Fortunately this formula simplifies to:
  3432                                  ;
  3433                                  ;	Ticks from clock * 5 * 65,536
  3434                                  ;      --------------------------------- = time in 100th of seconds
  3435                                  ;		59,659
  3436                                  ;
  3437                                  ; The calculation is done by first multipling tick by 5. Next we divide by
  3438                                  ; 59,659.  In this division we multiply by 65,536 by shifting the dividend
  3439                                  ; my 16 bits to the left.
  3440                                  ;
  3441                                  ; start with ticks in CX:DX
  3442                                  ; multiply by 5
  3443 00000E5E 89C8                    		MOV	AX,CX
  3444 00000E60 89D3                    		MOV	BX,DX
  3445 00000E62 D1E2                    		SHL	DX,1
  3446 00000E64 D1D1                    		RCL	CX,1		;TIMES 2
  3447 00000E66 D1E2                    		SHL	DX,1
  3448 00000E68 D1D1                    		RCL	CX,1		;TIMES 4
  3449 00000E6A 01DA                    		ADD	DX,BX
  3450 00000E6C 11C8                    		ADC	AX,CX		;TIMES 5
  3451 00000E6E 92                      		XCHG	AX,DX		
  3452                                  	
  3453                                  
  3454                                  ; now have ticks * 5 in DX:AX
  3455                                  ; we now need to multiply by 65,536 and divide by 59659 d.
  3456                                  
  3457 00000E6F B90BE9                  		mov	CX,59659	; get divisor
  3458 00000E72 F7F1                    		div	CX
  3459                                  					; DX now has remainder
  3460                                  					; AX has high word of final quotient
  3461 00000E74 89C3                    		mov	BX,AX		; put high work if safe place
  3462 00000E76 31C0                    		xor	AX,AX		; this is the multiply by 65536
  3463 00000E78 F7F1                    		div	CX		; BX:AX now has time in 100th of seconds
  3464                                  
  3465                                  ;
  3466                                  ;Rounding based on the remainder may be added here
  3467                                  ;The result in BX:AX is time in 1/100 second.
  3468 00000E7A 89DA                    		mov	DX,BX
  3469 00000E7C B9C800                  		mov	CX,200		;Extract 1/100's
  3470                                  ;Division by 200 is necessary to ensure no overflow--max result
  3471                                  ;is number of seconds in a day/2 = 43200.
  3472 00000E7F F7F1                    		div	CX
  3473 00000E81 80FA64                  		cmp	DL,100		;Remainder over 100?
  3474 00000E84 7203                    		jb	short NOADJ
  3475 00000E86 80EA64                  		sub	DL,100		;Keep 1/100's less than 100
  3476                                  NOADJ:
  3477 00000E89 F5                      		cmc			;If we subtracted 100, carry is now set
  3478 00000E8A 88D3                    		mov	BL,DL		;Save 1/100's
  3479                                  ;To compensate for dividing by 200 instead of 100, we now multiply
  3480                                  ;by two, shifting a one in if the remainder had exceeded 100.
  3481 00000E8C D1D0                    		rcl	AX,1
  3482 00000E8E B200                    		mov	DL,0
  3483 00000E90 D1D2                    		rcl	DX,1
  3484 00000E92 B93C00                  		mov	CX,60		;Divide out seconds
  3485 00000E95 F7F1                    		div	CX
  3486 00000E97 88D7                    		mov	BH,DL		;Save the seconds
  3487 00000E99 F6F1                    		div	CL		;Break into hours and minutes
  3488 00000E9B 86C4                    		xchg	AL,AH
  3489                                  
  3490                                  ;Time is now in AX:BX (hours, minutes, seconds, 1/100 sec)
  3491                                  
  3492 00000E9D 50                      		push	AX
  3493 00000E9E 89F0                    		MOV	AX,SI		; DAYCNT
  3494 00000EA0 AB                      		stosw
  3495 00000EA1 58                      		pop	AX
  3496 00000EA2 AB                      		stosw
  3497 00000EA3 89D8                    		mov	AX,BX
  3498 00000EA5 AB                      		stosw
  3499 00000EA6 E94DF8                  		jmp	EXIT
  3500                                  
  3501                                  ;-----------------------------------------------------------------------------
  3502                                  ; MSDISK.ASM (1) - MSDOS 3.3 - 02/02/1988
  3503                                  ;-----------------------------------------------------------------------------
  3504                                  ; 26/05/2018 - Retro DOS v3.0
  3505                                  ; 23/03/2018 - Retro DOS v2.0
  3506                                  
  3507                                  ;------------------------------------------------------------------------
  3508                                  ;									:
  3509                                  ;	       DISK INTERFACE ROUTINES					:
  3510                                  ;									:
  3511                                  ;									:
  3512                                  ;   This file contains the Disk Device Driver.				:
  3513                                  ;									:
  3514                                  ;   The routines in this files are:					:
  3515                                  ;									:
  3516                                  ;	routine 		function				:
  3517                                  ;	------- 		--------				:
  3518                                  ;									:
  3519                                  ;	MEDIA$CHK		Determine if media in drive has changed :
  3520                                  ;									:
  3521                                  ;	GET$BPB 		Build a valid BPB for drive		:
  3522                                  ;									:
  3523                                  ;	DSK$REM 		Determine if disk has removable media	:
  3524                                  ;									:
  3525                                  ;	DSK$WRTV		Disk write with verify			:
  3526                                  ;									:
  3527                                  ;	DSK$WRT 		Disk write				:
  3528                                  ;									:
  3529                                  ;	DSK$READ		Read disk				:
  3530                                  ;									:
  3531                                  ;									:
  3532                                  ;  These routines are not called directly.  Call are made via		:
  3533                                  ; the strategy and interrupt entry point (see Device Header).		:
  3534                                  ;									:
  3535                                  ;  Data structures:							:
  3536                                  ;	There are two main types of data structures associated with	:
  3537                                  ;  the disk drives.  The first is the BDS.  BDS is the Bios Data	:
  3538                                  ;  structure.  There is one BDS for each logical drive in the system.	:
  3539                                  ;  All the BDS's are linked together in a list with the pointer to the  :
  3540                                  ;  first BDS being found in START_BDS.	The BDS hold various values	:
  3541                                  ;  important to the disk drive.  For example there is a field for last	:
  3542                                  ;  time accesses.  As actions take place in the system the BDS are	:
  3543                                  ;  update to reflect the actions.  For example if there is a read to	:
  3544                                  ;  a disk the last access field for the BDS for that drive is updated	:
  3545                                  ;  to the current time. 						:
  3546                                  ;	 The second data structure associated with disk drives is the	:
  3547                                  ;  BPB.  A BPB is a Bios Parameter Block.  The BPB contains information :
  3548                                  ;  about the media inside a disk drive.  Some on the fields in the BPB	:
  3549                                  ;  are Sectors per track, number of FATs, and number of tracks.  This	:
  3550                                  ;  information is used to tell where sectors are on the disk.  For	:
  3551                                  ;  example,  if we need to read logical sector 52:			:
  3552                                  ;									:
  3553                                  ;	Diskette			Track	Sector	Side		:
  3554                                  ;    single density							:
  3555                                  ;    eight sectors per track		  6	   5	  0		:
  3556                                  ;									:
  3557                                  ;    double density							:
  3558                                  ;    nine sectors per track		  2	   7	  1		:
  3559                                  ;									:
  3560                                  ;  The BPB for the media in the drive is stored in the BDS for the	:
  3561                                  ;  drive.  If the user changes the floppy in the drive a call is	:
  3562                                  ;  made to GET$BPB to build a new BPB in the BDS.  See this routine	:
  3563                                  ;  for the algorithm.							:
  3564                                  ;									:
  3565                                  ;									:
  3566                                  ;------------------------------------------------------------------------
  3567                                  
  3568                                  ;
  3569                                  ; Maximum number of retries in case of error
  3570                                  ;
  3571                                  
  3572                                  MAXERR	EQU 5
  3573                                  LSTDRV	EQU 0504h
  3574                                  
  3575                                  ;
  3576                                  ; Some floppy drives do not have changeline support.  The result is a
  3577                                  ; large amount of inefficiency in the code.  A media-check always returns
  3578                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
  3579                                  ; always discard any cached data.
  3580                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
  3581                                  ; The following three items are used to do this.  The logical door latch is
  3582                                  ; based on the premise that it is not physically possible to change floppy
  3583                                  ; disks in a drive in under two seconds (most people take about 10).  The
  3584                                  ; logical door latch is implemented by saving the time of the last successful
  3585                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
  3586                                  ; current time is compared to the saved time.  If less than two seconds have
  3587                                  ; passed then the value "No Change" is returned.  If more than two seconds
  3588                                  ; have passed the value "Don't Know" is returned.
  3589                                  ;    There is one complecation to this algorithm.  Some programs change the
  3590                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
  3591                                  ; This possiblity is detected by counting the number of disk operations
  3592                                  ; which occur without any time passing.  If this count exceeds the value of
  3593                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  3594                                  ; Know".  The variable "AccessCount" is used to keep track of the number
  3595                                  ; of disk operation which occur without the time changing.
  3596                                  ;
  3597                                  
  3598                                  AccessMax EQU 5
  3599                                  
  3600                                  ;
  3601                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  3602                                  ; have to be made to read the diskette.  Consequently a large head settle
  3603                                  ; time was always used in the I/O operations.  To get around this problem
  3604                                  ; we need to continually adjust the head settle time.  The following
  3605                                  ; algorithm is used:
  3606                                  ;
  3607                                  ;   Get the current head settle value.
  3608                                  ;   If it is 1, then
  3609                                  ;	set slow = 15
  3610                                  ;   else
  3611                                  ;	set slow = value
  3612                                  ;   ...
  3613                                  ;   if we are seeking and writing then
  3614                                  ;	use slow
  3615                                  ;   else
  3616                                  ;	use fast
  3617                                  ;   ...
  3618                                  ;   restore current head settle value
  3619                                  ;
  3620                                  
  3621                                  ;
  3622                                  ; flags for size of FAT
  3623                                  ;
  3624                                  
  3625                                  fTOOBIG	EQU 80h
  3626                                  fBIG	EQU 40h
  3627                                  
  3628                                  error_unknown_media equ	7	; for use in BUILD BPB call
  3629                                  
  3630                                  struc BPB_TYPE
  3631 00000000 ????                    .SECSIZE:	resw 1
  3632 00000002 ??                      .SECALL:	resb 1
  3633 00000003 ????                    .RESNUM:	resw 1
  3634 00000005 ??                      .FATNUM:	resb 1
  3635 00000006 ????                    .DIRNUM:	resw 1
  3636 00000008 ????                    .SECNUM:	resw 1
  3637 0000000A ??                      .FATID:		resb 1
  3638 0000000B ????                    .FATSIZE:	resw 1
  3639 0000000D ????                    .SLIM:		resw 1
  3640 0000000F ????                    .HLIM:		resw 1
  3641 00000011 ????                    .HIDDEN:	resw 1
  3642                                  .size:
  3643                                  endstruc
  3644                                  
  3645                                  ; 29/06/2019 - Retro DOS v3.1
  3646                                  
  3647                                  ; --------------------------------------------------------------------------
  3648                                  ;
  3649                                  ; SetDrive scans through the data structure of BDSs and returns a
  3650                                  ; pointer to the BDS that belongs to the drive specified in AL.
  3651                                  ; Carry is set if no BDS has a logical drive number which matches the
  3652                                  ; value in AL.
  3653                                  ;	Input:
  3654                                  ;	  AL contains the logical drive number
  3655                                  ;	Output:
  3656                                  ;	  DS:DI points to correct BDS if Carry is clear.
  3657                                  ;
  3658                                  ;	 All register except DS and DI are preserved
  3659                                  ;
  3660                                  ; --------------------------------------------------------------------------
  3661                                  
  3662                                  SETDRIVE:
  3663                                  		; 27/05/2018 - Retro DOS v3.0
  3664                                  		; (MSDOS v3.3, 'MSDISK.ASM')
  3665                                  		
  3666 00000EA9 53                      		push	bx
  3667 00000EAA 0E                      		push	cs
  3668 00000EAB 1F                      		pop	ds
  3669                                  
  3670 00000EAC 8B3E[FA00]              		mov	di,[START_BDS] 
  3671                                  Scan_Loop:
  3672                                  ;;Rev 3.30 Modification -----------------------------------------
  3673 00000EB0 2E803E[6C00]01          		CMP	BYTE [CS:PHYS_DRV],1 ; DOES AL HAVE PHYS DRV?
  3674 00000EB6 7207                    		JB	short USE_LOGICAL_DRV
  3675 00000EB8 384504                  		CMP	BYTE [DI+BDS.DriveNum],AL
  3676 00000EBB 7414                    		JE	short SetDrv
  3677 00000EBD EB05                    		JMP	SHORT GET_NXT_BDS
  3678                                  USE_LOGICAL_DRV:
  3679 00000EBF 384505                  		CMP	[DI+BDS.DriveLet],AL
  3680 00000EC2 740D                    		JE	short SetDrv
  3681                                  GET_NXT_BDS:
  3682 00000EC4 8B5D02                  		MOV	BX,[DI+BDS.Link+2] ; GO TO NEXT BDS
  3683                                  		;MOV	DI,[DI+BDS.Link]
  3684 00000EC7 8B3D                    		mov	di,[di] ; 05/07/2019
  3685 00000EC9 8EDB                    		mov	ds,bx
  3686                                  ;;End of Modification -----------------------------------------
  3687                                  
  3688 00000ECB 83FFFF                  		cmp	di,-1		; at end of list?
  3689 00000ECE 75E0                    		jnz	short Scan_Loop	; no, keep looking
  3690 00000ED0 F9                      		stc			; yes, indicate error set carry
  3691                                  SetDrv:
  3692 00000ED1 5B                      		pop	bx		; restore bx
  3693 00000ED2 C3                      		retn
  3694                                  
  3695                                  ;------------------------------------------------------------------------
  3696                                  ;									:
  3697                                  ; The next 100 or so lines of code do the Media Check. Media Check	:
  3698                                  ; determines if the diskette (media) in the drive has been changed.	:
  3699                                  ;									:
  3700                                  ;	SI is used to hold media check code:				:
  3701                                  ;			-1	media changed				:
  3702                                  ;			 0	Don't know                              :
  3703                                  ;			 1	media has not been changed		:
  3704                                  ;									:
  3705                                  ; The algorithm used is a follows:					:
  3706                                  ;	if (hard disk)							:
  3707                                  ;	    if (changed by format)					:
  3708                                  ;		   return (not changed) 				:
  3709                                  ;	    if	not (changed by format) 				:
  3710                                  ;		   return (changed)					:
  3711                                  ;	else we have a floppy						:
  3712                                  ;	    if floppy has change line support go ask the floppy 	:
  3713                                  ;	    if floppy does not have change line do the following	:
  3714                                  ;		read the time						:
  3715                                  ;		if more than two second have passed return don't know   :
  3716                                  ;		if no time has passed then might be unreliable		:
  3717                                  ;		  counter (some program fool with the counter when	:
  3718                                  ;		  they should not).  See note below for procedure with	:
  3719                                  ;		  unreliable counter					:
  3720                                  ;		if sometime has passed but not two second return	:
  3721                                  ;		  media has not changed.  This is based on the		:
  3722                                  ;		  assumption that it is not physically possible to	:
  3723                                  ;		  change a disk in less the two seconds (most people	:
  3724                                  ;		  take about 10 seconds).				:
  3725                                  ;									:
  3726                                  ;------------------------------------------------------------------------
  3727                                  
  3728                                  MEDIA$CHK:
  3729                                  		; 13/06/2018
  3730                                  		; 26/05/2018 - Retro DOS v3.0
  3731                                  		; (Volume Serial Number Check)
  3732                                  
  3733                                  		; 08/04/2018
  3734                                  		; Retro DOS v2.0
  3735                                  		; (Media check code here is mix of MSDOS 2.0, MSDOS 3.3
  3736                                  		; and Retro DOS v2.0 special media -disk change- check code..)
  3737                                  		; (..it is not compatible with MSDOS 3.3 mediacheck)
  3738                                  		; (Excluded methods: Volume Serial Number Check,
  3739                                  		; "fChanged_By_Format" check -via int 13h hook-)
  3740                                  
  3741                                  		; 26/05/2018
  3742                                  
  3743 00000ED3 E8D3FF                  		call	SETDRIVE ; point DS:DI to BDS for specified drive	
  3744                                  
  3745 00000ED6 2E813E[7200]6B6A        		cmp	word [CS:Secrete_Code], 'kj' ; Secrete code for
  3746 00000EDD 7546                    		jne	short Media$Done	; DOS 3.3 MSBIO.
  3747                                  		
  3748                                  		;cmp	AL, 1	; Retro DOS v2.0 method
  3749                                  				; We will not check disk change status
  3750                                  				; if disk/unit number > 1.
  3751                                  				; (hard disk or diskette 3 ! or diskette 4 !)
  3752                                  		;ja	short Media$Done
  3753                                  
  3754                                  ;
  3755                                  ; For non-removable disks only return changed if changed by format,
  3756                                  ; otherwise return 'not changed'.
  3757                                  ;
  3758 00000EDF BE0100                  		mov	si,1		; assume no change
  3759 00000EE2 F745290001              		test	word [DI+BDS.Flags],fChanged_By_Format
  3760 00000EE7 7417                    		jz	short WeAreNotFakingIt
  3761                                  					; reset flag
  3762 00000EE9 816529FFFE              		and	word [DI+BDS.Flags],~fChanged_By_Format
  3763                                  
  3764                                  ;
  3765                                  ; If media has been changed by format, must use the ROM.
  3766                                  ; Cannot rely on the 2 second time check.
  3767                                  ;
  3768 00000EEE 2EC606[FF00]FF          		mov	byte [CS:TIM_DRV],-1  ; Ensure that we ask the ROM if
  3769                                  					      ; media has changed
  3770 00000EF4 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3771 00000EF9 740C                    		jz	short WeHaveAFloppy
  3772 00000EFB BEFFFF                  		mov	SI,-1			; Indicate media changed
  3773 00000EFE EB25                    		jmp	short Media$Done
  3774                                  ;
  3775                                  ; return 'not changed' if disk is a hard file.
  3776                                  ;
  3777                                  
  3778                                  WeAreNotFakingIt:
  3779 00000F00 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  3780 00000F05 751E                    		jnz	short Media$Done
  3781                                  
  3782                                  		;
  3783                                  		; return 'not changed' if disk is a hard file.
  3784                                  		;
  3785                                  
  3786                                  		;mov	si,1    ; not changed
  3787                                  
  3788                                  		;cmp	al, [CS:HARDNUM]
  3789                                  		;jnb	short Media$Done ; fixed/hard disk !
  3790                                  
  3791                                  ;
  3792                                  ; If this code is reached disk is a diskette drive
  3793                                  ;
  3794                                  
  3795                                  WeHaveAFloppy:
  3796 00000F07 31F6                    		xor	si,si	; Presume "I don't know"
  3797                                  
  3798                                  		; 11/04/2018
  3799                                  		;mov	[CS:MEDIACHK_DRV], al ; Retro DOS v2.0 method 
  3800                                  		; 13/04/2018
  3801                                  		;mov	[MEDIACHK_DRV], al
  3802                                  
  3803                                  ;
  3804                                  ; If drive is a floppy with changeline support the rom is called to
  3805                                  ; determine if the media has changed. It is not necessary to do the 2
  3806                                  ; second check on these drives.
  3807                                  ;
  3808                                  		;CALL	MediaCheck
  3809                                  
  3810                                  		; DL = drive number (0..3) ; 13/04/2018
  3811                                  
  3812                                  		;and	si, si
  3813                                  		;jnz	short Media$Done
  3814                                  
  3815                                  		; SI = 0, "I don't know" (if media has been changed or not!?)
  3816                                  
  3817                                  		;inc	si	; 1 = no change
  3818                                  		 
  3819                                  		; 26/05/2018 - Retro DOS v3.0
  3820                                  		;----------------------------------------|
  3821                                  		; Warning: Do not change the following. ;|
  3822                                  		;	   It gets patched in MSINIT	;|
  3823                                  							;|
  3824                                  Media_Patch:						;|
  3825 00000F09 E8D00C                  		CALL	MediaCheck			;|
  3826 00000F0C 7233                    		jc	short ERR$EXITJ			;|
  3827 00000F0E E8420E                  		call	HasChange			;|
  3828 00000F11 7512                    		jnz	short Media$Done		;|
  3829                                  		;----------------------------------------|
  3830                                  
  3831                                  ;
  3832                                  ; If this code is reached the drive is a floppy with no changeline support
  3833                                  ;
  3834                                  
  3835 00000F13 BE0100                  		MOV	SI,1			; PRESUME NO CHANGE
  3836 00000F16 2EA0[FF00]              		mov	al,[CS:TIM_DRV] 	; last drive accessed
  3837                                  						;is drive of last access the same?
  3838                                  		;mov	al,[TIM_DRV]
  3839                                  		;;CMP	AL,[CS:MEDIACHK_DRV]
  3840                                  		;;cmp	al,[MEDIACHK_DRV]  ; 11/04/2018
  3841                                  		;CMP	AL,DL ; 13/04/2018
  3842                                  
  3843 00000F1A 3A4504                  		cmp	al,[DI+BDS.DriveNum] ; 26/05/2018
  3844 00000F1D 7505                    		JNE	short Media$Unk		; no, then return don't know
  3845                                  ;
  3846                                  ; CHECK TO SEE IF THIS DRIVE HAS BEEN ACCESSED IN THE LAST 2 SECONDS.
  3847                                  ;
  3848 00000F1F E82500                  		call	CHECK_TIME_OF_ACCESS
  3849 00000F22 EB01                    		jmp	short Media$Done
  3850                                  
  3851                                  Media$Unk:
  3852 00000F24 4E                      		DEC	SI			; RETURN "I DON'T KNOW"
  3853                                  
  3854                                  ;
  3855                                  ; SI now contains the correct value for media change. Clean up the left overs
  3856                                  ;
  3857                                  Media$Done:
  3858 00000F25 2EC41E[0A00]            		les	bx,[CS:PTRSAV]		; get original packet
  3859                                  		;les	bx,[PTRSAV] ; 11/04/2018
  3860 00000F2A 2689770E                		mov	[ES:BX+TRANS],SI
  3861 00000F2E 09F6                    		or	SI,SI
  3862                                  		;jns	EXIT
  3863 00000F30 7803                    		js	short INIT_PATCH
  3864 00000F32 E9C1F7                  		jmp	EXIT
  3865                                  
  3866                                  		;; make sure we ask ROM for media check
  3867                                  		;mov	byte [CS:TIM_DRV],-1
  3868                                  		;;mov	byte [TIM_DRV],-1 ; 11/04/2018
  3869                                  		;jmp	EXIT
  3870                                  
  3871                                  		; 26/05/2018 - Retro DOS v3.0
  3872                                  		;----------------------------------------|
  3873                                  		; Warning: Do not change the following. ;|
  3874                                  		;	   It gets patched in msinit	;|
  3875                                  							;|
  3876                                  INIT_PATCH:						;|
  3877 00000F35 E86C0D                  		CALL	MEDIA_SET_VID			;|
  3878                                  		;----------------------------------------|
  3879 00000F38 2EC606[FF00]FF          		mov	byte [cs:TIM_DRV],-1 ; make sure we ask ROM for media check
  3880                                  VOLIDOK:
  3881 00000F3E E9B5F7                  		jmp	EXIT
  3882                                  
  3883                                  ERR$EXITJ:
  3884 00000F41 E8CC04                  		CALL	MAPERROR
  3885 00000F44 E9A2F7                  		JMP	ERR$EXIT
  3886                                  
  3887                                  ;
  3888                                  ; PERFORM A CHECK ON THE TIME PASSED SINCE THE LAST ACCESS FOR THIS
  3889                                  ; PHYSICAL DRIVE.
  3890                                  ; WE ARE ACCESSING THE SAME DRIVE.  IF THE TIME OF LAST SUCCESSFUL ACCESS
  3891                                  ; WAS LESS THAN 2 SECONDS AGO, THEN WE MAY PRESUME THAT THE DISK WAS NOT
  3892                                  ; CHANGED
  3893                                  ; RETURNS IN SI:
  3894                                  ;	0 - IF TIME OF LAST ACCESS WAS >= 2 SECONDS
  3895                                  ;	1 - IF TIME WAS < 2 SECONDS (I.E NO MEDIA CHANGE ASSUMED)
  3896                                  ; REGISTERS AFFECTED AX,CX,DX, FLAGS.
  3897                                  ;
  3898                                  
  3899                                  CHECK_TIME_OF_ACCESS:
  3900                                  		; 27/05/2018 - Retro DOS v3.0
  3901 00000F47 BE0100                  		mov	si,1			; Presume no change
  3902                                  		;;Rev 3.30 Modification
  3903 00000F4A 30E4                    		xor	AH, AH			; set command to read time
  3904 00000F4C CD1A                    		int	1Ah			; call rom-bios clock routine
  3905                                  
  3906                                  ;
  3907                                  ; Once time is read, must make sure the date wrap is not lost.	The ROM will
  3908                                  ; return the value only once, it must check for day wrap on each call.
  3909                                  ;
  3910 00000F4E D0E8                    		SHR	AL,1
  3911 00000F50 2E8316[8804]00          		ADC	word [CS:DAYCNT],0	; ADD IT TO OUR SAVED DAY COUNT
  3912                                  		;ADC	word [DAYCNT], 0 ; 11/04/2018
  3913                                  ;
  3914                                  ; Compute elapsed time1
  3915                                  ;
  3916                                  		; 27/05/2018
  3917                                  		; Retro DOS v3.0
  3918 00000F56 8B454D                  		MOV	AX,[DI+BDS.TIM_LO]	; GET STORED TIME
  3919 00000F59 29C2                    		SUB	DX,AX
  3920 00000F5B 8B454F                  		MOV	AX,[DI+BDS.TIM_HI]
  3921 00000F5E 19C1                    		SBB	CX,AX
  3922                                  ;
  3923                                  ; CX:DX is the elapsed time
  3924                                  ;
  3925 00000F60 751D                    		JNZ	short TimeCheck_Unk	; CX <> 0 => > 1 hour
  3926 00000F62 09D2                    		OR	DX,DX			; did some time pass?
  3927 00000F64 7514                    		JNZ	short TimePassed	; yes, examine max value
  3928                                  ;
  3929                                  ; No noticeable time has passed. There are two possibilities. First there
  3930                                  ; could be two driver calls with in one clock tick (55 milliseconds).  The
  3931                                  ; second possibility is the program has reprogramed the counter -- this is
  3932                                  ; the unreliable counter case. To distinguish between the case a count is
  3933                                  ; kept of the number of calls that happen without a clock tick (the variable
  3934                                  ; is AccessCount).  If this count exceeds a set limit (MaxAccess) it is
  3935                                  ; assumed the counter is unreliable and the value don't know is returned.
  3936                                  ; If AccessCount is less than MaxAccess we assume the time is valid and
  3937                                  ; therefore the media has not changed.
  3938                                  ;
  3939 00000F66 2EFE06[FE00]            		inc	byte [cs:AccessCount]
  3940                                  						; Exceeded threshold for count?
  3941 00000F6B 2E803E[FE00]05          		cmp	byte [cs:AccessCount],AccessMax
  3942 00000F71 720D                    		jb	short TimeCheck_Ret	; no, return media unchanged
  3943 00000F73 2EFE0E[FE00]            		dec	byte [cs:AccessCount]	; don't let the count wrap
  3944 00000F78 EB05                    		jmp	short TimeCheck_Unk	; "I don't know" if media changed
  3945                                  
  3946                                  ;
  3947                                  ; If this code is reached some time has passed.  Need to determine if
  3948                                  ; 2 seconds have passed.  Note: 18.2 ticks per second.
  3949                                  ;
  3950                                  TimePassed:
  3951 00000F7A 83FA24                  		CMP	DX,18*2			; IF ( Time_passed <= 2secs )
  3952 00000F7D 7601                    		JBE	short TimeCheck_Ret	;      presume no change
  3953                                  
  3954                                  
  3955                                  ; Everything indicates that we do not know what has happened.
  3956                                  ;
  3957                                  TimeCheck_Unk:
  3958 00000F7F 4E                      		DEC	SI			; Presume I don't know
  3959                                  TimeCheck_Ret:
  3960 00000F80 C3                      		RETN
  3961                                  
  3962                                  ERR$EXITJ2:
  3963 00000F81 E965F7                  		JMP 	ERR$EXIT
  3964                                  
  3965                                  
  3966                                  ;------------------------------------------------------------------------
  3967                                  ;									:
  3968                                  ;		Get Bios Parameter Block				:
  3969                                  ;									:
  3970                                  ; GET$BPB is called to build a valid BPB for the media in the disk	:
  3971                                  ; drive.  A BPB (Bios Parameter Block) contains information about	:
  3972                                  ; the media which is currently in the drive.  The values stored is	:
  3973                                  ; information like number of fat sectors, size of drive, 8 or 9 sectors,:
  3974                                  ; etc.									:
  3975                                  ;									:
  3976                                  ;	This routine is called by the device drive code.		:
  3977                                  ;									:
  3978                                  ;	On entry AL contains the logical drive number which needs	:
  3979                                  ;	  the BPB built.						:
  3980                                  ;	ES:[DI] points to a buffer; the first byte of the buffer is a	:
  3981                                  ;	   media decriptor byte.					:
  3982                                  ;									:
  3983                                  ;------------------------------------------------------------------------
  3984                                  ;
  3985                                  ; Build a valid BPB for the disk in the drive.
  3986                                  ;
  3987                                  
  3988                                  GET$BPB:
  3989 00000F84 268A25                  		mov	AH,[ES:DI]		; get FAT ID byte read by DOS
  3990 00000F87 E81FFF                  		call	SETDRIVE		; get the correct BDS for the drv
  3991                                  		; 27/05/2018
  3992                                  		;;Rev 3.30 Modification
  3993 00000F8A F745290100              		TEST	word [DI+BDS.Flags],fNon_Removable
  3994 00000F8F 7508                    		JNZ	short ALREADY_GOTBPB	; NO NEED TO BUILD FOR FIXED DISKS
  3995                                  		;End of Modification
  3996 00000F91 E81C00                  		call	GETBP			; build a BPB if necessary.
  3997 00000F94 72EB                    		jc	short ERR$EXITJ2	; if error exit
  3998                                  SET_PATCH:
  3999 00000F96 E8D80D                  		CALL	Set_Volume_ID
  4000                                  ALREADY_GOTBPB:
  4001 00000F99 83C706                  		add	di,BDS.BytePerSec	; return the BPB that is in the current BDS
  4002                                  
  4003                                  SetPTRSAV:					; return point for DSK$INIT
  4004 00000F9C 2EC41E[0A00]            		les	BX,[CS:PTRSAV]
  4005 00000FA1 2688670D                		mov	[ES:BX+MEDIA],AH
  4006 00000FA5 26897F12                		mov	[ES:BX+COUNT],DI
  4007 00000FA9 268C5F14                		mov	[ES:BX+COUNT+2],DS
  4008 00000FAD E946F7                  		jmp	EXIT
  4009                                  
  4010                                  ; 13/06/2018
  4011                                  ; 27/05/2018 - Retro DOS v3.0
  4012                                  
  4013                                  ;
  4014                                  ;      GETBP fills the BDS with the BPB for the media currently in the drive.
  4015                                  ; The following steps are followed:
  4016                                  ;	If the Return_Fake_BPB flag is set then the GETBP just returns.
  4017                                  ;	If the BDS is for a hard disk (non-removable) then GETBP returns since
  4018                                  ;   the BPB cannot change on a hard disk drive.
  4019                                  ;	For all other cases GETBP reads the boot sector and looks for a BPB
  4020                                  ;   in the boot sector. (All DOS 2.X and about disks should have a valid
  4021                                  ;   BPB in the boot sector.)
  4022                                  ;	If no valid BPB is found (DOS 1.X disk) then GETBP reads the FAT
  4023                                  ;   sector and gets the FAT ID byte.  With this byte a valid BPB is build.
  4024                                  ;
  4025                                  ;	Inputs:
  4026                                  ;		DS:DI points to correct BDS
  4027                                  ;
  4028                                  ;	Outputs:
  4029                                  ;		Fills in BPB in current BDS if valid BPB or FAT ID on disk.
  4030                                  ;		Carry set, and AL=7 if invalid disk.
  4031                                  ;		Carry set and error code in AL if other error.
  4032                                  ;
  4033                                  
  4034                                  GETBP:
  4035                                  					; if non-removable or returning
  4036                                  					; fake BPB then return BPB as is.
  4037 00000FB0 F745290500              		TEST	WORD [DI+BDS.Flags],RETURN_FAKE_BPB|fNon_Removable
  4038 00000FB5 7403                    		jz	short GETBP1
  4039 00000FB7 E98E00                  		JMP	GETRET_Exit
  4040                                  
  4041                                  GETBP1:
  4042 00000FBA 51                      		push	cx
  4043 00000FBB 52                      		push	dx
  4044 00000FBC 06                      		push	es
  4045 00000FBD 53                      		push	bx
  4046                                  ;
  4047                                  ; Attempt to read in boot sector and determine BPB.
  4048                                  ; We assume that the 2.x and greater DOS disks all have a valid boot sector.
  4049                                  ;
  4050                                  Rdboot:
  4051 00000FBE E88D00                  		call	READBOOTSEC
  4052 00000FC1 7233                    		jc	short GetBP_Err_Ret
  4053                                  		;jnc	short NoRdErr
  4054                                  		;jmp	GetBP_Err_Ret	; Carry set if there was error.
  4055                                  NoRdErr:
  4056 00000FC3 83FB00                  		cmp	bx,0		; BX is 0 if boot sector is valid.
  4057                                  		;or	bx, bx
  4058 00000FC6 7505                    		jnz	short DoFatBPB	; if not go read FAT
  4059                                  
  4060 00000FC8 E8DD00                  		call	MOVBPB		; Move BPB into registers.
  4061 00000FCB EB5F                    		jmp	short HAS1
  4062                                  	
  4063                                  ;
  4064                                  ; At this point the drive contains a 1.X diskette.  We read the FAT byte
  4065                                  ; and fill in the BPB from there.
  4066                                  ;
  4067                                  
  4068                                  DoFatBPB:
  4069 00000FCD E8FA00                          	call    READFAT		; puts media descriptor byte in AH
  4070 00000FD0 7224                            	jc	short GetBP_Err_Ret ; if carry set, there was error, get out
  4071                                  
  4072                                  		;----------------------------------------|
  4073                                  		; Warning: Do not change the following. ;|
  4074                                  		;          It gets patched in msinit    ;|
  4075                                  							;|
  4076                                  GETBP1_PATCH:   		                        ;|
  4077 00000FD2 E8DE0C                  		call    hidensity               	;|
  4078                                  		;----------------------------------------|
  4079                                  		
  4080                                  		; Test for a valid 3.5" medium
  4081 00000FD5 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall
  4082 00000FD9 7520                            	jnz	short Is_Floppy
  4083                                          
  4084 00000FDB 80FCF9                  		cmp     ah,0F9H		; is it a valid fat ID byte for 3.5" ?
  4085 00000FDE 7569                    		jnz     short Got_Unknown_Medium
  4086 00000FE0 BB[7704]                        	mov     bx,SM92		; pointer to correct BPB
  4087 00000FE3 0E                              	push    cs
  4088 00000FE4 07                              	pop     es
  4089                                  ;--------------------------------------------------------------bug330a08
  4090                                  		;mov	al,[es:bx+bpbType.spf]
  4091 00000FE5 268A07                  		mov	al,[es:bx]  ; 05/07/2019 - Retro DOS v3.1
  4092 00000FE8 268B4F03                        	mov     cx,[es:bx+bpbType.csec]
  4093 00000FEC 268B5705                        	mov     dx,[es:bx+bpbType.spa]
  4094 00000FF0 268B5F01                        	mov     bx,[es:bx+bpbType.spt]
  4095                                  ;--------------------------------------------------------------bug330a08
  4096 00000FF4 EB33                    		jmp	short HAS1_res	; Need to load reserved sectors
  4097                                  
  4098                                  		; 13/06/2018
  4099                                  GetBP_Err_Ret:
  4100 00000FF6 E81704                  		CALL	MAPERROR
  4101 00000FF9 EB49                    		JMP	SHORT GETRET
  4102                                  
  4103                                  ;
  4104                                  ; must be a 5.25" floppy if we come here
  4105                                  ;
  4106                                  Is_Floppy:
  4107 00000FFB 88E1                    		mov     CL,AH		; save media
  4108 00000FFD 80E1F8                  		and     CL,0F8H		; normalize
  4109 00001000 80F9F8                  		cmp     CL,0F8H		; compare with good media byte
  4110 00001003 7544                            	jnz     short Got_Unknown_Medium
  4111                                  
  4112 00001005 B001                    GOODID: 	mov     AL,1		; set number of FAT sectors
  4113 00001007 BB0840                          	mov     BX,64*256+8	; set dir entries and sector max
  4114 0000100A B94001                          	mov     CX,40*8		; set size of drive
  4115 0000100D BA0101                          	mov     DX,01*256+1	; set head limit and sec/all unit
  4116 00001010 F6C402                         		test    AH,00000010B	; test for 8 or 9 sectors
  4117 00001013 7507                            	jnz	short HAS8	; NZ = has 8 sectors
  4118 00001015 FEC0                            	inc     AL		; inc number of FAT sectors
  4119 00001017 FEC3                            	inc     BL		; inc sector max
  4120 00001019 83C128                          	add     CX,40		; increase size
  4121 0000101C F6C401                  HAS8:   	test    AH,00000001B	; test for 1 or 2 heads
  4122 0000101F 7408                    		jz	short HAS1_res	; Z = 1 head
  4123 00001021 01C9                    		add     CX,CX		; double size of disk
  4124 00001023 B770                    		mov     BH,112		; increase number of directory entries
  4125 00001025 FEC6                    		inc     DH		; inc sec/all unit
  4126 00001027 FEC2                    		inc     DL		; inc head limit
  4127                                  HAS1_res:
  4128 00001029 8B7509                  		mov	si,[DI+BDS.RESSEC]
  4129                                  					; save values in BDS
  4130 0000102C 887508                  HAS1:		mov     [DI+BDS.SecPerClus],DH
  4131 0000102F 887D0C                          	mov     [DI+BDS.cDir],BH
  4132 00001032 894D0E                          	mov     [DI+BDS.DRVLIM],CX
  4133 00001035 886510                          	mov     [DI+BDS.Mediad],AH
  4134 00001038 884511                          	mov     [DI+BDS.cSecFat],AL
  4135 0000103B 885D13                          	mov     [DI+BDS.SECLIM],BL
  4136 0000103E 885515                          	mov     [DI+BDS.HDLIM],DL
  4137 00001041 897509                          	mov     [DI+BDS.RESSEC],SI
  4138                                  GETRET: 
  4139 00001044 5B                      		pop     bx
  4140 00001045 07                      		pop	es
  4141 00001046 5A                      		pop	dx
  4142 00001047 59                      		pop	cx	
  4143                                  GETRET_Exit:
  4144 00001048 C3                      		retn
  4145                                  
  4146                                  ;
  4147                                  ; We have a 3.5" diskette for which we cannot build a BPB. We do not assume any
  4148                                  ; type of BPB for this medium.
  4149                                  ;
  4150                                  Got_Unknown_Medium:
  4151 00001049 B007                    		mov	al,error_unknown_media
  4152 0000104B F9                      		stc
  4153 0000104C EBF6                    		jmp	short GETRET
  4154                                  
  4155                                  ;
  4156                                  ; Read in the boot sector. Set carry if error in reading sector.
  4157                                  ; BX is set to 1 if the boot sector is invalid, otherwise it is 0.
  4158                                  ;
  4159                                  READBOOTSEC:
  4160 0000104E B90100                  		mov	CX,0001h	; set track and sector number
  4161 00001051 30F6                    		xor     DH,DH		; set head number for read_sector
  4162 00001053 E88600                  		call	READ_SECTOR
  4163 00001056 724F                    		jc	short Err_ret	; error - get out
  4164 00001058 31DB                    		xor	bx,bx		; assume valid boot sector.
  4165                                  
  4166                                  				; at this point the boot sector has been
  4167                                  				; read in from the disk.  We now need to
  4168                                  				; determine if the boot sector contains
  4169                                  				; a valid BPB.	Currently there are only
  4170                                  				; a few simple checks.	Expanding the
  4171                                  				; number or types of checks would not be
  4172                                  				; a bad idea.
  4173                                  
  4174                                  ;*******************************************************************************
  4175                                  ; Put a sanity check for the boot sector in here to detect boot sectors that
  4176                                  ; do not have valid BPBs.
  4177                                  ; We examine the first two bytes - they must contain a long jump or a short
  4178                                  ; jump followed by a NOP.
  4179                                  ; If this test is passed, we further check by examining the signature at
  4180                                  ; the end of the boot sector for the word AA55H.
  4181                                  ; If the signature is not present, we examine the media descriptor byte to
  4182                                  ; see if it is valid.
  4183                                  ;******************************************************************************
  4184 0000105A 2E803E[3001]69          		cmp	byte [cs:DiskSector],069H    ; Is it a direct jump?
  4185 00001060 7418                    		JE	short Check_bpb_MediaByte    ; DON'T NEED TO FIND A NOP
  4186 00001062 2E803E[3001]E9          		cmp	byte [cs:DiskSector],0E9H    ; DOS 2.0 jump?
  4187 00001068 7410                    		JE	short Check_bpb_MediaByte    ; NO NEED FOR NOP
  4188 0000106A 2E803E[3001]EB          		cmp	byte [cs:DiskSector],0EBH    ; How about a short jump.
  4189 00001070 7533                    		JNE	short INVALIDBOOTSEC
  4190 00001072 2E803E[3201]90          		cmp	byte [cs:DiskSector+2],090H  ; Is next one a NOP?
  4191 00001078 752B                    		JNE	short INVALIDBOOTSEC
  4192                                  
  4193                                  ; Don't have to perform the following signature check since
  4194                                  ; we need to check the media byte even with the good signatured diskette.
  4195                                  ;CHECK_SIGNATURE:
  4196                                  ;		CMP	word [cs:DiskSector+1FEh],0AA55h ; SEE IF NON-IBM
  4197                                  ;							 ; DISK OR 1.X MEDIA.
  4198                                  ;		JZ	short CHECKSINGLESIDED ; GO SEE IF SINGLE SIDED MEDIUM.
  4199                                  ;					       ; MAY NEED SOME SPECIAL HANDLING
  4200                                  ;
  4201                                  ; CHECK FOR NON-IBM DISKS WHICH DO NOT HAVE THE SIGNATURE AA55 AT THE
  4202                                  ; END OF THE BOOT SECTOR, BUT STILL HAVE A VALID BOOT SECTOR. THIS IS DONE
  4203                                  ; BY EXAMINING THE MEDIA DESCRIPTOR IN THE BOOT SECTOR.
  4204                                  ;
  4205                                  
  4206                                  ;;Rev 3.30 Modification
  4207                                  Check_bpb_MediaByte:
  4208                                  
  4209 0000107A 2EA0[4501]              		MOV	AL,[CS:MediaByte]
  4210 0000107E 24F0                    		AND	AL,0F0H
  4211 00001080 3CF0                    		CMP	AL,0F0H		; ALLOW FOR STRANGE MEDIA
  4212 00001082 7521                    		JNZ	short INVALIDBOOTSEC 
  4213                                  ;
  4214                                  ; THERE WERE SOME (APPARENTLY A BUNCH) DISKETTES THAT HAD BEEN FORMATTED
  4215                                  ; UNDER DOS 3.1 AND EARLIER VERSIONS WHICH HAVE INVALID BPBS IN THEIR BOOT
  4216                                  ; SECTORS. THESE ARE SPECIFICALLY DISKETTES THAT WERE FORMATTED IN DRIVES
  4217                                  ; WITH ONE HEAD, OR WHOSE SIDE 0 WAS BAD. THESE CONTAIN BPBS IN THE BOOT
  4218                                  ; SECT THAT HAVE THE SEC/CLUS FIELD SET TO 2 INSTEAD OF 1, AS IS STANDARD
  4219                                  ; IN DOS. TO SUPPORT THEM, WE HAVE TO INTRODUCE A "HACK" THAT WILL
  4220                                  ; HELP OUR BUILD BPB ROUTINE TO RECOGNISE THESE SPECIFIC CASES, AND TO
  4221                                  ; SET UP OUT COPY OF THE BPB ACCORDINGLY.
  4222                                  ; WE DO THIS BY CHECKING TO SEE IF THE BOOT SECTOR IS OFF A DISKETTE THAT
  4223                                  ; IS SINGLE-SIDED AND IS A PRE-DOS 3.20 DISKETTE. IF IT IS, WE SET THE
  4224                                  ; SEC/CLUS FIELD TO 1. IF NOT, WE CARRY ON AS NORMAL.
  4225                                  CHECKSINGLESIDED:
  4226 00001084 2EA0[4501]              		MOV	AL,[CS:MediaByte]
  4227 00001088 A801                    		TEST	AL,0001H ; IS LOW BIT SET? - INDICATES DOUBLE SIDED
  4228 0000108A 751A                    		JNZ	short GoodDsk
  4229 0000108C 2E813E[3801]332E        		CMP	word [CS:DiskSector+8],"3."
  4230 00001093 7508                    		JNZ	short MUSTBEEARLIER
  4231 00001095 2E803E[3A01]32          		CMP	byte [CS:DiskSector+10],"2"
  4232 0000109B 7309                    		JAE	short GoodDsk
  4233                                  
  4234                                  ; WE MUST HAVE A PRE-3.20 DISKETTE. SET THE SEC/CLUS FIELD TO 1
  4235                                  MUSTBEEARLIER:
  4236 0000109D 2EC606[3D01]01          		MOV	BYTE [CS:SECPERCLUSINSECTOR],1
  4237 000010A3 EB01                    		JMP	short GoodDsk
  4238                                  
  4239                                  INVALIDBOOTSEC:
  4240 000010A5 43                      		INC	BX		; SET THAT BOOT SECTOR INVALID
  4241                                  ;;End of Modification
  4242                                  
  4243                                  GoodDsk:				; carry already reset
  4244 000010A6 F8                      		clc
  4245                                  Err_ret:
  4246 000010A7 C3                      		retn
  4247                                  
  4248                                  ;Err_Ret:				; carry is already set on entry here
  4249                                  ;		retn
  4250                                  
  4251                                  ;
  4252                                  ; MovBPB moves the BPB read from the Boot sector into registers for use by
  4253                                  ; GETBP routine at Has1
  4254                                  ;
  4255                                  MOVBPB:
  4256 000010A8 1E                      		push	ds
  4257 000010A9 57                      		push	di
  4258 000010AA 0E                      		push	cs
  4259 000010AB 1F                      		pop	ds
  4260 000010AC BF[3B01]                		mov	di,BPB_In_Sector
  4261 000010AF 8A7502                  		mov	dh,[DI+BPB_TYPE.SECALL]	;sectors per unit
  4262 000010B2 8A7D06                  		mov	bh,[DI+BPB_TYPE.DIRNUM]	;number of directory entries
  4263 000010B5 8B4D08                  		mov	cx,[DI+BPB_TYPE.SECNUM]	;size of drive
  4264 000010B8 8A650A                  		mov	ah,[DI+BPB_TYPE.FATID]	;media descriptor
  4265 000010BB 8A450B                  		mov	al,[DI+BPB_TYPE.FATSIZE] ;number of FAT sectors
  4266 000010BE 8A5D0D                  		mov	bl,[DI+BPB_TYPE.SLIM]	;sectors per track
  4267 000010C1 8A550F                  		mov	dl,[DI+BPB_TYPE.HLIM]	;number of heads
  4268 000010C4 8B7503                  		mov	si,[DI+BPB_TYPE.RESNUM]	;reserved sectors
  4269 000010C7 5F                      		pop	di
  4270 000010C8 1F                      		pop	ds
  4271 000010C9 C3                      		retn
  4272                                  
  4273                                  ;
  4274                                  ; Read in the FAT sector and get the Media Byte from it.
  4275                                  ; Input : AL contains logical drive.
  4276                                  ; Output:
  4277                                  ;	  Carry set if an error occurs, AX contains error code.
  4278                                  ;	  Otherwise, AH contains media byte on exit. AL is preserved.
  4279                                  
  4280                                  READFAT:
  4281 000010CA 50                      		push	ax		   ; preserve logical drive in AL
  4282 000010CB B600                    		MOV	DH,0		   ; HEAD 0
  4283 000010CD B90200                  		mov	CX,2		   ; set track and sector number
  4284 000010D0 E80900                  		call	READ_SECTOR	   ; CS:BX points to fat sector
  4285 000010D3 7205                    		jc	short Bad_FAT_Ret  ; error, get out
  4286 000010D5 58                      		pop	ax		   ; reset logical drive
  4287 000010D6 2E8A27                  		mov	ah,[CS:BX]	   ; media byte
  4288 000010D9 C3                      		retn
  4289                                  
  4290                                  Bad_FAT_Ret:				   ; carry set on entry
  4291 000010DA 59                      		pop	cx	           ; clear stack
  4292 000010DB C3                      		retn
  4293                                  
  4294                                  ;
  4295                                  ; Read_sector reads a single sector into the tempory buffer 'DiskSector'.
  4296                                  ; Up to three retries are done in case of error.
  4297                                  ;
  4298                                  ;    Inputs:
  4299                                  ;	DS:DI	points to BDS for drive
  4300                                  ;	CH - track number
  4301                                  ;	CL - sector number
  4302                                  ;	DH - head number
  4303                                  ;
  4304                                  ;    Outputs:
  4305                                  ;	If carry is clear -- successful read
  4306                                  ;	   CS:BX points to buffer holding sector
  4307                                  ;	   AX, BX are not preserved, CX, DX, BP, and ES are preserved
  4308                                  ;
  4309                                  ;	If carry is set -- error on read
  4310                                  ;	   AX, BX, and DX are not preserved; CX, BP, and ES are preserved
  4311                                  ;
  4312                                  ;
  4313                                  
  4314                                  READ_SECTOR:
  4315 000010DC 55                      		push	BP		; preserve BP register
  4316 000010DD BD0300                  		mov	BP,3		; BP is retry count, set to 3
  4317 000010E0 06                      		push	ES		; preserve ES also
  4318 000010E1 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  4319 000010E4 BB[3001]                		mov	BX,DiskSector	; Get ES:BX to point to buffer
  4320 000010E7 0E                      		push	CS		;    get the segment right
  4321 000010E8 07                      		pop	ES		; now ES:BX is correct
  4322                                  
  4323                                  RD_RET:
  4324                                  					; set command to read (AH=2) and
  4325 000010E9 B80102                  		mov	AX,0201h	; number of sectors to 1 (AL=1)
  4326 000010EC CD13                    		int	13h		; call rom-bios disk routines
  4327 000010EE 733C                    		jnc	short OKRET2	; if no carry then no error - done
  4328                                  Rd_rty:
  4329 000010F0 E83407                  		call	AGAIN		; reset disk and decrement BP
  4330 000010F3 7434                    		jz	short ERR_RD_RET
  4331 000010F5 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  4332 000010FA 75ED                    		JNZ	short RD_RET
  4333                                  
  4334                                  ;;Rev 3.30 Modification -----------------------------------------
  4335 000010FC 1E                      		push	ds		; For retry, set head settle
  4336 000010FD 50                      		push	ax		; time to 0Fh.
  4337 000010FE 2EC536[1001]            		lds	si,[CS:DPT]
  4338 00001103 8A4409                  		mov	al,[SI+DISK_PARMS.DISK_HEAD_STTL]
  4339 00001106 2EA2[0D01]              		mov	[CS:Save_head_sttl],al
  4340 0000110A C644090F                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],NORMSETTLE
  4341 0000110E 58                      		pop	ax
  4342 0000110F 1F                      		pop	ds
  4343                                  					; SET CMD TO READ (AH=2) AND
  4344 00001110 B80102                  		MOV	AX,0201h	; NUM OF SECTORS TO 1 (AL=1)
  4345 00001113 CD13                    		INT	13h		; CALL ROM-BIOS DISK ROUTINES
  4346 00001115 1E                      		push	ds
  4347 00001116 50                      		push	ax
  4348 00001117 2EC536[1001]            		lds	si,[CS:DPT]
  4349 0000111C 2EA0[0D01]              		mov	al,[CS:Save_head_sttl]
  4350 00001120 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],al
  4351 00001123 58                      		pop	ax
  4352 00001124 1F                      		pop	ds
  4353 00001125 7305                    		jnc	short OKRET2
  4354 00001127 EBC7                    		jmp	short Rd_rty
  4355                                  ERR_RD_RET:
  4356 00001129 B2FF                    		MOV	DL,-1	; MAKE SURE WE ASK ROM IF MEDIA  CHANGED
  4357 0000112B F9                      		STC		; RETURN ERROR
  4358                                  ;;End of Modification -----------------------------------------
  4359                                  
  4360                                  			; Update information pertaining to last drive
  4361                                  			; accessed, time of access, last track accessed
  4362                                  			; in that drive.
  4363                                  OKRET2:
  4364                                  				; set up for head settle logic in DISK
  4365 0000112C 2E8816[6B00]            		mov	[CS:STEP_DRV],DL ; save last drive accessed
  4366 00001131 2E8816[FF00]            		mov	[CS:TIM_DRV],DL	; save the values
  4367 00001136 886D4C                  		mov	[DI+BDS.Track],CH ;
  4368 00001139 9C                      		pushf			; save the flags
  4369 0000113A E8EB02                  		call	SET_TIM
  4370 0000113D 9D                      		popf			; restore flags
  4371 0000113E 07                      		pop	ES		; restore registers
  4372 0000113F 5D                      		pop	BP
  4373 00001140 C3                      		retn
  4374                                  
  4375                                  ;27/05/2018 - Retro DOS v3.0
  4376                                  
  4377                                  ;------------------------------------------------------------------------
  4378                                  ;									:
  4379                                  ;		Disk Removable Routine					:
  4380                                  ;									:
  4381                                  ;  This routine determines if a particular logical drive has		:
  4382                                  ;  removable media.							:
  4383                                  ;									:
  4384                                  ;  Input								:
  4385                                  ;     AL contains the logical drive number which the check is being	:
  4386                                  ;  done.								:
  4387                                  ;------------------------------------------------------------------------
  4388                                  
  4389                                  DSK$REM:				;ARR 2.41
  4390 00001141 E865FD                  		call	SETDRIVE	; get BDS for this drive
  4391 00001144 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  4392 00001149 7503                    		jnz	short NON_REM
  4393 0000114B E9A8F5                  		jmp	EXIT
  4394                                  
  4395                                  NON_REM:				; if non removable set busy bit
  4396 0000114E E98AF5                  		jmp	BUS$EXIT
  4397                                  
  4398                                  ;------------------------------------------------------------------------
  4399                                  ;									:
  4400                                  ;		DISK I/O ROUTINES					:
  4401                                  ;									:
  4402                                  ;  On entry the register contain the following values:			:
  4403                                  ;									:
  4404                                  ;	AH - Media Descriptor byte					:
  4405                                  ;	AL - logical drive number					:
  4406                                  ;	CX - count of sectors to be read or written			:
  4407                                  ;	DX - start sector						:
  4408                                  ;	DI - offset of destination buffer				:
  4409                                  ;									:
  4410                                  ;------------------------------------------------------------------------
  4411                                  
  4412                                  ;------------------------------------------------------------------------
  4413                                  ;									:
  4414                                  ;		Disk Write with Verify					:
  4415                                  ;									:
  4416                                  ;  Input								:
  4417                                  ;	See about header for register contents on entry.		:
  4418                                  ;									:
  4419                                  ;------------------------------------------------------------------------
  4420                                  
  4421                                  
  4422                                  DSK$WRITV:
  4423 00001151 2EC706[0401]0301        		MOV	WORD [CS:WRTVERIFY],103H
  4424 00001158 EB07                    		JMP	SHORT DSK$CL
  4425                                  
  4426                                  ;------------------------------------------------------------------------
  4427                                  ;									:
  4428                                  ;		       Disk Write					:
  4429                                  ;									:
  4430                                  ;  Input								:
  4431                                  ;	See about header for register contents on entry.		:
  4432                                  ;									:
  4433                                  ;------------------------------------------------------------------------
  4434                                  
  4435                                  DSK$WRIT:
  4436 0000115A 2EC706[0401]0300        		MOV	WORD [CS:WRTVERIFY],ROMWrite
  4437                                  
  4438                                  DSK$CL:
  4439 00001161 E88F00                  		CALL	DISKIO
  4440                                  DSK$IO:
  4441 00001164 7203                    		JC	short DSKBad
  4442 00001166 E98DF5                  		JMP	EXIT
  4443                                  DSKBad:
  4444 00001169 E975F5                  		JMP	ERR$CNT
  4445                                  
  4446                                  ;------------------------------------------------------------------------
  4447                                  ;									:
  4448                                  ;			Disk Read					:
  4449                                  ;									:
  4450                                  ;  Input								:
  4451                                  ;	See about header for register contents on entry.		:
  4452                                  ;									:
  4453                                  ;------------------------------------------------------------------------
  4454                                  
  4455                                  DSK$READ:
  4456 0000116C E87F00                  		CALL	DISKRD
  4457 0000116F EBF3                    		JMP	short DSK$IO
  4458                                  
  4459                                  ; -----------------------------------------------------------------------
  4460                                  ; Miscellaneous odd jump routines. Moved out of mainline for speed.
  4461                                  ; -----------------------------------------------------------------------
  4462                                  
  4463                                  ; CheckSingle determines if the drive specified is a virtual drive (more
  4464                                  ; than one logical drive associated with one physical drive). If this
  4465                                  ; is the case we need to prompt the user to place the correct disk in
  4466                                  ; the drive.
  4467                                  ;
  4468                                  ;	Input:
  4469                                  ;	   DS:DI pints to the BDS for the drive being checked.
  4470                                  ;
  4471                                  ;	If there is a error the carry flag is set on return
  4472                                  ;
  4473                                  ;  All registers are preserved.
  4474                                  
  4475                                  
  4476                                  CHECKSINGLE:
  4477                                  		; 27/05/2018 - Retro DOS v3.0
  4478 00001171 50                      		push	AX		; save affected registers
  4479 00001172 53                      		push	BX
  4480                                  
  4481 00001173 8B5D29                  		mov	BX,[DI+BDS.Flags]
  4482                                  					;Can't change disk
  4483 00001176 F6C321                  		TEST	BL,fNon_Removable | fI_Own_Physical
  4484 00001179 7562                    		jnz	short SingleRet	; on hard drive so return
  4485                                  					; is there a drive sharing this
  4486 0000117B F6C310                  		TEST	BL,fI_Am_Mult	;   physical drive?
  4487 0000117E 745D                    		jz	short SingleRet	; if not, then return
  4488                                  
  4489                                  			; At this point there is more than one
  4490                                  			; logical drive mapped to this physical drive.
  4491                                  			; But the drive being accessed is not the
  4492                                  			; owner of the physical drive.	What needs to
  4493                                  			; be done is find the current owner BDS and
  4494                                  			; turn off the owner flag and then make current
  4495                                  			; BDS the owner of the drive.  Then prompt the
  4496                                  			; user to change disks.
  4497                                  	
  4498 00001180 8A4504                  		mov	al,[DI+BDS.DriveNum] ; get physical drive number
  4499 00001183 1E                      		push	ds		; preserve pointer to current BDS
  4500 00001184 57                      		push	di
  4501 00001185 0E                      		push	cs
  4502 00001186 1F                      		pop	ds		; Point to start of BDS linked list
  4503                                  
  4504 00001187 BF[FA00]                		mov	di,START_BDS
  4505                                  Scan_List:
  4506 0000118A 8B5D02                  		mov	bx,[DI+BDS.Link+2] ; go to next BDS
  4507                                  		;mov	di,[DI+BDS.Link]
  4508 0000118D 8B3D                    		mov	di,[di] ; 05/07/2019
  4509 0000118F 8EDB                    		mov	ds,bx
  4510                                  		
  4511 00001191 83FFFF                  		cmp	di,-1		; end of list?
  4512 00001194 744A                    		jz	short Single_Err_Ret ; if so there must be an error
  4513                                  					; same physical drive?
  4514 00001196 384504                  		cmp	[DI+BDS.DriveNum],al
  4515 00001199 75EF                    		jnz	short Scan_List	; no, keep looking
  4516                                  
  4517                                  Check_Own:				; yes, check to see if owner
  4518 0000119B 8B5D29                  		mov	bx,[DI+BDS.Flags]
  4519 0000119E F6C320                  		test	bl,fI_Own_Physical
  4520 000011A1 74E7                    		jz	short Scan_List	; not owner, keep looking
  4521 000011A3 80F320                  		xor	bl,fI_Own_Physical ; yes owner, reset ownership flag
  4522 000011A6 895D29                  		mov	[DI+BDS.Flags],bx
  4523 000011A9 5F                      		pop	di		; Restore pointer to current BDS
  4524 000011AA 1F                      		pop	ds
  4525 000011AB 31DB                    		xor	bx,bx
  4526 000011AD 80CB20                  		or	bl,fI_Own_Physical ; establish current BDS as owner
  4527 000011B0 095D29                  		or	[DI+BDS.Flags],bx
  4528                                  
  4529                                  			;
  4530                                  			; We examine the fSetOwner flag. If it is
  4531                                  			; set, then we are using the code in
  4532                                  			; CheckSingle to just set the owner of
  4533                                  			; a drive. We must not issue the prompt
  4534                                  			; in this case.
  4535                                  			;
  4536                                  
  4537 000011B3 2E803E[7000]01          		cmp	byte [cs:fSetOwner],1
  4538 000011B9 7422                    		jz	short SingleRet
  4539                                  	
  4540                                  			;
  4541                                  			; To support "backward" compatibility with
  4542                                  			; IBM's "single drive status byte" we now
  4543                                  			; check to see if we are in a single drive
  4544                                  			; system and the Application has "cleverly"
  4545                                  			; diddled the SDSB (Single Drive Status Byte)
  4546                                  			;
  4547                                  
  4548 000011BB 2E803E[6F00]02          		cmp	byte [cs:Single],2	   ; single drive system?
  4549 000011C1 7517                    		jne	short Ignore_SDSB  ; no, jump down
  4550                                  
  4551 000011C3 1E                      		push	ds		   ; yes...		
  4552 000011C4 57                      		push	di
  4553 000011C5 50                      		push	ax
  4554                                  
  4555 000011C6 8A4505                  		mov	al,[DI+BDS.DriveLet] ; IF (Curr_drv == Req_drv)
  4556 000011C9 88C4                    		mov	ah,al
  4557 000011CB 31FF                    		xor	di,di
  4558 000011CD 8EDF                    		mov	ds,di
  4559 000011CF 86060405                		xchg	al,[LSTDRV]	    ; THEN swap(Curr_drv,Req_drv)
  4560 000011D3 38C4                    		cmp	ah,al		    ; ELSE
  4561 000011D5 58                      		pop	ax		    ;     swap(Curr_drv,Req_drv)	
  4562 000011D6 5F                      		pop	di		    ;	  Issue Swap_dsk_msg	
  4563 000011D7 1F                      		pop	ds
  4564 000011D8 7403                    		je	short SingleRet	
  4565                                  
  4566                                  Ignore_SDSB:
  4567 000011DA E8CD08                  		call	SWPDSK		; ask user for correct disk
  4568                                  
  4569                                  SingleRet:
  4570 000011DD 5B                      		pop	BX		; restore registers
  4571 000011DE 58                      		pop	AX
  4572 000011DF C3                      		retn			; return
  4573                                  
  4574                                  Single_Err_Ret:
  4575 000011E0 F9                      		stc			; set carry flage to indicate error
  4576 000011E1 5F                      		pop	di		; restore current BDS
  4577 000011E2 1F                      		pop	ds
  4578 000011E3 EBF8                    		jmp	short SingleRet
  4579                                  
  4580                                  ;
  4581                                  ; BadDrive is called when sector specified is greater than last
  4582                                  ; sector on disk.
  4583                                  ; or when BDS is not found for drive
  4584                                  ;
  4585                                  
  4586                                  BadDrive:
  4587 000011E5 B008                    		mov	AL,8		; error code 'sector not found'
  4588 000011E7 F9                      		stc			; indicate error
  4589                                  IORET:	
  4590 000011E8 C3                      		retn			; return
  4591                                  
  4592                                  BogusSettle:
  4593 000011E9 B00F                    		MOV	AL,NORMSETTLE	; someone has diddled the settle
  4594 000011EB E9B100                  		JMP	GotSlowSettle
  4595                                  
  4596                                  ; -----------------------------------------------------------------------
  4597                                  ;
  4598                                  ;	DISK I/O HANDLER
  4599                                  ;
  4600                                  ;   On entry:
  4601                                  ;	AL = Drive Number (0-6)
  4602                                  ;	AH = Media Descriptor
  4603                                  ;	CX = sector count
  4604                                  ;	DX = first sector
  4605                                  ;	DS = CS
  4606                                  ;	ES:DI = transfer address
  4607                                  ;	[RFLAG] = operation (2 for read, 3 for write)
  4608                                  ;	[VERIFY] = 1 for verity after write
  4609                                  ;
  4610                                  ;   On exit:
  4611                                  ;	if successful carry flag = 0
  4612                                  ;	  else CF=1 and AL contains error code
  4613                                  ;
  4614                                  ; -----------------------------------------------------------------------
  4615                                  
  4616                                  DISKRD:		; 27/05/2018 - Retro DOS v3.0
  4617                                  		;mov	byte [CS:RFLAG],ROMRead	; set command to read
  4618 000011EE C606[0401]02            		mov	byte [RFLAG],ROMRead	 ; 11/04/2018
  4619                                  DISKIO:
  4620                                  		; 13/04/2018
  4621                                  		; 08/04/2018
  4622                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  4623                                  
  4624                                  		;clc
  4625                                  		;jcxz	IORET
  4626                                  		
  4627                                  		;;mov	[CS:SPSAV],SP		; save the sp value
  4628                                  		;mov	[SPSAV],sp
  4629                                  
  4630 000011F3 89FB                    		mov	BX,DI			; ES:BX is transfer address
  4631 000011F5 E8B1FC                  		call	SETDRIVE		; map logical and physical
  4632 000011F8 72EB                    		jc	short BadDrive		; carry means BDS not found
  4633 000011FA 8A4510                  		mov	al,[DI+BDS.Mediad]
  4634 000011FD 2EA2[0201]              		mov	[CS:MedByt],al		; Preserve media byte for drive for use
  4635                                  						; in determining media change.
  4636 00001201 E3E5                    		jcxz	IORET
  4637 00001203 2E8926[1801]            		mov	[CS:SPSAV],SP		; save the sp value
  4638                                  
  4639                                  		; DX = Sector address (offset)
  4640                                  		; BX = Buffer address (offset)
  4641                                  		
  4642                                  ; Ensure that we are trying to access valid sectors on the drive
  4643                                  ;
  4644 00001208 89D6                    		mov	SI,DX			; start with first sector
  4645 0000120A 01CE                    		add	SI,CX			; add in sector count
  4646 0000120C 035517                  		add	DX,[DI+BDS.HIDSEC]	; add in the hidden sectors
  4647 0000120F 3B750E                  		cmp	SI,[DI+BDS.DRVLIM]	; compare against max (volume size)
  4648 00001212 77D1                    		ja	short BadDrive		; if greater than max, error
  4649 00001214 2E890E[0601]            		mov	[CS:SECCNT],CX		; save sector count
  4650                                  
  4651                                  ;;Rev 3.30 Modification -----------------------------------------
  4652                                  ; SET UP POINTER TO DISK BASE TABLE IN [DPT]. WE CANNOT ASSUME THAT IOSETUP
  4653                                  ; WILL DO IT BECAUSE WE WILL SKIP THE SET UP STUFF WITH HARD DISKS.
  4654 00001219 1E                      		PUSH	DS
  4655 0000121A 31C0                    		XOR	AX,AX
  4656 0000121C 8ED8                    		MOV	DS,AX
  4657 0000121E C5367800                		LDS	SI,[DSKADR]		; CURRENT DISK PARM TABLE
  4658 00001222 2E8936[1001]            		MOV	[CS:DPT],SI
  4659 00001227 2E8C1E[1201]            		MOV	[CS:DPT+2],DS
  4660 0000122C 1F                      		POP	DS
  4661                                  ;;End of Modification -----------------------------------------
  4662                                  
  4663                                  
  4664                                  ; For hard drives do not do media check or set DPT.
  4665                                  ;
  4666                                  
  4667 0000122D F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  4668 00001232 7509                    		jnz	short Skip_Setup
  4669                                  	
  4670 00001234 E83AFF                  		CALL	CHECKSINGLE
  4671                                  
  4672                                  ;
  4673                                  ; Check to see if we have previously noted a change line.  The routine
  4674                                  ; returns if everything is OK.	Otherwise, it pops off the stack and returns
  4675                                  ; the proper error code.
  4676                                  ;
  4677                                  		;----------------------------------------|
  4678                                  		; Warning: Do not change the following. ;|
  4679                                  		;	   It gets patched in msinit	;|
  4680                                  							;|
  4681                                  DiskIO_PATCH:						;|
  4682 00001237 E8E909                  		CALL	CheckLatchIO			;|
  4683                                  		;----------------------------------------|
  4684                                  ;
  4685                                  ; Set up tables and variables for I/O
  4686 0000123A E82900                  		call	IOSETUP
  4687                                  ;
  4688                                  ; Now the settle values are correct for the following code
  4689                                  ;
  4690                                  Skip_Setup:
  4691 0000123D 89D0                    		mov	AX,DX		; setup locical sector for divide
  4692 0000123F 31D2                    		xor	DX,DX
  4693 00001241 F77513                  		div	word [DI+BDS.SECLIM] ; divide by sectors per track
  4694 00001244 FEC2                    		inc	DL
  4695 00001246 2E8816[1401]            		mov	[CS:CURSEC],DL	; save current sector
  4696 0000124B 8B4D15                  		mov	CX,[DI+BDS.HDLIM]  ; get number of heads
  4697 0000124E 31D2                    		xor	DX,DX		; divide tracks by heads per cylinder
  4698 00001250 F7F1                    		div	CX
  4699 00001252 2E8816[1501]            		mov	[CS:CURHD],DL	; save current head
  4700 00001257 2EA3[1601]              		mov	[CS:CURTRK],AX	; save current track
  4701                                  ;
  4702                                  ; We are now set up for the I/O.  Normally, we consider the DMA boundary
  4703                                  ; violations here.  Not true.  We perform the operation as if everything is
  4704                                  ; symmetric; let the DISK INT handler worry about the DMA violations.
  4705                                  ;
  4706 0000125B 2EA1[0601]              		mov	AX,[CS:SECCNT]
  4707 0000125F E87100                  		call	BLOCK
  4708 00001262 E84100                  		call	DONE
  4709 00001265 C3                      		retn
  4710                                  
  4711                                  ; 27/05/2018 - Retro DOS v3.0
  4712                                  
  4713                                  ; IOSetUp:
  4714                                  ;
  4715                                  ; IOSetUp does the following functions:
  4716                                  ;   *	Set the drive-last-accessed flag (for diskette only).  No need to
  4717                                  ;	update these flags for hard disks becuase we know a hard disk will
  4718                                  ;	not be removed.
  4719                                  ;   *	Set the proper last sector number in the Disk Parameter Table (DPT)
  4720                                  ;   *	Set the proper motor start up time in DPT
  4721                                  ;   *	Set the proper head settle time in the DPT
  4722                                  ;
  4723                                  ; Input:
  4724                                  ;	DS:DI -> current BDS.
  4725                                  ; Output:
  4726                                  ;	AX,CX,SI are destroyed.
  4727                                  ;
  4728                                  
  4729                                  IOSETUP:
  4730 00001266 8A4504                  		MOV	AL,[DI+BDS.DriveNum]
  4731 00001269 2EA2[FF00]              		MOV	[CS:TIM_DRV],AL	; SAVE DRIVE LETTER
  4732                                  ;
  4733                                  ; determine proper head settle values
  4734                                  ;
  4735 0000126D 8CD9                    		mov	CX,DS
  4736 0000126F 2EC536[1001]            		LDS	SI,[CS:DPT]	; GET POINTER TO DISK BASE TABLE
  4737 00001274 2EA0[0E01]              		MOV	AL,[CS:EOT]
  4738 00001278 884404                  		mov	[SI+DISK_PARMS.DISK_EOT],AL	; bump for us
  4739 0000127B 8A440A                  		mov	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT] 
  4740                                  					; preserve old motor start time
  4741 0000127E 2EA2[0901]              		mov	[CS:MotorStartup],AL
  4742                                  ;
  4743                                  ; For 3.5" drives, both external as well as on the K09, we need to set the
  4744                                  ; Motor Start Time to 4. This checking for every I/O is going to affect
  4745                                  ; performance across the board, but is necessary!!
  4746                                  ;
  4747 00001282 06                      		push	es
  4748 00001283 8EC1                    		mov	es,cx		; ES:DI -> to current BDS
  4749 00001285 26807D2802              		cmp	byte [es:di+BDS.FormFactor],ffSmall
  4750 0000128A 7505                    		jnz	short Motor_Start_OK
  4751 0000128C B004                    		mov	AL,4
  4752 0000128E 86440A                  		xchg	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT]
  4753                                  Motor_Start_OK:
  4754 00001291 07                      		pop	ES
  4755                                  ;
  4756                                  ; DS:SI now points to disk parameter table.  Get current settle and set fast
  4757                                  ; settle
  4758                                  ;
  4759 00001292 30C0                    		XOR	AL,AL
  4760 00001294 FEC0                    		INC	AL		; IBM WANTS FAST SETTLE = 1 - RS
  4761 00001296 864409                  		xchg	AL,[SI+DISK_PARMS.DISK_HEAD_STTL]
  4762                                  					; get settle and set up for fast
  4763 00001299 2EA2[0A01]              		mov	[CS:SettleCurrent],AL
  4764 0000129D B00F                    		MOV	AL,NORMSETTLE	; SOMEONE HAS DIDDLED THE SETTLE
  4765                                  GotSlowSettle:
  4766 0000129F 8ED9                    		mov	DS,CX
  4767 000012A1 2EA2[0B01]              		mov	[CS:SettleSlow],AL
  4768 000012A5 C3                      		retn
  4769                                  
  4770                                  ;
  4771                                  ; Set time of last access, and reset default values in the DPT.
  4772                                  ;
  4773                                  DONE:
  4774 000012A6 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  4775 000012AB 7525                    		jnz	short RETZ	; Do not set for non-removable Media
  4776 000012AD E87801                  		call	SET_TIM		; set time of last access for drive
  4777                                  ;
  4778                                  ; Restore head settle and EOT values
  4779                                  ;
  4780                                  DiddleBack:
  4781 000012B0 50                      		push	ax			; preserve AX
  4782 000012B1 8CDA                    		mov	DX,DS			; save DS in DX
  4783 000012B3 2EA0[0A01]              		mov	AL,[cs:SettleCurrent]	; get value in registers
  4784 000012B7 2E8A26[0901]            		mov	AH,[cs:MotorStartup]
  4785 000012BC 2EC536[1001]            		lds	SI,[CS:DPT]		; get pointer to DPT
  4786 000012C1 C6440409                		mov	byte [SI+DISK_PARMS.DISK_EOT],9 ; save values in DPT
  4787 000012C5 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  4788 000012C8 C6440302                		mov	byte [SI+DISK_PARMS.DISK_SECTOR_SIZ],2
  4789 000012CC 88640A                  		mov	[SI+DISK_PARMS.DISK_MOTOR_STRT],AH
  4790 000012CF 8EDA                    		mov	DS,DX			; restore DS
  4791 000012D1 58                      		pop	ax			; restore AX
  4792                                  RETZ:
  4793 000012D2 C3                      		retn
  4794                                  
  4795                                  ;
  4796                                  ; Block reads or writes the number of sectors specified in AX
  4797                                  ; handling track boundaries.  For example, on an 8 sector per track
  4798                                  ; disk there might be a request to read 6 sectors starting at the 5th
  4799                                  ; sector.  Block breaks this request into a read of sectors 5-8 on
  4800                                  ; the first track and a read of sectors 1-2 on the next track.	Disk is
  4801                                  ; called to do the actual read.
  4802                                  ;
  4803                                  ;   Inputs:
  4804                                  ;	AX - number of sectors to be read
  4805                                  ;	DS:DI points to BDS for disk drive
  4806                                  ;	cs:CurSec - sector on track where read should start
  4807                                  ;	cs:CurTrk - track where read should start
  4808                                  ;	cs:CurHd - head for read
  4809                                  ;	ES:BX - transfer address
  4810                                  ; AX, CX, and BL are not preserved
  4811                                  ;
  4812                                  
  4813                                  BLOCK:
  4814 000012D3 09C0                    		or	AX,AX		; see if any sectors to read
  4815 000012D5 74FB                    		jz	short RETZ	; if not, return
  4816                                  ;;Rev 3.30 Modification -----------------------------------------
  4817                                  ; Fixed disk will not be restricted to the trk-by-trk basis.
  4818 000012D7 F745290100              		test	word [DI+BDS.Flags], fNon_Removable
  4819 000012DC 7406                    		jz	short BLOCK_FLOPPY
  4820 000012DE E82600                  		call	DISK
  4821 000012E1 31C0                    		xor	ax,ax
  4822 000012E3 C3                      		RETN
  4823                                  BLOCK_FLOPPY:
  4824                                  ;;End of Modification -----------------------------------------
  4825                                  ;
  4826                                  ; READ AT MOST 1 TRACK WORTH.  PERFORM MINIMIZATION AT SECTOR / TRACK
  4827                                  ;
  4828 000012E4 8A4D13                  		mov	CL,[DI+BDS.SECLIM] ; get sectors per track
  4829 000012E7 FEC1                    		inc	CL
  4830 000012E9 2E2A0E[1401]            		sub	CL,[CS:CURSEC]	; set CX to number of sector after current
  4831 000012EE 30ED                    		xor	CH,CH		;    sector on the current track
  4832 000012F0 39C8                    		cmp	AX,CX		; is all of request on current track?
  4833 000012F2 7302                    		jae	short GotMin	; no, jump down
  4834 000012F4 89C1                    		mov	CX,AX	; yes, set number of sector on this track to AX
  4835                                  GotMin:
  4836                                  				; now
  4837                                  				; AX is the requested number of sectors to read
  4838                                  				; CX is the number that we can do on this track
  4839 000012F6 50                      		push	AX
  4840 000012F7 51                      		push	CX
  4841 000012F8 89C8                    		mov	AX,CX	; AL is number of sectors to read
  4842 000012FA E80A00                  		call	DISK
  4843 000012FD 59                      		pop	CX
  4844 000012FE 58                      		pop	AX
  4845                                  
  4846                                  				; CX is the number of sectors just transferred
  4847 000012FF 29C8                    		sub	AX,CX	; reduce sectors-remaining by last I/O
  4848 00001301 D0E1                    		shl	CL,1
  4849 00001303 00CF                    		add	BH,CL	; adjust transfer address
  4850 00001305 EBCC                    		jmp	short BLOCK ; jump to do any remaining sectors
  4851                                  
  4852                                  
  4853                                  ; 27/05/2018 - Retro DOS v3.0
  4854                                  ;
  4855                                  ;  DISK:
  4856                                  ; Disk is called to read or write one or more sectors on a track.
  4857                                  ; Retries are make if an error occurs.
  4858                                  ;
  4859                                  ;    Input:
  4860                                  ;	AL - number of sector to be read/written (they must all be on one track)
  4861                                  ;	DS:DI points to BDS for the drive
  4862                                  ;	ES:BX is transfer address (must not cross 64k physical boundry)
  4863                                  ;	[RFLAG] is 2 for read and 3 for write
  4864                                  ;	[VERIFY] is 0 for normal, 1 for verify after write
  4865                                  ;	[CurTrk] is track (cylinder) to be read/written.
  4866                                  ;	[CurHd] is head to be used in operation.
  4867                                  ;	[CurSec] is sector to start read on.
  4868                                  ;
  4869                                  ; The following are overwritten: BP,
  4870                                  ;   Output:
  4871                                  ;	[SECCNT] is decrement by the number of sectors read or written
  4872                                  
  4873                                  DISK:
  4874 00001307 BD0500                  		mov	BP,MAXERR	; set up retry count
  4875 0000130A 2E8A26[0401]            		MOV	AH,[CS:RFLAG]	;GET READ/WRITE INDICATOR
  4876                                  
  4877                                  RETRY:
  4878                                  				; AX is overwritten in int 13 call, so
  4879                                  				; to do a retry we need to save the
  4880                                  				; value by pushing on the stack
  4881 0000130F 50                      		push	AX
  4882                                  				; the next five lines of code put the
  4883                                  				; sector number in bit 5-0 of CL and the
  4884                                  				; cylinder number in CH and bits 7-6 of
  4885                                  				; CL.  The register must be set up in this
  4886                                  				; way for the bios.
  4887 00001310 2E8B16[1601]            		mov	DX,[CS:CURTRK]	;Load current cylinder
  4888                                  ;;Rev 3.30 Modification -----------------------------------------
  4889 00001315 F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk
  4890 0000131A 7409                    		jz	short DISK_NOT_MINI 	;no, skip this.
  4891                                  		;cmp	byte [DI+BDSM.isMini], 1
  4892 0000131C 837D4D01                		cmp	word [DI+BDSM.isMini], 1 ;Is this a mini disk?
  4893 00001320 7503                    		jnz	short DISK_NOT_MINI	;No. continue to next.
  4894 00001322 03554F                  		add	dx, [DI+BDSM.Hidden_Trks] ;else add hidden trks.
  4895                                  DISK_NOT_MINI:
  4896                                  ;;End of Modification -----------------------------------------
  4897 00001325 D0CE                    		ror	DH,1 ; get high two bits of cylinder in correct place
  4898 00001327 D0CE                    		ror	DH,1
  4899                                  
  4900 00001329 2E0A36[1401]            		or	DH,[cs:CURSEC]	; get sector value
  4901 0000132E 89D1                    		mov	CX,DX ; put cylinder/sector values in correct register
  4902                                  				; get head value
  4903 00001330 86E9                    		xchg	CH,CL	; put bytes in correct place
  4904 00001332 2E8A36[1501]            		mov	DH,[CS:CURHD]
  4905                                  				; get drive number
  4906 00001337 8A5504                  		mov	DL,[DI+BDS.DriveNum]
  4907                                  
  4908 0000133A 807D2805                		CMP	BYTE [DI+BDS.FormFactor],ffHardFile
  4909 0000133E 7414                    		JZ	short DO_Fast ; HARD FILES USE FAST SPEED
  4910                                  ;
  4911                                  ; The registers are now all set up for call on rom-bios.
  4912                                  ; The next dozen or so line determines whether we call Do_Fast or Do_Norm
  4913                                  ; for the actual I/O read.  Do_Fast calls FastSpeed for the actual I/O.
  4914                                  ; Do_Norm calls NormSpeed.  NormSpeed changes the value for the head settle
  4915                                  ; time in the disk parameter table to a larger value and then calls FastSpeed
  4916                                  ; to do the I/O.  So Do_Fast just has a shorter head settle time.
  4917                                  ;
  4918 00001340 2E803E[6B00]FF          		CMP	byte [CS:STEP_DRV],-1
  4919                                  		;jz	short Do_Writej
  4920 00001346 7459                    		jz	short DO_WRITE ; 14/06/2018
  4921                                  
  4922 00001348 80FC02                  		cmp	AH,ROMRead	; For read...
  4923 0000134B 7407                    		je	short DO_Fast	;   ... alway use fast
  4924                                  
  4925 0000134D 80FC04                  		cmp	AH, ROMVerify	; For verify...
  4926 00001350 7402                    		je	short DO_Fast	;   ... alway use fast
  4927                                  
  4928                                  Do_Writej:
  4929 00001352 EB4D                    		jmp	short DO_WRITE	; Jump down for write...
  4930                                  
  4931                                  DO_Fast:
  4932 00001354 E8AB00                  		CALL	FASTSPEED	; do I/O carry set if error
  4933                                  TestErr:
  4934 00001357 7262                    		jc	short DSKERR	; error -- get out
  4935                                  ; SET DRIVE AND TRACK OF LAST ACCESS
  4936 00001359 2E8816[6B00]            		mov	[CS:STEP_DRV],DL ; save the last drive accessed
  4937 0000135E 886D4C                  		mov	[DI+BDS.Track],CH ; save in BDS
  4938                                  
  4939                                  NO_SET:
  4940 00001361 2E813E[0401]0301        		cmp	word [CS:WRTVERIFY],103H ; Check for write and verify
  4941 00001368 7448                    		jz	short DOVERIFY	; yes -- go do verify
  4942                                  NOVERIFY:
  4943 0000136A 58                      		pop	AX		; pop command and num sec. from stack
  4944 0000136B 80E13F                  		and	CL,03FH		; Eliminate cylinder bits from sector
  4945 0000136E 30E4                    		xor	AH,AH
  4946 00001370 2E2906[0601]            		sub	[CS:SECCNT],AX	; Reduce count of sectors to go
  4947 00001375 00C1                    		add	CL,AL		; Next sector
  4948 00001377 2E880E[1401]            		mov	[CS:CURSEC],CL
  4949                                  					 ; See if sector/track limit reached
  4950 0000137C 3A4D13                  		cmp	CL,[DI+BDS.SECLIM]
  4951 0000137F 761E                    		jbe	short Disk_Ret	; yes, return
  4952                                  NextTrack:
  4953 00001381 2EC606[1401]01          		mov	byte [CS:CURSEC],1 ; Start with first sector of next track
  4954 00001387 2E8A36[1501]            		mov	DH,[CS:CURHD]
  4955 0000138C FEC6                    		inc	DH		; go to next head
  4956 0000138E 3A7515                  		cmp	DH,[DI+BDS.HDLIM] ; at head limit?
  4957 00001391 7207                    		jb	short NOXOR	; no, jump down
  4958 00001393 30F6                    		xor	DH,DH		; at head limit, reset to head zero ...
  4959 00001395 2EFF06[1601]            		inc	word [CS:CURTRK] ; 	and go to next head
  4960                                  NOXOR:
  4961 0000139A 2E8836[1501]            		mov	[CS:CURHD],DH	; save new head number
  4962                                  Disk_Ret:
  4963 0000139F F8                      		clc			; successful return so clear error flag
  4964 000013A0 C3                      		retn			; all done
  4965                                  
  4966                                  ;
  4967                                  ; The request is for write.  Determine if we are talking about the same
  4968                                  ; track and drive.  If so, use the fast speed.
  4969                                  ;
  4970                                  DO_WRITE:
  4971 000013A1 2E3A16[6B00]            		cmp	DL,[CS:STEP_DRV] ; same drive?
  4972 000013A6 7505                    		jnz	short DO_Norm 	 ; no, do normal speed
  4973 000013A8 3A6D4C                  		cmp	CH,[DI+BDS.Track] ; same track on drive
  4974 000013AB 74A7                    		jz	short DO_Fast	; yes, do fast speed
  4975                                  DO_Norm:
  4976 000013AD E83300                  		call	NORMSPEED	; use larger head settle time
  4977 000013B0 EBA5                    		jmp	SHORT TestErr	; test for error
  4978                                  
  4979                                  ;
  4980                                  ; we have a verify request also.  Get state info and go verify
  4981                                  ;
  4982                                  
  4983                                  DOVERIFY:
  4984 000013B2 58                      		pop	AX		; get number of sectors from stack
  4985 000013B3 50                      		push	AX		;    in non-detructive fashion
  4986 000013B4 B404                    		MOV	AH,ROMVerify	; REQUEST VERIFY
  4987 000013B6 E84900                  		CALL	FASTSPEED	; MZ  2.21 change settle mode
  4988 000013B9 73AF                    		JNC	short NOVERIFY
  4989                                  
  4990                                  ;
  4991                                  ; Need to special case the change-line error AH=06h.  If we get this, we
  4992                                  ; need to return it.
  4993                                  ;
  4994                                  	;----------------------------------------|
  4995                                  	; Warning: Do not change the following. ;|
  4996                                  	;	   It gets patched in msinit	;|
  4997                                  						;|
  4998                                  DSKERR:						;|
  4999 000013BB E8AA08                  		CALL	CheckIO 		;|
  5000                                  	;---------------------------------------;|
  5001                                  
  5002 000013BE E86604                  		Call	AGAIN	; reset the disk and decrement retry cnt
  5003 000013C1 7409                    		jz	short HARDERR ; if z flag set, did all retries-give up
  5004 000013C3 80FC80                  		cmp	AH,80H		; timeout?
  5005 000013C6 7404                    		jz	short HARDERR ; yes, jump to hard error
  5006                                  DSKERR1:
  5007 000013C8 58                      		pop	AX		; Restore sector count
  5008 000013C9 E943FF                  		jmp	RETRY		;     and try again
  5009                                  
  5010                                  HARDERR:
  5011 000013CC E84100                  		CALL	MAPERROR
  5012                                  
  5013                                  HARDERR2:			; for routines that call MapError themselves
  5014 000013CF 2EC606[FF00]FF          		mov	byte [CS:TIM_DRV],-1 ;Force a media check through ROM
  5015 000013D5 2E8B0E[0601]            		mov	CX,[CS:SECCNT]	;Get count of sectors to go
  5016 000013DA 2E8B26[1801]            		mov	SP,[CS:SPSAV]	;Recover entry stack pointer
  5017                                  ;
  5018                                  ; Since we are performing a non-local goto, restore the disk parameters
  5019                                  ;
  5020                                  MedByt_OK:
  5021 000013DF E8CEFE                  		call	DiddleBack
  5022 000013E2 C3                      		retn			;and return
  5023                                  
  5024                                  ;
  5025                                  ; change settle value from SettleCurrent to whatever is appropriate
  5026                                  ;
  5027                                  NORMSPEED:
  5028 000013E3 1E                      		push	DS		; save two registers
  5029 000013E4 50                      		push	AX
  5030                                  				; change value in current disk parm tbl
  5031 000013E5 2EA0[0B01]              		mov	AL,[CS:SettleSlow] 
  5032 000013E9 2EC536[1001]            		lds	SI,[CS:DPT]	; current disk parm table
  5033 000013EE 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  5034 000013F1 58                      		pop	AX		; restore command and sector count
  5035 000013F2 1F                      		pop	DS
  5036 000013F3 E80C00                  		call	FASTSPEED	; do I/0
  5037 000013F6 1E                      		push	DS	; restore the value in disk parm table
  5038 000013F7 2EC536[1001]            		lds	SI,[CS:DPT]
  5039 000013FC C6440901                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],1 ; 1 is fast settle
  5040 00001400 1F                      		pop	DS
  5041 00001401 C3                      		retn
  5042                                  
  5043                                  FASTSPEED:
  5044                                  ;
  5045                                  ; If the drive has been marked as too big (i.e. starting sector of the
  5046                                  ; partition is > 16 bits, then ALWAYS return drive not ready.
  5047                                  ;
  5048 00001402 F6451980                		TEST	BYTE [DI+BDS.FatSiz],fTOOBIG
  5049 00001406 7503                    		JNZ	short NotReady
  5050                                  
  5051 00001408 CD13                    		int	13h		; call rom-bios disk routines
  5052                                  Death:
  5053 0000140A C3                      		retn
  5054                                  NotReady:
  5055 0000140B F9                      		stc			; set carry to indicate error
  5056 0000140C B480                    		mov	AH,80h		; put error code in AH
  5057 0000140E EBFA                    		jmp	short Death	; jump to ret
  5058                                  
  5059                                  ;
  5060                                  ; Map error returned by ROM into corresponding code to be returned to
  5061                                  ; DOS in AL.
  5062                                  ;
  5063                                  MAPERROR:
  5064 00001410 51                      		push	CX		; save cx
  5065 00001411 0E                      		push	CS
  5066 00001412 07                      		pop	ES		; make ES the local segment
  5067 00001413 88E0                    		mov	AL,AH		; move error code into AL
  5068 00001415 2EA2[2601]              		mov	[CS:LSTERR],AL	; terminate list with error code
  5069 00001419 B90800                  		mov	CX,NUMERR	; number of possible error conditions
  5070 0000141C BF[1F01]                		mov	DI,ERRIN	; point to error conditions
  5071 0000141F F2AE                    		repne	SCASB
  5072 00001421 2E8A4507                		mov	AL,[CS:DI+NUMERR-1] ; get translation
  5073 00001425 59                      		pop	cx		; restore cx
  5074 00001426 F9                      		stc			; flag error condition
  5075 00001427 C3                      		retn
  5076                                  
  5077                                  ;
  5078                                  ; Set the time of last access for this drive. This is done only for removable
  5079                                  ; media.
  5080                                  ;
  5081                                  SET_TIM:
  5082 00001428 50                      		push	ax
  5083 00001429 30E4                    		xor	AH, AH		; set command to get time
  5084 0000142B CD1A                    		int	1Ah		; call rom-bios timer function
  5085 0000142D 08C0                    		or	AL,AL		; is there 24 hour rollover?
  5086 0000142F 7405                    		jz	short NOROLL3 	; no, skip down
  5087 00001431 2EFF06[8804]            		inc	word [CS:DAYCNT] ; yes, then increment DayCnt
  5088                                  NOROLL3:
  5089                                  ; We have the new time. If we see that the time has passed, then we reset
  5090                                  ; the threshold counter...
  5091 00001436 3B554D                  		cmp	DX,[DI+BDS.TIM_LO] ; Did any time pass?
  5092 00001439 7505                    		jnz	short SetAccess	; yes, update access time
  5093 0000143B 3B4D4F                  		cmp	CX,[DI+BDS.TIM_HI] ; now look at the high bits
  5094 0000143E 740C                    		jz	short Done_Set	; if equal then no time passed
  5095                                  SetAccess:				; we get here if some time has passed
  5096                                  					; zero AccessCount to show time passage
  5097 00001440 2EC606[FE00]00          		mov	byte [CS:AccessCount],0
  5098 00001446 89554D                  		MOV	[DI+BDS.TIM_LO],DX ; save low time bits
  5099 00001449 894D4F                  		MOV	[DI+BDS.TIM_HI],CX ; save high time bit
  5100                                  Done_Set:
  5101 0000144C F8                      		clc			; indicate no error
  5102 0000144D 58                      		pop	ax		; restore AX register
  5103 0000144E C3                      		retn
  5104                                  
  5105                                  
  5106                                  ; include msioctl.inc
  5107                                  
  5108                                  ;-----------------------------------------------------------------------------
  5109                                  ; include msioctl.inc - MSDOS 3.3 - MSDISK.ASM - 02/02/1988
  5110                                  ;-----------------------------------------------------------------------------
  5111                                  ; 24/03/2018 - Retro DOS v2.0
  5112                                  
  5113                                  		; include ioctl.inc
  5114                                  
  5115                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  5116                                  ; ............................................................................
  5117                                  
  5118                                  ;*** J.K.
  5119                                  ;General Guide -
  5120                                  ;Category Code:
  5121                                  ; 0... .... DOS Defined
  5122                                  ; 1... .... User defined
  5123                                  ; .xxx xxxx Code
  5124                                  
  5125                                  ;Function Code:
  5126                                  ; 0... .... Return error if unsupported
  5127                                  ; 1... .... Ignore if unsupported
  5128                                  ; .0.. .... Intercepted by DOS
  5129                                  ; .1.. .... Passed to driver
  5130                                  ; ..0. .... Sends data/commands to device
  5131                                  ; ..1. .... Quries data/info from device
  5132                                  ; ...x .... Subfunction
  5133                                  ;
  5134                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  5135                                  ; function set.  It plays no critical role; some functions may contain both
  5136                                  ; command and query elements. The convention is that such commands are
  5137                                  ; defined as "sends data".
  5138                                  
  5139                                  ;*****************************;*
  5140                                  ; BLOCK DRIVERS 	      ;*
  5141                                  ;*****************************;*
  5142                                  
  5143                                  ; IOCTL SUB-FUNCTIONS
  5144                                  IOCTL_GET_DEVICE_INFO	EQU	0
  5145                                  IOCTL_SET_DEVICE_INFO	EQU	1
  5146                                  IOCTL_READ_HANDLE	EQU	2
  5147                                  IOCTL_WRITE_HANDLE	EQU	3
  5148                                  IOCTL_READ_DRIVE	EQU	4
  5149                                  IOCTL_WRITE_DRIVE	EQU	5
  5150                                  IOCTL_GET_INPUT_STATUS	EQU	6
  5151                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  5152                                  IOCTL_CHANGEABLE?	EQU	8
  5153                                  IOCTL_DeviceLocOrRem?	EQU	9
  5154                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  5155                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  5156                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  5157                                  GENERIC_IOCTL		EQU	0Dh   ;13
  5158                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  5159                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  5160                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  5161                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  5162                                  
  5163                                  ; GENERIC IOCTL SUB-FUNCTIONS
  5164                                  RAWIO			EQU	8
  5165                                  
  5166                                  ; RAWIO SUB-FUNCTIONS
  5167                                  GET_DEVICE_PARAMETERS	EQU	60H
  5168                                  SET_DEVICE_PARAMETERS	EQU	40H
  5169                                  READ_TRACK		EQU	61H
  5170                                  WRITE_TRACK		EQU	41H
  5171                                  VERIFY_TRACK		EQU	62H
  5172                                  FORMAT_TRACK		EQU	42H
  5173                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  5174                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  5175                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  5176                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  5177                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  5178                                  
  5179                                  
  5180                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  5181                                  BUILD_DEVICE_BPB	EQU	000000001B
  5182                                  
  5183                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  5184                                  INSTALL_FAKE_BPB	EQU	000000001B
  5185                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  5186                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  5187                                  
  5188                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  5189                                  STATUS_FOR_FORMAT	EQU	000000001B
  5190                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  5191                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  5192                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  5193                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  5194                                  
  5195                                  ; DEVICETYPE VALUES
  5196                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  5197                                  DEV_5INCH		EQU	0
  5198                                  DEV_5INCH96TPI		EQU	1
  5199                                  DEV_3INCH720KB		EQU	2
  5200                                  DEV_8INCHSS		EQU	3
  5201                                  DEV_8INCHDS		EQU	4
  5202                                  DEV_HARDDISK		EQU	5
  5203                                  DEV_OTHER		EQU	7
  5204                                  ;DEV_3INCH1440KB	EQU	7
  5205                                  DEV_3INCH2880KB		EQU	9
  5206                                  ; Retro DOS v2.0 - 26/03/2018
  5207                                  ;;DEV_TAPE		EQU	6
  5208                                  ;;DEV_ERIMO		EQU	8
  5209                                  ;DEV_3INCH2880KB	EQU	9
  5210                                  DEV_3INCH1440KB		EQU	10
  5211                                  
  5212                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
  5213                                  					; CURRENTLY SUPPORT.
  5214                                  MAX_DEV_TYPE		EQU	10
  5215                                  
  5216                                  struc A_SECTORTABLE
  5217 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  5218 00000002 ????                    .ST_SECTORSIZE:		resw	1
  5219                                  .size:
  5220                                  endstruc
  5221                                  
  5222                                  ; MSDOS 6.0 - BPB.INC - 1991
  5223                                  ; ####
  5224                                  ;**	BIOS PARAMETER BLOCK DEFINITION
  5225                                  ;
  5226                                  ;	The BPB contains information about the disk structure. It dates
  5227                                  ;	back to the earliest FAT systems and so FAT information is
  5228                                  ;	intermingled with physical driver information.
  5229                                  ;
  5230                                  ;	A boot sector contains a BPB for its device; for other disks
  5231                                  ;	the driver creates a BPB. DOS keeps copies of some of this
  5232                                  ;	information in the DPB.
  5233                                  ;
  5234                                  ;	The BDS structure contains a BPB within it.
  5235                                  ;
  5236                                  
  5237                                  struc A_BPB
  5238 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
  5239 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
  5240 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
  5241 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
  5242 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
  5243 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
  5244 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
  5245 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
  5246 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
  5247 0000000F ????                    .BPB_HEADS:		resw	1
  5248 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
  5249 00000013 ????                    			resw	1
  5250 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
  5251 00000017 ????                    			resw	1
  5252 00000019 ????????????            			resb	6	; NOTE:  many times these
  5253                                  ;					; 	 6 bytes are omitted
  5254                                  ;					;	 when BPB manipulations
  5255                                  ;					;	 are performed!
  5256                                  .size:
  5257                                  endstruc
  5258                                  ; ####
  5259                                  
  5260                                  struc A_DEVICEPARAMETERS
  5261 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
  5262 00000001 ??                      .DP_DEVICETYPE:		resb	1
  5263 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
  5264 00000004 ????                    .DP_CYLINDERS:		resw	1
  5265 00000006 ??                      .DP_MEDIATYPE:		resb	1
  5266 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
  5267 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
  5268 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  5269                                  endstruc
  5270                                  
  5271                                  struc A_TRACKREADWRITEPACKET
  5272 00000000 ??                      .TRWP_SPECIALFUNCTIONS:	resb	1
  5273 00000001 ????                    .TRWP_HEAD:		resw	1
  5274 00000003 ????                    .TRWP_CYLINDER:		resw	1
  5275 00000005 ????                    .TRWP_FIRSTSECTOR:	resw	1
  5276 00000007 ????                    .TRWP_SECTORSTOREADWRITE: resw	1
  5277 00000009 ????????                .TRWP_TRANSFERADDRESS:	resd	1
  5278                                  endstruc
  5279                                  
  5280                                  ;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
  5281                                  struc A_FORMATPACKET
  5282 00000000 ??                      .FP_SPECIALFUNCTIONS:	resb	1  ; db ?
  5283 00000001 ????                    .FP_HEAD: 		resw	1  ; dw ? 
  5284 00000003 ????                    .FP_CYLINDER:		resw	1  ; dw ?
  5285 00000005 ????                    .FP_TRACKCOUNT:		resw	1  ; dw 1 ; !
  5286                                  endstruc
  5287                                  
  5288                                  struc A_VERIFYPACKET
  5289 00000000 ??                      .VP_SPECIALFUNCTIONS:	resb	1
  5290 00000001 ????                    .VP_HEAD: 		resw	1
  5291 00000003 ????                    .VP_CYLINDER:		resw	1
  5292                                  endstruc
  5293                                  
  5294                                  struc A_MEDIA_ID_INFO
  5295 00000000 ????                    .MI_LEVEL:		resw	1  ; dw 0 ; !		;J.K. 87 Info. level
  5296 00000002 ????????                .MI_SERIAL:		resd	1  ; dd ?		;J.K. 87 Serial #
  5297 00000006 <res Bh>                .MI_LABEL:		resb	11 ; db 11 DUP (' ') ;!	;J.K. 87 volume label
  5298 00000011 ????????????????        .MI_SYSTEM:		resb 	8  ; db 8 DUP (' ')  ;!	;J.K. 87 File system type
  5299                                  endstruc
  5300                                  
  5301                                  struc A_DISKACCESS_CONTROL	   ;AN002; Unpublished function. Only for Hard file.
  5302 00000000 ??                      .DAC_SPECIALFUNCTIONS:	resb 	1  ; db 0 ; ! ;AN002; Always 0
  5303 00000001 ??                      .DAC_ACCESS_FLAG: 	resb 	1  ; db 0 ; ! 
  5304                                  				   ; Non Zero - allow disk I/O to unformatted hard file
  5305                                  endstruc			   ; 0 - Disallow disk I/O to unformatted hard file
  5306                                  
  5307                                  
  5308                                  struc A_MEDIA_SENSE			; Media sense structure added 5.00
  5309 00000000 ??                      .MS_ISDEFAULT:		resb	1	; If 1 type returned is drv default
  5310 00000001 ??                      .MS_DEVICETYPE:		resb	1	; Drive type 
  5311 00000002 ??                      .MS_RESERVED1:		resb	1	; RESERVED
  5312 00000003 ??                      .MS_RESERVED2:		resb 	1	; RESERVED 
  5313                                  endstruc
  5314                                  
  5315                                  ;********************************;*
  5316                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  5317                                  ;********************************;*
  5318                                  
  5319                                  ;RAWIO SUB-FUNCTIONS
  5320                                  GET_RETRY_COUNT 	EQU	65H
  5321                                  SET_RETRY_COUNT 	EQU	45H
  5322                                  
  5323                                  struc A_RETRYCOUNT
  5324 00000000 ????                    .RC_COUNT:		resw 1
  5325                                  endstruc
  5326                                  
  5327                                  ;********************************;*		;J.K. 4/29/86
  5328                                  ; CHARACTER DEVICES (SCREEN)	 ;*
  5329                                  ;********************************;*		;J.K. 4/29/86
  5330                                  ;
  5331                                  ;SC_MODE_INFO	 struc
  5332                                  ;SC_INFO_LENGTH 	 DW	 9
  5333                                  ;SC_MODE		 DB	 0
  5334                                  ;SC_COLORS		 DW	 0
  5335                                  ;SC_WIDTH		 DW	 0
  5336                                  ;SC_LENGTH		 DW	 0
  5337                                  ;SC_MODE_INFO	 ends
  5338                                  ;
  5339                                  ;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.
  5340                                  
  5341                                  ;SUBFUNCTIONS FOR CON$GENIOCTL
  5342                                  ;GET_SC_MODE		 EQU	 60h
  5343                                  ;SET_SC_MODE		 EQU	 40h
  5344                                  ;The following subfunctions are reserved for installable CODE PAGE switch
  5345                                  ;console devices. - J.K. 4/29/86
  5346                                  ;Get_active_codepage	 equ	 6Ah
  5347                                  ;Invoke_active_codepage  equ	 4Ah
  5348                                  ;Start_designate_codepage equ	 4Ch
  5349                                  ;End_designate_codepage  equ	 4Dh
  5350                                  ;Get_list_of_designated_codepage equ 6Bh
  5351                                  ;J.K. 4/29/86 *** End of Con$genioctl equates & structures
  5352                                  
  5353                                  ; 28/05/2018 - Retro DOS v3.0
  5354                                  
  5355                                  ; 29/06/2019 - Retro DOS v3.1
  5356                                  
  5357                                  ; -----------------------------------------------------------------
  5358                                  ;
  5359                                  ; Generic IOCTL dispatch tables
  5360                                  ;
  5361                                  ; -----------------------------------------------------------------
  5362                                  
  5363                                  IOReadJumpTable: 
  5364 0000144F 02                      		db	2		;maximum number (zero based)
  5365 00001450 [9914]                  		dw	GetDeviceParameters
  5366 00001452 [0817]                  		dw	ReadTrack
  5367 00001454 [E316]                  		dw	VerifyTrack
  5368                                  
  5369                                  IOWriteJumpTable:
  5370 00001456 02                      		db	2		;maximum number (zero based)
  5371 00001457 [D514]                  		dw	SetDeviceParameters
  5372 00001459 [1017]                  		dw	WriteTrack
  5373 0000145B [9615]                  		dw	FormatTrack
  5374                                  ; -----------------------------------------------------------------
  5375                                  ;
  5376                                  ; Generic$IOCTL:
  5377                                  ;    Perform Generic IOCTL request
  5378                                  ;    Input:
  5379                                  ;	al	- unit number
  5380                                  ;    Output:
  5381                                  ;	if carry set then al contains error code
  5382                                  ;
  5383                                  ; -----------------------------------------------------------------
  5384                                  
  5385                                  GENERIC$IOCTL:
  5386 0000145D 2EC41E[0A00]            		les	bx,[cs:PTRSAV]		; es:bx points to request header.
  5387 00001462 E844FA                  		call	SETDRIVE		; ds:di points to BDS for drive.
  5388                                  ;
  5389                                  ; At this point:
  5390                                  ;    es:bx - points to the Request Header
  5391                                  ;    ds:di points to the BDS for the drive
  5392                                  ;
  5393 00001465 26807F0D08              		cmp	byte [es:bx+IOCTL_REQ.MAJORFUNCTION],RAWIO
  5394 0000146A 752A                    		jne	IOCTL_Func_Err
  5395 0000146C 268A470E                		mov	al,[es:bx+IOCTL_REQ.MINORFUNCTION]
  5396 00001470 BE[4F14]                		mov	si,IOReadJumpTable
  5397 00001473 A820                    		test	al,GEN_IOCTL_FN_TST	; Test of req. function
  5398 00001475 7503                    		jnz	short NotGenericIoctlWrite	;   function is a Read.
  5399 00001477 BE[5614]                		mov	si,IOWriteJumpTable
  5400                                  NotGenericIoctlWrite:
  5401 0000147A 240F                    		and	al,0FH
  5402 0000147C 2E3A04                  		cmp	al,[cs:si]
  5403 0000147F 7715                    		ja	short IOCTL_Func_Err
  5404 00001481 98                      		cbw
  5405 00001482 D1E0                    		shl	ax, 1
  5406 00001484 46                      		inc	si
  5407 00001485 01C6                    		add	si,ax
  5408 00001487 26C45F13                		les	bx,[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
  5409 0000148B 2EFF14                  		call	[cs:si]
  5410 0000148E 7203                    		jc	short FailGeneric$IOCTL
  5411 00001490 E963F2                  		jmp	EXIT
  5412                                  
  5413                                  FailGeneric$IOCTL:
  5414 00001493 E953F2                  		jmp	ERR$EXIT
  5415                                  
  5416                                  IOCTL_Func_Err:
  5417 00001496 E946F2                  		jmp	CMDERR
  5418                                  
  5419                                  ; -----------------------------------------------------------------
  5420                                  ;
  5421                                  ; GetDeviceParameters:
  5422                                  ;
  5423                                  ; Input: DS:DI points to BDS for drive
  5424                                  ;	 ES:BX points to device parameter packet
  5425                                  ;
  5426                                  ; -----------------------------------------------------------------
  5427                                  
  5428                                  GetDeviceParameters:
  5429                                  ; Copy info from BDS to the device parameters packet
  5430 00001499 8A4528                  		mov	al,[DI+BDS.FormFactor]
  5431 0000149C 26884701                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE], al
  5432 000014A0 8B4529                  		mov	ax,[DI+BDS.Flags]
  5433 000014A3 83E003                  		and	ax,fNon_Removable+fChangeline	; mask off other bits
  5434 000014A6 26894702                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES], ax
  5435 000014AA 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5436 000014AD 26894704                		mov	[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS], ax
  5437                                  
  5438                                  ; Set media type to default
  5439 000014B1 30C0                    		xor	al, al
  5440 000014B3 26884706                		mov	[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE],al
  5441                                  
  5442                                  ; Copy recommended BPB
  5443 000014B7 8D752D                  		lea	si, [DI+BDS.RBytePerSec]
  5444                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],BUILD_DEVICE_BPB
  5445 000014BA 26F60701                		test	byte [es:bx],BUILD_DEVICE_BPB ; 05/07/2019
  5446 000014BE 740B                    		jz	short use_BPB_present
  5447                                  ; Get the correct disk in the drive
  5448 000014C0 E8AEFC                  		call	CHECKSINGLE
  5449                                  ; Build the BPB from scratch
  5450 000014C3 E8EAFA                  		call	GETBP
  5451 000014C6 720C                    		jc	short Get_Parm_Ret
  5452 000014C8 8D7506                  		lea	si,[DI+BDS.BytePerSec]
  5453                                  use_BPB_present:
  5454 000014CB 8D7F07                  		lea	di,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5455 000014CE B91300                  		mov	cx,BPB_TYPE.size	; for now use 'small' BPB
  5456 000014D1 F3A4                    		rep	movsb
  5457 000014D3 F8                      		clc
  5458                                  Get_Parm_Ret:
  5459 000014D4 C3                      		retn
  5460                                  
  5461                                  ; -----------------------------------------------------------------
  5462                                  ;
  5463                                  ; SetDeviceParameters:
  5464                                  ;
  5465                                  ; Input: DS:DI points to BDS for drive
  5466                                  ;	 ES:BX points to device parameter packet
  5467                                  ;
  5468                                  ; -----------------------------------------------------------------
  5469                                  
  5470                                  SetDeviceParameters:
  5471                                  
  5472                                  ; Make sure the fChanged_By_Format flag gets set to kick DOS into looking at
  5473                                  ; the BPB
  5474 000014D5 814D294001              		or	word [DI+BDS.Flags],fChanged_By_Format | fChanged
  5475                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],ONLY_SET_TRACKLAYOUT
  5476 000014DA 26F60702                		test	byte [es:bx],ONLY_SET_TRACKLAYOUT ; 05/07/2019
  5477                                  		;jz	short SetDevParm_1
  5478                                  		;jmp	short SetTrackTable		; Originally TrackLayout
  5479 000014DE 756D                    		jnz	short SetTrackTable ; 05/07/2019 - Retro DOS v3.1
  5480                                  SetDevParm_1:
  5481                                  ; Copy info from the device parameters packet to BDS
  5482 000014E0 268A4701                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5483 000014E4 884528                  		mov	[DI+BDS.FormFactor], al
  5484                                  
  5485 000014E7 268B4704                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
  5486 000014EB 89452B                  		mov	[DI+BDS.cCyln],ax
  5487                                  
  5488                                  ; If change line is not loaded then ignore changeling flag
  5489 000014EE 268B4702                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
  5490 000014F2 2E803E[6D00]00          		cmp	byte [cs:fHave96],0
  5491 000014F8 7503                    		jnz	short Have_Change
  5492 000014FA 83E0FD                  		and	ax,~fChangeline
  5493                                  Have_Change:
  5494                                  ; ignore all bits except Non_removable and Changeline
  5495 000014FD 83E003                  		and	ax,fNon_Removable | fChangeline
  5496 00001500 8B4D29                  		mov	cx,[DI+BDS.Flags]
  5497 00001503 83E1F4                  		and	cx,~(fNon_Removable | fChangeline | GOOD_TRACKLAYOUT)
  5498 00001506 09C8                    		or	ax,cx
  5499 00001508 894529                  		mov	[DI+BDS.Flags],ax
  5500                                  
  5501                                  ; Set media type
  5502 0000150B 268A4706                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
  5503 0000150F 2EA2[9B05]              		mov	[cs:mediaType],al
  5504                                  ; the media changed (maybe) so we will have to do a SetDASD the next time
  5505                                  ; we format a track
  5506 00001513 814D298000              		or	word [DI+BDS.Flags],SET_DASD_true
  5507                                  
  5508 00001518 1E                      		push	ds
  5509 00001519 57                      		push	di
  5510 0000151A 06                      		push	es
  5511 0000151B 53                      		push	bx
  5512                                  ; Figure out what we are supposed to do with the BPB
  5513                                  
  5514                                  ; Were we asked to install a fake BPB?
  5515                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],INSTALL_FAKE_BPB
  5516 0000151C 26F60701                		test	byte [es:bx],INSTALL_FAKE_BPB ; 05/07/2019
  5517 00001520 7515                    		jnz	short InstallFakeBPB
  5518                                  
  5519                                  ; Were we returning a fake BPB when asked to build a BPB?
  5520 00001522 F745290400              		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  5521 00001527 7406                    		jz	short InstallRecommendedBPB
  5522                                  
  5523                                  ; We were returning a fake BPB but we can stop now
  5524 00001529 836529FB                		and	word[DI+BDS.Flags],~RETURN_FAKE_BPB
  5525 0000152D EB17                    		jmp	short DoneWithBPBstuff
  5526                                  
  5527                                  InstallRecommendedBPB:
  5528 0000152F B91F00                  		mov	cx,A_BPB.size
  5529 00001532 8D7D2D                  		lea	di,[DI+BDS.RBytePerSec]
  5530 00001535 EB06                    		jmp	short CopyTheBPB
  5531                                  
  5532                                  InstallFakeBPB:
  5533 00001537 B91300                  		mov	cx,BPB_TYPE.size    ; move 'smaller' BPB
  5534 0000153A 8D7D06                  		lea	di,[DI+BDS.BytePerSec]
  5535                                  CopyTheBPB:
  5536 0000153D 8D7707                  		lea	si,[bx+A_DEVICEPARAMETERS.DP_BPB]
  5537                                  ; exchange es and ds
  5538 00001540 06                      		push	es
  5539 00001541 1E                      		push	ds
  5540 00001542 07                      		pop	es
  5541 00001543 1F                      		pop	ds
  5542                                  
  5543 00001544 F3A4                    		rep	movsb
  5544                                  
  5545                                  DoneWithBPBstuff:
  5546 00001546 E8AD03                  		call	RestoreOldDPT
  5547 00001549 5B                      		pop	bx
  5548 0000154A 07                      		pop	es
  5549 0000154B 5F                      		pop	di
  5550 0000154C 1F                      		pop	ds
  5551                                  
  5552                                  ; Set up track table (if neccessary)
  5553                                  SetTrackTable:
  5554 0000154D 268B4F26                		mov	cx,[es:bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
  5555 00001551 2E890E[9905]            		mov	[cs:SectorsPerTrack],cx
  5556 00001556 836529F7                		and	word [DI+BDS.Flags],~GOOD_TRACKLAYOUT
  5557                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],TRACKLAYOUT_IS_GOOD
  5558 0000155A 26F60704                		test	byte [es:bx],TRACKLAYOUT_IS_GOOD ; 05/07/2019
  5559 0000155E 7404                    		jz	short UglyTrackLayout
  5560 00001560 834D2908                		or	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  5561                                  
  5562                                  UglyTrackLayout:
  5563 00001564 83F93F                  		cmp	cx,MAX_SECTORS_IN_TRACK
  5564 00001567 7729                    		ja	short TooManySectorsPerTrack
  5565 00001569 E325                    		jcxz	SectorInfoSaved		; if no value don't copy table
  5566                                  						; save information in the track table
  5567                                  
  5568 0000156B 53                      		push    BX			; get ES:BX to point to sector
  5569 0000156C 83C328                  		add     BX,A_DEVICEPARAMETERS.DP_SECTORTABLE ;  table in Device param. struct
  5570                                  	
  5571 0000156F 57                      		push    DI
  5572 00001570 BF[9F04]                		mov     DI,TrackTable + 2	; CS:DI now points to sector id
  5573                                                                                  ; of the first track table entry
  5574 00001573 50                      		push    AX			; preserve AX value
  5575                                  
  5576                                                                                  ; For MAX_SECTORS_IN_TRACK
  5577                                  TrackLoop:                                      ;   DO:
  5578 00001574 268B07                  		mov     AX,[ES:BX]		;   get sector number
  5579 00001577 2E8805                  		mov	[CS:DI],AL		;   save in track table
  5580                                  
  5581 0000157A 268B4702                	        mov     AX,[ES:BX+2]		;   get sector size
  5582 0000157E E83602                  	        call    SectorSizeToSectorIndex ;   convert size to index number
  5583 00001581 2E884501                		mov     [CS:DI+1],AL		;   save size in track table
  5584                                  
  5585 00001585 83C304                  		add     BX,A_SECTORTABLE.size	;   advance pointers to next
  5586 00001588 83C704                  		add     DI,A_SECTORTABLE.size	;   entries
  5587 0000158B E0E7                    		loopnz  TrackLoop		; End FOR
  5588                                  
  5589 0000158D 58                      		pop     AX 			; restore the saved values
  5590 0000158E 5F                      		pop     DI
  5591 0000158F 5B                      		pop     BX
  5592                                  
  5593                                  SectorInfoSaved:
  5594 00001590 F8                      		clc
  5595 00001591 C3                      		retn
  5596                                  
  5597                                  TooManySectorsPerTrack:
  5598 00001592 B00C                    		mov	al, 0Ch
  5599 00001594 F9                      		stc
  5600 00001595 C3                      		retn
  5601                                  
  5602                                  ; ---------------------------------------------------------------------------
  5603                                  ;
  5604                                  ; FormatTrack:
  5605                                  ; If SpecialFunction byte is 1, then this is a status call to see if there is
  5606                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5607                                  ; combination is legal. If SpecialFunction byte is 0, then format the track.
  5608                                  ;
  5609                                  ; Input: DS:DI points to BDS for drive
  5610                                  ;        ES:BX points to format packet
  5611                                  ;
  5612                                  ; Output:
  5613                                  ;       For status call:
  5614                                  ;       SpecialFunction byte set to:
  5615                                  ;               0 - ROM support + legal combination
  5616                                  ;               1 - No ROM support
  5617                                  ;               2 - Illegal Combination
  5618                                  ;		3 - no media present			;Rev 3.30
  5619                                  ;       Carry cleared.
  5620                                  ;
  5621                                  ;       For format track:
  5622                                  ;               Carry set if error
  5623                                  ;
  5624                                  ;
  5625                                  ;  Flags also may be altered. All other registers preserved.
  5626                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5627                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5628                                  ;  to the one returned. The original pointer to the disk base table is stored
  5629                                  ;  in TempDPT, until it is restored.
  5630                                  ;
  5631                                  ;  This proc was changed to force a status for format call if we are on the
  5632                                  ;  new ROM.
  5633                                  ;
  5634                                  ; ---------------------------------------------------------------------------
  5635                                  
  5636                                  FormatTrack:
  5637                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],STATUS_FOR_FORMAT
  5638 00001596 26F60701                		test	byte [es:bx],STATUS_FOR_FORMAT ; 05/07/2019
  5639 0000159A 7408                    		jz	short SkipStatusOnly
  5640                                  
  5641                                  Do_Status_Only:
  5642 0000159C E89900                  		call	FormatStatus
  5643                                  		;mov	[es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],al
  5644 0000159F 268807                  		mov	[es:bx],al ; 05/07/2019
  5645                                  		;clc
  5646 000015A2 F8                      		clc	; 05/07/2019 - Retro DOS v3.1 (CF=1 is possible from 'FormatStatus')
  5647 000015A3 C3                      		retn
  5648                                  	
  5649                                  SkipStatusOnly:                       ; for a hard disk only do the verify
  5650 000015A4 807D2805                        	cmp     byte [DI+BDS.FormFactor],DEV_HARDDISK
  5651 000015A8 7503                    		jnz	short SkipVerify
  5652 000015AA E98700                  		jmp	DoVerifyTrack
  5653                                  SkipVerify:
  5654 000015AD 1E                      		push	ds			; Format a Track
  5655 000015AE 57                      		push	di
  5656 000015AF 06                      		push	es
  5657 000015B0 53                      		push	bx
  5658 000015B1 E88400                  		call	FormatStatus		; SetDASD checks media_set_for_format
  5659                                  		;;14/06/2018 (IBMDOS 3.3,IBMBIO.COM)
  5660                                  		;cmp	al,1
  5661                                  		;je	short NeedToSetDasd
  5662 000015B4 3C03                    		cmp	al,3			; Check for time out
  5663                                  		;jne	short NoSetDasd
  5664 000015B6 745D                    		je	short Format_Failed	; Fail if time out
  5665                                  		;jmp	short Format_Failed
  5666                                  NeedToSetDasd:
  5667 000015B8 E81202                          	call    SetDASD
  5668                                  ;
  5669                                  ; Store Cylinder,Head in track table
  5670                                  ;                       ***** ASSUMPTION *******
  5671                                  ;       Since format requests on Fixed Media are converted to Verifies, we
  5672                                  ;       assume that we are formatting a floppy and hence have 255 or less
  5673                                  ;       tracks and heads. We therefore must change the Cylinder, Head data
  5674                                  ;       from the Request Packet Size to that of the TrackTable (see Int 13
  5675                                  ;       interface in IBM's Tech Ref.).
  5676                                  
  5677                                  ; Check to ensure correct disk is in drive
  5678                                  NoSetDasd:
  5679 000015BB E8B3FB                  		call    CHECKSINGLE
  5680                                  
  5681 000015BE 268B4703                		mov     ax,[es:bx+A_FORMATPACKET.FP_CYLINDER]
  5682 000015C2 2EA3[1C01]              		mov     [cs:TRKNUM],ax
  5683 000015C6 268B4F01                		mov     cx,[es:bx+A_FORMATPACKET.FP_HEAD]
  5684 000015CA 2E880E[1B01]            		mov     [cs:HDNUM],cl
  5685 000015CF 88CC                    		mov     ah,cl
  5686                                                          ; this next piece of code copies the correct head
  5687                                                          ; and cylinder numbers to the tracktable
  5688 000015D1 57                      		push    di			; preserve DI
  5689 000015D2 BF[9D04]                		mov     di,TrackTable
  5690 000015D5 2E8B0E[9905]            		mov     CX,[cs:SectorsPerTrack] ; get number of sectors
  5691 000015DA E308                            	jcxz    EndSetUpTrackTable	; if nothing to do skip down
  5692                                  SetUpLoop:
  5693 000015DC 2E8905                  		mov     [cs:di],AX		; set head and track value
  5694 000015DF 83C704                  		add     di,4			; move to next entry
  5695 000015E2 E0F8                    		loopnz  SetUpLoop		; loop if not done yet
  5696                                  EndSetUpTrackTable:
  5697 000015E4 5F                              	pop     di			; restore DI (BDS pointer)
  5698 000015E5 B90500                          	mov     cx,MAXERR		; Set up retry count
  5699                                  FormatRetry:
  5700 000015E8 51                      		push    cx
  5701                                                                  		; set up registers for format call to TO_ROM
  5702 000015E9 2EA1[9905]              		mov     AX,[CS:SectorsPerTrack]	; set number of sectors
  5703 000015ED B405                    		mov     AH,ROMFormat
  5704 000015EF 0E                      		push    cs			; set ES:BX to point to
  5705 000015F0 07                      		pop     es			;    the track table
  5706 000015F1 BB[9D04]                		mov     BX,TrackTable
  5707                                                                                  ; don't need to set CL on format
  5708 000015F4 E84202                  		call    To_ROM
  5709 000015F7 59                      		pop	cx
  5710 000015F8 7330                    		jnc	short FormatOk
  5711                                  		;pop     cx
  5712 000015FA 2EC606[9D05]01          		mov	byte [cs:Had_Format_Error],1	; Mark the error
  5713 00001600 50                      		push	ax		
  5714 00001601 51                      		push	cx			
  5715 00001602 52                      		push	dx
  5716 00001603 E82602                  		call    ResetDisk
  5717 00001606 E82F00                  		call	FormatStatus
  5718 00001609 3C01                    		cmp	al,1
  5719 0000160B 7503                    		jnz	short While_Err
  5720 0000160D E8BD01                  		call	SetDASD 
  5721                                  While_Err:
  5722 00001610 5A                      		pop	dx
  5723 00001611 59                      		pop	cx
  5724 00001612 58                      		pop	ax
  5725 00001613 E2D3                    		loop    FormatRetry
  5726                                  
  5727                                  ; Format failed
  5728                                  Format_Failed:
  5729 00001615 2EC606[9D05]01          		mov	byte [cs:Had_Format_Error],1	; Indicate a format error
  5730 0000161B 80FC06                  		cmp	ah,Dsk_change_line_Err		; Convert change line to
  5731 0000161E 7502                    		jne	short Map_Err			;   to time out.
  5732 00001620 B480                    		mov	ah,Dsk_time_out_Err
  5733                                  Map_Err:
  5734 00001622 E8EBFD                          	call    MAPERROR
  5735 00001625 5B                      		pop	bx
  5736 00001626 07                      		pop	es
  5737 00001627 5F                      		pop	di
  5738 00001628 1F                      		pop	ds
  5739 00001629 C3                      		retn
  5740                                  
  5741                                  FormatOk:
  5742 0000162A 2EC606[9D05]00          		mov	byte [cs:Had_Format_Error],0 ; Reset format error flag
  5743                                  		;pop     cx			; clean up stack after bailing out
  5744                                  						; of FormatRetry loop early
  5745 00001630 5B                      		pop	bx
  5746 00001631 07                      		pop	es
  5747 00001632 5F                      		pop	di
  5748 00001633 1F                      		pop	ds
  5749                                  DoVerifyTrack:
  5750 00001634 E8AC00                  	        call    VerifyTrack             ; Will reset DPT entries.
  5751 00001637 C3                      		retn
  5752                                  
  5753                                  ;
  5754                                  ; FormatStatus:
  5755                                  ; If SpecialFunction byte is 1, then this routine is called to see if there is
  5756                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  5757                                  ; combination is legal.
  5758                                  ;
  5759                                  ; Input: DS:DI points to BDS for drive
  5760                                  ;	 ES:BX points to format packet
  5761                                  ;
  5762                                  ; Output:
  5763                                  ;	SpecialFunction byte set to:
  5764                                  ;		0 - ROM support + legal combination
  5765                                  ;		1 - No ROM support
  5766                                  ;		2 - Illegal Combination
  5767                                  ;		3 - No media present, ROM support exists but can't determine
  5768                                  ;		    media
  5769                                  ;	Carry cleared.
  5770                                  ;
  5771                                  ;	For format track:
  5772                                  ;		Carry set if error
  5773                                  ;
  5774                                  ;
  5775                                  ;  Flags also may be altered. All other registers preserved.
  5776                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  5777                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  5778                                  ;  to the one returned. The original pointer to the disk base table is stored
  5779                                  ;  in TempDPT, until it is restored.
  5780                                  ;
  5781                                  ;
  5782                                  FormatStatus:
  5783 00001638 51                      		push	cx
  5784 00001639 52                      		push	dx
  5785                                  			; Are we here because of a format err
  5786 0000163A 2E803E[9D05]01          		cmp	byte [cs:Had_Format_Error],1
  5787 00001640 7411                    		je	short Fstat01
  5788 00001642 2E803E[9C05]01          		cmp	byte [cs:Media_Set_For_Format],1
  5789 00001648 7503                    		jnz	short FStat03
  5790 0000164A E99200                  		jmp	Stat_Ret
  5791                                  FStat03:
  5792 0000164D 2EC606[9C05]00          		mov	byte [cs:Media_Set_For_Format],0
  5793                                  ;
  5794                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5795                                  ;			modification - sp001
  5796                                  ;	
  5797                                  ;	remove check for new rom from here. we shall just assume the
  5798                                  ;	prescence of the new rom and go ahead and issue the int13 call
  5799                                  ;	anyway. later on if there is an error we shall check this to
  5800                                  ;	see if it is there because of lack of rom support, in which
  5801                                  ;	case the appropriate error will be indicated by setting al to 1
  5802                                  ;
  5803                                  ;	I would ideally like to see the new rom testing code shifted to
  5804                                  ;	msinit and this code reintroduced. however for this version we
  5805                                  ;	are aiming to stick close to the IBM variety. 
  5806                                  ;
  5807                                  ;	More changes to support this commenting out will follow. All
  5808                                  ;	will be marked as modification sp001
  5809                                  ;
  5810                                  ;	mov	al,1			; No ROM support available error code
  5811                                  ;	test	byte ptr cs:[NEW_ROM],1
  5812                                  ;	jnz	short FStat01
  5813                                  ;	jmp	Stat_Ret
  5814                                  Fstat01:
  5815 00001653 1E                      		push	ds
  5816 00001654 56                      		push	si
  5817                                  
  5818 00001655 31C0                    		xor	ax,ax
  5819 00001657 8ED8                    		mov	ds,ax
  5820 00001659 C5367800                		lds	si,[DSKADR]		; DS:SI := pDPT
  5821                                  
  5822 0000165D 2E8936[1001]            		mov	word [cs:DPT],si	; cs:[DPT] := pDPT
  5823 00001662 2E8C1E[1201]            		mov	word [cs:DPT+2],ds
  5824                                  
  5825 00001667 5E                      		pop	si
  5826 00001668 1F                      		pop	ds
  5827                                  
  5828                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5829                                  ;			modification sp001
  5830                                  ;	
  5831                                  ;	the following instruction introduced for the new rom modification
  5832                                  ;
  5833 00001669 2EC606[7100]01          		mov	byte [cs:NEW_ROM],1		; assume new rom
  5834                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5835 0000166F 8B452B                  		mov	ax,[DI+BDS.cCyln]
  5836 00001672 8B4D13                  		mov	cx,[DI+BDS.SECLIM]
  5837                                  					; set up registers for format status call
  5838 00001675 80E403                  		and	AH,03h		; 'and' out unneeded track bits
  5839 00001678 D0CC                    		ror	AH,1		; get track and sector values correct
  5840 0000167A D0CC                    		ror	AH,1
  5841 0000167C 08CC                    		or	AH,CL		; set sector number
  5842 0000167E 86E0                    		xchg	AH,AL
  5843 00001680 89C1                    		mov	CX,AX
  5844 00001682 FECD                    		dec	CH
  5845 00001684 8A5504                  		mov	DL,[DI+BDS.DriveNum] ; get drive number
  5846 00001687 B418                    		mov	AH,18h	; set command to "sec/trk supported?"
  5847                                  
  5848 00001689 06                      		push	es
  5849 0000168A 57                      		push	di
  5850 0000168B 1E                      		push	ds
  5851 0000168C 56                      		push	si
  5852                                  
  5853 0000168D CD13                    		int	13h		; call rom bios to see if supported
  5854 0000168F 7234                    		jc	short Format_Stat_Err ; if carry, combination is not supported
  5855                                  
  5856                                  				; ES:DI points to new Disk Base Table
  5857                                  				; combination for this drive replace
  5858                                  				; current (DskAdr) pointer with new one,
  5859                                  				; saving the old one in TempDPT.
  5860                                  
  5861                                  		; Are we here because of a format err
  5862 00001691 2E803E[9D05]01          		cmp	byte [cs:Had_Format_Error],1
  5863 00001697 7508                    		jnz	short Fstat02	; Then skip the disk base setup
  5864                                  	
  5865 00001699 30C0                    		xor	al,al			; Supported and OK
  5866 0000169B 2EA2[9D05]              		mov	[cs:Had_Format_Error],al ; Clear format error
  5867 0000169F EB3A                    		jmp	short Pop_Stat_Ret	; Back to work
  5868                                  Fstat02:
  5869 000016A1 31C0                    		xor	ax,ax
  5870 000016A3 8ED8                    		mov	ds,ax
  5871 000016A5 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  5872                                  
  5873 000016A9 2E8936[9E05]            		mov	[cs:TempDPT],si
  5874 000016AE 2E8C1E[A005]            		mov	[cs:TempDPT+2],ds ; Save pDPT
  5875                                  
  5876 000016B3 893E7800                		mov	[DSKADR],DI 	; Setup New DPT returned by
  5877 000016B7 8C067A00                		mov	[DSKADR+2],ES	; ROM
  5878                                  
  5879 000016BB 2EC606[9C05]01          		mov	byte [cs:Media_Set_For_Format],1 ; set flag
  5880 000016C1 30C0                    		xor	al,al		; Legal combination + ROM support code
  5881 000016C3 EB16                    		jmp	short Pop_Stat_Ret
  5882                                  
  5883                                  Format_Stat_Err:
  5884 000016C5 B003                    		mov	al,3			; Assume a time out
  5885 000016C7 80FC80                  		cmp	ah,Dsk_time_out_Err	; Was it a time out???
  5886 000016CA 740F                    		jz	short Pop_Stat_Ret	;  Yes - then done
  5887 000016CC FEC8                    		dec	al			; Assume an illegal comb.
  5888 000016CE 80FC0C                  		cmp	ah,Dsk_illegal_combination ; Was it an illegal comb???
  5889 000016D1 7408                    		jz	short Pop_Stat_Ret	; Yes - then done
  5890 000016D3 FEC8                    		dec	al			; Assume No ROM Support	
  5891                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5892                                  ;			modification sp001
  5893                                  ;
  5894                                  ;	the following instruction was introduced for the new_rom modification
  5895                                  ;
  5896 000016D5 2EC606[7100]00          		mov	byte [cs:NEW_ROM],0	; the old rom
  5897                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  5898                                  
  5899                                  ; Return result of status call
  5900                                  Pop_Stat_Ret:
  5901 000016DB 5E                      		pop	si
  5902 000016DC 1F                      		pop	ds
  5903 000016DD 5F                      		pop	di
  5904 000016DE 07                      		pop	es
  5905                                  Stat_Ret:
  5906 000016DF F8                      		clc
  5907 000016E0 5A                      		pop	dx
  5908 000016E1 59                      		pop	cx
  5909 000016E2 C3                      		retn
  5910                                  
  5911                                  ; ---------------------------------------------------------------------------
  5912                                  ;
  5913                                  ; VerifyTrack:
  5914                                  ;
  5915                                  ; Input: DS:DI points to BDS for drive
  5916                                  ;	 ES:BX points to verify packet
  5917                                  ;
  5918                                  ; ---------------------------------------------------------------------------
  5919                                  
  5920                                  VerifyTrack:
  5921 000016E3 2EC606[0401]04          		mov	byte [cs:RFLAG],ROMVerify
  5922 000016E9 268B4703                		mov	ax,[es:bx+A_VERIFYPACKET.VP_CYLINDER]
  5923 000016ED 2EA3[1601]              		mov	[cs:CURTRK], ax
  5924 000016F1 268B4701                		mov	ax,[es:bx+A_VERIFYPACKET.VP_HEAD]
  5925                                  
  5926                                  ;	****** ASSUMPTION ******
  5927                                  ;	we assume that we have less than 256 heads, and that the Request
  5928                                  ;	Header Data Structure is unneccessarily big
  5929 000016F5 2EA2[1501]              		mov	[cs:CURHD],al
  5930 000016F9 31C0                    		xor	ax,ax
  5931 000016FB 2E8B0E[9905]            		mov	cx,[cs:SectorsPerTrack]
  5932                                  ; Use 0:0 as the transfer address for verify
  5933 00001700 31DB                    		xor	bx, bx
  5934 00001702 8EC3                    		mov	es, bx
  5935 00001704 E83100                  		call	TrackIO
  5936 00001707 C3                      		retn
  5937                                  
  5938                                  ; ---------------------------------------------------------------------------
  5939                                  ;
  5940                                  ; ReadTrack:
  5941                                  ;
  5942                                  ; Input: DS:DI points to BDS for drive
  5943                                  ;	 ES:BX points to read packet
  5944                                  ;
  5945                                  ; ---------------------------------------------------------------------------
  5946                                  
  5947                                  ReadTrack:
  5948 00001708 2EC606[0401]02          		mov	byte [cs:RFLAG],ROMRead
  5949 0000170E EB08                    		jmp	short ReadWriteTrack
  5950                                  
  5951                                  ; ---------------------------------------------------------------------------
  5952                                  ;
  5953                                  ; WriteTrack:
  5954                                  ;
  5955                                  ; Input: DS:DI points to BDS for drive
  5956                                  ;	 ES:BX points to write packet
  5957                                  ;
  5958                                  ; ---------------------------------------------------------------------------
  5959                                  
  5960                                  WriteTrack:
  5961 00001710 2EC606[0401]03          		mov	byte [cs:RFLAG],ROMWrite
  5962 00001716 EB00                    		jmp	short ReadWriteTrack
  5963                                  
  5964                                  ; ---------------------------------------------------------------------------
  5965                                  ;
  5966                                  ; ReadWriteTrack:
  5967                                  ;
  5968                                  ; Input:
  5969                                  ;    DS:DI points to BDS for drive
  5970                                  ;    ES:BX points to write packet
  5971                                  ;    RFLAG - 2 for read, 3 for write
  5972                                  ;
  5973                                  ; ---------------------------------------------------------------------------
  5974                                  
  5975                                  ReadWriteTrack:
  5976 00001718 268B4703                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
  5977 0000171C 2EA3[1601]              		mov	[cs:CURTRK],ax
  5978 00001720 268B4701                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
  5979                                  
  5980                                  ;	****** ASSUMPTION ******
  5981                                  ;	we assume that we have less than 256 heads, and that the Request
  5982                                  ;	Header Data Structure is unneccessarily big
  5983 00001724 2EA2[1501]              		mov	[cs:CURHD],al
  5984 00001728 268B4705                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
  5985 0000172C 268B4F07                		mov	cx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
  5986 00001730 26C45F09                		les	bx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
  5987 00001734 E80100                  		call	TrackIO
  5988 00001737 C3                      		retn
  5989                                  ; ---------------------------------------------------------------------------
  5990                                  ;
  5991                                  ; TrackIO:
  5992                                  ;    Performs Track Read/Write/Verify
  5993                                  ;
  5994                                  ;   Input:
  5995                                  ;      RFLAG	- 2 = Read
  5996                                  ;		  3 = Write
  5997                                  ;		  4 = Verify
  5998                                  ;      ax	- Index into track table of first sector to IO
  5999                                  ;      cx	- number of sectors to IO
  6000                                  ;      es:bx	- Transfer address
  6001                                  ;      ds:di	- pointer to BDS
  6002                                  ;      curtrk	- current cylinder
  6003                                  ;      curhd	- current head
  6004                                  ;
  6005                                  ; ---------------------------------------------------------------------------
  6006                                  
  6007                                  TrackIO:
  6008                                  ; procedure `disk' will pop stack to SPsav and return if error
  6009 00001738 2E8926[1801]            		mov	[cs:SPSAV], sp
  6010                                  ; Ensure correct disk is in drive
  6011 0000173D E831FA                  		call	CHECKSINGLE
  6012                                  ;
  6013                                  ; Set up tables and variables for I/O
  6014                                  ;
  6015 00001740 2E803E[9C05]01          		cmp	byte [cs:Media_Set_For_Format],1
  6016 00001746 7407                    		jz	short DPTAlreadySet
  6017                                  ;
  6018                                  ; SET UP TABLES AND VARIABLES FOR I/O
  6019                                  ;
  6020 00001748 50                      		push	ax
  6021 00001749 51                      		push	cx
  6022 0000174A E819FB                  		call	IOSETUP
  6023 0000174D 59                      		pop	cx
  6024 0000174E 58                      		pop	ax
  6025                                  ;
  6026                                  ; point si at the table entry of the first sector to be IO'd
  6027                                  ;
  6028                                  DPTAlreadySet:
  6029 0000174F BE[9D04]                		mov	si,TrackTable
  6030 00001752 D1E0                    		shl	ax,1
  6031 00001754 D1E0                    		shl	ax,1
  6032 00001756 01C6                    		add	si,ax
  6033                                  ;
  6034                                  ; we want:
  6035                                  ;    cx to be the number of times we have to loop
  6036                                  ;    dx to be the number of sectors we read on each iteration
  6037 00001758 BA0100                  		mov	dx,1
  6038 0000175B F745290800              		test	word [DI+BDS.Flags],GOOD_TRACKLAYOUT
  6039 00001760 7402                    		jz	short IOnextSector
  6040                                  
  6041                                  ; Hey! we can read all the sectors in one blow
  6042 00001762 87D1                    		xchg	dx, cx
  6043                                  
  6044                                  IOnextSector:
  6045 00001764 51                      		push	cx
  6046 00001765 52                      		push	dx
  6047                                  ; skip over the cylinder and head in the track table
  6048 00001766 46                      		inc	si
  6049 00001767 46                      		inc	si
  6050                                  
  6051                                  ; Get sector id from track table
  6052 00001768 2E8A04                  		mov     AL,[cs:si]	; get current sector value
  6053 0000176B 2EA2[1401]              		mov     [cs:CURSEC], AL	; save cursec value
  6054                                          
  6055                                  ;*** For a Fixed disk multi-track disk I/O -  4/14/86
  6056                                  ;Assumptions: 1). In the input CX (# of sectors to go) to TRACKIO, only CL is
  6057                                  ;valid.  2). Sector size should be set to 512 bytes. 3). GOODTRACKLAYOUT.
  6058                                  ;
  6059 0000176F F745290100              		test	word [DI+BDS.Flags],fNon_Removable ;Fixed disk? - J.K
  6060 00001774 740E                    		jz	short IOREMOVABLE		;no -
  6061 00001776 2E8916[0601]            		mov	[cs:SECCNT], dx 		;# of sectors to I/O -
  6062 0000177B 89D0                    		mov	ax, dx				;		 
  6063 0000177D E887FB                  		call	DISK				;		
  6064 00001780 5A                      		pop	dx				;		 
  6065 00001781 59                      		pop	cx				;		
  6066 00001782 F8                      		clc					;		
  6067 00001783 C3                      		retn					;		
  6068                                  
  6069                                  IOREMOVABLE:		 
  6070 00001784 2E8A4401                        	mov     AL,[cs:si+1]	; get sector size index
  6071                                  
  6072                                  		; The next eight lines put sector size index in DPT
  6073 00001788 06                      		push    ES                      ; save value while getting pointer
  6074 00001789 56                      		push    SI                      ;    to DPT
  6075 0000178A 50                      		push	AX
  6076                                  
  6077 0000178B 2EC436[1001]            		les     SI,[cs:DPT]		; ES:SI points to DPT
  6078                                                                                  ; put size in DPT
  6079 00001790 26884403                		mov     [ES:SI+DISK_PARMS.DISK_SECTOR_SIZ], AL
  6080 00001794 8B4513                  		mov     AX,[DI+BDS.SECLIM]        ; get number of sector/track
  6081 00001797 26884404                		mov     [ES:SI+DISK_PARMS.DISK_EOT],AL ; patch in DPT
  6082                                  
  6083 0000179B 58                      		pop	AX			; restore register values
  6084 0000179C 5E                      		pop     SI     
  6085 0000179D 07                      		pop     ES
  6086                                                                          ; convert index to byte value
  6087 0000179E E82200                  		call    SectorSizeIndexToSectorSize
  6088 000017A1 50                      		push    AX                      ; save number of bytes in sector
  6089 000017A2 89D0                    		mov     AX, DX                  ; get number of sector for I/0
  6090                                  
  6091                                  DoTheIO:
  6092 000017A4 2EA3[0601]              		mov	[cs:SECCNT],ax	; set up the count of sectors to I/O
  6093 000017A8 E85CFB                  		call	DISK		
  6094                                  					; advance buffer pointer by adding
  6095                                  					;   sector size
  6096 000017AB 58                      		pop	ax
  6097 000017AC 01C3                    		add	bx, ax
  6098 000017AE 5A                      		pop	dx
  6099 000017AF 59                      		pop	cx
  6100 000017B0 E2B2                    		loop	IOnextSector
  6101 000017B2 E8F1FA                  		call	DONE		; Set time of last access, and reset
  6102 000017B5 F8                      		clc			; entries in DPT.
  6103 000017B6 C3                      		retn
  6104                                  
  6105                                  ; ---------------------------------------------------------------------------
  6106                                  ;
  6107                                  ; The sector size in bytes needs to be converted to an index value for the IBM
  6108                                  ; ROM. (0=>128, 1=>256,2=>512,3=>1024). It is assumed that only these values
  6109                                  ; are permissible.
  6110                                  ; On Input   AX contains sector size in bytes
  6111                                  ; On Output  AL contains index
  6112                                  ;
  6113                                  ; ---------------------------------------------------------------------------
  6114                                  
  6115                                  SectorSizeToSectorIndex:
  6116 000017B7 80E407                  		and     AH, 07h 	; very simple error correction
  6117 000017BA 88E0                    		mov     AL, AH          ; shift left 8 bits
  6118 000017BC 3C04                    		cmp     AL, 4           ; size 1024?
  6119 000017BE 7502                    		jnz	short SecToIndexRet ; no, then we are done
  6120 000017C0 2C01                    		sub     AL, 1           ; if 1024, adjust index to 3
  6121                                  SecToIndexRet:
  6122 000017C2 C3                      		retn
  6123                                  
  6124                                  SectorSizeIndexToSectorSize:
  6125                                  ; value in AH on entry is not important
  6126 000017C3 51                      		push    CX              ; save CX value
  6127 000017C4 88C1                    		mov     CL, AL          ; use index number as shift size
  6128 000017C6 B88000                  		mov     AX, 0080h       ; set AX to 128
  6129 000017C9 D3E0                    		shl     AX, CL          ; shift by index to get proper value
  6130 000017CB 59                      		pop     CX              ; restore CX value
  6131 000017CC C3                      		retn
  6132                                  
  6133                                  ; ---------------------------------------------------------------------------
  6134                                  ;
  6135                                  ; Set up the ROM for formatting.
  6136                                  ; we have to tell the ROM BIOS what type of disk is in the drive.
  6137                                  ; On Input   - DS:DI - points to BDS
  6138                                  ;
  6139                                  ; ---------------------------------------------------------------------------
  6140                                  
  6141                                  SetDASD:
  6142                                  ; See if we have new ROM and have issues Set Media Type For Format call
  6143 000017CD 2EF606[9C05]01                  	test    byte [cs:Media_Set_For_Format],1
  6144 000017D3 7549                    		jnz	short DasdHasBeenSet
  6145                                  ; See if we have previously set DASD type
  6146 000017D5 2E803E[9D05]01          		cmp	byte [cs:Had_Format_Error],1
  6147 000017DB 740C                    		je	short DoSetDasd
  6148 000017DD F745298000              		test    word [DI+BDS.Flags],SET_DASD_true
  6149 000017E2 743A                    		jz	short DasdHasBeenSet
  6150 000017E4 8165297FFF              		and     word [DI+BDS.Flags],~SET_DASD_true
  6151                                                  ; the next nine lines determine and put the DASD type in AL
  6152                                  DoSetDasd:
  6153 000017E9 2EC606[9D05]00          		mov	byte [cs:Had_Format_Error],0
  6154 000017EF 2EC606[1E01]50                  	mov	byte [cs:GAP_PATCH],50h	; assume 48tpi or 3.5" drive
  6155 000017F5 807D2802                        	cmp     byte [DI+BDS.FormFactor],ffSmall ; is 3.5" drive?
  6156 000017F9 7504                            	jnz	short Not35Drive	; no, skip down
  6157 000017FB B004                            	mov     AL,04h			; yes set proper DASD value
  6158 000017FD EB18                    		jmp     short Do_Set            ; jump down
  6159                                  
  6160                                  Not35Drive:
  6161 000017FF B001                    		mov     AL,01h			;
  6162 00001801 807D2801                		cmp     byte [DI+BDS.FormFactor],ff96tpi; 96tpi disk drive?
  6163 00001805 7510                    		jnz	short Do_Set		; no skip down to rom call
  6164 00001807 FEC0                    		inc     AL                      ; reflect 96tpi drive in DASD type
  6165 00001809 807D130F                		cmp     byte [DI+BDS.SECLIM],15 ; 96tpi media in drive?
  6166 0000180D 7508                    		jnz	short Do_Set		; no, skip down to rom call
  6167 0000180F FEC0                    		inc     AL                      ; reflect 96tpi media in DASD type
  6168 00001811 2EC606[1E01]54          		mov	byte [cs:GAP_PATCH],54h ;  and in the GAP_PATCH
  6169                                  Do_Set:
  6170 00001817 B417                    		mov     AH,17h			; set command to Set DASD type
  6171 00001819 8A5504                  		mov     DL,[DI+BDS.DriveNum]	; set drive number
  6172 0000181C CD13                    		int     13h                     ; call rom-bios
  6173                                  DasdHasBeenSet:
  6174 0000181E 8A6513                  		mov     ah,[DI+BDS.SECLIM]
  6175 00001821 2E8826[1A01]            		mov	[cs:FORMT_EOT],ah
  6176 00001826 C3                      		retn
  6177                                  
  6178                                  ; ---------------------------------------------------------------------------
  6179                                  ;
  6180                                  ; This routine is called if an error occurs while formatting or verifying.
  6181                                  ; It resets the drive, and decrements the retry count.
  6182                                  ; On Entry - DS:DI - points to BDS for the drive
  6183                                  ;	     BP    - contains retry count
  6184                                  ; On Exit    Flags indicate result of decrementing retry count
  6185                                  ;
  6186                                  ;
  6187                                  ;  There are some drives that "lose" the changeline indication if another
  6188                                  ;  floppy drive is accessed before the changeline is recorded by the device
  6189                                  ;  driver. In this situation, it is possible for the ROM to also not detect
  6190                                  ;  that the medium has changed. So, the end result is that we could have a
  6191                                  ;  diskette in the drive for which we can not even read the boot sector.
  6192                                  ;  We "fix" this by setting the byte at location DISK_STATE_MACHINE_DRV_0 (hex)
  6193                                  ;  for physical drive 0 (or DISK_STATE_MACHINE_DRV_1  for drive 1) to 0 (See
  6194                                  ;  IBM PC/AT "blessed" addresses Document for explanation) . This tells the ROM
  6195                                  ;  that the medium is 'unknown'.  The ROM actually uses these locations for
  6196                                  ;  itself.  Note that we do this only for internal drives; we do not do this for
  6197                                  ;  fixed disks or for physical drives > 1. We may end up corrupting some
  6198                                  ;  other bytes in memory that may be used for something else.
  6199                                  ;  NOTE: We do not stuff this byte if the last operation was a FORMAT because
  6200                                  ;  the ROM loses track of what it is trying to format!!
  6201                                  ;
  6202                                  ;  This routine was changed to only stuff 61H when the drive indicated it
  6203                                  ;  supported changeline. The Phoenix ROM was taking a very long time
  6204                                  ;  to figure out what the media was which caused disk time outs to take
  6205                                  ;  forever
  6206                                  ;
  6207                                  ;  We assume that DS:DI points to the current BDS for this drive.
  6208                                  ;	no registers should be touched
  6209                                  ;
  6210                                  ; ---------------------------------------------------------------------------
  6211                                  
  6212                                  AGAIN:
  6213 00001827 E80200                  		call	ResetDisk
  6214 0000182A 4D                      		dec	bp		; decrement retry count
  6215 0000182B C3                      		RETN
  6216                                  
  6217                                  ResetDisk:
  6218 0000182C 50                      		push	ax
  6219 0000182D 30E4                    		xor	AH, AH			; set command to reset disk
  6220 0000182F CD13                    		int	13h			; call the rom-bios
  6221 00001831 58                      		pop	ax
  6222 00001832 2EC606[6B00]FF          		mov	byte [cs:STEP_DRV],-1	; zap up the speed
  6223 00001838 C3                      		retn
  6224                                  
  6225                                  ; ---------------------------------------------------------------------------
  6226                                  ;
  6227                                  ; This routine sets up the Drive Parameter Table with the values needed for
  6228                                  ; Format, does an Int 13. Values in DPT are restored after a VERIFY is done.
  6229                                  ;
  6230                                  ; On Entry  -	DS:DI - points to BDS for the drive
  6231                                  ;		ES:BX - points to TRKBUF
  6232                                  ;		AL    - number of sectors
  6233                                  ;		AH    - Int 13 function code
  6234                                  ;		CL    - Sector number for verify
  6235                                  ; On Exit   -	DS,DI,ES,BX remain unchanged.
  6236                                  ;		ax and flags are the results of the int 13
  6237                                  ;
  6238                                  ; ---------------------------------------------------------------------------
  6239                                  
  6240                                  To_ROM:
  6241 00001839 1E                      		push	ds
  6242 0000183A 57                      		push	di
  6243 0000183B 06                      		push	es
  6244 0000183C 53                      		push	bx
  6245 0000183D 56                      		push	si
  6246                                  
  6247                                  ; The below line was replaced because saving the DPT is predicated upon
  6248                                  ; whether the functionality of the new ROM was used, not if it exists.
  6249                                  ;		test	byte ptr cs:[NEW_ROM],1
  6250                                  
  6251 0000183E 2EF606[9C05]01          		test	byte [cs:Media_Set_For_Format],1
  6252 00001844 753D                    		jnz	short Got_Valid_DPT
  6253                                  
  6254                                  ; Set up values in the DPT
  6255                                  ; Set up motor start correctly for 3.5" drives.
  6256 00001846 50                      		push	ax
  6257 00001847 1E                      		push	ds
  6258                                  
  6259 00001848 31C0                    		xor	ax,ax
  6260 0000184A 8ED8                    		mov	ds,ax
  6261 0000184C C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  6262                                  
  6263 00001850 2E8936[1001]            		mov	[cs:DPT],si
  6264 00001855 2E8C1E[1201]            		mov	[cs:DPT+2],ds	; Save pDPT
  6265                                  
  6266 0000185A 1F                      		pop     ds
  6267 0000185B 06                      		push    ES		; save value in ES
  6268 0000185C 2EC436[1001]            		LES     SI,[CS:DPT]
  6269                                  
  6270 00001861 8B5513                  		mov     DX,[DI+BDS.SECLIM] ; set the sector per track in
  6271 00001864 26885404                		mov     [es:si+DISK_PARMS.DISK_EOT],DL	; the Disk Parameter Table
  6272 00001868 83FA0F                  		cmp     DX, 15                  ; 96tip media?
  6273 0000186B 7409                    		jz	short To_ROM1		; yes, skip down
  6274                                                                  ; no - set Format Gap to 320/360 media value
  6275 0000186D 2E8A0E[1E01]            		mov     CL,[cs:GAP_PATCH]
  6276 00001872 26884C07                		mov     [ES:SI+DISK_PARMS.DISK_FORMT_GAP],CL
  6277                                  To_ROM1:                                ; 3.5" floppy drive?
  6278 00001876 807D2802                		cmp     byte [DI+BDS.FormFactor],ffSmall
  6279 0000187A 7505                    		jnz	short To_ROM2	; no, skip down
  6280                                                                  ; yes - reset disk motor start value
  6281 0000187C 26C6440A04              		mov     byte [ES:SI+DISK_PARMS.DISK_MOTOR_STRT],4
  6282                                  To_ROM2:
  6283 00001881 07                      		pop     ES		; restore ES value
  6284 00001882 58                      		pop     ax
  6285                                  
  6286                                  Got_Valid_DPT:
  6287                                   					; now set up the registers
  6288 00001883 8A5504                          	mov     DL,[DI+BDS.DriveNum] ; set drive number
  6289 00001886 2E8A36[1B01]                    	mov     DH,[CS:HDNUM]	; set head number
  6290 0000188B 2E8B0E[1C01]            		mov     CX,[CS:TRKNUM]	; set track number
  6291 00001890 D0CD                    		ror     CH,1
  6292 00001892 D0CD                    		ror     CH,1
  6293 00001894 86E9                    		xchg    CH, CL
  6294 00001896 CD13                    		int     13h		; call the rom-bios disk routines
  6295 00001898 5E                      		pop	si
  6296 00001899 5B                      		pop	bx
  6297 0000189A 07                      		pop	es
  6298 0000189B 5F                      		pop	di
  6299 0000189C 1F                      		pop	ds
  6300 0000189D C3                      		retn
  6301                                  
  6302                                  ; ---------------------------------------------------------------------------
  6303                                  ;
  6304                                  ; Get the owner of the physical drive represented by the logical drive in BL.
  6305                                  ; The assumption is that we **ALWAYS** keep track of the owner of a drive!!
  6306                                  ; If this is not the case, the system may hang, just following the linked list.
  6307                                  ;
  6308                                  ; ---------------------------------------------------------------------------
  6309                                  
  6310                                  IOCTL$GETOWN:
  6311 0000189E E808F6                  		call	SETDRIVE
  6312 000018A1 8A4504                  		mov	al,[DI+BDS.DriveNum]	; Get physical drive number
  6313 000018A4 0E                      		push	cs
  6314 000018A5 1F                      		pop	ds
  6315 000018A6 BF[FA00]                		mov	di,START_BDS
  6316                                  Own_Loop:
  6317 000018A9 384504                  		cmp	[DI+BDS.DriveNum],al
  6318 000018AC 7507                    		jne	short GetNextBDS
  6319 000018AE F745292000              		test	word [DI+BDS.Flags],fI_Own_Physical
  6320 000018B3 7509                    		jnz	short Done_GetOwn
  6321                                  GetNextBDS:
  6322 000018B5 8B5D02                  		mov	bx,[DI+BDS.Link+2]
  6323                                  		;mov	di,[DI+BDS.Link]
  6324 000018B8 8B3D                    		mov	di,[di] ; 05/07/2019
  6325 000018BA 8EDB                    		mov	ds,bx
  6326 000018BC EBEB                    		jmp	short Own_Loop
  6327                                  Done_GetOwn:
  6328 000018BE EB1D                    		JMP	SHORT EXIT_OWN
  6329                                  
  6330                                  ; ---------------------------------------------------------------------------
  6331                                  ;
  6332                                  ; Set the ownership of the physical drive represented by the logical drive in
  6333                                  ; BL.
  6334                                  ;
  6335                                  ; ---------------------------------------------------------------------------
  6336                                  
  6337                                  IOCTL$SETOWN:
  6338 000018C0 E8E6F5                  		call	SETDRIVE
  6339 000018C3 2EC606[7000]01          		mov	byte [cs:fSetOwner],1	; set flag for CheckSingle to
  6340                                  						; look at.
  6341 000018C9 E8A5F8                  		call	CHECKSINGLE		; Set ownership of drive
  6342 000018CC 2EC606[7000]00          		mov	byte [cs:fSetOwner],0	; reset flag
  6343 000018D2 31DB                    		xor	bx,bx
  6344 000018D4 8EC3                    		mov	es,bx
  6345 000018D6 B1FF                    		mov	cl,-1
  6346 000018D8 26880E0405              		mov	byte [es:LSTDRV],cl 	; Set up SDSB as well
  6347                                  
  6348                                  EXIT_OWN:
  6349                                  ; If there is only one logical drive assigned to this physical drive, return
  6350                                  ; 0 to user to indicate this.
  6351 000018DD 30C9                    		xor	cl,cl
  6352 000018DF F745291000              		test	word [DI+BDS.Flags],fI_Am_Mult
  6353 000018E4 7405                    		jz	short EXIT_NO_MULT
  6354 000018E6 8A4D05                  		mov	cl,[DI+BDS.DriveLet]	; Get logical drive number
  6355 000018E9 FEC1                    		inc	cl			; get it 1-based
  6356                                  EXIT_NO_MULT:
  6357 000018EB 2EC51E[0A00]            		LDS	BX,[CS:PTRSAV]
  6358 000018F0 884F01                  		mov	[BX+UNIT],CL
  6359 000018F3 E900EE                  		jmp	EXIT
  6360                                  
  6361                                  ;
  6362                                  ; Moves the old DPT that had been saved in TempDPT back to DPT. This is done
  6363                                  ; only if the first byte of TempDPT is not -1.
  6364                                  ; All registers (including flags) are preserved.
  6365                                  ;
  6366                                  
  6367                                  RestoreOldDPT:
  6368                                  ; If we have already restored the disk base table earlier, do not do it
  6369                                  ; again.
  6370 000018F6 50                      		push	ax
  6371 000018F7 30C0                    		xor	al,al
  6372                                  ; Reset flag and get current flag setting
  6373 000018F9 2EA2[9D05]              		mov	[cs:Had_Format_Error],al
  6374 000018FD 2E8606[9C05]            		xchg	[cs:Media_Set_For_Format],al
  6375 00001902 08C0                    		or	al,al
  6376 00001904 7419                    		jz	short DontRestore
  6377 00001906 56                      		push	si
  6378 00001907 1E                      		push	ds
  6379 00001908 06                      		push	es
  6380 00001909 2EC536[9E05]            		LDS	SI,[CS:TempDPT]
  6381 0000190E 31C0                    		xor	ax,ax
  6382 00001910 8EC0                    		mov	es,ax			; have ES -> segment 0
  6383 00001912 2689367800              		MOV	[ES:DSKADR],SI
  6384 00001917 268C1E7A00              		MOV	[ES:DSKADR+2],DS
  6385                                  GotCurrentDPT:
  6386 0000191C 07                      		pop	es
  6387 0000191D 1F                      		pop	ds
  6388 0000191E 5E                      		pop	si
  6389                                  DontRestore:
  6390 0000191F 58                      		pop	ax
  6391 00001920 F8                      		clc				; clear carry
  6392 00001921 C3                      		retn				; (7/31/86)
  6393                                  
  6394                                  ;end of file msioctl.asm
  6395                                  
  6396                                  ; ............................................................................
  6397                                  
  6398                                  ;-----------------------------------------------------------------------------
  6399                                  ; MSDISK.ASM (2) - MSDOS 3.3 - 02/02/1988
  6400                                  ;-----------------------------------------------------------------------------
  6401                                  ; 28/05/2018 - Retro DOS v3.0
  6402                                  ; 24/03/2018 - Retro DOS v2.0 
  6403                                  
  6404                                  ;
  6405                                  ; Check_Wrap is a routine that adjusts the starting sector, starting head
  6406                                  ; and starting cylinder for an Int 13 request that requests I/O of a lot
  6407                                  ; of sectors. It only does this for fixed disks. It is used in the sections
  6408                                  ; of code that handle ECC errors and DMA errors. It is necessary, because
  6409                                  ; ordinarily the ROM would take care of wraps around heads and cylinders,
  6410                                  ; but we break down a request when we get an ECC or DMA error into several
  6411                                  ; I/O of one or more sectors. In this case, we may already be beyond the
  6412                                  ; number of sectors on a track on the medium, and the request would fail.
  6413                                  ;
  6414                                  ; Input conditions:
  6415                                  ;	ALL registers set up for an Int 13 request.
  6416                                  ;
  6417                                  ; Output:
  6418                                  ;	 - contains starting head number for request
  6419                                  ;	 - contains starting sector and cylinder numbers
  6420                                  ;	(The above may or may not have been changed, and are 0-based)
  6421                                  ;	All other registers preserved.
  6422                                  ;
  6423                                  
  6424                                  Check_Wrap:
  6425 00001922 50                      		push	ax
  6426 00001923 53                      		push	bx
  6427 00001924 1E                      		push	ds
  6428 00001925 57                      		push	di
  6429 00001926 2EC606[6C00]01          		mov	byte [cs:PHYS_DRV],1;Use phys. drive in AL to get BDS
  6430 0000192C 88D0                    		mov	al,dl		; put drive number in AL for get BDS
  6431 0000192E E878F5                  		call	SETDRIVE	; Get pointer to BDS for drive.
  6432 00001931 2EC606[6C00]00          		mov	byte [cs:PHYS_DRV],0; Restore flag to use Logical Drive
  6433 00001937 725E                    		jc	short No_Wrap	; Do nothing if wrong phys. drive
  6434                                  
  6435 00001939 F745290100              		test	word [DI+BDS.Flags],fNon_Removable
  6436 0000193E 7457                    		jz	short No_Wrap	; No wrapping for removable media
  6437 00001940 8B5D13                  		MOV	BX,[DI+BDS.SECLIM]
  6438 00001943 89C8                    		MOV	AX,CX
  6439 00001945 83E03F                  		AND	AX,003FH	; EXTRACT SECTOR NUMBER
  6440 00001948 39D8                    		cmp	ax,bx		; If Wrap
  6441 0000194A 764B                    		jbe	short No_Wrap
  6442                                  
  6443 0000194C F6F3                    		div	bl		; AH=new sector#, AL = # of head wraps
  6444                                  
  6445                                  ; We need to be careful here.  If the new sector number == 0, then we are
  6446                                  ; on the last sector on that track
  6447 0000194E 08E4                    		or	ah,ah
  6448 00001950 7504                    		jnz	short Not_on_Bound
  6449                                  
  6450 00001952 88DC                    		mov	ah,bl		; set sector = SECLIM if on Bndry
  6451 00001954 FEC8                    		dec	al		; and decrement Num. head wraps
  6452                                  
  6453                                  Not_on_Bound:
  6454 00001956 80E1C0                  		and	CL,0C0H		; zero out sector #
  6455                                  
  6456 00001959 08E1                    		or	CL,AH		; OR in new sector #
  6457 0000195B 30E4                    		xor	ah,ah		; AX = # of head wraps
  6458 0000195D 40                      		inc	ax
  6459 0000195E 00F0                    		add	al,DH		; add in starting head #
  6460 00001960 80D400                  		adc	ah,0		; catch any carry
  6461 00001963 3B4515                  		CMP	AX,[DI+BDS.HDLIM] ; are we going to wrap around a head?
  6462 00001966 7635                    		jbe	short No_Wrap_Head ; Do not lose new head number!!
  6463                                  
  6464 00001968 52                      		push	DX		; preserve drive number and head number
  6465 00001969 31D2                    		xor	dx,dx
  6466 0000196B 8B5D15                  		mov	bx,[DI+BDS.HDLIM]
  6467 0000196E F7F3                    		div	bx		; DX=new head #, AX=# of cylinder wraps
  6468                                  ; Careful here! If new head # is 0, then we are on the last head.
  6469 00001970 09D2                    		or	dx,dx
  6470 00001972 7507                    		jnz	short No_Head_Bound
  6471                                  
  6472 00001974 89DA                    		mov	dx,bx		; On boundary. Set to HDLIM
  6473                                  ; If we had some cylinder wraps, we need to reduce them by one!!
  6474 00001976 09C0                    		or	ax,ax
  6475 00001978 7401                    		jz	short No_Head_Bound
  6476                                  
  6477 0000197A 48                      		dec	ax		; Reduce number of cylinder wraps
  6478                                  No_Head_Bound:
  6479 0000197B 88D7                    		mov	bh,dl		; bh has new head number
  6480 0000197D 5A                      		POP	DX		; restore drive number and head number
  6481                                  
  6482 0000197E FECF                    		dec	bh		; get it 0-based
  6483 00001980 88FE                    		mov	DH,bh		; set up new head number in DH
  6484                                  
  6485 00001982 88CF                    		mov	bh,CL
  6486 00001984 80E73F                  		and	bh,3FH		; preserve sector number
  6487 00001987 B306                    		mov	bl,6
  6488 00001989 86CB                    		xchg	cl,bl
  6489 0000198B D2EB                    		shr	bl,cl		; get ms cylinder bits to ls end
  6490                                  
  6491 0000198D 00C5                    		ADD	CH,AL		; ADD IN CYLINDER WRAP
  6492 0000198F 10E3                    		adc	bl,ah		; add in high byte
  6493 00001991 D2E3                    		shl	bl,cl		; move up to ms end
  6494 00001993 86D9                    		xchg	bl,cl		; restore cylinder bits into CL
  6495 00001995 08F9                    		or	CL,bh		; OR in sector number
  6496                                  No_Wrap:
  6497 00001997 F8                      		clc			; reset carry
  6498 00001998 5F                      		pop	di
  6499 00001999 1F                      		pop	ds
  6500 0000199A 5B                      		pop	bx
  6501 0000199B 58                      		pop	ax
  6502 0000199C C3                      		retn
  6503                                  
  6504                                  No_Wrap_Head:
  6505 0000199D 88C6                    		mov	DH,al		; Do not lose new head number
  6506 0000199F FECE                    		dec	DH		; get it 0-based
  6507 000019A1 EBF4                    		jmp	short No_Wrap
  6508                                  
  6509                                  ; INT_2F_13:
  6510                                  ;		This code is chained into the INT_2F interrupt during bios
  6511                                  ;	initialization.  It allows the user to change the ORIG13 int_13 vector
  6512                                  ;	after booting.	This allows testing and implementation of custom int_13
  6513                                  ;	handlers, without giving up MS-DOS error recovery
  6514                                  ;
  6515                                  ;	Entry Conditions
  6516                                  ;		AH	== RESET_Int_13  (13h)
  6517                                  ;		DS:DX	== Address of New INT_13 Handler
  6518                                  ;		ES:BX	== Address of New INT_13 vector used by WARM BOOT
  6519                                  ;								(INT 19)
  6520                                  ;
  6521                                  ;	Exit Conditions
  6522                                  ;		Orig13	== Address of new Int_13 Handler
  6523                                  ;		DS:DX	== Old ORIG13 value
  6524                                  ;		ES:BX	== Old OLD13  value
  6525                                  
  6526                                  INT_2F_13:
  6527 000019A3 80FC13                  		cmp	AH,13h			; IF (interrupt_value != Reset_Int_13)
  6528 000019A6 7405                    		je	short Chg_Orig13
  6529 000019A8 2EFF2E[0400]            		jmp	far [CS:NEXT2F_13]	;    THEN Continue on Int_2F chain
  6530                                  
  6531                                  Chg_Orig13:					;    ELSE
  6532 000019AD 2EFF36[AE00]            		push	word [CS:ORIG13]	;	 Save Old value of OLD13 and
  6533 000019B2 2EFF36[B000]            		push	word [CS:ORIG13+2]	;	 ORIG13 so that we can
  6534                                  
  6535 000019B7 2EFF36[AA00]            		push	word [CS:OLD13]		;	 Return them to caller
  6536 000019BC 2EFF36[AC00]            		push	word [CS:OLD13+2]
  6537                                  
  6538 000019C1 2E8916[AE00]            		mov	word [CS:ORIG13],DX	;	 Orig13 := Addr. Of New INT_13
  6539                                  						;	             		Vector
  6540 000019C6 2E8C1E[B000]            		mov	word [CS:ORIG13+2],DS
  6541                                  
  6542 000019CB 2E891E[AA00]            		mov	word [CS:OLD13],BX	;	 Old13 := Addr. Of New
  6543                                  						;			  Boot_13 vector
  6544 000019D0 2E8C06[AC00]            		mov	word [CS:OLD13+2],ES
  6545                                  
  6546 000019D5 07                      		pop	ES			;	 ES:BX := Old OLD13 vector
  6547 000019D6 5B                      		pop	BX
  6548                                  
  6549 000019D7 1F                      		pop	DS			;	 DS:DX := Old ORIG13 vector
  6550 000019D8 5A                      		pop	DX
  6551                                  
  6552 000019D9 CF                      		iret				;    END else
  6553                                  
  6554                                  ;--------------------------------------------------------------------------
  6555                                  ;move_sector:
  6556                                  
  6557                                  Move:
  6558 000019DA 51                      		push	CX
  6559 000019DB B90001                  		mov	CX,512/2
  6560 000019DE FC                      		cld
  6561 000019DF F3A5                    		rep	MOVSW
  6562 000019E1 59                      		pop	CX
  6563 000019E2 C3                      		retn
  6564                                  
  6565                                  ;--------------------------------------------------------------------------
  6566                                  
  6567                                  DoINT:
  6568 000019E3 8A5608                  		mov	DL,[BP+INT13FRAME.olddx]
  6569 000019E6 30E4                    		xor	AH,AH
  6570 000019E8 08C0                    		or	AL,AL
  6571 000019EA 740F                    		jz	short DoIntDone
  6572 000019EC 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  6573 000019EF FF760E                  		push	word [BP+INT13FRAME.oldf]
  6574 000019F2 2EFF1E[AE00]            		call	far [CS:ORIG13]
  6575 000019F7 9C                      		pushf
  6576 000019F8 8F460E                  		pop	word [BP+INT13FRAME.oldf]
  6577                                  DoIntDone:
  6578 000019FB C3                      		retn
  6579                                  
  6580                                  ;
  6581                                  ; Int 2f handler for external block drivers to communicate with the internal
  6582                                  ; block driver in msdisk. The multiplex number chosen is 8. The handler
  6583                                  ; sets up the pointer to the request packet in [PTRSAV] and then jumps to
  6584                                  ; DSK$IN, the entry point for all disk requests.
  6585                                  ; On exit from this driver (at EXIT), we will return to the external driver
  6586                                  ; that issued this Int 2F, and can then remove the flags from the stack.
  6587                                  ; This scheme allows us to have a small external device driver, and makes
  6588                                  ; the maintainance of the various drivers (DRIVER and msBIO) much easier,
  6589                                  ; since we only need to make changes in one place (most of the time).
  6590                                  ;
  6591                                  ; AL contains the Int2F function:
  6592                                  ;   0 - Check for installed handler - RESERVED
  6593                                  ;   1 - Install the BDS into the linked list
  6594                                  ;   2 - DOS request
  6595                                  ;
  6596                                  
  6597                                  MYNUM		EQU	8
  6598                                  
  6599                                  INT2F_DISK:
  6600 000019FC 80FC08                  		cmp	ah,MYNUM
  6601 000019FF 7405                    		je	short Mine
  6602 00001A01 2EFF2E[1806]            		jmp	far [cs:INT_2F_NEXT]	; chain to next Int 2F handler
  6603                                  Mine:
  6604 00001A06 3CF8                    		cmp	al,0F8H 		; IRET on reserved functions
  6605 00001A08 7201                    		jb	short Do_Func
  6606 00001A0A CF                      		IRET
  6607                                  Do_Func:
  6608 00001A0B 08C0                    		or	al,al			; A GET INSTALLED STATE request?
  6609 00001A0D 7503                    		jne	short Disp_Func
  6610 00001A0F B0FF                    		mov	al,0FFH
  6611 00001A11 CF                      		IRET
  6612                                  Disp_Func:
  6613 00001A12 3C01                    		cmp	al,1			; Request for installing BDS?
  6614 00001A14 7504                    		jne	short Do_DOS_Req
  6615 00001A16 E81A00                  		call	INSTALL_BDS
  6616 00001A19 CF                      		IRET
  6617                                  Do_DOS_Req:
  6618                                  ; Set up pointer to request packet
  6619 00001A1A 2E891E[0A00]            		MOV	[CS:PTRSAV],BX
  6620 00001A1F 2E8C06[0C00]            		MOV	[CS:PTRSAV+2],ES
  6621 00001A24 E97BEC                  		jmp	DSK$IN
  6622                                  
  6623                                  ; 29/06/2019 - Retro DOS v3.1
  6624                                  
  6625                                  ;*************************************************************************
  6626                                  
  6627                                  DSK$INIT:	; 29/05/2018 - Retro DOS v3.0
  6628 00001A27 0E                      		PUSH	CS
  6629 00001A28 1F                      		POP	DS
  6630                                  
  6631 00001A29 8A26[6A00]              		MOV	AH,[DRVMAX]
  6632 00001A2D BF[E405]                		MOV	DI,DSKDRVS
  6633 00001A30 E969F5                  		JMP	SetPTRSAV
  6634                                  
  6635                                  ; ---------------------------------------------------------------------------
  6636                                  ;
  6637                                  ; Install_BDS installs a BDS a location DS:DI into the current linked list of
  6638                                  ; BDS maintained by this device driver. It places the BDS at the END of the
  6639                                  ; list.
  6640                                  ;
  6641                                  ; ---------------------------------------------------------------------------
  6642                                  
  6643                                  INSTALL_BDS:
  6644                                  ; ds:di point to BDS to be installed
  6645 00001A33 2EC436[FA00]            		les	si,[cs:START_BDS]	; Start at beginning of list
  6646 00001A38 06                      		push	es			; Save pointer to current BDS
  6647 00001A39 56                      		push	si
  6648                                  ; es:si now point to BDS in linked list
  6649                                  Loop_Next_BDS:
  6650 00001A3A 83FEFF                  		cmp	si,-1			; got to end of linked list?
  6651 00001A3D 7437                    		jz	short Install_Ret
  6652                                  ; If we have several logical drives using the same physical drive, we must
  6653                                  ; set the I_Am_Mult flag in each of the appropriate BDSs.
  6654 00001A3F 8A4504                  		mov	al,[DI+BDS.DriveNum]
  6655 00001A42 26384404                		cmp	[ES:SI+BDS.DriveNum],al
  6656 00001A46 751F                    		jnz	short Next_BDS
  6657 00001A48 31DB                    		xor	bx,bx
  6658 00001A4A B310                    		mov	bl,fI_Am_Mult
  6659 00001A4C 095D29                  		or	[DI+BDS.Flags],bx	; set flags in both BDSs concerned
  6660 00001A4F 26095C29                		or	[ES:SI+BDS.Flags],bx
  6661 00001A53 B320                    		mov	bl,fI_Own_Physical
  6662 00001A55 83F3FF                  		xor	bx,-1
  6663 00001A58 215D29                  		and	[DI+BDS.Flags],bx	; reset that flag for 'new' BDS
  6664                                  ; We must also set the fChangeline bit correctly.
  6665 00001A5B 268B5C29                		mov	bx,[ES:SI+BDS.Flags]	; determine if changeline available
  6666 00001A5F 80E302                  		and	bl,fChangeline
  6667 00001A62 30FF                    		xor	bh,bh
  6668 00001A64 095D29                  		or	[DI+BDS.Flags],bx
  6669                                  
  6670                                  Next_BDS:
  6671                                  ; Before moving to next BDS, preserve pointer to current one. This is needed at
  6672                                  ; the end when the new BDS is linked into the list.
  6673 00001A67 5B                      		pop	bx			; discard previous pointer to BDS
  6674 00001A68 5B                      		pop	bx
  6675 00001A69 06                      		push	es
  6676 00001A6A 56                      		push	si
  6677 00001A6B 268B5C02                		mov	bx,[ES:SI+BDS.Link+2]
  6678                                  		;mov	si,[ES:SI+BDS.Link]
  6679 00001A6F 268B34                  		mov	si,[es:si] ; 05/07/2019
  6680 00001A72 8EC3                    		mov	es,bx
  6681 00001A74 EBC4                    		jmp	short Loop_Next_BDS
  6682                                  
  6683                                  Install_Ret:
  6684 00001A76 5E                      		pop	si			; Retrieve pointer to last BDS
  6685 00001A77 07                      		pop	es			; in linked list.
  6686 00001A78 8CD8                    		mov	ax,ds
  6687 00001A7A 26894402                		mov	[ES:SI+BDS.Link+2],ax	; install BDS
  6688                                  		;mov	[ES:SI+BDS.Link],di
  6689 00001A7E 26893C                  		mov	[es:si],di ; 05/07/2019
  6690                                  		;mov	word [DI+BDS.Link],-1	; set NEXT pointer to NULL
  6691                                  		;mov	dword [DI+BDS.Link],-1  ; Retro DOS v3.0
  6692 00001A81 C705FFFF                		mov	word [DI],-1 ; 05/07/2019 - Retro DOS v3.1
  6693 00001A85 C3                      		retn
  6694                                  
  6695                                  ; ---------------------------------------------------------------------------
  6696                                  ;
  6697                                  ; RE_INIT installs the Int 2F vector that will handle communication between
  6698                                  ; external block drivers and the internal driver. It also installs the
  6699                                  ; Reset_Int_13 interface. It is called by SYSYINIT
  6700                                  ;
  6701                                  ; ---------------------------------------------------------------------------
  6702                                  
  6703                                  RE_INIT:
  6704 00001A86 50                      		PUSH	AX
  6705 00001A87 1E                      		PUSH	DS
  6706 00001A88 57                      		PUSH	DI
  6707 00001A89 31FF                    		XOR	DI,DI
  6708 00001A8B 8EDF                    		MOV	DS,DI
  6709 00001A8D BFBC00                  		MOV	DI,2FH*4		; point it to Int 2F Vector
  6710 00001A90 8B05                    		MOV	AX,[DI]
  6711 00001A92 2EA3[1806]              		MOV	[CS:INT_2F_NEXT],AX
  6712 00001A96 8B4502                  		MOV	AX,[DI+2]		; preserve old Int 2F vector
  6713 00001A99 2EA3[1A06]              		MOV	[CS:INT_2F_NEXT+2],AX
  6714                                  
  6715                                  ; INSTALL the Reset_Int_13
  6716                                  ; interface
  6717 00001A9D FA                      		CLI
  6718 00001A9E C705[A319]              		MOV	word [DI],INT_2F_13	; install new vectors
  6719 00001AA2 8C4D02                  		MOV	[DI+2],CS
  6720 00001AA5 FB                      		STI
  6721 00001AA6 5F                      		POP	DI
  6722 00001AA7 1F                      		POP	DS
  6723 00001AA8 58                      		POP	AX
  6724 00001AA9 CB                      		RETF
  6725                                  
  6726                                  ;---------------------------------------------------------------------------
  6727                                  ;
  6728                                  ;  Ask to swap the disk in drive A:
  6729                                  ; Using a different drive in a one drive system so
  6730                                  ; request the user to change disks
  6731                                  ;
  6732                                  ;---------------------------------------------------------------------------
  6733                                  
  6734                                  SWPDSK:		; 29/05/2018 - Retro DOS v3.0
  6735                                  
  6736                                  		; 13/04/2018
  6737                                  		; 09/04/2018
  6738                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  6739                                  
  6740 00001AAA 8A4505                  		mov	al,[DI+BDS.DriveLet]	; get the drive letter
  6741 00001AAD 0441                    		add	al,"A"
  6742 00001AAF 2EA2[EF1A]              		mov	[cs:DRVLET],AL
  6743                                  
  6744 00001AB3 1E                      		push	ds			; preserve segment register
  6745 00001AB4 0E                      		push	cs
  6746 00001AB5 1F                      		pop	ds
  6747 00001AB6 BE[D31A]                		mov	SI,SNGMSG		; ds:si -> message
  6748 00001AB9 53                      		push	BX
  6749                                  
  6750 00001ABA E80A00                  		call	WRMSG			;Print disk change message
  6751 00001ABD E878F1                  		call	FLUSH
  6752                                  						; wait for a keyboard character
  6753 00001AC0 30E4                    		xor	AH, AH			; set command to read character
  6754 00001AC2 CD16                    		int	16h			; call rom-bios
  6755 00001AC4 5B                      		POP	BX
  6756 00001AC5 1F                      		pop	ds			; restore segment register
  6757                                  WRMRET:
  6758 00001AC6 C3                      		retn
  6759                                  
  6760                                  ;----------------------------------------------
  6761                                  ;
  6762                                  ;  WrMsg writes out message pointed to by [SI]
  6763                                  ;
  6764                                  ;----------------------------------------------
  6765                                  
  6766                                  WRMSG:
  6767 00001AC7 AC                      		lodsb				; get the next character of the message
  6768 00001AC8 08C0                    		or	AL,AL			; see if end of message
  6769 00001ACA 74FA                    		jz	short WRMRET
  6770 00001ACC 9C                      		pushf
  6771 00001ACD 0E                      		push	CS
  6772 00001ACE E8E6EC                  		call	OUTCHR
  6773 00001AD1 EBF4                    		jmp	SHORT WRMSG
  6774                                  
  6775                                  
  6776                                  ;	INCLUDE BIOMES.INC
  6777                                  
  6778                                  ; BIOMES.INC - 24/07/1987
  6779                                  ;----------------------------------------------------------------------------
  6780                                  ;
  6781                                  ; Single drive message for msbio.com. Nul terminated.
  6782                                  ;
  6783                                  
  6784 00001AD3 0D0A496E7365727420-     SNGMSG:	DB	0Dh,0Ah,"Insert diskette for drive "
  6784 00001ADC 6469736B6574746520-
  6784 00001AE5 666F72206472697665-
  6784 00001AEE 20                 
  6785 00001AEF 413A20616E64207374-     DRVLET:	DB	"A: and strike",0Dh,0Ah,"any key when ready",0Dh,0Ah,0Ah,0
  6785 00001AF8 72696B650D0A616E79-
  6785 00001B01 206B6579207768656E-
  6785 00001B0A 2072656164790D0A0A-
  6785 00001B13 00                 
  6786                                  
  6787                                  EndFloppy:
  6788                                  
  6789                                  ;
  6790                                  ; End of code for virtual floppy drives
  6791                                  ;
  6792                                  
  6793                                  EndSwap:
  6794                                  
  6795                                  HNUM:	
  6796 00001B14 00                      	DB	0			; number of hardfile (hard drives)
  6797                                  HARDDRV:
  6798 00001B15 80                      	DB	80H			;Physical drive number of first hardfile
  6799                                  
  6800                                  
  6801                                  ;
  6802                                  ;  "HDRIVE" is a hard disk with 512 byte sectors
  6803                                  ;
  6804                                  
  6805                                  	;EVENB
  6806                                  
  6807                                  align 2
  6808                                  
  6809                                  BDSH:
  6810 00001B16 FFFF                    	DW	-1			; Link to next structure
  6811 00001B18 7000                    	DW	KERNEL_SEGMENT
  6812 00001B1A 80                      	DB	80h			; physical drive number
  6813 00001B1B 43                      	DB	"C"                     ; Logical Drive Letter
  6814                                  HDRIVE:
  6815 00001B1C 0002                    	DW	512
  6816 00001B1E 01                      	DB	1			; Sectors/allocation unit
  6817 00001B1F 0100                    	DW	1			; Reserved sectors for DOS
  6818 00001B21 02                      	DB	2			; No. of allocation tables
  6819 00001B22 1000                    	DW	16			; Number of directory entries
  6820 00001B24 0000                    	DW	0000			; Number of sectors (at 512 bytes each)
  6821 00001B26 F8                      	DB	11111000B		; Media descriptor
  6822 00001B27 0100                    	DW	1			; Number of FAT sectors
  6823 00001B29 0000                    	DW	00			; Sector limit
  6824 00001B2B 0000                    	DW	00			; Head limit
  6825 00001B2D 0000                    	DW	00			; Hidden sector count
  6826 00001B2F 00                      	DB	0			; TRUE => bigfat
  6827 00001B30 0000                    OPCNTH:	DW	0			; Open Ref. Count
  6828 00001B32 4E4F204E414D452020-     VOLIDH:	DB	"NO NAME    ",0         ; Volume ID for this disk
  6828 00001B3B 202000             
  6829 00001B3E 03                      	DB	3			; Form Factor
  6830 00001B3F 2000                    FLAGSH:	DW	0020H			; Various Flags
  6831 00001B41 2800                    	DW	40			; number of cylinders
  6832                                  RecBPBH:
  6833 00001B43 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6834                                  TRACKH:	
  6835 00001B62 FF                      	DB	-1			; Last track accessed on this drive
  6836                                  TIM_LOH:
  6837 00001B63 FFFF                    	DW	-1			; Keep these two contiguous (?)
  6838                                  TIM_HIH:
  6839 00001B65 FFFF                    	DW	-1
  6840                                  
  6841                                  ;
  6842                                  ; End of single hard disk section
  6843                                  ;
  6844                                  
  6845                                  EndOneHard:
  6846                                  
  6847                                  ;
  6848                                  ;"DRIVEX" is an extra type of drive usually reserved for an
  6849                                  ; additional hard file
  6850                                  ;
  6851                                  
  6852                                  	;EVENB
  6853                                  
  6854 00001B67 90                      align 2
  6855                                  
  6856                                  BDSX:
  6857 00001B68 FFFF                    	DW	-1			; Link to next structure
  6858 00001B6A 7000                    	DW	KERNEL_SEGMENT
  6859 00001B6C 81                      	DB	81h			; physical drive number
  6860 00001B6D 44                      	DB	"D"                     ; Logical Drive Letter
  6861                                  DRIVEX:
  6862 00001B6E 0002                    	DW	512
  6863                                  	;DB	0
  6864 00001B70 01                      	db	1  ; 01/08/2019		; Sectors/allocation unit
  6865 00001B71 0100                    	DW	1			; Reserved sectors for DOS
  6866 00001B73 02                      	DB	2			; No. of allocation tables
  6867                                  	;DW	0			; Number of directory entries
  6868 00001B74 1000                    	dw	16 ; 01/08/2019
  6869 00001B76 0000                    	DW	0			; Number of sectors (at 512 bytes each)
  6870 00001B78 F8                      	DB	11111000b ; 0F8h	; Media descriptor
  6871                                  	;DW	0			; Number of FAT sectors
  6872 00001B79 0100                    	dw	1  ; 01/08/2019	
  6873 00001B7B 0000                    	DW	0			; Sector limit
  6874 00001B7D 0000                    	DW	0			; Head limit
  6875 00001B7F 0000                    	DW	0			; Hidden sector count
  6876 00001B81 0000                    	dw	0 ; 16/07/2019 - high word of hidden sector count
  6877 00001B83 00000000                	dd	0 ; 16/07/2019 - big totalsectors
  6878 00001B87 00                      	DB	0			; TRUE => bigfat
  6879 00001B88 0000                    OPCNTD:	DW	0			; Open Ref. Count
  6880 00001B8A 4E4F204E414D452020-     VOLIDD: DB	"NO NAME    ",0         ; Volume ID for this disk
  6880 00001B93 202000             
  6881 00001B96 03                      	DB	3			; Form Factor
  6882 00001B97 2000                    FLAGSD:	DW	20h			; Various Flags
  6883 00001B99 2800                    	DW	40			; number of cylinders
  6884                                  RecBPBD:
  6885 00001B9B 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  6886                                  TRACKD:
  6887 00001BBA FF                      	DB	-1			; Last track accessed on this drive
  6888                                  TIM_LOD:
  6889 00001BBB FFFF                    	DW	-1			; Keep these two contiguous
  6890                                  TIM_HID:
  6891 00001BBD FFFF                    	DW	-1
  6892                                  
  6893                                  ;
  6894                                  ; End of section for two hard disks
  6895                                  
  6896                                  EndTwoHard:
  6897                                  
  6898                                  TWOHARD:
  6899                                  
  6900                                  ;
  6901                                  ; End of code for virtual floppy drives
  6902                                  ;
  6903                                  
  6904                                  ; include ms96tpi.inc
  6905                                  
  6906                                  ; MS96TPI.INC - 24/07/1987
  6907                                  ;----------------------------------------------------------------------------
  6908                                  ; 01/06/2018 - Retro DOS v3.0
  6909                                  ; 25/03/2018 - Retro DOS v2.0
  6910                                  
  6911                                  ;------------------------------------------------------------------------
  6912                                  ;									:
  6913                                  ; File: ms96tpi.asm							:
  6914                                  ;									:
  6915                                  ; This file contains code to support the 96 tpi drives. The code	:
  6916                                  ; is included in the bio if the machine has at least one drive with	:
  6917                                  ; changeline support. If the machine has no changeline drives then	:
  6918                                  ; the code is not kept in the bio at system initialization time.	:
  6919                                  ;									:
  6920                                  ;------------------------------------------------------------------------
  6921                                  
  6922                                  ;------------------------------------------------------------------------
  6923                                  ;									:
  6924                                  ;		DISK OPEN/CLOSE ROUTINES				:
  6925                                  ;									:
  6926                                  ;------------------------------------------------------------------------
  6927                                  
  6928                                  DSK$OPEN:					; AL is logical drive
  6929 00001BBF E8E7F2                  		call	SETDRIVE		; Get BDS for drive
  6930 00001BC2 FF451A                  		inc	WORD [DI+BDS.Opcnt]
  6931 00001BC5 E92EEB                  		jmp	EXIT
  6932                                  
  6933                                  DSK$CLOSE:					; AL is logical drive
  6934 00001BC8 E8DEF2                  		call	SETDRIVE		; Get BDS for drive
  6935 00001BCB 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  6936 00001BCF 7403                    		jz	short EXITJX		; Watch out for wrap
  6937 00001BD1 FF4D1A                  		dec	WORD [DI+BDS.Opcnt]
  6938                                  EXITJX:
  6939 00001BD4 E91FEB                  		jmp	EXIT
  6940                                  
  6941                                  ;
  6942                                  ; ChkOpCnt checks the number of open files on drive.
  6943                                  ;
  6944                                  ; Input : DS:DI points to current BDS for drive.
  6945                                  ;
  6946                                  ; Return : zero set if no open files
  6947                                  ;	   zero reset if open files
  6948                                  ;
  6949                                  
  6950                                  ChkOpCnt:
  6951 00001BD7 837D1A00                		cmp	WORD [DI+BDS.Opcnt],0
  6952 00001BDB C3                      		retn
  6953                                  
  6954                                  ;
  6955                                  ; At media check time, we need to really get down and check what the change is.
  6956                                  ; This is GUARANTEED to be expensive.
  6957                                  ;
  6958                                  ; On entry AL contains logical drive number
  6959                                  ;
  6960                                  
  6961                                  MediaCheck:
  6962                                  		; 01/06/2018 - Retro DOS v3.0
  6963                                  
  6964                                  		; 13/04/2018
  6965                                  		; 08/04/2018
  6966                                  		; Retro DOS v2.0
  6967                                  
  6968 00001BDC E892F5                  		call	CHECKSINGLE	; make sure correct disk is in place
  6969 00001BDF 31F6                    		xor	SI,SI
  6970 00001BE1 E86F01                  		call	HasChange
  6971 00001BE4 742E                    		jz	short MediaRet
  6972 00001BE6 E85F01                  		call	CheckROMChange
  6973 00001BE9 752A                    		jnz	short MediaDoVolId
  6974 00001BEB 50                      		push	AX
  6975 00001BEC 52                      		push	DX
  6976                                  					; see if changeline has been triggered
  6977                                  ;;Rev 3.30 Modification
  6978 00001BED 8A5504                  		mov	DL, [DI+BDS.DriveNum] ; set logical drive number	  
  6979 00001BF0 B416                    		mov	AH, 16h		; get changeline status	  
  6980 00001BF2 CD13                    		int	13h		; call rom diskette routine	  
  6981                                  ;;End of Modification
  6982 00001BF4 5A                      		pop	DX
  6983 00001BF5 58                      		pop	AX
  6984 00001BF6 721D                    		jc	short MediaDoVolId ; if changeline was triggered jmp
  6985 00001BF8 BE0100                  		mov	SI,1		; else signal no change
  6986                                  
  6987                                  ; There are some drives with changeline that "lose" the changeline indication
  6988                                  ; if a different drive is accessed after the current one. In order to avoid
  6989                                  ; missing a media change, we return an "I don't know" to DOS if the changeline
  6990                                  ; is not active AND we are accessing a different drive from the last one.
  6991                                  ; If we are accessing the same drive, then we can safely rely on the changeline
  6992                                  ; status.
  6993                                  
  6994                                  LOSECHNG:
  6995 00001BFB 2E8A1E[FF00]            		mov	bl,[cs:TIM_DRV] ; get last drive accessed
  6996 00001C00 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  6997 00001C03 740F                    		jz	short MediaRet
  6998                                  
  6999                                  ; Do the 2 second twiddle. If time >= 2 seconds, do a volid check.
  7000                                  ; Otherwise return "I don't know" (Strictly speaking, we should return a
  7001                                  ; "Not Changed" here since the 2 second test said no change.) - RS.
  7002                                  
  7003 00001C05 50                      		push	ax
  7004 00001C06 51                      		push	cx
  7005 00001C07 52                      		push	dx
  7006 00001C08 E83CF3                  		call	CHECK_TIME_OF_ACCESS
  7007 00001C0B 5A                      		pop	dx
  7008 00001C0C 59                      		pop	cx
  7009 00001C0D 58                      		pop	ax
  7010 00001C0E 09F6                    		or	si,si
  7011 00001C10 7403                    		jz	short MediaDoVolId ; Check_Time says ">= 2 secs passed"
  7012 00001C12 31F6                    		xor	si,si		; return "I don't know"
  7013                                  MediaRet:
  7014 00001C14 C3                      		retn
  7015                                  
  7016                                  ; 01/06/2018 - Retro DOS v3.0
  7017                                  
  7018                                  ;
  7019                                  ; MediaDoVolid: if this is called somehow the media was changed. Look at
  7020                                  ; VID to see. We do not look at FAT because this may be different since we
  7021                                  ; only set MedByt when doing a READ or WRITE.
  7022                                  ;
  7023                                  
  7024                                  MediaDoVolId:
  7025 00001C15 E898F3                  		call	GETBP		; build a new BPB in current BDS
  7026 00001C18 72FA                    		jc	short MediaRet
  7027 00001C1A E83400                  		call	Check_VID
  7028 00001C1D 73F5                    		jnc	short MediaRet
  7029 00001C1F E8EEF7                  		call	MAPERROR	; fix up AL for return to DOS
  7030 00001C22 C3                      		retn
  7031                                  
  7032                                  ;
  7033                                  ; Checklatchio:
  7034                                  ;
  7035                                  ; Simple, quick check of latched change. If no indication, then return
  7036                                  ; otherwise do expensive check. If the expensive test fails, POP off the
  7037                                  ; return and set AL = 15 (for invalid media change) which will be returned to
  7038                                  ; DOS.
  7039                                  ;
  7040                                  
  7041                                  CheckLatchIO:
  7042                                  ; If returning fake BPB then assume the disk has not changed
  7043                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  7044                                  ;		jnz	short CheckRet
  7045                                  ;;Rev 3.30 Modification
  7046 00001C23 E82D01                  		call	HasChange		;change line supported?
  7047 00001C26 7405                    		jz	short CheckRet		;No. Just return
  7048                                  ;;End of Modification
  7049 00001C28 E8ACFF                  		call	ChkOpCnt
  7050 00001C2B 7501                    		jnz	short CheckROM
  7051                                  CheckRet:
  7052 00001C2D C3                      		retn
  7053                                  ;
  7054                                  ; Check for past ROM indications. If no ROM change indicated, then return OK.
  7055                                  ;
  7056                                  
  7057                                  CheckROM:
  7058 00001C2E E81701                  		call	CheckROMChange
  7059 00001C31 74FA                    		jz	short CheckRet		; no change
  7060                                  ;
  7061                                  ; We now see that a change line has been seen in the past.  Let's do the
  7062                                  ; expensive verification.
  7063                                  ;
  7064 00001C33 E87AF3                  		call	GETBP			; build BPB in current BDS
  7065 00001C36 720F                    		jc	short Ret_No_Error_Map	; GETBP has already called MapError
  7066 00001C38 E81600                  		call	Check_VID
  7067 00001C3B 7207                    		jc	short CheckLatchRet	; disk error trying to read in.
  7068 00001C3D 09F6                    		or	SI,SI			; Is changed for sure?
  7069 00001C3F 79EC                    		jns	short CheckRet
  7070 00001C41 E84800                  		call	ReturnVID
  7071                                  CheckLatchRet:
  7072 00001C44 E8C9F7                  		call	MAPERROR		; fix up AL for return to DOS
  7073                                  Ret_No_Error_Map:
  7074 00001C47 F9                      		stc				; indicate an error
  7075 00001C48 5E                      		pop	si			; pop off return address
  7076 00001C49 C3                      		retn
  7077                                  
  7078                                  ;
  7079                                  ;  CheckFatVID:
  7080                                  ;
  7081                                  ; Check the FAT and the VID. Return in DI -1 or 0. Return with carry set
  7082                                  ; ONLY if there was a disk error. Return that error code in AX.
  7083                                  ;
  7084                                  
  7085                                  CheckFATVID:
  7086 00001C4A E80402                  		call	FAT_CHECK
  7087 00001C4D 09F6                    		or	SI,SI
  7088 00001C4F 7810                    		js	short Changed_Drv
  7089                                  ;
  7090                                  ; The fat was the same.  How about the volume ID?
  7091                                  ;
  7092                                  Check_VID:
  7093 00001C51 E83A01                  		call	Read_Volume_ID
  7094 00001C54 720A                    		jc	short CheckFatRet
  7095 00001C56 E8E101                  		call	Check_Volume_ID
  7096                                  
  7097 00001C59 09F6                    		or	SI,SI
  7098 00001C5B 7504                    		jnz	short Changed_Drv
  7099 00001C5D E8EE00                  		call	ResetChanged
  7100                                  CheckFatRet:
  7101 00001C60 C3                      		retn
  7102                                  Changed_Drv:
  7103 00001C61 2EC606[FF00]FF          		mov	byte [cs:TIM_DRV],-1 	; Ensure that we ask ROM for media
  7104 00001C67 C3                      		retn				; check next time round
  7105                                  
  7106                                  ;
  7107                                  ; CheckIO: At I/O time the rom-bios returned an error. We need to
  7108                                  ; determine if the error is due to a media change. If error code is not
  7109                                  ; change-line error (06h) we just return. We pop off the call and jmp to
  7110                                  ; harderr if we see an error.
  7111                                  ;
  7112                                  ;   On entry:  AH contains error code returned from rom-bios.
  7113                                  ;
  7114                                  
  7115                                  CheckIO:
  7116 00001C68 80FC06                  		cmp	AH,6			; change line error?
  7117 00001C6B 75F3                    		jnz	short CheckFatRet	; no - just return
  7118 00001C6D E867FF                  		call	ChkOpCnt
  7119 00001C70 74EE                    		jz	short CheckFatRet	; no open files
  7120                                  ; If returning fake BPB then ignore disk changes
  7121                                  ;		test	word [DI+BDS.Flags],RETURN_FAKE_BPB
  7122                                  ;		jnz	short IgnoreChange
  7123 00001C72 E83BF3                  		call	GETBP			; build up a new BPB in current BDS
  7124 00001C75 7212                    		jc	short No_Error_Map	; GETBP has already called MapError
  7125 00001C77 E8D0FF                  		call	CheckFATVID
  7126 00001C7A 7209                    		jc	short CheckIORet	; disk error trying to read in.
  7127 00001C7C 09F6                    		or	SI,SI			; Is changed for sure?
  7128 00001C7E 7802                    		js	short CheckIOErr	; yes changed
  7129                                  IgnoreChange:
  7130 00001C80 45                      		inc	BP			; allow a retry
  7131 00001C81 C3                      		retn
  7132                                  CheckIOErr:
  7133 00001C82 E80700                  		call	ReturnVID
  7134                                  CheckIORet:
  7135 00001C85 F9                      		stc				; make sure carry gets passed through
  7136 00001C86 E943F7                  		jmp	HARDERR
  7137                                  
  7138                                  No_Error_Map:
  7139 00001C89 E943F7                  		jmp	HARDERR2
  7140                                  
  7141                                  ;
  7142                                  ; Return VID sets up the VID for a return to DOS.
  7143                                  ;
  7144                                  
  7145                                  ReturnVID:
  7146 00001C8C 1E                      		push	DS			; save pointer to current BDS
  7147 00001C8D 57                      		push	di
  7148 00001C8E 51                      		push	cx
  7149 00001C8F E8CF01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7150 00001C92 2EC51E[0A00]            		lds	BX,[cs:PTRSAV]
  7151 00001C97 897F16                  		mov	[BX+EXTRA],DI
  7152 00001C9A 8C4718                  		mov	[BX+EXTRA+2],ES
  7153 00001C9D 59                      		pop	cx
  7154 00001C9E 5F                      		pop	di			; restore current BDS
  7155 00001C9F 1F                      		pop	DS
  7156                                  ;;		MOV	AH,6			; INVALID MEDIA CHANGE
  7157 00001CA0 B40F                    		mov	AH,0Fh			; set error as 'invalid media change'
  7158 00001CA2 F9                      		stc				; indicate error by setting carry flag
  7159 00001CA3 C3                      		retn
  7160                                  
  7161                                  ;
  7162                                  ; Media_Set_VID:
  7163                                  ;
  7164                                  ; Moves the pointer to the volid for the drive into the original request packet
  7165                                  ; On entry, DS:BX points to the original packet.
  7166                                  ; No attempt is made to preserve registers.
  7167                                  ;
  7168                                  
  7169                                  MEDIA_SET_VID:
  7170 00001CA4 E8BA01                  		call	init_vid_loop		; Sets ES:DI -> vid
  7171 00001CA7 2EC51E[0A00]            		lds	bx,[cs:PTRSAV]		; get pointer to packet
  7172 00001CAC 897F0F                  		mov	[BX+TRANS+1],DI
  7173 00001CAF 8C4711                  		mov	[BX+TRANS+3],ES
  7174 00001CB2 C3                      		retn
  7175                                  
  7176                                  ;
  7177                                  ;   HiDensity - examine a drive/media descriptor to set the media type.  If
  7178                                  ;   the media descriptor is NOT F9 (not 96tpi or 3 1/2), we return and let the
  7179                                  ;   caller do the rest.  Otherwise, we pop off the return and jump to the tail
  7180                                  ;   of GETBP. For 3.5" media, we just return.
  7181                                  ;
  7182                                  ;   Inputs:	DS:DI point to correct BDS for this drive
  7183                                  ;		AH has media byte
  7184                                  ;
  7185                                  ;   Outputs:	Carry clear
  7186                                  ;		    No registers modified
  7187                                  ;		Carry set
  7188                                  ;		    AL = sectors/fat
  7189                                  ;		    BH = number of root directory entries
  7190                                  ;		    BL = sectors per track
  7191                                  ;		    CX = number of sectors
  7192                                  ;		    DH = sectors per allocation unit
  7193                                  ;		    DL = number of heads
  7194                                  ;
  7195                                  
  7196                                  hidensity:
  7197                                  ; Check for correct drive
  7198                                  ;
  7199 00001CB3 F745290200              		test	word [DI+BDS.Flags],fChangeline	; is it special?
  7200 00001CB8 741C                    		jz	short DoFloppy		; no, do normal floppy test
  7201                                  ;
  7202                                  ; We have a media byte that is pretty complex. Examine drive information
  7203                                  ; table to see what kind it is.
  7204                                  ;
  7205 00001CBA 807D2802                		cmp	byte [DI+BDS.FormFactor],ffSmall;  Is it single-media?
  7206 00001CBE 7416                    		jz	short DoFloppy		; yes, use fatid...
  7207                                  ;
  7208                                  ; 96 tpi drive
  7209                                  ;
  7210 00001CC0 80FCF9                  		cmp	AH,0F9h
  7211 00001CC3 7511                    		jnz	short DoFloppy
  7212 00001CC5 B007                    		mov	al,7			; seven sectors / fat
  7213 00001CC7 BB0FE0                  		mov	bx,224*256+0Fh		; 224 root dir entries & 0f sector max
  7214 00001CCA B96009                  		mov	cx,80*15*2		; 80 tracks, 15 sectors/track, 2 sides
  7215 00001CCD BA0201                  		mov	dx,1*256+2		; sectors/allocation unit & head max
  7216                                  popr:
  7217 00001CD0 83C402                  		add	SP,2			; pop off return address
  7218 00001CD3 E953F3                  		jmp	HAS1_res		; return to tail of GETBP
  7219                                  
  7220                                  
  7221                                  DoFloppy:
  7222 00001CD6 C3                      		retn
  7223                                  
  7224                                  ;
  7225                                  ; Certain poorly designed programs avoid DOS altogether and use INT 13 directly.
  7226                                  ; These programs even retry operations and, thus, will ignore the disk change
  7227                                  ; logic.
  7228                                  ;
  7229                                  ; We hook INT 13 and note all errors.
  7230                                  ;
  7231                                  
  7232 00001CD7 00000000                REAL13:		dd	0
  7233 00001CDB 00000000                OLDINT:		dd	0
  7234 00001CDF 0000                    DMY:		dw	0
  7235                                  
  7236                                  INT13:
  7237                                  		; 16/06/2018
  7238 00001CE1 2E8F06[DB1C]            		pop	word [cs:OLDINT]
  7239 00001CE6 2E8F06[DD1C]            		pop	word [cs:OLDINT+2]
  7240 00001CEB 2E8F06[DF1C]            		pop	word [cs:DMY]
  7241 00001CF0 9C                      		pushf
  7242 00001CF1 2EFF1E[D71C]            		call	far [cs:REAL13]	; simulate another INT 13
  7243 00001CF6 7205                    		jc	short Err13	; did an error occur?
  7244 00001CF8 2EFF2E[DB1C]            		jmp	far [cs:OLDINT]	; no, return and pop off flags
  7245                                  Err13:
  7246 00001CFD 9C                      		pushf			; save state
  7247 00001CFE 80FC06                  		cmp	AH,06h		; is error a 'change' error?
  7248 00001D01 7406                    		jz	short GotErr	; yes, jump down
  7249                                  _B:		
  7250 00001D03 9D                      		popf			; no, some other error, ignore it ;;End of Modification
  7251 00001D04 2EFF2E[DB1C]            		jmp	far [cs:OLDINT]	; return and pop off flags
  7252                                  
  7253                                  GotErr: 	
  7254 00001D09 08D2                    		or	DL,DL		; is this for the hard disk?
  7255 00001D0B 78F6                    		js	short _B	; yes, ignore
  7256 00001D0D 2EC706[0001]4000        		mov	word [cs:FlagBits],fChanged
  7257 00001D14 E80200                  		call	Set_Changed_DL
  7258 00001D17 EBEA                    		jmp	short _B
  7259                                  
  7260                                  ;
  7261                                  ; Set_Changed_DL - Sets flag bits according to bits set in [FlagBits].
  7262                                  ;		   Essentially used to indicate Changeline, or Format.
  7263                                  ;
  7264                                  ;   Inputs:	DL contains physical drive number
  7265                                  ;		[FlagBits] contains bits to set in the flag field in the BDSs
  7266                                  ;   Outputs:	None
  7267                                  ;   Registers modified: Flags
  7268                                  ;
  7269                                  
  7270                                  Set_Changed_DL:
  7271 00001D19 53                      		push	BX
  7272 00001D1A 52                      		push	DX
  7273 00001D1B 88D3                    		mov	BL,DL
  7274                                  ALL_SET:
  7275 00001D1D 2E8B16[0001]            		mov	dx,[cs:FlagBits] ; get bits to set in flag field
  7276 00001D22 30FF                    		xor	BH,BH
  7277                                  ;
  7278                                  ; In the virtual drive system we *must* flag the other drives as being changed
  7279                                  ;
  7280                                  ; assume first BDS is in this segment
  7281 00001D24 50                      		push	ax
  7282 00001D25 1E                      		push	ds		; save current BDS
  7283 00001D26 57                      		push	di
  7284 00001D27 2EC53E[FA00]            		lds	di,[cs:START_BDS]
  7285                                  Scan_BDS:
  7286 00001D2C 83FFFF                  		cmp	di,-1
  7287 00001D2F 7411                    		jz	short SkipSet
  7288 00001D31 385D04                  		cmp	byte [DI+BDS.DriveNum],bl
  7289 00001D34 7503                    		jnz	short Get_Next_BDS
  7290                                  ;
  7291                                  ; Someone may complain, but this *always* must be done when a disk change is
  7292                                  ; noted.  There are *no* other compromising circumstances.
  7293                                  ;
  7294                                  SetChanged:
  7295 00001D36 095529                  		or	[DI+BDS.Flags],dx ; signal change on other drive
  7296                                  Get_Next_BDS:
  7297 00001D39 8B4502                  		mov	ax,[DI+BDS.Link+2]  ; go to next BDS
  7298                                  		;mov	di,[DI+BDS.Link]
  7299 00001D3C 8B3D                    		mov	di,[di] ; 05/07/2019
  7300 00001D3E 8ED8                    		mov	ds,ax
  7301 00001D40 EBEA                    		jmp	short Scan_BDS
  7302                                  SkipSet:
  7303 00001D42 5F                      		pop	di		    ; restore current BDS
  7304 00001D43 1F                      		pop	ds
  7305 00001D44 58                      		pop	ax
  7306 00001D45 5A                      		pop	DX
  7307 00001D46 5B                      		pop	BX
  7308 00001D47 C3                      		retn
  7309                                  
  7310                                  ;
  7311                                  ; CheckROMChange - see if external program has diddled ROM change line.
  7312                                  ;
  7313                                  ;   Inputs:	DS:DI points to current BDS.
  7314                                  ;   Outputs:	Zero set - no change
  7315                                  ;		Zero reset - change
  7316                                  ;   Registers modified: none
  7317                                  
  7318                                  CheckROMChange:
  7319 00001D48 F745294000              		test	word [DI+BDS.Flags],fChanged
  7320 00001D4D C3                      		retn
  7321                                  
  7322                                  ;
  7323                                  ; ResetChanged - restore value of change line
  7324                                  ;
  7325                                  ;   Inputs:	DS:DI points to current BDS
  7326                                  ;   Outputs:	none
  7327                                  ;   Registers modified: none
  7328                                  
  7329                                  ResetChanged:
  7330 00001D4E 836529BF                		and	word [DI+BDS.Flags],~fChanged
  7331 00001D52 C3                      		retn
  7332                                  
  7333                                  ;
  7334                                  ; HasChange - see if drive can supply change line
  7335                                  ;
  7336                                  ;   Inputs:	DS:DI points to current BDS
  7337                                  ;   Outputs:	Zero set - no change line available
  7338                                  ;		Zero reset - change line available
  7339                                  ;   Registers modified: none
  7340                                  
  7341                                  HasChange:
  7342 00001D53 F745290200              		test	word [DI+BDS.Flags],fChangeline
  7343 00001D58 C3                      		retn
  7344                                  
  7345                                  ; 01/06/2018 - Retro DOS v3.0
  7346                                  
  7347                                  ; include msvolid.inc
  7348                                  
  7349                                  ;-------------------------------------------------------------------------
  7350                                  ;
  7351                                  ;  File: msvolid.asm
  7352                                  ;	This file contains the volume_id subroutines and data structures.
  7353                                  ;
  7354                                  ;	Routines in this file are:
  7355                                  ;	   Set_Volume_ID       -	main routine, calls other routines.
  7356                                  ;	   read_volume_id      -	read the volume ID and tells if it has
  7357                                  ;					   been changed.
  7358                                  ;	   Transfer_volume_id  -	copy the volume ID from TMP to special
  7359                                  ;					   drive.
  7360                                  ;	   Check_Volume_ID     -	compare volume ID in TMP area with one
  7361                                  ;					   expected for drive.
  7362                                  ;	   Fat_Check	       -	see of the fatID has changed in the
  7363                                  ;					   specified drive.
  7364                                  ;	   Init_Vid_loop       -	set up for VID scan or move
  7365                                  ;
  7366                                  ;
  7367                                  ;-------------------------------------------------------------------------
  7368                                  
  7369                                  ;
  7370                                  ; length of the volume id
  7371                                  ;
  7372                                  
  7373                                  vid_size    equ 12
  7374                                  
  7375                                  ;
  7376                                  ; null volume id
  7377                                  ;
  7378                                  
  7379                                  nul_vid:
  7380 00001D59 4E4F204E414D452020-     	db  "NO NAME    ",0
  7380 00001D62 202000             
  7381                                  
  7382                                  ;
  7383                                  ; data scratch area used to hold volume ids
  7384                                  ;
  7385                                  
  7386                                  tmp_vid:
  7387 00001D65 4E4F204E414D452020-     	db  "NO NAME    ",0
  7387 00001D6E 202000             
  7388                                  
  7389                                  ;
  7390                                  ; Set_Volume_ID
  7391                                  ;   If drive has changeline support, read in and set the volume_ID
  7392                                  ; and the last FAT_ID byte.  If no change line support then do nothing.
  7393                                  ;
  7394                                  ;   On entry:
  7395                                  ;	DS:DI points to the BDS for this disk.
  7396                                  ;	AH contains media byte
  7397                                  ;
  7398                                  ;   On Exit:
  7399                                  ;	Carry clear:
  7400                                  ;	   Successful call
  7401                                  ;	Carry set
  7402                                  ;	   Error and AX has error code
  7403                                  ;
  7404                                  
  7405                                  Set_Volume_ID:
  7406 00001D71 52                      		push	dx		; save registers
  7407 00001D72 50                      		push	ax
  7408 00001D73 E8DDFF                  		CALL	HasChange	; does drive have changeline support?
  7409 00001D76 740D                    		jz	short setvret	; no, get out
  7410 00001D78 57                      		push	di
  7411 00001D79 E81200                  		call	Read_Volume_ID	; read the volume ID
  7412 00001D7C 5F                      		pop	di
  7413 00001D7D 720A                    		jc	short SetErr	; if error go to error routine
  7414 00001D7F E8A700                  		call	transfer_volume_ID ; copy the volume id to special drive
  7415 00001D82 E8C9FF                  		call	ResetChanged	; restore value of change line
  7416                                  setvret:				; SET Volume RETurn
  7417 00001D85 F8                      		clc			; no error, clear carry flag
  7418 00001D86 58                      		pop	ax		; restore registers
  7419 00001D87 5A                      		pop	dx
  7420 00001D88 C3                      		retn
  7421                                  SetErr:
  7422 00001D89 5A                      		pop	dx		; pop stack but don't overwrite AX
  7423 00001D8A 5A                      		pop	dx		; restore DX
  7424 00001D8B C3                      		retn
  7425                                  
  7426                                  root_sec:
  7427 00001D8C 0000                    		DW	0		;Root sector #
  7428                                  
  7429                                  ;
  7430                                  ; read_volume_id read the volume ID and tells if it has been changed.
  7431                                  ;
  7432                                  ;   On entry:
  7433                                  ;	DS:DI points to current BDS for drive.
  7434                                  ;   On Exit:
  7435                                  ;	Carry Clear
  7436                                  ;	    SI = 1  No change
  7437                                  ;	    SI = 0  ?
  7438                                  ;	    SI = -1 Change
  7439                                  ;
  7440                                  ;	Carry Set:
  7441                                  ;	    Error and AX has error code.
  7442                                  ;
  7443                                  
  7444                                  Read_Volume_ID:
  7445 00001D8E 06                      		push	ES		; preserve registers
  7446 00001D8F 52                      		push	DX
  7447 00001D90 51                      		push	CX
  7448 00001D91 53                      		push	BX
  7449 00001D92 50                      		push	AX
  7450 00001D93 1E                      		push	DS		; Preserve Current BDS
  7451 00001D94 57                      		push	DI
  7452 00001D95 0E                      		push	cs		; get ES segment correct
  7453 00001D96 07                      		pop	es
  7454 00001D97 0E                      		push	cs		; get DS segment correct
  7455 00001D98 1F                      		pop	ds
  7456 00001D99 BF[651D]                		mov	di,tmp_vid
  7457 00001D9C BE[591D]                		mov	si,nul_vid
  7458 00001D9F B90C00                  		mov	cx,vid_size
  7459 00001DA2 F3A4                    		rep	movsb		; initialize tmp_vid to null vi_id
  7460                                  
  7461 00001DA4 5F                      		pop	DI		; Restore Current BDS
  7462 00001DA5 1F                      		pop	DS
  7463 00001DA6 8A450B                  		mov	al,[DI+BDS.cFAT] ; # of fats
  7464 00001DA9 8B4D11                  		mov	cx,[DI+BDS.cSecFat] ; sectors / fat
  7465 00001DAC F6E1                    		mul	cl			    ; size taken by fats
  7466 00001DAE 034509                  		add	ax,[DI+BDS.RESSEC] ; add on reserved sectors
  7467                                  					; AX is now sector # (0 based)
  7468 00001DB1 2EA3[8C1D]              		mov	[cs:root_sec],ax ; set initial value
  7469 00001DB5 8B450C                  		mov	ax,[DI+BDS.cDir] ; # root dir entries
  7470 00001DB8 B104                    		mov	cl,4		; 16 entries/sector
  7471 00001DBA D3E8                    		shr	ax,cl		; divide by 16
  7472 00001DBC 89C1                    		mov	cx,ax		; cx is # of sectors to scan
  7473                                  next_sec:
  7474 00001DBE 51                      		push	cx		; save outer loop counter
  7475 00001DBF 2EA1[8C1D]              		mov	ax,[cs:root_sec] ; get sector #
  7476 00001DC3 8B4D13                  		mov	cx,[DI+BDS.SECLIM] ; sectors / track
  7477 00001DC6 31D2                    		xor	DX,DX
  7478 00001DC8 F7F1                    		div	cx
  7479                                  				; set up registers for call to read_sector
  7480 00001DCA 42                      		inc	DX	; dx= sectors into track, ax= track count from 0
  7481 00001DCB 88D1                    		mov	cl,dl	; sector to read
  7482 00001DCD 31D2                    		xor	DX,DX
  7483 00001DCF F77515                  		div	word [DI+BDS.HDLIM] ; # heads on this disc
  7484 00001DD2 88D6                    		mov	dh,dl	; Head number
  7485 00001DD4 88C5                    		mov	ch,al	; Track #
  7486 00001DD6 E803F3                  		call	READ_SECTOR ; get first sector of the root directory,
  7487                                  				; ES:BX -> BOOT
  7488 00001DD9 724A                    		jc	short ReadVIDErr ; error on read
  7489 00001DDB B91000                  		mov	cx,16		; # of dir entries in a block of root
  7490 00001DDE B008                    		mov	al,08h		; volume label bit
  7491                                  fvid_loop:
  7492 00001DE0 26803F00                		cmp	byte [es:bx],0	; End of dir?
  7493 00001DE4 743C                    		jz	short no_vid	; yes, no vol id
  7494 00001DE6 26803FE5                		cmp	byte [es:bx],0E5h ; empty entry?
  7495 00001DEA 7406                    		jz	short ent_loop	; yes, skip
  7496 00001DEC 2684470B                		test	[es:bx+11],al	; is volume label bit set in fcb?
  7497 00001DF0 7511                    		jnz	short found_vid	; jmp yes
  7498                                  ent_loop:
  7499 00001DF2 83C320                  		ADD	BX,32		;ADD LENGTH OF DIRECTORY ENTRY
  7500 00001DF5 E2E9                    		loop	fvid_loop
  7501 00001DF7 59                      		pop	cx		; outer loop
  7502 00001DF8 2EFF06[8C1D]            		inc	word [cs:root_sec] ; next sector
  7503 00001DFD E2BF                    		loop	next_sec	; continue
  7504                                  NotFound:
  7505 00001DFF 31F6                    		XOR	SI,SI
  7506 00001E01 EB18                    		jmp	short fvid_ret
  7507                                  
  7508                                  found_vid:
  7509 00001E03 59                      		pop	cx		; clean stack of outer loop counter
  7510 00001E04 89DE                    		mov	si,bx		; point to volume_id
  7511 00001E06 1E                      		push	ds		; preserve currnet BDS
  7512 00001E07 57                      		push	di
  7513 00001E08 06                      		push	es		; es:si points to volume id.
  7514 00001E09 1F                      		pop	ds		; source segment
  7515 00001E0A 0E                      		push	cs
  7516 00001E0B 07                      		pop	es		; destination segment
  7517 00001E0C BF[651D]                		mov	di,tmp_vid	; dest of volume_id
  7518 00001E0F B90B00                  		mov	cx,vid_size-1	; length of string minus NUL
  7519 00001E12 F3A4                    		rep	movsb		; mov volume label to tmp_vid
  7520 00001E14 30C0                    		xor	al,al
  7521 00001E16 AA                      		stosb			; Null terminate
  7522 00001E17 31F6                    		XOR	SI,SI
  7523 00001E19 5F                      		pop	DI		; restore current BDS
  7524 00001E1A 1F                      		pop	DS
  7525                                  fvid_ret:
  7526 00001E1B 58                      		pop	ax
  7527 00001E1C F8                      		clc
  7528                                  RVIDRet:
  7529 00001E1D 5B                      		pop	BX		; restore register
  7530 00001E1E 59                      		pop	CX
  7531 00001E1F 5A                      		pop	DX
  7532 00001E20 07                      		pop	ES
  7533 00001E21 C3                      		retn
  7534                                  no_vid:
  7535 00001E22 59                      		pop	cx		; clean stack of outer loop counter
  7536 00001E23 EBDA                    		jmp	short NotFound	; not found
  7537                                  ReadVIDErr:
  7538 00001E25 5E                      		pop	SI
  7539 00001E26 5E                      		pop	SI
  7540 00001E27 EBF4                    		jmp	short RVIDRet
  7541                                  
  7542                                  ;
  7543                                  ;   Transfer_volume_id - copy the volume ID from TMP to special drive
  7544                                  ;
  7545                                  ;   Inputs:	DS:DI nas current BDS
  7546                                  ;   Outputs:	BDS for drive has volume ID from TMP
  7547                                  ;
  7548                                  
  7549                                  transfer_volume_ID:
  7550 00001E29 1E                      		push	DS		; preserve current BDS
  7551 00001E2A 57                      		push	DI
  7552 00001E2B 06                      		push	ES
  7553 00001E2C 56                      		push	SI
  7554 00001E2D 51                      		push	CX
  7555 00001E2E E83000                  		call	init_vid_loop
  7556 00001E31 FC                      		cld
  7557 00001E32 F3A4                    		rep	MOVSB		; transfer
  7558 00001E34 59                      		pop	CX
  7559 00001E35 5E                      		pop	SI
  7560 00001E36 07                      		pop	ES
  7561 00001E37 5F                      		pop	DI		; restore current BDS
  7562 00001E38 1F                      		pop	DS
  7563 00001E39 C3                      		retn
  7564                                  
  7565                                  ;
  7566                                  ;   Check_Volume_ID - compare volume ID in TMP area with one expected for
  7567                                  ;	drive
  7568                                  ;
  7569                                  ;   Inputs:	DS:DI has current BDS for drive
  7570                                  ;   Outputs:	SI = 0 if compare succeeds
  7571                                  ;		SI = -1 if compare fails.
  7572                                  
  7573                                  Check_Volume_ID:
  7574 00001E3A 1E                      		push	DS		; preserve current BDS for drive
  7575 00001E3B 57                      		push	DI
  7576 00001E3C 06                      		push	ES
  7577 00001E3D 51                      		push	CX
  7578 00001E3E E82000                  		call	init_vid_loop
  7579 00001E41 FC                      		cld
  7580 00001E42 F3A6                    		repz	cmpsb		; are the 2 volume_ids the same?
  7581 00001E44 BE0000                  		mov	si,0		; assume unknown
  7582 00001E47 7403                    		jz	short check_vid_ret ; carry clear if jump taken
  7583 00001E49 BEFFFF                  		mov	si,-1		; failure
  7584                                  check_vid_ret:
  7585 00001E4C 59                      		pop	CX
  7586 00001E4D 07                      		pop	ES
  7587 00001E4E 5F                      		pop	DI		; restore current BDS
  7588 00001E4F 1F                      		pop	DS
  7589 00001E50 C3                      		retn
  7590                                  
  7591                                  ;
  7592                                  ;   Fat_Check - see of the fatID has changed in the specified drive.
  7593                                  ;	      - uses the FAT ID obtained from the boot sector.
  7594                                  ;
  7595                                  ;   Inputs:	MedByt is expected FAT ID
  7596                                  ;		DS:DI points to current BDS
  7597                                  ;   Output:	Carry Clear
  7598                                  ;		    SI = -1 if fat ID different,
  7599                                  ;		    SI = 0 otherwise
  7600                                  ;   No other registers changed.
  7601                                  
  7602                                  FAT_CHECK:
  7603 00001E51 50                      		push	AX
  7604 00001E52 31F6                    		xor	SI,SI		; say FAT ID's are same.
  7605 00001E54 2EA0[0201]              		mov	AL,[cs:MedByt]
  7606                                  					 ; compare it with the BDS medbyte
  7607 00001E58 3A4510                  		cmp	AL,[DI+BDS.Mediad]
  7608 00001E5B 7401                    		jz	short OkRet1	; carry clear
  7609 00001E5D 4E                      		dec	SI
  7610                                  OkRet1:		
  7611 00001E5E F8                      		clc
  7612 00001E5F 58                      		pop	AX
  7613 00001E60 C3                      		retn
  7614                                  
  7615                                  ;
  7616                                  ;   Init_Vid_loop - set up for VID scan or move
  7617                                  ;
  7618                                  ;   Inputs:	DS:DI pionts to BDS for the drive
  7619                                  ;   Outputs:	DS:SI points to tmp_vid
  7620                                  ;		ES:DI points to vid for drive
  7621                                  ;		CX has size for VID compare
  7622                                  ;
  7623                                  
  7624                                  init_vid_loop:
  7625 00001E61 50                      		push	ax
  7626 00001E62 1E                      		push	ds
  7627 00001E63 07                      		pop	es
  7628 00001E64 0E                      		push	cs
  7629 00001E65 1F                      		pop	ds
  7630 00001E66 BE[651D]                		mov	si,tmp_vid	; source
  7631 00001E69 83C71C                  		add	di,BDS.Volid
  7632 00001E6C B90C00                  		mov	cx,vid_size
  7633 00001E6F 58                      		pop	ax
  7634 00001E70 C3                      		retn
  7635                                  
  7636                                  ;-----------------------------------------------------------------------------
  7637                                  
  7638                                  End96tpi:
  7639                                  
  7640                                  ;Rev 3.30 modification ----------------------------
  7641                                  ;Memory allocation for BDSM table.
  7642                                  
  7643                                  BDSMs:
  7644                                  		;times BDSM.size*Max_mini_dsk_num db 0	;currently max. 23
  7645                                  
  7646                                  	; 03/08/2019
  7647                                  		%rep	Max_mini_dsk_num ; 23 
  7648                                  ;BDSM:
  7649                                  		DW	-1			; Link to next structure
  7650                                  		DW	0
  7651                                  		DB	50h			; physical drive number
  7652                                  		DB	3                    	; Logical Drive Letter
  7653                                  ;DRIVEM:
  7654                                  		DW	512
  7655                                  		;DB	0
  7656                                  		db	1	; Sectors/allocation unit
  7657                                  		DW	1			; Reserved sectors for DOS
  7658                                  		DB	2			; No. of allocation tables
  7659                                  		DW	16			; Number of directory entries
  7660                                  		DW	0			; Number of sectors (at 512 bytes each)
  7661                                  		DB	11111000b  ; 0F8h	; Media descriptor
  7662                                  		DW	1			; Number of FAT sectors
  7663                                  		DW	0			; Sector limit
  7664                                  		DW	0			; Head limit
  7665                                  		DW	0			; Hidden sector count
  7666                                  		DB	0			; TRUE => bigfat
  7667                                  ;OPCNTM:
  7668                                  		DW	0			; Open Ref. Count
  7669                                  ;VOLIDM: 
  7670                                  		db	"NO NAME    ",0	; Volume ID for this disk
  7671                                  		DB	3			; Form Factor
  7672                                  ;FLAGSM:	
  7673                                  		DW	20h			; Various Flags
  7674                                  		DW	40			; number of cylinders
  7675                                  ;RecBPBM:
  7676                                  		times	31 db 0			; Recommended BPB for drive
  7677                                  ;TRACKM:
  7678                                  		DB	-1			; Last track accessed on this drive
  7679                                  ;BDSM_ISMINI:
  7680                                  		DW	1			; Keep these two contiguous
  7681                                  ;BDSM_HIDDEN_TRKS:
  7682                                  		DW	0
  7683                                  
  7684                                  		%endrep
  7648                              <1> 
  7649 00001E71 FFFF                <1>  DW -1
  7650 00001E73 0000                <1>  DW 0
  7651 00001E75 50                  <1>  DB 50h
  7652 00001E76 03                  <1>  DB 3
  7653                              <1> 
  7654 00001E77 0002                <1>  DW 512
  7655                              <1> 
  7656 00001E79 01                  <1>  db 1
  7657 00001E7A 0100                <1>  DW 1
  7658 00001E7C 02                  <1>  DB 2
  7659 00001E7D 1000                <1>  DW 16
  7660 00001E7F 0000                <1>  DW 0
  7661 00001E81 F8                  <1>  DB 11111000b
  7662 00001E82 0100                <1>  DW 1
  7663 00001E84 0000                <1>  DW 0
  7664 00001E86 0000                <1>  DW 0
  7665 00001E88 0000                <1>  DW 0
  7666 00001E8A 00                  <1>  DB 0
  7667                              <1> 
  7668 00001E8B 0000                <1>  DW 0
  7669                              <1> 
  7670 00001E8D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00001E96 202000              <1>
  7671 00001E99 03                  <1>  DB 3
  7672                              <1> 
  7673 00001E9A 2000                <1>  DW 20h
  7674 00001E9C 2800                <1>  DW 40
  7675                              <1> 
  7676 00001E9E 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00001EBD FF                  <1>  DB -1
  7679                              <1> 
  7680 00001EBE 0100                <1>  DW 1
  7681                              <1> 
  7682 00001EC0 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00001EC2 FFFF                <1>  DW -1
  7650 00001EC4 0000                <1>  DW 0
  7651 00001EC6 50                  <1>  DB 50h
  7652 00001EC7 03                  <1>  DB 3
  7653                              <1> 
  7654 00001EC8 0002                <1>  DW 512
  7655                              <1> 
  7656 00001ECA 01                  <1>  db 1
  7657 00001ECB 0100                <1>  DW 1
  7658 00001ECD 02                  <1>  DB 2
  7659 00001ECE 1000                <1>  DW 16
  7660 00001ED0 0000                <1>  DW 0
  7661 00001ED2 F8                  <1>  DB 11111000b
  7662 00001ED3 0100                <1>  DW 1
  7663 00001ED5 0000                <1>  DW 0
  7664 00001ED7 0000                <1>  DW 0
  7665 00001ED9 0000                <1>  DW 0
  7666 00001EDB 00                  <1>  DB 0
  7667                              <1> 
  7668 00001EDC 0000                <1>  DW 0
  7669                              <1> 
  7670 00001EDE 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00001EE7 202000              <1>
  7671 00001EEA 03                  <1>  DB 3
  7672                              <1> 
  7673 00001EEB 2000                <1>  DW 20h
  7674 00001EED 2800                <1>  DW 40
  7675                              <1> 
  7676 00001EEF 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00001F0E FF                  <1>  DB -1
  7679                              <1> 
  7680 00001F0F 0100                <1>  DW 1
  7681                              <1> 
  7682 00001F11 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00001F13 FFFF                <1>  DW -1
  7650 00001F15 0000                <1>  DW 0
  7651 00001F17 50                  <1>  DB 50h
  7652 00001F18 03                  <1>  DB 3
  7653                              <1> 
  7654 00001F19 0002                <1>  DW 512
  7655                              <1> 
  7656 00001F1B 01                  <1>  db 1
  7657 00001F1C 0100                <1>  DW 1
  7658 00001F1E 02                  <1>  DB 2
  7659 00001F1F 1000                <1>  DW 16
  7660 00001F21 0000                <1>  DW 0
  7661 00001F23 F8                  <1>  DB 11111000b
  7662 00001F24 0100                <1>  DW 1
  7663 00001F26 0000                <1>  DW 0
  7664 00001F28 0000                <1>  DW 0
  7665 00001F2A 0000                <1>  DW 0
  7666 00001F2C 00                  <1>  DB 0
  7667                              <1> 
  7668 00001F2D 0000                <1>  DW 0
  7669                              <1> 
  7670 00001F2F 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00001F38 202000              <1>
  7671 00001F3B 03                  <1>  DB 3
  7672                              <1> 
  7673 00001F3C 2000                <1>  DW 20h
  7674 00001F3E 2800                <1>  DW 40
  7675                              <1> 
  7676 00001F40 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00001F5F FF                  <1>  DB -1
  7679                              <1> 
  7680 00001F60 0100                <1>  DW 1
  7681                              <1> 
  7682 00001F62 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00001F64 FFFF                <1>  DW -1
  7650 00001F66 0000                <1>  DW 0
  7651 00001F68 50                  <1>  DB 50h
  7652 00001F69 03                  <1>  DB 3
  7653                              <1> 
  7654 00001F6A 0002                <1>  DW 512
  7655                              <1> 
  7656 00001F6C 01                  <1>  db 1
  7657 00001F6D 0100                <1>  DW 1
  7658 00001F6F 02                  <1>  DB 2
  7659 00001F70 1000                <1>  DW 16
  7660 00001F72 0000                <1>  DW 0
  7661 00001F74 F8                  <1>  DB 11111000b
  7662 00001F75 0100                <1>  DW 1
  7663 00001F77 0000                <1>  DW 0
  7664 00001F79 0000                <1>  DW 0
  7665 00001F7B 0000                <1>  DW 0
  7666 00001F7D 00                  <1>  DB 0
  7667                              <1> 
  7668 00001F7E 0000                <1>  DW 0
  7669                              <1> 
  7670 00001F80 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00001F89 202000              <1>
  7671 00001F8C 03                  <1>  DB 3
  7672                              <1> 
  7673 00001F8D 2000                <1>  DW 20h
  7674 00001F8F 2800                <1>  DW 40
  7675                              <1> 
  7676 00001F91 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00001FB0 FF                  <1>  DB -1
  7679                              <1> 
  7680 00001FB1 0100                <1>  DW 1
  7681                              <1> 
  7682 00001FB3 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00001FB5 FFFF                <1>  DW -1
  7650 00001FB7 0000                <1>  DW 0
  7651 00001FB9 50                  <1>  DB 50h
  7652 00001FBA 03                  <1>  DB 3
  7653                              <1> 
  7654 00001FBB 0002                <1>  DW 512
  7655                              <1> 
  7656 00001FBD 01                  <1>  db 1
  7657 00001FBE 0100                <1>  DW 1
  7658 00001FC0 02                  <1>  DB 2
  7659 00001FC1 1000                <1>  DW 16
  7660 00001FC3 0000                <1>  DW 0
  7661 00001FC5 F8                  <1>  DB 11111000b
  7662 00001FC6 0100                <1>  DW 1
  7663 00001FC8 0000                <1>  DW 0
  7664 00001FCA 0000                <1>  DW 0
  7665 00001FCC 0000                <1>  DW 0
  7666 00001FCE 00                  <1>  DB 0
  7667                              <1> 
  7668 00001FCF 0000                <1>  DW 0
  7669                              <1> 
  7670 00001FD1 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00001FDA 202000              <1>
  7671 00001FDD 03                  <1>  DB 3
  7672                              <1> 
  7673 00001FDE 2000                <1>  DW 20h
  7674 00001FE0 2800                <1>  DW 40
  7675                              <1> 
  7676 00001FE2 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002001 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002002 0100                <1>  DW 1
  7681                              <1> 
  7682 00002004 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002006 FFFF                <1>  DW -1
  7650 00002008 0000                <1>  DW 0
  7651 0000200A 50                  <1>  DB 50h
  7652 0000200B 03                  <1>  DB 3
  7653                              <1> 
  7654 0000200C 0002                <1>  DW 512
  7655                              <1> 
  7656 0000200E 01                  <1>  db 1
  7657 0000200F 0100                <1>  DW 1
  7658 00002011 02                  <1>  DB 2
  7659 00002012 1000                <1>  DW 16
  7660 00002014 0000                <1>  DW 0
  7661 00002016 F8                  <1>  DB 11111000b
  7662 00002017 0100                <1>  DW 1
  7663 00002019 0000                <1>  DW 0
  7664 0000201B 0000                <1>  DW 0
  7665 0000201D 0000                <1>  DW 0
  7666 0000201F 00                  <1>  DB 0
  7667                              <1> 
  7668 00002020 0000                <1>  DW 0
  7669                              <1> 
  7670 00002022 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000202B 202000              <1>
  7671 0000202E 03                  <1>  DB 3
  7672                              <1> 
  7673 0000202F 2000                <1>  DW 20h
  7674 00002031 2800                <1>  DW 40
  7675                              <1> 
  7676 00002033 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002052 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002053 0100                <1>  DW 1
  7681                              <1> 
  7682 00002055 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002057 FFFF                <1>  DW -1
  7650 00002059 0000                <1>  DW 0
  7651 0000205B 50                  <1>  DB 50h
  7652 0000205C 03                  <1>  DB 3
  7653                              <1> 
  7654 0000205D 0002                <1>  DW 512
  7655                              <1> 
  7656 0000205F 01                  <1>  db 1
  7657 00002060 0100                <1>  DW 1
  7658 00002062 02                  <1>  DB 2
  7659 00002063 1000                <1>  DW 16
  7660 00002065 0000                <1>  DW 0
  7661 00002067 F8                  <1>  DB 11111000b
  7662 00002068 0100                <1>  DW 1
  7663 0000206A 0000                <1>  DW 0
  7664 0000206C 0000                <1>  DW 0
  7665 0000206E 0000                <1>  DW 0
  7666 00002070 00                  <1>  DB 0
  7667                              <1> 
  7668 00002071 0000                <1>  DW 0
  7669                              <1> 
  7670 00002073 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000207C 202000              <1>
  7671 0000207F 03                  <1>  DB 3
  7672                              <1> 
  7673 00002080 2000                <1>  DW 20h
  7674 00002082 2800                <1>  DW 40
  7675                              <1> 
  7676 00002084 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000020A3 FF                  <1>  DB -1
  7679                              <1> 
  7680 000020A4 0100                <1>  DW 1
  7681                              <1> 
  7682 000020A6 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000020A8 FFFF                <1>  DW -1
  7650 000020AA 0000                <1>  DW 0
  7651 000020AC 50                  <1>  DB 50h
  7652 000020AD 03                  <1>  DB 3
  7653                              <1> 
  7654 000020AE 0002                <1>  DW 512
  7655                              <1> 
  7656 000020B0 01                  <1>  db 1
  7657 000020B1 0100                <1>  DW 1
  7658 000020B3 02                  <1>  DB 2
  7659 000020B4 1000                <1>  DW 16
  7660 000020B6 0000                <1>  DW 0
  7661 000020B8 F8                  <1>  DB 11111000b
  7662 000020B9 0100                <1>  DW 1
  7663 000020BB 0000                <1>  DW 0
  7664 000020BD 0000                <1>  DW 0
  7665 000020BF 0000                <1>  DW 0
  7666 000020C1 00                  <1>  DB 0
  7667                              <1> 
  7668 000020C2 0000                <1>  DW 0
  7669                              <1> 
  7670 000020C4 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000020CD 202000              <1>
  7671 000020D0 03                  <1>  DB 3
  7672                              <1> 
  7673 000020D1 2000                <1>  DW 20h
  7674 000020D3 2800                <1>  DW 40
  7675                              <1> 
  7676 000020D5 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000020F4 FF                  <1>  DB -1
  7679                              <1> 
  7680 000020F5 0100                <1>  DW 1
  7681                              <1> 
  7682 000020F7 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000020F9 FFFF                <1>  DW -1
  7650 000020FB 0000                <1>  DW 0
  7651 000020FD 50                  <1>  DB 50h
  7652 000020FE 03                  <1>  DB 3
  7653                              <1> 
  7654 000020FF 0002                <1>  DW 512
  7655                              <1> 
  7656 00002101 01                  <1>  db 1
  7657 00002102 0100                <1>  DW 1
  7658 00002104 02                  <1>  DB 2
  7659 00002105 1000                <1>  DW 16
  7660 00002107 0000                <1>  DW 0
  7661 00002109 F8                  <1>  DB 11111000b
  7662 0000210A 0100                <1>  DW 1
  7663 0000210C 0000                <1>  DW 0
  7664 0000210E 0000                <1>  DW 0
  7665 00002110 0000                <1>  DW 0
  7666 00002112 00                  <1>  DB 0
  7667                              <1> 
  7668 00002113 0000                <1>  DW 0
  7669                              <1> 
  7670 00002115 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000211E 202000              <1>
  7671 00002121 03                  <1>  DB 3
  7672                              <1> 
  7673 00002122 2000                <1>  DW 20h
  7674 00002124 2800                <1>  DW 40
  7675                              <1> 
  7676 00002126 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002145 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002146 0100                <1>  DW 1
  7681                              <1> 
  7682 00002148 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 0000214A FFFF                <1>  DW -1
  7650 0000214C 0000                <1>  DW 0
  7651 0000214E 50                  <1>  DB 50h
  7652 0000214F 03                  <1>  DB 3
  7653                              <1> 
  7654 00002150 0002                <1>  DW 512
  7655                              <1> 
  7656 00002152 01                  <1>  db 1
  7657 00002153 0100                <1>  DW 1
  7658 00002155 02                  <1>  DB 2
  7659 00002156 1000                <1>  DW 16
  7660 00002158 0000                <1>  DW 0
  7661 0000215A F8                  <1>  DB 11111000b
  7662 0000215B 0100                <1>  DW 1
  7663 0000215D 0000                <1>  DW 0
  7664 0000215F 0000                <1>  DW 0
  7665 00002161 0000                <1>  DW 0
  7666 00002163 00                  <1>  DB 0
  7667                              <1> 
  7668 00002164 0000                <1>  DW 0
  7669                              <1> 
  7670 00002166 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000216F 202000              <1>
  7671 00002172 03                  <1>  DB 3
  7672                              <1> 
  7673 00002173 2000                <1>  DW 20h
  7674 00002175 2800                <1>  DW 40
  7675                              <1> 
  7676 00002177 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002196 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002197 0100                <1>  DW 1
  7681                              <1> 
  7682 00002199 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 0000219B FFFF                <1>  DW -1
  7650 0000219D 0000                <1>  DW 0
  7651 0000219F 50                  <1>  DB 50h
  7652 000021A0 03                  <1>  DB 3
  7653                              <1> 
  7654 000021A1 0002                <1>  DW 512
  7655                              <1> 
  7656 000021A3 01                  <1>  db 1
  7657 000021A4 0100                <1>  DW 1
  7658 000021A6 02                  <1>  DB 2
  7659 000021A7 1000                <1>  DW 16
  7660 000021A9 0000                <1>  DW 0
  7661 000021AB F8                  <1>  DB 11111000b
  7662 000021AC 0100                <1>  DW 1
  7663 000021AE 0000                <1>  DW 0
  7664 000021B0 0000                <1>  DW 0
  7665 000021B2 0000                <1>  DW 0
  7666 000021B4 00                  <1>  DB 0
  7667                              <1> 
  7668 000021B5 0000                <1>  DW 0
  7669                              <1> 
  7670 000021B7 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000021C0 202000              <1>
  7671 000021C3 03                  <1>  DB 3
  7672                              <1> 
  7673 000021C4 2000                <1>  DW 20h
  7674 000021C6 2800                <1>  DW 40
  7675                              <1> 
  7676 000021C8 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000021E7 FF                  <1>  DB -1
  7679                              <1> 
  7680 000021E8 0100                <1>  DW 1
  7681                              <1> 
  7682 000021EA 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000021EC FFFF                <1>  DW -1
  7650 000021EE 0000                <1>  DW 0
  7651 000021F0 50                  <1>  DB 50h
  7652 000021F1 03                  <1>  DB 3
  7653                              <1> 
  7654 000021F2 0002                <1>  DW 512
  7655                              <1> 
  7656 000021F4 01                  <1>  db 1
  7657 000021F5 0100                <1>  DW 1
  7658 000021F7 02                  <1>  DB 2
  7659 000021F8 1000                <1>  DW 16
  7660 000021FA 0000                <1>  DW 0
  7661 000021FC F8                  <1>  DB 11111000b
  7662 000021FD 0100                <1>  DW 1
  7663 000021FF 0000                <1>  DW 0
  7664 00002201 0000                <1>  DW 0
  7665 00002203 0000                <1>  DW 0
  7666 00002205 00                  <1>  DB 0
  7667                              <1> 
  7668 00002206 0000                <1>  DW 0
  7669                              <1> 
  7670 00002208 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002211 202000              <1>
  7671 00002214 03                  <1>  DB 3
  7672                              <1> 
  7673 00002215 2000                <1>  DW 20h
  7674 00002217 2800                <1>  DW 40
  7675                              <1> 
  7676 00002219 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002238 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002239 0100                <1>  DW 1
  7681                              <1> 
  7682 0000223B 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 0000223D FFFF                <1>  DW -1
  7650 0000223F 0000                <1>  DW 0
  7651 00002241 50                  <1>  DB 50h
  7652 00002242 03                  <1>  DB 3
  7653                              <1> 
  7654 00002243 0002                <1>  DW 512
  7655                              <1> 
  7656 00002245 01                  <1>  db 1
  7657 00002246 0100                <1>  DW 1
  7658 00002248 02                  <1>  DB 2
  7659 00002249 1000                <1>  DW 16
  7660 0000224B 0000                <1>  DW 0
  7661 0000224D F8                  <1>  DB 11111000b
  7662 0000224E 0100                <1>  DW 1
  7663 00002250 0000                <1>  DW 0
  7664 00002252 0000                <1>  DW 0
  7665 00002254 0000                <1>  DW 0
  7666 00002256 00                  <1>  DB 0
  7667                              <1> 
  7668 00002257 0000                <1>  DW 0
  7669                              <1> 
  7670 00002259 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002262 202000              <1>
  7671 00002265 03                  <1>  DB 3
  7672                              <1> 
  7673 00002266 2000                <1>  DW 20h
  7674 00002268 2800                <1>  DW 40
  7675                              <1> 
  7676 0000226A 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002289 FF                  <1>  DB -1
  7679                              <1> 
  7680 0000228A 0100                <1>  DW 1
  7681                              <1> 
  7682 0000228C 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 0000228E FFFF                <1>  DW -1
  7650 00002290 0000                <1>  DW 0
  7651 00002292 50                  <1>  DB 50h
  7652 00002293 03                  <1>  DB 3
  7653                              <1> 
  7654 00002294 0002                <1>  DW 512
  7655                              <1> 
  7656 00002296 01                  <1>  db 1
  7657 00002297 0100                <1>  DW 1
  7658 00002299 02                  <1>  DB 2
  7659 0000229A 1000                <1>  DW 16
  7660 0000229C 0000                <1>  DW 0
  7661 0000229E F8                  <1>  DB 11111000b
  7662 0000229F 0100                <1>  DW 1
  7663 000022A1 0000                <1>  DW 0
  7664 000022A3 0000                <1>  DW 0
  7665 000022A5 0000                <1>  DW 0
  7666 000022A7 00                  <1>  DB 0
  7667                              <1> 
  7668 000022A8 0000                <1>  DW 0
  7669                              <1> 
  7670 000022AA 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000022B3 202000              <1>
  7671 000022B6 03                  <1>  DB 3
  7672                              <1> 
  7673 000022B7 2000                <1>  DW 20h
  7674 000022B9 2800                <1>  DW 40
  7675                              <1> 
  7676 000022BB 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000022DA FF                  <1>  DB -1
  7679                              <1> 
  7680 000022DB 0100                <1>  DW 1
  7681                              <1> 
  7682 000022DD 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000022DF FFFF                <1>  DW -1
  7650 000022E1 0000                <1>  DW 0
  7651 000022E3 50                  <1>  DB 50h
  7652 000022E4 03                  <1>  DB 3
  7653                              <1> 
  7654 000022E5 0002                <1>  DW 512
  7655                              <1> 
  7656 000022E7 01                  <1>  db 1
  7657 000022E8 0100                <1>  DW 1
  7658 000022EA 02                  <1>  DB 2
  7659 000022EB 1000                <1>  DW 16
  7660 000022ED 0000                <1>  DW 0
  7661 000022EF F8                  <1>  DB 11111000b
  7662 000022F0 0100                <1>  DW 1
  7663 000022F2 0000                <1>  DW 0
  7664 000022F4 0000                <1>  DW 0
  7665 000022F6 0000                <1>  DW 0
  7666 000022F8 00                  <1>  DB 0
  7667                              <1> 
  7668 000022F9 0000                <1>  DW 0
  7669                              <1> 
  7670 000022FB 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002304 202000              <1>
  7671 00002307 03                  <1>  DB 3
  7672                              <1> 
  7673 00002308 2000                <1>  DW 20h
  7674 0000230A 2800                <1>  DW 40
  7675                              <1> 
  7676 0000230C 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 0000232B FF                  <1>  DB -1
  7679                              <1> 
  7680 0000232C 0100                <1>  DW 1
  7681                              <1> 
  7682 0000232E 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002330 FFFF                <1>  DW -1
  7650 00002332 0000                <1>  DW 0
  7651 00002334 50                  <1>  DB 50h
  7652 00002335 03                  <1>  DB 3
  7653                              <1> 
  7654 00002336 0002                <1>  DW 512
  7655                              <1> 
  7656 00002338 01                  <1>  db 1
  7657 00002339 0100                <1>  DW 1
  7658 0000233B 02                  <1>  DB 2
  7659 0000233C 1000                <1>  DW 16
  7660 0000233E 0000                <1>  DW 0
  7661 00002340 F8                  <1>  DB 11111000b
  7662 00002341 0100                <1>  DW 1
  7663 00002343 0000                <1>  DW 0
  7664 00002345 0000                <1>  DW 0
  7665 00002347 0000                <1>  DW 0
  7666 00002349 00                  <1>  DB 0
  7667                              <1> 
  7668 0000234A 0000                <1>  DW 0
  7669                              <1> 
  7670 0000234C 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002355 202000              <1>
  7671 00002358 03                  <1>  DB 3
  7672                              <1> 
  7673 00002359 2000                <1>  DW 20h
  7674 0000235B 2800                <1>  DW 40
  7675                              <1> 
  7676 0000235D 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 0000237C FF                  <1>  DB -1
  7679                              <1> 
  7680 0000237D 0100                <1>  DW 1
  7681                              <1> 
  7682 0000237F 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002381 FFFF                <1>  DW -1
  7650 00002383 0000                <1>  DW 0
  7651 00002385 50                  <1>  DB 50h
  7652 00002386 03                  <1>  DB 3
  7653                              <1> 
  7654 00002387 0002                <1>  DW 512
  7655                              <1> 
  7656 00002389 01                  <1>  db 1
  7657 0000238A 0100                <1>  DW 1
  7658 0000238C 02                  <1>  DB 2
  7659 0000238D 1000                <1>  DW 16
  7660 0000238F 0000                <1>  DW 0
  7661 00002391 F8                  <1>  DB 11111000b
  7662 00002392 0100                <1>  DW 1
  7663 00002394 0000                <1>  DW 0
  7664 00002396 0000                <1>  DW 0
  7665 00002398 0000                <1>  DW 0
  7666 0000239A 00                  <1>  DB 0
  7667                              <1> 
  7668 0000239B 0000                <1>  DW 0
  7669                              <1> 
  7670 0000239D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000023A6 202000              <1>
  7671 000023A9 03                  <1>  DB 3
  7672                              <1> 
  7673 000023AA 2000                <1>  DW 20h
  7674 000023AC 2800                <1>  DW 40
  7675                              <1> 
  7676 000023AE 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000023CD FF                  <1>  DB -1
  7679                              <1> 
  7680 000023CE 0100                <1>  DW 1
  7681                              <1> 
  7682 000023D0 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000023D2 FFFF                <1>  DW -1
  7650 000023D4 0000                <1>  DW 0
  7651 000023D6 50                  <1>  DB 50h
  7652 000023D7 03                  <1>  DB 3
  7653                              <1> 
  7654 000023D8 0002                <1>  DW 512
  7655                              <1> 
  7656 000023DA 01                  <1>  db 1
  7657 000023DB 0100                <1>  DW 1
  7658 000023DD 02                  <1>  DB 2
  7659 000023DE 1000                <1>  DW 16
  7660 000023E0 0000                <1>  DW 0
  7661 000023E2 F8                  <1>  DB 11111000b
  7662 000023E3 0100                <1>  DW 1
  7663 000023E5 0000                <1>  DW 0
  7664 000023E7 0000                <1>  DW 0
  7665 000023E9 0000                <1>  DW 0
  7666 000023EB 00                  <1>  DB 0
  7667                              <1> 
  7668 000023EC 0000                <1>  DW 0
  7669                              <1> 
  7670 000023EE 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000023F7 202000              <1>
  7671 000023FA 03                  <1>  DB 3
  7672                              <1> 
  7673 000023FB 2000                <1>  DW 20h
  7674 000023FD 2800                <1>  DW 40
  7675                              <1> 
  7676 000023FF 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 0000241E FF                  <1>  DB -1
  7679                              <1> 
  7680 0000241F 0100                <1>  DW 1
  7681                              <1> 
  7682 00002421 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002423 FFFF                <1>  DW -1
  7650 00002425 0000                <1>  DW 0
  7651 00002427 50                  <1>  DB 50h
  7652 00002428 03                  <1>  DB 3
  7653                              <1> 
  7654 00002429 0002                <1>  DW 512
  7655                              <1> 
  7656 0000242B 01                  <1>  db 1
  7657 0000242C 0100                <1>  DW 1
  7658 0000242E 02                  <1>  DB 2
  7659 0000242F 1000                <1>  DW 16
  7660 00002431 0000                <1>  DW 0
  7661 00002433 F8                  <1>  DB 11111000b
  7662 00002434 0100                <1>  DW 1
  7663 00002436 0000                <1>  DW 0
  7664 00002438 0000                <1>  DW 0
  7665 0000243A 0000                <1>  DW 0
  7666 0000243C 00                  <1>  DB 0
  7667                              <1> 
  7668 0000243D 0000                <1>  DW 0
  7669                              <1> 
  7670 0000243F 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002448 202000              <1>
  7671 0000244B 03                  <1>  DB 3
  7672                              <1> 
  7673 0000244C 2000                <1>  DW 20h
  7674 0000244E 2800                <1>  DW 40
  7675                              <1> 
  7676 00002450 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 0000246F FF                  <1>  DB -1
  7679                              <1> 
  7680 00002470 0100                <1>  DW 1
  7681                              <1> 
  7682 00002472 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002474 FFFF                <1>  DW -1
  7650 00002476 0000                <1>  DW 0
  7651 00002478 50                  <1>  DB 50h
  7652 00002479 03                  <1>  DB 3
  7653                              <1> 
  7654 0000247A 0002                <1>  DW 512
  7655                              <1> 
  7656 0000247C 01                  <1>  db 1
  7657 0000247D 0100                <1>  DW 1
  7658 0000247F 02                  <1>  DB 2
  7659 00002480 1000                <1>  DW 16
  7660 00002482 0000                <1>  DW 0
  7661 00002484 F8                  <1>  DB 11111000b
  7662 00002485 0100                <1>  DW 1
  7663 00002487 0000                <1>  DW 0
  7664 00002489 0000                <1>  DW 0
  7665 0000248B 0000                <1>  DW 0
  7666 0000248D 00                  <1>  DB 0
  7667                              <1> 
  7668 0000248E 0000                <1>  DW 0
  7669                              <1> 
  7670 00002490 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 00002499 202000              <1>
  7671 0000249C 03                  <1>  DB 3
  7672                              <1> 
  7673 0000249D 2000                <1>  DW 20h
  7674 0000249F 2800                <1>  DW 40
  7675                              <1> 
  7676 000024A1 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000024C0 FF                  <1>  DB -1
  7679                              <1> 
  7680 000024C1 0100                <1>  DW 1
  7681                              <1> 
  7682 000024C3 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 000024C5 FFFF                <1>  DW -1
  7650 000024C7 0000                <1>  DW 0
  7651 000024C9 50                  <1>  DB 50h
  7652 000024CA 03                  <1>  DB 3
  7653                              <1> 
  7654 000024CB 0002                <1>  DW 512
  7655                              <1> 
  7656 000024CD 01                  <1>  db 1
  7657 000024CE 0100                <1>  DW 1
  7658 000024D0 02                  <1>  DB 2
  7659 000024D1 1000                <1>  DW 16
  7660 000024D3 0000                <1>  DW 0
  7661 000024D5 F8                  <1>  DB 11111000b
  7662 000024D6 0100                <1>  DW 1
  7663 000024D8 0000                <1>  DW 0
  7664 000024DA 0000                <1>  DW 0
  7665 000024DC 0000                <1>  DW 0
  7666 000024DE 00                  <1>  DB 0
  7667                              <1> 
  7668 000024DF 0000                <1>  DW 0
  7669                              <1> 
  7670 000024E1 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 000024EA 202000              <1>
  7671 000024ED 03                  <1>  DB 3
  7672                              <1> 
  7673 000024EE 2000                <1>  DW 20h
  7674 000024F0 2800                <1>  DW 40
  7675                              <1> 
  7676 000024F2 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002511 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002512 0100                <1>  DW 1
  7681                              <1> 
  7682 00002514 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002516 FFFF                <1>  DW -1
  7650 00002518 0000                <1>  DW 0
  7651 0000251A 50                  <1>  DB 50h
  7652 0000251B 03                  <1>  DB 3
  7653                              <1> 
  7654 0000251C 0002                <1>  DW 512
  7655                              <1> 
  7656 0000251E 01                  <1>  db 1
  7657 0000251F 0100                <1>  DW 1
  7658 00002521 02                  <1>  DB 2
  7659 00002522 1000                <1>  DW 16
  7660 00002524 0000                <1>  DW 0
  7661 00002526 F8                  <1>  DB 11111000b
  7662 00002527 0100                <1>  DW 1
  7663 00002529 0000                <1>  DW 0
  7664 0000252B 0000                <1>  DW 0
  7665 0000252D 0000                <1>  DW 0
  7666 0000252F 00                  <1>  DB 0
  7667                              <1> 
  7668 00002530 0000                <1>  DW 0
  7669                              <1> 
  7670 00002532 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000253B 202000              <1>
  7671 0000253E 03                  <1>  DB 3
  7672                              <1> 
  7673 0000253F 2000                <1>  DW 20h
  7674 00002541 2800                <1>  DW 40
  7675                              <1> 
  7676 00002543 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 00002562 FF                  <1>  DB -1
  7679                              <1> 
  7680 00002563 0100                <1>  DW 1
  7681                              <1> 
  7682 00002565 0000                <1>  DW 0
  7683                              <1> 
  7648                              <1> 
  7649 00002567 FFFF                <1>  DW -1
  7650 00002569 0000                <1>  DW 0
  7651 0000256B 50                  <1>  DB 50h
  7652 0000256C 03                  <1>  DB 3
  7653                              <1> 
  7654 0000256D 0002                <1>  DW 512
  7655                              <1> 
  7656 0000256F 01                  <1>  db 1
  7657 00002570 0100                <1>  DW 1
  7658 00002572 02                  <1>  DB 2
  7659 00002573 1000                <1>  DW 16
  7660 00002575 0000                <1>  DW 0
  7661 00002577 F8                  <1>  DB 11111000b
  7662 00002578 0100                <1>  DW 1
  7663 0000257A 0000                <1>  DW 0
  7664 0000257C 0000                <1>  DW 0
  7665 0000257E 0000                <1>  DW 0
  7666 00002580 00                  <1>  DB 0
  7667                              <1> 
  7668 00002581 0000                <1>  DW 0
  7669                              <1> 
  7670 00002583 4E4F204E414D452020- <1>  db "NO NAME    ",0
  7670 0000258C 202000              <1>
  7671 0000258F 03                  <1>  DB 3
  7672                              <1> 
  7673 00002590 2000                <1>  DW 20h
  7674 00002592 2800                <1>  DW 40
  7675                              <1> 
  7676 00002594 00<rep 1Fh>         <1>  times 31 db 0
  7677                              <1> 
  7678 000025B3 FF                  <1>  DB -1
  7679                              <1> 
  7680 000025B4 0100                <1>  DW 1
  7681                              <1> 
  7682 000025B6 0000                <1>  DW 0
  7683                              <1> 
  7685                                  
  7686                                  ;** End_of_BDSM defined in MSINIT.ASM will be used to set the appropriate
  7687                                  ;** ending address of BDSM table.
  7688                                  ;;End of modification ----------------------------
  7689                                  
  7690                                  ;
  7691                                  ;;3.3 BUG FIX -SP ------------------------------
  7692                                  ;Paragraph buffer between the BDSMs and MSHARD
  7693                                  ;
  7694                                  ;The relocation code for MSHARD needs this. this cannot be used for 
  7695                                  ;anything. nothing can come before this or after this.....IMPORTANT!!!!
  7696                                  ;don't get too smart and using this buffer for anything!!!!!!
  7697                                  ;
  7698 000025B8 00<rep 10h>             		times 16 db 0
  7699                                  ;
  7700                                  ;end of bug fix buffer
  7701                                  ;;
  7702                                  ;;3.3 BUG FIX -SP------------------------------
  7703                                  
  7704                                  ;-----------------------------------------------------------------------------
  7705                                  ; MSHARD.ASM - MSDOS 3.3 - 24/07/1987
  7706                                  ;-----------------------------------------------------------------------------
  7707                                  ; 02/06/2018 - Retro DOS v3.0
  7708                                  
  7709                                  ;***
  7710                                  ;	Title:	Disk
  7711                                  ;	By:	Michael Hanson
  7712                                  ;	C:	Copyright (C) 1985-1987 by Microsoft corp.
  7713                                  ;	Date:	1/11/85
  7714                                  ;
  7715                                  ;		There is a bug in some versions of IBM's AT ROM BIOS
  7716                                  ;		interupts are not disabled during read operations.
  7717                                  ;
  7718                                  ;	Use:	This program should be chained in line with the disk
  7719                                  ;		interrupt 13h, it intercepts read calls to the hard disk
  7720                                  ;		and handles them appropriately.  For other functions it
  7721                                  ;		passes controll to OLD13, which should contain the
  7722                                  ;		address of the AT ROM disk routine. The entry point for
  7723                                  ;		this program is IBM_DISK_IO.
  7724                                  ;
  7725                                  
  7726                                  	; .286c		;Use 80286 non-protected mode
  7727                                  
  7728                                  BIOSEG	equ	040h	;Segment for ROM BIOS Data
  7729                                  ROMSEG	equ	0F000h	;Segment of ROM
  7730                                  
  7731                                  BAD_DISK equ	01
  7732                                  
  7733                                  HF_PORT	equ	01F0h
  7734                                  HF_REG_PORT equ	03F6h
  7735                                  
  7736                                  ;*	Offsets into Fixed disk parameter table
  7737                                  FDP_PRECOMP	equ 5
  7738                                  FDP_CONTROL	equ 8
  7739                                  
  7740                                  ;DATA	SEGMENT AT BIOSEG	;ROM BIOS data segment
  7741                                  
  7742                                  	;ORG 42h
  7743                                  ;CMD_BLOCK	DB 6 DUP (?)
  7744                                  
  7745                                  CMD_BLOCK equ 42h ; 6 bytes, hard disk controller command bytes	
  7746                                  
  7747                                  ;*	Offsets into CMD_BLOCK for registers
  7748                                  PRE_COMP equ 0	;Write Pre-compensation
  7749                                  SEC_CNT	 equ 1	;Sector count
  7750                                  SEC_NUM	 equ 2	;Sector number
  7751                                  CYL_LOW	 equ 3	;Cylinder number, low part
  7752                                  CYL_HIGH equ 4	;Cylinder number, high part
  7753                                  DRV_HEAD equ 5	;Drive/Head (Bit 7 = ECC mode, Bit 5 = 512 byte sectors, 
  7754                                  		;            Bit 4 = drive number, Bits 3-0 have head number)
  7755                                  CMD_REG  equ 6	;Command register
  7756                                  
  7757                                  	;ORG 074h
  7758                                  
  7759                                  ;DISK_STATUS1 	DB ?
  7760                                  ;HF_NUM		DB ?
  7761                                  ;CONTROL_BYTE	DB ?
  7762                                  
  7763                                  DISK_STATUS1 equ 74h ; 1 byte
  7764                                  HF_NUM	     equ 75h ; 1 byte
  7765                                  CONTROL_BYTE equ 76h ; 1 byte 	  	
  7766                                  
  7767                                  ;DATA	ENDS
  7768                                  
  7769                                  ;***	Define where the ROM routines are actually located
  7770                                  ;ROM	SEGMENT AT ROMSEG
  7771                                  
  7772                                  	;ORG 02E1Eh
  7773                                  ;ROMCOMMAND PROC FAR
  7774                                  ;ROMCOMMAND ENDP
  7775                                  
  7776                                  ROMCOMMAND equ 02E1Eh
  7777                                  
  7778                                  	;ORG 02E7Fh
  7779                                  ;ROMWAIT PROC FAR
  7780                                  ;ROMWAIT ENDP
  7781                                  
  7782                                  ROMWAIT	equ 02E7Fh
  7783                                  
  7784                                  	;ORG 02EE2h
  7785                                  ;ROMWAIT_DRQ PROC FAR
  7786                                  ;ROMWAIT_DRQ ENDP
  7787                                  
  7788                                  ROMWAIT_DRQ equ 02EE2h
  7789                                  
  7790                                  	;ORG 02EF8h
  7791                                  ;ROMCHECK_STATUS PROC FAR
  7792                                  ;ROMCHECK_STATUS ENDP
  7793                                  
  7794                                  ROMCHECK_STATUS equ 02EF8h
  7795                                  
  7796                                  ;	ORG 02F69h
  7797                                  ;ROMCHECK_DMA PROC FAR
  7798                                  ;ROMCHECK_DMA ENDP
  7799                                   
  7800                                  ROMCHECK_DMA equ 02F69h
  7801                                  
  7802                                  ;	ORG 02F8Eh
  7803                                  ;ROMGET_VEC PROC FAR
  7804                                  ;ROMGET_VEC ENDP
  7805                                  
  7806                                  ROMGET_VEC equ 2F8Eh	
  7807                                  
  7808                                  ;	ORG 0FF65h
  7809                                  ;ROMFRET PROC FAR	;Far return at F000:FF65 in AT ROM.
  7810                                  ;ROMFRET ENDP
  7811                                  
  7812                                  ROMFRET	equ 0FF65h
  7813                                  
  7814                                  ;ROM	ENDS
  7815                                  
  7816                                  
  7817                                  ;CODE	SEGMENT BYTE PUBLIC 'code'
  7818                                  
  7819                                  ;EXTRN	OLD13:DWORD		;Link to AT bios int 13h
  7820                                  
  7821                                  ;PUBLIC	IBM_DISK_IO	
  7822                                  
  7823                                  ;	ASSUME CS:CODE
  7824                                  ;	ASSUME DS:DATA
  7825                                  
  7826                                  
  7827                                  ;***	IBM_DISK_IO - main routine, fixes AT ROM bug
  7828                                  ;
  7829                                  ;	ENTRY:	(AH) = function, 02 or 0A for read.
  7830                                  ;		(DL) = drive number (80h or 81h).
  7831                                  ;		(DH) = head number.
  7832                                  ;		(CH) = cylinder number.
  7833                                  ;		(CL) = Sector number (high 2 bits has cylinder number).
  7834                                  ;		(AL) = number of sectors.
  7835                                  ;		(ES:BX) = address of read buffer.
  7836                                  ;		For more on register contents see ROM BIOS listing.
  7837                                  ;		Stack set up for return by an IRET.
  7838                                  ;
  7839                                  ;	EXIT:	(AH) = status of current operation.
  7840                                  ;		(CY) = 1 IF failed, 0 if successful.
  7841                                  ;		For other register contents see ROM BIOS listing.
  7842                                  ;
  7843                                  ;	USES:	
  7844                                  ;
  7845                                  ;
  7846                                  ;	WARNING: Uses OLD13 vector for non-read calls.
  7847                                  ;		Does direct calls to the AT ROM.
  7848                                  ;		Does segment arithmatic.
  7849                                  ;
  7850                                  ;	EFFECTS: Performs DISK I/O operation.
  7851                                  ;
  7852                                  ;IBM_DISK_IO PROC FAR
  7853                                  
  7854                                  IBM_DISK_IO:
  7855 000025C8 80FA80                  		CMP	DL,80h
  7856 000025CB 720A                    		JB	short ATD1	;Pass through floppy disk calls.
  7857 000025CD 80FC02                  		CMP	AH,02h
  7858 000025D0 740A                    		JE	short ATD2	;Intercept call 02 (read sectors).
  7859 000025D2 80FC0A                  		CMP	AH,0Ah
  7860 000025D5 7405                    		JE	short ATD2	;and call 0Ah (read long).
  7861                                  ATD1:
  7862                                  		; 16/06/2018
  7863 000025D7 2EFF2E[AA00]            		JMP	far [cs:OLD13]	;Use ROM INT 13h handler.
  7864                                  ATD2:
  7865 000025DC 53                      		PUSH	BX
  7866 000025DD 51                      		PUSH	CX
  7867 000025DE 52                      		PUSH	DX
  7868 000025DF 57                      		PUSH	DI
  7869 000025E0 1E                      		PUSH	DS
  7870 000025E1 06                      		PUSH	ES
  7871 000025E2 50                      		PUSH	AX
  7872 000025E3 B84000                  		MOV	AX,BIOSEG	;Establish BIOS segment addressing.
  7873 000025E6 8ED8                    		MOV	DS,AX
  7874 000025E8 C606740000              		MOV	byte [DISK_STATUS1],0 ;Initially no error code.
  7875 000025ED 80E27F                  		AND	DL,07Fh		;Mask to hard disk number
  7876 000025F0 3A167500                		CMP	DL,[HF_NUM]
  7877 000025F4 7207                    		JB	short ATD3	;Disk number in range
  7878 000025F6 C606740001              		MOV	byte [DISK_STATUS1],BAD_DISK
  7879 000025FB EB20                    		JMP	SHORT ATD4	;Disk number out of range error, return
  7880                                  
  7881                                  ATD3:
  7882 000025FD 53                      		PUSH	BX
  7883 000025FE 8CC0                    		MOV	AX,ES		;Make ES:BX to Seg:000x form.
  7884 00002600 C1EB04                  		SHR	BX,4
  7885 00002603 01D8                    		ADD	AX,BX
  7886 00002605 8EC0                    		MOV	ES,AX
  7887 00002607 5B                      		POP	BX
  7888 00002608 83E30F                  		AND	BX,000Fh
  7889 0000260B 0E                      		PUSH	CS
  7890 0000260C E8DD00                  		CALL	CHECK_DMA
  7891 0000260F 720C                    		JC	short ATD4	;Abort if DMA across segment boundary
  7892                                  
  7893 00002611 58                      		POP	AX		;Restore AX register for SETCMD
  7894 00002612 50                      		PUSH	AX
  7895 00002613 E81900                  		CALL	SETCMD		;Set up command block for disk op
  7896 00002616 BAF603                  		MOV	DX,HF_REG_PORT
  7897 00002619 EE                      		OUT	DX,AL		;Write out command modifier
  7898 0000261A E86A00                  		CALL	DOCMD		;Carry out command
  7899                                  ATD4:
  7900 0000261D 58                      		POP	AX
  7901 0000261E 8A267400                		MOV	AH,[DISK_STATUS1] ;On return AH has error code
  7902                                  		; 16/06/2018
  7903                                  		;STC
  7904                                  		;OR	AH,AH
  7905                                  		;JNZ	short ATD5	;Carry set if error
  7906                                  		;CLC
  7907                                  ;ATD5:
  7908 00002622 80FC01                  		cmp	ah,1
  7909 00002625 F5                      		cmc	
  7910                                  
  7911 00002626 07                      		POP	ES
  7912 00002627 1F                      		POP	DS
  7913 00002628 5F                      		POP	DI
  7914 00002629 5A                      		POP	DX
  7915 0000262A 59                      		POP	CX
  7916 0000262B 5B                      		POP	BX
  7917                                  		; 16/06/2018
  7918 0000262C CA0200                  		RETF	2		;Far return, dropping flags
  7919                                  
  7920                                  ;IBM_DISK_IO ENDP
  7921                                  
  7922                                  ;***	SETCMD - Set up CMD_BLOCK for the disk operation
  7923                                  ;
  7924                                  ;	ENTRY:	(DS) = BIOS Data segment.
  7925                                  ;		(ES:BX) in seg:000x form.
  7926                                  ;		Other registers as in INT 13h call
  7927                                  ;	
  7928                                  ;	EXIT:	CMD_BLOCK set up for disk read call.
  7929                                  ;		CONTROL_BYTE set up for disk operation.
  7930                                  ;		(AL) = Control byte modifier
  7931                                  ;
  7932                                  ;
  7933                                  ;	Sets the fields of CMD_BLOCK using the register contents
  7934                                  ;	and the contents of the disk parameter block for the given drive.
  7935                                  ;
  7936                                  ;	WARNING: (AX) destroyed.
  7937                                  ;		Does direct calls to the AT ROM.
  7938                                  ;
  7939                                  
  7940                                  ;SETCMD	PROC NEAR
  7941                                  
  7942                                  SETCMD:
  7943 0000262F A24300                  		MOV	[CMD_BLOCK+SEC_CNT],AL
  7944 00002632 C606480020              		MOV	byte [CMD_BLOCK+CMD_REG],020h ;Assume function 02
  7945 00002637 80FC02                  		CMP	AH, 2
  7946 0000263A 7405                    		JE	short SETC1	;CMD_REG = 20h if function 02 (read)
  7947                                     					;CMD_REG = 22h if function 0A (" long)
  7948 0000263C C606480022              		MOV	byte [CMD_BLOCK+CMD_REG],022h
  7949                                  SETC1:					;No longer need value in AX
  7950 00002641 88C8                    		MOV	AL,CL
  7951 00002643 243F                    		AND	AL,03Fh		;Mask to sector number
  7952 00002645 A24400                  		MOV 	[CMD_BLOCK+SEC_NUM],AL
  7953 00002648 882E4500                		MOV	[CMD_BLOCK+CYL_LOW],CH
  7954 0000264C 88C8                    		MOV	AL,CL
  7955 0000264E C0E806                  		SHR	AL,6		;Get two high bits of cylinder number
  7956 00002651 A24600                  		MOV	[CMD_BLOCK+CYL_HIGH],AL
  7957 00002654 89D0                    		MOV	AX,DX
  7958 00002656 C0E004                  		SHL	AL,4		;Drive number
  7959 00002659 80E40F                  		AND	AH,0Fh
  7960 0000265C 08E0                    		OR	AL,AH		;Head number
  7961 0000265E 0CA0                    		OR	AL,0A0h		;Set ECC and 512 bytes per sector
  7962 00002660 A24700                  		MOV	[CMD_BLOCK+DRV_HEAD],AL
  7963 00002663 06                      		PUSH	ES		;GET_VEC destroys ES:BX
  7964 00002664 53                      		PUSH	BX
  7965 00002665 0E                      		PUSH	CS
  7966 00002666 E85B00                  		CALL	GET_VEC
  7967                                  					;Write pre-comp from disk parameters
  7968 00002669 268B4705                		MOV	AX,[ES:BX+FDP_PRECOMP]
  7969 0000266D C1E802                  		SHR	AX,2
  7970 00002670 A24200                  		MOV	[CMD_BLOCK+PRE_COMP],AL	;Only use low part
  7971 00002673 268A4708                		MOV	AL,[ES:BX+FDP_CONTROL]	;Control byte modifier
  7972 00002677 5B                      		POP	BX
  7973 00002678 07                      		POP	ES
  7974 00002679 8A267600                		MOV	AH,[CONTROL_BYTE]
  7975 0000267D 80E4C0                  		AND	AH,0C0h		;Keep disable retry bits
  7976 00002680 08C4                    		OR	AH,AL
  7977 00002682 88267600                		MOV	[CONTROL_BYTE],AH
  7978 00002686 C3                      		RETN
  7979                                  
  7980                                  ;SETCMD	ENDP	
  7981                                  
  7982                                  ;***	DOCMD - Carry out READ operation to AT hard disk
  7983                                  ;
  7984                                  ;	ENTRY:	(ES:BX) = address for read in data.
  7985                                  ;		CMD_BLOCK set up for disk read.
  7986                                  ;
  7987                                  ;	EXIT:	Buffer at (ES:BX) contains data read.
  7988                                  ;		DISK_STATUS1 set to error code (0 if success).
  7989                                  ;
  7990                                  ;	
  7991                                  ;
  7992                                  ;	WARNING: (AX), (BL), (CX), (DX), (DI) destroyed.
  7993                                  ;		No check is made for DMA boundary overrun.
  7994                                  ;
  7995                                  ;	EFFECTS: Programs disk controller.
  7996                                  ;		Performs disk input.
  7997                                  ;
  7998                                  
  7999                                  ;DOCMD	PROC NEAR
  8000                                  DOCMD:
  8001 00002687 89DF                    		MOV	DI,BX	;(ES:DI) = data buffer addr.
  8002 00002689 0E                      		PUSH	CS
  8003 0000268A E83F00                  		CALL	COMMAND
  8004 0000268D 7534                    		JNZ	short DOC3
  8005                                  DOC1:
  8006 0000268F 0E                      		PUSH	CS
  8007 00002690 E84100                  		CALL	_WAIT	;Wait for controller to complete read
  8008 00002693 752E                    		JNZ	short DOC3
  8009 00002695 B90001                  		MOV	CX,100h	;256 words per sector
  8010 00002698 BAF001                  		MOV	DX,HF_PORT
  8011 0000269B FC                      		CLD		;String op goes up
  8012 0000269C FA                      		CLI		;Disable interrupts (BUG WAS FORGETTING THIS)
  8013 0000269D F36D                    		REPZ	INSW	;Read in sector
  8014 0000269F FB                      		STI
  8015 000026A0 F606480002              		TEST	byte [CMD_BLOCK+CMD_REG],02h
  8016 000026A5 7410                    		JZ	short DOC2 ;No ECC bytes to read.
  8017 000026A7 0E                      		PUSH	CS
  8018 000026A8 E83100                  		CALL	WAIT_DRQ
  8019 000026AB 7216                    		JC	short DOC3
  8020 000026AD B90400                  		MOV	CX,4	;4 bytes of ECC
  8021 000026B0 BAF001                  		MOV	DX,HF_PORT
  8022 000026B3 FA                      		CLI
  8023 000026B4 F36C                    		REPZ	INSB	;Read in ECC
  8024 000026B6 FB                      		STI
  8025                                  DOC2:
  8026 000026B7 0E                      		PUSH	CS
  8027 000026B8 E82900                  		CALL	CHECK_STATUS
  8028 000026BB 7506                    		JNZ	short DOC3 ;Operation failed
  8029 000026BD FE0E4300                		DEC	byte  [CMD_BLOCK+SEC_CNT]	
  8030 000026C1 75CC                    		JNZ	short DOC1 ;Loop while more sectors to read
  8031                                  DOC3:
  8032 000026C3 C3                      		RETN
  8033                                  
  8034                                  ;DOCMD	ENDP
  8035                                  
  8036                                  ;***	GET_VEC - Get pointer to hard disk parameters.
  8037                                  ;
  8038                                  ;	ENTRY:	(DL) = Low bit has hard disk number (0 or 1).
  8039                                  ;
  8040                                  ;	EXIT:	(ES:BX) = address of disk parameters table.
  8041                                  ;
  8042                                  ;	USES:	AX for segment computation.
  8043                                  ;
  8044                                  ;	Loads ES:BX from interrupt table in low memory, vector 46h (disk 0)
  8045                                  ;	or 70h (disk 1).
  8046                                  ;	
  8047                                  ;	WARNING: (AX) destroyed.
  8048                                  ;		This does a direct call to the AT ROM.
  8049                                  ;
  8050                                  
  8051                                  ;GET_VEC PROC NEAR
  8052                                  GET_VEC:
  8053                                  		;PUSH	OFFSET ROMFRET
  8054 000026C4 6865FF                  		push	ROMFRET
  8055                                  		;JMP	ROMGET_VEC
  8056 000026C7 EA8E2F00F0              		jmp	ROMSEG:ROMGET_VEC
  8057                                  ;GET_VEC ENDP
  8058                                  
  8059                                  ;***	COMMAND - Send contents of CMD_BLOCK to disk controller.
  8060                                  ;
  8061                                  ;	ENTRY:	Control_byte 
  8062                                  ;		CMD_BLOCK - set up with values for hard disk controller.
  8063                                  ;
  8064                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8065                                  ;		NZ if error, ZR for no error.
  8066                                  ;
  8067                                  ;
  8068                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8069                                  ;		Does a direct call to the AT ROM.
  8070                                  ;
  8071                                  ;	EFFECTS: Programs disk controller.
  8072                                  ;
  8073                                  
  8074                                  ;COMMAND PROC NEAR
  8075                                  COMMAND:
  8076                                  		;PUSH	OFFSET ROMFRET
  8077 000026CC 6865FF                  		push	ROMFRET	
  8078                                  		;JMP	ROMCOMMAND
  8079 000026CF EA1E2E00F0              		jmp	ROMSEG:ROMCOMMAND
  8080                                  ;COMMAND ENDP
  8081                                  
  8082                                  ;***	WAIT - Wait for disk interrupt
  8083                                  ;
  8084                                  ;	ENTRY:	Nothing.
  8085                                  ;
  8086                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8087                                  ;		NZ if error, ZR if no error.
  8088                                  ;
  8089                                  ;
  8090                                  ;	WARNING: (AX), (BL), (CX) destroyed.
  8091                                  ;		Does a direct call to the AT ROM.
  8092                                  ;		
  8093                                  ;	EFFECTS: Calls int 15h, function 9000h.
  8094                                  ;
  8095                                  
  8096                                  ;WAIT	PROC NEAR
  8097                                  _WAIT:
  8098                                  		;PUSH	OFFSET ROMFRET 
  8099 000026D4 6865FF                  		push	ROMFRET
  8100                                  		;JMP	ROMWAIT
  8101 000026D7 EA7F2E00F0              		jmp	ROMSEG:ROMWAIT
  8102                                  ;WAIT	ENDP
  8103                                  
  8104                                  ;***	WAIT_DRQ - Wait for data request.
  8105                                  ;
  8106                                  ;	ENTRY:	Nothing.
  8107                                  ;
  8108                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8109                                  ;		CY if error, NC if no error.
  8110                                  ;
  8111                                  ;
  8112                                  ;	WARNING: (AL), (CX), (DX) destroyed.
  8113                                  ;		Does a direct call to the AT ROM.
  8114                                  ;
  8115                                  
  8116                                  ;WAIT_DRQ PROC NEAR
  8117                                  WAIT_DRQ:
  8118                                  		;PUSH	OFFSET ROMFRET 
  8119 000026DC 6865FF                  		push	ROMFRET
  8120                                  		;JMP	ROMWAIT_DRQ
  8121 000026DF EAE22E00F0              		jmp	ROMSEG:ROMWAIT_DRQ
  8122                                  ;WAIT_DRQ ENDP
  8123                                  
  8124                                  ;***	CHECK_STATUS - Check hard disk status.
  8125                                  ;
  8126                                  ;	ENTRY:	Nothing.
  8127                                  ;
  8128                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8129                                  ;		NZ if error, ZR if no error.
  8130                                  ;
  8131                                  ;
  8132                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8133                                  ;		Does a direct call to the AT ROM.
  8134                                  ;
  8135                                  
  8136                                  ;CHECK_STATUS PROC NEAR
  8137                                  CHECK_STATUS:
  8138                                  		;PUSH	OFFSET ROMFRET 
  8139 000026E4 6865FF                  		push	ROMFRET
  8140                                  		;JMP	ROMCHECK_STATUS
  8141 000026E7 EAF82E00F0              		jmp	ROMSEG:ROMCHECK_STATUS
  8142                                  ;CHECK_STATUS ENDP
  8143                                  
  8144                                  ;***	CHECK_DMA - check for DMA overrun 64k segment.
  8145                                  ;
  8146                                  ;	ENTRY:	(ES:BX) = addr. of memory buffer in seg:000x form.
  8147                                  ;		CMD_BLOCK set up for operation.
  8148                                  ;
  8149                                  ;	EXIT:	DISK_STATUS1 - Error code.
  8150                                  ;		CY if error, NC if no error.
  8151                                  ;
  8152                                  ;
  8153                                  ;	WARNING: Does a direct call to the AT ROM.
  8154                                  ;
  8155                                  
  8156                                  ;CHECK_DMA PROC NEAR
  8157                                  CHECK_DMA:
  8158                                  		;PUSH	OFFSET ROMFRET 
  8159 000026EC 6865FF                  		push	ROMFRET
  8160                                  		;JMP	ROMCHECK_DMA
  8161 000026EF EA692F00F0              		jmp	ROMSEG:ROMCHECK_DMA	
  8162                                  ;CHECK_DMA ENDP
  8163                                  
  8164                                  
  8165                                  ;CODE	ENDS
  8166                                  ;	END
  8167                                  
  8168                                  ;-----------------------------------------------------------------------------
  8169                                  ; MSINIT.ASM - MSDOS 3.3 - 02/02/1988
  8170                                  ;-----------------------------------------------------------------------------
  8171                                  ; 02/06/2018 - Retro DOS v3.0
  8172                                  ; 19/03/2018 - Retro DOS v2.0
  8173                                  
  8174                                  ENDATROM:
  8175                                  
  8176                                  ;CMOS Clock setting support routines used by MSCLOCK.		
  8177                                  ;Warning!!! This code will be dynamically relocated by MSINIT.
  8178                                  
  8179                                  Daycnt_To_Day:
  8180                                  ;Entry: [DAYCNT] = number of days since 1-1-80
  8181                                  ;Return: CH=centry in BCD, CL=year in BCD, DH=month in BCD, DL=day in BCD
  8182                                  									 
  8183 000026F4 2EFF36[8804]            		push	word [cs:DAYCNT]	;save daycnt			 
  8184 000026F9 2E813E[8804]891C        		cmp	word [cs:DAYCNT], (365*20+(20/4)) 
  8185                                  						;# days from 1-1-1980 to 1-1-2000
  8186 00002700 730E                    		jae	short century20						 
  8187 00002702 2EC606[8B04]13          		mov	byte [cs:base_century], 19					 
  8188 00002708 2EC606[8C04]50          		mov	byte [cs:base_year], 80						 
  8189 0000270E EB13                    		jmp	short years							 
  8190                                  century20:				;20th century			 
  8191 00002710 2EC606[8B04]14          		mov	byte [cs:base_century], 20					 
  8192 00002716 2EC606[8C04]00          		mov	byte [cs:base_year], 0						 
  8193 0000271C 2E812E[8804]891C        		sub	word [cs:DAYCNT], (365*20+(20/4)) ;adjust daycnt			 
  8194                                  years:									 
  8195 00002723 31D2                    		xor	dx, dx							 
  8196 00002725 2EA1[8804]              		mov	ax, [cs:DAYCNT]						 
  8197 00002729 BBB505                  		mov	bx, (366+365*3) 	;# of days in a Leap year block  
  8198 0000272C F7F3                    		div	bx			;AX = # of leap block, DX=daycnt 
  8199 0000272E 2E8916[8804]            		mov	[cs:DAYCNT], dx		;save daycnt left		 
  8200                                  ;	or	ah, ah				;ax should be less than 256	 
  8201                                  ;	jz	short OK1							 
  8202                                  ;	jmp	Erroroccur						 
  8203                                  ;OK1:									 
  8204 00002733 B304                    		mov	bl, 4							 
  8205 00002735 F6E3                    		mul	bl			;AX=# of years. Less than 100	 
  8206 00002737 2E0006[8C04]            		add	[cs:base_year], al	;So, ah = 0. Adjust year	 
  8207 0000273C 2EFF06[8804]            		inc	word [cs:DAYCNT]	;set daycnt to 1 base		 
  8208 00002741 2E813E[8804]6E01        		cmp	word [cs:DAYCNT], 366	;daycnt=remainder of leap year bk
  8209 00002748 7626                    		jbe	short Leapyear		;within 366+355+355+355 days.	 
  8210 0000274A 2EFE06[8C04]            		inc	byte [cs:base_year]	;if daycnt <= 366, then leap year
  8211 0000274F 2E812E[8804]6E01        		sub	word [cs:DAYCNT], 366	;else daycnt--, base_year++;	 
  8212                                  					;And next three years are normal 
  8213 00002756 B90300                  		mov	cx, 3							 
  8214                                  Regularyear:								 
  8215 00002759 2E813E[8804]6D01        		cmp	word [cs:DAYCNT], 365	;for(i=1; i>3 or daycnt <=365;i++)
  8216 00002760 7614                    		jbe	short Yeardone		;{if (daycnt > 365)		
  8217 00002762 2EFE06[8C04]            		inc	byte [cs:base_year]	;  { daycnt -= 365		
  8218 00002767 2E812E[8804]6D01        		sub	word [cs:DAYCNT], 365	;  }				
  8219 0000276E E2E9                    		loop	Regularyear		;}				
  8220                                  ;	jmp	Erroroccur		 ;cannot come to here		
  8221                                  Leapyear:								
  8222 00002770 2EC606[8E04]1D          		mov	byte [cs:month_tab+1],29 ;leap year. change month table. 
  8223                                  Yeardone:								
  8224 00002776 31DB                    		xor	bx, bx							
  8225 00002778 31D2                    		xor	dx, dx							
  8226 0000277A 2EA1[8804]              		mov	ax, [cs:DAYCNT]						
  8227 0000277E BE[8D04]                		mov	si, month_tab					
  8228 00002781 B90C00                  		mov	cx, 12							
  8229                                  Months: 								
  8230 00002784 FEC3                    		inc	bl			;				
  8231                                  		;mov	dl, [si] ; 28/03/2018
  8232 00002786 2E8A14                  		mov	dl, [cs:si]		;cmp daycnt for each month til fit
  8233 00002789 39D0                    		cmp	ax, dx			;dh=0.				 
  8234 0000278B 7605                    		jbe	short Month_done						 
  8235 0000278D 46                      		inc	si			;next month			 
  8236 0000278E 29D0                    		sub	ax, dx			;adjust daycnt			 
  8237 00002790 E2F2                    		loop	Months							 
  8238                                  ;	jmp	Erroroccur						 
  8239                                  Month_done:								 
  8240 00002792 2EC606[8E04]1C          		mov	byte [cs:month_tab+1], 28 ;restore month table value	 
  8241 00002798 88DA                    		mov	dl, bl							 
  8242 0000279A 2E8A36[8C04]            		mov	dh, [cs:base_year]						 
  8243 0000279F 2E8A0E[8B04]            		mov	cl, [cs:base_century]	;al=day,dl=month,dh=year,cl=cntry
  8244 000027A4 2EFF16[9904]            		call	word [cs:BinToBCD]	;To save 15 bytes, Bin_To_BCD proc
  8245                                  						;was rel from Daycnt_to_Day proc. 
  8246                                  ;	call Bin_To_BCD 			;convert "day" to bcd             
  8247 000027A9 86D0                    		xchg	dl, al			;dl = bcd day, al = month	  
  8248 000027AB 2EFF16[9904]            		call	word [cs:BinToBCD]					  
  8249                                  ;	call Bin_To_BCD 						  
  8250 000027B0 86F0                    		xchg	dh, al			;dh = bcd month, al = year	  
  8251 000027B2 2EFF16[9904]            		call	word [cs:BinToBCD]					  
  8252                                  ;	call Bin_To_BCD 						  
  8253 000027B7 86C8                    		xchg	cl, al			;cl = bcd year, al = century	 
  8254 000027B9 2EFF16[9904]            		call	word [cs:BinToBCD]					 
  8255                                  ;	call Bin_To_BCD						 
  8256 000027BE 88C5                    		mov	ch, al			;ch = bcd century		 
  8257 000027C0 2E8F06[8804]            		pop	word [cs:DAYCNT]	;restore original value 	 
  8258 000027C5 C3                      		retn								 
  8259                                  						 
  8260                                  	;public	EndDaycntToDay						 
  8261                                  EndDaycntToDay:						 
  8262                                  									 
  8263                                  	;public	Bin_To_BCD						 
  8264                                  Bin_To_BCD:			; real time clock sup
  8265                                  ;Convert a binary input in AL (less than 63h or 99 decimal)
  8266                                  ;into a bcd value in AL.  AH destroyed. 			
  8267 000027C6 51                      		push	cx						
  8268 000027C7 30E4                    		xor	ah, ah						
  8269 000027C9 B10A                    		mov	cl, 10						
  8270 000027CB F6F1                    		div	cl			;al=high digit bcd, ah=low digit bcd
  8271 000027CD B104                    		mov	cl, 4						
  8272 000027CF D2E0                    		shl	al, cl			;mov the high digit to high nibble
  8273 000027D1 08E0                    		or	al, ah							
  8274 000027D3 59                      		pop	cx							
  8275 000027D4 C3                      		retn								
  8276                                  					
  8277                                  	;Public	EndCMOSClockset 	;End of routines for CMOS clock 
  8278                                  EndCMOSClockSet:
  8279                                  
  8280                                  		;evenb
  8281 000027D5 90                      align 2
  8282                                  
  8283                                  ; 02/06/2018 - Retro DOS v3.0
  8284                                  
  8285                                  ;									
  8286                                  ; THE K09 REQUIRES ROUTINES FOR READING THE CLOCK BECAUSE OF THE SUSPEND/
  8287                                  ; RESUME FACILITY. THE SYSTEM CLOCK NEEDS TO BE RESET AFTER RESUME.	 
  8288                                  ;
  8289                                  
  8290                                  ;	ASSUME	ES:NOTHING									 
  8291                                  									 
  8292                                  ; THE FOLLOWING ROUTINE IS EXECUTED AT RESUME TIME WHEN THE SYSTEM	 
  8293                                  ; POWERED ON AFTER SUSPENSION. IT READS THE REAL TIME CLOCK AND 	 
  8294                                  ; RESETS THE SYSTEM TIME AND DATE, AND THEN IRETS.			 
  8295                                  ; Warning!!! This code will be dynamically relocated by MSINIT.
  8296                                  
  8297                                  ;INT6C	PROC	FAR							 
  8298                                  
  8299                                  INT6C:
  8300 000027D6 0E                      		PUSH	CS							 
  8301 000027D7 1F                      		POP	DS							 
  8302                                  									 
  8303                                  	;ASSUME DS:CODE							 
  8304                                  									 
  8305 000027D8 8F06[2006]              		POP	WORD [INT6C_RET_ADDR] ; POP OFF RETURN ADDRESS	 
  8306 000027DC 8F06[2206]              		POP	WORD [INT6C_RET_ADDR+2]				 
  8307 000027E0 9D                      		POPF								 
  8308 000027E1 E81300                  		CALL	READ_REAL_DATE		; GET THE DATE FROM THE CLOCK	 
  8309 000027E4 FA                      		CLI								 
  8310 000027E5 8936[8804]              		MOV	[DAYCNT],SI		; UPDATE DOS COPY OF DATE 	 
  8311 000027E9 FB                      		STI								 
  8312 000027EA E8C000                  		CALL	READ_REAL_TIME		; GET THE TIME FROM THE RTC	 
  8313 000027ED FA                      		CLI								 
  8314 000027EE B401                    		MOV	AH,01h			; COMMAND TO SET THE TIME
  8315 000027F0 CD1A                    		INT	1Ah			; CALL ROM-BIOS TIME ROUTINE 
  8316 000027F2 FB                      		STI								
  8317 000027F3 FF2E[2006]              		JMP	far [INT6C_RET_ADDR]	; LONG JUMP			
  8318                                  									
  8319                                  ;INT6C	ENDP
  8320                                  
  8321                                  	;INCLUDE READCLOCK.INC						
  8322                                  	;INCLUDE CLOCKSUB.INC								
  8323                                  
  8324                                  ; 26/03/2018 - READCLOCK.INC, MSDOS 3.3, 24/07/1987
  8325                                  
  8326                                  ;************************************************************************
  8327                                  ;
  8328                                  ;   read_real_date reads real-time clock for date and returns the number
  8329                                  ;   of days elapsed since 1-1-80 in si
  8330                                  ;
  8331                                  READ_REAL_DATE: 			;MJB002
  8332 000027F7 50                      		PUSH	AX
  8333 000027F8 51                      		PUSH	CX
  8334 000027F9 52                      		PUSH	DX
  8335 000027FA 30E4                    		XOR	AH,AH		; throw away clock roll over
  8336 000027FC CD1A                    		INT	1AH					
  8337 000027FE 5A                      		POP	DX
  8338 000027FF 59                      		POP	CX
  8339 00002800 58                      		POP	AX
  8340                                  
  8341 00002801 50                      		PUSH	AX
  8342 00002802 53                      		PUSH	BX
  8343 00002803 51                      		PUSH	CX
  8344 00002804 52                      		PUSH	DX
  8345                                  		;mov	word [CS:DAYCNT2],1 ; REAL TIME CLOCK ERROR FLAG (+1 DAY)
  8346 00002805 C706[4006]0100          		mov	word [DAYCNT2],1
  8347 0000280B B404                    		mov	AH,4		; read date function code       
  8348 0000280D CD1A                    		int	1Ah		; read real-time clock	     
  8349                                  		;jnc	short read_ok 	; jmp success
  8350                                  		;jmp	r_d_ret 	; jmp error
  8351 0000280F 0F828B00                		jc	r_d_ret
  8352                                  read_ok:				; ******* get bcd values in binary *****
  8353 00002813 882E[2406]              		mov	[BIN_DATE_TIME+0],ch  ; store as hex value
  8354 00002817 880E[2506]              		mov	[BIN_DATE_TIME+1],cl  ; ...
  8355 0000281B 8836[2606]              		mov	[BIN_DATE_TIME+2],dh  ; ...
  8356 0000281F 8816[2706]              		mov	[BIN_DATE_TIME+3],dl  ; ...
  8357                                  		;mov	word [CS:DAYCNT2],2  ; READ OF R-T CLOCK SUCCESSFUL
  8358 00002823 C706[4006]0200          		mov	word [DAYCNT2],2
  8359 00002829 E84C01                  		call	bcd_verify	; verify bcd values in range
  8360 0000282C 7270                    		jc	short r_d_ret 	; jmp some value out of range
  8361                                  		;mov	word [CS:DAYCNT2],3  ; READ OF R-T CLOCK SUCCESSFUL
  8362 0000282E C706[4006]0300          		mov	word [DAYCNT2],3
  8363 00002834 E8EA00                  		call	date_verify	; verify date values in range
  8364 00002837 7265                    		jc	short r_d_ret 	; jmp some value out of range
  8365                                  		;mov	word [CS:DAYCNT2],0  ; VERIFY SUCCESSFUL		  
  8366 00002839 C706[4006]0000          		mov	word [DAYCNT2],0
  8367 0000283F E8A400                  		call	in_bin		; convert date to binary
  8368                                  					; ******* years since 1-1-80 *********
  8369 00002842 A0[2506]                		mov	al,[BIN_DATE_TIME+1]  ; get years into century
  8370 00002845 98                      		cbw				     ;
  8371 00002846 803E[2406]14            		cmp	byte [BIN_DATE_TIME+0],20  ; 20th century?
  8372 0000284B 7503                    		jnz	short century_19 ; jmp no
  8373 0000284D 83C064                  		add	ax,100		; add in a century
  8374                                  century_19:			;
  8375 00002850 83E850                  		sub	ax,80		; subtract off 1-1-80
  8376 00002853 B104                    		mov	cl,4		; leap year every 4
  8377 00002855 F6F1                    		div	cl		; al= # leap year blocks, ah= remainder
  8378 00002857 88E3                    		mov	bl,ah		; save odd years
  8379 00002859 98                      		cbw			; zero ah
  8380 0000285A B9B505                  		mov	cx,366+3*365	; # of days in leap year blocks
  8381 0000285D F7E1                    		mul	cx		; dx:ax is result
  8382                                  		;mov	[CS:DAYCNT2],AX	; SAVE COUNT OF DAYS
  8383 0000285F A3[4006]                		mov	[DAYCNT2],AX
  8384 00002862 88D8                    		mov	al,bl		; get odd years count
  8385 00002864 98                      		cbw			;
  8386 00002865 09C0                    		or	ax,ax		; is ax= 0?
  8387 00002867 740B                    		jz	short leap_year	; jmp if none
  8388 00002869 B96D01                  		mov	cx,365		; days in year
  8389 0000286C F7E1                    		mul	cx		; dx:ax is result
  8390                                  		;add	[CS:DAYCNT2],AX ; ADD ON DAYS IN ODD YEARS
  8391 0000286E 0106[4006]              		add	[DAYCNT2],AX
  8392 00002872 EB07                    		jmp	short leap_adjustment ; account for leap year
  8393                                  leap_year:			; possibly account for a leap day
  8394 00002874 803E[2606]02            		cmp	byte [BIN_DATE_TIME+2],2 ; is month february
  8395 00002879 7604                    		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
  8396                                  leap_adjustment:			; account for leap day
  8397                                  		;INC	word [CS:DAYCNT2] ; ...
  8398 0000287B FF06[4006]              		INC	word [DAYCNT2]
  8399                                  no_leap_adjustment:			; ******* get days of month *******
  8400 0000287F 8A0E[2706]              		mov	cl,[BIN_DATE_TIME+3] ; ...
  8401 00002883 30ED                    		xor	ch,ch		;
  8402 00002885 49                      		dec	cx		; because of offset from day 1, not day 0
  8403                                  		;add	[CS:DAYCNT2],CX	; ******* GET DAYS IN MONTHS PRECEEDING *****
  8404 00002886 010E[4006]              		add	[DAYCNT2],CX
  8405 0000288A 8A0E[2606]              		mov	cl,[BIN_DATE_TIME+2] ; get month
  8406 0000288E 30ED                    		xor	ch,ch		;
  8407 00002890 49                      		dec	cx		; january starts at offset 0
  8408 00002891 D1E1                    		shl	cx,1		; word offset
  8409 00002893 BE[2806]                		mov	si,MONTH_TABLE	; beginning of month_table
  8410 00002896 01CE                    		add	si,cx		; point into month table
  8411 00002898 8B04                    		mov	ax,[si]		; get # days in previous months
  8412                                  		;add	[CS:DAYCNT2],AX ; ...
  8413 0000289A 0106[4006]              		add	[DAYCNT2],AX
  8414                                  r_d_ret:			;
  8415                                  		;MOV	SI,[CS:DAYCNT2] ; RESULT IN SI
  8416 0000289E 8B36[4006]              		MOV	SI,[DAYCNT2]
  8417 000028A2 5A                      		POP	DX
  8418 000028A3 59                      		POP	CX
  8419 000028A4 5B                      		POP	BX
  8420 000028A5 58                      		POP	AX
  8421 000028A6 C3                      		retn			;
  8422                                  
  8423                                  r_t_retj:
  8424 000028A7 31C9                    		xor	cx,cx
  8425 000028A9 31D2                    		xor	dx,dx
  8426 000028AB EB38                    		jmp	short r_t_ret
  8427                                  ;
  8428                                  ; Read_Real_Time reads the time from the RTC. on exit, it has the number of
  8429                                  ; ticks (at 18.2 ticks per sec.) in CX:DX.
  8430                                  ;
  8431                                  READ_REAL_TIME:
  8432 000028AD B402                    		mov	ah,2
  8433 000028AF CD1A                    		int	1AH
  8434 000028B1 72F4                    		jc	short r_t_retj
  8435                                  oktime:
  8436 000028B3 882E[2406]              		mov	[BIN_DATE_TIME],ch		; hours
  8437 000028B7 880E[2506]              		mov	[BIN_DATE_TIME+1],cl		; minutes
  8438 000028BB 8836[2606]              		mov	[BIN_DATE_TIME+2],dh		; seconds
  8439 000028BF C606[2706]00            		mov	byte [BIN_DATE_TIME+3],0	; unused for time
  8440 000028C4 E8B100                  		call	bcd_verify
  8441 000028C7 72DE                    		jc	short r_t_retj
  8442 000028C9 E89300                  		call	time_verify
  8443 000028CC 72D9                    		jc	short r_t_retj
  8444 000028CE E81500                  		call	in_bin
  8445 000028D1 8A2E[2406]              		mov	ch,[BIN_DATE_TIME]
  8446 000028D5 8A0E[2506]              		mov	cl,[BIN_DATE_TIME+1]
  8447 000028D9 8A36[2606]              		mov	dh,[BIN_DATE_TIME+2]
  8448 000028DD 8A16[2706]              		mov	dl,[BIN_DATE_TIME+3]
  8449                                  ; get time in ticks in CX:DX
  8450                                  		;CALL	near [cs:TimeToTicks]
  8451 000028E1 FF16[AD0D]              		CALL	word [TimeToTicks]
  8452                                  r_t_ret:
  8453 000028E5 C3                      		retn
  8454                                  
  8455                                  ;
  8456                                  ;   in_bin converts bin_date_time values from bcd to bin
  8457                                  ;
  8458                                  in_bin: 			      ;
  8459 000028E6 A0[2406]                		mov	al,[BIN_DATE_TIME+0]  ; century or hours
  8460 000028E9 E81F00                  		call	bcd_to_bin	      ; ...
  8461 000028EC A2[2406]                		mov	[BIN_DATE_TIME+0],al  ;
  8462 000028EF A0[2506]                		mov	al,[BIN_DATE_TIME+1]  ; years or minutes
  8463 000028F2 E81600                  		call	bcd_to_bin	      ; ...
  8464 000028F5 A2[2506]                		mov	[BIN_DATE_TIME+1],al  ;
  8465 000028F8 A0[2606]                		mov	al,[BIN_DATE_TIME+2]  ; months or seconds
  8466 000028FB E80D00                  		call	bcd_to_bin	      ; ...
  8467 000028FE A2[2606]                		mov	[BIN_DATE_TIME+2],al  ;
  8468 00002901 A0[2706]                		mov	al,[BIN_DATE_TIME+3]  ; days (not used for time)
  8469 00002904 E80400                  		call	bcd_to_bin	      ; ...
  8470 00002907 A2[2706]                		mov	[BIN_DATE_TIME+3],al  ;
  8471 0000290A C3                      		retn			      ;
  8472                                  ;
  8473                                  ;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
  8474                                  ;   a binary representation in al
  8475                                  ;   ah is destroyed
  8476                                  ;
  8477                                  bcd_to_bin:				;
  8478 0000290B 88C4                    		mov	ah,al		; copy bcd number to ah
  8479 0000290D 250FF0                  		and	ax,0F00Fh	; clear unwanted nibbles
  8480 00002910 88C3                    		mov	bl,al		; save units place
  8481 00002912 86E0                    		xchg	ah,al		; 10's place to al
  8482 00002914 30E4                    		xor	ah,ah		; ah not wanted
  8483 00002916 B104                    		mov	cl,4		; shift count
  8484 00002918 D3E8                    		shr	ax,cl		;mjb004 swap nibbles
  8485 0000291A B10A                    		mov	cl,10		; convert al to ...
  8486 0000291C F6E1                    		mul	cl		; ... its binary value
  8487 0000291E 00D8                    		add	al,bl		; add in units
  8488 00002920 C3                      		retn
  8489                                  
  8490                                  ; 26/03/2018 - CLOCKSUB.INC, MSDOS 3.3, 24/07/1987					
  8491                                  
  8492                                  ;
  8493                                  ;   date_verify loosely checks bcd date values to be in range in bin_date_time
  8494                                  ;
  8495                                  date_verify:				    	    ;
  8496 00002921 803E[2406]20            		cmp	byte [BIN_DATE_TIME+0],20h  ; century check
  8497 00002926 7735                    		ja	short date_error	    ; jmp error
  8498 00002928 740E                    		jz	short century_20	    ; jmp in 20th century
  8499 0000292A 803E[2406]19            		cmp	byte [BIN_DATE_TIME+0],19h  ; century check
  8500 0000292F 722C                    		jb	short date_error	    ; jmp error
  8501 00002931 803E[2506]80            		cmp	byte [BIN_DATE_TIME+1],80h  ; year check
  8502 00002936 7225                    		jb	short date_error	    ; jmp error
  8503                                  century_20:				    	    ;
  8504 00002938 803E[2506]99            		cmp	byte [BIN_DATE_TIME+1],99h  ; year check
  8505 0000293D 771E                    		ja	short date_error	    ; jmp error
  8506 0000293F 803E[2606]12            		cmp	byte [BIN_DATE_TIME+2],12h  ; month check
  8507 00002944 7717                    		ja	short date_error	    ; jmp error
  8508 00002946 803E[2606]00            		cmp	byte [BIN_DATE_TIME+2],00h  ; month check
  8509 0000294B 7610                    		jbe	short date_error	    ; jmp error
  8510 0000294D 803E[2706]31            		cmp	byte [BIN_DATE_TIME+3],31h  ; day check
  8511 00002952 7709                    		ja	short date_error	    ; jmp error
  8512 00002954 803E[2706]00            		cmp	byte [BIN_DATE_TIME+3],00h  ; day check
  8513 00002959 7602                    		jbe	short date_error	    ; jmp error
  8514 0000295B F8                      		clc				    ; set success flag
  8515 0000295C C3                      		ret				    ;
  8516                                  date_error:				   	    ;
  8517 0000295D F9                      		stc				    ; set error flag
  8518 0000295E C3                      		retn				    ;
  8519                                  
  8520                                  ;
  8521                                  ; time_verify very loosely checks bcd date values to be in range in bin_date_time
  8522                                  ;
  8523                                  time_verify:
  8524 0000295F 803E[2406]24            		cmp	byte [BIN_DATE_TIME+0],24h
  8525 00002964 7710                    		ja	short time_error
  8526 00002966 803E[2506]59            		cmp	byte [BIN_DATE_TIME+1],59h
  8527 0000296B 7709                    		ja	short time_error
  8528 0000296D 803E[2606]59            		cmp	byte [BIN_DATE_TIME+2],59h
  8529 00002972 7702                    		ja	short time_error
  8530 00002974 F8                      		clc
  8531 00002975 C3                      		retn
  8532                                  time_error:
  8533 00002976 F9                      		stc
  8534 00002977 C3                      		retn
  8535                                  
  8536                                  ;
  8537                                  ;   bcd_verify checks values in bin_date_time to be valid
  8538                                  ;   bcd numerals.  carry set if any nibble out of range
  8539                                  ;
  8540                                  bcd_verify:				  ;
  8541 00002978 B90400                  		mov	cx,4		  ; 4 bytes to check
  8542 0000297B BB[2406]                		mov	bx,BIN_DATE_TIME  ;
  8543                                  bv_loop:				  ;
  8544 0000297E 8A07                    		mov	al,[bx]		  ; get a bcd number (0..99)
  8545 00002980 88C4                    		mov	ah,al		  ;
  8546 00002982 250FF0                  		and	ax,0F00Fh	  ; 10's place in high ah, 1's in al
  8547 00002985 3C0A                    		cmp	al,10		  ; is 1's place in range?
  8548 00002987 7716                    		ja	short bv_error	  ; jmp out of range
  8549 00002989 D0EC                    		shr	ah,1		  ; swap nibbles
  8550 0000298B D0EC                    		shr	ah,1		  ; ...
  8551 0000298D D0EC                    		shr	ah,1		  ; ...
  8552 0000298F D0EC                    		shr	ah,1		  ; ...
  8553 00002991 80E40F                  		and	ah,0fh		  ; get rid of any erroneous bits
  8554 00002994 80FC0A                  		cmp	ah,10		  ; is 10's place in range
  8555 00002997 7706                    		ja	short bv_error	  ; jmp out of range
  8556 00002999 43                      		inc	bx		  ; next byte
  8557 0000299A 49                      		dec	cx		  ;
  8558 0000299B 75E1                    		jnz	short bv_loop 	  ;
  8559 0000299D F8                      		clc			  ; set success flag
  8560 0000299E C3                      		retn			  ;
  8561                                  bv_error:				  ;
  8562 0000299F F9                      		stc			  ; set error flag
  8563 000029A0 C3                      		retn			  ;
  8564                                  
  8565                                  ; 02/06/2018 - Retro DOS v3.0
  8566                                  
  8567                                  ENDK09:
  8568                                  
  8569                                  ;------------------------------------------------------------------------
  8570                                  ;									:
  8571                                  ;	System initialization						:
  8572                                  ;									:
  8573                                  ;	The entry conditions are established by the bootstrap		:
  8574                                  ;	loader and are considered unknown.  The following jobs		:
  8575                                  ;	will be performed by this module:				:
  8576                                  ;									:
  8577                                  ;	1.	All device initialization is performed			:
  8578                                  ;	2.	A local stack is set up and DS:SI are set		:
  8579                                  ;		to point to an initialization table. Then		:
  8580                                  ;		an inter-segment call is made to the first		:
  8581                                  ;		byte of the dos 					:
  8582                                  ;	3.	Once the dos returns from this call the ds		:
  8583                                  ;		register has been set up to point to the start		:
  8584                                  ;		of free memory. The initialization will then		:
  8585                                  ;		load the command program into this area 		:
  8586                                  ;		beginning at 100 hex and transfer control to		:
  8587                                  ;		this program.						:
  8588                                  ;									:
  8589                                  ;------------------------------------------------------------------------
  8590                                  
  8591                                  ; DRVFAT must be the first location of freeable space!
  8592                                  	;EVENB
  8593                                  
  8594 000029A1 90                      align 2
  8595                                  
  8596 000029A2 0000                    DRVFAT:	DW	0			; Drive and FAT ID of DOS
  8597                                  ; 03/07/2018
  8598                                  ;BIOS$:	DW	0			; First sector of data
  8599                                  ;DOSCNT:DW	0			; How many sectors to read
  8600 000029A4 00                      fBigFAT: DB	0			; Flags for drive
  8601                                  ; 01/07/2018
  8602                                  ;FatLen:	DW	0		; number of sectors in FAT.
  8603                                  ;FatLoc:	DW	0		; seg addr of fat sector
  8604                                  
  8605                                  ;;Rev 3.30 Modification -----------------------------------------------
  8606                                  ; THE FOLLOWING TWO BYTES ARE USED TO SAVE INFO RETURNED BY INT 13, AH=8
  8607                                  ; CALL TO DETERMINE DRIVE PARAMETERS.					
  8608 000029A5 02                      NUM_HEADS: DB	2			; NUMBER OF HEADS RETURNED BY ROM
  8609 000029A6 09                      SEC_TRK:   DB	9			; SEC/TRK RETURNED BY ROM	 
  8610 000029A7 28                      NUM_CYLN:  DB	40			; NUMBER OF CYLINDERS RET BY ROM 
  8611                                  									 
  8612                                  ;;End of Modification -----------------------------------------------
  8613                                  
  8614                                  ;BOOTBIAS equ	200H							 
  8615                                  
  8616                                  	;EVENB
  8617                                  align 2
  8618                                  					 
  8619 000029A8 0002000140000000        DiskTable:  DW	512,	0100h,	64,	0
  8620 000029B0 0008010270000000        	    DW	2048,	0201h,	112,	0
  8621 000029B8 0020020400010000        	    DW	8192,	0402h,	256,	0
  8622 000029C0 A87F030800020000        	    DW	32680,	0803h,	512,	0
  8623 000029C8 FFFF041000040000        	    DW	65535,	1004h,	1024,	0
  8624                                  
  8625 000029D0 A87F030800020000        DiskTable2: DW	32680,	0803h,	512,	0
  8626 000029D8 FFFF020400024000        	    DW	65535,	0402h,	512,	fBIG
  8627                                  
  8628                                  ;;Rev 3.30 Modification -----------------------------------------------
  8629                                  
  8630                                  ;*************************************************************************
  8631                                  ;Variables for Mini disk initialization
  8632                                  ;*************************************************************************
  8633 000029E0 0000                    End_Of_BDSM:	dw	0		;offset value of the ending add
  8634                                  					;of BDSM table. Needed to figure
  8635                                  					;the Final_DOS_Location.
  8636 000029E2 00                      numh:		db	0		;number of hard files
  8637 000029E3 00                      mininum: 	db	0		;logical drive num for mini disk 
  8638 000029E4 00                      num_mini_dsk:	db	0		;# of mini disk installed	 
  8639 000029E5 80                      Rom_Minidsk_num: db	80h		;physical mini disk number	 
  8640 000029E6 0000                    Mini_HDLIM:	dw	0						 
  8641 000029E8 0000                    Mini_SECLIM:	dw	0						 
  8642 000029EA 0000                    Mini_BPB_ptr:	dw	0		;temporary variable used to save 
  8643                                  					;Mini Disk BPB pt add in DskDrvs.
  8644                                  ;;End of Modification -----------------------------------------------
  8645                                  
  8646 000029EC 30312F31302F383400      Bios_Date:   DB	'01/10/84',0
  8647                                  
  8648                                  ; 02/06/2018 - Retro DOS v3.0
  8649                                  
  8650                                  PatchTable:
  8651 000029F5 0A00[090F]              		DW	10,Media_Patch
  8652 000029F9 0300[D20F]              		DW	3,GETBP1_PATCH
  8653 000029FD 0300[960F]              		DW	3,SET_PATCH
  8654 00002A01 0300[3712]              		DW	3,DiskIO_PATCH
  8655 00002A05 0300[BB13]              		DW	3,DSKERR
  8656 00002A09 0A00[EF07]              		DW	10,Changed_Patch
  8657 00002A0D 0300[350F]              		DW	3,INIT_PATCH
  8658 00002A11 0000                    		DW	0
  8659                                  
  8660                                  ;-----------------------------------------------------------------------------
  8661                                  
  8662                                  ; 28/03/2018
  8663                                  ; MSDOS 6.0 - MSINIT.ASM, 1991
  8664 00002A13 0000                    init_bootseg:	dw	0	; seg addr of buffer for reading boot record
  8665                                  
  8666                                  BootBias equ 200h ; 19/03/2018
  8667                                  
  8668                                  ;-----------------------------------------------------------------------------
  8669                                  
  8670 00002A15 90<rep Bh>              align 16
  8671                                  
  8672                                  ;-----------------------------------------------------------------------------
  8673                                  ; entry point from boot sector
  8674                                  ;-----------------------------------------------------------------------------
  8675                                  ; 02/06/2018 - Retro DOS v3.0
  8676                                  
  8677                                  ;-----------------------------------------------------------------------------
  8678                                  
  8679                                  ; ----------------------------------------------------------------------------
  8680                                  ; SYSINIT PARAMETER ADDRESS EQUALITIES - 25/02/2018 (MSDOS 2.0 'SYSINIT.ASM')
  8681                                  ; ----------------------------------------------------------------------------
  8682                                  ; ('sysinit.s', 'SYSINIT.BIN')
  8683                                  
  8684                                  ; IN SYSINIT SEGMENT (SYSINITSEG):
  8685                                  
  8686                                  CURRENT_DOS_LOCATION EQU 6   ; dw (segment)
  8687                                  FINAL_DOS_LOCATION   EQU 10  ; dw (segment)
  8688                                  DEVICE_LIST	     EQU 12  ; dd (segment:offset)	
  8689                                  DOSSIZE		     EQU 16  ; dw ; Retro DOS 2.0 - 'MSDOS.BIN' size in words
  8690                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  8691                                  ;MEMORY_SIZE	     EQU 18  ; dw (paragraphs)	
  8692                                  ;DEFAULT_DRIVE	     EQU 20  ; db
  8693                                  SYSI_COUNTRY	     EQU 18  ; dd (segment:offset) - country table pointer	
  8694                                  STACK_COUNT	     EQU 22  ; dw 	
  8695                                  STACK_SIZE	     EQU 24  ; dw
  8696                                  STACK_ADDR	     EQU 26  ; dd (segment:offset)  
  8697                                  MEMORY_SIZE	     EQU 30  ; dw (paragraphs)
  8698                                  DEFAULT_DRIVE	     EQU 32  ; db 	 						
  8699                                  
  8700                                  ;-----------------------------------------------------------------------------
  8701                                  ; initialization - stage 1
  8702                                  ;-----------------------------------------------------------------------------
  8703                                  ; 02/06/2018 - Retro DOS v3.0
  8704                                  
  8705                                  		; Retro DOS 3.0 Modification on MSDOS 3.3 IBMBIO.COM code
  8706                                  		; (Because of Retro DOS 2.0, MSDOS 3.3 boot sector difference)
  8707                                  
  8708                                  INIT:
  8709                                  		; 07/04/2018
  8710                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  8711                                                  ; DL = [bsDriveNumber]
  8712                                  		; DH = [bsMedia]
  8713                                  		; AX = [bsSectors] ; Total sectors
  8714                                  		; DS = 0, SS = 0
  8715                                  		; BP = 7C00h
  8716                                  
  8717                                  		; Move Retro DOS v2.0 boot sector parameters to 0060h:0
  8718 00002A20 BB6000                  		mov	bx, 60h
  8719 00002A23 8EC3                    		mov	es, bx
  8720 00002A25 89EE                    		mov	si, bp
  8721 00002A27 29FF                    		sub	di, di
  8722 00002A29 B92300                  		mov	cx, 35 ; 70 bytes, 35 words
  8723                                  		;mov	cl, 35
  8724 00002A2C F3A5                    		rep	movsw
  8725                                  
  8726 00002A2E 0E                      		push	cs
  8727 00002A2F 1F                      		pop	ds
  8728                                  
  8729                                  		; 27/03/2018
  8730 00002A30 B9E860                  		mov	cx, KERNEL_SIZE	; words !
  8731                                  		; 07/04/2018
  8732                                  		;mov	bx, KERNEL_SEGMENT ; 0070h
  8733 00002A33 B370                    		mov	bl, KERNEL_SEGMENT
  8734 00002A35 8EC3                    		mov	es, bx
  8735 00002A37 31FF                    		xor	di, di
  8736 00002A39 89FE                    		mov	si, di
  8737                                  		
  8738                                  		; Move KERNEL file from 1000h:0 to 0070h:0
  8739                                  		; (Retro DOS v2 BS loads 'MSDOS.SYS' at 1000h:0000h)
  8740 00002A3B F3A5                    		rep	movsw
  8741                                  		; 17/06/2018 
  8742                                  		;mov	ds, bx
  8743                                  INIT0:
  8744 00002A3D 06                      		push	es
  8745 00002A3E 68[422A]                		push	INIT1 ; 07/04/2018
  8746 00002A41 CB                      		retf	; jump to 0070h:INIT1
  8747                                  
  8748                                  ;INIT:
  8749                                  INIT1:
  8750                                  ; 02/06/2018 - Retro DOS v3.0
  8751                                  
  8752                                  		; 19/03/2018
  8753                                  		; Retro DOS v2.0 (24/02/2018)
  8754                                  		; [REF: MSDOS 3.3, MSBIO, "MSINIT.ASM"  (24/07/1987)]
  8755                                  
  8756                                  ;------------------------------------------------------------------------
  8757                                  ;									:
  8758                                  ;	System initialization						:
  8759                                  ;									:
  8760                                  ;	The entry conditions are established by the bootstrap		:
  8761                                  ;	loader and are considered unknown.  The following jobs		:
  8762                                  ;	will be performed by this module:				:
  8763                                  ;									:
  8764                                  ;	1.	All device initialization is performed			:
  8765                                  ;	2.	A local stack is set up and DS:SI are set		:
  8766                                  ;		to point to an initialization table. Then		:
  8767                                  ;		an inter-segment call is made to the first		:
  8768                                  ;		byte of the dos 					:
  8769                                  ;	3.	Once the dos returns from this call the ds		:
  8770                                  ;		register has been set up to point to the start		:
  8771                                  ;		of free memory. The initialization will then		:
  8772                                  ;		load the command program into this area 		:
  8773                                  ;		beginning at 100 hex and transfer control to		:
  8774                                  ;		this program.						:
  8775                                  ;									:
  8776                                  ;------------------------------------------------------------------------
  8777                                  
  8778                                  		; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  8779                                  		EOI	EQU	20H
  8780                                  		AKPORT	EQU	20H
  8781                                  		INITSPOT EQU	534H	; IBM wants 4 zeros here
  8782                                  		BRKADR	EQU	1BH * 4	; 6CH, 1BH break vector address
  8783                                  		TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  8784                                  		DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  8785                                  		SEC9	EQU	522H	; address of disk parameters
  8786                                  		;CHROUT	EQU	29H
  8787                                  		;LSTDRV	EQU     504H
  8788                                  		;;SYSIZE	EQU 200H ;NUMBER OF PARAGRAPHS IN SYSINIT MODULE
  8789                                  		 ; 26/03/2018
  8790                                  		RSINIT	EQU	0A3H
  8791                                  		NORMSETTLE EQU  15
  8792                                  
  8793                                  		; Retro DOS v1.0 (10/02/2018)
  8794                                  		; (Register values from Retro DOS v1.0 Boot Sector)
  8795                                  		; CS = 60h  ; BIO_SEGMENT
  8796                                  		; DS = 0
  8797                                  		; ES = 0
  8798                                  		; SS = 0
  8799                                  		; SP = 0FFFEh
  8800                                   		; BP = 7C00h
  8801                                  		; DL = Physical drive number = 0
  8802                                  		;push	cs
  8803                                  		;pop	ds
  8804                                  
  8805                                  		; Retro DOS v1.0 boot sector (fd0) dos parameters
  8806                                  		; (17 bytes)
  8807                                  		bsBytesPerSec	equ 11
  8808                                  		bsSecPerClust	equ 13
  8809                                  		bsResSectors	equ 14	
  8810                                  		bsFATs		equ 16
  8811                                  		bsRootDirEnts	equ 17
  8812                                  		bsSectors	equ 19	
  8813                                  		bsMedia		equ 21
  8814                                  		bsFATsecs	equ 22
  8815                                  		bsSecPerTrack	equ 24
  8816                                  		bsHeads		equ 26
  8817                                  
  8818                                  		; Retro DOS 1.0 extensions (to boot sector parameters) 
  8819                                  		bsDataStart	equ 64
  8820                                  
  8821                                  		;push	ds
  8822                                  		;pop	es
  8823                                  
  8824                                  		; 14/02/2018
  8825                                  		; Set video mode to 3 (Clear screen)
  8826 00002A42 B80300                  		mov	ax, 3
  8827 00002A45 CD10                    		int	10h
  8828                                  
  8829                                  		; 06/04/2018 - Retro DOS v2.0
  8830                                  		; (IBMDOS 2.1, IBMBIO.COM, 20/10/1983)
  8831                                  		; (by IDA Pro Free Dissassembler)
  8832                                  		; 19/03/2018
  8833                                  		; (Source Code Ref: MSDOS 3.3, MSINIT.ASM, 1991)
  8834                                  		
  8835                                  		; "MSINIT.ASM"
  8836                                  		;---------------------------------------------------------------
  8837                                  		; At this point the registers contain these values:
  8838                                  		;   AX = 0-based drive we booted from
  8839                                  		;   BX = the logical number of the first data sector on the disk
  8840                                  		;   CX = number of floppies including logical one
  8841                                  
  8842                                  		;
  8843                                  		; set up local stack
  8844                                  		;
  8845                                  
  8846                                  		;XOR	BX,BX
  8847                                  		;CLI		; turn interrupts off while manupulating stack
  8848                                  		;MOV	SS,BX	; set stack segment register
  8849                                  		;MOV	SP,700h	; set stack pointer
  8850                                  		;STI		; turn interrupts on
  8851                                  
  8852                                  ; 02/06/2018 - Retro DOS v3.0
  8853                                  
  8854                                  ;
  8855                                  ; Entry from boot sector.  The register contents are:
  8856                                  ;   DL = INT 13 drive number we booted from
  8857                                  ;   CH = media byte
  8858                                  ;   BX = First data sector on disk (0-based)
  8859                                  ;
  8860 00002A47 FA                      		CLI
  8861 00002A48 31C0                    		XOR	AX,AX
  8862 00002A4A 8ED8                    		MOV	DS,AX
  8863                                  ;
  8864                                  ; Preserve original int 13 vector
  8865                                  ;   We need to save INT13 in two places in case we are running on an AT.
  8866                                  ; On ATs we install the IBM supplied ROM_BIOS patch DISK.OBJ which hooks
  8867                                  ; INT13 ahead of ORIG13.  Since INT19 must unhook INT13 to point to the
  8868                                  ; ROM INT13 routine, we must have that ROM address also stored away.
  8869                                  ;
  8870                                  		; 16/06/2018
  8871 00002A4C A14C00                  		MOV	AX,[13h*4]
  8872 00002A4F 2EA3[AA00]              		MOV	[CS:OLD13],AX
  8873 00002A53 2EA3[AE00]              		MOV	[CS:ORIG13],AX
  8874 00002A57 A14E00                  		MOV	AX,[13h*4+2]
  8875 00002A5A 2EA3[AC00]              		MOV	[CS:OLD13+2],AX
  8876 00002A5E 2EA3[B000]              		MOV	[CS:ORIG13+2],AX
  8877                                  
  8878                                  ;
  8879                                  ; Set up INT 13 for new action
  8880                                  ;
  8881 00002A62 C7064C00[E507]          		MOV	WORD [13h*4],Block13
  8882 00002A68 8C0E4E00                		MOV	[13h*4+2],CS
  8883                                  ;
  8884                                  ; Preserve original int 19 vector
  8885                                  ;
  8886 00002A6C A16400                  		MOV	AX,[19h*4]
  8887 00002A6F 2EA3[A805]              		MOV	[CS:ORIG19],AX	
  8888 00002A73 A16600                  		MOV	AX,[19h*4+2]
  8889 00002A76 2EA3[AA05]              		MOV	[CS:ORIG19+2],AX
  8890                                  ;
  8891                                  ; Set up INT 19 for new action
  8892                                  ;
  8893 00002A7A C7066400[340A]          		MOV	WORD[19h*4],INT19
  8894 00002A80 8C0E6600                		MOV	[19h*4+2],CS
  8895 00002A84 FB                      		STI
  8896                                  
  8897                                  		;; 07/04/2018
  8898                                  		;; Retro DOS v2.0
  8899                                  		;INT	11h		; rom-bios equipment determination
  8900                                  		;; 10/04/2018
  8901                                  		;TEST	AL,1
  8902                                  		;JNZ	SHORT CHECKSINGLEFD
  8903                                  		;XOR	AX,AX
  8904                                  		;JMP	SHORT NOFD
  8905                                  ;CHECKSINGLEFD:
  8906                                  		;MOV	CL, 6
  8907                                  		;SHR	AL, CL
  8908                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  8909                                  		;INC	byte [Single]	;REMEMBER THIS
  8910                                  ;NOTSINGLE:
  8911                                  		;XOR	AH,AH
  8912                                  		;INC	AL ; 10/04/2018
  8913                                  
  8914                                  		;; 02/06/2018
  8915                                  		;; Retro DOS v3.0  (MSDOS 3.3, MSINIT.ASM, 02/02/1988)
  8916                                  
  8917 00002A85 CD11                    		INT	11h		; rom-bios equipment determination
  8918 00002A87 D0C0                    		ROL	AL,1		;PUT BITS 6 & 7 INTO BITS 0 & 1
  8919 00002A89 D0C0                    		ROL	AL,1
  8920 00002A8B 83E003                  		AND	AX,3		;ONLY LOOK AT BITS 0 & 1
  8921 00002A8E 7506                    		JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  8922 00002A90 40                      		INC	AX		;PRETEND IT'S A TWO DRIVE SYSTEM
  8923 00002A91 2EFE06[6F00]            		INC	byte [CS:Single] ;REMEMBER THIS
  8924                                  NOTSINGLE:
  8925 00002A96 40                      		INC	AX		;AX HAS NUMBER OF DRIVES, 2-4
  8926                                  					;IS ALSO 0 INDEXED BOOT DRIVE IF WE
  8927                                  					;  BOOTED OFF HARD FILE
  8928 00002A97 88C1                    		mov	CL,AL		; save number of diskette drives in CL
  8929 00002A99 F6C280                  		test	DL,80h		; booted from hard disk ?
  8930 00002A9C 7502                    		jnz	short GotHrd	; yes, jump down
  8931 00002A9E 31C0                    		xor	AX,AX		; no - indicate boot from drive A
  8932                                  GotHrd:		
  8933                                  		; At this point the registers contain these values:
  8934                                  		;   AX = 0-based drive we booted from
  8935                                  		;   BX = the logical number of the first data sector on the disk
  8936                                  		;   CL = number of floppies including logical one
  8937                                  		;   CH = media byte
  8938                                  		;
  8939                                  ;
  8940                                  ; set up local stack
  8941                                  ;
  8942 00002AA0 88F5                    		mov	ch, dh	; 01/07/2018
  8943                                  
  8944 00002AA2 31D2                    		xor	DX,DX
  8945 00002AA4 FA                      		cli			; turn interrupts off while manupulating stack
  8946 00002AA5 8ED2                    		mov	SS,DX		; set stack segment register
  8947 00002AA7 BC0007                  		mov	SP,700h 	; set stack pointer
  8948 00002AAA FB                      		sti			; turn interrupts on
  8949                                  	
  8950                                  					; preserve some of the values in registers
  8951 00002AAB 51                      		push	CX ; (***)	; save number of floppies and media byte
  8952                                  		; 03/07/2018
  8953                                  		; 16/06/2018
  8954                                  		;mov	[CS:BIOS$],BX	; save first data sector
  8955 00002AAC 88EC                    		mov	AH,CH		; FAT ID to AH too
  8956 00002AAE 50                      		push	AX ; (**)	; save boot drive number and media byte
  8957                                  
  8958                                  ;;Rev 3.30 Modification -----------------------------------------------
  8959                                  ; Let Model_byte, Secondary_Model_Byte be set here!!!	
  8960 00002AAF B4C0                    		mov	ah,0C0h 	; return system environment 
  8961 00002AB1 CD15                    		int	15h		; call ROM-Bios routine     
  8962 00002AB3 7217                    		jc	short No_Rom_System_Conf ; just use Model_Byte	
  8963 00002AB5 80FC00                  		cmp	ah,0		; double check		
  8964 00002AB8 7512                    		jne	short No_Rom_System_Conf
  8965                                  			 		;get the model byte				
  8966 00002ABA 268A4702                		mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
  8967 00002ABE 2EA2[A205]              		mov	[CS:MODEL_BYTE],al
  8968                                  					 ;secondary model byte					
  8969 00002AC2 268A4703                		mov	al, [ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
  8970 00002AC6 2EA2[A305]              		mov	[CS:Secondary_Model_Byte],al				
  8971 00002ACA EB0D                    		jmp	short Turn_Timer_On					
  8972                                  No_Rom_System_Conf:							
  8973 00002ACC BEFFFF                  		MOV	SI,0FFFFH	;MJB001 			
  8974 00002ACF 8EC6                    		MOV	ES,SI		;MJB001 			
  8975 00002AD1 26A00E00                		MOV	AL,[ES:0EH]	; GET MODEL BYTE ARR 2.41	
  8976 00002AD5 2EA2[A205]              		MOV	[CS:MODEL_BYTE],AL ; SAVE MODEL BYTE ARR 2.41	
  8977                                  ;;End of Modification -----------------------------------------------
  8978                                  	
  8979                                  Turn_Timer_On:								
  8980 00002AD9 B020                    		mov	AL,EOI
  8981 00002ADB E620                    		out	AKPORT,AL	; turn on the timer
  8982                                  
  8983                                  		; 02/06/2018
  8984                                  
  8985                                  ;;Rev 3.30 Modification -----------------------------------------------
  8986 00002ADD BE[E800]                		mov	si,COM4DEV 
  8987 00002AE0 E80706                  		call	AUX_INIT
  8988 00002AE3 BE[D600]                		mov	si,COM3DEV
  8989 00002AE6 E80106                  		call	AUX_INIT
  8990                                  ;;End of Modification -----------------------------------------------
  8991 00002AE9 BE[C400]                		mov	SI,COM2DEV
  8992 00002AEC E8FB05                  		call	AUX_INIT		;INIT COM2
  8993 00002AEF BE[7400]                		mov	SI,COM1DEV
  8994 00002AF2 E8F505                  		call	AUX_INIT		;INIT COM1
  8995                                  
  8996 00002AF5 BE[B200]                		mov	SI,LPT3DEV
  8997 00002AF8 E8E705                  		call	PRINT_INIT		;INIT LPT3
  8998 00002AFB BE[9800]                		mov	SI,LPT2DEV
  8999 00002AFE E8E105                  		call	PRINT_INIT		;INIT LPT2
  9000 00002B01 BE[8600]                		mov	SI,LPT1DEV
  9001 00002B04 E8DB05                  		call	PRINT_INIT		;INIT LPT1
  9002                                  
  9003 00002B07 31D2                    		xor	DX,DX
  9004 00002B09 8EDA                    		mov	DS,DX			;TO INITIALIZE PRINT SCREEN VECTOR
  9005 00002B0B 8EC2                    		mov	ES,DX
  9006                                  
  9007 00002B0D 31C0                    		xor	AX,AX
  9008 00002B0F BF3405                  		mov	DI,INITSPOT
  9009 00002B12 AB                      		stosw				;INIT four bytes to 0
  9010 00002B13 AB                      		stosw
  9011                                  
  9012 00002B14 8CC8                    		mov	AX,CS			;FETCH SEGMENT
  9013                                  
  9014 00002B16 C7066C00[4306]          		mov	word [BRKADR],CBREAK	;BREAK ENTRY POINT
  9015 00002B1C A36E00                  		mov	[BRKADR+2],AX		;VECTOR FOR BREAK
  9016                                  
  9017 00002B1F C706A400[B707]          		mov	word [CHROUT*4],OUTCHR
  9018 00002B25 A3A600                  		mov	[CHROUT*4+2],AX
  9019                                  
  9020 00002B28 BF0400                  		mov	DI,4
  9021 00002B2B BB[4906]                		mov	BX,INTRET		;WILL INITIALIZE REST OF INTERRUPTS
  9022 00002B2E 93                      		xchg	AX,BX
  9023 00002B2F AB                      		stosw				;Location 4
  9024 00002B30 93                      		xchg	AX,BX
  9025 00002B31 AB                      		stosw				;INT 1		;Location 6
  9026 00002B32 83C704                  		add	DI,4
  9027 00002B35 93                      		xchg	AX,BX
  9028 00002B36 AB                      		stosw				;Location 12
  9029 00002B37 93                      		xchg	AX,BX
  9030 00002B38 AB                      		stosw				;INT 3		;Location 14
  9031 00002B39 93                      		xchg	AX,BX
  9032 00002B3A AB                      		stosw				;Location 16
  9033 00002B3B 93                      		xchg	AX,BX
  9034 00002B3C AB                      		stosw				;INT 4		;Location 18
  9035                                  
  9036 00002B3D 89160005                		mov	[500H],DX		;SET PRINT SCREEN & BREAK =0
  9037 00002B41 89160405                		mov	[LSTDRV],DX		;clean out last drive spec
  9038                                  
  9039 00002B45 8B367800                		mov	SI,[DSKADR]
  9040 00002B49 8E1E7A00                		mov	DS,[DSKADR+2]		; DS:SI -> current table
  9041                                  
  9042 00002B4D BF2205                  		mov	DI,SEC9 		; ES:DI -> New Table
  9043 00002B50 B90B00                  		mov	CX,DISK_PARMS.size ; 11
  9044 00002B53 F3A4                    		rep	MOVSB			; Copy Table
  9045 00002B55 06                      		push	ES			;
  9046 00002B56 1F                      		pop	DS			; DS = 0
  9047                                  							
  9048 00002B57 C70678002205            		mov	word [DSKADR],SEC9 	; Point disk parm vector to new table	
  9049 00002B5D 8C1E7A00                		mov	[DSKADR+2],DS 
  9050                                  
  9051                                  ;-----------------------------------------------
  9052                                  ;
  9053                                  ; THE FOLLOWING DEPEND ON THE TYPE OF MACHINE.
  9054                                  ;
  9055                                  		; 16/06/2018
  9056 00002B61 2E803E[A205]FD          		CMP	byte [CS:MODEL_BYTE],0FDH ; IS THIS AN OLD ROM?
  9057 00002B67 720B                    		JB	short NO_DIDDLE		; NO
  9058 00002B69 C7062B050F02            		MOV	WORD [SEC9+DISK_PARMS.DISK_HEAD_STTL],0200H+NORMSETTLE
  9059                                  						; SET HEAD SETTLE AND MOTOR START
  9060                                  						; ON PC-1 PC-2 PC-XT HAL0
  9061 00002B6F C6062205DF              		MOV	byte [SEC9+DISK_PARMS.DISK_SPECIFY_1],0DFH 
  9062                                  						; SET 1ST SPECIFY BYTE
  9063                                  						; ON PC-1 PC-2 PC-XT HAL0
  9064                                  NO_DIDDLE:
  9065 00002B74 CD12                    		int	12h			; call rom-bios for memory size
  9066 00002B76 B106                    		mov	CL,6			; get ready for shift
  9067 00002B78 D3E0                    		shl	AX,CL			; change from K to 16 byte blocks
  9068 00002B7A 59                      		pop	CX ; (**)		; restore CX
  9069                                  		; 03/07/2018
  9070 00002B7B 0E                      		push	cs
  9071 00002B7C 1F                      		pop	ds
  9072 00002B7D 890E[A229]              		mov	[DRVFAT],cx
  9073                                  		; 16/06/2018
  9074                                  		;mov	[CS:DRVFAT],CX
  9075                                  		;push	AX ; (*)
  9076                                  		; 03/07/2018
  9077 00002B81 89C2                    		mov	dx,ax ; (*)		
  9078                                  
  9079                                  		; 02/06/2018
  9080                                  		;mov	dx,[7C00h+16h]		; number of sectors/fat from boot sec
  9081                                  		
  9082                                  		;01/07/2018
  9083                                  		;mov	dx,[600h+16h]		; ((Retro DOS v2.0/v3.0 modification))
  9084                                  		
  9085                                  		;xor	dh,dh
  9086                                  		; 17/06/2018
  9087                                  		;push	cs
  9088                                  		;pop	ds
  9089                                  		; 01/07/2018
  9090                                  		;mov	[FatLen],dx
  9091                                  		; 16/06/2018
  9092                                  		;mov	[CS:FatLen],DX
  9093                                  ;
  9094                                  ; Convert sector count to paragraph count:512 bytes / sec / 16 bytes / para
  9095                                  ; = 32 para /sector
  9096                                  ;
  9097                                  ;;Rev 3.30 Modification -----------------------------------------------
  9098                                  		; 01/07/2018
  9099                                  		;SHL	DX,1
  9100                                  		;SHL	DX,1
  9101                                  		;SHL	DX,1
  9102                                  		;SHL	DX,1
  9103                                  		;SHL	DX,1
  9104                                  ;;End of Modification -----------------------------------------------
  9105                                  		;SUB	AX,DX			; room for FAT
  9106                                  		; 16/06/2018
  9107                                  		;MOV	[CS:FatLoc],AX		; location to read fat
  9108                                  		; 01/07/2018
  9109                                  		;; 17/06/2018
  9110                                  		;mov	[FatLoc],ax
  9111                                  
  9112                                  		; 01/07/2018
  9113                                  
  9114                                  		; 08/04/2018
  9115                                  		; 28/03/2018
  9116                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9117 00002B83 83E840                  		sub	ax,64		;room for boot record buffer segment (1 kb)
  9118 00002B86 A3[132A]                		mov	[init_bootseg],ax
  9119                                  
  9120                                  		;POP	AX ; (*)
  9121                                  		; 03/07/2018
  9122                                  		;pop	dx ; (*)
  9123                                  
  9124                                  		;; 02/06/2018
  9125                                  		;MOV	word [SYSINIT_START+DEVICE_LIST],CONHeader
  9126                                  		;MOV	[SYSINIT_START+DEVICE_LIST+2],CS
  9127                                  		; 05/07/2018
  9128 00002B89 C706[8C35][1800]        		MOV	word [SYSINIT+DEVICE_LIST],CONHeader
  9129 00002B8F 8C0E[8E35]              		MOV	[SYSINIT+DEVICE_LIST+2],CS
  9130                                  
  9131                                  		;; 06/04/2018
  9132                                  		;;MOV	[SYSINIT_START+MEMORY_SIZE],AX ; Top of memory (in paragraphs)
  9133                                  		;mov	[SYSINIT_START+MEMORY_SIZE],dx ; 01/07/2018
  9134                                  		;INC	CL
  9135                                  		;MOV	[SYSINIT_START+DEFAULT_DRIVE],CL ; SAVE DEFAULT DRIVE SPEC
  9136                                  
  9137                                  		; 05/07/2018
  9138                                  		;MOV	[SYSINIT+MEMORY_SIZE],AX
  9139 00002B93 8916[9E35]              		mov	[SYSINIT+MEMORY_SIZE],dx
  9140 00002B97 FEC1                    		INC	CL
  9141 00002B99 880E[A035]              		MOV	[SYSINIT+DEFAULT_DRIVE],CL
  9142                                  		
  9143                                  		; 02/06/2018
  9144                                  		;mov	dx,ax
  9145                                  
  9146                                  		; 08/04/2018
  9147                                  		; 28/03/2018
  9148                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  9149                                  		;sub	ax,64		;room for boot record buffer segment (1 kb)
  9150                                  		;mov	[init_bootseg],ax
  9151                                  
  9152                                  		;mov	ax,MSDOS_BIN_SEGMENT  ; MSDOS_BIN_OFFSET >> 4
  9153                                  		;add	ax,KERNEL_SEGMENT ; 26/03/2018
  9154                                  		;;MOV	[SYSINIT_START+CURRENT_DOS_LOCATION],AX
  9155                                  		;05/07/2018
  9156                                  		;MOV	[SYSINIT+CURRENT_DOS_LOCATION],AX
  9157                                  
  9158                                  		; 29/06/2019 - Retro DOS v3.1
  9159 00002B9D C706[8635]2105          		mov	word [SYSINIT+CURRENT_DOS_LOCATION], MSDOS_BIN_SEGMENT
  9160                                  
  9161                                  ; 02/06/2018
  9162                                  ;
  9163                                  ; IMPORTANT: Some old IBM hardware generates spurious INT F's due to bogus
  9164                                  ; printer cards. We initialize this value to point to an IRET ONLY IF
  9165                                  ;
  9166                                  ; 1) The original segment points to storage inside valid RAM.
  9167                                  ;
  9168                                  ; 2) The original segment is 0F000:xxxx
  9169                                  ;
  9170                                  ; Theses are capricious requests from our OEM for reasons behind them, read
  9171                                  ; the DCR's for the IBM DOS 3.2 project.
  9172                                  ;
  9173                                  		; 03/07/2018
  9174                                  		;push	ax
  9175                                  		
  9176                                  		; 02/06/2018 - Retro DOS v3.0
  9177                                  		;push	ds
  9178                                  		;pop	es
  9179                                  
  9180 00002BA3 31C0                    		xor	ax,ax
  9181 00002BA5 8ED8                    		mov	ds,ax
  9182                                  
  9183 00002BA7 A13E00                  		mov	ax,[0Fh*4+2]		; segment for Int 15
  9184                                  
  9185                                  		;;cmp	ax,[es:SYSINIT_START+MEMORY_SIZE] ; Condition 1
  9186                                  		; 05/07/2018
  9187                                  		;cmp	ax,[es:SYSINIT+MEMORY_SIZE]
  9188 00002BAA 39D0                    		cmp	ax,dx
  9189 00002BAC 7605                    		jna	short ResetIntF
  9190                                  
  9191 00002BAE 3D00F0                  		cmp	ax,0F000h		; Condition 2
  9192 00002BB1 750A                    		jne	short KeepIntF
  9193                                  ResetIntF:
  9194 00002BB3 C7063C00[4906]          		mov	word [0Fh*4],INTRET
  9195 00002BB9 8C0E3E00                		mov	[0Fh*4+2],cs
  9196                                  KeepIntF:
  9197                                  		;pop	ax
  9198                                  ;
  9199                                  ; END IMPORTANT
  9200                                  ;
  9201                                  
  9202                                  ; 02/06/2018 - Retro DOS v3.0
  9203                                  
  9204                                  ;**************************************************************
  9205                                  ;	WILL INITIALIZE THE NUMBER OF DRIVES		
  9206                                  ;	AFTER THE EQUIPMENT CALL (INT 11H) BITS 6&7 WILL TELL	
  9207                                  ;	THE INDICATIONS ARE AS FOLLOWS: 		
  9208                                  ;							
  9209                                  ;	BITS	7	6	DRIVES			
  9210                                  ;		0	0	1			
  9211                                  ;		0	1	2			
  9212                                  ;		1	0	3			
  9213                                  ;		1	1	4			
  9214                                  ;************************************************************** 
  9215 00002BBD 0E                      		PUSH	CS
  9216 00002BBE 1F                      		POP	DS
  9217 00002BBF 0E                      		PUSH	CS
  9218 00002BC0 07                      		POP	ES
  9219                                  
  9220 00002BC1 E88B06                  		call	CMOS_CLOCK_READ  ;Before doing anything if CMOS clock,
  9221                                  				 ;then set the system time accordingly.
  9222                                  				 ;Also, reset the cmos clock rate.
  9223                                  
  9224 00002BC4 31F6                    		XOR	SI,SI
  9225 00002BC6 C704[151B]              		MOV	word [SI],HARDDRV ;set up pointer to hdrive
  9226                                  
  9227 00002BCA 58                      		POP	AX ; (***) ;number of floppies and FAT ID
  9228 00002BCB 30E4                    		XOR	AH,AH	; Chuck FAT ID byte
  9229 00002BCD A2[0801]                		MOV	[HARDNUM],AL ;Remember which drive is hard disk
  9230 00002BD0 A2[6A00]                		MOV	[DRVMAX],AL  ;And set initial number of drives
  9231 00002BD3 D1E0                    		SHL	AX,1	;Two bytes per address
  9232 00002BD5 BF[E405]                		MOV	DI,DSKDRVS
  9233 00002BD8 01C7                    		ADD	DI,AX	;Point to hardfile location
  9234 00002BDA BE[EC05]                		MOV	SI,HDSKTAB
  9235 00002BDD A5                      		MOVSW		;Two addresses to move
  9236 00002BDE A5                      		MOVSW
  9237 00002BDF B280                    		mov	DL,80h	; tell rom bios to look at hard drives
  9238 00002BE1 B408                    		mov	AH,08h	; set command to get drive parameter
  9239 00002BE3 CD13                    		int	13h	; call ROM-BIOS to get number of drives
  9240 00002BE5 7204                    		jc	short ENDDRV ; old, rom therefore no hard disks
  9241 00002BE7 8816[141B]              		mov	[HNUM],DL ; save number of hard drives in HNUM
  9242                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))
  9243                                  ENDDRV:
  9244                                  ;
  9245                                  ; Scan the list of drives to determine their type. We have three flavors of
  9246                                  ; diskette drives:
  9247                                  ;
  9248                                  ;   48tpi drives    We do nothing special for them
  9249                                  ;   96tpi drives    Mark the fact that they have changeline support.
  9250                                  ;   3 1/2 drives    Mark changeline support and small.
  9251                                  ;
  9252                                  ; The following code uses registers for certain values:
  9253                                  ;   DL - Physical Drive
  9254                                  ;   DS:DI - points to current BDS
  9255                                  ;   CX - Flag bits for BDS
  9256                                  ;   DH - Form Factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
  9257                                  ;
  9258 00002BEB 30D2                    		XOR	DL,DL	; start out with drive 0.
  9259                                  		; 17/06/2018
  9260                                  		;push	cs
  9261                                  		;pop	ds
  9262 00002BED C606[0E01]09            		MOV	byte [EOT],9
  9263 00002BF2 BF[FA00]                		mov	di,START_BDS
  9264                                  LOOP_DRIVE:
  9265 00002BF5 3A16[6A00]              		cmp	dl,[DRVMAX]
  9266 00002BF9 7203                    		jb	short GOT_MORE
  9267 00002BFB E90401                  		jmp	DONE_DRIVES
  9268                                  GOT_MORE:
  9269 00002BFE 31C9                    		xor	cx,cx		; zero all flags
  9270                                  		;mov	di,[DI+BDS.Link] ; get next BDS
  9271 00002C00 8B3D                    		mov	di,[di] ; 05/07/2019
  9272 00002C02 B600                    		mov	dh,ff48tpi	; Set Form Factor to 48 tpi
  9273 00002C04 C606[A729]28            		MOV	byte [NUM_CYLN],40 ; 40 TRACKS PER SIDE
  9274                                  								
  9275                                  		;PUSH	DS						
  9276 00002C09 57                      		PUSH	DI						
  9277 00002C0A 52                      		PUSH	DX						
  9278 00002C0B 51                      		PUSH	CX
  9279                                  		; 17/06/2018						
  9280                                  		;PUSH	ES						
  9281 00002C0C 0E                      		push	cs ; ((*))		
  9282                                  						
  9283 00002C0D B408                    		MOV	AH,08h		;GET DRIVE PARAMETERS
  9284 00002C0F CD13                    		INT	13h		;CALL ROM-BIOS		
  9285                                  		;JNC	short PARMSFROMROM					
  9286                                  		;JMP	short NOPARMSFROMROM ; GOT AN OLD ROM
  9287 00002C11 7277                    		jc	short NOPARMSFROMROM ; 03/06/2018
  9288                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))	
  9289                                  PARMSFROMROM:							
  9290                                  ;If CMOS is bad, it gives ES,AX,BX,CX,DH,DI=0. CY=0.	 
  9291                                  ;In this case, we are going to put bogus informations to BDS table.
  9292                                  ;We are going to set CH=39,CL=9,DH=1 to avoid divide overflow when	
  9293                                  ;they are calculated at the later time.  This is just for the Diagnostic
  9294                                  ;Diskette which need IO.SYS,MSDOS to boot up before it sets CMOS.	
  9295                                  ;This should only happen with drive B.	
  9296                                  
  9297                                  ;;Rev 3.30 Modification -----------------------------------------------
  9298 00002C13 80FD00                  		CMP	CH,0	; if ch=0, then cl,dh=0 too.	 
  9299 00002C16 7506                    		JNE	short PFR_OK							 
  9300 00002C18 B527                    		MOV	CH,39	; ROM gave wrong info.		 
  9301 00002C1A B109                    		MOV	CL,9	; Let's default to 360K.         
  9302 00002C1C B601                    		MOV	DH,1							 
  9303                                  PFR_OK: 								 
  9304 00002C1E FEC6                    		INC	DH	; MAKE NUMBER OF HEADS 1-BASED	 
  9305 00002C20 FEC5                    		INC	CH	; MAKE NUMBER OF CYLINDERS 1-BASED
  9306 00002C22 8836[A529]              		MOV	[NUM_HEADS],DH	; SAVE PARMS RETURNED BY ROM	 
  9307 00002C26 80E13F                  		AND	CL,00111111B	; EXTRACT SECTORS/TRACK 	 
  9308 00002C29 880E[A629]              		MOV	[SEC_TRK],CL						 
  9309 00002C2D 882E[A729]              		MOV	[NUM_CYLN],CH	; ASSUME LESS THAN 256 CYLINDERS!! 
  9310                                  ; MAKE SURE THAT EOT CONTAINS THE MAX NUM OF SEC/TRK IN SYSTEM OF FLOPPIES
  9311 00002C31 3A0E[0E01]              		CMP	CL,[EOT]	; MAY SET CARRY 		 
  9312 00002C35 7604                    		JBE	short EOT_OK							
  9313 00002C37 880E[0E01]              		MOV	[EOT],CL						
  9314                                  EOT_OK: 							
  9315 00002C3B 07                      		POP	ES ; ((*)) es = cs = ds						
  9316 00002C3C 59                      		POP	CX						
  9317 00002C3D 5A                      		POP	DX						
  9318 00002C3E 5F                      		POP	DI						
  9319                                  		;POP	DS						
  9320                                  ;
  9321                                  ; Check for presence of changeline
  9322                                  ;
  9323 00002C3F B415                    		mov	AH,15h      	; set command to get DASD type
  9324 00002C41 CD13                    		int	13h	     	; call ROM-BIOS
  9325 00002C43 720D                    		JC	short CHANGELINE_DONE 	
  9326 00002C45 80FC02                  		CMP	AH,2		; CHECK FOR PRESENCE OF CHANGELINE
  9327 00002C48 7508                    		JNE	short CHANGELINE_DONE 					 
  9328                                  ;;End of Modification -----------------------------------------------
  9329                                  
  9330                                  ;
  9331                                  ; We have a drive with change line support.
  9332                                  ;
  9333 00002C4A 80C902                  		or	CL,fChangeline	; signal type
  9334 00002C4D C606[6D00]01            		mov	byte [fHave96],1 ; Remember that we have 96tpi disks
  9335                                  ;									  
  9336                                  ; WE NOW TRY TO SET UP THE FORM FACTOR FOR THE TYPES OF MEDIA THAT WE KNOW
  9337                                  ; AND CAN RECOGNISE. FOR THE REST, WE SET THE FORM FACTOR AS "OTHER".     
  9338                                  ;									  
  9339                                  CHANGELINE_DONE:							  
  9340                                  ; 40 CYLINDERS AND 9 OR LESS SEC/TRK, TREAT AS 48 TPI MEDIUM.		  
  9341 00002C52 803E[A729]28            		CMP	byte [NUM_CYLN],40						  
  9342 00002C57 750B                    		JNZ	short TRY_80							  
  9343 00002C59 803E[A629]09            		CMP	byte [SEC_TRK],9						  
  9344                                  		;JBE	short GOT_FF
  9345 00002C5E 7653                    		jbe	short NEXTDRIVE ; 03/06/2018							  
  9346                                  GOTOTHER:								  
  9347 00002C60 B607                    		MOV	DH,ffOther	; WE HAVE A "STRANGE" MEDIUM     
  9348                                  		;JMP	SHORT GOT_FF
  9349 00002C62 EB4F                    		jmp	short NEXTDRIVE	; 03/06/2018				  
  9350                                  
  9351                                  ;									  
  9352                                  ; 80 CYLINDERS AND 9 SECTORS/TRACK => 720 KB DEVICE			  
  9353                                  ; 80 CYLINDERS AND 15 SEC/TRK => 96 TPI MEDIUM				  
  9354                                  ;									  
  9355                                  TRY_80: 
  9356                                  	; 03/06/2018 - Retro DOS v3.0 - MSDOS 6.0 (MSINIT.ASM, 1991) modifications
  9357                                  	
  9358 00002C64 803E[A729]50            		CMP	byte [NUM_CYLN],80						
  9359 00002C69 75F5                    		JNZ	short GOTOTHER
  9360                                  
  9361                                  		; 03/06/2018 (MSDOS 6.0, MSINIT.ASM, 1991)
  9362 00002C6B B609                    		mov	dh,ff288	   ; assume 2.88 MB drive m037
  9363 00002C6D 803E[A629]24            		cmp	byte [SEC_TRK],36  ; is it ?		  m037
  9364 00002C72 743F                    		je	short NEXTDRIVE	   ; yeah, go update	  m037
  9365                                  
  9366 00002C74 803E[A629]0F            		CMP	byte [SEC_TRK],15						
  9367 00002C79 740B                    		JZ	short GOT96							
  9368 00002C7B 803E[A629]09            		CMP	byte [SEC_TRK],9						
  9369 00002C80 75DE                    		JNZ	short GOTOTHER	 ; (1.44MB, 3.5" diskette drive)
  9370 00002C82 B602                    		MOV	DH,ffSmall
  9371                                  		;JMP	SHORT GOT_FF
  9372 00002C84 EB2D                    		jmp	short NEXTDRIVE
  9373                                  GOT96:	
  9374 00002C86 B601                    		MOV	DH,ff96tpi
  9375                                  ;GOT_FF: 
  9376 00002C88 EB29                    		JMP	SHORT NEXTDRIVE 
  9377                                  
  9378                                  ; WE HAVE AN OLD ROM, SO WE EITHER HAVE A 48TPI OR 96TPI DRIVE. IF THE DRIVE
  9379                                  ; HAS CHANGELINE, WE ASSUME IT IS A 96TPI, OTHERWISE IT IS A 48TPI.
  9380                                  
  9381                                  NOPARMSFROMROM:
  9382 00002C8A 07                      		POP	ES ; ; ((*))
  9383 00002C8B 59                      		POP	CX
  9384 00002C8C 5A                      		POP	DX
  9385 00002C8D 5F                      		POP	DI
  9386                                  		;POP	DS
  9387                                  
  9388 00002C8E B415                    		MOV	AH,15h		; SET COMMAND TO GET DASD TYPE
  9389 00002C90 CD13                    		INT	13h		; CALL ROM-BIOS
  9390 00002C92 721F                    		JC	short NEXTDRIVE
  9391 00002C94 80FC02                  		CMP	AH,2		; IS THERE CHANGELINE?
  9392 00002C97 751A                    		JNZ	short NEXTDRIVE
  9393 00002C99 80C902                  		OR	CL,fChangeline
  9394 00002C9C C606[6D00]01            		MOV	byte [fHave96],1 ; REMEMBER WE HAVE 96TPI DRIVES
  9395 00002CA1 C606[A729]50            		MOV	byte [NUM_CYLN],80
  9396 00002CA6 B601                    		MOV	DH,ff96tpi
  9397 00002CA8 B00F                    		MOV	AL,15		; SET EOT IF NECESSARY
  9398 00002CAA 3A06[0E01]              		CMP	AL,[EOT]
  9399 00002CAE 7603                    		JBE	short EOT_OK2
  9400 00002CB0 A2[0E01]                		MOV	[EOT],AL
  9401                                  EOT_OK2:
  9402                                  NEXTDRIVE:
  9403 00002CB3 80C920                  		or	cl,fI_Own_Physical ; set this true for all drives
  9404 00002CB6 88D7                    		mov	bh,dl	 	;save Int13 drive number
  9405                                  
  9406                                  ; we need to do special things if we have a single drive system and are setting
  9407                                  ; up a logical drive. it needs to have the same int13 drive number as its
  9408                                  ; counterpart, but the next drive letter. also reset ownership flag.
  9409                                  ; we detect the presence of this situation by examining the flag single for the
  9410                                  ; value 2.
  9411                                  
  9412 00002CB8 803E[6F00]02            		cmp	byte [Single],2
  9413 00002CBD 7505                    		jnz	short NOT_SPECIAL
  9414 00002CBF FECF                    		dec	bh	; int13 drive number same for logical drive
  9415                                  	 			; reset ownership flag for logical drive
  9416 00002CC1 80F120                  		xor	cl,fI_Own_Physical
  9417                                  NOT_SPECIAL:
  9418                                  ; The values that we put in for RHdlim and RSeclim will only remain if the
  9419                                  ; form factor is of type "ffOther".
  9420                                  		
  9421 00002CC4 31C0                    		xor	ax,ax			; fill BDS for drive
  9422 00002CC6 A0[A529]                		mov	al,[NUM_HEADS]
  9423 00002CC9 89453C                  		mov	[di+BDS.RHDLIM],ax
  9424 00002CCC A0[A629]                		mov	al,[SEC_TRK]
  9425 00002CCF 89453A                  		mov	[di+BDS.RSECLIM],ax
  9426 00002CD2 894D29                  		mov	[di+BDS.Flags],cx
  9427 00002CD5 887528                  		mov	[di+BDS.FormFactor],dh
  9428 00002CD8 885505                  		mov	[di+BDS.DriveLet],dl
  9429 00002CDB 887D04                  		mov	[di+BDS.DriveNum],bh
  9430 00002CDE 8A1E[A729]              		mov	bl,[NUM_CYLN]
  9431 00002CE2 885D2B                  		mov	[di+BDS.cCyln],bl	; only the l.s. byte is set here
  9432 00002CE5 803E[6F00]01            		cmp	byte [Single],1		; Special case for single drive system
  9433 00002CEA 7511                    		jnz	short NO_SINGLE
  9434                                  						; Don't forget we have
  9435 00002CEC C606[6F00]02            		mov	byte [Single],2		;   single drive system
  9436 00002CF1 83C910                  		or	cx,fI_Am_Mult		; set that this is one of
  9437                                  						;   several drives
  9438 00002CF4 094D29                  		or	[di+BDS.Flags],cx	; save flags
  9439                                  		;mov	di,[di+BDS.Link]	; move to next BDS in list
  9440 00002CF7 8B3D                    		mov	di,[di] ; 05/07/2019
  9441 00002CF9 FEC2                    		inc	dl			; add a number
  9442 00002CFB EBB6                    		jmp	short NEXTDRIVE		; Use same info for BDS as previous
  9443                                  NO_SINGLE:
  9444 00002CFD FEC2                    		inc	dl
  9445 00002CFF E9F3FE                  		jmp	LOOP_DRIVE	
  9446                                  
  9447                                  DONE_DRIVES:
  9448                                  		;mov	ax,-1			; Signify end of list by
  9449                                  		;mov	[di+BDS.Link],ax	;    setting pointer to -1
  9450                                  		;mov	word [di+BDS.Link],-1 ; 03/07/2018
  9451 00002D02 C705FFFF                		mov	word [di],-1 ; 05/07/2019
  9452                                  ;
  9453                                  ; Set up all the hard drives in the system
  9454                                  ;
  9455                                  		; 03/06/2018	
  9456                                  DoHard:
  9457 00002D06 803E[141B]00            		cmp	byte [HNUM], 0		; IF (No_Hard_files)
  9458 00002D0B 7E4F                    		jle	short STATIC_CONFIGURE 	;    THEN EXIT TO CONFIGURE
  9459 00002D0D B280                    		mov	DL,80h			; set first hard file number
  9460 00002D0F BF[161B]                		mov	di,BDSH		    	; Set up first hard file.
  9461 00002D12 8A1E[0801]              		mov	bl,[HARDNUM]
  9462 00002D16 E89F01                  		call	SETHARD
  9463 00002D19 730D                    		jnc	short HardFile1_OK
  9464 00002D1B FE0E[141B]              		dec	byte [HNUM]		; First hard file is bad.
  9465 00002D1F 803E[141B]00            		cmp	byte [HNUM],0		; IF (Second_Hard_File)
  9466 00002D24 7F15                    		jg	short Second_Hard	;   THEN Set up second hard file
  9467 00002D26 EB34                    		JMP	SHORT STATIC_CONFIGURE	
  9468                                  	
  9469                                  HardFile1_OK:
  9470 00002D28 E808ED                  		call	INSTALL_BDS	    	; install BDS into linked list
  9471 00002D2B 803E[141B]02            		cmp	byte [HNUM],2		; IF (Only_one_hardfile)
  9472 00002D30 7219                    		jb	short SetIt	    	;    THEN SetIt "in place"
  9473                                  
  9474 00002D32 8A1E[0801]              		mov	bl,[HARDNUM]
  9475 00002D36 FEC3                    		inc	BL			; next drive letter
  9476 00002D38 BF[681B]                		mov	di,BDSX
  9477                                  Second_Hard:					; SETUP Second Hard FILE
  9478 00002D3B B281                    		mov	DL,81h			; set second hard file number
  9479 00002D3D E87801                  		call	SETHARD
  9480 00002D40 7306                    		jnc	short HardFile2_OK
  9481 00002D42 FE0E[141B]              		dec	byte [HNUM]
  9482 00002D46 EB03                    		jmp	short SetIt
  9483                                  
  9484                                  HardFile2_OK:
  9485 00002D48 E8E8EC                  		call	INSTALL_BDS
  9486                                  SetIt:
  9487 00002D4B A0[141B]                		mov	al,[HNUM]
  9488 00002D4E 08C0                    		or	al,al
  9489 00002D50 740A                    		jz	short STATIC_CONFIGURE
  9490 00002D52 0206[0801]              		add	al,[HARDNUM]
  9491 00002D56 A2[6A00]                		mov	[DRVMAX],al
  9492                                  
  9493                                  ; End of physical drive initialization.	
  9494                                  ; *** Do not change the position of the following statement.
  9495                                  ; *** DoMini routine will use [DRVMAX] value for the start of the logical
  9496                                  ; *** drive number of Mini disk(s).
  9497                                  
  9498 00002D59 E8C403                  		call    DoMini		;For setting up mini disks, if found
  9499                                  
  9500                                  ; End of drive initialization.
  9501                                  
  9502                                  ; 03/06/2018 - Retro DOS v3.0
  9503                                  
  9504                                  ;9/24/86 We now decide, based on the configurations available so far,
  9505                                  ;what code or data we need to keep as a stay resident code. The following
  9506                                  ;table shows the configurations under consideration. They are listed in  
  9507                                  ;the order of their current position memory.				  
  9508                                  ;Configuration will be done in two ways:				  
  9509                                  ;First, we are going to set "Static configuration". Static configuration 
  9510                                  ;will consider from basic configuration to ENDOF96TPI configuration.	  
  9511                                  ;The result of static configuration will be the address the Dynamic	  
  9512                                  ;configuration will use to start with.					  
  9513                                  ;Secondly, "Dynamic cofiguration" will be performed. Dynamic configuration
  9514                                  ;involves possible relocation of CODE/DATA. Dynamic configuration routine 
  9515                                  ;will take care of BDSM tables and AT ROM Fix module thru K09 suspend/res 
  9516                                  ;code individually. After these operation, FINAL_DOS_LOCATION will be set.
  9517                                  ;This will be the place SYSINIT routine will relocate MSDOS module.	  
  9518                                  ;									  
  9519                                  ;   1.	 BASIC CONFIGURATION FOR MSBIO (EndFloppy, EndSwap)		  
  9520                                  ;   2.	 ENDONEHARD							  
  9521                                  ;   3.	 ENDTWOHARD							  
  9522                                  ;   4.	 END96TPI	;a system that supports "Change Line Error"       
  9523                                  ;   5.	 End of BDSM	;BDSM tables for mini disks.			  
  9524                                  ;   6.	 ENDATROM	;Some of AT ROM fix module.			  
  9525                                  ;   7.	 ENDCMOSCLOCKSET;Supporting program for CMOS clock write.	  
  9526                                  ;   8.	 ENDK09 	;K09 CMOS Clock module to handle SUSPEND/RESUME   
  9527                                  ;									  
  9528                                  ;9/24/86.								  
  9529                                  									  
  9530                                  ; *** For mini disk configuration. 4/7/86	 			  
  9531                                  ; *** END_OF_BDSM will contain the ending address(off) of BDSM table for  
  9532                                  ; *** mini disks which is located right after the label END96TPI.	  
  9533                                  ; *** The variable NUM_MINI_DSK will indicate the existance. 4/7/86	  
  9534                                  									  
  9535                                  STATIC_CONFIGURE:	
  9536                                  		; 05/07/2019						  
  9537                                  		;PUSH	AX ; !@							  
  9538                                  
  9539 00002D5C B8[711E]                		mov	ax,End96tpi		;let's start with the biggest one.
  9540 00002D5F 803E[6D00]00            		cmp	byte [fHave96],0	;Is change line support there?	  
  9541 00002D64 7514                    		jnz	short Config96		;Yes.				 
  9542                                  									  
  9543 00002D66 B8[BF1B]                		mov	ax,EndTwoHard					
  9544 00002D69 803E[141B]01            		cmp	byte [HNUM],1 		;1 hard file?			
  9545 00002D6E 772A                    		ja	short ConfigTwoHard						
  9546                                  No_Two_HRD:								
  9547 00002D70 B8[671B]                		mov	ax,EndOneHard					
  9548 00002D73 7425                    		je	short ConfigOneHard ; 29/06/2019						
  9549                                  Basic_Floppy:								
  9550 00002D75 B8[141B]                		mov	ax,EndFloppy					 
  9551 00002D78 EB30                    		jmp	short DYNAMIC_CONFIGURE	;static configuration is done!	
  9552                                  ;
  9553                                  ; Keep the 96tpi code
  9554                                  ;
  9555                                  Config96:
  9556                                  ;
  9557                                  ; Save old INT 13 vector
  9558                                  ;
  9559 00002D7A 50                      		PUSH	AX
  9560 00002D7B 1E                      		PUSH	DS
  9561 00002D7C 31C0                    		XOR	AX,AX
  9562 00002D7E 8ED8                    		MOV	DS,AX
  9563 00002D80 A14C00                  		MOV	AX,[4*13h]
  9564 00002D83 2EA3[D71C]              		MOV	[CS:REAL13],AX
  9565 00002D87 A14E00                  		MOV	AX,[4*13h+2]
  9566 00002D8A 2EA3[D91C]              		MOV	[CS:REAL13+2],AX
  9567                                  ;
  9568                                  ; Insert new vector
  9569                                  ;
  9570 00002D8E C7064C00[E11C]          		MOV	word [4*13h],INT13
  9571 00002D94 8C0E4E00                		MOV	[4*13h+2],CS
  9572 00002D98 1F                      		POP	DS
  9573 00002D99 58                      		POP	AX
  9574                                  ;
  9575                                  ; Keep two hard disk BPBs
  9576                                  ;
  9577                                  ConfigTwoHard:
  9578                                  ;
  9579                                  ; Keep one hard disk BPB
  9580                                  ;
  9581                                  ConfigOneHard:
  9582                                  ;
  9583                                  ; Adjust the number of drives to include the hard disks.
  9584                                  ;
  9585 00002D9A 50                      		PUSH	AX
  9586 00002D9B A0[0801]                		MOV	AL,[HARDNUM]
  9587 00002D9E 0206[141B]              		ADD	AL,[HNUM]
  9588 00002DA2 0206[E429]              		add	al,[num_mini_dsk] ;4/7/86 for mini disks installed	
  9589                                  				;if not installed, then num_mini_dsk = 0.
  9590 00002DA6 A2[6A00]                		MOV	[DRVMAX],AL
  9591 00002DA9 58                      		POP	AX
  9592                                  
  9593                                  DYNAMIC_CONFIGURE:
  9594 00002DAA E8D800                  		call	Get_Para_Offset ;For dynamic allocation, we are
  9595                                  					;going to use offset address that
  9596                                  					;is in paragraph boundary.
  9597                                  		; 17/06/2018 (es=cs=ds)
  9598                                  		;push	cs
  9599                                  		;pop	es		;es -> code
  9600                                  		
  9601 00002DAD FC                      		cld			;clear direction
  9602                                  
  9603 00002DAE 803E[E429]00            		cmp	byte [num_mini_dsk], 0	;Mini disk(s) installed ?
  9604 00002DB3 7406                    		jz	short CheckATROM	;No.
  9605                                  		; 03/07/2018
  9606 00002DB5 A1[E029]                		mov	ax,[End_Of_BDSM]	;set the new ending address
  9607 00002DB8 E8CA00                  		call	Get_Para_Offset 	
  9608                                  CheckATROM:				
  9609 00002DBB 803E[A205]FC            		cmp	byte [MODEL_BYTE],0FCh	;AT ?
  9610 00002DC0 7535                    		jnz	short CheckCMOSClock				
  9611 00002DC2 803E[141B]00            		cmp	byte [HNUM],0 		;No hard file?	
  9612 00002DC7 742E                    		jz	short CheckCMOSClock			
  9613 00002DC9 BE00F0                  		mov	si,0F000h					
  9614 00002DCC 8EC6                    		mov	es,si			;ES -> BIOS segment
  9615 00002DCE BE[EC29]                		mov	si,Bios_Date			
  9616 00002DD1 BFF5FF                  		mov	di,0FFF5H	;ROM BIOS string is at F000:FFF5
  9617                                  Cmpbyte:				;Only patch ROM for bios 01/10/84
  9618 00002DD4 A6                      		cmpsb							
  9619 00002DD5 7520                    		jnz	short CheckCMOSClock					
  9620 00002DD7 807CFF00                		cmp	byte [si-1],0				
  9621 00002DDB 75F7                    		jnz	short Cmpbyte 					
  9622                                  SetRomCode:				;Now we have to install ROM fix
  9623                                  					;AX is the address to move.
  9624 00002DDD 0E                      		push	cs						
  9625 00002DDE 07                      		pop	es		;set ES to CODE seg	
  9626 00002DDF A3[AE00]                		mov	[ORIG13],ax				
  9627 00002DE2 8C0E[B000]              		mov	[ORIG13+2],cs	;set new ROM bios int 13 vector
  9628 00002DE6 B9[F426]                		mov	cx,ENDATROM				
  9629 00002DE9 BE[C825]                		mov	si,IBM_DISK_IO				
  9630 00002DEC 29F1                    		sub	cx,si		;size of AT ROM FIX module
  9631 00002DEE 89C7                    		mov	di,ax		;destination	
  9632 00002DF0 F3A4                    		rep	movsb		;relocate it		
  9633 00002DF2 89F8                    		mov	ax,di		;new ending address
  9634 00002DF4 E88E00                  		call	Get_Para_Offset ;in AX			
  9635                                  CheckCMOSClock: 						
  9636 00002DF7 0E                      		push	cs						
  9637 00002DF8 07                      		pop	es		 ;set ES to CODE seg	
  9638 00002DF9 803E[8A04]01            		cmp	byte [HaveCMOSClock],1 ;CMOS Clock exists?	
  9639 00002DFE 7528                    		jne	short CheckK09	
  9640                                  				
  9641 00002E00 A3[9B04]                		mov	[DaycntToDay],ax ;set the address for MSCLOCK
  9642 00002E03 B9[C627]                		mov	cx,EndDaycntToDay			
  9643 00002E06 BE[F426]                		mov	si,Daycnt_To_Day				 
  9644 00002E09 29F1                    		sub	cx,si		;size of CMOS clock sub routine  
  9645 00002E0B 89C7                    		mov	di,ax							  
  9646 00002E0D F3A4                    		rep	movsb							
  9647 00002E0F 89F8                    		mov	ax,di						
  9648 00002E11 E87100                  		call	Get_Para_Offset 					 
  9649 00002E14 A3[9904]                		mov	[BinToBCD],ax	;set the address for MSCLOCK
  9650 00002E17 B9[D527]                		mov	cx,EndCMOSClockSet				
  9651 00002E1A BE[C627]                		mov	si,Bin_To_BCD				
  9652 00002E1D 29F1                    		sub	cx,si							
  9653 00002E1F 89C7                    		mov	di,ax							
  9654 00002E21 F3A4                    		rep	movsb							
  9655 00002E23 89F8                    		mov	ax,di							
  9656 00002E25 E85D00                  		call	Get_Para_Offset 					
  9657                                  CheckK09:								
  9658 00002E28 50                      		push	ax		;save ax	     		
  9659 00002E29 B80041                  		mov	ax,4100h	;Q: is it a K09 	     
  9660 00002E2C B300                    		mov	bl,0		;
  9661                                  		;xor	bl,bl			  
  9662 00002E2E CD15                    		int	15h		;			   
  9663 00002E30 58                      		pop	ax						
  9664 00002E31 7228                    		jc	short ConfigDone
  9665                                  								
  9666 00002E33 BE[D627]                		mov	si,INT6C				
  9667 00002E36 B9[A129]                		mov	cx,ENDK09					
  9668 00002E39 29F1                    		sub	cx,si		;size of K09 routine	
  9669 00002E3B 89C7                    		mov	di,ax							
  9670 00002E3D 57                      		push	di		;save destination		
  9671 00002E3E F3A4                    		rep	movsb							
  9672 00002E40 89F8                    		mov	ax,di					
  9673 00002E42 E84000                  		call	Get_Para_Offset ;AX = new ending address	
  9674 00002E45 5F                      		pop	di							
  9675                                  								
  9676 00002E46 50                      		push	ax							 
  9677 00002E47 1E                      		push	ds							
  9678 00002E48 C606[6E00]01            		mov	byte [fHaveK09],1 ;remember we have a K09 type	
  9679 00002E4D 31C0                    		xor	ax,ax							
  9680 00002E4F 8ED8                    		mov	ds,ax							
  9681 00002E51 893EB001                		mov	[4*6Ch],di	;new INT 6Ch handler	
  9682 00002E55 8C0EB201                		mov	[4*6Ch+2],cs					
  9683 00002E59 1F                      		pop	ds							
  9684 00002E5A 58                      		pop	ax		;restore the ending address	
  9685                                  ;
  9686                                  ; Set up config stuff for SYSINIT
  9687                                  ;
  9688                                  ConfigDone:
  9689                                  		; 03/06/2018 - Retro DOS v3.0	
  9690                                  		;; 07/04/2018
  9691                                  		;MOV	AX,END_OF_HD2P_TBL
  9692                                  		; 06/04/2018
  9693                                  		;MOV	AX,INIT
  9694 00002E5B 83C00F                  		ADD	AX,15
  9695                                  		;SHR	AX,1
  9696 00002E5E D1D8                    		RCR	AX,1
  9697 00002E60 D1E8                    		SHR	AX,1
  9698 00002E62 D1E8                    		SHR	AX,1
  9699 00002E64 D1E8                    		SHR	AX,1
  9700 00002E66 83C070                  		ADD	AX,KERNEL_SEGMENT
  9701                                  		;MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
  9702                                  		; 05/07/2018
  9703 00002E69 A3[8A35]                		MOV	[SYSINIT+FINAL_DOS_LOCATION],AX
  9704                                  
  9705                                  		; 05/07/2019
  9706                                  		;POP	AX ; !@
  9707                                  
  9708                                  		; 03/06/2018
  9709                                  		; 19/03/2018
  9710 00002E6C B9C076                  		mov	cx,msdos_bin_size+1
  9711 00002E6F D1E9                    		shr	cx,1
  9712                                  		;mov	[SYSINIT_START+DOSSIZE],cx ; DOS size in words
  9713                                  		; 05/07/2018
  9714 00002E71 890E[9035]              		mov	[SYSINIT+DOSSIZE],cx
  9715                                  
  9716                                  		; 03/06/2018
  9717 00002E75 803E[6D00]00            		CMP	BYTE [fHave96],0
  9718 00002E7A 7503                    		JNZ	SHORT ReadDos
  9719 00002E7C E87F02                  		call	PURGE_96TPI	;mjb001 eliminate calls to 96tpi hoohah
  9720                                  
  9721                                  ReadDos:
  9722                                  		; 06/07/2019
  9723                                  
  9724                                  		; 19/03/2018 (*) No need to read remain clusters of
  9725                                  		; MSDOS kernel because of Retro DOS v2.0 boot sector
  9726                                  		; has loaded all of the kernel file before.
  9727                                  		; ;("MSINIT.ASM" contains kernel file reading code here...)  
  9728                                  
  9729                                  		; 30/03/2018
  9730                                  		;mov	ax,[DRVFAT]
  9731                                  		;call	SETDRIVE
  9732                                  		;call	GETBP
  9733                                  		
  9734                                  		; 24/02/2018 - Retro DOS 2.0 - MSDOS 3.3 ("MSINIT.ASM")
  9735                                  
  9736 00002E7F E8D201                  		CALL	SETDRVPARMS
  9737                                  		
  9738                                  		; 06/07/2018
  9739                                  		
  9740                                  		; 03/06/2018 - Retro DOS v3.0
  9741                                  		;JMP	SYSINIT
  9742                                  		; 05/07/2018
  9743 00002E82 E97104                  		jmp	_SYSINIT ; GOINIT
  9744                                  
  9745                                  ;-----------------------------------------------------------------------------
  9746                                  ; 03/06/2018 - Retro DOS v3.0
  9747                                  
  9748                                  Get_Para_Offset:
  9749                                  ;in:  AX - offset value
  9750                                  ;out: AX - offset value adjusted for the next paragraph boundary.
  9751 00002E85 83C00F                  		add	ax, 15		;make a paragraph
  9752 00002E88 D1D8                    		rcr	ax, 1	
  9753 00002E8A D1E8                    		shr	ax, 1	
  9754 00002E8C D1E8                    		shr	ax, 1
  9755 00002E8E D1E8                    		shr	ax, 1
  9756 00002E90 D1E0                    		shl	ax, 1		;now, make it back to offset value
  9757 00002E92 D1E0                    		shl	ax, 1
  9758 00002E94 D1E0                    		shl	ax, 1
  9759 00002E96 D1E0                    		shl	ax, 1
  9760 00002E98 C3                      		retn
  9761                                  
  9762                                  ; 01/07/2018
  9763                                  ;;
  9764                                  ;;	READ A FAT SECTOR INTO fat location
  9765                                  ;;
  9766                                  ;GETFAT:
  9767                                  ;		XOR	DI,DI			; offset
  9768                                  ;		MOV	DX,1			; relative sector (1st sector of fat)
  9769                                  ;		MOV	CX,[FatLen]		; read entire fat.
  9770                                  ;		MOV	AX,[FatLoc]		;
  9771                                  ;		MOV	ES,AX			; location to read
  9772                                  ;		MOV	AX,[DRVFAT]		; AH FAT ID byte, AL drive
  9773                                  ;		JMP	DISKRD
  9774                                  
  9775                                  
  9776                                  ; 02/06/2018 - Retro DOS v3.0	
  9777                                  ; 19/03/2018 - Retro DOS v2.0
  9778                                  
  9779                                  ;	READ A BOOT RECORD INTO 7C0h:BootBias
  9780                                  ;  GetBoot reads the boot record into 7C0h:BootBias
  9781                                  ;  On Entry:
  9782                                  ;	DL contains ROM drive number (80h or 81h)
  9783                                  ;  On Exit:
  9784                                  ;	if carry set error
  9785                                  ;	if carry clear:
  9786                                  ;	   ES:BX piont to boot sector
  9787                                  ;	AX and CX are not preserved
  9788                                  ;	BX and ES are used to return values
  9789                                  ;
  9790                                  GETBOOT:
  9791                                  		; 08/04/2018
  9792                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  9793                                  
  9794                                  		;mov	AX, 07C0h     ; prepare to load ES
  9795                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991	
  9796                                  		;mov	ax, [cs:init_bootseg]
  9797 00002E99 A1[132A]                		mov	ax, [init_bootseg]
  9798 00002E9C 8EC0                    		mov	ES, AX	      ; load ES segment register
  9799 00002E9E BB0002                  		mov	BX, BootBias  ; load BX,  ES:BX is where sector goes
  9800 00002EA1 B80102                  		mov	AX, 0201h     ; command to read & num sec. to 1
  9801 00002EA4 30F6                    		xor	DH, DH	      ; head number zero
  9802 00002EA6 B90100                  		mov	CX, 0001h     ; cylinder zero and sector one
  9803 00002EA9 CD13                    		int	13h	      ; call rom bios
  9804 00002EAB 720A                    		jc	short ERRET
  9805 00002EAD 26813EFE0355AA          		cmp	WORD [ES:BootBias+1FEH],0AA55H	; DAVE LITTON MAGIC WORD?
  9806 00002EB4 7401                    		je	short Norm_Ret
  9807 00002EB6 F9                      		stc
  9808                                  ERRET:
  9809                                  Norm_Ret:
  9810 00002EB7 C3                      		RETN
  9811                                  
  9812                                  ;
  9813                                  ;   SetHard - generate BPB for a variable sized hard file.  IBM has a
  9814                                  ;   partitioned hard file; we must read physical sector 0 to determine where
  9815                                  ;   our own logical sectors start.  We also read in our boot sector to
  9816                                  ;   determine version number
  9817                                  ;
  9818                                  ;   Inputs:	DL is ROM drive number (80 OR 81)
  9819                                  ;		DS:DI points to BDS
  9820                                  ;   Outputs:	Carry clear -> BPB is filled in
  9821                                  ;		Carry set   -> BPB is left uninitialized due to error
  9822                                  ;
  9823                                  
  9824                                  SETHARD:
  9825                                  		; 03/06/2018 - Retro DOS v3.0
  9826                                  		; (20/03/2018 - Retro DOS v2.0)
  9827                                  
  9828 00002EB8 57                      		push	di
  9829 00002EB9 53                      		push	bx
  9830 00002EBA 1E                      		push	ds
  9831 00002EBB 885D05                  		mov	byte [di+BDS.DriveLet],bl
  9832 00002EBE 885504                  		mov	byte [di+BDS.DriveNum],dl
  9833 00002EC1 31C0                    		xor	ax,ax
  9834 00002EC3 0C01                    		or	al,fNon_Removable
  9835 00002EC5 094529                  		or	[di+BDS.Flags],ax
  9836 00002EC8 C6452805                		mov	byte [di+BDS.FormFactor],ffHardFile
  9837 00002ECC C606[A429]00            		mov	byte [fBigFAT],0	; Assume 12 bit FAT
  9838 00002ED1 52                      		PUSH	DX
  9839                                  
  9840 00002ED2 B408                    		mov	AH,8		; set command to get drive parameters
  9841 00002ED4 CD13                    		int	13h		; call rom-bios disk routine
  9842                                  
  9843                                  				; DH is number of heads-1
  9844                                  				; DL is number of hard disks attached
  9845                                  				; Low 6 bits of CL is sectors/track
  9846                                  				; High 2 bits of CL with CH are max # of cylinders
  9847 00002ED6 FEC6                    		INC	DH		; get number of heads
  9848 00002ED8 887515                  		MOV	[DI+BDS.HDLIM],DH
  9849 00002EDB 5A                      		POP	DX
  9850 00002EDC 7223                    		JC	short SETRET	; carry here means no hard disk
  9851 00002EDE 80E13F                  		AND	CL,3FH		; extract number of sectors/track
  9852 00002EE1 884D13                  		MOV	[DI+BDS.SECLIM],CL
  9853 00002EE4 E8B2FF                  		CALL	GETBOOT		;   if (getBoot ())
  9854 00002EE7 7218                    		JC	short SETRET	;	return -1;
  9855 00002EE9 BBC203                  		MOV	BX,1C2H+BootBias ;   p = &boot[0x1C2];
  9856                                  SET1:
  9857 00002EEC 26803F01                		CMP	BYTE [ES:BX],1	;   while (p->PartitionType != 1 &&
  9858 00002EF0 7418                    		JZ	short SET2
  9859 00002EF2 26803F04                		CMP	Byte [ES:BX],4	;	p->PartitionType != 4) {
  9860 00002EF6 7412                    		JZ	short SET2
  9861 00002EF8 83C310                  		ADD	BX,16		;	p += sizeof Partition;
  9862 00002EFB 81FB0204                		CMP	BX,202H+BootBias ;	if (p == &boot[0x202h])
  9863 00002EFF 75EB                    		JNZ	short SET1	;	    return -1;
  9864                                  SETRET:
  9865 00002F01 F9                      		STC			;	}
  9866 00002F02 E94B01                  		jmp	Ret_Hard
  9867                                  
  9868                                  ; --- install a mini disk. BX value saved ---
  9869                                  
  9870                                  SetMini:								 
  9871 00002F05 57                      		push	di							 
  9872 00002F06 53                      		push	bx							 
  9873 00002F07 1E                      		push	ds							 
  9874 00002F08 EBE2                    		jmp	short SET1	;will be returned to Find mini partition routine.
  9875                                  					;Some logic has been added to SET1 to 
  9876                                  					;deal with Mini disks.
  9877                                  SET2:
  9878 00002F0A 52                      		PUSH	DX
  9879 00002F0B 268B4704                		MOV	AX,[ES:BX+4]
  9880 00002F0F 268B5706                		MOV	DX,[ES:BX+6]
  9881                                  
  9882                                  ;Decrement the sector count by 1 to make it zero based. Exactly 64k
  9883                                  ;sectors should be allowed	 
  9884                                  ;				 
  9885 00002F13 83E801                  		SUB	AX,1		; PTM 901    12/12/86 MT
  9886 00002F16 83DA00                  		SBB	DX,0		; PTM 901    12/12/86 MT
  9887                                  
  9888 00002F19 26034708                		ADD	AX,[ES:BX+8]
  9889 00002F1D 2613570A                		ADC	DX,[ES:BX+10]
  9890 00002F21 7405                    		JZ	short OKDrive
  9891 00002F23 800E[A429]80            		OR	byte [fBigFAT],fTOOBIG
  9892                                  OKDrive:
  9893 00002F28 5A                      		POP	DX
  9894 00002F29 268B4704                		MOV	AX,[ES:BX+4]
  9895 00002F2D 894517                  		MOV	[DI+BDS.HIDSEC],AX	; BPB->HidSecCt = p->PartitionBegin;
  9896 00002F30 268B4708                		MOV	AX,[ES:BX+8]
  9897 00002F34 83F840                  		CMP	AX,64		;  if (p->PartitionLength < 64)
  9898 00002F37 72C8                    		JB	short SETRET	;	return -1;
  9899                                  
  9900 00002F39 89450E                  		MOV	[DI+BDS.DRVLIM],AX ; BPB->MaxSec = p->PartitionLength;
  9901 00002F3C 50                      		PUSH	AX
  9902                                  
  9903 00002F3D 52                      		PUSH	DX
  9904 00002F3E 8B4517                  		MOV	AX,[DI+BDS.HIDSEC]	; boot sector number
  9905 00002F41 31D2                    		XOR	DX,DX
  9906 00002F43 88F7                    		MOV	BH,DH
  9907 00002F45 8A5D13                  		MOV	BL,[DI+BDS.SECLIM]
  9908 00002F48 F7F3                    		DIV	BX
  9909 00002F4A 88D1                    		MOV	CL,DL			; CL is sector number
  9910 00002F4C FEC1                    		INC	CL			; sectors are 1 based
  9911 00002F4E 99                      		CWD
  9912 00002F4F 8A5D15                  		MOV	BL,[DI+BDS.HDLIM]
  9913 00002F52 F7F3                    		DIV	BX			; DL is head, AX is cylinder
  9914                                  ;
  9915                                  ; DL is head.
  9916                                  ; AX is cylinder
  9917                                  ; CL is sector number
  9918                                  ; TOS is drive
  9919                                  ;
  9920                                  ;
  9921                                  		; 20/03/2018
  9922                                  ;*** For Mini Disks ***  4/7/86 
  9923 00002F54 837D4D01                		cmp	word [di+BDSM.isMini], 1 ;check for mini disk - 4/7/86
  9924 00002F58 7503                    		jnz	short OKnotMini		;not mini disk. - 4/7/86
  9925 00002F5A 03454F                  		add	ax, [di+BDSM.Hidden_Trks] ;set phy track num - 4/7/86
  9926                                  OKnotMini:				; 4/7/86
  9927                                  ;*** End of added logic for mini disk 
  9928                                  
  9929 00002F5D D0CC                    		ROR	AH,1			; move high two bits of cyl to high
  9930 00002F5F D0CC                    		ROR	AH,1			; two bits of upper byte
  9931 00002F61 80E4C0                  		AND	AH,0C0h 		; turn off remainder of bits
  9932 00002F64 08E1                    		OR	CL,AH			; move two bits to correct spot
  9933 00002F66 88C5                    		MOV	CH,AL			; CH is Cylinder
  9934                                  ;
  9935                                  ; CL is sector + 2 high bits of cylinder
  9936                                  ; CH is low 8 bits of cylinder
  9937                                  ; DL is head
  9938                                  ; TOS is drive
  9939                                  ;
  9940 00002F68 58                      		POP	AX			; AL is drive
  9941 00002F69 88D6                    		MOV	DH,DL			; DH is head
  9942 00002F6B 88C2                    		MOV	DL,AL			; DL is drive
  9943                                  ;
  9944                                  ; CL is sector + 2 high bits of cylinder
  9945                                  ; CH is low 8 bits of cylinder
  9946                                  ; DH is head
  9947                                  ; DL is drive
  9948                                  ;
  9949 00002F6D 31DB                    		xor	BX, BX			; clear BX -- ES:BX points to buffer
  9950 00002F6F B80102                  		mov	ax, 0201h		; set command to read one sector
  9951 00002F72 CD13                    		int	13h			; call rom-bios to read sector
  9952 00002F74 58                      		pop	AX
  9953                                  
  9954                                  ;
  9955                                  ; ES:[0] points to the boot sector.  In theory, (ha ha) the BPB in this thing
  9956                                  ; is correct.  We can, therefore, pull out all the relevant statistics on the
  9957                                  ; media if we recognize the version number.
  9958                                  ;
  9959 00002F75 26813E03004942          		CMP	WORD [ES:3], "IB"  ; "B" SHL 8 + "I"
  9960 00002F7C 751C                    		JNZ	short unknownj
  9961 00002F7E 26813E05004D20          		CMP	WORD [ES:5], "M "  ; " " SHL 8 + "M"
  9962 00002F85 7513                    		JNZ	short unknownj
  9963 00002F87 26813E0800322E          		CMP	WORD [ES:8], "2."  ; "." SHL 8 + "2"
  9964 00002F8E 750C                    		JNZ	short Try5
  9965 00002F90 26803E0A0030            		CMP	BYTE [ES:10], "0"
  9966 00002F96 7504                    		JNZ	short Try5
  9967 00002F98 EB13                    		JMP	SHORT CopyBPB
  9968                                  unknownj:
  9969 00002F9A EB4A                    		jmp	short unknown
  9970                                  Try5:
  9971 00002F9C 26813E0800332E          		CMP	WORD [ES:8],"3."  ; "." SHL 8 + "3"
  9972 00002FA3 75F5                    		JNZ	short unknownj
  9973 00002FA5 26803E0A0031            		cmp	byte [es:10],"1"    ;do not trust 3.0 boot record.  4/15/86
  9974 00002FAB 72ED                    		jb	short unknownj	    ;if version >= 3.1, then O.K.  4/15/86
  9975                                  
  9976                                  CopyBPB:
  9977                                  ; We have a valid Boot sector. Use the BPB in it to build the
  9978                                  ; BPB in BIOS. It is assumed that ONLY SecPerClus, cDIR, and
  9979                                  ; cSecFat need to be set (all other values in already). fBigFat
  9980                                  ; is also set.
  9981 00002FAD 26A11300                		MOV	AX,[ES:11+BDS.DRVLIM-BDS.BytePerSec] ; Total sectors
  9982 00002FB1 48                      		DEC	AX			; Subtract # reserved (always 1)
  9983 00002FB2 268B161600              		MOV	DX,[ES:11+BDS.cSecFat-BDS.BytePerSec] ; Sectors for 1 fat
  9984 00002FB7 895511                  		MOV	[DI+BDS.cSecFat],DX 	; Set in BIOS BPB
  9985 00002FBA D1E2                    		SHL	DX,1			; Always 2 FATs
  9986 00002FBC 29D0                    		SUB	AX,DX			; Sub # FAT sectors
  9987 00002FBE 268B161100              		MOV	DX,[ES:11+BDS.cDir-BDS.BytePerSec] ; # root entries
  9988 00002FC3 89550C                  		MOV	[DI+BDS.cDir],DX	; Set in BIOS BPB
  9989 00002FC6 B104                    		MOV	CL,4
  9990 00002FC8 D3EA                    		SHR	DX,CL			; Div by 16 ents/sector
  9991 00002FCA 29D0                    		SUB	AX,DX			; Sub # dir sectors
  9992                                  		; AX now contains the # of data sectors.
  9993 00002FCC 268A0E0D00              		MOV	CL,[ES:11+BDS.SecPerClus-BDS.BytePerSec] ; Sectors per cluster
  9994 00002FD1 884D08                  		MOV	[DI+BDS.SecPerClus],CL	; Set in BIOS BPB
  9995 00002FD4 31D2                    		XOR	DX,DX
  9996 00002FD6 88F5                    		MOV	CH,DH
  9997 00002FD8 F7F1                    		DIV	CX
  9998                                  		; AX now contains the # clusters.
  9999 00002FDA 3DF60F                  		CMP	AX,4096-10		; is this 16-bit fat?
 10000 00002FDD 7205                    		JB	short GoodRetj		; No
 10001 00002FDF 800E[A429]40            		OR	byte [fBigFAT],fBIG	; 16 bit FAT
 10002                                  GoodRetj:
 10003 00002FE4 EB62                    		JMP	short GoodRet
 10004                                  
 10005                                  unknown:
 10006 00002FE6 BE[D029]                		MOV	SI,DiskTable2
 10007                                  Scan:
 10008 00002FE9 3B04                    		CMP	AX,[SI]
 10009 00002FEB 7605                    		JBE	short GotParm
 10010 00002FED 83C608                  		ADD	SI,4*2
 10011 00002FF0 EBF7                    		JMP	short Scan
 10012                                  GotParm:
 10013 00002FF2 8A4C06                  		MOV	CL,[SI+6]
 10014 00002FF5 080E[A429]              		OR	[fBigFAT],CL
 10015 00002FF9 8B4C02                  		MOV	CX,[SI+2]
 10016 00002FFC 8B5404                  		MOV	DX,[SI+4]
 10017                                  ;
 10018                                  ;	AX = number of sectors on disk drive
 10019                                  ;	DX = number of dir entries,
 10020                                  ;	CH = number of sectors per cluster
 10021                                  ;	CL = log base 2 of ch
 10022                                  ;
 10023                                  ;	NOW CALCULATE SIZE OF FAT TABLE
 10024                                  ;
 10025 00002FFF 89550C                  		MOV	[DI+BDS.cDir],DX	;SAVE NUMBER OF DIR ENTRIES
 10026 00003002 886D08                  		MOV	[DI+BDS.SecPerClus],CH  ;SAVE SECTORS PER CLUSTER
 10027 00003005 F606[A429]40            		TEST	byte [fBigFAT],fBIG	;   if (fBigFat)
 10028 0000300A 751E                    		JNZ	short DoBig	;	goto DoBig;
 10029 0000300C 31DB                    		XOR	BX,BX
 10030 0000300E 88EB                    		MOV	BL,CH
 10031 00003010 4B                      		DEC	BX
 10032 00003011 01C3                    		ADD	BX,AX
 10033 00003013 D3EB                    		SHR	BX,CL			;   BX = 1+(BPB->MaxSec+SecPerClus-1)/
 10034 00003015 43                      		INC	BX			;	    SecPerClus
 10035 00003016 80E3FE                  		AND	BL,11111110b		;   BX &= ~1; (=number of clusters)
 10036 00003019 89DE                    		MOV	SI,BX
 10037 0000301B D1EB                    		SHR	BX,1
 10038 0000301D 01F3                    		ADD	BX,SI
 10039 0000301F 81C3FF01                		ADD	BX,511			;   BX += 511 + BX/2
 10040 00003023 D0EF                    		SHR	BH,1			;   BH >>= 1; (=BX/512)
 10041 00003025 887D11                  		MOV	BYTE [DI+BDS.cSecFat],BH ;SAVE NUMBER OF FAT SECTORS
 10042 00003028 EB1E                    		JMP	SHORT GoodRet	 
 10043                                  DoBig:
 10044 0000302A B104                    		MOV	CL,4			; 16 (2^4) directory entries per sector
 10045 0000302C D3EA                    		SHR	DX,CL			; cSecDir = cDir / 16;
 10046 0000302E 29D0                    		SUB	AX,DX			; AX -= cSecDir; AX -= cSecReserved;
 10047 00003030 48                      		DEC	AX			; ax = t - r - d
 10048 00003031 B302                    		MOV	BL,2
 10049 00003033 8A7D08                  		MOV	BH,[DI+BDS.SecPerClus]	; bx = 256 * secperclus + 2
 10050 00003036 31D2                    		XOR	DX,DX
 10051 00003038 01D8                    		ADD	AX,BX			; ax = t-r-d+256*spc+2
 10052 0000303A 83D200                  		ADC	DX,0
 10053 0000303D 83E801                  		SUB	AX,1			; ax = t-r-d+256*spc+1
 10054 00003040 83DA00                  		SBB	DX,0
 10055 00003043 F7F3                    		DIV	BX			; cSecFat = ceil((total-dir-res)/
 10056                                  						;		 (256*secperclus+2));
 10057 00003045 894511                  		MOV	[DI+BDS.cSecFat],AX	; number of fat sectors
 10058                                  GoodRet:
 10059 00003048 8A1E[A429]              		MOV	BL,[fBigFAT]
 10060 0000304C 885D19                  		MOV	[DI+BDS.FatSiz],BL	; set size of fat on media
 10061 0000304F F8                      		CLC
 10062                                  Ret_Hard:
 10063 00003050 1F                      		pop	ds
 10064 00003051 5B                      		pop	bx
 10065 00003052 5F                      		pop	di
 10066 00003053 C3                      		RETN	
 10067                                  
 10068                                  ; 03/08/2019
 10069                                  ; 06/07/2019 - Retro DOS v3.1
 10070                                  ; (Note: Following offset may change when SYSINIT code will be changed.)
 10071                                  ;BPB_Table equ SYSINIT_START + 169Eh  ; (BPBTable offset in sysinit2.asm)
 10072                                  ;;BPB_Table equ SYSINIT_START + 1C34h
 10073                                  ;BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 10074                                  
 10075                                  ; 22/11/2022
 10076                                  BPB_Table equ SYSINIT_START + 1696h  ; (BPBTable offset in sysinit2.asm)
 10077                                  BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)
 10078                                  
 10079                                  ;
 10080                                  ; SetDrvParms sets up the recommended BPB in each BDS in the system based on
 10081                                  ; the form factor. It is assumed that the BPBs for the various form factors
 10082                                  ; are present in the BPBTable. For hard files, the Recommended BPB is the same
 10083                                  ; as the BPB on the drive.
 10084                                  ; No attempt is made to preserve registers since we are going to jump to
 10085                                  ; SYSINIT straight after this routine.
 10086                                  ;
 10087                                  
 10088                                  SETDRVPARMS:
 10089 00003054 31DB                    		xor	bx,bx
 10090                                  		;les	di,dword ptr [cs:START_BDS] ; get first BDS in list
 10091 00003056 2EC43E[FA00]            		les	di,[cs:START_BDS] ; 03/07/2018
 10092                                  NextBDS:
 10093 0000305B 83FFFF                  		cmp	di,-1
 10094 0000305E 7501                    		jnz	short Do_SetP
 10095                                  Done_SetParms:
 10096 00003060 C3                      		RETN
 10097                                  Do_SetP:
 10098 00003061 06                      		push	es
 10099 00003062 57                      		push	di			; preserve pointer to BDS
 10100                                  		;mov	bl,es:[di].FormFactor
 10101 00003063 268A5D28                		mov	bl,[es:di+BDS.FormFactor]
 10102 00003067 80FB05                  		cmp	bl,ffHardFile
 10103 0000306A 7524                    		jnz	short NotHardFF
 10104                                  		;mov	ax,es:[di].DrvLim
 10105 0000306C 268B450E                		mov	ax,[es:di+BDS.DRVLIM]
 10106 00003070 50                      		push	ax
 10107                                  		;mov	ax,wo"rd ptr es:[di].hdlim
 10108 00003071 268B4515                		mov	ax,[es:di+BDS.HDLIM]
 10109                                  		;mul	word ptr es:[di].seclim
 10110 00003075 26F76513                		mul	word [es:di+BDS.SECLIM]
 10111 00003079 89C1                    		mov	cx,ax			; cx has # sectors per cylinder
 10112 0000307B 58                      		pop	ax
 10113 0000307C 31D2                    		xor	dx,dx			; set up for div
 10114 0000307E F7F1                    		div	cx			; div #sec by sec/cyl to get # cyl
 10115 00003080 09D2                    		or	dx,dx
 10116 00003082 7401                    		jz	short No_Cyl_Rnd	; came out even
 10117 00003084 40                      		inc	ax			; round up
 10118                                  No_Cyl_Rnd:
 10119                                  		;mov	es:[di].cCyln,ax
 10120 00003085 2689452B                		mov	[es:di+BDS.cCyln],ax
 10121 00003089 06                      		push	es
 10122 0000308A 1F                      		pop	ds
 10123                                  		;lea	si,[di].BytePerSec	; ds:si -> BPB for hard file
 10124 0000308B 8D7506                  		lea	si,[di+BDS.BytePerSec]
 10125                                  
 10126 0000308E EB3C                    		jmp	short Set_RecBPB
 10127                                  NotHardFF:
 10128 00003090 0E                      		push	cs
 10129 00003091 1F                      		pop	ds
 10130 00003092 80FB07                  		cmp	bl,ffOther		; Special case "other" type of medium
 10131 00003095 752A                    		JNZ	short NOT_PROCESS_OTHER
 10132                                  Process_Other:
 10133 00003097 31D2                    		xor	dx,dx
 10134                                  		;mov	ax,[di].cCyln
 10135                                  		;mov	bx,[di].RHdlim
 10136 00003099 8B452B                  		mov	ax,[di+BDS.cCyln]
 10137 0000309C 8B5D3C                  		mov	bx,[di+BDS.RHDLIM]
 10138 0000309F F7E3                    		mul	bx
 10139                                  		;mov	bx,[di].RSeclim
 10140 000030A1 8B5D3A                  		mov	bx,[di+BDS.RSECLIM]
 10141 000030A4 F7E3                    		mul	bx
 10142                                  		;mov	[di].RDrvlim,ax 	; Have the total number of sectors
 10143 000030A6 894535                  		mov	[di+BDS.RDRVLIM],ax
 10144 000030A9 48                      		dec	ax
 10145                                  
 10146                                  ; New logic to get the sectors/fat area.				  
 10147                                  						;Fat entry assumed to be 1.5 bytes
 10148 000030AA BB0300                  		mov	bx,3
 10149 000030AD F7E3                    		mul	bx
 10150 000030AF BB0200                  		mov	bx,2
 10151 000030B2 F7F3                    		div	bx
 10152 000030B4 31D2                    		xor	dx,dx
 10153 000030B6 BB0002                  		mov	bx,512
 10154 000030B9 F7F3                    		div	bx
 10155 000030BB 40                      		inc	ax
 10156                                  No_Round_Up:
 10157                                  		;mov	[di].RcSecFat,ax
 10158 000030BC 894538                  		mov	[di+BDS.RcSecFat],ax
 10159 000030BF EB13                    		jmp	short Go_To_Next_BDS
 10160                                  
 10161                                  NOT_PROCESS_OTHER:
 10162 000030C1 D1E3                    		shl	bx,1			; bx is word index into table of BPBs
 10163                                  		;mov	si,offset BPBTable
 10164                                  		; 06/07/2018
 10165 000030C3 BE[B649]                		mov	si,BPB_Table  ; Retro DOS v3.0 modification (06/07/2018)
 10166                                  				      ; (FD BPB Tables are in SYINIT section)
 10167                                  		;mov	si,word ptr [si+bx]	; get address of BPB
 10168 000030C6 8B30                    		mov	si,[si+bx]
 10169                                  
 10170                                  		; 28/08/2023 (BugFix)
 10171 000030C8 81C6[2033]              		add	si,SYSINIT_START
 10172                                  Set_RecBPB:
 10173                                  		;lea	di,[di].RBytePerSec	; es:di -> RecBPB
 10174 000030CC 8D7D2D                  		lea	di,[di+BDS.RBytePerSec]
 10175 000030CF B91900                  		mov	cx,BPBSIZ
 10176 000030D2 F3A4                    		REP	MOVSB			; MOVE BPBSIZ BYTES
 10177                                  Go_To_Next_BDS:
 10178 000030D4 5F                      		pop	di
 10179 000030D5 07                      		pop	es			; restore pointer to BDS
 10180                                  		;mov	bx,word ptr es:[di].link+2
 10181                                  		;mov	di,word ptr es:[di].link
 10182 000030D6 268B5D02                		mov	bx,[es:di+BDS.Link+2]
 10183                                  		;mov	di,[es:di+BDS.Link]
 10184 000030DA 268B3D                  		mov	di,[es:di] ; 05/07/2019
 10185 000030DD 8EC3                    		mov	es,bx
 10186 000030DF E979FF                  		jmp	NextBDS
 10187                                  
 10188                                  ; ----------------------------------------------------------------------------
 10189                                  ; 03/06/2018 - Retro DOS v3.0
 10190                                  
 10191                                  
 10192                                  ; SI POINTS TO DEVICE HEADER
 10193                                  ;
 10194                                  ;  4/22/86 - print_init, aux_init is modified to eliminate the
 10195                                  ;  self-modifying code.
 10196                                  
 10197                                  PRINT_INIT:
 10198 000030E2 E80F00                  		call	GET_DEVICE_NUMBER
 10199 000030E5 B401                    		mov	ah,1		;initalize printer port
 10200 000030E7 CD17                    		int	17h		;call ROM-Bios routine
 10201 000030E9 C3                      		retn
 10202                                  
 10203                                  AUX_INIT:
 10204 000030EA E80700                  		call	GET_DEVICE_NUMBER
 10205 000030ED B0A3                    		mov	al,RSINIT	;2400,N,1,8 (MSEQU.INC)
 10206 000030EF B400                    		mov	ah,0		;initalize AUX port
 10207 000030F1 CD14                    		int	14h		;call ROM-Bios routine
 10208 000030F3 C3                      		retn
 10209                                  
 10210                                  GET_DEVICE_NUMBER:
 10211                                  ;SI -> device header
 10212                                  		; 16/06/2018
 10213 000030F4 2E8A440D                		MOV	AL,[CS:SI+13]	;GET DEVICE NUMBER FROM THE NAME
 10214                                  		;MOV	AL,[SI+13]
 10215 000030F8 2C31                    		SUB	AL,"1"
 10216 000030FA 98                      		CBW
 10217 000030FB 89C2                    		MOV	DX,AX
 10218 000030FD C3                      		RETN
 10219                                  
 10220                                  ; ----------------------------------------------------------------------------
 10221                                  
 10222                                  ;
 10223                                  ;   purge_96tpi NOP's calls to 96tpi support.
 10224                                  ;
 10225                                  PURGE_96TPI:
 10226 000030FE 1E                      		PUSH	DS
 10227 000030FF 06                      		PUSH	ES
 10228                                  
 10229 00003100 0E                      		push	cs			;mjb001
 10230 00003101 07                      		pop	es			;mjb001
 10231 00003102 0E                      		push	cs			;mjb001
 10232 00003103 1F                      		pop	ds			;mjb001
 10233                                  		
 10234 00003104 BE[F529]                		MOV	SI,PatchTable
 10235                                  PatchLoop:
 10236 00003107 AD                      		LODSW
 10237 00003108 89C1                    		MOV	CX,AX
 10238 0000310A E309                    		JCXZ	PatchDone
 10239 0000310C AD                      		LODSW
 10240 0000310D 89C7                    		MOV	DI,AX
 10241 0000310F B090                    		MOV	AL,90h
 10242 00003111 F3AA                    		REP	STOSB
 10243 00003113 EBF2                    		JMP	short PatchLoop
 10244                                  
 10245                                  PatchDone:
 10246 00003115 BF[2507]                		mov	di,TABLE_PATCH		;ARR 2.42
 10247 00003118 B8[F606]                		MOV	AX,EXIT
 10248 0000311B AB                      		STOSW
 10249 0000311C AB                      		STOSW
 10250                                  
 10251 0000311D 07                      		POP	ES
 10252 0000311E 1F                      		POP	DS
 10253 0000311F C3                      		retn				;mjb001
 10254                                  
 10255                                  ; ----------------------------------------------------------------------------
 10256                                  ; 03/06/2018 - Retro DOS v3.0
 10257                                  ; (19/03/2018 - Retro DOS v2.0)
 10258                                  
 10259                                  ;Mini disk initialization routine. Called right after DoHard - 4/7/86
 10260                                  ; DoMini **************************************************************** 
 10261                                  ; **CS=DS=ES=code							
 10262                                  ; **DoMini will search for every extended partition in the system, and
 10263                                  ;   initialize it.							
 10264                                  ; **BDSM stands for BDS table for Mini disk and located right after the
 10265                                  ;   label End96Tpi. End_Of_BDSM will have the offset value of the ending
 10266                                  ;   address of BDSM table.						 
 10267                                  ; **BDSM is the same as usual BDS except that TIM_LO, TIM_HI entries are
 10268                                  ;   overlapped and used to id mini disk and the number of Hidden_trks.
 10269                                  ;   Right now, they are called as IsMini, Hidden_Trks respectively.
 10270                                  ; **DoMini will use the same routine in SETHARD routine after label SET1
 10271                                  ;   to save coding.							
 10272                                  ; **DRVMAX determined in DoHard routine will be used for the next
 10273                                  ;   available logical mini disk drive number.	
 10274                                  ;								
 10275                                  ; Input: DRVMAX, DSKDRVS					
 10276                                  ;								
 10277                                  ; Output: MiniDisk installed. BDSM table established and installed to BDS.
 10278                                  ;	  num_mini_dsk - number of mini disks installed in the system.
 10279                                  ;	  End_Of_BDSM - ending offset address of BDSM.		
 10280                                  ;								
 10281                                  ;									
 10282                                  ; Called modules:						
 10283                                  ;		  GetBoot, WRMSG, int 13h (AH=8, Rom)		
 10284                                  ;		  FIND_MINI_PARTITION (new), Install_BDSM (new),
 10285                                  ;		  SetMini (new, it will use SET1 routine)	
 10286                                  ; Variables used: End_Of_BDSM, numh, mininum, num_mini_dsk,	
 10287                                  ;		  Rom_Minidsk_num, Mini_HDLIM, Mini_SECLIM		
 10288                                  ;		  BDSMs, BDSM_type (struc), START_BDS			
 10289                                  ;***********************************************************************
 10290                                  ;
 10291                                  
 10292                                  DoMini:
 10293                                  		;push	ax			;Do I need to do this?
 10294                                  
 10295 00003120 BF[711E]                		mov	di,BDSMs		;from now on, DI points to BDSM
 10296 00003123 B280                    		mov	dl,80h 			;look at first hard drive
 10297 00003125 B408                    		mov	ah,08h			;get drive parameters
 10298 00003127 CD13                    		int	13h			;call ROM-Bios
 10299 00003129 80FA00                  		cmp	dl, 0
 10300 0000312C 7451                    		jz	short DoMiniRet		;no hard file? Then exit.
 10301 0000312E 8816[E229]              		mov	[numh],dl		;save the number of hard files.
 10302 00003132 31C0                    		xor	ax,ax
 10303 00003134 A0[6A00]                		mov	al,[DRVMAX]
 10304 00003137 A2[E329]                		mov	[mininum],al		;this will be logical drive letter
 10305                                  						;for mini disk to start with.
 10306                                  
 10307 0000313A D1E0                    		shl	ax,1			;ax=number of devices. word bndry
 10308 0000313C 53                      		push	bx
 10309 0000313D BB[E405]                		mov	bx,DSKDRVS
 10310 00003140 01C3                    		add	bx,ax
 10311 00003142 891E[EA29]              		mov	[Mini_BPB_ptr],BX	;Mini_BPB_ptr points to first avlb
 10312                                  						;spot in DskDrvs for Mini disk
 10313                                  						;which points to BPB area of BDSM.
 10314 00003146 5B                      		pop	bx
 10315                                  
 10316 00003147 C606[E529]80            		mov	byte [Rom_Minidsk_num],80h
 10317                                  DoMiniBegin:
 10318 0000314C FEC6                    		inc	dh			;Get # of heads (conv to 1 based)
 10319 0000314E 31C0                    		xor	ax,ax
 10320 00003150 88F0                    		mov	al,dh
 10321 00003152 A3[E629]                		mov	[Mini_HDLIM],ax		;save it.
 10322 00003155 31C0                    		xor	ax,ax
 10323 00003157 80E13F                  		and	cl,3Fh	 		;Get # of sectors/track
 10324 0000315A 88C8                    		mov	al,cl
 10325 0000315C A3[E829]                		mov	[Mini_SECLIM],ax 	;and save it.
 10326                                  
 10327 0000315F 8A16[E529]              		mov	dl,[Rom_Minidsk_num]	;drive number <DL>
 10328 00003163 E833FD                  		call	GETBOOT 		;rd master boot rec 7c0:BootBias
 10329 00003166 7203                    		jc	short DoMiniNext
 10330 00003168 E81500                  		call	FIND_MINI_PARTITION
 10331                                  DoMiniNext:
 10332 0000316B FE0E[E229]              		dec	byte [numh]
 10333 0000316F 740E                    		jz	short DoMiniRet
 10334 00003171 FE06[E529]              		inc	byte [Rom_Minidsk_num] 	;Next hard file
 10335 00003175 8A16[E529]              		mov	dl,[Rom_Minidsk_num]	;look at next hard drive
 10336 00003179 B408                    		mov	ah,08h			;get drive parameters
 10337 0000317B CD13                    		int	13h			;call ROM-Bios
 10338 0000317D EBCD                    		jmp	short DoMiniBegin
 10339                                  
 10340                                  DoMiniRet:
 10341                                  		;pop	ax
 10342                                  FmpRet: 			; 19/03/2018 -  Retro DOS v2.0
 10343 0000317F C3                      		retn
 10344                                  
 10345                                  ;Find_Mini_Partition tries to find every Extended partition on a disk.
 10346                                  ;At entry:	DI -> BDSM entry
 10347                                  ;		ES:BX -> 07C0:BootBias - Master Boot Record
 10348                                  ;		Rom_Minidsk_num - ROM drive number
 10349                                  ;		MiniNum - Logical drive number
 10350                                  ;		Mini_HDLIM, Mini_SECLIM 
 10351                                  ;
 10352                                  ;Called routine: SETMINI which uses SET1 (in SETHARD routine)
 10353                                  ;Variables & equates used from orig BIOS - flags, fNon_Removable, fBigfat
 10354                                  ;
 10355                                  
 10356                                  FIND_MINI_PARTITION:
 10357 00003180 81C3C201                		add	bx,1C2h			;BX -> system id.
 10358                                  FmpNext:
 10359                                  		; 05/07/2019 - Retro DOS v3.1
 10360 00003184 26803F05                		cmp	byte [ES:BX],5		; 5 = extended partition ID.
 10361 00003188 740A                    		je	short FmpGot
 10362 0000318A 83C310                  		add	bx,16			; for next entry
 10363 0000318D 81FB0204                		cmp	bx,202h+BootBias ; 402h
 10364 00003191 75F1                    		jnz	short FmpNext
 10365                                  		;jmp	short FmpRet		;not found extended partition
 10366 00003193 C3                      		retn
 10367                                  FmpGot:
 10368 00003194 31C0                    		xor	ax,ax
 10369 00003196 0C01                    		or	al,fNon_Removable ; 1
 10370 00003198 094529                  		or	[DI+BDS.Flags],ax
 10371 0000319B C6452805                		mov	byte [DI+BDS.FormFactor],ffHardFile ; 5
 10372 0000319F C606[A429]00            		mov	byte [fBigFAT],0	;assume 12 bit Fat.
 10373 000031A4 A1[E629]                		mov	ax,[Mini_HDLIM]
 10374 000031A7 894515                  		mov	[DI+BDS.HDLIM],ax
 10375 000031AA A1[E829]                		mov	ax,[Mini_SECLIM]
 10376 000031AD 894513                  		mov	[DI+BDS.SECLIM],ax
 10377 000031B0 A0[E529]                		mov	al,[Rom_Minidsk_num]
 10378 000031B3 884504                  		mov	[DI+BDS.DriveNum],al	;set physical number
 10379 000031B6 A0[E329]                		mov	al,[mininum]
 10380 000031B9 884505                  		mov	[DI+BDS.DriveLet],al	;set logical number
 10381                                  
 10382 000031BC 26837F0840              		cmp	word [ES:BX+8],64 ;**With current BPB, only lower word	
 10383                                  					; is meaningful.			
 10384 000031C1 74BC                    		je	short FmpRet	;should be bigger than 64 sectors at least
 10385 000031C3 83EB04                  		sub	bx,4		;let BX point to the start of the entry 
 10386 000031C6 268A7702                		mov	dh,[ES:BX+2]						
 10387 000031CA 80E6C0                  		and	dh,11000000b		;get higher bits of cyl 
 10388 000031CD D0C6                    		rol	dh,1
 10389 000031CF D0C6                    		rol	dh,1	
 10390 000031D1 268A5703                		mov	dl,[ES:BX+3]		;cyl byte
 10391 000031D5 89554F                  		mov	[DI+BDSM.Hidden_Trks],dx ;set hidden trks
 10392                                  ;** Now, read the volume boot record into BootBias.
 10393 000031D8 268B4F02                		mov	cx,[ES:BX+2]		;cylinder,cylinder/sector
 10394 000031DC 268A7701                		mov	dh,[ES:BX+1]		;head
 10395 000031E0 8A16[E529]              		mov	dl,[Rom_Minidsk_num]	;drive
 10396                                  		; 03/07/2018
 10397                                  		;mov	ax,7C0h 		;
 10398 000031E4 A1[132A]                		mov	ax,[init_bootseg]
 10399 000031E7 8EC0                    		mov	es,ax			;buffer segment
 10400 000031E9 BB0002                  		mov	bx,BootBias ; 200h	;buffer offset
 10401 000031EC B80102                  		mov	ax,0201h		;read,1 sector
 10402 000031EF CD13                    		int	13h			;call ROM-Bios routine
 10403 000031F1 728C                    		jc	short FmpRet		;cannot continue.
 10404 000031F3 BBC203                  		mov	bx,1C2h+BootBias ; 3C2h
 10405                                  
 10406 000031F6 E80CFD                  		call	SetMini 		;install a mini disk. BX value saved.
 10407 000031F9 7225                    		jc	short FmpNextChain
 10408                                  
 10409 000031FB E82500                  		call	INSTALL_BDSM		;install the BDSM into the BDS table
 10410 000031FE FE06[E329]              		inc	byte [mininum] 		;increase the logical drive number for next
 10411 00003202 FE06[E429]              		inc	byte [num_mini_dsk]	;increase the number of mini disk installed.
 10412                                  
 10413 00003206 53                      		push	bx			;now, set the DskDrvs pointer to BPB info.
 10414 00003207 8B1E[EA29]              		mov	bx,[Mini_BPB_ptr]
 10415                                  		;lea	si,[di].BytePerSec	;points to BPB of BDSM
 10416 0000320B 8D7506                  		lea	si,[di+BDSM.mBytePerSec]
 10417 0000320E 8937                    		mov	[bx],si
 10418 00003210 FF06[EA29]              		inc	word [Mini_BPB_ptr]	;advance to the next address
 10419 00003214 FF06[EA29]              		inc	word [Mini_BPB_ptr]
 10420 00003218 5B                      		pop	bx							 
 10421                                  								 
 10422                                  		;add	DI,type BDSM_type	;adjust to the next BDSM table entry. 
 10423 00003219 83C751                  		add	DI,BDSM.size  ; 81
 10424 0000321C 893E[E029]              		mov	[End_Of_BDSM],DI	;set the ending address of BDSM table to this. 
 10425                                  
 10426                                  FmpNextChain:
 10427 00003220 E961FF                  		jmp	FmpNext		;let's find out if we have any chained partition
 10428                                  ;FmpRet: 								 
 10429                                  ;		retn
 10430                                  
 10431                                  ;SetMini:								 
 10432                                  ;		push	di							 
 10433                                  ;		push	bx							 
 10434                                  ;		push	ds							 
 10435                                  ;		jmp	short SET1	;will be returned to Find mini partition routine.
 10436                                  ;					;Some logic has been added to SET1 to 
 10437                                  ;					;deal with Mini disks.				  ;3.30
 10438                                  														  ;3.30
 10439                                  ;									 
 10440                                  ;Install BDSM installs a BDSM (pointed by DS:DI) into the end of the current 
 10441                                  ;linked list of BDS.							 
 10442                                  ;Also, set the current BDSM pointer segment to DS.			 
 10443                                  ;At entry: DS:DI -> BDSM						 
 10444                                  ;
 10445                                  									 
 10446                                  INSTALL_BDSM:								 
 10447 00003223 50                      		push	ax							 
 10448 00003224 56                      		push	si							 
 10449 00003225 06                      		push	es							 
 10450                                  									 
 10451                                  		;les	si, dword ptr cs:START_BDS	;start of the beginning of list
 10452 00003226 C436[FA00]              		les	si, [START_BDS]
 10453                                  I_BDSM_Next:								 
 10454 0000322A 26833CFF                		cmp	word [es:si], -1		;end of the list?	 
 10455 0000322E 740B                    		jz	short I_BDSM_New						 
 10456                                  		;mov	si, [es:si+BDSM.mLink]
 10457 00003230 268B34                  		mov	si, [es:si] ; 05/07/2019				 
 10458 00003233 268B4402                		mov	ax, [es:si+BDSM.mLink+2]	;next pointer		 
 10459 00003237 8EC0                    		mov	es, ax							 
 10460 00003239 EBEF                    		jmp	short I_BDSM_Next					 
 10461                                  I_BDSM_New:								 
 10462 0000323B 8CD8                    		mov	ax, ds							 
 10463 0000323D 894502                  		mov	[di+BDSM.mLink+2], ax	;BDSM segment had not been initialized.
 10464 00003240 26894402                		mov	[es:si+BDSM.mLink+2], ax				 
 10465                                  		;mov	[es:si+BDSM.mLink], di
 10466 00003244 26893C                  		mov	[es:si], di ; 05/07/2019				 
 10467                                  		;mov	word [di+BDSM.mLink], -1	;make sure it is a null ptr.
 10468 00003247 C705FFFF                		mov	word [di], -1 ; 05/07/2019 
 10469                                  I_BDSM_ret:								 
 10470 0000324B 07                      		pop	es							 
 10471 0000324C 5E                      		pop	si							 
 10472 0000324D 58                      		pop	ax							 
 10473 0000324E C3                      		retn								 
 10474                                  									 
 10475                                  ;**End of mini disk initialization**	; 4/7/86
 10476                                  
 10477                                  ; ----------------------------------------------------------------------------
 10478                                  ; 03/06/2018 - Retro DOS v3.0
 10479                                  
 10480                                  CMOS_CLOCK_READ:
 10481                                  														  ;3.30
 10482                                  ; IN ORDER TO DETERMINE IF THERE IS A CLOCK PRESENT IN THE SYSTEM, THE FOLLOWING 
 10483                                  ; NEEDS TO BE DONE.							 
 10484 0000324F 50                      		PUSH	AX							 
 10485 00003250 51                      		PUSH	CX							 
 10486 00003251 52                      		PUSH	DX							 
 10487 00003252 55                      		PUSH	BP							 
 10488                                  									 
 10489 00003253 31ED                    		XOR	BP,BP							 
 10490                                  LOOP_CLOCK:								 
 10491 00003255 31C9                    		XOR	CX,CX							 
 10492 00003257 31D2                    		XOR	DX,DX							 
 10493 00003259 B402                    		MOV	AH,2			;READ REAL TIME CLOCK
 10494 0000325B CD1A                    		INT	1Ah			;CALL ROM-BIOS ROUTINE
 10495 0000325D 83F900                  		CMP	CX,0							 
 10496 00003260 7512                    		JNZ	short CLOCK_PRESENT						 
 10497                                  									 
 10498 00003262 83FA00                  		CMP	DX,0							 
 10499 00003265 750D                    		JNZ	short CLOCK_PRESENT						 
 10500                                  									 
 10501 00003267 83FD01                  		CMP	BP,1			; READ AGAIN AFTER A SLIGHT DELAY, IN CASE CLOCK
 10502 0000326A 741B                    		JZ	short NO_READDATE	; WAS AT ZERO SETTING.		 
 10503                                  									 
 10504 0000326C 45                      		INC	BP			; ONLY PERFORM DELAY ONCE.	 
 10505 0000326D B90040                  		MOV	CX,4000H						 
 10506                                  DELAY:									 
 10507 00003270 E2FE                    		LOOP	DELAY							 
 10508 00003272 EBE1                    		JMP	LOOP_CLOCK						 
 10509                                  									 
 10510                                  CLOCK_PRESENT:								 
 10511                                  		;mov	byte [cs:HaveCMOSClock], 1 ; Set the flag for cmos clock 
 10512 00003274 C606[8A04]01            		mov	byte [HaveCMOSClock], 1
 10513                                  									 
 10514 00003279 E81000                  		call	CMOSCK			; Reset CMOS clock rate that may be  
 10515                                  						; possibly destroyed by CP DOS and 
 10516                                  						; POST routine did not restore that.			 
 10517 0000327C 56                       		PUSH	SI							 
 10518 0000327D E877F5                  		CALL	READ_REAL_DATE		;READ REAL-TIME CLOCK FOR DATE 
 10519                                  									 
 10520 00003280 FA                      		CLI			 
 10521 00003281 8936[8804]              		MOV	[DAYCNT],SI		;SET SYSTEM DATE		 
 10522 00003285 FB                      		STI			 
 10523 00003286 5E                      		POP	SI			 
 10524                                  NO_READDATE:								 
 10525 00003287 5D                      		POP	BP							 
 10526 00003288 5A                      		POP	DX							 
 10527 00003289 59                      		POP	CX							 
 10528 0000328A 58                      		POP	AX							 
 10529 0000328B C3                      		RETN								 
 10530                                  				 
 10531                                  ;									 
 10532                                  ; 10/28/86								 
 10533                                  ; THE FOLLOWING CODE IS WRITTEN BY JACK GULLEY IN ENGINEERING GROUP. 
 10534                                  ; CP DOS IS CHANGING CMOS CLOCK RATE FOR ITS OWN PURPOSES AND IF THE 
 10535                                  ; USE COLD BOOT THE SYSTEM TO USE PC DOS WHILE RUNNING CP DOS, THE CMOS 
 10536                                  ; CLOCK RATE ARE STILL SLOW WHICH SLOW DOWN DISK OPERATIONS OF PC DOS 
 10537                                  ; WHICH USES CMOS CLOCK. PC DOS IS PUT THIS CODE IN MSINIT TO FIX THIS 
 10538                                  ; PROBLEM AT THE REQUEST OF CP DOS. 				 
 10539                                  ; THE PROGRAM IS MODIFIED TO BE RUN ON MSINIT. Equates are defined in CMOSEQU.INC. 
 10540                                  ; This program will be called by CMOS_Clock_Read procedure. 	 
 10541                                  ;									 
 10542                                  ;  The following code CMOSCK is used to insure that the CMOS has not	 
 10543                                  ;	had its rate controls left in an invalid state on older AT's.
 10544                                  ;									 
 10545                                  ;	It checks for an AT model byte "FC" with a submodel type of
 10546                                  ;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate	 
 10547                                  ;	bits incase POST has not done it. This initilization routine	 
 10548                                  ;	is only needed once when DOS loads. It should be ran as soon	 
 10549                                  ;	as possible to prevent slow diskette access.			 
 10550                                  ;									 
 10551                                  ;	This code exposes one to DOS clearing CMOS setup done by a	 
 10552                                  ;	resident program that hides and re-boots the system.		 
 10553                                  ;									 
 10554                                  CMOSCK:					; CHECK AND RESET RTC RATE BITS 
 10555                                  									 
 10556                                  ;Model byte and Submodel byte were already determined in MSINIT.	 
 10557 0000328C 50                      		push	ax
 10558                                  
 10559                                  	; 16/06/2018 - Retro DOS v3.0
 10560                                  
 10561                                  	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)							 
 10562                                  
 10563                                  	;cmp	cs:Model_byte, 0FCh ;check for PC-AT model byte	 
 10564 0000328D 803E[A205]FC            		cmp	byte [MODEL_BYTE],0FCh	
 10565                                  	;			 	; EXIT IF NOT "FC" FOR A PC-AT
 10566 00003292 7523                    		JNE	short CMOSCK9	; Exit if not an AT model	 
 10567                                  									 
 10568                                  	;CMP	cs:Secondary_Model_Byte,06H  ; Is it 06 for the industral AT 
 10569 00003294 803E[A305]06            		CMP	byte [Secondary_Model_Byte],06h
 10570 00003299 7407                    		JE	short CMOSCK4 	; Go reset CMOS periodic rate if 06 
 10571                                  	;CMP	cs:Secondary_Model_Byte,04H  ; Is it 00, 01, 02, or 03	 
 10572 0000329B 803E[A305]04            		cmp	byte [Secondary_Model_Byte],04h
 10573 000032A0 7315                    		JNB	short CMOSCK9 	; EXIT if problem fixed by POST  
 10574                                  					; Also,Secondary_model_byte = 0 
 10575                                  					;   when AH=0c0h, int 15h failed.
 10576                                  CMOSCK4:				;	RESET THE CMOS PERIODIC RATE 
 10577                                  					;  Model=FC submodel=00,01,02,03 or 06 
 10578                                  
 10579                                  		;mov	al,CMOS_REG_A or NMI	;NMI disabled on return
 10580 000032A2 B08A                    		mov	al,CMOS_REG_A + NMI	
 10581 000032A4 B426                    		mov	ah,00100110b		;Set divider & rate selection
 10582 000032A6 E83000                  		call	CMOS_WRITE
 10583                                  
 10584                                  		;mov	al,CMOS_REG_B or NMI	;NMI disabled on return
 10585 000032A9 B08B                    		mov	al,CMOS_REG_B + NMI	
 10586 000032AB E80B00                  		call	CMOS_READ
 10587 000032AE 2407                    		and	al,00000111b		;clear SET,PIE,AIE,UIE,SQWE
 10588 000032B0 88C4                    		mov	ah,al
 10589 000032B2 B00B                    		mov	al,CMOS_REG_B		;NMI enabled on return
 10590 000032B4 E82200                  		call	CMOS_WRITE
 10591                                  
 10592                                  CMOSCK9:					; EXIT ROUTINE		 
 10593 000032B7 58                      		pop	ax							 
 10594 000032B8 C3                      		RETN				; RETurn to caller		 
 10595                                  						;  Flags modifyied		 
 10596                                  							 
 10597                                  ;--- CMOS_READ ----------------------------------------------------------------- 
 10598                                  ;		READ BYTE FROM CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10599                                  ;									       :
 10600                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE READ				       :
 10601                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10602                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO READ		       :
 10603                                  ;									       :
 10604                                  ; OUTPUT: (AL)	VALUE AT LOCATION (AL) MOVED INTO (AL).  IF BIT 7 OF (AL) WAS  :
 10605                                  ;		ON THEN NMI LEFT DISABLED.  DURING THE CMOS READ BOTH NMI AND  :
 10606                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10607                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10608                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10609                                  ;		ONLY THE (AL) REGISTER AND THE NMI STATE IS CHANGED.	       :
 10610                                  ;------------------------------------------------------------------------------- 
 10611                                  									 
 10612                                  CMOS_READ:				; READ LOCATION (AL) INTO (AL) 
 10613 000032B9 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10614                                  
 10615 000032BA FA                      		cli
 10616 000032BB 53                      		push	bx
 10617 000032BC 50                      		push	ax		;save user NMI state
 10618 000032BD 0C80                    		or	al,NMI		;disable NMI for us
 10619 000032BF E670                    		out	CMOS_PORT,al
 10620 000032C1 90                      		nop			;undocumented delay needed
 10621 000032C2 E471                    		in	al,CMOS_DATA	;get data value
 10622                                  
 10623                                  		 ;set NMI state to user specified 
 10624 000032C4 89C3                    		mov	bx,ax		;save data value
 10625 000032C6 58                      		pop	ax		;get user NMI
 10626 000032C7 2480                    		and	al,NMI
 10627 000032C9 0C0F                    		or	al,CMOS_SHUT_DOWN
 10628 000032CB E670                    		out	CMOS_PORT,al
 10629 000032CD 90                      		nop
 10630 000032CE E471                    		in	al,CMOS_DATA
 10631                                  
 10632 000032D0 89D8                    		mov	ax,bx		;data value
 10633 000032D2 5B                      		pop	bx
 10634                                  
 10635 000032D3 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10636 000032D4 E80100                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10637 000032D7 C3                      		RETN			; RETURN WITH FLAGS RESTORED	 
 10638                                  									 
 10639                                  CMOS_POPF:				; POPF FOR LEVEL B- PARTS  
 10640 000032D8 CF                      		IRET			; RETURN FAR AND RESTORE FLAGS	 
 10641                                  									 
 10642                                  							 
 10643                                  ;--- CMOS_WRITE ----------------------------------------------------------------
 10644                                  ;		WRITE BYTE TO CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 10645                                  ;									       :
 10646                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE WRITTEN TO			       :
 10647                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 10648                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO WRITE		       :
 10649                                  ;	 (AH)=	NEW VALUE TO BE PLACED IN THE ADDRESSED TABLE LOCATION	       :
 10650                                  ;									       :
 10651                                  ; OUTPUT:	VALUE IN (AH) PLACED IN LOCATION (AL) WITH NMI LEFT DISABLED   :
 10652                                  ;		IF BIT 7 OF (AL) IS ON.  DURING THE CMOS UPDATE BOTH NMI AND   :
 10653                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 10654                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 10655                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 10656                                  ;		ONLY THE CMOS LOCATION AND THE NMI STATE IS CHANGED.	       :
 10657                                  ;-------------------------------------------------------------------------------
 10658                                  									 
 10659                                  CMOS_WRITE:				; WRITE (AH) TO LOCATION (AL) 
 10660 000032D9 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 10661 000032DA 50                      		PUSH	AX		; SAVE WORK REGISTER VALUES	 
 10662                                  
 10663 000032DB FA                      		cli
 10664 000032DC 50                      		push	ax		;save user NMI state
 10665 000032DD 0C80                    		or	al,NMI		;disable NMI for us
 10666 000032DF E670                    		out	CMOS_PORT,al
 10667 000032E1 90                      		nop
 10668 000032E2 88E0                    		mov	al,ah
 10669 000032E4 E671                    		out	CMOS_DATA,al	;write data
 10670                                  
 10671                                  		 ;set NMI state to user specified 
 10672 000032E6 58                      		pop	ax 		;get user NMI
 10673 000032E7 2480                    		and	al,NMI
 10674 000032E9 0C0F                    		or	al,CMOS_SHUT_DOWN
 10675 000032EB E670                    		out	CMOS_PORT,al
 10676 000032ED 90                      		nop
 10677 000032EE E471                    		in	al,CMOS_DATA
 10678                                  
 10679 000032F0 58                      		POP	AX		; RESTORE WORK REGISTERS	 
 10680 000032F1 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 10681 000032F2 E8E3FF                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 10682 000032F5 C3                      		RETN
 10683                                  
 10684                                  ;-----------------------------------------------------------------------------
 10685                                  ; 03/06/2018 - Retro DOS v3.0 
 10686                                  	
 10687                                  		; 07/04/2018 - Retro DOS v2.0
 10688                                  
 10689                                  ; *** SYSINIT1.ASM ***
 10690                                  ; ----------------------------------------------------------------------------
 10691                                  ; START OF MSDOS 3.3 SYSINIT CODE - SYSINIT1.ASM - 24/07/1987
 10692                                  ; ----------------------------------------------------------------------------
 10693                                  ; 02/06/2018 - Retro DOS v3.0	
 10694                                  ; 25/03/2018 - Retro DOS v2.0
 10695                                  
 10696                                  _SYSINIT: 	; 05/07/2018
 10697                                  		;JMP	GOINIT
 10698                                  
 10699                                  ; ..SYSINIT DATA .............................................................
 10700                                  
 10701                                  GOINIT:
 10702                                  		; 03/07/2018
 10703                                  Move_Myself:
 10704                                  		; 03/05/2018
 10705                                  		; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
 10706                                  		; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
 10707                                  
 10708                                  		SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
 10709                                  
 10710                                  		; 28/03/2018
 10711                                          	;CLD
 10712 000032F6 BE[2033]                        	MOV     SI,SYSINIT_START   ; MSSTACK (05/07/2018)
 10713 000032F9 31FF                            	XOR     DI,DI
 10714                                  		; 19/03/2018
 10715                                  	       	;mov	CX,[SYSINIT_START+MEMORY_SIZE]
 10716                                  		; 05/07/2018
 10717 000032FB 8B0E[9E35]              	       	mov	CX,[SYSINIT+MEMORY_SIZE]
 10718                                  
 10719 000032FF B8FE17                  		MOV	AX,SYSINITSIZE + 15 ; 03/05/2018
 10720 00003302 D1E8                    		SHR     AX,1                    ; Divide by 16 for paras
 10721 00003304 D1E8                    		SHR     AX,1
 10722 00003306 D1E8                    		SHR     AX,1
 10723 00003308 D1E8                    		SHR     AX,1
 10724 0000330A 29C1                    		SUB     CX,AX
 10725 0000330C 8EC1                    		MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
 10726 0000330E B9F017                  		MOV     CX,SYSINITSIZE + 1
 10727 00003311 D1E9                    		SHR     CX,1                    ; Divide by 2 to get words
 10728 00003313 F3A5                    		REP     MOVSW                   ; RELOCATE SYSINIT
 10729                                  
 10730 00003315 06                      		PUSH    ES
 10731                                  		;XOR	AX,AX ; 0
 10732                                  		;PUSH	AX
 10733                                  
 10734                                  		; 03/07/2018
 10735                                  		;PUSH	CX ; 0
 10736                                  		; 07/07/2019
 10737                                  		; 29/06/2019 - Retro DOS v3.1
 10738 00003316 B86002                  		mov	ax,0260h ; ((**)) ; 'sysinit:' offset in SYSINIT2.ASM
 10739                                  		;mov	ax,07F0h ; 01/07/2019
 10740 00003319 50                      		push	ax
 10741                                  
 10742 0000331A CB                      		RETF	; far jump to final location of SYSINIT code
 10743 0000331B 90<rep 5h>              align 16
 10744                                  
 10745                                  ; ----------------------------------------------------------------------------
 10746                                  ; MSDOS 3.3 -IBMBIO.COM- SYSINIT CODE -will be relocated-
 10747                                  ; ----------------------------------------------------------------------------
 10748                                  ; 11/06/2018 - Retro DOS v3.0 
 10749                                  
 10750                                  SYSINIT_START equ $
 10751                                  
 10752                                  ; 07/07/2019
 10753                                  ; 29/06/2019 - Retro DOS v3.1
 10754                                  ; (NOTE: Following address is sysinit code start address after msstack code
 10755                                  ;  in 'sysinit2.asm', it is 0252h for current SYSINIT, 29/06/2019)	
 10756                                  SYSINIT equ SYSINIT_START + 0260h ; ((**))
 10757                                  ;SYSINIT equ SYSINIT_START + 07F0h ; ((**)) ; 01/07/2019
 10758                                  
 10759                                  sysinit_code_start:
 10760                                  		; 22/11/2022
 10761                                  		; 09/07/2019 ('sysinit2.asm' last modification)
 10762 00003320 <bin 17EFh>             		incbin	'SYSINIT2.BIN' ; Retro DOS 3.1 - MSDOS 3.3 'SYSINIT'
 10763                                  sysinit_code_end:
 10764 00004B0F 90                      		db 90h
 10765                                  
 10766                                  align 16 ; Paragraph alignment is necessary here for MSDOS kernel relocation
 10767                                  
 10768                                  ; ----------------------------------------------------------------------------
 10769                                  ; START OF MSDOS 3.3 -IBMDOS.COM- KERNEL CODE (MSDOS.SYS) -will be relocated-
 10770                                  ; ----------------------------------------------------------------------------
 10771                                  ; 11/06/2018 - Retro DOS v3.0 
 10772                                  
 10773                                  MSDOS_BIN_OFFSET:  ; this offset must be paragraph aligned
 10774                                  		; 10/07/2024 (BugFix)
 10775                                  		; 22/01/2024 (BugFix)
 10776                                  		; 16/01/2024 (BugFix)
 10777                                  		; 22/11/2022 (BugFix)
 10778                                  		; 24/07/2019 ('msdos3.asm' last modification)
 10779                                  		; 29/06/2019 - Retro DOS 3.1 (msdos3.asm)
 10780 00004B10 <bin 76BFh>             		incbin	'MSDOS3.BIN'
 10781                                  msdos_bin_size	equ $ - MSDOS_BIN_OFFSET
 10782                                  
 10783                                  		;db 90h
 10784 0000C1CF 90                      align 2
 10785                                  END_OF_KERNEL equ $
