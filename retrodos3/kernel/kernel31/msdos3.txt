     1                                  ; ****************************************************************************
     2                                  ; MSDOS3.BIN (MSDOS 3.3 Kernel) - RETRO DOS v3.1 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 22/11/2022 (BugFix) - (Previous: 26/07/2019)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2019 (Retro DOS 3.0), 29/06/2019 (Retro DOS 3.1)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.14  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm msdos3.asm -l msdos3.txt -o MSDOS3.BIN)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    15                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    16                                  ; ****************************************************************************
    17                                  ; main file: 'retrodos3.s'
    18                                  ; incbin 'MSDOS3.BIN' ; (DOSGROUP CODE SEGMENT)
    19                                  ; ----------------------------------------------------------------------------
    20                                  ; 07/07/2018 - Erdogan Tan
    21                                  ; (Note: I have not got MSDOS 3.3 kernel source files; so, I need to continue
    22                                  ; by using disassembled MSDOS.SYS -v3.3- and MSDOS 6.0 kernel source files.)
    23                                  ; ----------------------------------------------------------------------------
    24                                  ; MSDOS 6.0 Kernel source files:
    25                                  ;	MSDATA.ASM, 
    26                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    27                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC)
    28                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    29                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    30                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    31                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    32                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    33                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    34                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    35                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    36                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    37                                  ;
    38                                  ; MSDOS 2.0 Kernel source files:
    39                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    40                                  ;	MSCODE.ASM
    41                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    42                                  
    43                                  ; ----------------------------------------
    44                                  ; 20/05/2019 - MSDOS3.S - Retro DOS v3.0
    45                                  ; 29/06/2019 - MSDOS3.ASM - Retro DOS v3.1
    46                                  ; ----------------------------------------
    47                                  
    48                                  ;============================================================================
    49                                  ; DOSLINK
    50                                  ;============================================================================
    51                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    52                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    53                                  ;stdio time xenix xenix2
    54                                  
    55                                  ;============================================================================
    56                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    57                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    58                                  ;============================================================================
    59                                  ;
    60                                  ; ###########################################################################
    61                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    62                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    63                                  ; #			 Licensed to: Freeware version			    #
    64                                  ; ###########################################################################
    65                                  ;
    66                                  ; Input	MD5   :	EF2ADCA1CB3882118FD247DD4C672C81
    67                                  
    68                                  ; ---------------------------------------------------------------------------
    69                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS33.BIN
    70                                  ; Format      :	Binary file
    71                                  ; Base Address:	0000h Range: 0000h - 75CFh Loaded length: 75CFh
    72                                  ;============================================================================
    73                                  ; MSDOS33.BIN = IBMDOS.COM, 17/03/1987, 30159 bytes (IBM PC DOS 3.30 kernel)
    74                                  
    75                                  ;============================================================================
    76                                  ; MSDOS.ASM
    77                                  ;============================================================================
    78                                  
    79                                  ;TITLE   Standard MSDOS
    80                                  ;NAME    MSDOS_2
    81                                  
    82                                  ; Number of disk I/O buffers
    83                                  
    84                                  ;	INCLUDE STDSW.ASM
    85                                  ;       INCLUDE MSHEAD.ASM
    86                                  ;       INCLUDE MSDATA.ASM
    87                                  
    88                                  ;	END
    89                                  
    90                                  ;============================================================================
    91                                  ; STDSW.ASM
    92                                  ;============================================================================
    93                                  
    94                                  TRUE    EQU     0FFFFH
    95                                  FALSE   EQU     ~TRUE ; NOT TRUE
    96                                  
    97                                  ; Use the switches below to produce the standard Microsoft version or the IBM
    98                                  ; version of the operating system
    99                                  ;MSVER   EQU     false
   100                                  ;IBM     EQU     true
   101                                  ;WANG    EQU     FALSE
   102                                  ;ALTVECT EQU     FALSE
   103                                  
   104                                  ; Set this switch to cause DOS to move itself to the end of memory
   105                                  ;HIGHMEM EQU     FALSE
   106                                  
   107                                  ;	IF      IBM
   108                                  ESCCH   EQU     0			; character to begin escape seq.
   109                                  CANCEL  EQU     27			;Cancel with escape
   110                                  TOGLINS EQU     TRUE			;One key toggles insert mode
   111                                  TOGLPRN EQU     TRUE			;One key toggles printer echo
   112                                  ZEROEXT EQU     TRUE
   113                                  ;       ELSE
   114                                  ;       IF      WANG			;Are we assembling for WANG?
   115                                  ;ESCCH   EQU     1FH			;Yes. Use 1FH for escape character
   116                                  ;       ELSE
   117                                  ;ESCCH   EQU     1BH
   118                                  ;       ENDIF
   119                                  ;CANCEL  EQU     "X"-"@"		;Cancel with Ctrl-X
   120                                  ;TOGLINS EQU     WANG			;Separate keys for insert mode on
   121                                  					;and off if not WANG
   122                                  ;TOGLPRN EQU     FALSE			;Separate keys for printer echo on
   123                                  					;and off
   124                                  ;ZEROEXT EQU     TRUE
   125                                  ;        ENDIF
   126                                  
   127                                  ;============================================================================
   128                                  ; MSHEAD.ASM
   129                                  ;============================================================================
   130                                  
   131                                  ;--------------------------------------------------------------
   132                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   133                                  ;--------------------------------------------------------------
   134                                  
   135                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   136                                  ;        by Microsoft MSDOS development group:
   137                                  ;           Tim Paterson (Ret.)
   138                                  ;           Aaron Reynolds
   139                                  ;           Nancy Panners (Parenting)
   140                                  ;           Mark Zbikowski
   141                                  ;           Chris Peters (BIOS) (ret.)
   142                                  
   143                                  ; ****************** Revision History *************************
   144                                  ;          >> EVERY change must noted below!! <<
   145                                  ;
   146                                  ; 0.34 12/29/80 General release, updating all past customers
   147                                  ; 0.42 02/25/81 32-byte directory entries added
   148                                  ; 0.56 03/23/81 Variable record and sector sizes
   149                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   150                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   151                                  ; 0.75 04/17/81 Improve and correct buffer handling
   152                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   153                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   154                                  ; 1.00 04/28/81 Renumber for general release
   155                                  ; 1.01 05/12/81 Fix bug in `STORE'
   156                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   157                                  ;               RENAME fix, general cleanup
   158                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   159                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   160                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   161                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   162                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   163                                  ;               of smaller improvements
   164                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   165                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   166                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   167                                  ;               zero extent field in IBM version (back to 1.01!)
   168                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   169                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   170                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   171                                  ;               is searched first when possible to minimize I/O
   172                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   173                                  ;               full sector write when file is growing
   174                                  ;      03/09/82 Multiple I/O buffers
   175                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   176                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   177                                  ;               must invalidate all buffers (disk and directory).
   178                                  ; 1.27 03/31/82 Installable device drivers
   179                                  ;                 Function call 47 - Get pointer to device table list
   180                                  ;                 Function call 48 - Assign CON AUX LIST
   181                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   182                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   183                                  ;               call entries.  Most CS relative references changed to SS
   184                                  ;               relative with an eye toward putting a portion of the DOS in
   185                                  ;               ROM.  DOS source also broken into header, data and code pieces
   186                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   187                                  ;               return the current values.
   188                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   189                                  ;               call to return flag location (call 29)
   190                                  ;      04/15/82 Volume ID attribute added
   191                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   192                                  ;               avoid a CS relative reference.
   193                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   194                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   195                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   196                                  ;               call 49.
   197                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   198                                  ;               address of DPB
   199                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   200                                  ;               writting to console device via file I/O.  Added a console
   201                                  ;               output attribute to devices.
   202                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   203                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   204                                  ;               as devices....  pipes, redirection now possible
   205                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   206                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   207                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   208                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   209                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   210                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   211                                  ;               out back about 1.27 or so (oops).  ARR
   212                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   213                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   214                                  ;               RMDIR Xenix calls
   215                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   216                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   217                                  ;               Frees up lots of memory.
   218                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   219                                  ;               system buffers
   220                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   221                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   222                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   223                                  ;               changed to set file handle environment.
   224                                  ; 2.00 08/01/82 Number for IBM release
   225                                  ;      01/19/83 No environ bug in EXEC
   226                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   227                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   228                                  ;      01/27/83 Growcnt fixed for 32-bits
   229                                  ;      01/27/83 Find-first problem after create
   230                                  ; 2.01 02/17/83 International DOS
   231                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   232                                  ;               an IBM PC
   233                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   234                                  ; (MSHEAD.ASM, MSDOS6.0, 1991) - mshead.asm 1.1 85/04/10 -
   235                                  ; 2.10 03/09/83 Start of NETWORK support
   236                                  ;		New Buffer structure
   237                                  ;		New Sytem file table structure
   238                                  ;		FCB moved to internal representation
   239                                  ;		DOS re-organized
   240                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   241                                  ;		device interface.
   242                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   243                                  ;               an IBM PC
   244                                  ; 2.50 09/12/83 More network stuff
   245                                  ;
   246                                  ; *************************************************************
   247                                  
   248                                  ; ----------------------------------------------------------------------------
   249                                  ; EQUATES
   250                                  
   251                                  ; Interrupt Entry Points:
   252                                  
   253                                  ; INTBASE:      ABORT
   254                                  ; INTBASE+4:    COMMAND
   255                                  ; INTBASE+8:    BASE EXIT ADDRESS
   256                                  ; INTBASE+C:    CONTROL-C ABORT
   257                                  ; INTBASE+10H:  FATAL ERROR ABORT
   258                                  ; INTBASE+14H:  BIOS DISK READ
   259                                  ; INTBASE+18H:  BIOS DISK WRITE
   260                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   261                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   262                                  ; INTBASE+40H:  Long jump to CALL entry point
   263                                  
   264                                  ENTRYPOINTSEG   EQU     0CH
   265                                  MAXDIF          EQU     0FFFH
   266                                  SAVEXIT         EQU     10
   267                                  ;08/07/2018 - Retro DOS v3.0
   268                                  ;WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   269                                  
   270                                         ; INCLUDE DOSSYM.ASM
   271                                         ; INCLUDE DEVSYM.ASM
   272                                  
   273                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   274                                  ; PAGE
   275                                  ; There are three kinds of context resets that can occur during normal DOS
   276                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   277                                  ; be handles in a clean fashion that allows nested executions along with the
   278                                  ; ability to trap one's own errors.
   279                                  ;
   280                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   281                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   282                                  ;           follows:
   283                                  ;
   284                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   285                                  ;           Save it in static memory.
   286                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   287                                  ;
   288                                  ;           The interrupt service routine must preserve all registers and
   289                                  ;           return carry set iff the operation is to be aborted (via abort
   290                                  ;           system call), otherwise, carry is reset and the operation is
   291                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   292                                  ;           RESULTS.
   293                                  ;
   294                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   295                                  ;           restore INT int_ctrl_c from the saved vector.
   296                                  ;
   297                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   298                                  ;           also preserve registers and return one of three values in AL: 0 and
   299                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   300                                  ;           himself is not to issue the abort, rather, the dos will do it for
   301                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   302                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   303                                  ;
   304                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   305                                  ;           abort call.  This is reserved for knowledgeable system programs.
   306                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   307                                  
   308                                  ;SUBTTL SEGMENT DECLARATIONS
   309                                  
   310                                  ; The following are all of the segments used.  They are declared in the order
   311                                  ; that they should be placed in the executable
   312                                  
   313                                  ;
   314                                  ; segment ordering for MSDOS
   315                                  ;
   316                                  
   317                                  ;START           SEGMENT BYTE PUBLIC 'START'
   318                                  ;START           ENDS
   319                                  
   320                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   321                                  ;CONSTANTS       ENDS
   322                                  
   323                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   324                                  ;DATA            ENDS
   325                                  
   326                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   327                                  ;CODE            ENDS
   328                                  
   329                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   330                                  ;LAST            ENDS
   331                                  
   332                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   333                                  
   334                                  ; The following segment is defined such that the data/const classes appear
   335                                  ; before the code class for ROMification
   336                                  
   337                                  ;START		SEGMENT BYTE PUBLIC 'START'
   338                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   339                                  ;		JMP     DOSINIT
   340                                  ;START		ENDS
   341                                  
   342                                  ;============================================================================
   343                                  ; DOSSYM.ASM
   344                                  ;============================================================================
   345                                  
   346                                  ;<Control character definitions>
   347                                  
   348                                  c_DEL       EQU     7Fh         ;    ASCII rubout or delete previous char
   349                                  c_BS        EQU     08h         ; ^H ASCII backspace
   350                                  c_CR        EQU     0Dh         ; ^M ASCII carriage return
   351                                  c_LF        EQU     0Ah         ; ^J ASCII linefeed
   352                                  c_ETB       EQU     17h         ; ^W ASCII end of transmission
   353                                  c_NAK       EQU     15h         ; ^U ASCII negative acknowledge
   354                                  c_ETX       EQU     03h         ; ^C ASCII end of text
   355                                  c_HT        EQU     09h         ; ^I ASCII tab
   356                                  
   357                                  ;============================================================================
   358                                  ; BPB.INC, MSDOS 3.3, 1987
   359                                  ;============================================================================
   360                                  ; 09/07/2018 - Retro DOS v3.0
   361                                  
   362                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   363                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   364                                  ;									   ;
   365                                  
   366                                  ; BIOS PARAMETER BLOCK DEFINITION
   367                                  ; THIS STRUCTURE IS USED TO BUILD A FULL DPB
   368                                  
   369                                  struc BPBLOCK
   370 00000000 ????                    .SECSZ: resw 1		; Size in bytes of physical sector
   371 00000002 ??                      .CLUS:  resb 1		; Sectors/Alloc unit
   372 00000003 ????                    .RES:   resw 1		; Number of reserved sectors
   373 00000005 ??                      .FTCNT: resb 1		; Number of FATs
   374 00000006 ????                    .DRCNT: resw 1		; Number of directory entries
   375 00000008 ????                    .SCCNT: resw 1		; Total number of sectors
   376 0000000A ??                      .MEDIA: resb 1		; Media descriptor byte
   377 0000000B ????                    .FTSEC:	resw 1		; Number of sectors taken up by one FAT
   378                                  .size:
   379                                  endstruc
   380                                  
   381                                  ; 09/07/2018 - Retro DOS v3.0
   382                                  ; (BPB.INC, MSDOS 6.0, 1991)
   383                                  
   384                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   385                                  ;
   386                                  ;	The BPB contains information about the disk structure.  It dates
   387                                  ;	back to the earliest FAT systems and so FAT information is
   388                                  ;	intermingled with physical driver information.
   389                                  ;
   390                                  ;	A boot sector contains a BPB for its device; for other disks
   391                                  ;	the driver creates a BPB.  DOS keeps copies of some of this
   392                                  ;	information in the DPB.
   393                                  ;
   394                                  ;	The BDS structure contains a BPB within it. 
   395                                  
   396                                  struc A_BPB
   397 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   398 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   399 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   400 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   401 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   402 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   403 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   404 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   405 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   406 0000000F ????                    .BPB_HEADS:		resw	1
   407 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   408 00000013 ????                    			resw	1
   409 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   410 00000017 ????                    			resw	1
   411 00000019 ????????????            			resb	6	; NOTE:  many times these
   412                                  ;					; 	 6 bytes are omitted
   413                                  ;					;	 when BPB manipulations
   414                                  ;					;	 are performed!
   415                                  .size:
   416                                  endstruc
   417                                  
   418                                  ;                                                                          ;
   419                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   420                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   421                                  
   422                                  ;============================================================================
   423                                  ; BUFFER.INC, MSDOS 3.3, 1987
   424                                  ;============================================================================
   425                                  ; 09/07/2018 - Retro DOS v3.0
   426                                  
   427                                  ; <Disk I/O Buffer Header>
   428                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   429                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   430                                  ;                                                                          ;
   431                                  
   432                                  ; Field definition for I/O buffer information
   433                                  
   434                                  struc BUFFINFO
   435 00000000 ????????                .buf_link:	resd 1		; Pointer to next buffer in list
   436 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   437                                  				; SFT table index (bit 7 = 1)
   438                                  				; = FFH if buffer free
   439 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   440                                  				;	= 0 if Local device buffer
   441                                  				; Bit 6 = 1 if buffer dirty
   442                                  				; Bit 5 = Reserved
   443                                  				; Bit 4 = Search bit (bit 7 = 1)
   444                                  				; Bit 3 = 1 if buffer is DATA
   445                                  				; Bit 2 = 1 if buffer is DIR
   446                                  				; Bit 1 = 1 if buffer is FAT
   447                                  				; Bit 0 = Reserved
   448 00000006 ????                    .buf_sector:	resw 1		; Sector number of buffer (bit 7 = 0)
   449                                  ; The next two items are often refed as a word (bit 7 = 0)
   450 00000008 ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   451 00000009 ??                      .buf_wrtcntinc:	resb 1		; "   "     "   , # sectors between each write
   452 0000000A ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   453 0000000E ????                    .buf_fill:	resw 1		; How full buffer is (bit 7 = 1)
   454                                  .size:
   455                                  endstruc
   456                                  
   457                                  %define buf_offset dword [buf_sector]
   458                                  				;For bit 7 = 1, this is the byte
   459                                  				;offset of the start of the buffer in
   460                                  				;the file pointed to by buf_ID.  Thus
   461                                  				;the buffer starts at location
   462                                  				;buf_offset in the file and contains
   463                                  				;buf_fill bytes.
   464                                  
   465                                  BUFINSIZ        EQU     BUFFINFO.size
   466                                  
   467                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   468                                  
   469                                  ;Flag byte masks
   470                                  buf_isnet	EQU	10000000B
   471                                  buf_dirty	EQU	01000000B
   472                                  ;***
   473                                  buf_visit	EQU	00100000B
   474                                  ;***
   475                                  buf_snbuf	EQU	00010000B
   476                                  
   477                                  buf_isDATA	EQU	00001000B
   478                                  buf_isDIR	EQU	00000100B
   479                                  buf_isFAT	EQU	00000010B
   480                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   481                                  
   482                                  buf_NetID	EQU	BUFINSIZ
   483                                  
   484                                  ;                                                                          ;
   485                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   486                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   487                                  
   488                                  ; <User stack inside of system call>
   489                                  ; Location of user registers relative user stack pointer
   490                                  
   491                                  struc	user_env   ; user_environ
   492 00000000 ????                    .user_AX: resw 1
   493 00000002 ????                    .user_BX: resw 1
   494 00000004 ????                    .user_CX: resw 1
   495 00000006 ????                    .user_DX: resw 1
   496 00000008 ????                    .user_SI: resw 1
   497 0000000A ????                    .user_DI: resw 1
   498 0000000C ????                    .user_BP: resw 1
   499 0000000E ????                    .user_DS: resw 1
   500 00000010 ????                    .user_ES: resw 1
   501 00000012 ????                    .user_IP: resw 1
   502 00000014 ????                    .user_CS: resw 1
   503 00000016 ????                    .user_F:  resw 1
   504                                  .size:
   505                                  endstruc
   506                                  
   507                                  ; 09/07/2018 - Retro DOS v3.0
   508                                  ; (VECTOR.INC, MSDOS 3.3, 1987)
   509                                  ; ----------------------------------------------------------------------------
   510                                  
   511                                  ; <interrupt definitions>
   512                                  
   513                                  INTTAB          EQU     20H
   514                                  INTBASE         EQU     4 * INTTAB
   515                                  ENTRYPOINT      EQU     INTBASE+40H
   516                                  
   517                                  ;	IF      ALTVECT
   518                                  ;ALTTAB  EQU     0F0H
   519                                  ;ALTBASE EQU     4 * ALTTAB
   520                                  ;	ENDIF
   521                                  
   522                                  ;
   523                                  ; interrupt assignments
   524                                  ;
   525                                  ;	IF	NOT ALTVECT
   526                                  int_abort	    EQU     INTTAB	; abort process
   527                                  int_command	    EQU     int_abort+1 ; call MSDOS
   528                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   529                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   530                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   531                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   532                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   533                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   534                                  					; resident
   535                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   536                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   537                                  ;									   ;
   538                                  int_spooler	    EQU     int_abort+8 ; spooler call
   539                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   540                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   541                                  ;									   ;
   542                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   543                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   544                                  ;	ELSE
   545                                  ;int_abort	    EQU     INTTAB	; abort process
   546                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   547                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   548                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   549                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   550                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   551                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   552                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   553                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   554                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   555                                  ;									   ;
   556                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   557                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   558                                  ;									   ;
   559                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   560                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   561                                  ;	ENDIF
   562                                  
   563                                  addr_int_abort		EQU    4 * int_abort
   564                                  addr_int_command	EQU    4 * int_command
   565                                  addr_int_terminate	EQU    4 * int_terminate
   566                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   567                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   568                                  addr_int_disk_read	EQU    4 * int_disk_read
   569                                  addr_int_disk_write	EQU    4 * int_disk_write
   570                                  addr_int_keep_process	EQU    4 * int_keep_process
   571                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   572                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   573                                  ;									   ;
   574                                  addr_int_spooler	EQU    4 * int_spooler
   575                                  addr_int_fastcon	EQU    4 * int_fastcon
   576                                  addr_int_IBM		EQU    4 * int_IBM
   577                                  ;									   ;
   578                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   579                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   580                                  
   581                                  
   582                                  ; <Disk map>
   583                                  ;  MSDOS partitions the disk into 4 sections:
   584                                  ;
   585                                  ;  phys sector 0:   +-------------------+
   586                                  ;       |           | boot/reserved     |
   587                                  ;       |           +-------------------+
   588                                  ;       |           |  File allocation  |
   589                                  ;       v           |      table(s)     |
   590                                  ;                   |  (multiple copies |
   591                                  ;                   |     are kept)     |
   592                                  ;                   +-------------------+
   593                                  ;                   |     Directory     |
   594                                  ;                   +-------------------+
   595                                  ;                   |     File space    |
   596                                  ;                   +-------------------+
   597                                  ;                   |   Unaddressable   |
   598                                  ;                   |  (to end of disk) |
   599                                  ;                   +-------------------+
   600                                  ;
   601                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   602                                  ; adjusted to maximize the file space addressable.
   603                                  
   604                                  ; BREAK <Directory entry>
   605                                  
   606                                  ;
   607                                  ;       +---------------------------+
   608                                  ;       |  (12 BYTE) filename/ext   |       0       0
   609                                  ;       +---------------------------+
   610                                  ;       |     (BYTE) attributes     |       11      B
   611                                  ;       +---------------------------+
   612                                  ;       |    (10 BYTE) reserved     |       12      C
   613                                  ;       +---------------------------+
   614                                  ;       | (WORD) time of last write |       22      16
   615                                  ;       +---------------------------+
   616                                  ;       | (WORD) date of last write |       24      18
   617                                  ;       +---------------------------+
   618                                  ;       |   (WORD) First cluster    |       26      1A
   619                                  ;       +---------------------------+
   620                                  ;       |     (DWORD) file size     |       28      1C
   621                                  ;       +---------------------------+
   622                                  ;
   623                                  ;   First byte of filename  = E5 -> free directory entry
   624                                  ;                           = 00 -> end of allocated directory
   625                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   626                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   627                                  ;
   628                                  struc dir_entry
   629 00000000 <res Bh>                .dir_name:	resb 11			; file name
   630 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   631 0000000C <res Ah>                .dir_pad:	resb 10			; reserved for expansion
   632 00000016 ????                    .dir_time:	resw 1			; time of last write
   633 00000018 ????                    .dir_date:	resw 1			; date of last write
   634 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   635 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   636 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   637                                  .size:
   638                                  endstruc
   639                                  
   640                                  attr_read_only      EQU      1h
   641                                  attr_hidden         EQU      2h
   642                                  attr_system         EQU      4h
   643                                  attr_volume_id      EQU      8h
   644                                  attr_directory      EQU     10h
   645                                  attr_archive        EQU     20h
   646                                  ;09/07/2018 - Retro DOS v3.0
   647                                  ;(DIRENT.INC, MSDOS 3.3, 1987)
   648                                  attr_device	    EQU     40h	; This is a VERY special bit.
   649                                  				;   NO directory entry on a disk EVER
   650                                  				;   has this bit set. It is set non-zero
   651                                  				;   when a device is found by GETPATH
   652                                  
   653                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   654                                                                          ; OR of hard attributes for FINDENTRY
   655                                  
   656                                  attr_ignore         EQU     attr_read_only+attr_archive
   657                                                                          ; ignore this(ese) attribute(s)
   658                                                                          ; during search first/next
   659                                  
   660                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   661                                                                          ; changeable via CHMOD
   662                                  
   663                                  ; 09/08/2018 - Retro DOS v3.0
   664                                  ; (DIRENT.INC, MSDOS 6,0, 1991)
   665                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   666                                  
   667                                  ; <File allocation Table information>
   668                                  ;
   669                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on the
   670                                  ; disk.  These entries are packed, two for every three bytes.  The contents of
   671                                  ; entry number N is found by 1) multiplying N by 1.5; 2) adding the result to
   672                                  ; the base address of the Allocation Table; 3) fetching the 16-bit word at this
   673                                  ; address; 4) If N was odd (so that N*1.5 was not an integer), shift the word
   674                                  ; right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry number zero
   675                                  ; is used as an end-of-file trap in the OS and is passed to the BIOS to help
   676                                  ; determine disk format.  Entry 1 is reserved for future use.  The first
   677                                  ; available allocation unit is assigned entry number two, and even though it is
   678                                  ; the first, is called cluster 2.  Entries greater than 0FF8H are end of file
   679                                  ; marks; entries of zero are unallocated.  Otherwise, the contents of a FAT
   680                                  ; entry is the number of the next cluster in the file.
   681                                  ;
   682                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would do
   683                                  ; because these clusters show as allocated, but are not part of any allocation
   684                                  ; chain and thus will never be allocated to a file.  A particular number is
   685                                  ; selected so that disk checking programs know what to do (ie.  a cluster with
   686                                  ; entry FF7H which is not in a chain is not an error).
   687                                  
   688                                  ;DIRSTRLEN       EQU     64	; Max length in bytes of directory strings
   689                                  
   690                                  ; 19/07/2018
   691                                  ; (DPB.INC, MSDOS 3.3, 1987)
   692                                  ; 07/07/2018 - Retro DOS v3.0
   693                                  ; (DPB.INC, MSDOS 6.0, 1991)
   694                                  ; ----------------------------------------------------------------------------
   695                                  ;**	DPB - Drive Parameter Block
   696                                  ;
   697                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   698                                  ;	possibly inaccurate deductions from code study... - jgl
   699                                  ;
   700                                  ;	The DPB is DOS's main structure for describing block devices.
   701                                  ;	It contains info about the "Drive" intermingled with info about
   702                                  ;	the FAT file system which is presumably on the drive.  I don't know
   703                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   704                                  ;
   705                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   706                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   707                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   708                                  
   709                                  struc	DPB
   710 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   711 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   712 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   713 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   714 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   715 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   716 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   717 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   718 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   719 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   720                                  ; MSDOS 3.3
   721 0000000F ??                      .FAT_SIZE:	resb 1		; Number of records occupied by FAT
   722                                  ; MSDOS 6.0
   723                                  ;.FAT_SIZE:	resw 1		; Number of records occupied by FAT
   724 00000010 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   725 00000012 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   726 00000016 ??                      .MEDIA:		resb 1		; Media byte
   727 00000017 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   728                                  				; check the first time this DPB is used
   729 00000018 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   730 0000001C ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   731 0000001E ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   732                                  .size:
   733                                  endstruc
   734                                  
   735                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   736                                  
   737                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   738                                  
   739                                  ;                                                                          ;
   740                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   741                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   742                                  
   743                                  ; 12/07/2018 - Retro DOS v3.0 
   744                                  ; (DOSSYM.INC, MSDOS 6.0, 1991)
   745                                  
   746                                  ;**	Character Type Flags
   747                                  ;
   748                                  ;	These flags are used in a lookup table indexed by the character code.
   749                                  ;	They're used to quickly classify characters when parsing paths.
   750                                  ;	I think that these are only used to parse FCBs - jgl
   751                                  
   752                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   753                                  FDELIM	equ 2		; is a delimiter
   754                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   755                                  FFCB	equ 8		; is valid in an FCB
   756                                  
   757                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   758                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   759                                  ;                                                                          ;
   760                                  devid_file_clean        EQU     40h     ; true if file and not written
   761                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   762                                  
   763                                  devid_device            EQU     80h     ; true if a device
   764                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   765                                  devid_device_raw        EQU     20h     ; true if in raw mode
   766                                  devid_device_special    EQU     10h     ; true if special device
   767                                  devid_device_clock      EQU     08h     ; true if clock device
   768                                  devid_device_null       EQU     04h     ; true if null device
   769                                  devid_device_con_out    EQU     02h     ; true if console output
   770                                  devid_device_con_in     EQU     01h     ; true if consle input
   771                                  
   772                                  ;
   773                                  ; structure of devid field as returned by IOCTL is:
   774                                  ;
   775                                  ;       BIT     7   6   5   4   3   2   1   0
   776                                  ;             |---|---|---|---|---|---|---|---|
   777                                  ;             | I | E | R | S | I | I | I | I |
   778                                  ;             | S | O | A | P | S | S | S | S |
   779                                  ;             | D | F | W | E | C | N | C | C |
   780                                  ;             | E |   |   | C | L | U | O | I |
   781                                  ;             | V |   |   | L | K | L | T | N |
   782                                  ;             |---|---|---|---|---|---|---|---|
   783                                  ;       ISDEV = 1 if this channel is a device
   784                                  ;             = 0 if this channel is a disk file
   785                                  ;
   786                                  ;       If ISDEV = 1
   787                                  ;
   788                                  ;             EOF = 0 if End Of File on input
   789                                  ;             RAW = 1 if this device is in Raw mode
   790                                  ;                 = 0 if this device is cooked
   791                                  ;             ISCLK = 1 if this device is the clock device
   792                                  ;             ISNUL = 1 if this device is the null device
   793                                  ;             ISCOT = 1 if this device is the console output
   794                                  ;             ISCIN = 1 if this device is the console input
   795                                  ;
   796                                  ;       If ISDEV = 0
   797                                  ;             EOF = 0 if channel has been written
   798                                  ;             Bits 0-5  are  the  block  device  number  for
   799                                  ;                 the channel (0 = A, 1 = B, ...)
   800                                  ;
   801                                  devid_ISDEV     EQU     80h
   802                                  devid_EOF       EQU     40h
   803                                  devid_RAW       EQU     20h
   804                                  devid_SPECIAL   EQU     10H
   805                                  devid_ISCLK     EQU     08h
   806                                  devid_ISNUL     EQU     04h
   807                                  devid_ISCOT     EQU     02h
   808                                  devid_ISCIN     EQU     01h
   809                                  
   810                                  devid_block_dev EQU     1Fh             ; mask for block device number
   811                                  
   812                                  ; 08/07/2018 - Retro DOS v3.0
   813                                  ; (PDB.INC, MSDOS 6.0, 1991)
   814                                  ; ----------------------------------------------------------------------------
   815                                  ; BREAK <Process data block>
   816                                  ;
   817                                  ;**	Process data block (otherwise known as program header)
   818                                  ;
   819                                  
   820                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   821                                  ;	can be rearranged here, ever.  Reserved areas are probably safe
   822                                  ;	for use.
   823                                  
   824                                  FILPERPROC	EQU     20
   825                                  
   826                                  struc PDB	; Process_data_block
   827 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   828 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   829 00000004 ??                                      resb 1
   830 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   831 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   832 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   833 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   834 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   835 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   836 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   837 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   838 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   839 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   840 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   841 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   842 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   843 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   844 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   845 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   846 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   847 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   848                                  				;  an extended FCB
   849                                  ;endstruc 	; MSDOS 3.3
   850                                  	  	; MSDOS 6.0
   851 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   852 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   853 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   854 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   855                                  endstruc
   856                                  
   857                                  ; BREAK <EXEC and EXE file structures>
   858                                  ;
   859                                  ; EXEC arg block - load/go program
   860                                  ;
   861                                  
   862                                  ;
   863                                  ; The following get used as arguments to the EXEC system call.  They indicate
   864                                  ; whether or not the program is executed or whether or not a program header
   865                                  ; gets created.
   866                                  ;
   867                                  exec_func_no_execute    EQU 1           ; no execute bit
   868                                  exec_func_overlay       EQU 2           ; overlay bit
   869                                  
   870                                  struc EXEC0
   871 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
   872 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
   873 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
   874 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
   875                                  .size:
   876                                  endstruc
   877                                  
   878                                  struc EXEC1
   879 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
   880 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
   881 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
   882 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
   883 0000000E ????                    .SP:		resw 1		; stack pointer of program
   884 00000010 ????                    .SS:		resw 1		; stack seg register of program
   885 00000012 ????                    .IP:		resw 1		; entry point IP
   886 00000014 ????                    .CS:		resw 1		; entry point CS
   887                                  .size:
   888                                  endstruc
   889                                  
   890                                  struc EXEC3
   891 00000000 ????                    .load_addr:	resw 1		; seg address of load point
   892 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
   893                                  endstruc
   894                                  
   895                                  ; 02/08/2018 (MSDOS 6.0, EXEC.INC, 1991)
   896                                  ;**	Exit codes (in upper byte) for terminating programs
   897                                  
   898                                  EXIT_TERMINATE		EQU	0
   899                                  EXIT_ABORT		EQU	0
   900                                  EXIT_CTRL_C		EQU	1
   901                                  EXIT_HARD_ERROR 	EQU	2
   902                                  EXIT_KEEP_PROCESS	EQU	3
   903                                  
   904                                  ;
   905                                  ; EXE file header
   906                                  ;
   907                                  
   908                                  struc EXE
   909 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
   910 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
   911 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
   912 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
   913 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
   914 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
   915 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
   916 0000000E ????                    .SS:          resw 1		; stack of image
   917 00000010 ????                    .SP:          resw 1		; SP of image
   918 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
   919 00000014 ????                    .IP:          resw 1		; IP of entry
   920 00000016 ????                    .CS:          resw 1		; CS of entry
   921 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
   922 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
   923 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
   924                                  .size:
   925                                  endstruc
   926                                  
   927                                  exe_valid_signature     EQU 5A4Dh
   928                                  exe_valid_old_signature EQU 4D5Ah
   929                                  
   930                                  struc symbol_entry
   931 00000000 ????????                .value:	resd 1
   932 00000004 ????                    .type:	resw 1
   933 00000006 ??                      .len:	resb 1
   934 00000007 <res FFh>               .name:	resb 255
   935                                  endstruc
   936                                  
   937                                  ; 07/07/2018 - Retro DOS v3.0
   938                                  ; MSDOS 6.0 (SF.INC, 1991)
   939                                  ; ----------------------------------------------------------------------------
   940                                  ;**	SF.INC - System File Table
   941                                  ;
   942                                  ;   AN000   version 4.00   Jan. 1988
   943                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   944                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   945                                  
   946                                  ;**	System File Table SuperStructure
   947                                  ;
   948                                  ;	The system file table entries are allocated in contiguous groups.
   949                                  ;	There may be more than one such groups; the SF "superstructure"
   950                                  ;	tracks the groups.
   951                                  
   952                                  struc	SFT
   953 00000000 ????????                .SFLink:	resd 1
   954 00000004 ????                    .SFCount:	resw 1		; number of entries
   955 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   956                                  .size:
   957                                  endstruc
   958                                  
   959                                  ; 07/07/2018 - Retro DOS v3.0
   960                                  ; MSDOS 6.0 (SF.INC, 1991)
   961                                  ; ----------------------------------------------------------------------------
   962                                  ;**	System file table entry
   963                                  ;
   964                                  ;	These are the structures which are at SFTABLE in the SF structure.
   965                                  
   966                                  struc SF_ENTRY
   967 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   968                                  				;   if FCB then ref count
   969 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   970 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   971 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   972                                  				; Bit 15 = 1 if remote file
   973                                  				;	 = 0 if local file or device
   974                                  				; Bit 14 = 1 if date/time is not to be
   975                                  				;   set from clock at CLOSE.  Set by
   976                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   977                                  				;   other reseters of the dirty bit
   978                                  				;   (WRITE)
   979                                  				; Bit 13 = Pipe bit (reserved)
   980                                  				;
   981                                  				; Bits 0-7 (old FCB_devid bits)
   982                                  				; If remote file or local file, bit
   983                                  				; 6=0 if dirty Device ID number, bits
   984                                  				; 0-5 if local file.
   985                                  				; bit 7=0 for local file, bit 7
   986                                  				;      =1 for local I/O device
   987                                  				; If local I/O device, bit 6=0 if EOF (input)
   988                                  				;		Bit 5=1 if Raw mode
   989                                  				;		Bit 0=1 if console input device
   990                                  				;		Bit 1=1 if console output device
   991                                  				;		Bit 2=1 if null device
   992                                  				;		Bit 3=1 if clock device
   993 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
   994                                  				; to device header if local device,
   995                                  				; points to net device header if
   996                                  				; remote
   997 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
   998 0000000D ????                    .sf_time:	resw	1	; Time associated with file
   999 0000000F ????                    .sf_date:	resw	1	; Date associated with file
  1000 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
  1001 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
  1002                                  
  1003                                  ; Starting here, the next 7 bytes may be used by the file system to store an
  1004                                  ; ID
  1005                                  
  1006                                  ; 09/07/2018 - Retro DOS v3.0
  1007                                  
  1008                                  ; MSDOS 3.3 SF.INC, 1987
  1009 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
  1010 0000001B ????                    .sf_lstclus	resw	1	; Last cluster accessed
  1011 0000001D ????                    .sf_dirsec:	resw	1	; Sector number of directory sector
  1012                                  				; for this file
  1013 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
  1014                                  
  1015                                  ; MSDOS 6.0, SF.INC, 1991
  1016                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
  1017                                  ;.sf_dirsec:	resd	1	; Sector number of directory sector
  1018                                  ;				; for this file
  1019                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
  1020                                  
  1021                                  ; End of 7 bytes of file-system specific info.
  1022                                  
  1023 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
  1024                                  				; directory entry.  This is used by
  1025                                  				; close to detect file deleted and
  1026                                  				; disk changed errors.
  1027                                  ; SHARING INFO
  1028 0000002B ????????                .sf_chain:	resd	1	; link to next SF
  1029 0000002F ????                    .sf_UID:	resw	1
  1030 00000031 ????                    .sf_PID:	resw	1
  1031 00000033 ????                    .sf_MFT:	resw	1
  1032                                  
  1033                                  ; MSDOS 6.0, SF.INC, 1991
  1034                                  ;.sf_lstclus:	resw	1	;AN009; Last cluster accessed
  1035                                  ;.sf_IFS_HDR:	resd	1
  1036                                  
  1037                                  .size:
  1038                                  endstruc
  1039                                  
  1040                                  ; 20/07/2018
  1041                                  ; MSDOS 3.3, SF.INC, 1987
  1042                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
  1043                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
  1044                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
  1045                                  ; MSDOS 6.0, SDF.INC, 1991
  1046                                  %define sf_fsda	     SF_ENTRRY.sf_cluspos ; byte ;DOS 4.00
  1047                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
  1048                                  
  1049                                  ; 19/07/2018
  1050                                  
  1051                                  ; MSDOS 3.3, SF.INC, 1987
  1052                                  
  1053                                  sf_default_number  EQU	5
  1054                                  
  1055                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
  1056                                  ; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
  1057                                  ; by placing a -1 in the ref_count field.
  1058                                  
  1059                                  sf_busy EQU -1
  1060                                  
  1061                                  ; mode mask for FCB detection
  1062                                  sf_isFCB		EQU	1000000000000000B
  1063                                  
  1064                                  ; Flag word masks
  1065                                  sf_isnet		EQU	1000000000000000B
  1066                                  sf_close_nodate 	EQU	0100000000000000B
  1067                                  sf_pipe 		EQU	0010000000000000B
  1068                                  sf_no_inherit		EQU	0001000000000000B
  1069                                  sf_net_spool		EQU	0000100000000000B
  1070                                  
  1071                                  ; 19/04/2018
  1072                                  sf_entry_size equ SF_ENTRY.size ; 53
  1073                                  
  1074                                  ;                                                                          ;
  1075                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1076                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1077                                  
  1078                                  ; 09/07/2018 - Retro DOS v3.0
  1079                                  ; (ARENA.INC, MSDOS 3.3, 1987)
  1080                                  ; ----------------------------------------------------------------------------
  1081                                  ;BREAK <Memory arena structure>
  1082                                  
  1083                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1084                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1085                                  ;                                                                          ;
  1086                                  ;
  1087                                  ; arena item
  1088                                  ;
  1089                                  
  1090                                  struc ARENA
  1091 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1092 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1093 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1094                                  endstruc
  1095                                  
  1096                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1097                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1098                                  ; Change them and change ALLOC.ASM.
  1099                                  
  1100                                  arena_owner_system  EQU 0               ; free block indication
  1101                                  
  1102                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1103                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1104                                  
  1105                                  ; 04/08/2018 - Retro DOS v3.0
  1106                                  ; (ARENA.INC, MSDOS 6.0, 1991)
  1107                                  
  1108                                  FIRST_FIT	EQU	00000000B
  1109                                  BEST_FIT	EQU	00000001B
  1110                                  LAST_FIT	EQU	00000010B
  1111                                  
  1112                                  ; MSDOS 6.0
  1113                                  ;LOW_FIRST	EQU	00000000B	; M001
  1114                                  ;HIGH_FIRST	EQU	10000000B	; M001
  1115                                  ;HIGH_ONLY	EQU	01000000B	; M001
  1116                                  
  1117                                  ;LINKSTATE	EQU	00000001B	; M002
  1118                                  
  1119                                  ;HF_MASK		EQU	~HIGH_FIRST	; M001
  1120                                  ;HO_MASK		EQU	~HIGH_ONLY	; M001
  1121                                  
  1122                                  ;STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1123                                  						; M026: used to mask of bits
  1124                                  						; M026: 6 & 7 of AllocMethod
  1125                                  
  1126                                  ; 07/07/2018 - Retro DOS v3.0
  1127                                  ; (MI.INC, MSDOS 6.0, 1991)
  1128                                  ; ----------------------------------------------------------------------------
  1129                                  ;BREAK <Machine instruction, flag definitions and character types>
  1130                                  
  1131                                  mi_INT		EQU	0CDh
  1132                                  mi_Long_JMP	EQU	0EAh
  1133                                  mi_Long_CALL	EQU	09Ah
  1134                                  mi_Long_RET	EQU	0CBh
  1135                                  mi_Near_RET	EQU	0C3h
  1136                                  
  1137                                  ;			xxxxoditszxaxpxc
  1138                                  f_Overflow	EQU	0000100000000000B
  1139                                  f_Direction	EQU	0000010000000000B
  1140                                  f_Interrupt	EQU	0000001000000000B
  1141                                  f_Trace 	EQU	0000000100000000B
  1142                                  f_Sign		EQU	0000000010000000B
  1143                                  f_Zero		EQU	0000000001000000B
  1144                                  f_Aux		EQU	0000000000010000B
  1145                                  f_Parity	EQU	0000000000000100B
  1146                                  f_Carry 	EQU	0000000000000001B
  1147                                  
  1148                                  ; <Standard I/O assignments>
  1149                                  
  1150                                  stdin       EQU     0
  1151                                  stdout      EQU     1
  1152                                  stderr      EQU     2
  1153                                  stdaux      EQU     3
  1154                                  stdprn      EQU     4
  1155                                  
  1156                                  ; <Xenix subfunction assignments>
  1157                                  
  1158                                  open_for_read   EQU 0
  1159                                  open_for_write  EQU 1
  1160                                  open_for_both   EQU 2
  1161                                  
  1162                                  ; 13/07/2018 - Retro DOS v3.0
  1163                                  ; (FILEMODE.INC, MSDOS 6.0, 1991)
  1164                                  
  1165                                  access_mask	EQU 0Fh ; 09/08/2018
  1166                                  
  1167                                  EXEC_OPEN	EQU 3		; access code of 3 indicates that open was 
  1168                                  				; made from exec
  1169                                  SHARING_MASK	    equ 0F0h
  1170                                  SHARING_COMPAT	    equ 000h
  1171                                  SHARING_DENY_BOTH   equ 010h
  1172                                  SHARING_DENY_WRITE  equ 020h
  1173                                  SHARING_DENY_READ   equ 030h
  1174                                  SHARING_DENY_NONE   equ 040h
  1175                                  SHARING_NET_FCB     equ 070h
  1176                                  SHARING_NO_INHERIT  equ 080h
  1177                                  
  1178                                  ; 09/07/2018 - Retro DOS v3.0
  1179                                  ; (SYSCALL.INC, MSDOS 3.3, 1987)
  1180                                  ; ----------------------------------------------------------------------------
  1181                                  
  1182                                  ; <system call definitions>
  1183                                  
  1184                                  ABORT                           EQU 0   ;  0      0
  1185                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1186                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1187                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1188                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1189                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1190                                  RAW_CON_IO                      EQU 6   ;  6      6
  1191                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1192                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1193                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1194                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1195                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1196                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1197                                  DISK_RESET                      EQU 13  ; 13      D
  1198                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1199                                  FCB_OPEN                        EQU 15  ; 15      F
  1200                                  FCB_CLOSE                       EQU 16  ; 16     10
  1201                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1202                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1203                                  FCB_DELETE                      EQU 19  ; 19     13
  1204                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1205                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1206                                  FCB_CREATE                      EQU 22  ; 22     16
  1207                                  FCB_RENAME                      EQU 23  ; 23     17
  1208                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1209                                  SET_DMA                         EQU 26  ; 26     1A
  1210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1211                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1212                                  ;                                                                          ;
  1213                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1214                                  ;                                                                          ;
  1215                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1216                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1217                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1218                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1219                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1220                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1221                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1222                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1223                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1224                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1225                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1226                                  GET_DATE                        EQU 42  ; 42     2A
  1227                                  SET_DATE                        EQU 43  ; 43     2B
  1228                                  GET_TIME                        EQU 44  ; 44     2C
  1229                                  SET_TIME                        EQU 45  ; 45     2D
  1230                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1231                                  ; Extended functionality group
  1232                                  GET_DMA                         EQU 47  ; 47     2F
  1233                                  GET_VERSION                     EQU 48  ; 48     30
  1234                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1235                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1236                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1237                                  ;                                                                          ;
  1238                                  GET_DPB                         EQU 50  ; 50     32
  1239                                  ;                                                                          ;
  1240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1242                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1243                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1244                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1245                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1246                                  CHAR_OPER                       EQU 55  ; 55     37
  1247                                  INTERNATIONAL                   EQU 56  ; 56     38
  1248                                  ; XENIX CALLS
  1249                                  ;   Directory Group
  1250                                  MKDIR                           EQU 57  ; 57     39
  1251                                  RMDIR                           EQU 58  ; 58     3A
  1252                                  CHDIR                           EQU 59  ; 59     3B
  1253                                  ;   File Group
  1254                                  CREAT                           EQU 60  ; 60     3C
  1255                                  OPEN                            EQU 61  ; 61     3D
  1256                                  CLOSE                           EQU 62  ; 62     3E
  1257                                  READ                            EQU 63  ; 63     3F
  1258                                  WRITE                           EQU 64  ; 64     40
  1259                                  UNLINK                          EQU 65  ; 65     41
  1260                                  LSEEK                           EQU 66  ; 66     42
  1261                                  CHMOD                           EQU 67  ; 67     43
  1262                                  IOCTL                           EQU 68  ; 68     44
  1263                                  XDUP                            EQU 69  ; 69     45
  1264                                  XDUP2                           EQU 70  ; 70     46
  1265                                  CURRENT_DIR                     EQU 71  ; 71     47
  1266                                  ;    Memory Group
  1267                                  ALLOC                           EQU 72  ; 72     48
  1268                                  DEALLOC                         EQU 73  ; 73     49
  1269                                  SETBLOCK                        EQU 74  ; 74     4A
  1270                                  ;    Process Group
  1271                                  EXEC                            EQU 75  ; 75     4B
  1272                                  EXIT                            EQU 76  ; 76     4C
  1273                                  _WAIT				EQU 77  ; 77     4D
  1274                                  FIND_FIRST                      EQU 78  ; 78     4E
  1275                                  ;   Special Group
  1276                                  FIND_NEXT                       EQU 79  ; 79     4F
  1277                                  ; SPECIAL SYSTEM GROUP
  1278                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1279                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1280                                  ;                                                                          ;
  1281                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1282                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1283                                  GET_IN_VARS                     EQU 82  ; 82     52
  1284                                  SETDPB                          EQU 83  ; 83     53
  1285                                  ;                                                                          ;
  1286                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1287                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1288                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1289                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1290                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1291                                  ;                                                                          ;
  1292                                  DUP_PDB                         EQU 85  ; 85     55
  1293                                  ;                                                                          ;
  1294                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1295                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1296                                  RENAME                          EQU 86  ; 86     56
  1297                                  FILE_TIMES                      EQU 87  ; 87     57
  1298                                  ALLOCOPER			EQU 88	; 88	 58
  1299                                  ; Network extention system calls
  1300                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1301                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1302                                  CREATENEWFILE			EQU 91	; 91	 5B
  1303                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1304                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1305                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1306                                  ;									   ;
  1307                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1308                                  					;	    CloseByName, CloseUser,
  1309                                  					;	    CloseUserProcess,
  1310                                  					;	    GetOpenFileList
  1311                                  ;									   ;
  1312                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1313                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1314                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1315                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1316                                  XNAMETRANS			EQU 96	; 96	 60
  1317                                  PATHPARSE			EQU 97	; 97	 61
  1318                                  GETCURRENTPSP			EQU 98	; 98	 62
  1319                                  HONGEUL 			EQU 99	; 99	 63
  1320                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1321                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1322                                  ;									   ;
  1323                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1324                                  ;									   ;
  1325                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1326                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1327                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1328                                  GETSETCDPG			EQU 102 ; 102	 66
  1329                                  EXTHANDLE			EQU 103 ; 103	 67
  1330                                  COMMIT				EQU 104 ; 104	 68
  1331                                  
  1332                                  ; 09/07/2018 - Retro DOS v3.0
  1333                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1334                                  
  1335                                  ;GetSetMediaID			EQU 105 ; 105	 69
  1336                                  ;IFS_IOCTL			EQU 107 ; 107	 6B
  1337                                  ;ExtOpen 			EQU 108 ; 108	 6C
  1338                                  
  1339                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1340                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1341                                  ;                                                                          ;
  1342                                  ;ifdef ROMEXEC
  1343                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1344                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1345                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1346                                  ;endif
  1347                                  ;                                                                          ;
  1348                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1349                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1350                                  
  1351                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1352                                  ;OEM_C1				EQU 249 ; 249    F9
  1353                                  ;OEM_C2				EQU 250 ; 250    FA
  1354                                  ;OEM_C3				EQU 251 ; 251    FB
  1355                                  ;OEM_C4				EQU 252 ; 252    FC
  1356                                  ;OEM_C5				EQU 253 ; 253    FD
  1357                                  ;OEM_C6				EQU 254 ; 254    FE
  1358                                  ;OEM_C7				EQU 255 ; 255    FF
  1359                                  
  1360                                  ;============================================================================
  1361                                  ; VERSIONA.INC (MSDOS 3.3, 24/07/1987)
  1362                                  ;============================================================================
  1363                                  ; 08/07/2018 - Retro DOS 3.0
  1364                                  
  1365                                  MAJOR_VERSION   EQU     3
  1366                                  MINOR_VERSION   EQU     30
  1367                                  
  1368                                  ;============================================================================
  1369                                  ; DOSSYM_V211.ASM (-*-)
  1370                                  ;============================================================================
  1371                                  
  1372                                  ;DOS_MAJOR_VERSION   EQU      2
  1373                                  ;DOS_MINOR_VERSION   EQU     11
  1374                                  
  1375                                  ;============================================================================
  1376                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1377                                  ;============================================================================
  1378                                  ; 09/07/2018 - Retro DOS 3.0
  1379                                  
  1380                                  ;
  1381                                  ; Current structure of the data returned by the international call
  1382                                  ;
  1383                                  
  1384                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1385                                  .Date_tim_format:
  1386 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1387                                  .Currency_sym:
  1388 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1389                                  .Thous_sep:
  1390 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1391                                  .Decimal_sep:
  1392 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1393                                  .Date_sep:
  1394 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1395                                  .Time_sep:
  1396 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1397                                  .Bit_field:	
  1398 0000000F ??                      		RESB 1		; Bit values
  1399                                                                     ;   Bit 0 = 0 if currency symbol first
  1400                                                                     ;         = 1 if currency symbol last
  1401                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1402                                                                     ;         = 1 if space after currency symbol
  1403                                  .Currency_cents:
  1404 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1405                                  .Time_24:
  1406 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1407                                  .Map_call:
  1408 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1409 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1410                                  				;  in pieces.
  1411                                  .Data_sep:
  1412 00000016 ????                    		RESB	2	; Data list separator character
  1413                                  .size:		
  1414                                  endstruc
  1415                                  
  1416                                  ;
  1417                                  ; Max size of the block returned by the INTERNATIONAL call
  1418                                  ;
  1419                                  internat_block_max	EQU	32
  1420                                  
  1421                                  ;============================================================================
  1422                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1423                                  ;============================================================================
  1424                                  ; 08/07/2018 - Retro DOS v3.0
  1425                                  
  1426                                  ;SysInitVars STRUC
  1427                                  struc SYSI
  1428 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1429 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1430 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1431 0000000C ????????                .CON:	    resd 1		; CON device
  1432 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1433 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1434 00000016 ????????                .CDS:	    resd 1		; CDS list
  1435 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1436 0000001E ????                    .Keep:	    resw 1		; keep count
  1437 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1438 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1439 00000022 ????????                .DEV:	    resd 1		; device list
  1440                                  ; 09/07/2018
  1441                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1442                                  ; Following parameters are used with MDSOS 6.0 (Retro DOS v4.0)
  1443 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1444 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1445 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1446 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1447 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splicees being done
  1448 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1449 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
  1450 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1451 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1452 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1453 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1454 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1455                                  endstruc
  1456                                  ;SysInitVars ENDS
  1457                                  
  1458                                  ;This is added for more information exchange between DOS, BIOS.
  1459                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1460                                  
  1461                                  ;SysInitVars_Ext struc
  1462                                  struc SYSI_EXT
  1463 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1464 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1465                                  endstruc
  1466                                  ;SysInitVars_Ext ends
  1467                                  
  1468                                  ;============================================================================
  1469                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1470                                  ;============================================================================
  1471                                  ; 09/07/2018 - Retro DOS v3.0
  1472                                  
  1473                                  ;*** J.K.
  1474                                  ;General Guide -
  1475                                  ;Category Code:
  1476                                  ; 0... .... DOS Defined
  1477                                  ; 1... .... User defined
  1478                                  ; .xxx xxxx Code
  1479                                  
  1480                                  ;Function Code:
  1481                                  ; 0... .... Return error if unsupported
  1482                                  ; 1... .... Ignore if unsupported
  1483                                  ; .0.. .... Intercepted by DOS
  1484                                  ; .1.. .... Passed to driver
  1485                                  ; ..0. .... Sends data/commands to device
  1486                                  ; ..1. .... Quries data/info from device
  1487                                  ; ...x .... Subfunction
  1488                                  ;
  1489                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1490                                  ; function set.  It plays no critical role; some functions may contain both
  1491                                  ; command and query elements. The convention is that such commands are
  1492                                  ; defined as "sends data".
  1493                                  
  1494                                  ;*****************************;*
  1495                                  ; BLOCK DRIVERS 	      ;*
  1496                                  ;*****************************;*
  1497                                  
  1498                                  ; IOCTL SUB-FUNCTIONS
  1499                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1500                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1501                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1502                                  IOCTL_READ_HANDLE	EQU	2
  1503                                  IOCTL_WRITE_HANDLE	EQU	3
  1504                                  IOCTL_READ_DRIVE	EQU	4
  1505                                  IOCTL_WRITE_DRIVE	EQU	5
  1506                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1507                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1508                                  IOCTL_CHANGEABLE?	EQU	8
  1509                                  IOCTL_DeviceLocOrRem?	EQU	9
  1510                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1511                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1512                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1513                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1514                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1515                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1516                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1517                                  ; (MSDOS 6.0)
  1518                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1519                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1520                                  
  1521                                  ; GENERIC IOCTL CATEGORY CODES
  1522                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1523                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1524                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1525                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1526                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1527                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1528                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1529                                  
  1530                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1531                                  RAWIO			EQU	8
  1532                                  
  1533                                  ; RAWIO SUB-FUNCTIONS
  1534                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1535                                  GET_DEVICE_PARAMETERS	EQU	60H
  1536                                  SET_DEVICE_PARAMETERS	EQU	40H
  1537                                  READ_TRACK		EQU	61H
  1538                                  WRITE_TRACK		EQU	41H
  1539                                  VERIFY_TRACK		EQU	62H
  1540                                  FORMAT_TRACK		EQU	42H
  1541                                  ; (MSDOS 6.0)
  1542                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1543                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1544                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1545                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1546                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1547                                  
  1548                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1549                                  BUILD_DEVICE_BPB	EQU	000000001B
  1550                                  
  1551                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1552                                  INSTALL_FAKE_BPB	EQU	000000001B
  1553                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1554                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1555                                  
  1556                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1557                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1558                                  STATUS_FOR_FORMAT	EQU	000000001B
  1559                                  ; (MSDOS 6.0)
  1560                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1561                                  
  1562                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1563                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1564                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1565                                  
  1566                                  ; DEVICETYPE VALUES
  1567                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1568                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1569                                  DEV_5INCH		EQU	0
  1570                                  DEV_5INCH96TPI		EQU	1
  1571                                  DEV_3INCH720KB		EQU	2
  1572                                  DEV_8INCHSS		EQU	3
  1573                                  DEV_8INCHDS		EQU	4
  1574                                  DEV_HARDDISK		EQU	5
  1575                                  DEV_OTHER		EQU	7
  1576                                  ; (MSDOS 6.0)
  1577                                  ;DEV_3INCH1440KB	EQU	7
  1578                                  DEV_3INCH2880KB		EQU	9
  1579                                  ; Retro DOS v2.0 - 26/03/2018
  1580                                  ;;DEV_TAPE		EQU	6
  1581                                  ;;DEV_ERIMO		EQU	8
  1582                                  ;DEV_3INCH2880KB	EQU	9
  1583                                  DEV_3INCH1440KB		EQU	10
  1584                                  
  1585                                  ; (MSDOS 3.3)
  1586                                  ;MAX_DEV_TYPE		EQU	7
  1587                                  
  1588                                  ; (MSDOS 6.0)
  1589                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1590                                  					; CURRENTLY SUPPORT.
  1591                                  
  1592                                  struc A_SECTORTABLE
  1593 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1594 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1595                                  .size:
  1596                                  endstruc
  1597                                  
  1598                                  ;============================================================================
  1599                                  ; DEVSYM.ASM
  1600                                  ;============================================================================
  1601                                  
  1602                                  ;SUBTTL DEVICE TABLE AND SRH DEFINITION
  1603                                  ;PAGE
  1604                                  
  1605                                  ; 07/07/2018 - Retro DOS v3.0
  1606                                  ; (DEVSYM.INC, MSDOS 6.0, 1991)
  1607                                  
  1608                                  ;**	DevSym.inc - Device Symbols
  1609                                  
  1610                                  ; The device table list has the form:
  1611                                  struc	SYSDEV
  1612 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1613 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1614 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1615 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1616 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1617                                  .size:
  1618                                  endstruc
  1619                                  
  1620                                  ;
  1621                                  ; ATTRIBUTE BIT MASKS
  1622                                  ;
  1623                                  ; CHARACTER DEVICES:
  1624                                  ;
  1625                                  ; BIT 15 -> MUST BE 1
  1626                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1627                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1628                                  ;     12 -> UNUSED
  1629                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1630                                  ;     10 -> MUST BE 0
  1631                                  ;      9 -> MUST BE 0
  1632                                  ;      8 -> UNUSED
  1633                                  ;      7 -> UNUSED
  1634                                  ;      6 -> UNUSED
  1635                                  ;      5 -> UNUSED
  1636                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1637                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1638                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1639                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1640                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1641                                  ;
  1642                                  ; BLOCK DEVICES:
  1643                                  ;
  1644                                  ; BIT 15 -> MUST BE 0
  1645                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1646                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1647                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1648                                  ;	    THE SAME PLACE.
  1649                                  ;     12 -> UNUSED
  1650                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1651                                  ;     10 -> MUST BE 0
  1652                                  ;      9 -> MUST BE 0
  1653                                  ;      8 -> UNUSED
  1654                                  ;      7 -> UNUSED
  1655                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1656                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1657                                  ;      5 -> UNUSED
  1658                                  ;      4 -> UNUSED
  1659                                  ;      3 -> UNUSED
  1660                                  ;      2 -> UNUSED
  1661                                  ;      1 -> UNUSED
  1662                                  ;      0 -> UNUSED
  1663                                  ;
  1664                                  
  1665                                  ;Attribute bit masks
  1666                                  DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
  1667                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1668                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1669                                  
  1670                                  ; 09/07/2018 - Retro DOS
  1671                                  ; (DEVSYM.INC, MSDOS 3.3, 1987) 
  1672                                  
  1673                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1674                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1675                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1676                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1677                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1678                                  				;  ENTRY POINTS, 0 IF NOT
  1679                                  
  1680                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1681                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1682                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1683                                  				;  ITS CURRENT FORM.
  1684                                  
  1685                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1686                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1687                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1688                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1689                                  
  1690                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1691                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1692                                  				;LOGICAL DRIVES, AND SUPPORTS
  1693                                  				;GENERIC IOCTL CALLS.
  1694                                  				;FOR CHARACTER DEVICES, THIS
  1695                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1696                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1697                                  
  1698                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1699                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1700                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1701                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1702                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1703                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1704                                  
  1705                                  ;Static Reguest Header
  1706                                  struc	SRHEAD
  1707 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1708 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1709 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1710 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1711 00000005 ????????????????                	resb 8		;Reserved for queue links
  1712                                  .size:
  1713                                  endstruc
  1714                                  
  1715                                  ;Status word masks
  1716                                  STERR   EQU     8000H           ;Bit 15 - Error
  1717                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1718                                  STDON   EQU     0100H           ;Bit 8 - Done
  1719                                  STECODE EQU     00FFH           ;Error code
  1720                                  WRECODE EQU     0
  1721                                  
  1722                                  ;Function codes
  1723                                  DEVINIT EQU     0               ;Initialization
  1724                                  DINITHL EQU     26              ;Size of init header
  1725                                  DEVMDCH EQU     1               ;Media check
  1726                                  DMEDHL  EQU     15              ;Size of media check header
  1727                                  DEVBPB  EQU     2               ;Get BPB
  1728                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1729                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1730                                  DEVRD   EQU     4               ;Read
  1731                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1732                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1733                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1734                                  DEVIST  EQU     6               ;Input status
  1735                                  DSTATHL EQU     13              ;Size of status header
  1736                                  DEVIFL  EQU     7               ;Input flush
  1737                                  DFLSHL  EQU     15              ;Size of flush header
  1738                                  DEVWRT  EQU     8               ;Write
  1739                                  DEVWRTV EQU     9               ;Write with verify
  1740                                  DEVOST  EQU     10              ;Output status
  1741                                  DEVOFL  EQU     11              ;Output flush
  1742                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1743                                  
  1744                                  ; 09/07/2018 - Retro DOS v3.0
  1745                                  ; (DEVSYM.INC, MSDOS 3.3, 1987) 
  1746                                  
  1747                                  DEVOPN	EQU	13		;DEVICE OPEN
  1748                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1749                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1750                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1751                                  ; 07/08/2018 - Retro DOS v3.0
  1752                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1753                                  GENIOCTL EQU	19
  1754                                  
  1755                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1756                                  ;		     20
  1757                                  ;		     21
  1758                                  ;		     22
  1759                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1760                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1761                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1762                                  
  1763                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1764                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1765                                  
  1766                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1767                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1768                                  ;
  1769                                  
  1770                                  struc IOCTL_REQ
  1771 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1772                                  				; GENERIC IOCTL ADDITION.
  1773 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1774 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1775 0000000F ????                    .REG_SI:	resw 1
  1776 00000011 ????                    .REG_DI:	resw 1
  1777 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1778                                  .size: ; 07/08/2018
  1779                                  endstruc
  1780                                  
  1781                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1782                                  GEN_IOCTL_WRT_TRK EQU	40H
  1783                                  GEN_IOCTL_RD_TRK  EQU	60H
  1784                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1785                                  
  1786                                  ;============================================================================
  1787                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1788                                  ;============================================================================
  1789                                  ; 16/07/2018 - Retro DOS v3.0 
  1790                                  
  1791                                  ;**	ERROR.INC - DOS Error Codes
  1792                                  ;
  1793                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1794                                  ;    return error codes through AX. If an error occurred then
  1795                                  ;    the carry bit will be set and the error code is in AX. If no error
  1796                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1797                                  ;
  1798                                  ;    Since the set of error codes is being extended as we extend the operating
  1799                                  ;    system, we have provided a means for applications to ask the system for a
  1800                                  ;    recommended course of action when they receive an error.
  1801                                  ;
  1802                                  ;    The GetExtendedError system call returns a universal error, an error
  1803                                  ;    location and a recommended course of action. The universal error code is
  1804                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1805                                  ;    is issued.
  1806                                  
  1807                                  
  1808                                  ;	2.0 error codes
  1809                                  
  1810                                  error_invalid_function		EQU	1
  1811                                  error_file_not_found		EQU	2
  1812                                  error_path_not_found		EQU	3
  1813                                  error_too_many_open_files	EQU	4
  1814                                  error_access_denied		EQU	5
  1815                                  error_invalid_handle		EQU	6
  1816                                  error_arena_trashed		EQU	7
  1817                                  error_not_enough_memory 	EQU	8
  1818                                  error_invalid_block		EQU	9
  1819                                  error_bad_environment		EQU	10
  1820                                  error_bad_format		EQU	11
  1821                                  error_invalid_access		EQU	12
  1822                                  error_invalid_data		EQU	13
  1823                                  ;**** reserved			EQU	14	; *****
  1824                                  error_invalid_drive		EQU	15
  1825                                  error_current_directory 	EQU	16
  1826                                  error_not_same_device		EQU	17
  1827                                  error_no_more_files		EQU	18
  1828                                  
  1829                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  1830                                  
  1831                                  error_write_protect		EQU	19
  1832                                  error_bad_unit			EQU	20
  1833                                  error_not_ready 		EQU	21
  1834                                  error_bad_command		EQU	22
  1835                                  error_CRC			EQU	23
  1836                                  error_bad_length		EQU	24
  1837                                  error_seek			EQU	25
  1838                                  error_not_DOS_disk		EQU	26
  1839                                  error_sector_not_found		EQU	27
  1840                                  error_out_of_paper		EQU	28
  1841                                  error_write_fault		EQU	29
  1842                                  error_read_fault		EQU	30
  1843                                  error_gen_failure		EQU	31
  1844                                  
  1845                                  ;	the new 3.0 error codes reported through INT 24
  1846                                  
  1847                                  error_sharing_violation 	EQU	32
  1848                                  error_lock_violation		EQU	33
  1849                                  error_wrong_disk		EQU	34
  1850                                  error_FCB_unavailable		EQU	35
  1851                                  error_sharing_buffer_exceeded	EQU	36
  1852                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  1853                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  1854                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  1855                                  
  1856                                  ;	New OEM network-related errors are 50-79
  1857                                  
  1858                                  error_not_supported		EQU	50
  1859                                  
  1860                                  error_net_access_denied		EQU	65	;M028
  1861                                  
  1862                                  ;	End of INT 24 reportable errors
  1863                                  
  1864                                  error_file_exists		EQU	80
  1865                                  error_DUP_FCB			EQU	81	; *****
  1866                                  error_cannot_make		EQU	82
  1867                                  error_FAIL_I24			EQU	83
  1868                                  
  1869                                  ;	New 3.0 network related error codes
  1870                                  
  1871                                  error_out_of_structures 	EQU	84
  1872                                  error_already_assigned		EQU	85
  1873                                  error_invalid_password		EQU	86
  1874                                  error_invalid_parameter 	EQU	87
  1875                                  error_NET_write_fault		EQU	88
  1876                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  1877                                  
  1878                                  ;	BREAK <Interrupt 24 error codes>
  1879                                  
  1880                                  ;**	Int24 Error Codes
  1881                                  
  1882                                  error_I24_write_protect 	EQU	0
  1883                                  error_I24_bad_unit		EQU	1
  1884                                  error_I24_not_ready		EQU	2
  1885                                  error_I24_bad_command		EQU	3
  1886                                  error_I24_CRC			EQU	4
  1887                                  error_I24_bad_length		EQU	5
  1888                                  error_I24_Seek			EQU	6
  1889                                  error_I24_not_DOS_disk		EQU	7
  1890                                  error_I24_sector_not_found	EQU	8
  1891                                  error_I24_out_of_paper		EQU	9
  1892                                  error_I24_write_fault		EQU	0Ah
  1893                                  error_I24_read_fault		EQU	0Bh
  1894                                  error_I24_gen_failure		EQU	0Ch
  1895                                  ; NOTE: Code 0DH is used by MT-DOS.
  1896                                  error_I24_wrong_disk		EQU	0Fh
  1897                                  
  1898                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  1899                                  ;
  1900                                  ;	NOTE: ABORT is ALWAYS allowed
  1901                                  
  1902                                  Allowed_FAIL			EQU	00001000B
  1903                                  Allowed_RETRY			EQU	00010000B
  1904                                  Allowed_IGNORE			EQU	00100000B
  1905                                  
  1906                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  1907                                  I24_area			EQU	00000110B  ; 00 if DOS
  1908                                  						   ; 01 if FAT
  1909                                  						   ; 10 if root DIR
  1910                                  						   ; 11 if DATA
  1911                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  1912                                  
  1913                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  1914                                  
  1915                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  1916                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  1917                                  ;	to take for error codes that they don't explicitly understand.
  1918                                  
  1919                                  ;	Values for error CLASS
  1920                                  
  1921                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  1922                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  1923                                  errCLASS_Auth		EQU	3	; Permission problem
  1924                                  errCLASS_Intrn		EQU	4	; Internal System Error
  1925                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  1926                                  errCLASS_SysFail	EQU	6	; System Failure
  1927                                  errCLASS_Apperr 	EQU	7	; Application Error
  1928                                  errCLASS_NotFnd 	EQU	8	; Not Found
  1929                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  1930                                  errCLASS_Locked 	EQU	10	; Locked
  1931                                  errCLASS_Media		EQU	11	; Media Failure
  1932                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  1933                                  errCLASS_Unk		EQU	13	; Unknown/other
  1934                                  
  1935                                  ;	Values for error ACTION
  1936                                  
  1937                                  errACT_Retry		EQU	1	; Retry
  1938                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  1939                                  errACT_User		EQU	3	; Ask user to regive info
  1940                                  errACT_Abort		EQU	4	; abort with clean up
  1941                                  errACT_Panic		EQU	5	; abort immediately
  1942                                  errACT_Ignore		EQU	6	; ignore
  1943                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  1944                                  
  1945                                  ;	Values for error LOCUS
  1946                                  
  1947                                  errLOC_Unk		EQU	1	; No appropriate value
  1948                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  1949                                  errLOC_Net		EQU	3	; Network
  1950                                  errLOC_SerDev		EQU	4	; Serial Device
  1951                                  errLOC_Mem		EQU	5	; Memory
  1952                                  
  1953                                  ;============================================================================
  1954                                  ; MULT.INC (MSDOS 3.3, 1987)
  1955                                  ;============================================================================
  1956                                  
  1957                                  ;Break <Critical section and Multiplex channels>
  1958                                  
  1959                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1960                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1961                                  ;									   ;
  1962                                  ; Critical section definitions
  1963                                  ;
  1964                                  ; These below are subject to leave-all sections
  1965                                  critDisk    EQU     1			; Disk I/O critical section
  1966                                  critDevice  EQU     2			; Device I/O critical section
  1967                                  critShare   EQU     1			; Sharer I/O critical section
  1968                                  critMem     EQU     1			; memory maintenance critical section
  1969                                  critNet     EQU     5			; network critical section
  1970                                  critSFT     EQU     1			; sft table allocation
  1971                                  ; These below are not subject to leave-all sections
  1972                                  critASSIGN  EQU     8			; Assign has munged a system call
  1973                                  ;									   ;
  1974                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1975                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1976                                  
  1977                                  ;
  1978                                  ; The current set of defined multiplex channels is (* means documented):
  1979                                  ;
  1980                                  ;   Channel(h)	Issuer		Receiver    Function
  1981                                  ;      00	server		PSPRINT     print job control
  1982                                  ;     *01	print/apps	PRINT	    Queueing of files
  1983                                  ;      02	BIOS		REDIR	    signal open/close of printers
  1984                                  ;
  1985                                  ;      05	command 	REDIR	    obtain text of net int 24 message
  1986                                  ;     *06	server/assign	ASSIGN	    Install check
  1987                                  ;
  1988                                  ;      08	external driver IBMBIO	    interface to internal routines
  1989                                  ;
  1990                                  ;      10	sharer/server	Sharer	    install check
  1991                                  ;      11	DOS/server	Redir	    install check/redirection funcs
  1992                                  ;      12	sharer/redir	DOS	    dos functions and structure maint
  1993                                  ;      13	MSNET		MSNET	    movement of NCBs
  1994                                  ;      14	DOS		NLSFUNC     down load NLS country info,DOS 3.3
  1995                                  ;      14	Apps		Popup	    DOS 4.XX popup screen functions
  1996                                  ;	  ***> NOTE <***  Yes there are 2 users of 14h but since DOS 4.XX
  1997                                  ;			  doesn't use NLSFUNC, there is no conflict
  1998                                  ;      15	Apps		MSCDEX	    CD-ROM redirector interface
  1999                                  ;      16	Winoldap (?)	WIN386	    Private Windows communication
  2000                                  ;      17	Winoldap (?)	WIN386	    Win386 clipboard interface
  2001                                  ;      18	Apps		MS-Manager  Toggle interface to manager
  2002                                  ;      19,(13h) external driver IBMBIO	    Reset_Int_13, allows installation
  2003                                  ;					    of alternative INT_13 drivers after
  2004                                  ;					    boot_up
  2005                                  ;      B0	GRAFTABL	GRAFTABL
  2006                                  ;
  2007                                  
  2008                                  MultSHARE   EQU     10h 		; sharer
  2009                                      ;	1   MFT_enter
  2010                                      ;	2   MFTClose
  2011                                      ;	3   MFTclU
  2012                                      ;	4   MFTCloseP
  2013                                      ;	5   MFTCloN
  2014                                      ;	6   set_block
  2015                                      ;	7   clr_block
  2016                                      ;	8   chk_block
  2017                                      ;	9   MFT_get
  2018                                      ;	10  ShSave
  2019                                      ;	11  ShChk
  2020                                      ;	12  ShCol
  2021                                      ;	13  ShCloseFile
  2022                                  
  2023                                  MultNET     EQU     11h 		; Network support
  2024                                      ;	1   NET_RMDIR
  2025                                      ;	2   NET_SEQ_RMDIR
  2026                                      ;	3   NET_MKDIR
  2027                                      ;	4   NET_SEQ_MKDIR
  2028                                      ;	5   NET_CHDIR
  2029                                      ;	6   NET_CLOSE
  2030                                      ;	7   NET_COMMIT
  2031                                      ;	8   NET_READ
  2032                                      ;	9   NET_WRITE
  2033                                      ;	10  NET_LOCK
  2034                                      ;	11  NET_UNLOCK
  2035                                      ;	12  NET_DISK_INFO
  2036                                      ;	13  NET_SET_FILE_ATTRIBUTE
  2037                                      ;	14  NET_SEQ_SET_FILE_ATTRIBUTE
  2038                                      ;	15  NET_GET_FILE_INFO
  2039                                      ;	16  NET_SEQ_GET_FILE_INFO
  2040                                      ;	17  NET_RENAME
  2041                                      ;	18  NET_SEQ_RENAME
  2042                                      ;	19  NET_DELETE
  2043                                      ;	20  NET_SEQ_DELETE
  2044                                      ;	21  NET_OPEN
  2045                                      ;	22  NET_SEQ_OPEN
  2046                                      ;	23  NET_CREATE
  2047                                      ;	24  NET_SEQ_CREATE
  2048                                      ;	25  NET_SEQ_SEARCH_FIRST
  2049                                      ;	26  NET_SEQ_SEARCH_NEXT
  2050                                      ;	27  NET_SEARCH_FIRST
  2051                                      ;	28  NET_SEARCH_NEXT
  2052                                      ;	29  NET_ABORT
  2053                                      ;	30  NET_ASSOPER
  2054                                      ;	31  Printer_SET_STRING
  2055                                      ;	32  NetFlushBuf
  2056                                      ;	33  NetBufWrite
  2057                                      ;	34  NetResetEnvironment
  2058                                      ;	35  NetSpoolCheck
  2059                                      ;	36  NetSpoolClose
  2060                                  
  2061                                  MultDOS     EQU     12h 		; DOS call back
  2062                                      ;	1   DOS_CLOSE
  2063                                      ;	2   RECSET
  2064                                      ;	3   Get DOSGROUP
  2065                                      ;	4   PATHCHRCMP
  2066                                      ;	5   OUT
  2067                                      ;	6   NET_I24_ENTRY
  2068                                      ;	7   PLACEBUF
  2069                                      ;	8   FREE_SFT
  2070                                      ;	9   BUFWRITE
  2071                                      ;	10  SHARE_VIOLATION
  2072                                      ;	11  SHARE_ERROR
  2073                                      ;	12  SET_SFT_MODE
  2074                                      ;	13  DATE16
  2075                                      ;	14  SETVISIT
  2076                                      ;	15  SCANPLACE
  2077                                      ;	16  SKIPVISIT
  2078                                      ;	17  StrCpy
  2079                                      ;	18  StrLen
  2080                                      ;	19  UCase
  2081                                      ;	20  POINTCOMP
  2082                                      ;	21  CHECKFLUSH
  2083                                      ;	22  SFFromSFN
  2084                                      ;	23  GetCDSFromDrv
  2085                                      ;	24  Get_User_Stack
  2086                                      ;	25  GetThisDrv
  2087                                      ;	26  DriveFromText
  2088                                      ;	27  SETYEAR
  2089                                      ;	28  DSUM
  2090                                      ;	29  DSLIDE
  2091                                      ;	30  StrCmp
  2092                                      ;	31  initcds
  2093                                      ;	32  pjfnfromhandle
  2094                                      ;	33  $NameTrans
  2095                                      ;	34  CAL_LK
  2096                                      ;	35  DEVNAME
  2097                                      ;	36  Idle
  2098                                      ;
  2099                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2100                                      ;	0   NLSInstall
  2101                                      ;	1   ChgCodePage
  2102                                      ;	2   GetExtInfo
  2103                                      ;	3   SetCodePage
  2104                                      ;	4   GetCntry
  2105                                      ;
  2106                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2107                                  ;	  it calls Multdos 42 to set up an entry routine address
  2108                                      ;	0   Install status  (reserved)
  2109                                      ;	1   Lookup
  2110                                      ;	2   Insert
  2111                                      ;	3   Delete
  2112                                      ;	4   Purge	    (reserved)
  2113                                  
  2114                                  ;============================================================================
  2115                                  ; FIND.INC (MSDOS 3.3, 1987)
  2116                                  ;============================================================================
  2117                                  ; 09/07/2018 - Retro DOS v3.0
  2118                                  
  2119                                  ;Break	<find first/next buffer>
  2120                                  
  2121                                  struc find_buf
  2122 00000000 ??                      .drive:	    resb 1		; drive of search
  2123 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2124 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2125 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2126 0000000F ????                    .DirStart:  resw 1		; DirStart
  2127 00000011 ??                      .attr:	    resb 1		; attribute found
  2128 00000012 ????                    .time:	    resw 1		; time
  2129 00000014 ????                    .date:	    resw 1		; date
  2130 00000016 ????                    .size_l:    resw 1		; low(size)
  2131 00000018 ????                    .size_h:    resw 1		; high(size)
  2132 0000001A <res Dh>                .pname:	    resb 13		; packed name
  2133                                  .size:
  2134                                  endstruc
  2135                                  
  2136                                  ;============================================================================
  2137                                  ; DOSCNTRY.INC (MSDOS 3.3, 1987)
  2138                                  ;============================================================================
  2139                                  ; 09/07/2018 - Retro DOS v3.0
  2140                                  
  2141                                  ;Equates for COUNTRY INFORMATION.
  2142                                  SetCountryInfo	EQU	1	;country info
  2143                                  SetUcase	EQU	2	;uppercase table
  2144                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2145                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2146                                  SetFileList	EQU	5	;valid file character list
  2147                                  SetCollate	EQU	6	;collating sequence
  2148                                  SetDBCS 	EQU	7	;double byte character set
  2149                                  SetALL		EQU	-1	;all the entries
  2150                                  
  2151                                  
  2152                                  ;DOS country and code page information table structure.
  2153                                  ;Internally, IBMDOS gives a pointer to this table.
  2154                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2155                                  ;this structure.
  2156                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2157 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2158 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2159 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2160 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 5)
  2161 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2162 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2163                                  
  2164 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2165 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2166                                  
  2167 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2168 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2169                                  
  2170 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2171 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2172                                  
  2173 00000060 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2174 00000061 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2175 00000063 ????                    .ccDosCountry:		resw 1	;system country code id
  2176 00000065 ????                    .ccDosCodePage:		resw 1	;system code page id
  2177 00000067 ????                    .ccDFormat:		resw 1	;date format
  2178 00000069 ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2179 0000006E ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2180 00000070 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2181 00000072 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2182 00000074 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2183 00000076 ??                      .ccCFormat:		resb 1	;currency format flags
  2184 00000077 ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2185 00000078 ??                      .ccTFormat:		resb 1	;time format
  2186 00000079 ????????                .ccMono_Ptr:		resd 1	;monocase routine entry point
  2187 0000007D ????                    .ccListSep:		resb 2	;data list separator
  2188 0000007F <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2189                                  .size:
  2190                                  endstruc
  2191                                  
  2192                                  ;Ucase table
  2193                                  struc CC_UCASE_TAB
  2194 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2195 00000002 <res 80h>               .ccUcase_data:		resb 128
  2196                                  endstruc
  2197                                  
  2198                                  ;File Ucase table
  2199                                  struc CC_FILE_UCASE_TAB
  2200 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2201 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2202                                  endstruc
  2203                                  
  2204                                  ;File char list
  2205                                  struc CC_FILE_CHAR_TAB
  2206 00000000 ????                    .ccFilechar_leng:	resw 1
  2207 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2208                                  endstruc
  2209                                  
  2210                                  ;collate table
  2211                                  struc CC_COLLATE_TAB
  2212 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2213 00000002 <res 100h>              .ccCollate_data:	resb 256
  2214                                  endstruc
  2215                                  
  2216                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2217                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) 
  2218                                  
  2219                                  ; 06/08/2018
  2220                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2221                                  
  2222                                  ;CAPITALIZATION equates
  2223                                  CAP_ONE_CHAR	equ	20H
  2224                                  CAP_STRING	equ	21H
  2225                                  CAP_ASCIIZ	equ	22H
  2226                                  CHECK_YES_NO	equ	23H
  2227                                  UPPER_TABLE	equ	80H
  2228                                  
  2229                                  ;NLS_YES	equ	59H  ; 'Y'
  2230                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2231                                  ;NLS_NO		equ	4EH  ; 'N'	
  2232                                  ;NLS_no2	equ	6EH  ; 'n'	
  2233                                  
  2234                                  ;============================================================================
  2235                                  ; CURDIR.INC (MSDOS 3.3, 1987)
  2236                                  ;============================================================================
  2237                                  ; 09/07/2018 - Retro DOS v3.0
  2238                                  
  2239                                  ;BREAK <Current directory list structure>
  2240                                  
  2241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2242                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2243                                  ;									   ;
  2244                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2245                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2246                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2247                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2248                                  ; of the disk being changed or if the path must be recracked.  The END	   ;
  2249                                  ; field is the location of the end of the definition.  No .. is allowed    ;
  2250                                  ; past this point							   ;
  2251                                  
  2252                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2253                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2254                                  
  2255                                  struc curdir	; curdir_list
  2256 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2257 00000043 ????                    .flags:		resw 1			; various flags
  2258 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2259 00000049 ????                    .ID:		resw 1			; cluster of current dir (net ID)
  2260 0000004B ????                    		resw 1
  2261 0000004D ????                    .user_word:	resw 1
  2262 0000004F ????                    .end:		resw 1			; end of assignment
  2263                                  .size:
  2264                                  endstruc
  2265                                  
  2266                                  curdirLen	EQU curdir.size		; Needed for screwed up
  2267                                  
  2268                                  %define curdir_netID curdir_ID  ; dword
  2269                                  
  2270                                  ;Flag word masks
  2271                                  curdir_isnet	EQU	1000000000000000B
  2272                                  curdir_inuse	EQU	0100000000000000B
  2273                                  curdir_splice	EQU	0010000000000000B
  2274                                  curdir_local	EQU	0001000000000000B
  2275                                  ;									   ;
  2276                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2277                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2278                                  
  2279                                  ;============================================================================
  2280                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2281                                  ;============================================================================
  2282                                  ; 09/07/2018 - Retro DOS v3.0
  2283                                  
  2284                                  ;BREAK <File Control Block definition>
  2285                                  
  2286                                  ;
  2287                                  ; Field definition for FCBs
  2288                                  ; The FCB has the following structure:
  2289                                  ;
  2290                                  ;	+---------------------------+
  2291                                  ;	|   Drive indicator(byte)   |
  2292                                  ;	+---------------------------+
  2293                                  ;	|    Filename (8 chars)     |
  2294                                  ;	+---------------------------+
  2295                                  ;	|    Extension (3 chars)    |
  2296                                  ;	+---------------------------+
  2297                                  ;	|   Current Extent(word)    |
  2298                                  ;	+---------------------------+
  2299                                  ;	|    Record size (word)     |
  2300                                  ;	+---------------------------+
  2301                                  ;	|    File Size (2 words)    |
  2302                                  ;	+---------------------------+
  2303                                  ;	|	Date of write	    |
  2304                                  ;	+---------------------------+
  2305                                  ;	|	Time of write	    |
  2306                                  ;	+---------------------------+
  2307                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2308                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2309                                  ;									   ;
  2310                                  ;	+---------------------------+
  2311                                  ;	|   8 bytes reserved	    |
  2312                                  ;	+---------------------------+
  2313                                  ;									   ;
  2314                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2315                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2316                                  ;	|    next record number     |
  2317                                  ;	+---------------------------+
  2318                                  ;	|   random record number    |
  2319                                  ;	+---------------------------+
  2320                                  ;
  2321                                  
  2322                                  struc	SYS_FCB
  2323 00000000 ??                      .drive:	resb 1
  2324 00000001 ????????????????        .name:	resb 8
  2325 00000009 ??????                  .ext:	resb 3
  2326 0000000C ????                    .EXTENT: resw 1
  2327 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2328 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2329                                  				; following word
  2330 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2331 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2332 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2333                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2334                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2335                                  ;									   ;
  2336 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2337                                  ;									   ;
  2338                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2339                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2340 00000020 ??                      .NR:	resb 1			; Next record
  2341 00000021 ????????                .RR:	resb 4			; Random record
  2342                                  endstruc
  2343                                  
  2344                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2345                                  				; NEXT
  2346                                  ; 20/07/2018
  2347                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2348                                  
  2349                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2350                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2351                                  ; NOTE about this byte (fcb_nsl_drive)
  2352                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2353                                  ;	00 means a local file or device with sharing loaded
  2354                                  ;	10 means a remote (network) file
  2355                                  ;	01 means a local file with no sharing loaded
  2356                                  ;	11 means a local device with no sharing loaded
  2357                                  
  2358                                  ; 20/07/2018
  2359                                  
  2360                                  ;
  2361                                  ; Network FCB
  2362                                  ;
  2363                                  
  2364                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2365                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2366                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2367                                  
  2368                                  ;
  2369                                  ; No sharing local file FCB
  2370                                  ;
  2371                                  
  2372                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2373                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2374                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2375                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2376                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2377                                  
  2378                                  ;
  2379                                  ; No sharing local device FCB
  2380                                  ;
  2381                                  
  2382                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2383                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2384                                  
  2385                                  ;
  2386                                  ; Sharing local FCB
  2387                                  ;
  2388                                  
  2389                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2390                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2391                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2392                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2393                                  
  2394                                  ;
  2395                                  ; Bogusness:  the four cases are:
  2396                                  ;
  2397                                  ;   local file	    00
  2398                                  ;   local device    40
  2399                                  ;   local sharing   C0
  2400                                  ;   network	    80
  2401                                  ;
  2402                                  ; Since sharing and network collide, we cannot use a test instruction for
  2403                                  ; deciding whether a network or a share check in involved
  2404                                  ;
  2405                                  FCBDEVICE   EQU 040h
  2406                                  FCBNETWORK  EQU 080h
  2407                                  FCBSHARE    EQU 0C0h
  2408                                  
  2409                                  ; FCBSPECIAL must be able to mask off both net and share
  2410                                  FCBSPECIAL  EQU 080h
  2411                                  FCBMASK     EQU 0C0h
  2412                                  
  2413                                  ;============================================================================
  2414                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2415                                  ;============================================================================
  2416                                  ; 11/07/2018 - Retro DOS v3.0
  2417                                  
  2418                                  struc	FEI	; FASTOPEN_EXTENDED_INFO
  2419 00000000 ??                      .dirpos:	resb 1
  2420                                  ;.dirsec:	resd 1 ; MSDOS 6.0
  2421 00000001 ????                    .dirsec:	resw 1 ; MSDOS 3.3
  2422 00000003 ????                    .clusnum:	resw 1
  2423                                  ;.lastent:	resw 1	; for search first ; MSDOS 6.0
  2424                                  ;.dirstart:	resw 1	; for search first ; MSDOS 6.0
  2425                                  .size:
  2426                                  endstruc
  2427                                  
  2428                                  ; 23/07/2018
  2429                                  ;FASTOPEN NAME CACHING Subfunctions
  2430                                  FONC_Look_up	equ	1
  2431                                  FONC_insert	equ	2
  2432                                  FONC_delete	equ	3
  2433                                  FONC_update	equ	4
  2434                                  FONC_purge	equ	5	;reserved for the future use.
  2435                                  FONC_Rename	equ	6	;AN001
  2436                                  
  2437                                  ; 27/07/2018
  2438                                  ;FastOpen Data Structure
  2439                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2440 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2441 00000002 ????????                .name_caching:	resd 1
  2442                                  ; MSDOS 6.0
  2443                                  ;.fatchain_caching: resd 1	;reserved for future use
  2444                                  .size:
  2445                                  endstruc
  2446                                  
  2447                                  ; 27/07/2018
  2448                                  ;Equates used in DOS.
  2449                                  FastOpen_Set	       equ     00000001b
  2450                                  FastOpen_Reset	       equ     11111110b
  2451                                  Lookup_Success	       equ     00000010b
  2452                                  Lookup_Reset	       equ     11111101b
  2453                                  Special_Fill_Set       equ     00000100b
  2454                                  Special_Fill_Reset     equ     11111011b
  2455                                  No_Lookup	       equ     00001000b
  2456                                  Set_For_Search	       equ     00010000b	;DCR 167
  2457                                  
  2458                                  ; 09/08/2018 
  2459                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2460                                  ; Fastxxx equates
  2461                                  FastOpen_ID	   equ	   1
  2462                                  FastSeek_ID	   equ	   2
  2463                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2464                                  
  2465                                  ;Structure definitions
  2466                                  ;
  2467                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2468 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2469 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2470                                  endstruc
  2471                                  
  2472                                  ;============================================================================
  2473                                  ; LOCK.INC, MSDOS 6.0, 1991
  2474                                  ;============================================================================
  2475                                  ; 14/07/2018 - Retro DOS v3.0
  2476                                  
  2477                                  ;**	LOCK.INC - Definitions for Record Locking
  2478                                  
  2479                                  ;**	LOCK functions
  2480                                  
  2481                                  LOCK_ALL	    equ    0
  2482                                  UNLOCK_ALL	    equ    1
  2483                                  LOCK_MUL_RANGE	    equ    2
  2484                                  UNLOCK_MUL_RANGE    equ    3
  2485                                  LOCK_READ	    equ    4
  2486                                  WRITE_UNLOCK	    equ    5
  2487                                  LOCK_ADD	    equ    6
  2488                                  
  2489                                  ;**	Structure for Lock buffer
  2490                                  
  2491                                  struc LockBuf
  2492 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2493 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2494                                  endstruc
  2495                                  
  2496                                  ;============================================================================
  2497                                  ; DPL.ASM, MSDOS 6.0, 1991
  2498                                  ;============================================================================
  2499                                  ; 04/08/2018 - Retro DOS v3.0
  2500                                  
  2501                                  ; (SRVCALL.ASM)
  2502                                  
  2503                                  struc DPL
  2504 00000000 ????                    .AX:	resw	1	; AX register
  2505 00000002 ????                    .BX:	resw	1	; BX register
  2506 00000004 ????                    .CX:	resw	1	; CX register
  2507 00000006 ????                    .DX:	resw	1	; DX register
  2508 00000008 ????                    .SI:	resw	1	; SI register
  2509 0000000A ????                    .DI:	resw	1	; DI register
  2510 0000000C ????                    .DS:	resw	1	; DS register
  2511 0000000E ????                    .ES:	resw	1	; ES register
  2512 00000010 ????                    .rsrvd: resw	1	; Reserved
  2513 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2514 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2515                                  .size:
  2516                                  endstruc
  2517                                   
  2518                                  ;============================================================================
  2519                                  ; MSDATA.ASM
  2520                                  ;============================================================================
  2521                                  ;============================================================================
  2522                                  ; MS_DATA.ASM (MSDOS 6.0, 1991) (1)
  2523                                  ;============================================================================
  2524                                  ; 16/07/2018 - Retro DOS 3.0	
  2525                                  
  2526                                  ;Break <Uninitialized data overlayed by initialization code>
  2527                                  
  2528                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
  2529                                  ; Init code overlaps with data area below
  2530                                  
  2531                                  		; Offset 0358h in IBMDOS.COM (MSDOS 3.3)
  2532                                  
  2533                                  ;	I_am    TIMEBUF,6               ; Time read from clock device
  2534                                  ;	I_am    DEVIOBUF,2              ; Buffer for I/O under file assignment
  2535                                  
  2536                                  TIMEBUF		EQU 	DATASEGMENT	; Offset 0358h (in IBMDOS.COM 3.3)
  2537                                  DEVIOBUF	EQU	TIMEBUF+6
  2538                                  ;
  2539                                  ; The following areas are used as temp buffer in EXEC system call
  2540                                  ;
  2541                                  ;       I_am    OPENBUF,128             ; buffer for name operations
  2542                                  ;       I_am    RenBuf,128              ; buffer for rename destination
  2543                                  
  2544                                  OPENBUF		EQU	DEVIOBUF+2	; DATASEGMENT+8 
  2545                                  RENBUF		EQU	OPENBUF+128	; DATASEGMENT+136
  2546                                  
  2547                                  ; Buffer for search calls
  2548                                  ;        I_am    SEARCHBUF,53		; internal search buffer
  2549                                  ;        I_am    DummyCDS,curdirLen
  2550                                  
  2551                                  SEARCHBUF	EQU	RENBUF+128	; DATASEGMENT+264
  2552                                  DUMMYCDS	EQU	SEARCHBUF+53	; DATASEGMENT+317 
  2553                                  						; Offset 495h in MSDOS 3.3
  2554                                  ;
  2555                                  ; End of contiguous buffer
  2556                                  ;
  2557                                  
  2558                                  ; Temporary directory entry for use by many routines.  Device directory
  2559                                  ; entries (bogus) are built here.
  2560                                  ;
  2561                                  ;        PUBLIC  DevFCB
  2562                                  ;DEVFCB  LABEL   BYTE                    ; Uses NAME1, NAME2, combined
  2563                                  ; WARNING.. do not alter position of NAME1 relative to DEVFCB
  2564                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
  2565                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
  2566                                  
  2567                                  DEVFCB		EQU	DUMMYCDS+curdirLen ; DATASEGMENT+398
  2568                                  
  2569                                  ;	I_am    NAME1,12                ; File name buffer
  2570                                  ;       I_am    NAME2,13                ;
  2571                                  ;	I_am    DESTSTART,WORD          ;
  2572                                  ;	DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
  2573                                  
  2574                                  NAME1		EQU	DEVFCB		; Offset 04E6h in IBMDOS.COM 3.3
  2575                                  NAME2		EQU	NAME1+12	; DATASEGMENT+410
  2576                                  DESTSTART	EQU	NAME2+13	; DATASEGMENT+423
  2577                                  
  2578                                  ;
  2579                                  ; End Temporary directory entry.
  2580                                  ;
  2581                                  
  2582                                  ;       I_am    ATTRIB,BYTE             ; storage for file attributes
  2583                                  ;	I_am    EXTFCB,BYTE             ; TRUE => extended FCB in use
  2584                                  
  2585                                  ATTRIB		EQU	DEVFCB + dir_entry.size ; Offset 0506h
  2586                                  	; Offset 0507h in IBMDOS.COM (MSDOS 3.3) 
  2587                                  EXTFCB		EQU	ATTRIB+1	; DATASEGMENT+431
  2588                                  
  2589                                  ;       I_am    SATTRIB,BYTE            ; Storage for search attributes
  2590                                  ;       I_AM    open_access,BYTE        ; access of open system call
  2591                                  ;       I_am    FoundDel,BYTE           ; true => file was deleted
  2592                                  ;       I_am    Found_dev,BYTE          ; true => search found a device
  2593                                  ;       I_am    fSplice,BYTE            ; true => do a splice in transpath
  2594                                  ;       I_am    fSharing,BYTE           ; TRUE => no redirection
  2595                                  ;       I_am    SECCLUSPOS,BYTE         ; Position of first sector within cluster
  2596                                  ;       I_am    TRANS,BYTE              ;
  2597                                  ;       I_am    READOP,BYTE             ;
  2598                                  ;       I_am    THISDRV,BYTE            ;
  2599                                  ;       I_am    CLUSFAC,BYTE            ;
  2600                                  ;       I_am    CLUSSPLIT,BYTE          ;
  2601                                  ;       I_am    INSMODE,BYTE            ; true => insert mode in buffered read
  2602                                  ;       I_am    cMeta,BYTE              ; count of meta'ed components found
  2603                                  ;       I_am    VOLID,BYTE              ;
  2604                                  ;       I_am    exit_type,BYTE          ; type of exit...
  2605                                  
  2606                                  SATTRIB		EQU	EXTFCB+1	; DATASEGMENT+432
  2607                                  OPEN_ACCESS	EQU	SATTRIB+1	; DATASEGMENT+433
  2608                                  FOUNDDEL	EQU	OPEN_ACCESS+1	; DATASEGMENT+434
  2609                                  FOUND_DEV	EQU	FOUNDDEL+1	; DATASEGMENT+435
  2610                                  FSPLICE		EQU	FOUND_DEV+1	; DATASEGMENT+436
  2611                                  FSHARING	EQU	FSPLICE+1	; DATASEGMENT+437
  2612                                  SECCLUSPOS	EQU	FSHARING+1	; DATASEGMENT+438
  2613                                  TRANS		EQU	SECCLUSPOS+1	; DATASEGMENT+439
  2614                                  READOP		EQU	TRANS+1		; DATASEGMENT+440	
  2615                                  THISDRV		EQU	READOP+1	; DATASEGMENT+441
  2616                                  CLUSFAC		EQU	THISDRV+1	; DATASEGMENT+442
  2617                                  CLUSSPLIT	EQU	CLUSFAC+1	; DATASEGMENT+443
  2618                                  INSMODE		EQU	CLUSSPLIT+1	; DATASEGMENT+444
  2619                                  CMETA		EQU	INSMODE+1	; DATASEGMENT+445
  2620                                  VOLID		EQU	CMETA+1		; DATASEGMENT+446
  2621                                  EXIT_TYPE	EQU	VOLID+1		; DATASEGMENT+447
  2622                                          
  2623                                  ;	EVEN
  2624                                  
  2625                                  ; WARNING - the following two items are accessed as a word
  2626                                  
  2627                                  ;	I_am    CREATING,BYTE           ; true => creating a file
  2628                                  ;	I_am	DELALL,BYTE		; = 0 iff BUGBUG
  2629                                  ;					; = DIRFREE iff BUGBUG
  2630                                  ;	I_am    EXITHOLD,DWORD          ; Temp location for proc terminate
  2631                                  ;	I_am    user_SP,WORD            ; User SP for system call
  2632                                  ;	I_am    user_SS,WORD            ; User SS for system call
  2633                                  ;	I_am    CONTSTK,WORD            ;
  2634                                  ;	I_am    THISDPB,DWORD           ;
  2635                                  ;	I_am    CLUSSAVE,WORD           ;
  2636                                  ; MSDOS 3.3
  2637                                  ;	I_am    CLUSSEC,WORD		;	
  2638                                  ;; MSDOS 6.0
  2639                                  ;;	I_am    CLUSSEC,DWORD           ;>32mb         ; AC0000
  2640                                  
  2641                                  	; Offset 0518h in IBMDOS.COM (MSDOS 3.3) 
  2642                                  
  2643                                  CREATING	EQU	EXIT_TYPE+1 	; DATASEGMENT+448
  2644                                  	; (End of 'MOVDPB' (in MSINIT) - Offset 0519h (just after 'retf'))
  2645                                  DELALL		EQU	CREATING+1	; DATASEGMENT+449
  2646                                  EXITHOLD	EQU	DELALL+1	; DATASEGMENT+450
  2647                                  USER_SP		EQU	EXITHOLD+4	; DATASEGMENT+454
  2648                                  USER_SS		EQU	USER_SP+2	; DATASEGMENT+456
  2649                                  CONTSTK		EQU	USER_SS+2	; DATASEGMENT+458	
  2650                                  THISDPB		EQU	CONTSTK+2	; DATASEGMENT+460
  2651                                  CLUSSAVE	EQU	THISDPB+4	; DATASEGMENT+464
  2652                                  CLUSSEC		EQU	CLUSSAVE+2	; Offset 052Ah ; DATASEGENT+466
  2653                                  
  2654                                  ;       I_am    PREREAD,WORD            ; 0 means preread; 1 means optional
  2655                                  ;       I_am    FATBYT,WORD             ; Used by ALLOCATE
  2656                                  ;       I_am    FATBYTE,WORD            ; Used by $SLEAZEFUNC
  2657                                  ;       I_am    DEVPT,DWORD             ;
  2658                                  ;       I_am    THISSFT,DWORD           ; Address of user SFT
  2659                                  ;       I_am    THISCDS,DWORD           ; Address of current CDS
  2660                                  ;       I_am    THISFCB,DWORD           ; Address of user FCB
  2661                                  
  2662                                  ; MSDOS 3.3
  2663                                  PREREAD		EQU	CLUSSEC+2	; OffseT 052Ch ; DATASEGMENT+468
  2664                                  
  2665                                  ; MSDOS 6.0
  2666                                  ; PREREAD	EQU	CLUSSEC+4
  2667                                  
  2668                                  FATBYT		EQU	PREREAD+2	; DATASEGMENT+470
  2669                                  FATBYTE		EQU	FATBYT+2	; Offset 0530h ; DATASEGMENT+472
  2670                                  DEVPT		EQU	FATBYTE+2	; DATASEGMENT+474	
  2671                                  THISSFT		EQU	DEVPT+4		; Offset 0536h ; DATASEGMENT+478
  2672                                  THISCDS		EQU	THISSFT+4	; DATASEGMENT+482	
  2673                                  THISFCB		EQU	THISCDS+4	; DATASEGMENT+486
  2674                                  
  2675                                  ; DATASEGMENT+490 :  ; *!!!*
  2676                                  	; Here is offset 0542h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 
  2677                                  ;SFN		EQU	THISFCB+4	; DATASEGMENT + 0542h - 0358h
  2678                                  
  2679                                  ;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
  2680                                  ;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
  2681                                  ;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
  2682                                  ;       I_am    WFP_START,WORD          ;
  2683                                  ;       I_am    REN_WFP,WORD            ;
  2684                                  ;       I_am    CURR_DIR_END,WORD       ;
  2685                                  ;       I_am    NEXTADD,WORD            ;
  2686                                  ;       I_am    LASTPOS,WORD            ;
  2687                                  ;       I_am    CLUSNUM,WORD            ;
  2688                                  ;       I_am    DIRSEC,DWORD            ;>32mb 		; AC0000
  2689                                  ;       I_am    DIRSTART,WORD           ;
  2690                                  ;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
  2691                                  ;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
  2692                                  ;                                       ; sectors
  2693                                  ;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
  2694                                  ;       I_am    BYTPOS,4                ; Byte position in file of access
  2695                                  ;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
  2696                                  ;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
  2697                                  ;       I_am    SECCNT,WORD             ; No. of whole sectors
  2698                                  ;       I_am    ENTFREE,WORD            ;
  2699                                  ;       I_am    ENTLAST,WORD            ;
  2700                                  ;       I_am    NXTCLUSNUM,WORD         ;
  2701                                  ;       I_am    GROWCNT,DWORD           ;
  2702                                  ;       I_am    CURBUF,DWORD            ;
  2703                                  ;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
  2704                                  ;       I_am    SAVEBX,WORD             ;
  2705                                  ;       I_am    SAVEDS,WORD             ;
  2706                                  ;       I_am    restore_tmp,WORD        ; return address for restore world
  2707                                  ;       I_am    NSS,WORD
  2708                                  ;       I_am    NSP,WORD	
  2709                                  
  2710                                  ;	....  [ MS_DATA.ASM (MSDOS 6.0, 1991) (2) ] ; $$$
  2711                                  
  2712                                  ;DOSDATA ENDS
  2713                                  
  2714                                  ;============================================================================
  2715                                  ; MSHEAD.ASM
  2716                                  ;============================================================================
  2717                                  
  2718                                  [BITS 16]
  2719                                  [ORG 0]
  2720                                  
  2721                                  START:
  2722 00000000 E97E73                          JMP     DOSINIT
  2723                                  
  2724                                  ;============================================================================
  2725                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2726                                  ;============================================================================
  2727                                  ; 16/07/2018 - Retro DOS 3.0
  2728                                  
  2729                                  	; MSDOS 6.0
  2730                                  ;	dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  2731                                  ;BioDataSeg:
  2732                                  ;	dw	0070h		; Bios data segment fixed at 70h
  2733                                  
  2734                                  	; MSDOS 3.3
  2735 00000003 0000                    	dw	0
  2736 00000005 00                      	db	0 ; 12/08/2018
  2737 00000006 42554720                	db	"BUG "
  2738 0000000A 0000                    	dw	0
  2739 0000000C 0000                    	dw	0
  2740                                  
  2741                                  ;============================================================================
  2742                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
  2743                                  ;============================================================================
  2744                                  ; 16/07/2018 - Retro DOS 3.0	
  2745                                  
  2746                                  	; MSDOS 3.3
  2747                                  MYNUM:			; Offset 000Eh
  2748 0000000E 0000                    	dw	0	
  2749                                  FCBLRU: 
  2750 00000010 0000                    	dw	0
  2751                                  OpenLRU:
  2752 00000012 0000                    	dw	0
  2753                                  OEM_HANDLER: 		; Pointer to OEM handler code	
  2754 00000014 FFFFFFFF                	dd	-1
  2755                                  LeaveAddr:
  2756                                  	;dd	LeaveDOS
  2757 00000018 [BC15]                  	dw	LeaveDOS ; 12/08/2018
  2758                                  RetryCount:		; Share retries
  2759 0000001A 0300                    	dw	3
  2760                                  RetryLoop:
  2761 0000001C 0100                    	dw	1
  2762                                  LastBuffer:
  2763 0000001E FFFFFFFF                	dd	-1	; Buffer queue recency pointer
  2764                                  CONTPOS:
  2765 00000022 0000                    	dw	0	; location in buffer of next read
  2766                                  arena_head:
  2767 00000024 0000                    	dw	0	; Segment # of first arena in memory
  2768                                  
  2769                                  ;; 16/07/2018
  2770                                  ;;****************************************************************************
  2771                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
  2772                                  ;;****************************************************************************
  2773                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
  2774                                  ;;
  2775                                  ;;	AH = 52h
  2776                                  ;;
  2777                                  ;;	on return:
  2778                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
  2779                                  ;;		Known "invars" fields follow (varies with DOS version):
  2780                                  ;;
  2781                                  ;;	Offset Size		 Description
  2782                                  ;;
  2783                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
  2784                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
  2785                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
  2786                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
  2787                                  ;;		      0 indicates no unread input (DOS 3.x)
  2788                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
  2789                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
  2790                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
  2791                                  ;;	  08   dword  pointer to $CLOCK device driver
  2792                                  ;;	  0C   dword  pointer to CON device driver
  2793                                  ;;	  10   byte   number of logical drives in system
  2794                                  ;;	  11   word   maximum bytes/block of any block device
  2795                                  ;;	  13   dword  pointer to DOS cache buffer header
  2796                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
  2797                                  ;;		      point to the next device in device chain
  2798                                  ;;
  2799                                  ;;****************************************************************************
  2800                                  
  2801                                  ; The following block of data is used by SYSINIT.  Do not change the order or
  2802                                  ; size of this block
  2803                                  
  2804                                  
  2805                                  ; The following block of data is used by SYSINIT. 
  2806                                  ; Do not change the order or size of this block
  2807                                  
  2808                                  ;SYSINITVAR:
  2809                                  SYSINITVARS:
  2810                                  DPBHEAD:
  2811 00000026 00000000                	dd	0	; Pointer to head of DPB-FAT list
  2812                                  SFT_ADDR:
  2813 0000002A [98000000]              	dd	SFTABL	; Pointer to first SFT table
  2814                                  BCLOCK:
  2815 0000002E 00000000                	dd	0	; The CLOCK device
  2816                                  BCON:
  2817 00000032 00000000                	dd	0	; Console device entry points
  2818                                  MAXSEC:
  2819 00000036 8000                    	dw	128	; Maximum allowed sector size
  2820                                  BUFFHEAD:
  2821 00000038 00000000                	dd	0	; Pointer to head of buffer queue
  2822                                  CDSADDR:
  2823 0000003C 00000000                	dd	0	; Pointer to curdir structure table
  2824                                  SFTFCB:
  2825 00000040 00000000                	dd	0	; pointer to FCB cache table
  2826                                  KEEPCOUNT:
  2827 00000044 0000                    	dw	0	; count of FCB opens to keep
  2828                                  NUMIO:
  2829 00000046 00                      	db	0	; Number of disk tables
  2830                                  CDSCOUNT:
  2831 00000047 00                      	db	0	; Number of CDS structures in above
  2832                                  ; A fake header for the NUL device
  2833                                  NULDEV:
  2834 00000048 00000000                	dd	0	; Link to rest of device list
  2835                                  	;dw	8004h
  2836 0000004C 0480                    	dw	DEVTYP | ISNULL	; Null device attributes
  2837 0000004E [2C16]                  	dw	SNULDEV	; Strategy entry point
  2838 00000050 [3216]                  	dw	INULDEV	; Interrupt entry point
  2839 00000052 4E554C2020202020        	db	"NUL     " ; Name of null device
  2840                                  SPLICES:
  2841 0000005A 00                      	db	0	; TRUE => splices being done
  2842                                  
  2843                                  	; MSDOS 6.0 
  2844                                  ;Special_Entries:
  2845                                  ;	dw	0	; address of special entries	;AN000;
  2846                                  ;UU_IFS_DOS_CALL:
  2847                                  ;	dd	0	; entry for IFS DOS service	;AN000;
  2848                                  ;; 
  2849                                  ;; UU_IFS_HEADER:
  2850                                  ;; 	dd	0	; IFS header chain		;AN000;
  2851                                  ;;
  2852                                  ;ChkCopyProt:
  2853                                  ;	dw	0	; M068
  2854                                  ;A20OFF_PSP:
  2855                                  ;	dw	0	; M068
  2856                                  ;BUFFERS_PARM1:
  2857                                  ;	dw	0	; value of BUFFERS= ,m 	;AN000;
  2858                                  ;BUFFERS_PARM2:
  2859                                  ;	dw	0	; value of BUFFERS= ,n 	;AN000
  2860                                  ;BOOTDRIVE:
  2861                                  ;	db	0	; the boot drive	;AN000;
  2862                                  ;DDMOVE:
  2863                                  ;	db	0 	; 1 if we need DWORD move ;AN000;
  2864                                  ;EXT_MEM_SIZE:
  2865                                  ;	dw	0	; extended memory size 	;AN000;
  2866                                  
  2867                                  ;HASHINITVAR: ; LABEL   WORD	; AN000;
  2868                                  ;;
  2869                                  ;; Replaced by next two declarations
  2870                                  ;;
  2871                                  ;;UU_BUF_HASH_PTR:
  2872                                  ;;	dd	0	; buffer Hash table addr
  2873                                  ;;UU_BUF_HASH_COUNT:
  2874                                  ;;	dw	1	; number of Hash entries
  2875                                  ;
  2876                                  ;BufferQueue:
  2877                                  ;	dd	0	; Head of the buffer Queue
  2878                                  ;DirtyBufferCount:
  2879                                  ;	dw	0	; Count of Dirty buffers in the Que
  2880                                  ;			; BUGBUG ---- change to byte
  2881                                  ;SC_CACHE_PTR:
  2882                                  ;	dd	0	; secondary cache pointer
  2883                                  ;SC_CACHE_COUNT:
  2884                                  ;	dw	0 	; secondary cache count
  2885                                  ;BuffInHMA:
  2886                                  ;	db	0	; Flag to indicate that buffs are in HMA
  2887                                  ;LoMemBuff:
  2888                                  ;	dd	0	; Ptr to intermediate buffer
  2889                                  ;			;  in Low mem when buffs are in HMA
  2890                                  ;;
  2891                                  ;; All variables which have UU_ as prefix can be reused for other
  2892                                  ;; purposes and can be renamed. All these variables were used for
  2893                                  ;; EMS support of Buffer Manager. Now they are useless for Buffer
  2894                                  ;; manager ---- MOHANS
  2895                                  ;;
  2896                                  ;
  2897                                  ;	I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
  2898                                  ;UU_BUF_EMS_FIRST_PAGE:	
  2899                                  ;	db	0,0,0	; holds the first page above 640K
  2900                                  ;
  2901                                  ;;	I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
  2902                                  ;;					   ; above 640K
  2903                                  ;;UU_BUF_EMS_NPA640:
  2904                                  ;;	dw	0			
  2905                                  ;
  2906                                  ;CL0FATENTRY:
  2907                                  ;	dw	-1	; M014:	Holds the data that
  2908                                  ;			; is used in pack/unpack rts.
  2909                                  ;			; in fat.asm if cluster 0 is specified.
  2910                                  ;			; SR;
  2911                                  ;IoStatFail:
  2912                                  ;	db	0	; IoStatFail has been added to 
  2913                                  ;			; record a fail on an I24 
  2914                                  ;			; issued from IOFUNC on a status call. 
  2915                                  ;
  2916                                  ;;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
  2917                                  ;;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
  2918                                  ;;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
  2919                                  ;;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
  2920                                  ;;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
  2921                                  ;;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
  2922                                  ;
  2923                                  ;;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
  2924                                  ;						; state of the 	buffers page.
  2925                                  ;						; This one byte is retained to 
  2926                                  ;						; keep the size of this data 
  2927                                  ;						; block the same.;
  2928                                  ;ALLOCMSAVE:
  2929                                  ;	db	0	; M063: temp var. used to 
  2930                                  ;			; M063: save alloc method in
  2931                                  ;			; M063: msproc.asm
  2932                                  ;A20OFF_COUNT:
  2933                                  ;	db	0	; M068: indiactes the # of 
  2934                                  ;			; M068: int 21 calls for 
  2935                                  ;			; M068: which A20 is off
  2936                                  ;DOS_FLAG:
  2937                                  ;	db	0	; see DOSSYM.INC for Bit 
  2938                                  ;			; definitions
  2939                                  ;UNPACK_OFFSET:
  2940                                  ;	dw	0	; saves pointer to the start
  2941                                  ;			; of unpack code in exepatch.
  2942                                  ;			; asm.
  2943                                  ;UMBFLAG:
  2944                                  ;	db	0 	; M003: bit 0 indicates the 
  2945                                  ;			; M003: link state of the UMBs
  2946                                  ;			; M003: whether linked or not 
  2947                                  ;			; M003: to the DOS arena chain
  2948                                  ;SAVE_AX:
  2949                                  ;	dw	0	; M000: temp varibale to store ax
  2950                                  ;			; M000: in msproc.asm
  2951                                  ;UMB_HEAD:
  2952                                  ;	dw	-1	; M000: this is initialized to  
  2953                                  ;			; M000: the first umb arena by 
  2954                                  ;			; M000: BIOS sysinit.
  2955                                  ;START_ARENA:
  2956                                  ;	dw	1	; M000: this is the first arena 
  2957                                  ;			; M000: from which DOS will 
  2958                                  ;			; M000: start its scan for alloc.
  2959                                  
  2960                                  ; End of SYSINITVar block
  2961                                  
  2962                                  ; 16/07/2018
  2963                                  ; MSDOS 3.3 (& MDOS 6.0)
  2964                                  
  2965                                  ;
  2966                                  ; Sharer jump table
  2967                                  ;
  2968                                  
  2969                                  ;PUBLIC	JShare
  2970                                  	;EVEN
  2971 0000005B 90                      align 2
  2972                                  
  2973                                  JShare: ; LABEL	DWORD
  2974 0000005C [B817]0000              		DW	BadCall,0
  2975 00000060 [BC17]0000              MFT_enter	DW	OKCall, 0  ; 1   MFT_enter
  2976 00000064 [BC17]0000              MFTClose	DW	OKCall, 0  ; 2   MFTClose
  2977 00000068 [B817]0000              MFTclU		DW	BadCall,0  ; 3   MFTclU
  2978 0000006C [B817]0000              MFTCloseP	DW	BadCall,0  ; 4   MFTCloseP
  2979 00000070 [B817]0000              MFTCloN		DW	BadCall,0  ; 5   MFTCloN
  2980 00000074 [B817]0000              set_block	DW	BadCall,0  ; 6   set_block
  2981 00000078 [B817]0000              clr_block	DW	BadCall,0  ; 7   clr_block
  2982 0000007C [BC17]0000              chk_block	DW	OKCall, 0  ; 8   chk_block
  2983 00000080 [B817]0000              MFT_get		DW	BadCall,0  ; 9   MFT_get
  2984 00000084 [B817]0000              ShSave		DW	BadCall,0  ; 10  ShSave
  2985 00000088 [B817]0000              ShChk		DW	BadCall,0  ; 11  ShChk
  2986 0000008C [BC17]0000              ShCol		DW	OKCall, 0  ; 12  ShCol
  2987 00000090 [B817]0000              ShCloseFile	DW	BadCall,0  ; 13  ShCloseFile
  2988 00000094 [B817]0000              ShSU		DW	BadCall,0  ; 14  ShSU
  2989                                  
  2990                                  ;============================================================================
  2991                                  ; CONST2.ASM (MSDOS 6.0, 1991)
  2992                                  ;============================================================================
  2993                                  ; 16/07/2018 - Retro DOS 3.0	
  2994                                  
  2995                                  ;Break <Initialized data and data used at DOS initialization>
  2996                                  
  2997                                  ;
  2998                                  ; We need to identify the parts of the data area that are relevant to tasks
  2999                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
  3000                                  ; data will be gathered with the system code.  The process data under 2.x will
  3001                                  ; be available for swapping and under 3.0 it will be allocated per-process.
  3002                                  ;
  3003                                  ; The data that is system data will be identified by [SYSTEM] in the comments
  3004                                  ; describing that data item.
  3005                                  
  3006                                  ;	AsmVars <Debug, Redirector, ShareF>
  3007                                  
  3008                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
  3009                                  
  3010                                  ;
  3011                                  ; Table of routines for assignable devices
  3012                                  ;
  3013                                  ; MSDOS allows assignment if the following standard devices:
  3014                                  ;   stdin  (usually CON input)
  3015                                  ;   stdout (usually CON output)
  3016                                  ;   auxin  (usually AUX input)
  3017                                  ;   auxout (usually AUX output)
  3018                                  ;   stdlpt (usually PRN output)
  3019                                  ;
  3020                                  ; SPECIAL NOTE:
  3021                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
  3022                                  ;   If we're not at end-of-file, then we always say that we have a character.
  3023                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
  3024                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
  3025                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
  3026                                  ;   as EOF).
  3027                                  
  3028                                  ; Default SFTs for boot up
  3029                                  
  3030                                  		;PUBLIC	SFTABL
  3031                                  
  3032                                  SFTABL:	   ; LABEL   DWORD		; file table
  3033 00000098 FFFF                    		DW -1			; link to next table
  3034 0000009A FFFF                    		DW -1			; link seg to next table
  3035 0000009C 0500                    		DW sf_default_number	; Number of entries in table
  3036 0000009E 00<rep 109h>            		times (sf_default_number*sf_entry_size) db 0
  3037                                  
  3038                                  ; the next two variables relate to the position of the logical stdout/stdin
  3039                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
  3040                                  ; console.
  3041                                  
  3042                                  		; Offset 01A7h in IBMDOS.COM (MSDOS 3.3)
  3043 000001A7 00                      CARPOS:		db 0			; cursor position in stdin
  3044 000001A8 00                      STARTPOS:	db 0			; position of cursor at beginning
  3045 000001A9 00<rep 80h>             INBUF:		times 128 db 0		; general device input buffer
  3046 00000229 00<rep 83h>             CONBUF:		times 131 db 0		; The rest of INBUF and console buffer
  3047                                  		; Offset 02ACh in IBMDOS.COM (MSDOS 3.3)
  3048 000002AC 00                      PFLAG:		db 0			; printer echoing flag
  3049 000002AD 00                      VERFLG:		db 0			; Initialize with verify off
  3050 000002AE 03                      CHARCO:		db 00000011b		; Allows statchks every 4 chars...
  3051                                  switch_character:
  3052 000002AF 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
  3053 000002B0 00                      AllocMethod:	db 0			; how to alloc first(best)last
  3054 000002B1 00                      fShare:		db 0			; TRUE => sharing installed
  3055 000002B2 01                      DIFFNAM:	db 1			; Indicates when MYNAME has changed                                        ; of buffered input call
  3056 000002B3 20<rep 10h>             MYNAME:		times 16 db 20h		; My network name
  3057                                  
  3058                                  ;
  3059                                  ; The following table is a list of addresses that the sharer patches to be
  3060                                  ; PUSH AX to enable the critical sections
  3061                                  ;
  3062                                  		; Offset 02C3h in IBMDOS.COM (MSDOS 3.3)
  3063                                  
  3064                                  ;PUBLIC	CritPatch
  3065                                  
  3066                                  CritPatch:	; LABEL WORD
  3067                                  
  3068                                  ;IRP sect,<critDisk,critDevice>
  3069                                  
  3070                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
  3071                                  ;
  3072                                  ;SR; Change code patch address to a variable in data segment
  3073                                  ;
  3074                                  ;       dw OFFSET DOSDATA: redir_patch
  3075                                  ;       dw OFFSET DOSDATA: redir_patch
  3076                                  ;
  3077                                  ;;hkn	Short_Addr  E&sect
  3078                                  ;;hkn	Short_Addr  L&sect
  3079                                  ;
  3080                                  ;ELSE
  3081                                  ;	DW	0
  3082                                  ;	DW	0
  3083                                  ;ENDIF
  3084                                  ;ENDM
  3085                                  ;	DW	0
  3086                                  
  3087                                  	; 16/07/2018 - Retro DOS v3.0
  3088                                  	; IBMDOS.COM (MSDOS 3.3), offset 02C3h
  3089                                   
  3090 000002C3 [6320]                  	dw 	EcritDisk
  3091 000002C5 [6B20]                  	dw 	LcritDisk			
  3092 000002C7 [7320]                  	dw	EcritDevice
  3093 000002C9 [7B20]                  	dw 	LcritDevice
  3094                                  
  3095 000002CB 0000                    	dw	0
  3096                                  
  3097                                  ;
  3098                                  ; WARNING!!!  PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
  3099                                  ; Also, IBM server 1.0 requires this also.
  3100                                  ;
  3101                                  	;EVEN			; Force swap area to start on word boundry
  3102 000002CD 90                      align 2
  3103                                  	;PUBLIC	SWAP_START
  3104                                  SWAP_START:	; LABEL BYTE
  3105 000002CE 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
  3106 000002CF 00                      INDOS:		db 0		; DOS status for interrupt processing
  3107 000002D0 FF                      WPERR:		db -1		; Write protect error flag
  3108 000002D1 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
  3109 000002D2 0000                    EXTERR:		dw 0		; Extended Error code
  3110                                  
  3111                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
  3112 000002D4 00                      EXTERR_ACTION:	db 0		; Extended Error Action
  3113 000002D5 00                      EXTERR_CLASS:	db 0		; Extended Error Class
  3114                                  ; end warning
  3115                                   
  3116 000002D6 00000000                EXTERRPT:	dd 0		; Extended Error pointer
  3117                                  
  3118 000002DA 8000                    DMAADD:		dw 80H		; User's disk transfer address (disp/seg)
  3119 000002DC 0000                                    dw 0	
  3120 000002DE 0000                    CurrentPDB:	dw 0		; Current process identifier
  3121 000002E0 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
  3122 000002E2 0000                    exit_code:	dw 0		; exit code of last proc.
  3123 000002E4 00                      CURDRV:		db 0		; Default drive (init A)
  3124 000002E5 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
  3125                                  ;				; F.C. 2/17/86
  3126                                  ;CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
  3127                                  ;CPSWSAVE:	db 0		; copy of above in case of ABORT
  3128                                  SWAP_ALWAYS:	; 05/08/2018
  3129 000002E6 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
  3130                                  				;   extended error type stuff.
  3131                                  				;   NOTE: does not have Correct value on
  3132                                  				;   1-12, OEM, Get/Set CurrentPDB,
  3133                                  				;   GetExtendedError system calls)
  3134 000002E8 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
  3135 000002EA 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
  3136 000002EC 0000                    FirstArena:	dw 0		; first free block found
  3137 000002EE 0000                    BestArena:	dw 0		; best free block found
  3138 000002F0 0000                    LastArena:	dw 0		; last free block found
  3139 000002F2 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
  3140 000002F4 0000                    LASTENT:	dw 0		; Last entry for directory search
  3141 000002F6 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
  3142 000002F7 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
  3143 000002F8 00                      NoSetDir:	db 0		; true -> do not set directory
  3144 000002F9 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
  3145 000002FA 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
  3146                                  
  3147                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
  3148                                  	;EVEN
  3149 000002FB 90                      align 2
  3150                                  	; Offset 02FCh in IBMDOS.COM (MSDOS 3.3); 
  3151 000002FC 00                      DAY:		db 0		; Day of month
  3152 000002FD 00                      MONTH:		db 0		; Month of year
  3153 000002FE 0000                    YEAR:		dw 0		; Year (with century)
  3154 00000300 FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
  3155 00000302 00                      WEEKDAY:	db 0		; Day of week
  3156                                  ; end warning
  3157                                  
  3158 00000303 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
  3159 00000304 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
  3160 00000305 00                      fAborting:	db 0		; TRUE => abort in progress
  3161                                  
  3162                                  ; Combination of all device call parameters
  3163                                  	;PUBLIC	DEVCALL 	;
  3164                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
  3165                                  DEVCALL: ; 08/08/2018
  3166 00000306 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
  3167 00000307 00                      DEVCALL_REQUNIT: db 0		;Device unit number
  3168 00000308 00                      DEVCALL_REQFUNC: db 0		;Type of request
  3169 00000309 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
  3170 0000030B 00<rep 8h>                       times 8 db 0		;Reserved for queue links
  3171                                  
  3172                                  	;PUBLIC	CALLUNIT
  3173                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
  3174                                  CALLFLSH: ; LABEL   WORD	;
  3175 00000313 00                      CALLMED:	db 0		; media byte
  3176                                  CALLBR:	  ; LABEL   DWORD	;
  3177                                  	;PUBLIC	CALLXAD 	;
  3178                                  CALLXAD:  ; LABEL   DWORD	;
  3179 00000314 00                      CALLRBYT:	db 0		;
  3180                                  	;PUBLIC	CALLVIDM	;
  3181                                  CALLVIDM: ; LABEL   DWORD	;
  3182 00000315 00<rep 3h>              	times 3 db 0	;
  3183                                  	;PUBLIC CallBPB		;
  3184                                  CALLBPB:  ; LABEL   DWORD	;
  3185                                  CALLSCNT:			;
  3186 00000318 0000                    		dw 0		;
  3187                                  	;PUBLIC	CALLSSEC	;
  3188                                  CALLSSEC: ; LABEL   WORD	;
  3189 0000031A 0000                    		dw 0		;
  3190 0000031C 00000000                CALLVIDRW:	dd 0		;
  3191                                  ;*MSDOS 6.0
  3192                                  ;*CALLNEWSC:	dd 0		; starting sector for >32mb
  3193 00000320 00000000                CALLDEVAD:	dd 0		; stash for device entry point
  3194                                  
  3195                                  ; Same as above for I/O calls	;
  3196                                  				;
  3197                                  	;PUBLIC	IOCall		;
  3198                                  ;IOCALL	SRHEAD	<>		;
  3199                                  IOCALL:	; 07/08/2018
  3200 00000324 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
  3201 00000325 00                      IOCALL_REQUNIT:	db 0		;Device unit number
  3202 00000326 00                      IOCALL_REQFUNC: db 0		;Type of request
  3203 00000327 0000                    IOCALL_REQSTAT: dw 0		;Status Word
  3204 00000329 00<rep 8h>              	times 8	db 0		;Reserved for queue links
  3205                                  IOFLSH:	  ; LABEL   WORD	;
  3206                                          ;PUBLIC  IORCHR		;
  3207                                  IORCHR:	  ; LABEL   BYTE	;
  3208 00000331 00                      IOMED:		db 0		;
  3209 00000332 00000000                IOXAD:		dd 0		;
  3210 00000336 0000                    IOSCNT:		dw 0		;	
  3211 00000338 0000                    IOSSEC:		dw 0		;
  3212                                  
  3213                                  ; Call struct for DSKSTATCHK	;
  3214 0000033A 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
  3215 0000033B 00                      		db 0
  3216 0000033C 05                      DSKSTCOM:	db DEVRDND	; = 5
  3217 0000033D 0000                    DSKSTST:	dw 0		;
  3218 0000033F 00<rep 8h>              	times 8	db 0		;
  3219 00000347 00                      DSKCHRET:	db 0		;
  3220                                  
  3221                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
  3222                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
  3223                                  ;hkn   short_addr  DEVIOBUF	;
  3224                                  	
  3225 00000348 [5E03]                  DEVIOBUF_PTR	dw DEVIOBUF
  3226 0000034A 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
  3227 0000034C 0100                    DSKSTCNT:	dw 1		;
  3228 0000034E 0000                    		dw 0		;
  3229                                  
  3230 00000350 00                      CreatePDB:	db 0		; flag for creating a process
  3231                                  
  3232                                  ;* MSDOS 6.0
  3233                                  ;*	;PUBLIC	Lock_Buffer	;
  3234                                  ;*Lock_Buffer: ; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
  3235                                  ;*	    	dd 0		;MS. position
  3236                                  ;*	 	dd 0		;MS. length
  3237                                  
  3238                                  ;hkn; the foll. was moved from dosmes.asm.
  3239                                  
  3240                                  	;EVEN
  3241 00000351 90                      align 2				; needed to maintain offsets
  3242                                  
  3243                                  	; Offset 0352h in IBMDOS.COM (MSDOS 3.3)
  3244                                  	;PUBLIC  UserNum, OEMNum
  3245                                  USERNUM:
  3246 00000352 0000                     		dw 0		; 24 bit user number
  3247 00000354 00                      		db 0
  3248                                  ;IF IBM
  3249                                  ;IF IBMCOPYRIGHT
  3250 00000355 00                      OEMNUM:		DB 0		; 8 bit OEM number
  3251                                  ;ELSE
  3252                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
  3253                                  ;ENDIF
  3254                                  ;ELSE
  3255                                  ;OEMNUM:	DB 0FFh
  3256                                  ;ENDIF
  3257                                  
  3258                                  ; 17/07/2018
  3259                                  ;----------------------------------------------------------------------------
  3260                                  ; (MSDOS 3.3, DOSMES.INC, 1987)
  3261                                  
  3262                                  ; The next variable points to the country table for the current country
  3263                                  ;	(the table returned by the AL=0 INTERNATIONAL call).
  3264                                  
  3265 00000356 [E40F]                  CurrentCounry:	dw USTABLE			
  3266                                  
  3267                                  
  3268                                  ;DOSDATA ENDS
  3269                                  
  3270                                  ;----------------------------------------------------------------------------
  3271                                  
  3272                                  ; 16/07/2018 - Retro DOS v3.0
  3273                                  
  3274                                  align 2
  3275                                  
  3276                                  DATASEGMENT EQU $ ; 17/04/2018
  3277                                  
  3278                                  ;============================================================================
  3279                                  ; MSINIT.ASM
  3280                                  ;============================================================================
  3281                                  ; 16/07/2018 - Retro DOS v3.0
  3282                                  ;	      (MSINIT code order/reference: MSDOS 3.3, IBMDOS.COM, 1987)
  3283                                  	
  3284                                  ; 15/04/2018 - Retro DOS v2.0 (DATA adaption for NASM)
  3285                                  
  3286                                  ; TITLE MSINIT.ASM -- MS-DOS INITIALIZATION CODE
  3287                                  
  3288                                  ;       ORG     0                       ; reset to beginning of data segment
  3289                                  ; Init code below overlaps with data area
  3290                                  
  3291                                  	
  3292                                  	; Offset 0358h in IBMDOS.COM (MSDOS 3.3)
  3293                                  
  3294                                  ;INITBLOCK DB    110H DUP(0)     ; Allow for segment round up
  3295 00000358 00<rep 110h>            INITBLOCK:	TIMES 272 DB 0
  3296                                  
  3297                                  	; Offset 0468h in IBMDOS.COM (MSDOS 3.3)
  3298                                  
  3299 00000468 0000                    INITSP:		DW 0
  3300 0000046A 0000                    INITSS:		DW 0
  3301                                  ;BUFFSTRT:	DW 0
  3302                                  
  3303                                  	; Offset 046Ch in IBMDOS.COM (MSDOS 3.3)	
  3304                                  
  3305                                  ;ASSUME  CS:DOSGROUP,DS:DOSGROUP,ES:DOSGROUP,SS:NOTHING
  3306                                  ;
  3307                                  ;        EXTRN   QUIT:NEAR,IRET:NEAR,ABSDRD:FAR,ABSDWRT:FAR
  3308                                  ;        EXTRN   COMMAND:NEAR,CALL_ENTRY:NEAR
  3309                                  ;        IF      NOT IBM
  3310                                  ;        EXTRN   HEADER:BYTE
  3311                                  ;        ENDIF
  3312                                  
  3313                                  MOVDPB:
  3314                                  	; 08/07/2018 - Retro DOS v3.0
  3315                                  ; This section of code is safe from being overwritten by block move
  3316                                          ;MOV     SP,[CS:INITSP]
  3317                                          ;MOV     SS,[CS:INITSS]
  3318                                          ; 30/03/2018
  3319 0000046C 8B26[6804]              	MOV     SP,[INITSP]
  3320 00000470 8E16[6A04]                      MOV     SS,[INITSS]
  3321 00000474 F3A4                    	REP     MOVSB
  3322 00000476 FC                              CLD
  3323                                          ; 15/07/2018
  3324                                  	;MOV	[ES:DMAADD+2],DX
  3325 00000477 8916[DC02]              	MOV	[DMAADD+2],DX
  3326 0000047B 8B36[2600]                      MOV     SI,[DPBHEAD]	; Address of first DPB
  3327                                  	;MOV	[ES:DPBHEAD+2],ES
  3328 0000047F 8C06[2800]                      MOV	[DPBHEAD+2],ES
  3329                                  	;MOV	[ES:SFT_ADDR+2],ES
  3330 00000483 8C06[2C00]              	MOV     [SFT_ADDR+2],ES
  3331 00000487 8A0E[4600]                      MOV     CL,[NUMIO]	; Number of DPBs
  3332 0000048B 30ED                            XOR     CH,CH
  3333                                  SETFINDPB:
  3334 0000048D 268C441A                        MOV     [ES:SI+1AH],ES
  3335 00000491 26C64417FF                      MOV     BYTE [ES:SI+17H],-1  ; Never accessed before
  3336 00000496 83C620                          ADD     SI,DPBSIZ ; 32	; Point to next DPB
  3337 00000499 E2F2                            LOOP    SETFINDPB
  3338 0000049B 83EE20                          SUB     SI,DPBSIZ ; sub si,32
  3339 0000049E 26C7441AFFFF                    MOV     WORD [ES:SI+1AH],-1
  3340                                          ; 15/07/2018 - Retro DOS v3.0
  3341                                  	;; MSDOS 2.11
  3342                                          ;MOV	DI,[BUFFSTRT]		; Set up one default buffer
  3343                                  	;MOV	[ES:BUFFHEAD+2],ES
  3344                                          ;MOV	[ES:BUFFHEAD],DI
  3345                                  	; MSDOS 3.3
  3346 000004A4 06                      	push	es ; *
  3347 000004A5 BF[8F73]                	mov	di,SYSBUF+15 
  3348 000004A8 D1DF                    	rcr	di,1
  3349 000004AA D1EF                    	shr	di,1
  3350 000004AC D1EF                    	shr	di,1
  3351 000004AE D1EF                    	shr	di,1
  3352 000004B0 8CC0                    	mov	ax,es
  3353 000004B2 01F8                    	add	ax,di
  3354 000004B4 8EC0                    	mov	es,ax
  3355 000004B6 31FF                    	xor	di,di
  3356 000004B8 8C06[3A00]              	mov     [BUFFHEAD+2],es
  3357 000004BC 893E[3800]              	mov     [BUFFHEAD],di
  3358                                  	;	
  3359 000004C0 26C74504FF00                    MOV     WORD [ES:DI+4],00FFH
  3360 000004C6 26C705FFFF                      MOV     WORD [ES:DI],-1
  3361 000004CB 26C74502FFFF                    MOV     WORD [ES:DI+2],-1
  3362 000004D1 07                      	pop	es; * ; 15/07/2018
  3363 000004D2 06                              PUSH    ES
  3364 000004D3 42                              INC     DX			; Leave enough room for the ARENA
  3365 000004D4 8B36[F202]              	mov	si,[ENDMEM] ; 15/07/2018
  3366                                  
  3367                                  	; 11/08/2018 - Retro DOS v3.0
  3368                                          ;invoke _$DUP_PDB		; create jfns and set CurrentPDB
  3369 000004D8 E84F19                  	CALL	_$DUP_PDB
  3370 000004DB 07                              POP	ES
  3371                                  ;
  3372                                  ; set up memory arena
  3373                                  ;SPECIAL NOTE FOR HIGHMEM VERSION
  3374                                  ; At this point a process header has been built where the start of the 
  3375                                  ; CONSTANTS segment as refed by CS is. From this point until the return 
  3376                                  ; below be careful about references off of CS.
  3377                                  ;
  3378                                  	; 13/04/2018 ; *
  3379                                          ;PUSH	AX ; *
  3380                                          ;MOV	AX,[CurrentPDB]
  3381 000004DC 2EA1[DE02]                      MOV	AX,[CS:CurrentPDB] ; 15/03/2018
  3382 000004E0 26A3[DE02]              	MOV     [ES:CurrentPDB],AX	; Put it in the REAL location
  3383 000004E4 26C606[5003]00                  MOV     BYTE [ES:CreatePDB],0	; reset flag in REAL location
  3384 000004EA 48                              DEC     AX
  3385 000004EB 26A3[2400]                      MOV     [ES:arena_head],AX
  3386 000004EF 1E                              PUSH    DS
  3387 000004F0 8ED8                            MOV     DS,AX
  3388 000004F2 C60600005A                      MOV     BYTE [ARENA.SIGNATURE],arena_signature_end
  3389 000004F7 C70601000000                    MOV     WORD [ARENA.OWNER],arena_owner_system
  3390 000004FD 262B06[F202]                    SUB     AX,[ES:ENDMEM]
  3391 00000502 F7D8                            NEG     AX
  3392 00000504 48                              DEC     AX
  3393 00000505 A30300                          MOV     [ARENA.SIZE],AX
  3394 00000508 1F                              POP     DS
  3395                                          ;POP	AX ; *
  3396                                  
  3397 00000509 BF[9E00]                        MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
  3398                                  	; 15/07/2018
  3399 0000050C B80300                          MOV     AX,3
  3400 0000050F AB                              STOSW		; Adjust Refcount
  3401                                  	;MOV	DI,SYSINITVAR	; 16/03/2018 (Retro DOS v2.0)
  3402 00000510 BF[3B0F]                	MOV     DI,SysInitTable ; 15/07/2018 (Retro DOS v3.0)
  3403 00000513 CB                              RETF
  3404                                  	
  3405                                  	; 18/04/2018
  3406                                  FILL1	equ	$ - DATASEGMENT
  3407                                  ; ---------------------------------------------------------------------------
  3408                                  ; 16/07/2018 - Retro DOS v3.0
  3409 00000514 00<rep 2Eh>             	times (490-FILL1) db 0	; *!!!*
  3410                                  
  3411                                  ;============================================================================
  3412                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)  (2)
  3413                                  ;============================================================================
  3414                                  ; 16/07/2018 - Retro DOS 3.0	
  3415                                  
  3416                                  ;  MS_DATA.ASM (MSDOS 6.0, 1991) (1) ... $$$
  3417                                   
  3418                                  ; (continues from 'SFN' ..) - from offset 0542h in IBMDOS.COM, 1987 -
  3419                                  
  3420                                  ; DATASEGMENT + 490
  3421                                  
  3422                                  ;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
  3423                                  ;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
  3424                                  ;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
  3425                                  ;       I_am    WFP_START,WORD          ;
  3426                                  ;       I_am    REN_WFP,WORD            ;
  3427                                  ;       I_am    CURR_DIR_END,WORD       ;
  3428                                  ;       I_am    NEXTADD,WORD            ;
  3429                                  ;       I_am    LASTPOS,WORD            ;
  3430                                  ;       I_am    CLUSNUM,WORD            ;
  3431                                  ; MSDOS 3.3
  3432                                  ;	I_am	DIRSEC,WORD
  3433                                  ;; MSDOS 6.0
  3434                                  ;;      I_am    DIRSEC,DWORD            ;>32mb		; AC0000
  3435                                  ;       I_am    DIRSTART,WORD           ;
  3436                                  ;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
  3437                                  ;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
  3438                                  ;                                       ; sectors
  3439                                  ;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
  3440                                  ;       I_am    BYTPOS,4                ; Byte position in file of access
  3441                                  ;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
  3442                                  ;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
  3443                                  ;       I_am    SECCNT,WORD             ; No. of whole sectors
  3444                                  
  3445 00000542 FFFF                    SFN:		dw -1
  3446 00000544 0000                    JFN:		dw 0
  3447 00000546 00000000                PJFN:		dd 0
  3448 0000054A 0000                    WFP_START: 	dw 0
  3449 0000054C 0000                    REN_WFP: 	dw 0
  3450 0000054E 0000                    CURR_DIR_END: 	dw 0
  3451 00000550 0000                    NEXTADD: 	dw 0
  3452 00000552 0000                    LASTPOS: 	dw 0
  3453 00000554 0000                    CLUSNUM: 	dw 0
  3454                                  ; MSDOS 3.3
  3455 00000556 0000                    DIRSEC: 	dw 0
  3456                                  ; MSDOS 6.0
  3457                                  ;DIRSEC:	dd 0
  3458 00000558 0000                    DIRSTART: 	dw 0
  3459                                  ; MSDOS 3.3
  3460 0000055A 0000                    SECPOS: 	dw 0
  3461                                  ; MSDOS 6.0
  3462                                  ;SECPOS: 	dd 0
  3463                                  ; MSDOS 3.3
  3464 0000055C 0000                    VALSEC: 	dw 0
  3465                                  ; MSDOS 6.0
  3466                                  ;VALSEC: 	dd 0
  3467 0000055E 0000                    BYTSECPOS: 	dw 0
  3468 00000560 00000000                BYTPOS:		dd 0
  3469 00000564 0000                    BYTCNT1: 	dw 0
  3470 00000566 0000                    BYTCNT2: 	dw 0
  3471 00000568 0000                    SECCNT: 	dw 0
  3472                                  
  3473                                  	; Offset 056Ah in IBMDOS.COM (MSDOS 3.3)
  3474                                  ; DATASEGMENT + 530 (in Retro DOS v3.0)
  3475                                  
  3476                                  ;       I_am    ENTFREE,WORD            ;
  3477                                  ;       I_am    ENTLAST,WORD            ;
  3478                                  ;       I_am    NXTCLUSNUM,WORD         ;
  3479                                  ;       I_am    GROWCNT,DWORD           ;
  3480                                  ;       I_am    CURBUF,DWORD            ;
  3481                                  ;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
  3482                                  ;       I_am    SAVEBX,WORD             ;
  3483                                  ;       I_am    SAVEDS,WORD             ;
  3484                                  ;       I_am    restore_tmp,WORD        ; return address for restore world
  3485                                  ;       I_am    NSS,WORD
  3486                                  ;       I_am    NSP,WORD
  3487                                  
  3488 0000056A 0000                    ENTFREE:	dw 0
  3489 0000056C 0000                    ENTLAST:	dw 0
  3490 0000056E 0000                    NXTCLUSNUM:	dw 0
  3491 00000570 00000000                GROWCNT:	dd 0
  3492 00000574 00000000                CURBUF:		dd 0
  3493 00000578 00000000                CONSFT:		dd 0
  3494 0000057C 0000                    SAVEBX:		dw 0
  3495 0000057E 0000                    SAVEDS:		dw 0
  3496 00000580 0000                    RESTORE_TMP:	dw 0
  3497 00000582 0000                    NSS:		dw 0
  3498 00000584 0000                    NSP:		dw 0	 ; Offset 0584h in IBMDOS.COM (MSDOS 3.3)
  3499                                  
  3500                                  ; DATASEGMENT+558 :  ; *!!!*
  3501                                  	; Here is offset 0586h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 
  3502                                  
  3503                                  ; MSDOS 6.0
  3504                                  ;       I_am    EXTOPEN_FLAG,WORD,<0>   ;FT. extended open input flag       ;AN000;
  3505                                  ;       I_am    EXTOPEN_ON,BYTE,<0>     ;FT. extended open conditional flag ;AN000;
  3506                                  ;       I_am    EXTOPEN_IO_MODE,WORD,<0>;FT. extended open io mode          ;AN000;
  3507                                  ;       I_am    SAVE_DI,WORD            ;FT. extended open saved DI         ;AN000;
  3508                                  ;       I_am    SAVE_ES,WORD            ;FT. extended open saved ES         ;AN000;
  3509                                  ;       I_am    SAVE_DX,WORD            ;FT. extended open saved DX         ;AN000;
  3510                                  ;       I_am    SAVE_CX,WORD            ;FT. extended open saved CX         ;AN000;
  3511                                  ;       I_am    SAVE_BX,WORD            ;FT. extended open saved BX         ;AN000;
  3512                                  ;       I_am    SAVE_SI,WORD            ;FT. extended open saved SI         ;AN000;
  3513                                  ;       I_am    SAVE_DS,WORD            ;FT. extended open saved DS         ;AN000;
  3514                                  
  3515                                  ;	HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
  3516                                  ;	we used to just pass 16 bits in a register.  Now High_SECTOR holds
  3517                                  ;	the high 16, the low 16 are still in the register.
  3518                                  ;
  3519                                  ;       I_am    HIGH_SECTOR,WORD,<0>    ;>32mb higher sector #		    ;AN000;
  3520                                  ;
  3521                                  ;       ;I_am    UU_HIGH_SECTOR_TEMP,WORD,<0> ;M019: Unused
  3522                                  ;       I_am    OffsetMagicPatch,WORD,<offset MagicPatch> ;scottq 8/6/92
  3523                                  ;                                                         ;see dos\mpatch.asm
  3524                                  ;
  3525                                  ;       I_am    DISK_FULL,BYTE          ;>32mb indicating disk full when 1  ;AN000;
  3526                                  ;       I_am    TEMP_VAR,WORD           ; temporary variable for everyone   ;AN000;
  3527                                  ;       I_am    TEMP_VAR2,WORD          ; temporary variable 2 for everyone ;AN000;
  3528                                  ;       I_am    DrvErr,BYTE             ; used to save drive error          ;AN000;
  3529                                  ;       I_am    DOS34_FLAG,WORD,<0>     ; common flag for DOS 3.4           ;AN000;
  3530                                  ;       I_am    NO_FILTER_PATH,DWORD    ; pointer to orignal path           ;AN000;
  3531                                  ;       I_am    NO_FILTER_DPATH,DWORD   ; pointer to orignal path of destination;AN000;
  3532                                  ;; M008
  3533                                  ;       I_am   AbsRdWr_SS,WORD         ; INT 25/26 user stack segment
  3534                                  ;       I_am   AbsRdWr_SP,WORD         ; INT 25/26 user stack offset
  3535                                  ;       I_am   UU_Callback_flag,BYTE,<0>  ; Unused
  3536                                  ;; M008
  3537                                   
  3538                                  ; make those pushes fast!!!
  3539                                  	;.EVEN
  3540                                  align 2
  3541                                  
  3542                                  ; MSDOS 3.3 ($ MSDOS 6.0)
  3543                                  StackSize equ 180h			; gross but effective
  3544                                  
  3545                                  ;;;StackSize = 300h			; This is a "trial" change IBM hasn't
  3546                                  ;;;					; made up their minds about
  3547                                   
  3548                                  ;
  3549                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
  3550                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
  3551                                  ;
  3552                                   
  3553                                          ;PUBLIC  RENAMEDMA,AuxStack,DskStack,IOStack
  3554                                  RENAMEDMA:  ; LABEL   BYTE		; See DOS_RENAME
  3555                                  	;DB	StackSize DUP (?)       ;
  3556 00000586 00<rep 180h>            	times	StackSize db 0
  3557                                  
  3558                                  AUXSTACK:   ; LABEL   BYTE		;  Offset 0706h in IBMDOS.COM, 1987
  3559                                   	;DB	StackSize DUP (?)       ;
  3560 00000706 00<rep 180h>            	times	StackSize db 0
  3561                                  DSKSTACK:   ; LABEL   BYTE		;  Offset 0886h in IBMDOS.COM, 1987
  3562                                   	;DB	StackSize DUP (?)       ;
  3563 00000886 00<rep 180h>            	times	StackSize db 0
  3564                                  IOSTACK:    ; LABEL   BYTE		;  Offset 0A06h in IBMDOS.COM, 1987
  3565                                   
  3566                                  ; patch space for Boca folks.
  3567                                  ; Say What????!!! This does NOT go into the swappable area!
  3568                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
  3569                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
  3570                                   
  3571                                  ;PUBLIC  IBMPATCH
  3572                                  ;IBMPATCH label byte
  3573                                  ;	I_am    PRINTER_FLAG,BYTE,<0>   ; status of PRINT utility
  3574                                  ;	I_am    VOLCHNG_FLAG,BYTE,<0>   ; true if volume label created
  3575                                  ;	I_am    VIRTUAL_OPEN,BYTE,<0>   ; non-zero if we opened a virtual file
  3576                                  
  3577                                  IBMPATCH:
  3578 00000A06 00                      PRINTER_FLAG:	db 0
  3579 00000A07 00                      VOLCHNG_FLAG:	db 0
  3580 00000A08 00                      VIRTUAL_OPEN:	db 0
  3581                                  
  3582                                  ; MSDOS 6.0
  3583                                  ;; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
  3584                                  ;      I_am     FSeek_drive,BYTE         ;AN000; fastseek drive #
  3585                                  ;      I_am     FSeek_firclus,WORD       ;AN000; fastseek first cluster #
  3586                                  ;      I_am     FSeek_logclus,WORD       ;AN000; fastseek logical cluster #
  3587                                  ;      I_am     FSeek_logsave,WORD       ;AN000; fastseek returned log clus #
  3588                                  ;      I_am     UU_ACT_PAGE,WORD,<-1>    ;;;;;;; ;BL ; active EMS page ;AN000;
  3589                                  ;      I_am     TEMP_DOSLOC,WORD,<-1>    ;stores the temporary location of dos
  3590                                  					;at SYSINIT time.
  3591                                  ;SWAP_END LABEL   BYTE
  3592                                  ;PUBLIC  SWAP_END
  3593                                  
  3594                                  SWAP_END:
  3595                                   
  3596                                  ;; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
  3597                                  ;;   BE USED. If the size of the swap data area is ODD, it will be rounded up
  3598                                  ;;   to include this byte.
  3599                                  ;       DB      ?
  3600                                  
  3601 00000A09 00                      	db	0
  3602                                   
  3603                                  ;;hkn;	DB      (512+80+32-(SWAP_END-ibmpatch)) DUP (?)
  3604                                  
  3605                                  ;DOSDATA    ENDS
  3606                                  
  3607                                  ; 08/09/2018
  3608 00000A0A 00<rep 243h>            	times 579 db 0
  3609                                  
  3610                                  ;12/08/2018 - Retro DOS v3.0
  3611                                  ;15/07/2018
  3612                                  ;============================================================================
  3613                                  ; 	Retro DOS v3.0
  3614                                  ;============================================================================
  3615 00000C4D 00                      	db 	0
  3616                                  RETRODOSMSG:
  3617 00000C4E 0D0A                    	db	13,10
  3618                                  	;;db	"Retro DOS v3.0 by Erdogan Tan [2018]"
  3619                                  	;db	"Retro DOS v3.1 by Erdogan Tan [2019]" ; 29/06/2019
  3620 00000C50 526574726F20444F53-     	db	"Retro DOS v3.1 by Erdogan Tan [2019-2022]" ; 22/11/2022
  3620 00000C59 2076332E3120627920-
  3620 00000C62 4572646F67616E2054-
  3620 00000C6B 616E205B323031392D-
  3620 00000C74 323032325D         
  3621 00000C79 0D0A2400                	db	13,10,"$", 0 
  3622                                  
  3623                                  ;============================================================================
  3624                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3625                                  ;============================================================================
  3626                                  ; 16/07/2018 - Retro DOS 3.0
  3627                                  
  3628                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3629                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3630 00000C7D 03                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3631 00000C7E 1E                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3632                                  
  3633                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3634                                  ;        I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3635                                  ;        I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3636                                  
  3637                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3638                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3639                                  ;
  3640                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3641                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3642                                  
  3643                                  ; Days in year
  3644                                  
  3645                                  YRTAB:   
  3646 00000C7F C8A6                    	DB	200,166			; Leap year
  3647 00000C81 C8A5                    	DB	200,165
  3648 00000C83 C8A5                    	DB	200,165
  3649 00000C85 C8A5                    	DB	200,165
  3650                                  
  3651                                  ; Days of each month
  3652                                  
  3653                                  MONTAB:        
  3654 00000C87 1F                      	DB      31                      ; January
  3655                                  february:
  3656 00000C88 1C                      	DB	28 			; February--reset each 
  3657                                  					; time year changes
  3658 00000C89 1F                              DB      31                      ; March
  3659 00000C8A 1E                              DB      30                      ; April
  3660 00000C8B 1F                              DB      31                      ; May
  3661 00000C8C 1E                              DB      30                      ; June
  3662 00000C8D 1F                              DB      31                      ; July
  3663 00000C8E 1F                              DB      31                      ; August
  3664 00000C8F 1E                              DB      30                      ; September
  3665 00000C90 1F                              DB      31                      ; October
  3666 00000C91 1E                              DB      30                      ; November
  3667 00000C92 1F                              DB      31                      ; December
  3668                                  
  3669                                  ;
  3670                                  ; This is the error code mapping table for INT 21 errors.  This table defines
  3671                                  ; those error codes which are "allowed" for each system call.  If the error
  3672                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3673                                  ; is to return the "real" error via Extended error, and one of the allowed
  3674                                  ; errors on the actual call.
  3675                                  ;
  3676                                  ; The table is organized as follows:
  3677                                  ;
  3678                                  ;    Each entry in the table is of variable size, but the first
  3679                                  ;       two bytes are always:
  3680                                  ;
  3681                                  ;       Call#,Cnt of bytes following this byte
  3682                                  ;
  3683                                  ; EXAMPLE:
  3684                                  ;       Call 61 (OPEN)
  3685                                  ;
  3686                                  ;       DB      61,5,12,3,2,4,5
  3687                                  ;
  3688                                  ;       61 is the AH INT 21 call value for OPEN.
  3689                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3690                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3691                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3692                                  ;       this case 5).  The last value will be the one returned on the call if
  3693                                  ;       the "real" error is not one of the allowed ones.
  3694                                  ;
  3695                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3696                                  ;   there is NO entry.  This means that NO error codes are returned on this
  3697                                  ;   call, so set up an Extended error and leave the current error code alone.
  3698                                  ;
  3699                                  ; The table is terminated by a call value of 0FFh
  3700                                  
  3701                                  ;PUBLIC I21_MAP_E_TAB
  3702                                  	; 10/08/2018
  3703                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3704 00000C93 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3705 00000C97 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3706 00000C9C 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3707 00000CA0 0205                        DB          error_file_not_found,error_access_denied
  3708 00000CA2 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3709 00000CA6 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3710 00000CAA 04                          DB          error_too_many_open_files
  3711 00000CAB 05                          DB          error_access_denied
  3712                                      ; MSDOS 6.0
  3713                                      ;DB  OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3714                                      ;DB          error_too_many_open_files
  3715                                      ;DB          error_not_dos_disk,error_access_denied
  3716                                      ; MSDOS 3.3
  3717 00000CAC 3D0503020C                  DB  OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3718 00000CB1 0405                        DB          error_too_many_open_files,error_access_denied
  3719 00000CB3 3E0106                      DB  CLOSE,1,error_invalid_handle
  3720 00000CB6 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3721 00000CBA 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3722 00000CBE 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3723 00000CC3 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3724 00000CC7 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3725 00000CCC 05                          DB          error_access_denied
  3726 00000CCD 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3727 00000CD2 0605                        DB          error_invalid_handle,error_access_denied
  3728 00000CD4 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3729 00000CD8 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3730                                      ; MSDOS 6.0	
  3731                                      ;DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3732                                      ; MSDOS 3.3	
  3733 00000CDC 47010F                      DB  CURRENT_DIR,1,error_invalid_drive
  3734 00000CDF 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3735 00000CE3 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3736 00000CE7 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3737 00000CEC 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3738 00000CF1 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3739 00000CF4 0805                        DB          error_not_enough_memory,error_access_denied
  3740 00000CF6 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3741 00000CFB 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3742                                      ; MSDOS 6.0
  3743                                      ;DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3744                                      ;DB          error_current_directory,error_access_denied
  3745                                      ; MSDOS 3.3
  3746 00000CFE 5604110302                  DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3747 00000D03 05                          DB          error_access_denied
  3748                                      ; MSDOS 6.0	
  3749                                      ;DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3750                                      ;DB             error_invalid_data,error_invalid_function
  3751                                      ; MSDOS 3.03	
  3752 00000D04 57020601                    DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3753 00000D08 580101                      DB  ALLOCOPER,1,error_invalid_function
  3754 00000D0B 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3755 00000D0F 0405                        DB          error_too_many_open_files,error_access_denied
  3756 00000D11 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3757 00000D15 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3758 00000D18 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3759 00000D1C 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3760 00000D1E 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3761 00000D22 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3762 00000D26 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3763 00000D29 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3764 00000D2D 01                          DB              error_invalid_function
  3765                                      ; MSDOS 6.0		
  3766                                      ;DB	ExtOpen,10
  3767                                      ;DB   error_path_not_found,error_file_not_found,error_invalid_access
  3768                                      ;DB         error_too_many_open_files,error_file_exists,error_not_enough_memory
  3769                                      ;DB         error_not_dos_disk,error_invalid_data
  3770                                      ;DB             error_invalid_function,error_access_denied
  3771                                      ;DB GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3772                                      ;DB         error_invalid_function,error_access_denied
  3773 00000D2E FF                          DB  0FFh
  3774                                  
  3775                                  ;============================================================================
  3776                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3777                                  ;============================================================================
  3778                                  ; 16/07/2018 - Retro DOS 3.0
  3779                                  
  3780                                  ;**
  3781                                  ;
  3782                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
  3783                                  ; errors.  Each entry is 4 bytes long:
  3784                                  ;
  3785                                  ;       Err#,Class,Action,Locus
  3786                                  ;
  3787                                  ; A value of 0FFh indicates a call specific value (ie.  should already
  3788                                  ; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
  3789                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
  3790                                  ;
  3791                                  
  3792                                  ;PUBLIC  ERR_TABLE_21
  3793                                  ERR_TABLE_21: ; LABEL   BYTE
  3794 00000D2F 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,     0FFh
  3795 00000D33 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3796 00000D37 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3797 00000D3B 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,     errLOC_Unk
  3798 00000D3F 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,      0FFh
  3799 00000D43 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3800 00000D47 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,     errLOC_Mem
  3801 00000D4B 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3802 00000D4F 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
  3803 00000D53 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
  3804 00000D57 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,      errLOC_Unk
  3805 00000D5B 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3806 00000D5F 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,     errLOC_Unk
  3807 00000D63 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3808 00000D67 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,      errLOC_Disk
  3809 00000D6B 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,      errLOC_Disk
  3810 00000D6F 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3811 00000D73 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,      errLOC_Disk
  3812 00000D77 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3813 00000D7B 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3814 00000D7F 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,     0FFh
  3815 00000D83 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,      errLOC_Unk
  3816 00000D87 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,     errLOC_Disk
  3817 00000D8B 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
  3818 00000D8F 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,      errLOC_Net
  3819 00000D93 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,      errLOC_Unk
  3820 00000D97 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,     errLOC_Unk
  3821 00000D9B 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3822                                      ; MSDOS 6.0
  3823                                      ;DB  error_handle_EOF,            errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
  3824                                      ;DB  error_handle_Disk_Full,      errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
  3825                                      ;DB  error_sys_comp_not_loaded,   errCLASS_Unk,       errACT_Abort,     errLOC_Disk ;AN001;
  3826 00000D9F FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	    0FFh
  3827                                  
  3828                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
  3829                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
  3830                                  ;		db 2,8,3,2
  3831                                  ;		db 3,8,3,2
  3832                                  ;		db 4,1,4,1
  3833                                  ;		db 5,3,3,0FFh
  3834                                  ;		db 6,7,4,1
  3835                                  ;		db 7,7,5,5
  3836                                  ;		db 8,1,4,5
  3837                                  ;		db 9,7,4,5
  3838                                  ;		db 0Ah,7,4,5
  3839                                  ;		db 0Bh,9,3,1
  3840                                  ;		db 0Ch,7,4,1
  3841                                  ;		db 0Dh,9,4,1
  3842                                  ;		db 0Fh,8,3,2
  3843                                  ;		db 10h,3,3,2
  3844                                  ;		db 11h,0Dh,3,2
  3845                                  ;		db 12h,8,3,2
  3846                                  ;		db 50h,0Ch,3,2
  3847                                  ;		db 20h,0Ah,2,2
  3848                                  ;		db 21h,0Ah,2,2
  3849                                  ;		db 54h,1,4,0FFh
  3850                                  ;		db 56h,3,3,1
  3851                                  ;		db 52h,1,4,2
  3852                                  ;		db 32h,9,3,3
  3853                                  ;		db 55h,0Ch,3,3
  3854                                  ;		db 57h,9,3,1
  3855                                  ;		db 53h,0Dh,4,1
  3856                                  ;		db 24h,1,4,5
  3857                                  ;		db 0FFh,0FFh,0FFh,0FFh
  3858                                  
  3859                                  ;
  3860                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
  3861                                  ; errors.  Each entry is 4 bytes long:
  3862                                  ;
  3863                                  ;       Err#,Class,Action,Locus
  3864                                  ;
  3865                                  ; A Locus value of 0FFh indicates a call specific value (ie.  should already
  3866                                  ; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
  3867                                  ; THE END.
  3868                                  
  3869                                  ;PUBLIC  ERR_TABLE_24
  3870                                  ERR_TABLE_24: ; LABEL   BYTE
  3871 00000DA3 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3872 00000DA7 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3873 00000DAB 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,    0FFh
  3874 00000DAF 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3875 00000DB3 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,     errLOC_Disk
  3876 00000DB7 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3877 00000DBB 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,     errLOC_Disk
  3878 00000DBF 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3879 00000DC3 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,     errLOC_Disk
  3880 00000DC7 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,    errLOC_SerDev
  3881 00000DCB 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,     0FFh
  3882 00000DCF 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,     0FFh
  3883 00000DD3 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,     0FFh
  3884 00000DD7 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3885 00000DDB 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3886 00000DDF 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3887 00000DE3 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
  3888 00000DE7 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3889 00000DEB 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3890 00000DEF FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,     0FFh
  3891                                  
  3892                                  
  3893                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
  3894                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
  3895                                  ;		db 14h,4,5,1
  3896                                  ;		db 15h,5,7,0FFh
  3897                                  ;		db 16h,4,5,1
  3898                                  ;		db 17h,0Bh,4,2
  3899                                  ;		db 18h,4,5,1
  3900                                  ;		db 19h,5,1,2
  3901                                  ;		db 1Ah,0Bh,7,2
  3902                                  ;		db 1Bh,0Bh,4,2
  3903                                  ;		db 1Ch,2,7,4
  3904                                  ;		db 1Dh,5,4,0FFh
  3905                                  ;		db 1Eh,5,4,0FFh
  3906                                  ;		db 1Fh,0Dh,4,0FFh
  3907                                  ;		db 20h,0Ah,2,2
  3908                                  ;		db 21h,0Ah,2,2
  3909                                  ;		db 22h,0Bh,7,2
  3910                                  ;		db 32h,9,3,3
  3911                                  ;		db 23h,7,4,1
  3912                                  ;		db 24h,1,4,5
  3913                                  ;		db 0FFh,0Dh,5,0FFh
  3914                                  
  3915                                  ;
  3916                                  ; We need to map old int 24 errors and device driver errors into the new set
  3917                                  ; of errors.  The following table is indexed by the new errors
  3918                                  ;
  3919                                  
  3920                                  ;Public  ErrMap24
  3921                                  ErrMap24: ; Label   BYTE
  3922 00000DF3 13                          DB  error_write_protect	; 0
  3923 00000DF4 14                          DB  error_bad_unit		; 1
  3924 00000DF5 15                          DB  error_not_ready		; 2
  3925 00000DF6 16                          DB  error_bad_command	; 3
  3926 00000DF7 17                          DB  error_CRC		; 4
  3927 00000DF8 18                          DB  error_bad_length	; 5
  3928 00000DF9 19                          DB  error_seek		; 6
  3929 00000DFA 1A                          DB  error_not_DOS_disk	; 7
  3930 00000DFB 1B                          DB  error_sector_not_found	; 8
  3931 00000DFC 1C                          DB  error_out_of_paper	; 9
  3932 00000DFD 1D                          DB  error_write_fault	; A
  3933 00000DFE 1E                          DB  error_read_fault	; B
  3934 00000DFF 1F                          DB  error_gen_failure	; C
  3935 00000E00 1F                          DB  error_gen_failure	; D  RESERVED
  3936 00000E01 1F                          DB  error_gen_failure	; E  RESERVED
  3937 00000E02 22                          DB  error_wrong_disk	; F
  3938                                  
  3939                                  ;Public  ErrMap24End
  3940                                  ErrMap24End: ; LABEL   BYTE
  3941                                  
  3942                                  ; 16/07/2018 - Retro DOS v3.0
  3943                                  ;_MAXCALL:	db 	36
  3944                                  ;_MAXCOM:	db	104
  3945                                  
  3946                                  ; 08/09/2018
  3947 00000E03 24                          db  36
  3948 00000E04 68                          db  104
  3949                                  
  3950                                  ;============================================================================
  3951                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  3952                                  ;============================================================================
  3953                                  ; 11/07/2018 - Retro DOS v3.0
  3954                                  
  3955                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  3956                                  
  3957 00000E05 90                      align 2
  3958                                  
  3959                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  3960                                  
  3961                                  ; Standard Functions
  3962                                  ;DISPATCH    LABEL WORD
  3963                                  DISPATCH:
  3964                                  	; 16/07/2018 - Retro DOS v3.0
  3965                                  	; (MSDOS 3.3)
  3966                                  
  3967 00000E06 [CC64]                          short_addr  _$ABORT			    ;  0      0
  3968 00000E08 [7023]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  3969 00000E0A [7923]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  3970 00000E0C [3224]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  3971 00000E0E [4F24]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  3972 00000E10 [5524]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  3973 00000E12 [C222]                          short_addr  _$RAW_CON_IO		    ;  6      6
  3974 00000E14 [EE22]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  3975 00000E16 [8320]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  3976 00000E18 [EF20]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  3977 00000E1A [FB20]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  3978 00000E1C [6924]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  3979 00000E1E [7324]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  3980 00000E20 [501D]                          short_addr  _$DISK_RESET		    ; 13      D
  3981 00000E22 [4C1C]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  3982 00000E24 [7E2B]                          short_addr  _$FCB_OPEN			    ; 15      F
  3983 00000E26 [1C25]                          short_addr  _$FCB_CLOSE			    ; 16     10
  3984 00000E28 [7E2C]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  3985 00000E2A [132D]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  3986 00000E2C [B824]                          short_addr  _$FCB_DELETE		    ; 19     13
  3987 00000E2E [6A2C]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  3988 00000E30 [6F2C]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  3989 00000E32 [502C]                          short_addr  _$FCB_CREATE		    ; 22     16
  3990 00000E34 [8D25]                          short_addr  _$FCB_RENAME		    ; 23     17
  3991                                  	; 16/07/2018
  3992                                          ;short_addr _CPMFUNC			    ; 24     18	
  3993 00000E36 [1917]                          short_addr  NO_OP			    ; 24     18
  3994 00000E38 [471C]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  3995 00000E3A [3C1C]                          short_addr  _$SET_DMA			    ; 26     1A
  3996                                  
  3997                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  3998                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  3999                                  ;                                                                          ;
  4000 00000E3C [D91C]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  4001 00000E3E [DB1C]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  4002                                  ;                                                                          ;
  4003                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4004                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4005                                  
  4006                                          ;short_addr  _CPMFUNC			    ; 29     1D
  4007                                          ;short_addr  _CPMFUNC			    ; 30     1E
  4008                                  
  4009                                  ; 08/07/2018 - Retro DOS v3.0
  4010                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4011                                  
  4012 00000E40 [1917]                  	short_addr  NO_OP			    ; 29     1D
  4013 00000E42 [1917]                  	short_addr  NO_OP			    ; 30     1E
  4014                                  
  4015                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4016                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4017                                  ;                                                                          ;
  4018 00000E44 [1F1D]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  4019                                  ;                                                                          ;
  4020                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4021                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4022                                          ;short_addr _CPMFUNC			    ; 32     20
  4023                                  
  4024                                  ; 08/07/2018 - Retro DOS v3.0
  4025                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4026                                  
  4027 00000E46 [1917]                  	short_addr  NO_OP			    ; 32     20
  4028                                  
  4029 00000E48 [742C]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  4030 00000E4A [792C]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  4031 00000E4C [CD24]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  4032 00000E4E [A024]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  4033                                  
  4034                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  4035                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  4036                                  
  4037                                  ; Extended Functions
  4038 00000E50 [6E1C]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  4039                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4040                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4041                                  ;                                                                          ;
  4042 00000E52 [381E]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  4043                                  ;                                                                          ;
  4044                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4045                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4046 00000E54 [652C]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  4047 00000E56 [602C]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  4048 00000E58 [CE1C]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  4049 00000E5A [2118]                          short_addr  _$GET_DATE                      ; 42     2A
  4050 00000E5C [3E18]                          short_addr  _$SET_DATE                      ; 43     2B
  4051 00000E5E [5E18]                          short_addr  _$GET_TIME                      ; 44     2C
  4052 00000E60 [6F18]                          short_addr  _$SET_TIME                      ; 45     2D
  4053 00000E62 [1C1A]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  4054                                  
  4055                                  ; Extended functionality group
  4056 00000E64 [281C]                          short_addr  _$GET_DMA                       ; 47     2F
  4057 00000E66 [FE19]                          short_addr  _$GET_VERSION                   ; 48     30
  4058 00000E68 [7064]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  4059                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4060                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4061                                  ;                                                                          ;
  4062 00000E6A [211D]                          short_addr  _$GET_DPB			    ; 50     32
  4063                                  ;                                                                          ;
  4064                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4065                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4066 00000E6C [5F14]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  4067 00000E6E [071D]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  4068 00000E70 [5E1C]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  4069 00000E72 [FD1B]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  4070 00000E74 [861C]                          short_addr  _$CHAR_OPER                     ; 55     37
  4071 00000E76 [231A]                          short_addr  _$INTERNATIONAL                 ; 56     38
  4072                                  ; XENIX CALLS
  4073                                  ;   Directory Group
  4074 00000E78 [522F]                          short_addr  _$MKDIR			    ; 57     39
  4075 00000E7A [A42E]                          short_addr  _$RMDIR			    ; 58     3A
  4076 00000E7C [E02E]                          short_addr  _$CHDIR			    ; 59     3B
  4077                                  ;   File Group
  4078 00000E7E [F170]                          short_addr  _$CREAT			    ; 60     3C
  4079 00000E80 [3770]                          short_addr  _$OPEN			    ; 61     3D
  4080 00000E82 [C66D]                          short_addr  _$CLOSE		 	    ; 62     3E
  4081 00000E84 [DE6E]                          short_addr  _$READ			    ; 63     3F
  4082 00000E86 [336F]                          short_addr  _$WRITE			    ; 64     40
  4083 00000E88 [4671]                          short_addr  _$UNLINK			    ; 65     41
  4084 00000E8A [386F]                          short_addr  _$LSEEK			    ; 66     42
  4085 00000E8C [FE70]                          short_addr  _$CHMOD			    ; 67     43
  4086 00000E8E [AF2F]                          short_addr  _$IOCTL			    ; 68     44
  4087 00000E90 [F26F]                          short_addr  _$DUP			    ; 69     45
  4088 00000E92 [1470]                          short_addr  _$DUP2			    ; 70     46
  4089 00000E94 [472E]                          short_addr  _$CURRENT_DIR		    ; 71     47
  4090                                  ;   Memory Group
  4091 00000E96 [5165]                          short_addr  _$ALLOC			    ; 72     48
  4092 00000E98 [6E66]                          short_addr  _$DEALLOC                       ; 73     49
  4093 00000E9A [4A66]                          short_addr  _$SETBLOCK                      ; 74     4A
  4094                                  ;   Process Group
  4095 00000E9C [E55F]                          short_addr  _$EXEC			    ; 75     4B
  4096 00000E9E [A864]                          short_addr  _$EXIT			    ; 76     4C
  4097 00000EA0 [DB5F]                          short_addr  _$WAIT			    ; 77     4D
  4098 00000EA2 [862D]                          short_addr  _$FIND_FIRST		    ; 78     4E
  4099                                  ;   Special Group
  4100 00000EA4 [DF2D]                          short_addr  _$FIND_NEXT			    ; 79     4F
  4101                                  ; SPECIAL SYSTEM GROUP
  4102                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4103                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4104                                  ;                                                                          ;
  4105 00000EA6 [5314]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  4106 00000EA8 [5914]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  4107 00000EAA [131D]                          short_addr  _$GET_IN_VARS                   ; 82     52
  4108 00000EAC [801D]                          short_addr  _$SETDPB			    ; 83     53
  4109                                  ;                                                                          ;
  4110                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4111                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4112 00000EAE [171A]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  4113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4114                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4115                                  ;                                                                          ;
  4116 00000EB0 [2A1E]                          short_addr  _$DUP_PDB                       ; 85     55
  4117                                  ;                                                                          ;
  4118                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4119                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4120 00000EB2 [6E71]                          short_addr  _$RENAME			    ; 86     56
  4121 00000EB4 [A26F]                          short_addr  _$FILE_TIMES                    ; 87     57
  4122 00000EB6 [8F66]                          short_addr  _$ALLOCOPER                     ; 88     58
  4123                                  
  4124                                  ; 08/07/2018 - Retro DOS v3.0
  4125                                  ; -------------------------------------------------------------------------;
  4126                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4127                                  
  4128                                  ; Network extention system calls
  4129 00000EB8 [AB1C]                          short_addr  _$GetExtendedError              ; 89     59
  4130 00000EBA [FB71]                          short_addr  _$CreateTempFile                ; 90     5A
  4131 00000EBC [E371]                          short_addr  _$CreateNewFile                 ; 91     5B
  4132 00000EBE [9372]                          short_addr  _$LockOper                      ; 92     5C
  4133 00000EC0 [B166]                          short_addr  _$ServerCall                    ; 93     5D
  4134 00000EC2 [0769]                          short_addr  _$UserOper                      ; 94     5E
  4135 00000EC4 [9668]                          short_addr  _$AssignOper                    ; 95     5F
  4136 00000EC6 [5F6D]                          short_addr  _$NameTrans                     ; 96     60
  4137 00000EC8 [1917]                  	short_addr  NO_OP			    ; 97     61
  4138 00000ECA [5914]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  4139                                  ; the next call is reserved for hangool sys call
  4140                                  	; 16/07/2018
  4141                                  	;short_addr  _$ECS_Call			    ; 99     63
  4142 00000ECC [1917]                  	short_addr  NO_OP			    ; 99     63
  4143                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4144                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4145                                  ;                                                                          ;
  4146 00000ECE [8614]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  4147                                  ;                                                                          ;
  4148                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4149                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4150 00000ED0 [A91A]                          short_addr  _$GetExtCntry                   ; 101    65
  4151 00000ED2 [A61B]                          short_addr  _$GetSetCdPg                    ; 102    66
  4152 00000ED4 [156E]                          short_addr  _$ExtHandle                     ; 103    67
  4153 00000ED6 [F96D]                          short_addr  _$COMMIT                        ; 104    68
  4154                                  
  4155                                  ; 08/07/2018
  4156                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  4157                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  4158                                  
  4159                                  ;	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  4160                                  ;	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  4161                                  ;	short_addr  NO_OP                           ; 107    6B   
  4162                                  ;						    ; IFS_IOCTL no longer 
  4163                                  ;						    ; supported
  4164                                  ;	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  4165                                  
  4166                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4167                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4168                                  ;                                                                          ;
  4169                                  ;ifdef ROMEXEC
  4170                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  4171                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  4172                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  4173                                  ;endif
  4174                                  ;                                                                          ;
  4175                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4176                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4177                                  
  4178                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  4179                                  
  4180                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  4181                                  
  4182                                  ; 08/07/2018 - Retro DOS v3.0
  4183                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4184                                  
  4185                                  ;	If	Installed
  4186                                  
  4187                                  align 2
  4188                                  
  4189                                  ;PUBLIC FOO
  4190                                  
  4191                                  FOO:	; LABEL WORD
  4192 00000ED8 [CB17]                          short_addr  Leave2F
  4193                                  
  4194 00000EDA [DC0E]                  DTab:	DW  DOSTable
  4195                                  
  4196                                  	;PUBLIC FOO,DTAB
  4197                                  
  4198                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  4199                                         
  4200                                  DOSTable:  ; LABEL  WORD
  4201 00000EDC 2F                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  46
  4202 00000EDD [F817]                          short_addr  DOSInstall          ;   0 install check
  4203 00000EDF [BA3A]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  4204 00000EE1 [7B1C]                          short_addr  RECSET              ;   2   RECSET
  4205 00000EE3 [F517]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  4206 00000EE5 [4B56]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  4207 00000EE7 [7B23]                          short_addr  OUTT                ;   5   OUT
  4208 00000EE9 [B858]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  4209 00000EEB [DD5D]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  4210 00000EED [743B]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  4211 00000EEF [7F5F]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  4212 00000EF1 [2D73]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  4213 00000EF3 [6438]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  4214 00000EF5 [4D38]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  4215 00000EF7 [B618]                          short_addr  DATE16              ;   13  DATE16
  4216 00000EF9 [801F]                          short_addr  Idle		;   14      empty slot
  4217 00000EFB [D15D]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  4218 00000EFD [801F]                          short_addr  Idle		;   16      empty slot
  4219 00000EFF [491F]                          short_addr  StrCpy              ;   17  StrCpy
  4220 00000F01 [611F]                          short_addr  StrLen              ;   18  StrLen
  4221 00000F03 [0F56]                          short_addr  UCase		;   19  UCase
  4222 00000F05 [795E]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  4223 00000F07 [565F]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  4224 00000F09 [1568]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  4225 00000F0B [C769]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  4226 00000F0D [0B16]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  4227 00000F0F [7469]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  4228 00000F11 [846D]                          short_addr  DriveFromText       ;   26  DriveFromText
  4229 00000F13 [5D19]                          short_addr  SETYEAR             ;   27  SETYEAR
  4230 00000F15 [F419]                          short_addr  DSUM                ;   28  DSUM
  4231 00000F17 [5119]                          short_addr  DSLIDE              ;   29  DSLIDE
  4232 00000F19 [2B1F]                          short_addr  StrCmp              ;   30  StrCmp
  4233 00000F1B [BA68]                          short_addr  InitCDS             ;   31  initcds
  4234 00000F1D [E767]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  4235 00000F1F [5F6D]                          short_addr  _$NameTrans		;   33  $NameTrans
  4236 00000F21 [4017]                          short_addr  CAL_LK              ;   34  CAL_LK
  4237 00000F23 [DF4A]                          short_addr  DEVNAME             ;   35  DEVNAME
  4238 00000F25 [801F]                          short_addr  Idle                ;   36  Idle
  4239 00000F27 [6F1F]                          short_addr  DStrLen             ;   37  DStrLen
  4240 00000F29 [0220]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  4241 00000F2B [C66D]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  4242 00000F2D [0820]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  4243 00000F2F [DE6E]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  4244 00000F31 [E11F]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  4245 00000F33 [4120]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  4246 00000F35 [3420]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  4247 00000F37 [5E20]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  4248                                          
  4249                                  	; 10/08/2018
  4250                                  	;short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  4251                                  
  4252 00000F39 [1917]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  4253                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  4254                                  
  4255                                  DOSTableEnd:  ; LABEL BYTE
  4256                                  
  4257                                  	;ENDIF
  4258                                  
  4259                                  ;============================================================================
  4260                                  ; DOSTAB.ASM, MSDOS 6.0, 1991
  4261                                  ;============================================================================
  4262                                  ; 16/07/2018 - Retro DOS v3.0
  4263                                  
  4264                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
  4265                                  
  4266                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
  4267                                  ;
  4268                                  	;PUBLIC	SysInitTable
  4269                                  
  4270                                  SysInitTable:	; label  byte
  4271 00000F3B [2600]                  	dw      SYSINITVARS			; pointer to sysinit var
  4272 00000F3D 0000                            dw      0                             	; segment
  4273 00000F3F [FD0F]                          dw      COUNTRY_CDPG		   	; pointer to country tabl
  4274 00000F41 0000                            dw      0                            	; segment of pointer
  4275                                  
  4276                                  ; DOS 3.3 F.C. 6/12/86
  4277                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
  4278                                  ;
  4279                                  	;PUBLIC	FastOpenTable
  4280                                  	;PUBLIC	FastTable		; a better name
  4281                                  	;EXTRN	FastRet:FAR		; defined in misc2.asm
  4282                                  
  4283                                  ; MSDOS 6.0
  4284                                  ;FastTable:     ;label  byte		; a better name
  4285                                  ;FastOpenTable: ;label  byte
  4286                                  ;	dw      2                       ; number of entries
  4287                                  ;	dw      FastRet			; pointer to ret instr.
  4288                                  ;	dw      0                       ; and will be modified by
  4289                                  ;	dw      FastRet			; FASTxxx when loaded in
  4290                                  ;	dw      0                       
  4291                                  
  4292                                  ;
  4293                                  ; DOS 3.3 F.C. 6/12/86
  4294                                  ;
  4295                                  
  4296                                  ;	PUBLIC	FastFlg                 ; flags
  4297                                  ;FastFlg:	;label  byte		; don't change the foll: order
  4298                                  ;FastOpenFlg:
  4299                                  ;	db	0  ; I_am    FastOpenFlg,BYTE,<0>
  4300                                  
  4301                                  ; MSDOS 3.3
  4302                                  FastTable:
  4303                                  FastOpenTable:
  4304 00000F43 0400                    	dw      4 
  4305 00000F45 [FE1F]                  	dw      FastRet
  4306 00000F47 0000                    	dw      0  ; (('FastRet' segment will be set to CS by DOSINIT))
  4307                                  
  4308                                  	;PUBLIC	FastOpen_Ext_Info
  4309                                  
  4310                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
  4311                                  ; and clusnum  which are filled by DOS 3.ncwhen calling FastOpen Insert
  4312                                  ; or filled by FastOPen when calling FastOpen Lookup
  4313                                  
  4314                                  FastOpen_Ext_Info: ;label  byte		;dirpos
  4315 00000F49 00<rep 5h>              	times	FEI.size db 0	; 5 (for MSDOS 3.3), 11 (for MSDOS 6.0)
  4316                                  
  4317                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
  4318                                  ; when calling FastOpen Lookup
  4319                                  
  4320                                  	;PUBLIC	Dir_Info_Buff
  4321                                  
  4322                                  Dir_Info_Buff:	; label  byte
  4323 00000F4E 00<rep 20h>             	times	dir_entry.size db 0 ; 32 ; segment of pointer
  4324                                  
  4325                                  ; MSDOS 3.3 (IBMDOS.COM, 1987)
  4326                                  FastFlg:
  4327                                  FastOpenFlg:
  4328 00000F6E 00                      	db	0
  4329                                  
  4330                                  	;I_am	Next_Element_Start,WORD	; save next element start offset
  4331                                  Next_Element_Start:
  4332 00000F6F 0000                    	dw	0
  4333                                  
  4334                                  	; MSDOS 6.0
  4335                                  	;I_am    Del_ExtCluster,WORD     ; for dos_delete                       
  4336                                  
  4337                                  ; 17/07/2018
  4338                                  
  4339                                  ; The following is a stack and its pointer for interrupt 2F which is uesd
  4340                                  ; by NLSFUNC.  There is no significant use of this stack, we are just trying
  4341                                  ; not to destroy the INT 21 stack saved for the user.
  4342                                  
  4343                                  	;PUBLIC	USER_SP_2F
  4344                                  
  4345                                  USER_SP_2F:	; LABEL  WORD
  4346 00000F71 [730F]                  	dw	FAKE_STACK_2F
  4347                                  
  4348                                  	;PUBLIC	Packet_Temp
  4349                                  ;Packet_Temp	label  word		; temporary packet used by readtime
  4350                                  	;PUBLIC  DOS_TEMP		; temporary word
  4351                                  ;DOS_TEMP	label  word
  4352                                  FAKE_STACK_2F:
  4353                                  	;dw	14 dup (0)
  4354 00000F73 0000<rep Ch>            	times	12 dw 0			; 12 register temporary storage
  4355                                  
  4356                                  	;PUBLIC	Hash_Temp		; temporary word
  4357                                  ;Hash_Temp	label  word              
  4358                                  	;dw	4 dup (0)		; temporary hash table during config.sys
  4359                                  
  4360                                  	;PUBLIC  SCAN_FLAG             	; flag to indicate key ALT_Q
  4361                                  SCAN_FLAG:	; label  byte
  4362 00000F8B 00                      	db	0
  4363                                  
  4364                                  ; MSDOS 3.3
  4365                                  DISK_FULL:
  4366 00000F8C 00                      	db	0
  4367                                  
  4368                                  	;PUBLIC  DATE_FLAG
  4369                                  DATE_FLAG:   	;label  word 		; flag to
  4370 00000F8D 0000                    	dw     0                	; to update the date
  4371                                  
  4372                                  FETCHI_TAG:	;label  word		; OBSOLETE - no longer used
  4373 00000F8F 0000                    	dw     0			; formerly part of IBM's piracy protection
  4374                                  
  4375                                  ; MSDOS 6.0
  4376                                  ;      PUBLIC	MSG_EXTERROR 		; for system message addr              
  4377                                  ;MSG_EXTERROR	label  DWORD                                                     
  4378                                  ;               dd     0                ; for extended error                   
  4379                                  ;               dd     0                ; for parser                           
  4380                                  ;              	dd     0                ; for critical errror                  
  4381                                  ;              	dd     0                ; for IFS                              
  4382                                  ;              	dd     0                ; for code reduction                   
  4383                                  ;
  4384                                  ;      PUBLIC  	SEQ_SECTOR              ; last sector read                     
  4385                                  ;SEQ_SECTOR    	label  DWORD                                                     
  4386                                  ;              	dd     -1                                                        
  4387                                  ;
  4388                                  ;;      I_am    ACT_PAGE,WORD,<-1>      ; active EMS page                       
  4389                                  ;	I_am    SC_SECTOR_SIZE,WORD     ; sector size for SC                 
  4390                                  ;       I_am    SC_DRIVE,BYTE           ; drive # for secondary cache        
  4391                                  ;       I_am    CurSC_DRIVE,BYTE,<-1>   ; current SC drive                   
  4392                                  ;       I_am    CurSC_SECTOR,DWORD      ; current SC starting sector         
  4393                                  ;       I_am    SC_STATUS,WORD,<0>      ; SC status word                     
  4394                                  ;       I_am    SC_FLAG,BYTE,<0>        ; SC flag                            
  4395                                  ;       I_am    AbsDskErr,WORD,<0>	; Storage for Abs dsk read/write err
  4396                                  ;
  4397                                  ;	PUBLIC 	NO_NAME_ID                                                           
  4398                                  ;NO_NAME_ID	label byte                                                           
  4399                                  ;		db   'NO NAME    '	; null media id                      
  4400                                  ;
  4401                                  ;;hkn; moved from TABLE segment in kstrin.asm
  4402                                  ;
  4403                                  ;Public	KISTR001S,KISTR001E,LOOKSIZ	; 2/17/KK
  4404                                  ;KISTR001S	label	byte		; 2/17/KK
  4405                                  ;LOOKSIZ DB	0			; 0 if byte, NZ if word	2/17/KK
  4406                                  ;KISTR001E	label	byte		; 2/17/KK
  4407                                  ;
  4408                                  ;; the nul device driver used to be part of the code.  However, since the 
  4409                                  ;; header is in the data, and the entry points are only given as an offset,
  4410                                  ;; the strategy and interrupt entry points must also be in the data now.
  4411                                  ;;
  4412                                  ;
  4413                                  ;procedure   snuldev,far
  4414                                  ;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
  4415                                  ; 	or	es:[bx.reqstat],stdon	; set done bit
  4416                                  ;entry inuldev
  4417                                  ;	ret				; must not be a return!
  4418                                  ;endproc snuldev
  4419                                  ;
  4420                                  
  4421                                  ;============================================================================
  4422                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  4423                                  ;============================================================================
  4424                                  ; 17/07/2018 - Retro DOS v3.0
  4425                                  
  4426                                  ; ----------------------------------------------------------------------------
  4427                                  ; BREAK   <Copyright notice and version>
  4428                                  ; ----------------------------------------------------------------------------
  4429                                  
  4430                                  ;CODSTRT EQU     $
  4431                                  
  4432                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  4433                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  4434                                  
  4435                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  4436                                  ;       module. The reason is so that the data alignments are the same in
  4437                                  ;       IBM-DOS and MS-DOS up through header.
  4438                                  
  4439                                  	;PUBLIC	HEADER
  4440                                  
  4441                                  HEADER:	; LABEL	BYTE
  4442                                          ;IF	DEBUG
  4443                                          ;DB	13,10,"Debugging DOS version "
  4444                                          ;DB	MAJOR_VERSION + "0"
  4445                                          ;DB	"."
  4446                                          ;DB	(MINOR_VERSION / 10) + "0"
  4447                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  4448                                          ;ENDIF
  4449                                  
  4450                                          ;IF	NOT IBM
  4451 00000F91 0D0A4D532D444F5320-             DB	13,10,"MS-DOS version "
  4451 00000F9A 76657273696F6E20   
  4452 00000FA2 33                              DB	MAJOR_VERSION + "0"
  4453 00000FA3 2E                              DB	"."
  4454 00000FA4 33                              DB	(MINOR_VERSION / 10) + "0"
  4455                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  4456 00000FA5 30                              DB	(MINOR_VERSION % 10) + "0"
  4457                                  
  4458                                          ;IF	HIGHMEM
  4459                                          ;DB	"H"
  4460                                          ;ENDIF
  4461                                  
  4462 00000FA6 0D0A436F7079726967-     	DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  4462 00000FAF 687420313938312C38-
  4462 00000FB8 322C38332C38342C38-
  4462 00000FC1 38204D6963726F736F-
  4462 00000FCA 667420436F72702E0D-
  4462 00000FD3 0A24               
  4463                                  	;ENDIF
  4464                                  
  4465                                  ;IF DEBUG
  4466                                  ;	DB	13,10,"$"
  4467                                  ;ENDIF
  4468                                  
  4469                                  ;include copyrigh.inc
  4470                                  
  4471                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  4472                                  	;DB	"Licensed Material - Property of Microsoft "
  4473                                  	;DB	"All rights reserved "
  4474                                  
  4475                                  ;============================================================================
  4476                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4477                                  ;============================================================================
  4478                                  ; 17/07/2018 - Retro DOS v3.0
  4479                                  
  4480                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4481                                  ;	NAME	IBMCODE
  4482                                  
  4483                                  ;BREAK <NullDev -- Driver for null device>
  4484                                  
  4485                                  ; ROMDOS note:
  4486                                  ;	NUL device driver used to be here, but it was removed and placed in
  4487                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4488                                  ;	header, which is also in DOSDATA.
  4489                                  
  4490                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4491                                  
  4492                                  ;Public MSC001S,MSC001E
  4493                                  ;MSC001S label byte
  4494                                  	;IF	IBM
  4495                                  ; Codes returned by BIOS
  4496                                  ERRIN:
  4497 00000FD5 02                      	DB	2			; NO RESPONSE
  4498 00000FD6 06                      	DB	6			; SEEK FAILURE
  4499 00000FD7 0C                      	DB	12			; GENERAL ERROR
  4500 00000FD8 04                      	DB	4			; BAD CRC
  4501 00000FD9 08                      	DB	8			; SECTOR NOT FOUND
  4502 00000FDA 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4503                                  ERROUT:
  4504                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4505 00000FDB 80                      	DB	80H			; NO RESPONSE
  4506 00000FDC 40                      	DB	40H			; Seek failure
  4507 00000FDD 02                      	DB	2			; Address Mark not found
  4508 00000FDE 10                      	DB	10H			; BAD CRC
  4509 00000FDF 04                      	DB	4			; SECTOR NOT FOUND
  4510 00000FE0 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4511                                  
  4512                                  NUMERR	EQU	$-ERROUT
  4513                                  	;ENDIF
  4514                                  ;MSC001E label byte
  4515                                  
  4516                                  ;============================================================================
  4517                                  ; DOSMES.INC (MSDOS 3.3, 1987)
  4518                                  ;============================================================================
  4519                                  ; 17/07/2018 - Retro DOS v3.0
  4520                                  
  4521                                  ;TABLE	SEGMENT BYTE PUBLIC 'TABLE'
  4522                                  
  4523                                  ; The international table(s). Used for DOS 3.x  (x < 3)
  4524                                  ; This is simply a sequence of tables of the following form:
  4525                                  ;
  4526                                  ; Offset
  4527                                  ;		BYTE  Size of this table excluding this byte and the next
  4528                                  ;		WORD  Country code represented by this table
  4529                                  ;			A sequence of n bytes, where n is the number specified
  4530                                  ;			by the first byte above and is not > internat_block_max,
  4531                                  ;			in the correct order for being returned by the
  4532                                  ;			INTERNATIONAL call as follows:
  4533                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  4534                                  ;		5 BYTE	Currency symbol null terminated
  4535                                  ;		2 BYTE	thousands separator null terminated
  4536                                  ;		2 BYTE	Decimal point null terminated
  4537                                  ;		2 BYTE	Date separator null terminated
  4538                                  ;		2 BYTE	Time separator null terminated
  4539                                  ;		1 BYTE	Bit field.  Currency format.
  4540                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  4541                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  4542                                  ;			Bit 2.	=1 imbedded at decimal point, & no spaces;
  4543                                  ;		1 BYTE	No. of significant decimal digits in currency
  4544                                  ;		1 BYTE	Bit field.  Time format.
  4545                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  4546                                  ;		WORD	Segment offset for address of case conversion routine
  4547                                  ;		WORD	RESERVED. Filled in by DOS. Segment value for above routine
  4548                                  ;		2 BYTE	Data list separator null terminated.
  4549                                  ;		   NOTE: The segment part of the DWORD Map_call is set
  4550                                  ;			by the INTERNATIONAL call. Do not try to initialize
  4551                                  ;			it to anything meaningful.
  4552                                  ;
  4553                                  ; The list of tables is terminated by putting a byte of -1 after the last
  4554                                  ;	table (a table with length -1).
  4555                                  
  4556                                  	; PUBLIC  international_table
  4557                                  
  4558                                  ; Offset 0F95h in IBMDOS.COM (MSDOS 3.3), 1987
  4559                                  
  4560                                  international_table:	; LABEL BYTE
  4561                                  
  4562 00000FE1 18                      	DB 	INTERNAT_BLOCK.size  ; = 24 ; Size in bytes of this table
  4563 00000FE2 0100                    	DW 	1		; Country code
  4564                                  USTABLE:
  4565 00000FE4 0000                    	dw	0		; 0-USA, 1-EUR, 2-JAP
  4566 00000FE6 2400000000              	db	'$',0,0,0,0	; Currency Symbol 5 bytes
  4567 00000FEB 2C00                    	db	',',0		; Thousands separator 2 bytes
  4568 00000FED 2E00                    	db	'.',0		; Decimal separator 2 bytes
  4569 00000FEF 2D00                    	db	'-',0		; Date separator 2 bytes
  4570 00000FF1 3A00                    	db	':',0		; Time separator 2 bytes
  4571 00000FF3 00                      	db	0		; Bit values
  4572                                                                 	;   Bit 0 = 0 if currency symbol first
  4573                                                                 	;         = 1 if currency symbol last
  4574                                                                 	;   Bit 1 = 0 if No space after currency symbol
  4575                                                                 	;         = 1 if space after currency symbol
  4576 00000FF4 02                      	db	2		; Number of places after currency dec point
  4577 00000FF5 00                      	db	0		; if 24 hour time, 0 if 12 hour time
  4578 00000FF6 [FB17]                  	dw	MAP_CASE	; Address of case mapping call (DWORD)
  4579 00000FF8 0000                            dw	0		; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  4580                                  				;  in pieces.
  4581 00000FFA 2C00                    	db	',',0		; Data list separator character
  4582                                  
  4583                                  ;	Tables for the IBM PC character set follow. The values
  4584                                  ;	associated with some of the currency symbols may change with
  4585                                  ;	other character sets. You may wish to add or delete country
  4586                                  ;	entries. NOTE: It is not a mistake that the JAPANESE entry
  4587                                  ;	has different currency symbols for the KANJI and
  4588                                  ;	non-KANJI versions.
  4589                                  	
  4590 00000FFC FF                      	DB	-1		; end of table
  4591                                  
  4592                                  ; The following table is used for DOS 3.3
  4593                                  ;DOS country and code page information is defined here for DOS 3.3.
  4594                                  ;The initial value for ccDosCountry is 1 (USA).
  4595                                  ;The initial value for ccDosCodepage is 850.
  4596                                  ;
  4597                                  ;
  4598                                  	;PUBLIC  COUNTRY_CDPG,UCASE_TAB,FILE_UCASE_TAB
  4599                                  	;PUBLIC  FILE_CHAR_TAB
  4600                                  
  4601                                  ; country and code page infomation
  4602                                  
  4603                                  COUNTRY_CDPG:	; label  byte
  4604 00000FFD 0000000000000000        	db	0,0,0,0,0,0,0,0		; reserved words
  4605 00001005 5C434F554E5452592E-     	db	'\COUNTRY.SYS',0	; path name of country.sys
  4605 0000100E 53595300           
  4606 00001012 00<rep 33h>             	times	51 db 0
  4607 00001045 B501                    	dw	437			; system code page id
  4608 00001047 0500                    	dw	5			; number of entries
  4609 00001049 02                      	db	SetUcase		; Ucase type
  4610 0000104A [8610]                  	dw	UCASE_TAB		; pointer to upper case table
  4611 0000104C 0000                    	dw	0			; segment of poiter
  4612 0000104E 04                      	db	SetUcaseFile		; Ucase file char type
  4613 0000104F [0811]                  	dw	FILE_UCASE_TAB		; pointer to file upper case table
  4614 00001051 0000                    	dw	0			; segment of poiter
  4615 00001053 05                      	db	SetFileList		; valid file chars type
  4616 00001054 [8A11]                  	dw	FILE_CHAR_TAB		; pointer to valid file char tab
  4617 00001056 0000                    	dw	0			; segment of poiter
  4618 00001058 06                      	db	SetCollate		; collate type
  4619 00001059 [BA11]                  	dw	COLLATE_TAB		; pointer to collate table
  4620 0000105B 0000                    	dw	0			; segment of pointer
  4621 0000105D 01                      	db	SetCountryInfo		; country info type
  4622 0000105E 2600                    	dw	NEW_COUNTRY_SIZE	; extended country info size
  4623 00001060 0100                    	dw	1			; USA country id
  4624 00001062 B501                    	dw	437			; USA system code page id
  4625 00001064 0000                    	dw	0			; date format
  4626 00001066 2400000000              	db	'$',0,0,0,0		; currency symbol
  4627 0000106B 2C00                    	db	',',0			; thousand separator
  4628 0000106D 2E00                    	db	'.',0			; decimal separator
  4629 0000106F 2D00                    	db	'-',0			; date separator
  4630 00001071 3A00                    	db	':',0			; time separator
  4631 00001073 00                      	db	0			; currency format flag
  4632 00001074 02                      	db	2			; # of disgit in currency
  4633 00001075 00                      	db	0			; time format
  4634 00001076 [FB17]                  	dw	MAP_CASE		;mono case routine entry point
  4635 00001078 0000                    	dw	0			; segment of entry point
  4636 0000107A 2C00                    	db	',',0			; data list separator
  4637 0000107C 000000000000000000-     	dw	0,0,0,0,0		; reserved
  4637 00001085 00                 
  4638                                  
  4639                                  ; upper case table
  4640                                  
  4641                                  UCASE_TAB: 	; label   byte
  4642 00001086 8000                    	dw	128
  4643 00001088 809A45418E418F80        	db	128,154,069,065,142,065,143,128
  4644 00001090 4545454949498E8F        	db	069,069,069,073,073,073,142,143
  4645 00001098 9092924F994F5555        	db	144,146,146,079,153,079,085,085
  4646 000010A0 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
  4647 000010A8 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
  4648 000010B0 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
  4649 000010B8 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4650 000010C0 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4651 000010C8 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4652 000010D0 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4653 000010D8 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4654 000010E0 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4655 000010E8 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
  4656 000010F0 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4657 000010F8 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4658 00001100 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4659                                  
  4660                                  ; file upper case table
  4661                                  
  4662                                  FILE_UCASE_TAB: ; label  byte
  4663 00001108 8000                    	dw	128
  4664 0000110A 809A45418E418F80        	db	128,154,069,065,142,065,143,128
  4665 00001112 4545454949498E8F        	db	069,069,069,073,073,073,142,143
  4666 0000111A 9092924F994F5555        	db	144,146,146,079,153,079,085,085
  4667 00001122 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
  4668 0000112A 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
  4669 00001132 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
  4670 0000113A B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4671 00001142 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4672 0000114A C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4673 00001152 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4674 0000115A D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4675 00001162 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4676 0000116A E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
  4677 00001172 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4678 0000117A F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4679 00001182 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4680                                  
  4681                                  ; file char list
  4682                                  
  4683                                  FILE_CHAR_TAB:	; label  byte
  4684 0000118A 1600                    	dw	22				; length
  4685 0000118C 0100FF                  	db	1,0,255 			; include all
  4686 0000118F 000020                  	db	0,0,20h 			; exclude 0 - 20h
  4687 00001192 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
  4687 0000119B 7C3C3E2B3D3B2C     
  4688                                  	;db	24 dup (?)			; reserved
  4689 000011A2 00<rep 18h>             	times	24 db 0
  4690                                  
  4691                                  ; collate table
  4692                                  
  4693                                  COLLATE_TAB:	; label   byte
  4694 000011BA 0001                    	dw	256
  4695 000011BC 0001020304050607        	db	0,1,2,3,4,5,6,7
  4696 000011C4 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
  4697 000011CC 1011121314151617        	db	16,17,18,19,20,21,22,23
  4698 000011D4 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
  4699 000011DC 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
  4700 000011E4 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
  4701 000011EC 3031323334353637        	db	"0","1","2","3","4","5","6","7"
  4702 000011F4 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
  4703 000011FC 4041424344454647        	db	"@","A","B","C","D","E","F","G"
  4704 00001204 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
  4705 0000120C 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
  4706 00001214 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
  4707 0000121C 6041424344454647        	db	"`","A","B","C","D","E","F","G"
  4708 00001224 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
  4709 0000122C 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
  4710 00001234 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
  4711 0000123C 4355454141414143        	db	"C","U","E","A","A","A","A","C"
  4712 00001244 4545454949494141        	db	"E","E","E","I","I","I","A","A"
  4713 0000124C 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
  4714 00001254 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
  4715 0000125C 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
  4716 00001264 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
  4717 0000126C B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4718 00001274 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4719 0000127C C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4720 00001284 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4721 0000128C D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4722 00001294 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4723 0000129C E053                    	db	224,"S"
  4724 0000129E E2E3E4E5E6E7            	db	226,227,228,229,230,231
  4725 000012A4 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4726 000012AC F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4727 000012B4 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4728                                  
  4729                                  ;include divmes.inc
  4730                                  
  4731                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  4732                                  	;PUBLIC	DIVMES
  4733                                  
  4734 000012BC 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  4734 000012C5 6F766572666C6F770D-
  4734 000012CE 0A                 
  4735                                  
  4736                                  	;PUBLIC	DivMesLen
  4737                                  DivMesLen:
  4738 000012CF 1300                    	DW	$-DIVMES	; Length of the above message in bytes
  4739                                  
  4740                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  4741                                  
  4742                                  ; The following two tables implement the current buffered input editing
  4743                                  ; routines. The tables are pairwise associated in reverse order for ease
  4744                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  4745                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  4746                                  
  4747                                  	;PUBLIC	CANCHAR
  4748                                  CANCHAR:
  4749 000012D1 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  4750                                  	
  4751                                  	;PUBLIC	ESCCHAR
  4752                                  ESCCHAR:
  4753 000012D2 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  4754                                  	
  4755                                  	;IF	NOT Rainbow
  4756                                  
  4757                                  ESCTAB:	; LABEL BYTE
  4758                                  
  4759                                  	;IF	IBM
  4760 000012D3 40                      	DB	64		; Ctrl-Z - F6
  4761 000012D4 4D                      	DB	77		; Copy one char - -->
  4762 000012D5 3B                      	DB	59		; Copy one char - F1
  4763 000012D6 53                      	DB	83		; Skip one char - DEL
  4764 000012D7 3C                      	DB	60		; Copy to char - F2
  4765 000012D8 3E                      	DB	62		; Skip to char - F4
  4766 000012D9 3D                      	DB	61		; Copy line - F3
  4767 000012DA 3D                      	DB	61		; Kill line (no change to template ) - Not used
  4768 000012DB 3F                      	DB	63		; Reedit line (new template) - F5
  4769 000012DC 4B                      	DB	75		; Backspace - <--
  4770 000012DD 52                      	DB	82		; Enter insert mode - INS (toggle)
  4771 000012DE 52                      	DB	82		; Exit insert mode - INS (toggle)
  4772 000012DF 41                      	DB	65		; Escape character - F7
  4773 000012E0 41                      	DB	65		; End of table
  4774                                  	;ENDIF
  4775                                  
  4776                                  ESCEND: ; LABEL BYTE
  4777                                  
  4778                                  ESCTABLEN EQU ESCEND-ESCTAB
  4779                                  
  4780                                  ESCFUNC: ; LABEL WORD
  4781                                  	
  4782 000012E1 [3621]                  	short_addr  GETCH	; Ignore the escape sequence
  4783 000012E3 [2322]                  	short_addr  TWOESC
  4784 000012E5 [AB22]                  	short_addr  EXITINS
  4785 000012E7 [AB22]                  	short_addr  ENTERINS
  4786 000012E9 [AD21]                  	short_addr  BACKSP
  4787 000012EB [9722]                  	short_addr  REEDIT
  4788 000012ED [9A21]                  	short_addr  KILNEW
  4789 000012EF [2A22]                  	short_addr  COPYLIN
  4790 000012F1 [5D22]                  	short_addr  SKIPSTR
  4791 000012F3 [3022]                  	short_addr  COPYSTR
  4792 000012F5 [5322]                  	short_addr  SKIPONE
  4793 000012F7 [3522]                  	short_addr  COPYONE
  4794 000012F9 [3522]                  	short_addr  COPYONE
  4795 000012FB [B322]                  	short_addr  CTRLZ
  4796                                  
  4797                                  	;ENDIF
  4798                                  
  4799                                  ;TABLE	ENDS
  4800                                  
  4801                                  ; 17/07/2018
  4802                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
  4803                                  
  4804                                  ;CRTERRTAB: ; 19/07/2018	
  4805                                  ;	db	0,5,52h,50h,3,5,20h
  4806                                  
  4807                                  ; 08/08/2018
  4808                                  
  4809                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
  4810 000012FD 00                      	DB	0			; none
  4811 000012FE 05                      	DB	error_access_denied	; MakeNode error 1
  4812 000012FF 52                      	DB	error_cannot_make	; MakeNode error 2
  4813 00001300 50                      	DB	error_file_exists	; MakeNode error 3
  4814 00001301 03                      	DB	error_path_not_found	; MakeNode error 4
  4815 00001302 05                      	DB	error_access_denied	; MakeNode error 5
  4816 00001303 20                      	DB	error_sharing_violation ; MakeNode error 6
  4817                                  	; MSDOS 6.0
  4818                                  	;DB	error_file_not_found	; MakeNode error 7
  4819                                  
  4820                                  ;============================================================================
  4821                                  ; DEV.ASM (MSDOS 6.0, 1987)
  4822                                  ;============================================================================
  4823                                  ; 17/07/2018 - Retro DOS v3.0
  4824                                  
  4825                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
  4826                                  
  4827                                  ;Public DEV001S, DEV001E 		; Pathgen labels
  4828                                  ;DEV001s:
  4829                                  ;		length of packets
  4830 00001304 160E160D0F0E            LenTab:		DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
  4831                                  ;LenTab:	db	22,14,22,13,15,14
  4832                                  
  4833                                  ;	       Error Function
  4834                                  
  4835                                  CmdTab:
  4836 0000130A 8604                    	DB	86h, DEVRD	; 0 input
  4837 0000130C 8605                    	DB	86h, DEVRDND	; 1 input status
  4838 0000130E 8708                    	DB	87h, DEVWRT	; 2 output
  4839 00001310 870A                    	DB	87h, DEVOST	; 3 output status
  4840 00001312 8607                    	DB	86h, DEVIFL	; 4 input flush
  4841 00001314 8605                    	DB	86H, DEVRDND	; 5 input status with system WAIT
  4842                                  
  4843                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
  4844                                  
  4845                                  ;CmdTab:
  4846                                  ;	db	86h, 4
  4847                                  ;	db	86h, 5
  4848                                  ;	db	87h, 8
  4849                                  ;	db	87h, 10
  4850                                  ;	db	86h, 7
  4851                                  ;	db	86h, 5
  4852                                  
  4853                                  ;DEV001E:
  4854                                  
  4855                                  ;============================================================================
  4856                                  ; FCB.ASM (MSDOS 6.0, 1987)
  4857                                  ;============================================================================
  4858                                  ; 17/07/2018 - Retro DOS v3.0
  4859                                  
  4860                                  ; Character type table for file name scanning
  4861                                  ; Table provides a mapping of characters to validity bits.
  4862                                  ; Four bits are provided for each character.  Values 7Dh and above
  4863                                  ; have all bits set, so that part of the table is chopped off, and
  4864                                  ; the translation routine is responsible for screening these values.
  4865                                  ; The bit values are defined in DOSSYM.INC
  4866                                  
  4867                                  ;	      ; ^A and NUL
  4868                                  ;CharType:
  4869                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4870                                  ;
  4871                                  ;	      ; ^C and ^B
  4872                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4873                                  ;
  4874                                  ;	      ; ^E and ^D
  4875                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4876                                  ;
  4877                                  ;	      ; ^G and ^F
  4878                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4879                                  ;
  4880                                  ;	      ; TAB and BS
  4881                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4882                                  ;
  4883                                  ;	      ; ^K and ^J
  4884                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4885                                  ;
  4886                                  ;	      ; ^M and ^L
  4887                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4888                                  ;
  4889                                  ;	      ; ^O and ^N
  4890                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4891                                  ;
  4892                                  ;	      ; ^Q and ^P
  4893                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4894                                  ;
  4895                                  ;	      ; ^S and ^R
  4896                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4897                                  ;
  4898                                  ;	      ; ^U and ^T
  4899                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4900                                  ;
  4901                                  ;	      ; ^W and ^V
  4902                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4903                                  ;
  4904                                  ;	      ; ^Y and ^X
  4905                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4906                                  ;
  4907                                  ;	      ; ESC and ^Z
  4908                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4909                                  ;
  4910                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4912                                  ;
  4913                                  ;	      ; ^_ and ^^
  4914                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4915                                  ;
  4916                                  ;	      ; ! and SPACE
  4917                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
  4918                                  ;
  4919                                  ;	      ; # and "
  4920                                  ;	 db   LOW (NOT FFCB+FCHK)
  4921                                  ;
  4922                                  ;	      ; $ - )
  4923                                  ;	 db   3 dup (0FFh)
  4924                                  ;
  4925                                  ;	      ; + and *
  4926                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
  4927                                  ;
  4928                                  ;	      ; - and '
  4929                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
  4930                                  ;
  4931                                  ;	      ; / and .
  4932                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
  4933                                  ;
  4934                                  ;	      ; 0 - 9
  4935                                  ;	 db   5 dup (0FFh)
  4936                                  ;
  4937                                  ;	      ; ; and :
  4938                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
  4939                                  ;
  4940                                  ;	      ; = and <
  4941                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
  4942                                  ;
  4943                                  ;	      ; ? and >
  4944                                  ;	 db   NOT FFCB+FCHK+FDELIM
  4945                                  ;
  4946                                  ;	      ; A - Z
  4947                                  ;	 db   13 dup (0FFh)
  4948                                  ;
  4949                                  ;	      ; \ and [
  4950                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
  4951                                  ;
  4952                                  ;	      ; ^ and ]
  4953                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4954                                  ;
  4955                                  ;	      ; _ - {
  4956                                  ;	 db   15 dup (0FFh)
  4957                                  ;
  4958                                  ;	      ; } and |
  4959                                  ;	 db   NOT FFCB+FCHK+FDELIM
  4960                                  
  4961                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
  4962                                  ;					; character in the table
  4963                                  
  4964                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
  4965                                  
  4966                                  CharType:
  4967 00001316 F6F6F6F6F6F6F6F6                db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  4968 0000131E F6F0F6F6F6F6F6F6        	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  4969 00001326 F6F6F6F6F6F6F6F6        	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  4970 0000132E F6F6F6F6F6F6F6F6        	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  4971 00001336 F8FFF6FFFFFFFFFF        	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
  4972 0000133E FFFFFFF4F4FFFEF6        	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
  4973 00001346 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4974 0000134E FFFFF4F4F4F4F4FF        	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
  4975 00001356 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4976 0000135E FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4977 00001366 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4978 0000136E FFFFFFF6F6F6FFFF        	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
  4979 00001376 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4980 0000137E FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4981 00001386 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4982 0000138E FFFFFFFFF4FFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
  4983 00001396 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4984 0000139E FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4985 000013A6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4986 000013AE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4987 000013B6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4988 000013BE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4989 000013C6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4990 000013CE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4991 000013D6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4992 000013DE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4993 000013E6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4994 000013EE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4995 000013F6 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4996 000013FE FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4997 00001406 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4998 0000140E FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  4999                                  
  5000                                  ; 02/08/2018 - Retro DOS v3.0
  5001                                  ; DOSTAB.ASM - MSDOS 6.0 - 1991
  5002                                  
  5003                                  ; Offset 13CAh of IBMDOS.COM (MSDOS 3.3), 1987
  5004                                  
  5005 00001416 0000                    exec_init_SP:	dw 0
  5006 00001418 0000                    exec_init_SS:	dw 0
  5007 0000141A 0000                    exec_init_IP:	dw 0
  5008 0000141C 0000                    exec_init_CS:	dw 0
  5009                                  
  5010 0000141E 0000                    exec_signature:	dw 0	; must contain 4D5A  (yay zibo!)
  5011 00001420 0000                    exec_len_mod_512: dw 0	; low 9 bits of length
  5012 00001422 0000                    exec_pages:	dw 0	; number of 512b pages in file
  5013 00001424 0000                    exec_rle_count:	dw 0	; count of reloc entries
  5014 00001426 0000                    exec_par_dir:	dw 0	; number of paragraphs before image
  5015 00001428 0000                    exec_min_BSS:	dw 0	; minimum number of para of BSS
  5016 0000142A 0000                    exec_max_BSS:	dw 0	; max number of para of BSS
  5017 0000142C 0000                    exec_SS:	dw 0	; stack of image
  5018 0000142E 0000                    exec_SP:	dw 0	; SP of image
  5019 00001430 0000                    exec_chksum:	dw 0	; checksum  of file (ignored)
  5020 00001432 0000                    exec_IP:	dw 0	; IP of entry
  5021 00001434 0000                    exec_CS:	dw 0	; CS of entry
  5022 00001436 0000                    exec_rle_table:	dw 0	; byte offset of reloc table
  5023                                  
  5024                                  Exec_Header_Len	EQU $-exec_signature
  5025                                  
  5026                                  ; 02/08/2018 - Retro DOS v3.0
  5027                                  ; SRVCALL.ASM - MSDOS 6.0 - 1991
  5028                                  ;** Server DOS call functions
  5029                                  
  5030 00001438 [3C14]                  SERVERTAB:      dw SERVER_DISP
  5031 0000143A [E466]                  SERVERLEAVE:	dw SERVERRETURN
  5032 0000143C 0B                      SERVER_DISP:	db (SERVER_DISP_END-SERVER_DISP-1)/2
  5033 0000143D [4F67]                  		dw SRV_CALL	; 0
  5034 0000143F [E566]                  		dw COMMIT_ALL	; 1
  5035 00001441 [1C67]                  		dw CLOSE_NAME	; 2
  5036 00001443 [2867]                  		dw CLOSE_UID	; 3
  5037 00001445 [2F67]                  		dw CLOSE_UID_PID ; 4
  5038 00001447 [3667]                  		dw GET_LIST	; 5
  5039 00001449 [9067]                  		dw GET_DOS_DATA	; 6
  5040 0000144B [B467]                  		dw SPOOL_OPER	; 7
  5041 0000144D [B467]                  		dw SPOOL_OPER	; 8
  5042 0000144F [B467]                  		dw SPOOL_OPER	; 9
  5043 00001451 [C367]                  		dw _$SetExtendedError ; 10
  5044                                  SERVER_DISP_END:
  5045                                  
  5046                                  ;============================================================================
  5047                                  ; MSCODE.ASM
  5048                                  ;============================================================================
  5049                                  
  5050                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  5051                                  ; 03/03/2018
  5052                                  
  5053                                  ;
  5054                                  ; MSCODE.ASM -- MSDOS code
  5055                                  ;
  5056                                  
  5057                                  ;INCLUDE DOSSEG.ASM
  5058                                  ;INCLUDE STDSW.ASM
  5059                                  
  5060                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  5061                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5062                                  
  5063                                  ;.xcref
  5064                                  ;INCLUDE DOSSYM.ASM
  5065                                  ;INCLUDE DEVSYM.ASM
  5066                                  ;.cref
  5067                                  ;.list
  5068                                  
  5069                                  ;IFNDEF  KANJI
  5070                                  ;KANJI   EQU     0       ; FALSE
  5071                                  ;ENDIF
  5072                                  
  5073                                  ;IFNDEF  IBM
  5074                                  ;IBM     EQU     0
  5075                                  ;ENDIF
  5076                                  
  5077                                  ;IFNDEF  HIGHMEM
  5078                                  ;HIGHMEM  EQU     0
  5079                                  ;ENDIF
  5080                                  
  5081                                          ;i_need  USER_SP,WORD
  5082                                          ;i_need  USER_SS,WORD
  5083                                          ;i_need  SAVEDS,WORD
  5084                                          ;i_need  SAVEBX,WORD
  5085                                          ;i_need  INDOS,BYTE
  5086                                          ;i_need  NSP,WORD
  5087                                          ;i_need  NSS,WORD
  5088                                          ;i_need  CURRENTPDB,WORD
  5089                                          ;i_need  AUXSTACK,BYTE
  5090                                          ;i_need  CONSWAP,BYTE
  5091                                          ;i_need  IDLEINT,BYTE
  5092                                          ;i_need  NOSETDIR,BYTE
  5093                                          ;i_need  ERRORMODE,BYTE
  5094                                          ;i_need  IOSTACK,BYTE
  5095                                          ;i_need  WPERR,BYTE
  5096                                          ;i_need  DSKSTACK,BYTE
  5097                                          ;i_need  CNTCFLAG,BYTE
  5098                                          ;i_need  LEAVEADDR,WORD
  5099                                          ;i_need  NULLDEVPT,DWORD
  5100                                  
  5101                                          ;IF NOT IBM
  5102                                          ;i_need  OEM_HANDLER,DWORD
  5103                                          ;ENDIF
  5104                                  
  5105                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  5106                                  
  5107                                  ;============================================================================
  5108                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  5109                                  ;============================================================================
  5110                                  ; 11/07/2018 - Retro DOS v3.0
  5111                                  
  5112                                  ; 18/07/2018
  5113                                  
  5114                                  ; The following two routines are dispatched to directly with ints disabled
  5115                                  ; immediately after the int 21h entry.	no DIS state is set.
  5116                                  
  5117                                  ; ---------------------------------------------------------------------------
  5118                                  ; $Set_current_PDB takes BX and sets it to be the current process
  5119                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  5120                                  ;
  5121                                         ;procedure   $SET_CURRENT_PDB,NEAR
  5122                                  _$SET_CURRENT_PDB:
  5123                                          ;ASSUME	DS:NOTHING,SS:NOTHING
  5124 00001453 2E891E[DE02]                    MOV     [CS:CurrentPDB],BX ; 12/03/2018
  5125 00001458 CF                      	iret ; 08/07/2018 - Retro DOS v3.0
  5126                                  ;$SET_CURRENT_PDB    ENDP
  5127                                  
  5128                                  ; ---------------------------------------------------------------------------
  5129                                  ; $get_current_PDB returns in BX the current process
  5130                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  5131                                  ;
  5132                                          ;procedure $GET_CURRENT_PDB,NEAR
  5133                                  _$GET_CURRENT_PDB:
  5134                                          ;ASSUME	DS:NOTHING,SS:NOTHING
  5135 00001459 2E8B1E[DE02]            	mov	BX,[CS:CurrentPDB] ; 11/07/2018
  5136 0000145E CF                      	iret ; 08/07/2018 - Retro DOS v3.0
  5137                                  ;$GET_CURRENT_PDB    ENDP
  5138                                  ; ---------------------------------------------------------------------------
  5139                                  
  5140                                  ; 11/07/2018 - Retro DOS v3.0
  5141                                  
  5142                                  ;BREAK <$Set_CTRL_C_Trapping -- En/Disable ^C check in dispatcher>
  5143                                  
  5144                                  _$SET_CTRL_C_TRAPPING:
  5145                                  
  5146                                  ; Inputs:
  5147                                  ;       AL = 0 read ^C status
  5148                                  ;       AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  5149                                  ;	AL = 2 Set ^C status to contents of DL.	Output is old state.
  5150                                  ;	     (MSDISP.ASM,MSDOS 6.0, 1991)
  5151                                  ; Function:
  5152                                  ;       Enable disable ^C checking in dispatcher
  5153                                  ; Outputs:
  5154                                  ;       If AL = 0 then DL = 0/1 for ^C off/on
  5155                                  
  5156                                  	; 08/07/2018 - Retro DOS v3.0
  5157                                  
  5158 0000145F 08C0                            OR      AL,AL
  5159 00001461 7506                            JNZ     SHORT CTRL_C_set
  5160                                  
  5161                                  	; 11/07/2018
  5162 00001463 2E8A16[E502]            	mov	dl,[CS:CNTCFLAG]
  5163 00001468 CF                      	iret
  5164                                  
  5165                                  CTRL_C_set:
  5166                                  	; 08/07/2018
  5167 00001469 3C02                    	cmp	al,2
  5168 0000146B 7716                    	ja	short bad_val
  5169 0000146D 740B                    	je	short scct_3
  5170                                  
  5171 0000146F 52                      	push    dx
  5172 00001470 80E201                  	and     dl,1
  5173 00001473 2E8816[E502]            	mov     [cs:CNTCFLAG],dl
  5174 00001478 5A                      	pop     dx
  5175 00001479 CF                      	iret
  5176                                  
  5177                                  scct_3:
  5178 0000147A 80E201                  	and	dl,1
  5179 0000147D 2E8616[E502]                    xchg	dl,[CS:CNTCFLAG]
  5180 00001482 CF                              iret
  5181                                  
  5182                                  bad_val:
  5183 00001483 B0FF                    	MOV	AL,0FFH
  5184 00001485 CF                      	iret
  5185                                  
  5186                                  ; 11/07/2018
  5187                                  
  5188                                  _$SET_PRINTER_FLAG:
  5189                                  	; 08/07/2018 - Retro DOS v3.0
  5190                                  	;mov 	[cs:IOSTACK],al
  5191 00001486 2EA2[060A]              	mov	[cs:PRINTER_FLAG],al
  5192 0000148A CF                      	iret
  5193                                  
  5194                                  ; 08/07/2018 - Retro DOS v3.0
  5195                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  5196                                  
  5197                                  ; ----------------------------------------------------------------------------
  5198                                  ; BREAK   <System call entry points and dispatcher>
  5199                                  ; ----------------------------------------------------------------------------
  5200                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5201                                  
  5202                                          ;procedure   SYSTEM_CALL,NEAR
  5203                                  SYSTEM_CALL:
  5204                                  ;entry	QUIT				; INT 20H entry point
  5205                                  QUIT:
  5206                                  	;MOV	AH,0
  5207 0000148B 30E4                    	xor	ah,ah ; 08/07/2018
  5208 0000148D EB47                    	JMP     SHORT SAVREGS
  5209                                  
  5210                                  ; ---------------------------------------------------------------------------
  5211                                  
  5212                                  ;COMMAND:
  5213                                  ;	;IF	NOT IBM
  5214                                  ;       CMP	AH,SET_OEM_HANDLER
  5215                                  ;       JB      SHORT NOTOEM
  5216                                  ;	; 18/07/2018
  5217                                  ;	je	_$SET_OEM_HANDLER	
  5218                                  ;
  5219                                  ;	; 20/04/2018
  5220                                  ;       ;JMP	_$SET_OEM_HANDLER
  5221                                  ;
  5222                                  ;	; Retro DOS v2.0 - 20/04/2018
  5223                                  ;	CMP	AX, 0FFFFh
  5224                                  ;	;JNE	_$SET_OEM_HANDLER
  5225                                  ;	; 18/07/2018
  5226                                  ;	jne	DO_OEM_FUNC
  5227                                  ;
  5228                                  ;	PUSHA
  5229                                  ;	MOV     SI,RETRODOSMSG
  5230                                  ;       ;CALL	OUTMES
  5231                                  ;wrdosmsg:
  5232                                  ;	mov	ah, 0Eh
  5233                                  ;	mov	bx, 7
  5234                                  ;wrdosmsg_nxt:
  5235                                  ;	cs	lodsb
  5236                                  ;	cmp	al, '$'
  5237                                  ;	je	short wrdosmsg_ok		
  5238                                  ;	int	10h
  5239                                  ;	jmp	short wrdosmsg_nxt
  5240                                  ;wrdosmsg_ok:
  5241                                  ;	POPA
  5242                                  ;	JMP	SHORT BADCALL 
  5243                                  ;	;
  5244                                  ;NOTOEM:
  5245                                  ;	;ENDIF
  5246                                  ;
  5247                                  ;       CMP     AH,MAXCOM
  5248                                  ;       JBE     SHORT SAVREGS
  5249                                  
  5250                                  	; The system call in AH is out of the range that we know how
  5251                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  5252                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  5253                                  	; error as this may break some programs compatability.
  5254                                  
  5255                                  BADCALL:
  5256                                          ;MOV	AL,0
  5257 0000148F 30C0                    	xor	al,al ; 08/07/2018
  5258                                  ;entry	IRET
  5259                                  _IRET:
  5260 00001491 CF                              IRET
  5261                                  
  5262                                  ; ---------------------------------------------------------------------------
  5263                                  
  5264                                  ;entry	CALL_ENTRY                      ; System call entry point and dispatcher
  5265                                  CALL_ENTRY:
  5266 00001492 58                              POP     AX                      ; IP from the long call at 5
  5267 00001493 58                              POP     AX                      ; Segment from the long call at 5
  5268                                          ;POP	WORD [USER_SP]		; IP from the CALL 5
  5269 00001494 2E8F06[1E05]                    POP	WORD [CS:USER_SP] ; 12/03/2018
  5270 00001499 9C                      	PUSHF                           ; Start re-ordering the stack
  5271 0000149A FA                              CLI
  5272 0000149B 50                              PUSH    AX                      ; Save segment
  5273                                          ;PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  5274 0000149C 2EFF36[1E05]                    PUSH	WORD [CS:USER_SP] ; 12/03/2018
  5275 000014A1 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  5276 000014A4 77E9                            JA      SHORT BADCALL
  5277 000014A6 88CC                            MOV     AH,CL
  5278                                  	; 08/07/2018
  5279 000014A8 EB2C                    	jmp	short SAVREGS 
  5280                                  
  5281                                  COMMAND:
  5282                                  	; 08/07/2018 - Retro DOS v3.0
  5283                                  
  5284                                  	;IF	NOT IBM
  5285 000014AA 80FCF8                          CMP	AH,SET_OEM_HANDLER
  5286 000014AD 7221                            JB      SHORT NOTOEM
  5287                                  	; 18/07/2018
  5288 000014AF 0F845E01                	je	_$SET_OEM_HANDLER	
  5289                                  
  5290                                  	; 20/04/2018
  5291                                          ;JMP	_$SET_OEM_HANDLER
  5292                                  
  5293                                  	; Retro DOS v2.0 - 20/04/2018
  5294 000014B3 83F8FF                  	CMP	AX,0FFFFh
  5295                                  	;JNE	_$SET_OEM_HANDLER
  5296                                  	; 18/07/2018
  5297 000014B6 0F856201                	jne	DO_OEM_FUNC
  5298                                  
  5299 000014BA 60                      	PUSHA
  5300 000014BB BE[4E0C]                	MOV     SI,RETRODOSMSG
  5301                                          ;CALL	OUTMES
  5302                                  wrdosmsg:
  5303 000014BE B40E                    	mov	ah, 0Eh
  5304 000014C0 BB0700                  	mov	bx, 7
  5305                                  wrdosmsg_nxt:
  5306 000014C3 2EAC                    	cs	lodsb
  5307 000014C5 3C24                    	cmp	al, '$'
  5308 000014C7 7404                    	je	short wrdosmsg_ok		
  5309 000014C9 CD10                    	int	10h
  5310 000014CB EBF6                    	jmp	short wrdosmsg_nxt
  5311                                  wrdosmsg_ok:
  5312 000014CD 61                      	POPA
  5313 000014CE EBBF                    	JMP	SHORT BADCALL 
  5314                                  	;
  5315                                  
  5316                                  NOTOEM:
  5317                                  	;ENDIF
  5318                                  
  5319 000014D0 FA                      	cli	; 08/07/2018
  5320                                  
  5321                                  _COMMAND: ; MSDOS 3.3 (IBM)
  5322                                  
  5323 000014D1 80FC68                          CMP     AH,MAXCOM
  5324                                  	;JBE	SHORT SAVREGS
  5325 000014D4 77B9                            JA	SHORT BADCALL ; 08/07/2018
  5326                                  
  5327                                  SAVREGS:
  5328                                  	; 10/08/2018
  5329                                  	; 08/07/2018 - Retro DOS v3.0
  5330 000014D6 80FC33                  	cmp	ah,33h
  5331 000014D9 7484                    	jz	short _$SET_CTRL_C_TRAPPING
  5332 000014DB 721C                    	jb	short SaveAllRegs
  5333 000014DD 80FC64                  	cmp	ah,64h
  5334 000014E0 7717                    	ja	short SaveAllRegs
  5335 000014E2 74A2                    	jz	short _$SET_PRINTER_FLAG
  5336 000014E4 80FC51                  	cmp	ah,51h
  5337 000014E7 0F846EFF                	jz	_$GET_CURRENT_PDB
  5338 000014EB 80FC62                  	cmp	ah,62h
  5339 000014EE 0F8467FF                	jz	_$GET_CURRENT_PDB
  5340 000014F2 80FC50                  	cmp     ah,50h
  5341 000014F5 0F845AFF                	jz	_$SET_CURRENT_PDB
  5342                                  SaveAllRegs:
  5343 000014F9 E8FC00                          CALL    save_world
  5344 000014FC 2E8C1E[7E05]                    MOV	[CS:SAVEDS],DS	; 12/03/2018
  5345 00001501 2E891E[7C05]                    MOV	[CS:SAVEBX],BX	; 12/03/2018
  5346 00001506 8CCB                            MOV     BX,CS
  5347 00001508 8EDB                            MOV     DS,BX
  5348                                  ;ASSUME  DS:DOSGROUP
  5349 0000150A FE06[CF02]                      INC     BYTE [INDOS]		; Flag that we're in the DOS
  5350                                  	
  5351                                  	; 08/07/2018 - Retro DOS v3.0        
  5352 0000150E 31C0                    	xor     ax, ax
  5353 00001510 A3[EA02]                	mov     [USER_ID],ax
  5354 00001513 A1[DE02]                	mov     ax,[CurrentPDB]
  5355 00001516 A3[E802]                	mov     [PROC_ID],ax
  5356                                  
  5357 00001519 A1[1E05]                	MOV     AX,[USER_SP]
  5358 0000151C A3[8405]                        MOV     [NSP],AX
  5359 0000151F A1[2005]                        MOV     AX,[USER_SS]
  5360 00001522 A3[8205]                        MOV     [NSS],AX
  5361 00001525 58                              POP     AX
  5362 00001526 50                              PUSH    AX
  5363 00001527 8926[1E05]                      MOV     [USER_SP],SP
  5364 0000152B 8C16[2005]                      MOV     [USER_SS],SS
  5365                                  ;
  5366                                  ; save user stack in his area for later returns (possibly from EXEC)
  5367                                  ; Here comes multitasking!!!
  5368                                  ;
  5369 0000152F 8E1E[DE02]                      MOV     DS,[CurrentPDB]
  5370 00001533 89262E00                        MOV     [PDB.USER_STACK],SP
  5371 00001537 8C163000                        MOV     [PDB.USER_STACK+2],SS
  5372                                  	; 18/07/2018
  5373 0000153B 2EC606[0D05]00          	mov	byte [CS:FSHARING], 0
  5374                                  
  5375 00001541 8CCB                            MOV     BX,CS                   ; no holes here.
  5376 00001543 8ED3                            MOV     SS,BX
  5377                                  ;ASSUME  SS:DOSGROUP
  5378                                  
  5379                                  ;entry	REDISP
  5380                                  REDISP:
  5381 00001545 BC[0607]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  5382 00001548 FB                              STI                             ; Stack OK now
  5383                                  	; 08/07/2018
  5384                                          ;PUSH	CS
  5385                                          ;POP	DS
  5386 00001549 8CCB                    	mov	bx,cs
  5387 0000154B 8EDB                    	mov	ds,bx
  5388 0000154D 30FF                            XOR     BH,BH
  5389 0000154F 883E[0303]                      MOV     [CONSWAP],BH
  5390 00001553 C606[0403]01                    MOV     BYTE [IDLEINT],1
  5391 00001558 883E[F802]                      MOV     BYTE [NoSetDir],bh ; 0	; set directories on search
  5392 0000155C 883E[F602]                      mov	byte [FAILERR],bh ; 0	
  5393 00001560 88E3                    	MOV     BL,AH
  5394 00001562 D1E3                            SHL     BX,1
  5395 00001564 FC                              CLD
  5396 00001565 08E4                            OR      AH,AH
  5397 00001567 7416                            JZ      SHORT DSKROUT		; ABORT
  5398                                  
  5399                                          ;CMP	AH,12
  5400                                          ;JBE	SHORT IOROUT		; Character I/O
  5401                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  5402                                          ;JZ	SHORT IOROUT
  5403                                          ;CMP	AH,SET_CURRENT_PDB
  5404                                          ;JNZ	SHORT DSKROUT
  5405                                  
  5406                                  	; 10/08/2018
  5407 00001569 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  5408 0000156C 743D                    	jz      short DISPCALL
  5409 0000156E 80FC0C                  	cmp     ah,STD_CON_INPUT_FLUSH ; 0Ch
  5410 00001571 770C                    	ja      short DSKROUT
  5411                                  
  5412                                  IOROUT:
  5413 00001573 803E[CE02]00                    CMP     BYTE [ERRORMODE],0
  5414 00001578 7531                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  5415 0000157A BC[060A]                        MOV     SP,IOSTACK
  5416 0000157D EB2C                            JMP     SHORT DISPCALL
  5417                                  
  5418                                  DSKROUT:
  5419                                  	; 08/07/2018 - Retro DOS v3.0
  5420 0000157F A3[E602]                        mov     [USER_IN_AX],ax
  5421 00001582 C606[D102]01            	mov     byte [EXTERR_LOCUS],1	; errLOC_Unk  (Default)
  5422                                  
  5423 00001587 C606[CE02]00                    MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
  5424 0000158C C606[D002]FF                    MOV     BYTE [WPERR],-1		; error mode, so good place to
  5425                                                                          ; make sure flags are reset
  5426 00001591 50                      	push    ax
  5427 00001592 B482                    	mov     ah, 82h
  5428 00001594 CD2A                    	int     2Ah 		; Microsoft Networks 
  5429                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  5430 00001596 58                      	pop     ax
  5431 00001597 C606[0403]00            	mov     byte [IDLEINT],0
  5432                                  
  5433 0000159C BC[8608]                        MOV     SP,DSKSTACK
  5434 0000159F F606[E502]FF                    TEST    BYTE [CNTCFLAG],-1
  5435 000015A4 7405                            JZ      SHORT DISPCALL
  5436 000015A6 50                              PUSH    AX
  5437                                          ;invoke	DSKSTATCHK
  5438 000015A7 E8AE40                          CALL	DSKSTATCHK
  5439 000015AA 58                      	POP     AX
  5440                                  DISPCALL:
  5441                                  	; 08/07/2018 -Retro DOS v3.0
  5442                                  	;;;PUSH	WORD [LEAVEADDR] ; (***)
  5443                                          ;;;PUSH	WORD [CS:BX+DISPATCH]
  5444                                          ;;;;PUSH WORD [BX+DISPATCH]
  5445                                  
  5446                                  	; 11/07/2018	
  5447                                  	;mov	bx,[CS:BX+DISPATCH]
  5448 000015AB 8B9F[060E]               	mov	bx,[bx+DISPATCH] 
  5449                                  
  5450                                  	;;;MOV	BX,[SAVEBX]
  5451 000015AF 871E[7C05]              	xchg    bx,[SAVEBX]        
  5452                                  
  5453 000015B3 8E1E[7E05]              	MOV     DS,[SAVEDS]
  5454                                  ;ASSUME	DS:NOTHING
  5455                                          ;return
  5456                                  ;;;	RETN	
  5457                                  
  5458 000015B7 36FF16[7C05]            	call	word [SS:SAVEBX]
  5459                                  
  5460                                  ;entry LEAVE
  5461                                  ;;;_LEAVE:				; Exit from a system call
  5462                                  LeaveDOS: ; 18/07/2018 
  5463                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  5464 000015BC FA                      	CLI
  5465                                          ; 12/03/2018
  5466 000015BD 2EFE0E[CF02]            	DEC     BYTE [CS:INDOS]
  5467 000015C2 2E8B26[1E05]                    MOV     SP,[CS:USER_SP]
  5468 000015C7 2E8E16[2005]                    MOV     SS,[CS:USER_SS]
  5469 000015CC 89E5                    	MOV     BP,SP
  5470                                  	;MOV	[BP.user_AX],AL	
  5471                                          ;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  5472 000015CE 884600                          MOV     [BP],AL
  5473 000015D1 2EA1[8405]              	MOV     AX,[CS:NSP]
  5474 000015D5 2EA3[1E05]                      MOV     [CS:USER_SP],AX
  5475 000015D9 2EA1[8205]                      MOV     AX,[CS:NSS]
  5476 000015DD 2EA3[2005]                      MOV     [CS:USER_SS],AX
  5477 000015E1 E80100                  	CALL    restore_world
  5478                                  
  5479 000015E4 CF                              IRET
  5480                                  
  5481                                  ;SYSTEM_CALL ENDP
  5482                                  
  5483                                  ;
  5484                                  ; restore_world restores all registers ('cept SS:SP, CS:IP, flags) from
  5485                                  ; the stack prior to giving the user control
  5486                                  ;
  5487                                  
  5488                                  ; 11/07/2018 - Retro DOS v3.0
  5489                                          ;ASSUME  DS:NOTHING,ES:NOTHING
  5490                                  ;;restore_tmp DW  ?
  5491                                  ;restore_tmp: 
  5492                                  ;	dw	0
  5493                                          ;procedure restore_world,NEAR
  5494                                  restore_world:
  5495 000015E5 2E8F06[8005]                    POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
  5496 000015EA 58                              POP     AX              ; PUSH    ES
  5497 000015EB 5B                              POP     BX              ; PUSH    DS
  5498 000015EC 59                              POP     CX              ; PUSH    BP
  5499 000015ED 5A                              POP     DX              ; PUSH    DI
  5500 000015EE 5E                              POP     SI              ; PUSH    SI
  5501 000015EF 5F                              POP     DI              ; PUSH    DX
  5502 000015F0 5D                              POP     BP              ; PUSH    CX
  5503 000015F1 1F                              POP     DS              ; PUSH    BX
  5504 000015F2 07                              POP     ES              ; PUSH    AX
  5505                                  	; 07/07/2018 - Retro DOS v3.0
  5506 000015F3 2EFF26[8005]                   	jmp	word [CS:RESTORE_TMP]
  5507                                  
  5508                                  ;restore_world	ENDP
  5509                                  
  5510                                  ;
  5511                                  ; save_world saves complete registers on the stack
  5512                                  ;
  5513                                          ;procedure save_world,NEAR
  5514                                  save_world:
  5515 000015F8 2E8F06[8005]                    POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
  5516 000015FD 06                              PUSH    ES
  5517 000015FE 1E                              PUSH    DS
  5518 000015FF 55                              PUSH    BP
  5519 00001600 57                              PUSH    DI
  5520 00001601 56                              PUSH    SI
  5521 00001602 52                              PUSH    DX
  5522 00001603 51                              PUSH    CX
  5523 00001604 53                              PUSH    BX
  5524 00001605 50                              PUSH    AX
  5525                                  	; 07/07/2018 - Retro DOS v3.0
  5526 00001606 2EFF26[8005]                   	jmp	word [CS:RESTORE_TMP]
  5527                                  
  5528                                  ;save_world	ENDP
  5529                                  
  5530                                  ;
  5531                                  ; get_user_stack returns the user's stack (and hence registers) in DS:SI
  5532                                  ;
  5533                                          ;procedure get_user_stack,NEAR
  5534                                  Get_User_Stack:
  5535                                          ;LDS	SI,DWORD PTR [USER_SP]
  5536                                          ;LDS	SI,[USER_SP]
  5537 0000160B 2EC536[1E05]                    LDS	SI,[CS:USER_SP] ; 12/03/2018
  5538                                  	;return
  5539 00001610 C3                      	RETN
  5540                                  
  5541                                  ;get_user_stack  ENDP
  5542                                  
  5543                                  ; ---------------------------------------------------------------------------
  5544                                  ;
  5545                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  5546                                  ; Inputs:
  5547                                  ;	User registers, User Stack, INTS disabled
  5548                                  ;	If CALL F8, DS:DX is new handler address
  5549                                  ; Function:
  5550                                  ;	Process OEM INT 21 extensions
  5551                                  ; Outputs:
  5552                                  ;	Jumps to OEM_HANDLER if appropriate
  5553                                  ;
  5554                                  ; ---------------------------------------------------------------------------
  5555                                  
  5556                                  ;IF	NOT IBM
  5557                                  
  5558                                  _$SET_OEM_HANDLER:
  5559                                  	; 18/07/2018
  5560                                  
  5561                                  	;JNE	short DO_OEM_FUNC	; If above F8 try to jump to handler
  5562 00001611 2E8916[1400]            	MOV     [CS:OEM_HANDLER],DX	; Set Handler
  5563 00001616 2E8C1E[1600]            	MOV     [CS:OEM_HANDLER+2],DS
  5564 0000161B CF                      	IRET                            ; Quick return, Have altered no registers
  5565                                  
  5566                                  DO_OEM_FUNC:
  5567 0000161C 2E833E[1400]FF          	CMP     WORD [CS:OEM_HANDLER],-1
  5568 00001622 7503                    	JNZ     short OEM_JMP
  5569 00001624 E968FE                  	JMP     BADCALL                 ; Handler not initialized
  5570                                  
  5571                                  OEM_JMP:
  5572 00001627 2EFF2E[1400]            	JMP     FAR [CS:OEM_HANDLER]
  5573                                  
  5574                                  ;       ENDIF
  5575                                  
  5576                                  ;============================================================================
  5577                                  ; DOSTAB.ASM - MSDOS 6.0 - 1991
  5578                                  ;============================================================================
  5579                                  ; 11/07/2018 - Retro DOS v3.0
  5580                                  
  5581                                  ; the nul device driver used to be part of the code.  However, since the 
  5582                                  ; header is in the data, and the entry points are only given as an offset,
  5583                                  ; the strategy and interrupt entry points must also be in the data now.
  5584                                  ;
  5585                                  
  5586                                  ;procedure	snuldev,far
  5587                                  SNULDEV:
  5588                                  ;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
  5589                                  ; Offset 1599h in IBMDOS.COM (MSDOS 3.3), 1987
  5590                                  	;or	word [ES:BX+3],0100h
  5591 0000162C 26814F030001             	OR	word [ES:BX+SRHEAD.REQSTAT],STDON ; set done bit
  5592                                  ;entry inuldev
  5593                                  INULDEV:
  5594 00001632 CB                      	retf				; must not be a return!
  5595                                  ;endproc snuldev
  5596                                  
  5597                                  ;============================================================================
  5598                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  5599                                  ;============================================================================
  5600                                  ; 18/07/2018 - Retro DOS v3.0
  5601                                  
  5602                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  5603                                  
  5604                                  
  5605                                  ;   AbsSetup - setup for abs disk functions
  5606                                  ;----------------------------------------------------------------------------
  5607                                  
  5608                                  AbsSetup:
  5609 00001633 36FE06[CF02]            	INC	byte [SS:INDOS]		; SS override
  5610 00001638 FB                      	STI
  5611 00001639 FC                      	CLD
  5612 0000163A 1E                      	PUSH	DS
  5613 0000163B 16                      	push	ss
  5614 0000163C 1F                      	pop	ds
  5615 0000163D E89100                  	CALL	GETBP
  5616 00001640 7206                    	JC	short errdriv 		; PM. error drive ;AN000;
  5617 00001642 26C7461EFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  5618                                  errdriv:
  5619 00001648 1F                      	POP	DS
  5620 00001649 7301                    	jnc	short AbsSetup2
  5621                                  AbsSetup_retn:
  5622 0000164B C3                      	retn
  5623                                  
  5624                                  AbsSetup2:
  5625                                  	; MSDOS 6.0
  5626                                  	;				; SS override
  5627                                  	;MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  5628                                  	;CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  5629 0000164C 72FD                    	jc	short AbsSetup_retn
  5630                                  	;call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  5631                                  
  5632                                  	; MSDOS 3.3 (& MSDOS 6.0)
  5633 0000164E 1E                      	PUSH	DS
  5634 0000164F 56                      	PUSH	SI
  5635 00001650 50                      	PUSH	AX
  5636                                  
  5637 00001651 16                      	push	ss
  5638 00001652 1F                      	pop	ds
  5639                                  	
  5640 00001653 BE[6003]                	MOV	SI,OPENBUF
  5641 00001656 8804                    	MOV	[SI],AL
  5642 00001658 800441                  	ADD	BYTE [SI],"A"
  5643 0000165B C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
  5644 00001660 B80003                  	MOV	AX,0300H
  5645 00001663 F8                      	CLC
  5646 00001664 CD2A                    	INT	int_IBM 		; Will set carry if shared
  5647 00001666 58                      	POP	AX
  5648 00001667 5E                      	POP	SI
  5649 00001668 1F                      	POP	DS
  5650 00001669 73E0                    	jnc	short AbsSetup_retn
  5651                                  
  5652                                  	;mov	word [ss:EXTERR],32h
  5653 0000166B 36C706[D202]3200        	MOV	word [ss:EXTERR],error_not_supported
  5654 00001672 C3                      	retn
  5655                                  
  5656                                  ;---------------------------------------------------------------------------
  5657                                  ;
  5658                                  ; Procedure Name : ABSDRD
  5659                                  ;
  5660                                  ; Interrupt 25 handler.  Performs absolute disk read.
  5661                                  ; Inputs:	AL - 0-based drive number
  5662                                  ;		DS:BX point to destination buffer
  5663                                  ;		CX number of logical sectors to read
  5664                                  ;		DX starting  logical sector number (0-based)
  5665                                  ; Outputs:	Original flags still on stack
  5666                                  ;		Carry set
  5667                                  ;		    AH error from BIOS
  5668                                  ;		    AL same as low byte of DI from INT 24
  5669                                  ;
  5670                                  ;---------------------------------------------------------------------------
  5671                                          ;procedure   ABSDRD,FAR
  5672                                  ABSDRD:
  5673                                  	; 15/07/2018
  5674                                  ;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING
  5675 00001673 FA                              CLI
  5676                                          ;MOV	[USER_SS],SS
  5677                                          ;MOV	[USER_SP],SP
  5678                                  	; 15/03/2018
  5679 00001674 2E8C16[2005]                    MOV	[CS:USER_SS],SS
  5680 00001679 2E8926[1E05]                    MOV	[CS:USER_SP],SP        
  5681 0000167E 0E                      	PUSH    CS
  5682 0000167F 17                              POP     SS
  5683                                  ;ASSUME  SS:DOSGROUP
  5684 00001680 BC[8608]                        MOV	SP,DSKSTACK
  5685                                  
  5686                                  	;; MSDOS 2.11
  5687                                  
  5688                                          ;;;INC	BYTE [INDOS]
  5689                                          ;;INC	BYTE [SS:INDOS]
  5690                                  	;;STI
  5691                                          ;;CLD
  5692                                          ;;PUSH	ES
  5693                                          ;;PUSH	DS
  5694                                          ;;PUSH	SS
  5695                                          ;;POP	DS
  5696                                  ;;;ASSUME DS:DOSGROUP
  5697                                          ;;;invoke GETBP
  5698                                  	;;CALL	GETBP
  5699                                          ;;POP	DS
  5700                                  ;;;ASSUME DS:NOTHING
  5701                                  
  5702                                  	; 15/07/2018 - Retro DOS v3.0
  5703                                  	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
  5704 00001683 06                              PUSH    ES
  5705 00001684 E8ACFF                  	call    AbsSetup
  5706                                  	;	
  5707 00001687 721A                            JC      SHORT ILEAVE
  5708                                          ;invoke	DSKREAD
  5709 00001689 E82B2B                  	CALL	DSKREAD
  5710                                  TLEAVE:
  5711 0000168C 7415                            JZ      SHORT ILEAVE
  5712                                  
  5713                                  	; 15/07/2018 - Retro DOS v3.0
  5714                                          ;IF	IBM
  5715                                  ; Translate the error code to ancient 1.1 codes
  5716 0000168E 06                              PUSH    ES
  5717 0000168F 0E                              PUSH    CS
  5718 00001690 07                              POP     ES
  5719 00001691 30E4                            XOR     AH,AH			; Nul error code
  5720                                  	;mov	cx,6
  5721 00001693 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  5722 00001696 BF[D50F]                        MOV     DI,ERRIN		; Point to error conditions
  5723 00001699 F2AE                            REPNE   SCASB
  5724 0000169B 7504                            JNZ     SHORT LEAVECODE		; Not found
  5725                                  	;mov	ah,[ES:DI+5]
  5726 0000169D 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  5727                                  LEAVECODE:
  5728 000016A1 07                              POP     ES
  5729                                          ;ENDIF
  5730                                  
  5731 000016A2 F9                              STC
  5732                                  ILEAVE:
  5733 000016A3 07                              POP     ES
  5734 000016A4 FA                              CLI
  5735                                          ;DEC	BYTE [INDOS]
  5736                                          ;15/03/2018
  5737 000016A5 36FE0E[CF02]            	DEC	BYTE [SS:INDOS]
  5738                                  	; 15/08/2018
  5739                                          ;MOV	SS,[CS:USER_SS]
  5740                                  	;MOV	SP,[CS:USER_SP]
  5741 000016AA 368B26[1E05]            	MOV     SP,[SS:USER_SP]
  5742 000016AF 368E16[2005]                    MOV     SS,[SS:USER_SS]
  5743                                  ;ASSUME  SS:NOTHING
  5744 000016B4 FB                              STI
  5745                                          ;return
  5746 000016B5 CB                      	RETF   ; ! FAR return !
  5747                                  
  5748                                  ;ABSDRD	ENDP
  5749                                  
  5750                                  ;---------------------------------------------------------------------------
  5751                                  ;
  5752                                  ; Procedure Name : ABSDWRT
  5753                                  ;
  5754                                  ; Interrupt 26 handler.  Performs absolute disk write.
  5755                                  ; Inputs:	AL - 0-based drive number
  5756                                  ;		DS:BX point to source buffer
  5757                                  ;		CX number of logical sectors to write
  5758                                  ;		DX starting  logical sector number (0-based)
  5759                                  ; Outputs:	Original flags still on stack
  5760                                  ;		Carry set
  5761                                  ;		    AH error from BIOS
  5762                                  ;		    AL same as low byte of DI from INT 24
  5763                                  ;
  5764                                  ;---------------------------------------------------------------------------
  5765                                          ;procedure   ABSDWRT,FAR
  5766                                  ABSDWRT:
  5767                                  	; 15/07/2018
  5768                                  ;ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
  5769                                  
  5770 000016B6 FA                              CLI
  5771                                  	; 15/08/2018
  5772                                  	; 15/03/2018
  5773 000016B7 2E8C16[2005]            	MOV	[CS:USER_SS],SS
  5774 000016BC 2E8926[1E05]                    MOV	[CS:USER_SP],SP
  5775 000016C1 0E                              PUSH    CS
  5776 000016C2 17                              POP     SS
  5777                                  ;ASSUME	SS:DOSGROUP
  5778                                          ;MOV	SP,OFFSET DOSGROUP:DSKSTACK
  5779 000016C3 BC[8608]                        MOV	SP,DSKSTACK
  5780                                  
  5781                                  	;; MSDOS 2.11
  5782                                  
  5783                                          ;;;INC	BYTE [INDOS]
  5784                                          ;;INC	BYTE [SS:INDOS]
  5785                                  	;;STI
  5786                                          ;;CLD
  5787                                          ;;PUSH	ES
  5788                                          ;;PUSH	DS
  5789                                          ;;PUSH	SS
  5790                                          ;;POP	DS
  5791                                  ;;;ASSUME DS:DOSGROUP
  5792                                          ;;;invoke GETBP
  5793                                  	;;CALL	GETBP
  5794                                          ;;POP	DS
  5795                                  ;;;ASSUME DS:NOTHING
  5796                                  
  5797                                  	; 15/07/2018 - Retro DOS v3.0
  5798                                  	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
  5799 000016C6 06                              PUSH    ES
  5800 000016C7 E869FF                  	call    AbsSetup
  5801                                  	;
  5802 000016CA 72D7                            JC      SHORT ILEAVE
  5803                                          ;invoke DSKWRITE
  5804 000016CC E8112B                          CALL	DSKWRITE
  5805 000016CF EBBB                    	JMP     SHORT TLEAVE
  5806                                  
  5807                                  ;ABSDWRT ENDP
  5808                                  
  5809                                  ;----------------------------------------------------------------------------
  5810                                  ;
  5811                                  ; Procedure Name : GETBP
  5812                                  ;
  5813                                  ; Inputs:
  5814                                  ;	AL = Logical unit number (A = 0)
  5815                                  ; Function:
  5816                                  ;	Find Drive Parameter Block
  5817                                  ; Outputs:
  5818                                  ;	ES:BP points to DPB
  5819                                  ;	[THISDPB] = ES:BP
  5820                                  ;	Carry set if unit number bad or unit is a NET device.
  5821                                  ;		Later case sets extended error error_I24_not_supported
  5822                                  ; No other registers altered
  5823                                  ;
  5824                                  ;----------------------------------------------------------------------------
  5825                                  
  5826                                  GETBP:
  5827                                  	; 11/07/2018 - Retro DOS v3.0
  5828 000016D1 50                      	PUSH	AX
  5829 000016D2 0401                    	ADD	AL, 1		; No increment; need carry flag
  5830 000016D4 7203                    	JC	SHORT SKIPGET
  5831 000016D6 E89B52                  	CALL	GETTHISDRV
  5832                                  	; MSDOS 6.0
  5833                                  	;JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  5834                                  	;XOR	AH,AH			;DCR. ax= error code 	;AN000;
  5835                                  	;CMP	AX,error_not_dos_disk	;DCR. is unknown media ? ;AN000;
  5836                                  	;JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  5837                                  	;STC				;DCR.			;AN000;
  5838                                  	;MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  5839                                  	;MOV	WORD [AbsDskErr],201h
  5840                                  SKIPGET:
  5841 000016D9 58                      	POP	AX
  5842 000016DA 7213                    	JC	SHORT GETBP_RETN
  5843 000016DC C42E[3A05]              	LES	BP,[THISCDS]
  5844                                  	;TEST	WORD [ES:BP+43H],8000H
  5845 000016E0 26F746430080            	TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  5846 000016E6 7408                    	JZ	SHORT GETBP_CDS
  5847 000016E8 C706[D202]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32
  5848 000016EE F9                      	STC
  5849                                  GETBP_RETN:
  5850 000016EF C3                      	RETN
  5851                                  
  5852                                  GETBP_CDS:
  5853                                  	;LES	BP,[ES:BP+45H]
  5854 000016F0 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  5855                                  
  5856                                  GOTDPB:
  5857                                  	; Load THISDPB from ES:BP
  5858 000016F4 892E[2405]              	MOV	[THISDPB],BP
  5859 000016F8 8C06[2605]              	MOV	[THISDPB+2],ES
  5860 000016FC C3                      	RETN
  5861                                  
  5862                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  5863                                  
  5864                                  ;----------------------------------------------------------------------------
  5865                                  ;
  5866                                  ; Procedure Name : SYS_RETURN
  5867                                  ;
  5868                                  ; These are the general system call exit mechanisms. All internal system
  5869                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  5870                                  ; is to set the user's flags and set his AX register for return.
  5871                                  ;
  5872                                  ;----------------------------------------------------------------------------
  5873                                  
  5874                                          ;procedure   SYS_RETURN,NEAR
  5875                                  SYS_RETURN:        
  5876                                          ;entry	SYS_RET_OK
  5877                                  SYS_RET_OK:   
  5878                                  	; 18/07/2018
  5879                                  	; Offset 1666h in IBMDOS.COM (MSDOS 3.3), 1987
  5880                                  	; 23/07/2019 - Retro DOS v3.2
  5881                                  	;call	FETCHI_CHECK ; MSDOS 3.3 ! IBMDOS feature !  	
  5882                                       
  5883 000016FD E80BFF                  	call    Get_User_Stack
  5884                                  		; turn off user's carry flag
  5885                                  SYS_RET_OK_clc: ; 24/07/2019  
  5886                                          ;and	word [SI+16h],0FFFEh 
  5887                                         ;and	word [SI+user_env.user_F],~f_Carry
  5888                                  	; 24/07/2019
  5889 00001700 806416FE                	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh 
  5890 00001704 EB10                            JMP     SHORT DO_RET
  5891                                  
  5892                                          ;entry   SYS_RET_ERR
  5893                                  SYS_RET_ERR:        
  5894 00001706 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  5895 00001708 E86900                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  5896 0000170B E81A00                  	CALL	ErrorMap
  5897                                  
  5898                                  	;entry	From_GetSet
  5899                                  From_GetSet:
  5900 0000170E E8FAFE                          call    Get_User_Stack
  5901                                  		 ; signal carry to user
  5902                                  	;or	word [SI+16h],1
  5903                                  	;OR	word [SI+user_env.user_F],f_Carry
  5904                                  	; 24/07/2019
  5905 00001711 804C1601                	or	byte [SI+user_env.user_F],f_Carry
  5906 00001715 F9                      	STC			; also, signal internal error
  5907                                  DO_RET:
  5908                                          ;MOV	[SI+user_env.user_AX], AX ; Really only sets AH
  5909 00001716 8904                    	MOV	[SI],AX
  5910 00001718 C3                      	RETN
  5911                                  
  5912                                  	;entry	FCB_RET_OK
  5913                                  FCB_RET_OK:
  5914                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  5915                                  NO_OP:
  5916 00001719 30C0                    	XOR	AL,AL
  5917 0000171B C3                      	retn
  5918                                  
  5919                                  	;entry	FCB_RET_ERR
  5920                                  FCB_RET_ERR:
  5921 0000171C 30E4                    	XOR	AH,AH
  5922 0000171E 36A3[D202]              	mov	[ss:EXTERR],AX
  5923 00001722 E80300                  	CALL	ErrorMap
  5924 00001725 B0FF                    	MOV	AL,-1
  5925 00001727 C3                      	retn
  5926                                  
  5927                                  	;entry	ErrorMap
  5928                                  ErrorMap:
  5929 00001728 56                      	PUSH	SI
  5930                                  				; ERR_TABLE_21 is now in DOSDATA
  5931 00001729 BE[2F0D]                	MOV	SI,ERR_TABLE_21
  5932                                  				; SS override for FAILERR and EXTERR
  5933 0000172C 36803E[F602]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  5934 00001732 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  5935                                  		 ; Ooops, this is the REAL reason
  5936                                  	;mov	word [SS:EXTERR],53h
  5937 00001734 36C706[D202]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  5938                                  EXTENDED_NORMAL:
  5939 0000173B E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  5940 0000173E 5E                      	POP	SI
  5941 0000173F C3                      	retn
  5942                                  
  5943                                  	;EndProc SYS_RETURN
  5944                                  
  5945                                  ;---------------------------------------------------------------------------
  5946                                  ;
  5947                                  ; Procedure Name : CAL_LK
  5948                                  ;
  5949                                  ; Inputs:
  5950                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  5951                                  ;		(DS NEED not be DOSDATA)
  5952                                  ;	[EXTERR] is set with error
  5953                                  ; Function:
  5954                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  5955                                  ; Outputs:
  5956                                  ;	[EXTERR_CLASS] set
  5957                                  ;	[EXTERR_ACTION] set
  5958                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  5959                                  ; Destroys SI, FLAGS
  5960                                  ;
  5961                                  ;---------------------------------------------------------------------------
  5962                                  
  5963                                  	;procedure CAL_LK,NEAR
  5964                                  CAL_LK:
  5965 00001740 1E                      	PUSH	DS
  5966 00001741 50                      	PUSH	AX
  5967 00001742 53                      	PUSH	BX
  5968                                  
  5969                                  ;M048	Context DS		; DS:SI -> Table
  5970                                  ;
  5971                                  ; Since this function can be called thru int 2f we shall not assume that SS
  5972                                  ; is DOSDATA
  5973                                  
  5974                                  	;getdseg	<ds>	; M048: DS:SI -> Table
  5975                                  
  5976                                  	; 18/07/2018
  5977 00001743 16                      	push	ss
  5978 00001744 1F                      	pop	ds
  5979                                  
  5980 00001745 8B1E[D202]              	MOV	BX,[EXTERR]	; Get error in BL
  5981                                  TABLK1:
  5982 00001749 AC                      	LODSB
  5983                                  
  5984 0000174A 3CFF                    	CMP	AL,0FFH
  5985 0000174C 7409                    	JZ	short GOT_VALS	; End of table
  5986 0000174E 38D8                    	CMP	AL,BL
  5987 00001750 7405                    	JZ	short GOT_VALS	; Got entry
  5988 00001752 83C603                  	ADD	SI,3		; Next table entry
  5989                                  	; 15/08/2018
  5990 00001755 EBF2                    	JMP	short TABLK1
  5991                                  
  5992                                  GOT_VALS:
  5993 00001757 AD                      	LODSW			; AL is CLASS, AH is ACTION
  5994                                  
  5995 00001758 80FCFF                  	CMP	AH,0FFH
  5996 0000175B 7404                    	JZ	short NO_SET_ACT
  5997 0000175D 8826[D402]              	MOV	[EXTERR_ACTION],AH	; Set ACTION
  5998                                  NO_SET_ACT:
  5999 00001761 3CFF                    	CMP	AL,0FFH
  6000 00001763 7403                    	JZ	short NO_SET_CLS
  6001 00001765 A2[D502]                	MOV	[EXTERR_CLASS],AL	; Set CLASS
  6002                                  NO_SET_CLS:
  6003 00001768 AC                      	LODSB			; Get LOCUS
  6004                                  
  6005 00001769 3CFF                    	CMP	AL,0FFH
  6006 0000176B 7403                    	JZ	short NO_SET_LOC
  6007 0000176D A2[D102]                	MOV	[EXTERR_LOCUS],AL
  6008                                  NO_SET_LOC:
  6009 00001770 5B                      	POP	BX
  6010 00001771 58                      	POP	AX
  6011 00001772 1F                      	POP	DS
  6012 00001773 C3                      	retn
  6013                                  
  6014                                  	;EndProc CAL_LK
  6015                                  
  6016                                  ;---------------------------------------------------------------------------
  6017                                  ;
  6018                                  ; Procedure Name : ETAB_LK
  6019                                  ;
  6020                                  ; Inputs:
  6021                                  ;	AX is error code
  6022                                  ;	[USER_IN_AX] has AH value of system call involved
  6023                                  ; Function:
  6024                                  ;	Make sure error code is appropriate to this call.
  6025                                  ; Outputs:
  6026                                  ;	AX MAY be mapped error code
  6027                                  ;	[EXTERR] = Input AX
  6028                                  ; Destroys ONLY AX and FLAGS
  6029                                  ;
  6030                                  ;---------------------------------------------------------------------------
  6031                                  
  6032                                  	;procedure ETAB_LK,NEAR
  6033                                  
  6034                                  ETAB_LK: ; 10/08/2018
  6035 00001774 1E                      	PUSH	DS
  6036 00001775 56                      	PUSH	SI
  6037 00001776 51                      	PUSH	CX
  6038 00001777 53                      	PUSH	BX
  6039                                  
  6040                                  	;Context DS			; SS is DOSDATA
  6041                                  
  6042 00001778 16                      	push	ss
  6043 00001779 1F                      	pop	ds
  6044                                  
  6045 0000177A A3[D202]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  6046                                  
  6047                                  					; I21_MAP_E_TAB is now in DOSCODE
  6048 0000177D BE[930C]                	MOV	SI,I21_MAP_E_TAB
  6049 00001780 88C7                    	MOV	BH,AL			; Real code to BH
  6050 00001782 8A1E[E702]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  6051                                  TABLK2:
  6052                                  ;;hkn;	LODSW
  6053                                  ;	LODS	word ptr cs:[si] ; MSDOS 6.0
  6054                                  	
  6055                                  	; 18/07/2018
  6056 00001786 AD                      	lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  6057                                  
  6058 00001787 3CFF                    	CMP	AL,0FFH 		; End of table?
  6059 00001789 740C                    	JZ	short NOT_IN_TABLE	; Yes
  6060 0000178B 38D8                    	CMP	AL,BL			; Found call?
  6061 0000178D 740C                    	JZ	short GOT_CALL		; Yes
  6062 0000178F 86E0                    	XCHG	AH,AL			; Count to AL
  6063 00001791 30E4                    	XOR	AH,AH			; Make word for add
  6064 00001793 01C6                    	ADD	SI,AX			; Next table entry
  6065 00001795 EBEF                    	JMP	short TABLK2
  6066                                  
  6067                                  NOT_IN_TABLE:
  6068 00001797 88F8                    	MOV	AL,BH			; Restore original code
  6069 00001799 EB0B                    	JMP	SHORT NO_MAP
  6070                                  
  6071                                  GOT_CALL:
  6072 0000179B 88E1                    	MOV	CL,AH
  6073 0000179D 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  6074                                  CHECK_CODE:
  6075                                  ;;hkn;	LODSB
  6076                                  ;	LODS	byte ptr cs:[si]
  6077                                  
  6078                                  	; 18/07/2018
  6079 0000179F AC                      	lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  6080                                  
  6081 000017A0 38F8                    	CMP	AL,BH			; Code OK?
  6082 000017A2 7402                    	JZ	short NO_MAP		; Yes
  6083 000017A4 E2F9                    	LOOP	CHECK_CODE
  6084                                  NO_MAP:
  6085 000017A6 30E4                    	XOR	AH,AH			; AX is now valid code
  6086 000017A8 5B                      	POP	BX
  6087 000017A9 59                      	POP	CX
  6088 000017AA 5E                      	POP	SI
  6089 000017AB 1F                      	POP	DS
  6090 000017AC C3                      	retn
  6091                                  
  6092                                  	;EndProc ETAB_LK
  6093                                  
  6094                                  ; 18/07/2018 - Retro DOS v3.0
  6095                                  ;---------------------------------------------------------------------------
  6096                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  6097                                  
  6098                                  ;IF installed
  6099                                  ;---------------------------------------------------------------------------
  6100                                  ;
  6101                                  ; Procedure Name : SetBad
  6102                                  ;
  6103                                  ; SetBad sets up info for bad functions
  6104                                  ;
  6105                                  ;---------------------------------------------------------------------------
  6106                                  
  6107                                  SetBad:
  6108                                  	;mov	ax,1
  6109 000017AD B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  6110                                  
  6111                                  ;	set up ds to point to DOSDATA
  6112                                  
  6113                                  	; MSDOS 6.0
  6114                                  	;push	ds
  6115                                  
  6116                                  	;getdseg <ds>
  6117                                  	;MOV	[EXTERR_LOCUS],errLOC_Unk	
  6118                                  
  6119                                  	; MSDOS 3.3
  6120                                  	;mov	byte [cs:EXTERR_LOCUS],1
  6121 000017B0 2EC606[D102]01          	MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  6122                                  
  6123                                  	;pop	ds	  		;hkn; restore ds
  6124                                  
  6125 000017B6 F9                      	STC
  6126 000017B7 C3                      	retn
  6127                                  
  6128                                  ;--------------------------------------------------------------------------
  6129                                  ;
  6130                                  ; Procedure Name : BadCall
  6131                                  ;
  6132                                  ; BadCall is the initial routine for bad function calls
  6133                                  ;
  6134                                  ;--------------------------------------------------------------------------
  6135                                  
  6136                                  BadCall:
  6137 000017B8 E8F2FF                  	call	SetBad
  6138 000017BB CB                      	retf
  6139                                  
  6140                                  ;--------------------------------------------------------------------------
  6141                                  ;
  6142                                  ; OKCall always sets carry to off.
  6143                                  ;
  6144                                  ;-----------------------------------------------------------------------
  6145                                  
  6146                                  OKCall:
  6147 000017BC F8                      	CLC
  6148 000017BD CB                      	retf
  6149                                  
  6150                                  ;---------------------------------------------------------------------------
  6151                                  ;
  6152                                  ; Procedure Name : INT2F
  6153                                  ;
  6154                                  ; INT 2F handler works as follows:
  6155                                  ;   PUSH    AX
  6156                                  ;   MOV     AX,multiplex:function
  6157                                  ;   INT     2F
  6158                                  ;   POP     ...
  6159                                  ; The handler itself needs to make the AX available for the various routines.
  6160                                  ;
  6161                                  ;----------------------------------------------------------------------------
  6162                                  
  6163                                  ;PUBLIC	Int2F
  6164                                  ;INT2F	PROC	FAR
  6165                                  
  6166                                  	; 18/07/2018 - Retro DOS v3.0
  6167                                  
  6168                                  INT2F:
  6169                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  6170                                  INT2FNT:
  6171                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  6172 000017BE FB                      	STI
  6173                                  	;cmp	ah,11h
  6174 000017BF 80FC11                  	CMP	AH,MultNET
  6175 000017C2 750A                    	JNZ	short INT2FSHR
  6176                                  TestInstall:
  6177 000017C4 08C0                    	OR	AL,AL
  6178 000017C6 7403                    	JZ	short Leave2F
  6179                                  BadFunc:
  6180 000017C8 E8E2FF                  	CALL	SetBad
  6181                                  
  6182                                  	;entry	Leave2F
  6183                                  Leave2F:
  6184 000017CB CA0200                  	RETF	2			; long return + clear flags off stack
  6185                                  
  6186                                  INT2FSHR:
  6187                                  	;cmp	ah,10h
  6188 000017CE 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  6189 000017D1 74F1                    	JZ	short TestInstall	; yes, check for installation
  6190                                  INT2FNLS:
  6191                                  	;cmp	ah,14h
  6192 000017D3 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  6193 000017D6 74EC                    	JZ	short TestInstall	; yes check for installation
  6194                                  INT2FDOS:
  6195                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  6196                                  
  6197                                  	; 18/07/2018
  6198                                  	; MSDOS 6.0
  6199                                  	;CMP	AH,MultDOS
  6200                                  	;JNZ	check_win		;check if win386 broadcast
  6201                                  	;jmp	DispatchDOS
  6202                                  
  6203                                  	; .... win386 .... 
  6204                                  	
  6205                                  	; 18/07/2018
  6206                                  	; MSDOS 3.3
  6207                                  	;cmp	ah,12h	
  6208 000017D8 80FC12                  	CMP	AH,MultDOS
  6209 000017DB 7401                    	jz	short DispatchDOS
  6210 000017DD CF                      	iret
  6211                                  
  6212                                  ;INT2F	ENDP
  6213                                  	
  6214                                  DispatchDOS:
  6215 000017DE 2EFF36[D80E]            	PUSH	word [CS:FOO]		; push return address
  6216 000017E3 2EFF36[DA0E]            	PUSH	word [CS:DTab]		; push table address
  6217 000017E8 50                      	PUSH	AX			; push index
  6218 000017E9 55                      	PUSH	BP
  6219 000017EA 89E5                    	MOV	BP,SP
  6220                                  		; stack looks like:
  6221                                  		;   0	BP
  6222                                  		;   2	DISPATCH
  6223                                  		;   4	TABLE
  6224                                  		;   6	RETURN
  6225                                  		;   8	LONG-RETURN
  6226                                  		;   c	FLAGS
  6227                                  		;   e	AX
  6228                                  	
  6229 000017EC 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6230 000017EF 5D                      	POP	BP
  6231 000017F0 E8A707                  	call	TableDispatch
  6232 000017F3 EBD3                    	JMP	short BadFunc 		; return indicates invalid function
  6233                                  
  6234                                  INT2F_etcetera:
  6235                                  	;entry	DosGetGroup
  6236                                  DosGetGroup:
  6237                                  	; MSDOS 6.0
  6238                                  ;SR; Cannot use CS now
  6239                                  ;
  6240                                  ;	PUSH	CS
  6241                                  ;	POP	DS
  6242                                  
  6243                                  	;getdseg <ds>
  6244                                  	;retn
  6245                                  
  6246                                  	; MSDOS 3.3
  6247 000017F5 0E                      	push	cs
  6248 000017F6 1F                      	pop	ds
  6249 000017F7 C3                      	retn
  6250                                  
  6251                                  	;entry	DOSInstall
  6252                                  DOSInstall:
  6253 000017F8 B0FF                    	MOV	AL,0FFh
  6254 000017FA C3                      	retn
  6255                                  
  6256                                  ;ENDIF
  6257                                  
  6258                                  ;============================================================================
  6259                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  6260                                  ;============================================================================
  6261                                  ; 18/07/2018 - Retro DOS 3.0
  6262                                  
  6263                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
  6264                                  ;     ENTRY: AL = Character to map
  6265                                  ;     EXIT:  AL = The converted character
  6266                                  ; Alters no registers except AL and flags.
  6267                                  ; The routine should do nothing to chars below 80H.
  6268                                  ;
  6269                                  ; Example:
  6270                                  
  6271                                  ;Procedure   MAP_CASE,FAR
  6272                                  
  6273                                  MAP_CASE:
  6274                                  	; Offset 176Ch in IBMDOS.COM (MSDOS 3.3), 1987
  6275                                  	
  6276 000017FB 3C80                    	CMP	AL,80H
  6277 000017FD 7301                    	JAE	short Map1	;Map no chars below 80H ever
  6278 000017FF CB                      	RETF
  6279                                  Map1:
  6280 00001800 2C80                    	SUB	AL,80H		;Turn into index value
  6281 00001802 1E                      	PUSH	DS
  6282 00001803 53                      	PUSH	BX
  6283 00001804 BB[8810]                	MOV	BX,UCASE_TAB+2
  6284                                  FINISH:
  6285 00001807 0E                      	PUSH	CS		;Move to DS
  6286 00001808 1F                      	POP	DS
  6287 00001809 D7                      	XLAT			; Get upper case character
  6288 0000180A 5B                      	POP	BX
  6289 0000180B 1F                      	POP	DS
  6290                                  L_RET:	
  6291 0000180C CB                      	RETF
  6292                                  
  6293                                  ;EndProc MAP_CASE
  6294                                  
  6295                                  ;============================================================================
  6296                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6297                                  ;============================================================================
  6298                                  ; 18/07/2018 - Retro DOS v3.0
  6299                                  
  6300                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6301                                  
  6302                                  ; OEMFunction key is expected to process a single function
  6303                                  ;   key input from a device and dispatch to the proper
  6304                                  ;   routines leaving all registers UNTOUCHED.
  6305                                  ;
  6306                                  ; Inputs:   CS, SS are DOSGROUP
  6307                                  ; Outputs:  None. This function is expected to JMP to onw of
  6308                                  ;           the following labels:
  6309                                  ;
  6310                                  ;           GetCh       - ignore the sequence
  6311                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6312                                  ;           ExitIns     - toggle insert mode
  6313                                  ;           EnterIns    - toggle insert mode
  6314                                  ;           BackSp      - move backwards one space
  6315                                  ;           ReEdit      - reedit the line with a new template
  6316                                  ;           KilNew      - discard the current line and start from scratch
  6317                                  ;           CopyLin     - copy the rest of the template into the line
  6318                                  ;           SkipStr     - read the next character and skip to it in the template
  6319                                  ;           CopyStr     - read next char and copy from template to line until char
  6320                                  ;           SkipOne     - advance position in template one character
  6321                                  ;           CopyOne     - copy next character in template into line
  6322                                  ;           CtrlZ       - place a ^Z into the template
  6323                                  ; Registers that are allowed to be modified by this function are:
  6324                                  ;           AX, CX, BP
  6325                                  
  6326                                  OEMFunctionKey:
  6327 0000180D E87308                  	CALL	_$STD_CON_INPUT_NO_ECHO  ; Get the second byte of the sequence
  6328 00001810 B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6329 00001812 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6330 00001813 BF[D312]                	MOV     DI,ESCTAB		; offset of second byte table
  6331 00001816 F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6332 00001818 5F                      	POP     DI                      ; restore DI
  6333 00001819 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6334 0000181B 89CD                    	MOV     BP,CX                   ; move to indexable register
  6335                                  	;JMP	word [SS:BP+ESCFUNC]	; Go to the right routine
  6336 0000181D FFA6[E112]              	JMP	word [BP+ESCFUNC]
  6337                                  	
  6338                                  ;============================================================================
  6339                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6340                                  ;============================================================================
  6341                                  ; Retro DOS v3.0 - 18/07/2018
  6342                                  
  6343                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6344                                  ;----------------------------------------------------------------------------
  6345                                  ; Retro DOS v2.0 - 13/03/2018
  6346                                  
  6347                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6348                                  
  6349                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6350                                  
  6351                                  ;**	$GET_DATE - Get Current Date
  6352                                  ;
  6353                                  ;	ENTRY	none
  6354                                  ;	EXIT	(cx:dx) = current date
  6355                                  ;	USES	all
  6356                                  
  6357                                  _$GET_DATE:	;System call 42
  6358                                  
  6359 00001821 16                              PUSH    SS
  6360 00001822 1F                              POP     DS
  6361 00001823 E8B700                          CALL	READTIME        ;Check for rollover to next day
  6362 00001826 A1[FE02]                        MOV     AX,[YEAR]
  6363                                  
  6364                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6365                                  
  6366 00001829 8B1E[FC02]                      MOV     BX,[DAY]	; fetch both day and month
  6367 0000182D E8DBFD                  	CALL	Get_User_Stack	;Get pointer to user registers
  6368                                          ;MOV    [SI+6],BX  	;DH=month, DL=day
  6369 00001830 895C06                  	MOV	[SI+user_env.user_DX],BX
  6370 00001833 05BC07                          ADD     AX,1980         ;Put bias back
  6371                                          ;MOV    [SI+4],AX  	;CX=year
  6372 00001836 894404                  	MOV	[SI+user_env.user_CX],AX
  6373                                          ;MOV	AL,[WEEKDAY]
  6374 00001839 36A0[0203]                      MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6375 0000183D C3                      	RETN
  6376                                  
  6377                                  ;**	$SET_DATE - Set Current Date
  6378                                  ;
  6379                                  ;	ENTRY	(cx:dx) = current date
  6380                                  ;	EXIT	(al) = -1 iff bad date
  6381                                  ;		(al) = 0 if ok
  6382                                  ;	USES	all
  6383                                  
  6384                                  _$SET_DATE:			;System call 43
  6385                                  
  6386 0000183E B0FF                            MOV     AL,-1           ;Be ready to flag error
  6387 00001840 81E9BC07                        SUB     CX,1980         ;Fix bias in year
  6388 00001844 7217                            JC      SHORT RET24	;Error if not big enough
  6389 00001846 83F977                          CMP     CX,119          ;Year must be less than 2100
  6390 00001849 7712                            JA      SHORT RET24
  6391 0000184B 08F6                            OR      DH,DH
  6392 0000184D 740E                            JZ      SHORT RET24
  6393 0000184F 08D2                            OR      DL,DL
  6394 00001851 740A                            JZ      SHORT RET24	;Error if either month or day is 0
  6395 00001853 80FE0C                          CMP     DH,12           ;Check against max. month
  6396 00001856 7705                            JA      SHORT RET24
  6397 00001858 16                              PUSH    SS
  6398 00001859 1F                              POP     DS
  6399 0000185A E81301                  	CALL	DODATE
  6400                                  RET24:  
  6401 0000185D C3                      	RETN
  6402                                  
  6403                                  
  6404                                  ;**	$GET_TIME - Get Current Time
  6405                                  ;
  6406                                  ;	ENTRY	none
  6407                                  ;	EXIT	(cx:dx) = current time
  6408                                  ;	USES	all
  6409                                  
  6410                                  _$GET_TIME:			;System call 44
  6411                                  
  6412 0000185E 16                              PUSH    SS
  6413 0000185F 1F                              POP     DS
  6414 00001860 E87A00                  	CALL	READTIME
  6415 00001863 E8A5FD                  	CALL	Get_User_Stack           ;Get pointer to user registers
  6416                                         ;MOV     [SI+6],DX
  6417 00001866 895406                  	MOV	[SI+user_env.user_DX],DX
  6418                                         ;MOV     [SI+4],CX
  6419 00001869 894C04                  	MOV	[SI+user_env.user_CX],CX
  6420 0000186C 30C0                            XOR     AL,AL
  6421                                  RET26:  
  6422 0000186E C3                      	RETN
  6423                                  
  6424                                  ;**	$SET_TIME - Set Current Time
  6425                                  ;
  6426                                  ;	ENTRY	(cx:dx) = time
  6427                                  ;	EXIT	(al) = 0 if 0k
  6428                                  ;		(al) = -1 if invalid
  6429                                  ;	USES	ALL
  6430                                  
  6431                                  _$SET_TIME:			;System call 45
  6432                                  
  6433 0000186F B0FF                            MOV     AL,-1           ;Flag in case of error
  6434 00001871 80FD18                          CMP     CH,24           ;Check hours
  6435 00001874 73F8                            JAE     SHORT RET26
  6436 00001876 80F93C                          CMP     CL,60           ;Check minutes
  6437 00001879 73F3                            JAE     SHORT RET26
  6438 0000187B 80FE3C                          CMP     DH,60           ;Check seconds
  6439 0000187E 73EE                            JAE     SHORT RET26
  6440 00001880 80FA64                          CMP     DL,100          ;Check 1/100's
  6441 00001883 73E9                            JAE     SHORT RET26
  6442 00001885 51                              PUSH    CX
  6443 00001886 52                              PUSH    DX
  6444 00001887 16                              PUSH    SS
  6445 00001888 1F                              POP     DS
  6446 00001889 BB[5803]                        MOV     BX,TIMEBUF
  6447 0000188C B90600                          MOV     CX,6
  6448 0000188F 31D2                            XOR     DX,DX
  6449 00001891 89D0                            MOV     AX,DX
  6450 00001893 53                              PUSH    BX
  6451 00001894 E88A36                  	CALL	SETREAD
  6452 00001897 1E                              PUSH    DS
  6453 00001898 C536[2E00]                      LDS     SI,[BCLOCK]
  6454 0000189C E85E36                  	CALL	DEVIOCALL2      ;Get correct day count
  6455 0000189F 1F                              POP     DS
  6456 000018A0 5B                              POP     BX
  6457 000018A1 E8B036                  	CALL	SETWRITE
  6458 000018A4 8F06[5C03]                      POP     WORD [TIMEBUF+4]
  6459 000018A8 8F06[5A03]                      POP     WORD [TIMEBUF+2]
  6460 000018AC C536[2E00]                      LDS     SI,[BCLOCK]
  6461 000018B0 E84A36                  	CALL	DEVIOCALL2      ;Set the time
  6462 000018B3 30C0                            XOR     AL,AL
  6463 000018B5 C3                              RETN
  6464                                  
  6465                                  ; 11/07/2018 - Retro DOS v3.0
  6466                                  ; Retro DOS v2.0 - 14/03/2018
  6467                                  
  6468                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6469                                  
  6470                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6471                                  
  6472                                  ;
  6473                                  ; Date16 returns the current date in AX, current time in DX
  6474                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6475                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6476                                  ;
  6477                                  
  6478                                  DATE16:
  6479                                  	
  6480                                  ;M048	Context DS
  6481                                  ;
  6482                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6483                                  ; is DOSDATA
  6484                                  
  6485                                  	;getdseg	<ds>			; M048
  6486                                  
  6487                                  	;PUSH	SS
  6488 000018B6 0E                      	PUSH	CS
  6489 000018B7 1F                      	POP	DS
  6490                                  
  6491 000018B8 51                              PUSH    CX
  6492 000018B9 06                              PUSH    ES
  6493 000018BA E82000                          CALL    READTIME
  6494 000018BD 07                              POP     ES
  6495 000018BE D0E1                            SHL     CL,1            ;Minutes to left part of byte
  6496 000018C0 D0E1                            SHL     CL,1
  6497 000018C2 D1E1                            SHL     CX,1            ;Push hours and minutes to left end
  6498 000018C4 D1E1                            SHL     CX,1
  6499 000018C6 D1E1                            SHL     CX,1
  6500 000018C8 D0EE                            SHR     DH,1            ;Count every two seconds
  6501 000018CA 08F1                            OR      CL,DH           ;Combine seconds with hours and minutes
  6502 000018CC 89CA                            MOV     DX,CX
  6503                                  
  6504                                  ;	WARNING!  MONTH and YEAR must be adjacently allocated
  6505                                  
  6506 000018CE A1[FD02]                        MOV     AX,[MONTH]	;Fetch month and year
  6507 000018D1 B104                            MOV     CL,4
  6508 000018D3 D2E0                            SHL     AL,CL		;Push month to left to make room for day
  6509 000018D5 D1E0                            SHL     AX,1
  6510 000018D7 59                              POP     CX
  6511 000018D8 0A06[FC02]                      OR      AL,[DAY]
  6512                                  RET21:
  6513 000018DC C3                              RETN
  6514                                  
  6515                                  READTIME:
  6516                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6517                                  ;Uses AX, CX, DX.
  6518                                  
  6519 000018DD C706[8D0F]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6520 000018E3 56                              PUSH    SI
  6521 000018E4 53                              PUSH    BX
  6522                                  
  6523 000018E5 BB[5803]                        MOV     BX,TIMEBUF
  6524                                  
  6525 000018E8 B90600                          MOV     CX,6
  6526 000018EB 31D2                            XOR     DX,DX
  6527 000018ED 89D0                            MOV     AX,DX
  6528 000018EF E82F36                  	CALL	SETREAD
  6529 000018F2 1E                              PUSH    DS
  6530 000018F3 C536[2E00]                      LDS     SI,[BCLOCK]
  6531 000018F7 E80336                  	CALL	DEVIOCALL2      ;Get correct date and time
  6532 000018FA 1F                              POP     DS
  6533 000018FB 5B                              POP     BX
  6534 000018FC 5E                              POP     SI
  6535 000018FD A1[5803]                        MOV     AX,[TIMEBUF]
  6536 00001900 8B0E[5A03]                      MOV     CX,[TIMEBUF+2]
  6537 00001904 8B16[5C03]                      MOV     DX,[TIMEBUF+4]
  6538 00001908 3B06[0003]                      CMP     AX,[DAYCNT]     ;See if day count is the same
  6539                                          ;JZ	SHORT RET22
  6540 0000190C 74CE                    	JZ	SHORT RET21 ; 18/07/2018
  6541                                  	;cmp	ax,43830
  6542 0000190E 3D36AB                          CMP     AX,FOURYEARS*30 ;Number of days in 120 years
  6543 00001911 733D                            JAE     SHORT RET22	;Ignore if too large
  6544 00001913 A3[0003]                        MOV     [DAYCNT],AX
  6545 00001916 56                              PUSH    SI
  6546 00001917 51                              PUSH    CX
  6547 00001918 52                              PUSH    DX              ;Save time
  6548 00001919 31D2                            XOR     DX,DX
  6549                                  	;mov	cx,1461
  6550 0000191B B9B505                          MOV     CX,FOURYEARS    ;Number of days in 4 years
  6551 0000191E F7F1                            DIV     CX              ;Compute number of 4-year units
  6552 00001920 D1E0                            SHL     AX,1
  6553 00001922 D1E0                            SHL     AX,1
  6554 00001924 D1E0                            SHL     AX,1            ;Multiply by 8 (no. of half-years)
  6555 00001926 89C1                            MOV     CX,AX           ;<240 implies AH=0
  6556                                  
  6557 00001928 BE[7F0C]                        MOV     SI,YRTAB        ;Table of days in each year
  6558                                  
  6559 0000192B E82300                          CALL    DSLIDE          ;Find out which of four years we're in
  6560 0000192E D1E9                            SHR     CX,1            ;Convert half-years to whole years
  6561 00001930 7304                            JNC     SHORT SK	;Extra half-year?
  6562 00001932 81C2C800                        ADD     DX,200
  6563                                  SK:
  6564 00001936 E82400                          CALL    SETYEAR
  6565 00001939 B101                            MOV     CL,1            ;At least at first month in year
  6566                                  
  6567 0000193B BE[870C]                        MOV     SI,MONTAB       ;Table of days in each month
  6568                                          
  6569 0000193E E81000                  	CALL    DSLIDE          ;Find out which month we're in
  6570 00001941 880E[FD02]                      MOV     [MONTH],CL
  6571 00001945 42                              INC     DX              ;Remainder is day of month (start with one)
  6572 00001946 8816[FC02]                      MOV     [DAY],DL
  6573 0000194A E89400                          CALL    WKDAY           ;Set day of week
  6574 0000194D 5A                              POP     DX
  6575 0000194E 59                              POP     CX
  6576 0000194F 5E                              POP     SI
  6577                                  RET22:  
  6578 00001950 C3                      	RETN
  6579                                  
  6580                                  DSLIDE:
  6581 00001951 B400                            MOV     AH,0
  6582                                  DSLIDE1:
  6583 00001953 AC                              LODSB			;Get count of days
  6584 00001954 39C2                            CMP     DX,AX           ;See if it will fit
  6585 00001956 7217                            JB      SHORT RET23	;If not, done
  6586 00001958 29C2                            SUB     DX,AX
  6587 0000195A 41                              INC     CX              ;Count one more month/year
  6588 0000195B EBF6                            JMP     SHORT DSLIDE1
  6589                                  
  6590                                  SETYEAR:
  6591                                  ;Set year with value in CX. Adjust length of February for this year.
  6592                                  
  6593                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6594                                  ;       set DS to DOSDATA. Since the only guy calling this should be the DOS
  6595                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6596                                  ;	preserve DS as CHKYR is also called as a routine.
  6597                                  
  6598                                  
  6599                                  	; MSDOS 6.0 (18/07/2018) ; *
  6600                                  
  6601                                  	;GETDSEG DS
  6602                                  
  6603 0000195D 0E                      	PUSH	CS  ; *
  6604 0000195E 1F                      	POP	DS  ; *
  6605                                  
  6606                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987 
  6607                                  
  6608 0000195F 880E[FE02]                      MOV     [YEAR],CL
  6609                                  CHKYR:
  6610 00001963 F6C103                          TEST    CL,3            ;Check for leap year
  6611 00001966 B01C                            MOV     AL,28
  6612 00001968 7502                            JNZ     SHORT SAVFEB	;28 days if no leap year
  6613 0000196A FEC0                            INC     AL              ;Add leap day
  6614                                  SAVFEB:
  6615                                  	;mov	[february],al
  6616 0000196C A2[880C]                        MOV     [MONTAB+1],AL   ;Store for February
  6617                                  RET23:  
  6618 0000196F C3                      	RETN
  6619                                  
  6620                                  DODATE:
  6621 00001970 E8F0FF                          CALL    CHKYR           ;Set Feb. up for new year
  6622 00001973 88F0                            MOV     AL,DH
  6623                                  
  6624 00001975 BB[860C]                        MOV     BX,MONTAB-1
  6625                                  
  6626 00001978 D7                              XLAT                    ;Look up days in month
  6627 00001979 38D0                            CMP     AL,DL
  6628 0000197B B0FF                            MOV     AL,-1           ;Restore error flag, just in case
  6629                                          ;JB	SHORT RET25	;Error if too many days
  6630 0000197D 72F0                            jb	short RET23 ; 18/07/2018
  6631 0000197F E8DBFF                  	CALL    SETYEAR
  6632                                  ;
  6633                                  ; WARNING!  DAY and MONTH must be adjacently allocated
  6634                                  ;
  6635 00001982 8916[FC02]                      MOV     [DAY],DX	;Set both day and month
  6636 00001986 D1E9                            SHR     CX,1
  6637 00001988 D1E9                            SHR     CX,1
  6638                                  	;mov	ax,1461
  6639 0000198A B8B505                          MOV     AX,FOURYEARS
  6640 0000198D 89D3                            MOV     BX,DX
  6641 0000198F F7E1                            MUL     CX
  6642 00001991 8A0E[FE02]                      MOV     CL,[YEAR]
  6643 00001995 80E103                          AND     CL,3
  6644                                  
  6645 00001998 BE[7F0C]                        MOV     SI,YRTAB
  6646                                  
  6647 0000199B 89C2                            MOV     DX,AX
  6648 0000199D D1E1                            SHL     CX,1            ;Two entries per year, so double count
  6649 0000199F E85200                          CALL    DSUM            ;Add up the days in each year
  6650 000019A2 88F9                            MOV     CL,BH           ;Month of year
  6651                                  
  6652 000019A4 BE[870C]                        MOV     SI,MONTAB
  6653                                  
  6654 000019A7 49                              DEC     CX              ;Account for months starting with one
  6655 000019A8 E84900                          CALL    DSUM            ;Add up days in each month
  6656 000019AB 88D9                            MOV     CL,BL           ;Day of month
  6657 000019AD 49                              DEC     CX              ;Account for days starting with one
  6658 000019AE 01CA                            ADD     DX,CX           ;Add in to day total
  6659 000019B0 92                              XCHG    AX,DX           ;Get day count in AX
  6660 000019B1 A3[0003]                        MOV     [DAYCNT],AX
  6661 000019B4 56                              PUSH    SI
  6662 000019B5 53                              PUSH    BX
  6663 000019B6 50                              PUSH    AX
  6664                                  
  6665 000019B7 BB[5803]                        MOV     BX,TIMEBUF
  6666                                  
  6667 000019BA B90600                          MOV     CX,6
  6668 000019BD 31D2                            XOR     DX,DX
  6669 000019BF 89D0                            MOV     AX,DX
  6670 000019C1 53                              PUSH    BX
  6671 000019C2 E85C35                  	CALL	SETREAD
  6672                                  
  6673 000019C5 1E                              PUSH    DS
  6674 000019C6 C536[2E00]                      LDS     SI,[BCLOCK]
  6675 000019CA E83035                  	CALL	DEVIOCALL2	;Get correct date and time
  6676 000019CD 1F                              POP     DS
  6677 000019CE 5B                              POP     BX
  6678 000019CF E88235                  	CALL	SETWRITE
  6679 000019D2 8F06[5803]                      POP     WORD [TIMEBUF]
  6680 000019D6 1E                              PUSH    DS
  6681 000019D7 C536[2E00]                      LDS     SI,[BCLOCK]
  6682 000019DB E81F35                  	CALL	DEVIOCALL2      ;Set the date
  6683 000019DE 1F                              POP     DS
  6684 000019DF 5B                              POP     BX
  6685 000019E0 5E                              POP     SI
  6686                                  WKDAY:
  6687 000019E1 A1[0003]                        MOV     AX,[DAYCNT]
  6688 000019E4 31D2                            XOR     DX,DX
  6689 000019E6 B90700                          MOV     CX,7
  6690 000019E9 40                              INC     AX
  6691 000019EA 40                              INC     AX              ;First day was Tuesday
  6692 000019EB F7F1                            DIV     CX              ;Compute day of week
  6693 000019ED 8816[0203]                      MOV     [WEEKDAY],DL
  6694 000019F1 30C0                            XOR     AL,AL           ;Flag OK
  6695                                  RET25:
  6696 000019F3 C3                      	RETN
  6697                                  
  6698                                  ;**	DSUM - Compute the sum of a string of bytes
  6699                                  ;
  6700                                  ;	ENTRY	(cx) = byte count
  6701                                  ;		(ds:si) = byte address
  6702                                  ;		(dx) = sum register, initialized by caller
  6703                                  ;	EXIT	(dx) updated
  6704                                  ;	USES	ax, cx, dx, si, flags
  6705                                  
  6706                                  DSUM:
  6707 000019F4 B400                            MOV     AH,0
  6708                                  	;JCXZ	DSUM9
  6709 000019F6 E3FB                            JCXZ	RET25 ; 18/07/2018
  6710                                  DSUM1:
  6711 000019F8 AC                              LODSB
  6712 000019F9 01C2                            ADD     DX,AX
  6713 000019FB E2FB                            LOOP    DSUM1
  6714                                  DSUM9:
  6715 000019FD C3                              RETN
  6716                                  
  6717                                  
  6718                                  ;============================================================================
  6719                                  ; GETSET.ASM
  6720                                  ;============================================================================
  6721                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6722                                  ; Retro DOS v2.0 - 12/03/2018
  6723                                  
  6724                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6725                                  ;NAME	GETSET
  6726                                  
  6727                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6728                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6729                                  
  6730                                  ;USERNUM:
  6731                                  ;	DW	0			; 24 bit user number
  6732                                  ;       DB      0
  6733                                  ;;	IF      IBM
  6734                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6735                                  ;;	ELSE
  6736                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6737                                  ;;	ENDIF
  6738                                  
  6739                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6740                                  ;; 08/07/2018 - Retro DOS v3.0
  6741                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6742                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6743                                  
  6744                                  
  6745                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6746                                  
  6747                                  _$GET_VERSION:
  6748                                  
  6749                                  ; Inputs:
  6750                                  ;       None
  6751                                  ; Function:
  6752                                  ;       Return MS-DOS version number
  6753                                  ; Outputs:
  6754                                  ;       OEM number in BH
  6755                                  ;       User number in BL:CX (24 bits)
  6756                                  ;       Version number as AL.AH in binary
  6757                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6758                                  
  6759                                  ; MSDOS 6.0
  6760                                  ;		if input al = 00
  6761                                  ;		  (bh) = OEM number			
  6762                                  ;		else if input al = 01
  6763                                  ;		  (bh) = version flags
  6764                                  ;		 
  6765                                  ;		       	 bits 0-2 = DOS internal revision
  6766                                  ;		       	 bits 3-7 = DOS type flags
  6767                                  ;		              bit 3    = DOS is in ROM
  6768                                  ;		              bit 4    = DOS in in HMA
  6769                                  ;		              bits 5-7 = reserved
  6770                                  ;               M007 change - only bit 3 is now valid.  Other bits
  6771                                  ;               are 0 when AL = 1
  6772                                  
  6773                                  	
  6774                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6775                                  
  6776 000019FE 16                              PUSH    SS
  6777 000019FF 1F                              POP     DS
  6778 00001A00 8B1E[5403]                      MOV     BX,[USERNUM+2]
  6779 00001A04 8B0E[5203]                      MOV     CX,[USERNUM]
  6780 00001A08 A1[7D0C]                        MOV     AX,[MSVERS]
  6781 00001A0B E8FDFB                          call	Get_User_Stack
  6782                                          ;MOV	[SI+2],BX
  6783 00001A0E 895C02                  	mov	[SI+user_env.user_BX],BX
  6784                                          ;MOV	[SI+4],CX
  6785 00001A11 894C04                  	mov	[SI+user_env.user_CX],CX
  6786                                          ;MOV	[SI+user_env.user_AX],AX  ; Really only sets AH
  6787 00001A14 8904                            MOV	[SI],AX ; 31/03/2018
  6788 00001A16 C3                      	RETN
  6789                                  
  6790                                  ; 18/07/2018 - Retro DOS v3.0
  6791                                  
  6792                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6793                                  
  6794                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6795                                  ;
  6796                                  ;	ENTRY	none
  6797                                  ;	EXIT	(al) = value of VERIFY flag
  6798                                  ;	USES	all
  6799                                  
  6800                                  
  6801                                  _$GET_VERIFY_ON_WRITE:
  6802                                  
  6803                                  ;hkn; SS override
  6804 00001A17 36A0[AD02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6805 00001A1B C3                      	retn
  6806                                  
  6807                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6808                                  ;
  6809                                  ;	ENTRY	(al) = value of VERIFY flag
  6810                                  ;	EXIT	none
  6811                                  ;	USES	all
  6812                                  
  6813                                  _$SET_VERIFY_ON_WRITE:
  6814                                  
  6815 00001A1C 2401                    	AND	AL,1
  6816                                  ;hkn; SS override
  6817 00001A1E 36A2[AD02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6818                                  RET27:	; 18/07/2018
  6819 00001A22 C3                      	retn
  6820                                  
  6821                                  ; 19/07/2018 - Retro DOS v3.0
  6822                                  
  6823                                  ;BREAK <$International - return country-dependent information>
  6824                                  
  6825                                  ;----------------------------------------------------------------------------
  6826                                  ;
  6827                                  ; Procedure Name : $INTERNATIONAL
  6828                                  ;
  6829                                  ; Inputs:
  6830                                  ;	MOV	AH,International
  6831                                  ;	MOV	AL,country	(al = 0 => current country)
  6832                                  ;      [MOV	BX,country]
  6833                                  ;	LDS	DX,block
  6834                                  ;	INT	21
  6835                                  ; Function:
  6836                                  ;	give users an idea of what country the application is running
  6837                                  ; Outputs:
  6838                                  ;	IF DX != -1 on input (get country)
  6839                                  ;	  AL = 0 means return current country table.
  6840                                  ;	  0<AL<0FFH means return country table for country AL
  6841                                  ;	  AL = 0FF means return country table for country BX
  6842                                  ;	  No Carry:
  6843                                  ;	     Register BX will contain the 16-bit country code.
  6844                                  ;	     Register AL will contain the low 8 bits of the country code.
  6845                                  ;	     The block pointed to by DS:DX is filled in with the information
  6846                                  ;	     for the particular country.
  6847                                  ;		BYTE  Size of this table excluding this byte and the next
  6848                                  ;		BYTE  Country code represented by this table
  6849                                  ;			A sequence of n bytes, where n is the number specified
  6850                                  ;			by the first byte above and is not > internat_block_max,
  6851                                  ;			in the correct order for being returned by the
  6852                                  ;			INTERNATIONAL call as follows:
  6853                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  6854                                  ;		5 BYTE	Currency symbol null terminated
  6855                                  ;		2 BYTE	thousands separator null terminated
  6856                                  ;		2 BYTE	Decimal point null terminated
  6857                                  ;		2 BYTE	Date separator null terminated
  6858                                  ;		2 BYTE	Time separator null terminated
  6859                                  ;		1 BYTE	Bit field.  Currency format.
  6860                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  6861                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  6862                                  ;		1 BYTE	No. of significant decimal digits in currency
  6863                                  ;		1 BYTE	Bit field.  Time format.
  6864                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  6865                                  ;		DWORD	Call address of case conversion routine
  6866                                  ;		2 BYTE	Data list separator null terminated.
  6867                                  ;	  Carry:
  6868                                  ;	     Register AX has the error code.
  6869                                  ;	IF DX = -1 on input (set current country)
  6870                                  ;	  AL = 0 is an error
  6871                                  ;	  0<AL<0FFH means set current country to country AL
  6872                                  ;	  AL = 0FF means set current country to country BX
  6873                                  ;	  No Carry:
  6874                                  ;	    Current country SET
  6875                                  ;	    Register AL will contain the low 8 bits of the country code.
  6876                                  ;	  Carry:
  6877                                  ;	     Register AX has the error code.
  6878                                  ;-----------------------------------------------------------------------------
  6879                                  
  6880                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  6881                                  
  6882                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  6883                                  	 
  6884 00001A23 3CFF                    	CMP	AL,0FFH
  6885 00001A25 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  6886 00001A27 88C3                    	MOV	BL,AL			; Put AL country code in BX
  6887 00001A29 30FF                    	XOR	BH,BH
  6888                                  BX_HAS_CODE:
  6889 00001A2B 1E                      	PUSH	DS
  6890 00001A2C 07                      	POP	ES
  6891 00001A2D 52                      	PUSH	DX
  6892 00001A2E 5F                      	POP	DI			; User buffer to ES:DI
  6893                                  
  6894                                  ;hkn; SS is DOSDATA
  6895                                  ;	context DS
  6896                                  
  6897 00001A2F 16                      	push	ss
  6898 00001A30 1F                      	pop	ds
  6899                                  
  6900 00001A31 83FFFF                  	CMP	DI,-1
  6901 00001A34 745F                    	JZ	short international_set
  6902 00001A36 09DB                    	OR	BX,BX
  6903 00001A38 7505                    	JNZ	short international_find
  6904                                  
  6905                                  ;hkn; country_cdpg is in DOSDATA segment.
  6906 00001A3A BE[FD0F]                	MOV	SI,COUNTRY_CDPG
  6907                                  
  6908 00001A3D EB40                    	JMP	SHORT international_copy
  6909                                  
  6910                                  international_find:
  6911 00001A3F BD0000                  	MOV	BP,0			 ; flag it for GetCntry only
  6912 00001A42 E80B00                  	CALL	international_get
  6913 00001A45 7256                    	JC	short errtn
  6914 00001A47 83FB00                  	CMP	BX,0			 ; nlsfunc finished it ?
  6915 00001A4A 7533                    	JNZ	SHORT international_copy ; no, copy by myself
  6916 00001A4C 89D3                    	MOV	BX,DX			 ; put country back
  6917 00001A4E EB3A                    	JMP	SHORT international_ok3
  6918                                  
  6919                                  international_get:
  6920                                  
  6921                                  ;hkn; country_cdpg is in DOSDATA segment.
  6922                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  6923 00001A50 BE[FD0F]                	MOV	SI,COUNTRY_CDPG
  6924                                  
  6925                                  	; MSDOS 6.0
  6926                                  	;CMP	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
  6927                                  	;retz				 ; return if equal
  6928                                  
  6929                                  	; MSDOS 3.3
  6930                                  	;cmp	bx,[SI+63h]
  6931 00001A53 3B5C63                  	CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  6932 00001A56 74CA                    	jz	short RET27
  6933                                  
  6934 00001A58 89DA                    	MOV	DX,BX
  6935 00001A5A 31DB                    	XOR	BX,BX			; bx = 0, default code page
  6936                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  6937                                  
  6938 00001A5C B80014                  	mov	ax,1400h
  6939 00001A5F CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  6940                                  			; Return: AL = 00h not installed, OK to install
  6941                                  			; 01h not installed, not OK
  6942                                  			; FFh installed
  6943                                  	
  6944 00001A61 3CFF                    	CMP	AL,0FFH
  6945 00001A63 7516                    	JNZ	short interr		; not in memory
  6946                                  	;cmp	bp,0
  6947 00001A65 09ED                    	or	bp,bp			; GetCntry ?
  6948 00001A67 7507                    	JNZ	short stcdpg
  6949                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  6950                                  
  6951 00001A69 B80414                  	mov     ax,1404h
  6952 00001A6C CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  6953                                  			; BX = code page, DX = country code,
  6954                                  			; DS:SI -> internal code page structure
  6955                                  			; ES:DI -> user buffer
  6956                                  			; Return: AL = status
  6957                                  
  6958 00001A6E EB05                    	JMP	short chkok
  6959                                  	
  6960                                  	;nop
  6961                                  
  6962                                  stcdpg:
  6963                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  6964                                  
  6965 00001A70 B80314                  	mov     ax,1403h
  6966 00001A73 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  6967                                  			; DS:SI -> internal code page structure
  6968                                  			; BX = code page, DX = country code
  6969                                  			; Return: AL = status
  6970                                  chkok:
  6971 00001A75 08C0                    	or	al,al			; success ?
  6972                                  	;retz				; yes
  6973 00001A77 74A9                    	jz	short RET27
  6974                                  
  6975                                  setcarry:
  6976 00001A79 F9                      	STC				; set carry
  6977 00001A7A C3                      	retn
  6978                                  interr:
  6979 00001A7B B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  6980 00001A7D EBFA                    	JMP	short setcarry
  6981                                  
  6982                                  international_copy:
  6983                                  
  6984                                  ;hkn; country_cdpg is in DOSDATA segment.
  6985                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  6986                                  	; MSDOS 6.0
  6987                                  	;MOV	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
  6988                                  	;MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccDFormat
  6989                                  
  6990                                  	; MSDOS 3.3
  6991                                  	;mov	bx,[SI+63h]
  6992 00001A7F 8B5C63                  	mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  6993 00001A82 BE[6410]                	mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  6994                                  
  6995                                  	;mov	cx,24
  6996 00001A85 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  6997                                  
  6998                                  	; MSDOS 6.0
  6999                                  ;hkn;	must set up DS to SS so that international info can be copied
  7000                                  	;push	ds
  7001                                  	;push	ss					; cs -> ss
  7002                                  	;pop	ds
  7003                                  
  7004 00001A88 F3A4                    	REP	MOVSB			;copy country info
  7005                                  
  7006                                  	; MSDOS 6.0
  7007                                  ;hkn;	restore ds
  7008                                  	;pop	ds
  7009                                  
  7010                                  international_ok3:
  7011 00001A8A E87EFB                  	call	Get_User_Stack
  7012                                  ;ASSUME	DS:NOTHING
  7013                                  	;MOV	[SI+2],BX
  7014 00001A8D 895C02                  	MOV	[SI+user_env.user_BX],BX
  7015                                  international_ok:
  7016 00001A90 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7017 00001A92 E968FC                  	jmp	SYS_RET_OK
  7018                                  
  7019                                  international_set:
  7020                                  
  7021                                  ;hkn; ASSUME	DS:DOSGROUP
  7022                                  ;ASSUME	DS:DOSDATA
  7023                                  
  7024 00001A95 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7025 00001A98 E8B5FF                  	CALL	international_get
  7026 00001A9B 73F3                    	JNC	short international_ok
  7027                                  errtn:
  7028 00001A9D 3CFF                    	CMP	AL,0FFH
  7029 00001A9F 7403                    	JZ	short errtn2
  7030                                  errtn1:
  7031 00001AA1 E962FC                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7032                                  errtn2:
  7033                                  	;error	error_invalid_function	; NLSFUNC not existent
  7034                                  
  7035                                  	;mov	al,1
  7036 00001AA4 B001                    	mov	al,error_invalid_function 
  7037                                  	;jmp	short errtn1
  7038                                  errtn3:
  7039 00001AA6 E95DFC                  	jmp	SYS_RET_ERR
  7040                                  
  7041                                  ;EndProc $INTERNATIONAL
  7042                                  
  7043                                  ; 19/07/2018
  7044                                  
  7045                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7046                                  
  7047                                  ;---------------------------------------------------------------------------
  7048                                  ;
  7049                                  ; Procedure Name : $GetExtCntry
  7050                                  ;
  7051                                  ; Inputs:
  7052                                  ;	if AL >= 20H
  7053                                  ;	  AL= 20H    capitalize single char, DL= char
  7054                                  ;	      21H    capitalize string, CX= string length
  7055                                  ;	      22H    capitalize ASCIIZ string
  7056                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7057                                  ;	      80H bit 0 = use normal upper case table
  7058                                  ;		      1 = use file upper case table
  7059                                  ;	   DS:DX points to string
  7060                                  ;
  7061                                  ;	else
  7062                                  ;
  7063                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7064                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7065                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7066                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7067                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7068                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7069                                  ;	INT	21
  7070                                  ; Function:
  7071                                  ;	give users extended country dependent information
  7072                                  ;	or capitalize chars
  7073                                  ; Outputs:
  7074                                  ;	  No Carry:
  7075                                  ;	     extended country info is succesfully returned
  7076                                  ;	  Carry:
  7077                                  ;	     Register AX has the error code.
  7078                                  ;	     AX=0, NO	 for YES/NO CHECK
  7079                                  ;		1, YES
  7080                                  ;-------------------------------------------------------------------------------
  7081                                  
  7082                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7083                                  
  7084                                  	; MSDOS 6.0
  7085                                  _$GetExtCntry:
  7086 00001AA9 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7087 00001AAB 7262                    	JB	short notcap
  7088                                  capcap: 				;
  7089 00001AAD A880                    	TEST	AL,UPPER_TABLE		; which upper case table
  7090 00001AAF 7505                    	JNZ	short fileupper		; file upper case
  7091                                  
  7092                                  ;hkn; UCASE_TAB in DOSDATA
  7093 00001AB1 BB[8810]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7094 00001AB4 EB03                    	JMP	SHORT capit
  7095                                  
  7096                                  fileupper:
  7097                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7098 00001AB6 BB[0A11]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7099                                  capit:					;
  7100 00001AB9 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7101 00001ABB 750D                    	JNZ	short chkyes		; no
  7102 00001ABD 88D0                    	MOV	AL,DL			; set up AL
  7103 00001ABF E86E3B                  	call	GETLET3 		; upper case it
  7104 00001AC2 E846FB                  	call	Get_User_Stack		; get user stack
  7105 00001AC5 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7106 00001AC8 EB1C                    	JMP	SHORT nono		; done
  7107                                  chkyes: 				;
  7108 00001ACA 3C23                    	CMP	AL,CHECK_YES_NO		; check YES or NO ?
  7109 00001ACC 751B                    	JNZ	short capstring		; no
  7110 00001ACE 31C0                    	XOR	AX,AX			; presume NO
  7111                                  		      
  7112                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7113                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7114                                  
  7115                                  	; 06/08/2018 - Retro DOS v3.0
  7116                                  	;CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7117 00001AD0 80FA59                  	cmp	DL,'Y'
  7118 00001AD3 7410                    	JZ	short yesyes		; yes
  7119                                  	;CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7120 00001AD5 80FA79                  	cmp	dl,'y'
  7121 00001AD8 740B                    	JZ	short yesyes		; yes
  7122 00001ADA 80FA4E                  	cmp	dl,'N'
  7123                                  	;CMP	DL,[cs:NLS_NO]		; is  'N'?
  7124 00001ADD 7407                    	JZ	short nono		; no
  7125 00001ADF 80FA6E                  	CMP	DL,'n'
  7126                                  	;CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7127 00001AE2 7402                    	JZ	short nono		; no
  7128                                  ;dbcs_char:				;
  7129 00001AE4 40                      	INC	AX			; not YES or NO
  7130                                  yesyes: 				;
  7131 00001AE5 40                      	INC	AX			; return 1
  7132                                  nono:					;
  7133 00001AE6 E914FC                  	jmp	SYS_RET_OK		; done
  7134                                  capstring:				;
  7135 00001AE9 89D6                    	MOV	SI,DX			; si=dx
  7136 00001AEB 3C21                    	CMP	AL,CAP_STRING		; cap string ?
  7137 00001AED 750F                    	JNZ	short capascii		; no
  7138 00001AEF 09C9                    	OR	CX,CX			; check count 0
  7139 00001AF1 74F3                    	JZ	short nono		; yes finished
  7140                                  concap: 				;
  7141 00001AF3 AC                      	LODSB				; get char
  7142 00001AF4 E8393B                  	call	GETLET3 		; upper case it
  7143 00001AF7 8844FF                  	MOV	byte [SI-1],AL		; store back
  7144                                  next99: 				;
  7145 00001AFA E2F7                    	LOOP	concap			; continue
  7146 00001AFC EBE8                    	JMP	short nono		; done
  7147                                  capascii:				;
  7148 00001AFE 3C22                    	CMP	AL,CAP_ASCIIZ		; cap ASCIIZ string ?
  7149 00001B00 7545                    	JNZ	short capinval		; no
  7150                                  concap2:				;
  7151 00001B02 AC                      	LODSB				; get char
  7152 00001B03 08C0                    	or	al,al			; end of string ?
  7153 00001B05 74DF                    	JZ	short nono		; yes
  7154 00001B07 E8263B                  	call	GETLET3 		; upper case it
  7155 00001B0A 8844FF                  	MOV	[SI-1],AL		; store back
  7156 00001B0D EBF3                    	JMP	short concap2 		; continue
  7157                                  
  7158                                  	; MSDOS 3.3 ($ MSDOS 6.0)
  7159                                  
  7160                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7161                                  ; _$GetExtCntry:
  7162                                  
  7163                                  notcap:
  7164 00001B0F 83F905                  	CMP	CX,5			; minimum size is 5
  7165 00001B12 7279                    	jb	short sizeerror
  7166                                  
  7167                                  GEC_CONT:
  7168                                  ;hkn; SS is DOSDATA
  7169                                  	;context DS
  7170                                  
  7171 00001B14 16                      	push	ss
  7172                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7173 00001B15 1F                      	pop	ds  ; 17/05/2019 - BugFix
  7174                                  	
  7175                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7176 00001B16 BE[FD0F]                	MOV	SI,COUNTRY_CDPG
  7177                                  
  7178 00001B19 83FAFF                  	CMP	DX,-1			; active country ?
  7179 00001B1C 7503                    	JNZ	short GETCDPG 		; no
  7180                                  
  7181                                  ;hkn; use DS override to accesss country_cdpg fields
  7182                                  	;mov	dx,[si+63h]
  7183 00001B1E 8B5463                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7184                                  					; get active country id;smr;use DS
  7185                                  GETCDPG:
  7186 00001B21 83FBFF                  	CMP	BX,-1			; active code page?
  7187 00001B24 7503                    	JNZ	short CHKAGAIN		; no, check again
  7188                                  
  7189                                  ;hkn; use DS override to accesss country_cdpg fields
  7190                                  	;mov	bx,[si+65h]
  7191 00001B26 8B5C65                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7192                                  					; get active code page id;smr;Use DS
  7193                                  CHKAGAIN:
  7194                                  	;cmp	dx,[si+63h]
  7195 00001B29 3B5463                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7196                                  					; same as active country id?;smr;use DS
  7197 00001B2C 7552                    	JNZ	short CHKNLS		; no
  7198                                  	;cmp	bx,[si+65h]
  7199 00001B2E 3B5C65                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7200                                  					; same as active code pg id?;smr;use DS
  7201 00001B31 754D                    	JNZ	short CHKNLS		; no
  7202                                  CHKTYPE:
  7203                                  	;mov	bx,[si+48h]
  7204 00001B33 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7205                                  					; bx = sys code page id;smr;use DS
  7206                                  ;	CMP	AL,SetALL		; select all?
  7207                                  ;	JNZ	short SELONE
  7208                                  ;	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccNumber_of_entries
  7209                                  ;SELONE:
  7210 00001B36 51                      	PUSH	CX			; save cx
  7211                                  	;mov	cx,[si+4Ah]
  7212 00001B37 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]	;smr;use DS
  7213 00001B3A BE[4910]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7214                                  NXTENTRY:
  7215 00001B3D 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7216 00001B3F 740B                    	JZ	short FOUNDIT
  7217 00001B41 83C605                  	ADD	SI,5			; next entry
  7218 00001B44 E2F7                    	LOOP	NXTENTRY
  7219 00001B46 59                      	POP	CX
  7220                                  capinval:
  7221                                  	;error	error_invalid_function	; info type not found
  7222                                  	;mov	al,1
  7223 00001B47 B001                    	mov	al,error_invalid_function
  7224 00001B49 E9BAFB                  	jmp	SYS_RET_ERR
  7225                                  
  7226                                  FOUNDIT:
  7227 00001B4C A4                      	MOVSB				; move info id byte
  7228 00001B4D 59                      	POP	CX			; retsore char count
  7229                                  	;cmp	al,1
  7230 00001B4E 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7231 00001B50 7415                    	JZ	short setsize
  7232 00001B52 B90400                  	MOV	CX,4			; 4 bytes will be moved
  7233 00001B55 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7234                                  OK_RETN:
  7235 00001B58 F3A4                    	REP	MOVSB			; copy info
  7236 00001B5A 89C1                    	MOV	CX,AX			; CX = actual length returned
  7237 00001B5C 89D8                    	MOV	AX,BX			; return sys code page in ax
  7238                                  GETDONE:
  7239 00001B5E E8AAFA                  	call	Get_User_Stack		; return actual length to user's CX
  7240                                  	;mov	[si+4],cx 
  7241 00001B61 894C04                  	MOV	[SI+user_env.user_CX],CX
  7242                                  	; 26/07/2019
  7243                                  	;jmp	SYS_RET_OK
  7244 00001B64 E999FB                  	jmp	SYS_RET_OK_clc
  7245                                  setsize:
  7246 00001B67 83E903                  	SUB	CX,3			; size after length field
  7247 00001B6A 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7248 00001B6C 7302                    	JAE	short setsize2		; no
  7249 00001B6E 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7250                                  setsize2:
  7251 00001B70 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7252 00001B73 83C702                  	ADD	DI,2			; update index
  7253 00001B76 83C602                  	ADD	SI,2
  7254 00001B79 89C8                    	MOV	AX,CX
  7255 00001B7B 83C003                  	ADD	AX,3			; AX has the actual length
  7256 00001B7E EBD8                    	JMP	short OK_RETN 		; go move it
  7257                                  CHKNLS:
  7258 00001B80 30E4                    	XOR	AH,AH
  7259 00001B82 50                      	PUSH	AX			; save info type
  7260 00001B83 5D                      	POP	BP			; bp = info type
  7261                                  	
  7262                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7263                                  
  7264 00001B84 B80014                  	mov     ax, 1400h
  7265 00001B87 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7266                                  			; Return: AL = 00h not installed, OK to install
  7267                                  			; 01h not installed, not OK
  7268                                  			; FFh installed
  7269                                  	
  7270 00001B89 3CFF                    	CMP	AL,0FFH
  7271 00001B8B 7405                    	JZ	short NLSNXT		; in memory
  7272                                  
  7273                                  sizeerror:
  7274                                  	;error	error_invalid_function
  7275                                  	;mov	al,1
  7276 00001B8D B001                    	mov	al,error_invalid_function
  7277 00001B8F E974FB                  	jmp	SYS_RET_ERR
  7278                                  
  7279                                  NLSNXT: 
  7280                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7281                                  
  7282 00001B92 B80214                  	mov     ax, 1402h
  7283 00001B95 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7284                                  			; BP = subfunction, BX = code page
  7285                                  			; DX = country code, DS:SI -> internal code page structure
  7286                                  			; ES:DI -> user buffer, CX = size of user buffer
  7287                                  			; Return: AL = status
  7288                                  			; 00h successful
  7289                                  			; else DOS error code
  7290                                  
  7291 00001B97 3C00                    	CMP	AL,0			; success ?
  7292 00001B99 7508                    	JNZ	short NLSERROR
  7293 00001B9B 8B4448                  	mov     ax,[si+48h]
  7294 00001B9E 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]	
  7295                                  			; ax = sys code page id;smr;use ds;
  7296                                  			;BUGBUG;check whether DS is OK after the above calls
  7297 00001BA1 EBBB                    	JMP	short GETDONE
  7298                                  NLSERROR:
  7299 00001BA3 E960FB                  	jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7300                                  
  7301                                  ;EndProc $GetExtCntry
  7302                                  
  7303                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7304                                  
  7305                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7306                                  ;
  7307                                  ;   System call format:
  7308                                  ;
  7309                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7310                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7311                                  ;	MOV	BX,CODE_PAGE	( set code page only)
  7312                                  ;	INT	21
  7313                                  ;
  7314                                  ;	ENTRY	(al) = n
  7315                                  ;		(bx) = code page
  7316                                  ;	EXIT	'C' clear
  7317                                  ;		  global code page is set	(set global code page)
  7318                                  ;		  (BX) = active code page id	(get global code page)
  7319                                  ;		  (DX) = system code page id	(get global code page)
  7320                                  ;		'C' set
  7321                                  ;		  (AX) = error code
  7322                                  
  7323                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7324                                  
  7325                                  _$GetSetCdPg:
  7326                                  
  7327                                  ;hkn; SS is DOSDATA
  7328                                  	;context DS
  7329                                  
  7330 00001BA6 16                      	push	ss
  7331 00001BA7 1F                      	pop	ds
  7332                                  
  7333                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7334 00001BA8 BE[FD0F]                	MOV	SI,COUNTRY_CDPG
  7335                                  
  7336 00001BAB 3C01                    	CMP	AL,1		       ; get global code page
  7337 00001BAD 7512                    	JNZ	short setglpg 	       ; set global cod epage
  7338                                  	;mov	bx,[si+65h]
  7339 00001BAF 8B5C65                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7340                                  					; get active code page id;smr;use ds
  7341                                  	;mov	dx,[si+48h]
  7342 00001BB2 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7343                                  				  	; get sys code page id;smr;use ds
  7344 00001BB5 E853FA                  	call	Get_User_Stack
  7345                                  ;ASSUME DS:NOTHING
  7346                                  	;mov	[si+2],bx
  7347 00001BB8 895C02                  	MOV	[SI+user_env.user_BX],BX ; update returned bx
  7348                                  	;mov	[si+6],dx
  7349 00001BBB 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7350                                  OK_RETURN:
  7351                                  	;transfer SYS_RET_OK
  7352 00001BBE E93CFB                  	jmp	SYS_RET_OK
  7353                                  
  7354                                  ;hkn; ASSUME DS:DOSGROUP
  7355                                  ;ASSUME	DS:DOSDATA
  7356                                  
  7357                                  setglpg:
  7358 00001BC1 3C02                    	CMP	AL,2
  7359 00001BC3 7534                    	JNZ	short nomem
  7360                                  ;;;;;;; CMP	BX,[SI+DOS_CCDPG.ccDosCodePage] ; same as active code page
  7361                                  ;;;;;;; JZ	short OK_RETURN		; yes
  7362                                  	;mov	dx,[si+63h]
  7363 00001BC5 8B5463                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7364                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7365 00001BC8 B80014                  	mov     ax, 1400h
  7366 00001BCB CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7367                                  			; Return: AL = 00h not installed, OK to install
  7368                                  			; 01h not installed, not OK
  7369                                  			; FFh installed
  7370 00001BCD 3CFF                    	CMP	AL,0FFH
  7371 00001BCF 7528                    	JNZ	short nomem		; not in memory
  7372                                  	;CallInstall SetCodePage,NLSFUNC,1  ;set the code page
  7373 00001BD1 B80114                  	mov     ax, 1401h
  7374 00001BD4 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7375                                  			; DS:SI -> internal code page structure
  7376                                  			; BX = new code page, DX = country code???
  7377                                  			; Return: AL = status
  7378                                  			; 00h successful
  7379                                  			; else DOS error code
  7380                                  	;cmp	al,0
  7381 00001BD6 08C0                    	or	al,al			   ; success ?
  7382 00001BD8 74E4                    	JZ	short OK_RETURN		   ; yes
  7383 00001BDA 3C41                    	CMP	AL,65			   ; set device code page failed
  7384 00001BDC 7518                    	JNZ	short seterr
  7385 00001BDE B84100                  	MOV	AX,65
  7386 00001BE1 A3[D202]                	MOV	[EXTERR],AX
  7387                                  	;mov	byte [EXTERR_ACTION],6
  7388                                  	;mov	byte [EXTERR_CLASS],5
  7389                                  	;mov	byte [EXTERR_LOCUS],4
  7390 00001BE4 C606[D402]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7391 00001BE9 C606[D502]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7392 00001BEE C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7393                                  	;transfer From_GetSet
  7394 00001BF3 E918FB                  	jmp	From_GetSet
  7395                                  
  7396                                  seterr:
  7397                                  	;transfer SYS_RET_ERR
  7398 00001BF6 E90DFB                  	jmp	SYS_RET_ERR
  7399                                  
  7400                                  nomem:
  7401                                  	;error	error_invalid_function ; function not defined
  7402                                  	;mov	al,1
  7403 00001BF9 B001                    	mov	al,error_invalid_function
  7404 00001BFB EBF9                    	jmp	short seterr
  7405                                  
  7406                                  ;EndProc $GetSetCdPg
  7407                                  
  7408                                  
  7409                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7410                                  
  7411                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7412                                  ;
  7413                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7414                                  ;		drive.
  7415                                  ;
  7416                                  ;	This call returns the same info in the same registers (except for the
  7417                                  ;	FAT pointer) as the old FAT pointer calls
  7418                                  ;
  7419                                  ;	ENTRY	DL = Drive number
  7420                                  ;	EXIT	AX = Sectors per allocation unit
  7421                                  ;		   = -1 if bad drive specified
  7422                                  ;		On User Stack
  7423                                  ;		    BX = Number of free allocation units
  7424                                  ;		    DX = Total Number of allocation units on disk
  7425                                  ;		    CX = Sector size
  7426                                  
  7427                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7428                                  
  7429                                  _$GET_DRIVE_FREESPACE:
  7430                                  
  7431                                  ;hkn; SS is DOSDATA
  7432                                  	;context DS
  7433 00001BFD 16                      	push	ss
  7434 00001BFE 1F                      	pop	ds
  7435                                  
  7436 00001BFF 88D0                    	MOV	AL,DL
  7437                                  	;invoke	GetThisDrv		; Get drive
  7438 00001C01 E8704D                  	call	GETTHISDRV
  7439                                  SET_AX_RET:
  7440 00001C04 7218                    	JC	short BADFDRV
  7441                                  	;invoke	DISK_INFO
  7442 00001C06 E8A61C                  	call	DISK_INFO
  7443 00001C09 87D3                    	XCHG	DX,BX
  7444 00001C0B 72F7                    	JC	short SET_AX_RET	; User FAILed to I 24
  7445 00001C0D 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7446                                  DoSt:
  7447 00001C0F E8F9F9                  	call	Get_User_Stack
  7448                                  ;ASSUME	DS:NOTHING
  7449                                  	;mov	[si+6],dx
  7450                                  	;mov	[si+4],cx
  7451                                  	;mov	[si+2],bx
  7452 00001C12 895406                  	MOV	[SI+user_env.user_DX],DX
  7453 00001C15 894C04                  	MOV	[SI+user_env.user_CX],CX
  7454 00001C18 895C02                  	MOV	[SI+user_env.user_BX],BX
  7455                                  	;MOV	[SI+user_env.user_AX],AX
  7456 00001C1B 8904                    	mov     [si],ax
  7457                                  	;return
  7458 00001C1D C3                      	retn
  7459                                  
  7460                                  BADFDRV:
  7461                                  	; MSDOS 3.3
  7462                                  	;mov	al,0Fh
  7463 00001C1E B00F                    	mov	al,error_invalid_drive	; Assume error
  7464                                  
  7465                                  	;invoke	FCB_RET_ERR
  7466 00001C20 E8F9FA                  	call	FCB_RET_ERR
  7467 00001C23 B8FFFF                  	MOV	AX,-1
  7468 00001C26 EBE7                    	JMP	short DoSt
  7469                                  
  7470                                  ;EndProc $GET_DRIVE_FREESPACE
  7471                                  
  7472                                  
  7473                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7474                                  
  7475                                  ;**	$Get_DMA - Get Disk Transfer Address
  7476                                  ;
  7477                                  ;	ENTRY	none
  7478                                  ;	EXIT	ES:BX is current transfer address
  7479                                  ;	USES	all
  7480                                  
  7481                                  _$GET_DMA:
  7482 00001C28 368B1E[DA02]            	MOV	BX,[SS:DMAADD]
  7483 00001C2D 368B0E[DC02]            	MOV	CX,[SS:DMAADD+2]
  7484 00001C32 E8D6F9                  	call	Get_User_Stack
  7485                                  	;mov	[si+2],bx
  7486                                  	;mov	[si+10h],cx
  7487 00001C35 895C02                  	MOV	[SI+user_env.user_BX],BX
  7488 00001C38 894C10                  	MOV	[SI+user_env.user_ES],CX
  7489 00001C3B C3                      	retn
  7490                                  
  7491                                  ;**	$Set_DMA - Set Disk Transfer Address
  7492                                  ;
  7493                                  ;	ENTRY	DS:DX is current transfer address
  7494                                  ;	EXIT	none
  7495                                  ;	USES	all
  7496                                  
  7497                                  _$SET_DMA:
  7498 00001C3C 368916[DA02]            	MOV	[SS:DMAADD],DX
  7499 00001C41 368C1E[DC02]            	MOV	[SS:DMAADD+2],DS
  7500 00001C46 C3                      	retn
  7501                                  
  7502                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7503                                  
  7504                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7505                                  ;
  7506                                  ;	ENTRY	none
  7507                                  ;	EXIT	(AL) = drive number
  7508                                  ;	USES	all
  7509                                  
  7510                                  _$GET_DEFAULT_DRIVE:
  7511 00001C47 36A0[E402]              	MOV	AL,[SS:CURDRV]
  7512 00001C4B C3                      	retn
  7513                                  
  7514                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7515                                  ;
  7516                                  ;	ENTRY	(DL) = Drive number for new default drive
  7517                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7518                                  
  7519                                  _$SET_DEFAULT_DRIVE:
  7520 00001C4C 88D0                    	MOV	AL,DL
  7521 00001C4E FEC0                    	INC	AL			; A=1, B=2...
  7522 00001C50 E80A4D                  	call	GetVisDrv		; see if visible drive
  7523 00001C53 7204                    	JC	short SETRET		; errors do not set
  7524 00001C55 36A2[E402]              	MOV	[SS:CURDRV],AL		; no, set
  7525                                  
  7526                                  SETRET:
  7527 00001C59 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7528 00001C5D C3                      	retn
  7529                                  
  7530                                  
  7531                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7532                                  
  7533                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7534                                  ;
  7535                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7536                                  ;	contents of an interrupt vector.
  7537                                  ;
  7538                                  ;	ENTRY	(AL) = interrupt number
  7539                                  ;	EXIT	(ES:BX) = current interrupt vector
  7540                                  
  7541                                  _$GET_INTERRUPT_VECTOR:
  7542 00001C5E E81A00                  	CALL	RECSET
  7543 00001C61 26C41F                  	LES	BX,[ES:BX]
  7544 00001C64 E8A4F9                  	call	Get_User_Stack
  7545                                  	;mov	[si+2],bx
  7546                                  	;mov	[si+10h],es
  7547 00001C67 895C02                  	MOV	[SI+user_env.user_BX],BX
  7548 00001C6A 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7549 00001C6D C3                      	retn
  7550                                  
  7551                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7552                                  ;
  7553                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7554                                  ;	contents of an interrupt vector.
  7555                                  ;
  7556                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7557                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7558                                  ;	for explanation.
  7559                                  ;
  7560                                  ;	ENTRY	(AL) = interrupt number
  7561                                  ;		(ds:dx) = desired new vector value
  7562                                  ;	EXIT	none
  7563                                  ;	USES	all
  7564                                  
  7565                                  _$SET_INTERRUPT_VECTOR:
  7566 00001C6E E80A00                  	CALL	RECSET
  7567 00001C71 FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7568 00001C72 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7569 00001C75 268C5F02                	MOV	[ES:BX+2],DS
  7570 00001C79 FB                      	STI
  7571                                  					; M004, M068 - Start
  7572                                  	; MSDOS 6.0
  7573                                  	;test	byte [DOS_FLAG],EXECA20OFF
  7574                                  					; Q: was the previous call an int 21
  7575                                  					;    exec call
  7576                                  	;jnz	short siv_1		; Y: go set count
  7577 00001C7A C3                      	retn				; N: return
  7578                                  
  7579                                  ;siv_1:	
  7580                                  	;cmp	byte [A20OFF_COUNT],0	; Q: is count 0
  7581                                  	;jne	short siv_2		; N: done 
  7582                                  	;mov	byte [A20OFF_COUNT],1	; Y: set it to 1 to indicate to dos 
  7583                                  					; dispatcher to turn A20 Off before 
  7584                                  					; returning to user.
  7585                                  ;siv_2:
  7586                                  	;retn				; M004, M068 - End
  7587                                  	
  7588                                  RECSET:
  7589 00001C7B 31DB                    	XOR	BX,BX
  7590 00001C7D 8EC3                    	MOV	ES,BX
  7591 00001C7F 88C3                    	MOV	BL,AL
  7592 00001C81 D1E3                    	SHL	BX,1
  7593 00001C83 D1E3                    	SHL	BX,1
  7594 00001C85 C3                      	retn
  7595                                  
  7596                                  
  7597                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7598                                  
  7599                                  ;**	$Char_Oper - Manipulate Switch Character
  7600                                  ;
  7601                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7602                                  ;
  7603                                  ;	ENTRY	AL = function:
  7604                                  ;		    0 - read switch char
  7605                                  ;		    1 - set switch char (char in DL)
  7606                                  ;		    2 - read device availability
  7607                                  ;			Always returns available
  7608                                  ;		    3 - set device availability
  7609                                  ;			No longer supported (NOP)
  7610                                  ;	EXIT	(al) = 0xff iff error
  7611                                  ;		(al) != 0xff if ok
  7612                                  ;		  (dl) = character/flag, iff "read switch char" subfunction
  7613                                  ;	USES	AL, DL
  7614                                  ;
  7615                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7616                                  ;		The character / is always returned for subfunction 0,
  7617                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7618                                  
  7619                                  _$CHAR_OPER:
  7620                                  	; MSDOS 6.0
  7621                                  	;or	al,al				; get switch?
  7622                                  	;mov	dl,'/'				; assume yes
  7623                                  	;jz	short chop_1			; jump if yes
  7624                                  	;cmp	al,2				; check device availability?
  7625                                  	;mov	dl,-1				; assume yes
  7626                                  	;jz	short chop_1				; jump if yes
  7627                                  	;retn					; otherwise just quit
  7628                                  
  7629                                  ; subfunctions requiring return of value to user come here.  DL holds
  7630                                  ; value to return
  7631                                  
  7632                                  ;chop_1:
  7633                                  	;call	Get_User_Stack
  7634                                  	;mov	[SI+user_env.user_DX],dx	; store value for user
  7635                                  	;retn
  7636                                  
  7637                                  	; MSDOS 3.3
  7638                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7639 00001C86 16                      	push    ss
  7640 00001C87 1F                      	pop     ds
  7641 00001C88 3C01                    	cmp     al, 1
  7642 00001C8A 720B                    	jb      short chop_1
  7643 00001C8C 740F                    	jz      short chop_2
  7644 00001C8E 3C03                    	cmp     al, 3
  7645 00001C90 7210                    	jb      short chop_3
  7646 00001C92 7416                    	jz      short chop_5
  7647 00001C94 B0FF                    	mov     al, 0FFh
  7648 00001C96 C3                      	retn
  7649                                  chop_1:
  7650 00001C97 8A16[AF02]              	mov     dl,[chSwitch]
  7651 00001C9B EB07                    	jmp     short chop_4
  7652                                  chop_2:
  7653 00001C9D 8816[AF02]              	mov     [chSwitch], dl
  7654 00001CA1 C3                      	retn
  7655                                  chop_3:
  7656 00001CA2 B2FF                    	mov     dl, 0FFh
  7657                                  chop_4:
  7658 00001CA4 E864F9                  	call    Get_User_Stack
  7659 00001CA7 895406                  	mov     [si+6],dx
  7660                                  chop_5:
  7661 00001CAA C3                      	retn
  7662                                  
  7663                                  
  7664                                  ;**	$GetExtendedError - Return Extended error code
  7665                                  ;
  7666                                  ;	This function reads up the extended error info from the static
  7667                                  ;	variables where it was stored.
  7668                                  ;
  7669                                  ;	ENTRY	none
  7670                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7671                                  ;		BL = recommended action
  7672                                  ;		BH = class of error
  7673                                  ;		CH = locus of error
  7674                                  ;		ES:DI = may be pointer
  7675                                  ;	USES	ALL
  7676                                  
  7677                                  _$GetExtendedError:
  7678 00001CAB 16                      	push	ss
  7679 00001CAC 1F                      	pop	ds
  7680 00001CAD A1[D202]                	MOV	AX,[EXTERR]
  7681 00001CB0 C43E[D602]              	LES	DI,[EXTERRPT]
  7682 00001CB4 8B1E[D402]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7683 00001CB8 8A2E[D102]              	MOV	CH,[EXTERR_LOCUS]
  7684 00001CBC E84CF9                  	call	Get_User_Stack
  7685                                  	;mov	[si+0Ah],di
  7686 00001CBF 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7687                                  	;mov	[si+10h],es
  7688 00001CC2 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7689                                  	;mov	[si+2],bx
  7690 00001CC5 895C02                  	MOV	[SI+user_env.user_BX],BX
  7691                                  	;mov	[si+4],cx
  7692 00001CC8 894C04                  	MOV	[SI+user_env.user_CX],CX
  7693                                  	;jmp	SYS_RET_OK
  7694                                  	; 26/07/2019
  7695 00001CCB E932FA                  	jmp	SYS_RET_OK_clc
  7696                                  
  7697                                  ;============================================================================
  7698                                  ; PARSE.ASM, MSDOS 6.0, 1991
  7699                                  ;============================================================================
  7700                                  ; 19/07/2018 - Retro DOS v3.0
  7701                                  
  7702                                  ; System calls for parsing command lines
  7703                                  ;
  7704                                  ;   $PARSE_FILE_DESCRIPTOR
  7705                                  ;
  7706                                  ;   Modification history:
  7707                                  ;
  7708                                  ;       Created: ARR 30 March 1983
  7709                                  ;               EE PathParse 10 Sept 1983
  7710                                  ;
  7711                                  
  7712                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  7713                                  ;---------------------------------------------------------------------------
  7714                                  ; Inputs:
  7715                                  ;       DS:SI Points to a command line
  7716                                  ;       ES:DI Points to an empty FCB
  7717                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  7718                                  ;                   = 0 Parse stops if separator encountered
  7719                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  7720                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  7721                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  7722                                  ;                   = 0  "       "      "       - put blanks in FCB
  7723                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  7724                                  ;                   = 0  "       "      "        - put blanks in FCB
  7725                                  ; Function:
  7726                                  ;       Parse command line into FCB
  7727                                  ; Returns:
  7728                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  7729                                  ;       DS:SI points to first character after filename
  7730                                  ;---------------------------------------------------------------------------
  7731                                  
  7732                                  _$PARSE_FILE_DESCRIPTOR:
  7733 00001CCE E85938                  	call	MAKEFCB
  7734 00001CD1 56                      	PUSH    SI
  7735 00001CD2 E836F9                  	call	Get_User_Stack
  7736                                  	;pop	word [si+8]
  7737 00001CD5 8F4408                  	POP     word [SI+user_env.user_SI]
  7738 00001CD8 C3                      	retn
  7739                                  
  7740                                  ;============================================================================
  7741                                  ; MISC.ASM, MSDOS 6.0, 1991
  7742                                  ;============================================================================
  7743                                  ; 19/07/2018 - Retro DOS v3.0
  7744                                  
  7745                                  ;ENTRYPOINTSEG	EQU	0CH
  7746                                  ;MAXDIF		EQU	0FFFH
  7747                                  ;SAVEXIT 	EQU	10
  7748                                  ;WRAPOFFSET	EQU	0FEF0h
  7749                                  
  7750                                  ;
  7751                                  ;----------------------------------------------------------------------------
  7752                                  ;
  7753                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  7754                                  ;
  7755                                  ;	Return Stuff sort of like old get fat call
  7756                                  ;
  7757                                  ;	ENTRY	none
  7758                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7759                                  ;			GOD help anyone who tries to do ANYTHING except
  7760                                  ;			READ this ONE byte.
  7761                                  ;		DX = Total Number of allocation units on disk
  7762                                  ;		CX = Sector size
  7763                                  ;		AL = Sectors per allocation unit
  7764                                  ;		   = -1 if bad drive specified
  7765                                  ;	USES	all
  7766                                  ;
  7767                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  7768                                  ;
  7769                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  7770                                  ;
  7771                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  7772                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7773                                  ;			GOD help anyone who tries to do ANYTHING except
  7774                                  ;			READ this ONE byte.
  7775                                  ;		DX = Total Number of allocation units on disk
  7776                                  ;		CX = Sector size
  7777                                  ;		AL = Sectors per allocation unit
  7778                                  ;		   = -1 if bad drive specified
  7779                                  ;	USES	all
  7780                                  ;
  7781                                  ;----------------------------------------------------------------------------
  7782                                  ;
  7783                                  
  7784                                  _$SLEAZEFUNC:
  7785 00001CD9 B200                    	MOV	DL,0
  7786                                  
  7787                                  _$SLEAZEFUNCDL:
  7788 00001CDB 16                      	push	ss
  7789 00001CDC 1F                      	pop	ds
  7790                                  	
  7791 00001CDD 88D0                    	MOV	AL,DL
  7792 00001CDF E8924C                  	call	GETTHISDRV		; Get CDS structure
  7793                                  SET_AL_RET:
  7794                                  	; MSDOS 3.3
  7795                                  	;mov	al, 0Fh
  7796 00001CE2 B00F                    	MOV	AL,error_invalid_drive	; Assume error	;AC000;
  7797                                  
  7798 00001CE4 721E                    	JC	short BADSLDRIVE
  7799                                  
  7800 00001CE6 E8C61B                  	call	DISK_INFO
  7801 00001CE9 72F7                    	JC	short SET_AL_RET	; User FAILed to I 24
  7802 00001CEB 8826[3005]              	MOV	[FATBYTE],AH
  7803                                  
  7804                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  7805                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  7806                                  ; CALL AGAIN
  7807                                  
  7808 00001CEF BF[3005]                	MOV	DI,FATBYTE
  7809 00001CF2 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  7810 00001CF4 E814F9                  	call	Get_User_Stack
  7811                                  	;mov	[si+4],cx
  7812                                  	;mov	[si+6],bx
  7813                                  	;mov	[si+2],di
  7814 00001CF7 894C04                  	MOV	[SI+user_env.user_CX],CX
  7815 00001CFA 895C06                  	MOV	[SI+user_env.user_DX],BX
  7816 00001CFD 897C02                  	MOV	[SI+user_env.user_BX],DI
  7817                                  	
  7818                                  	;mov	[si+0Eh],cs
  7819                                  	;mov	[SI+user_env.user_DS],SS
  7820 00001D00 8C4C0E                  	MOV     [SI+user_env.user_DS],CS ; stash correct pointer
  7821                                  
  7822 00001D03 C3                      	retn
  7823                                  
  7824                                  BADSLDRIVE:
  7825 00001D04 E915FA                  	jmp	FCB_RET_ERR
  7826                                  
  7827                                  ;
  7828                                  ;----------------------------------------------------------------------------
  7829                                  ;
  7830                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  7831                                  ;
  7832                                  ;	Returns location of DOS status for interrupt routines
  7833                                  ;									   ;
  7834                                  ;	ENTRY	none
  7835                                  ;	EXIT	(es:bx) = flag location
  7836                                  ;	USES	all
  7837                                  ;
  7838                                  ;----------------------------------------------------------------------------
  7839                                  ;
  7840                                  
  7841                                  _$GET_INDOS_FLAG:
  7842 00001D07 E801F9                          CALL	Get_User_Stack
  7843                                          ;MOV	WORD [SI+2],INDOS
  7844 00001D0A C74402[CF02]            	MOV     word [SI+user_env.user_BX],INDOS
  7845                                          ;MOV	[SI+10H],SS
  7846 00001D0F 8C5410                  	MOV	[SI+user_env.user_ES],SS
  7847 00001D12 C3                      	RETN 
  7848                                  
  7849                                  ;
  7850                                  ;----------------------------------------------------------------------------
  7851                                  ;
  7852                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  7853                                  ;
  7854                                  ;	Return a pointer to interesting DOS variables This call is version
  7855                                  ;	dependent and is subject to change without notice in future versions.
  7856                                  ;	Use at risk.
  7857                                  ;
  7858                                  ;	ENTRY	none
  7859                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  7860                                  ;	uses	ALL
  7861                                  ;
  7862                                  ;----------------------------------------------------------------------------
  7863                                  ;
  7864                                  
  7865                                  _$GET_IN_VARS:
  7866 00001D13 E8F5F8                          CALL	Get_User_Stack
  7867                                          ;MOV	WORD [SI+2],SYSINITVAR
  7868                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  7869 00001D16 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  7870                                          ;MOV	[SI+10H],SS
  7871 00001D1B 8C5410                  	MOV	[SI+user_env.user_ES],SS
  7872 00001D1E C3                      	RETN
  7873                                  
  7874                                  ;
  7875                                  ;----------------------------------------------------------------------------
  7876                                  ;
  7877                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  7878                                  ;
  7879                                  ;	Return pointer to drive parameter table for default drive
  7880                                  ;
  7881                                  ;	ENTRY	none
  7882                                  ;	EXIT	(ds:bx) = DPB address
  7883                                  ;	USES	all
  7884                                  ;
  7885                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  7886                                  ;
  7887                                  ;	Return pointer to a specified drive parameter table
  7888                                  ;
  7889                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  7890                                  ;	EXIT	(al) = 0 iff ok
  7891                                  ;		  (ds:bx) = DPB address
  7892                                  ;		(al) = -1 if bad drive
  7893                                  ;	USES	all
  7894                                  ;
  7895                                  ;----------------------------------------------------------------------------
  7896                                  ;
  7897                                  
  7898                                  _$GET_DEFAULT_DPB:
  7899 00001D1F B200                    	MOV	DL,0
  7900                                  _$GET_DPB:
  7901 00001D21 16                      	push	ss
  7902 00001D22 1F                      	pop	ds
  7903                                  
  7904 00001D23 88D0                    	MOV	AL,DL
  7905 00001D25 E84C4C                  	call	GETTHISDRV		; Get CDS structure
  7906 00001D28 7223                    	JC	short ISNODRV 		; no valid drive
  7907 00001D2A C43E[3A05]              	LES	DI,[THISCDS]		; check for net CDS
  7908                                  	;test	word [es:di+43h],8000h
  7909 00001D2E 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
  7910 00001D34 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  7911 00001D36 E82A03                  	call	EcritDisk
  7912 00001D39 E8823E                  	call	FATREAD_CDS		; Force Media Check and return DPB
  7913 00001D3C E82C03                  	call	LcritDisk
  7914 00001D3F 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  7915                                  					;   have.
  7916 00001D41 E8C7F8                  	call	Get_User_Stack
  7917                                  	;mov	[si+2],bp
  7918                                  	;mov	[si+0Eh],es
  7919 00001D44 896C02                  	MOV	[SI+user_env.user_BX],BP
  7920 00001D47 8C440E                  	MOV	[SI+user_env.user_DS],ES
  7921 00001D4A 30C0                    	XOR	AL,AL
  7922 00001D4C C3                      	retn
  7923                                  ISNODRV:
  7924 00001D4D B0FF                    	MOV	AL,-1
  7925 00001D4F C3                      	retn
  7926                                  
  7927                                  ;
  7928                                  ;----------------------------------------------------------------------------
  7929                                  ;
  7930                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  7931                                  ;
  7932                                  ;	$DiskReset flushes and invalidates all buffers. BUGBUG - do
  7933                                  ;		we really invalidate? SHould we? THis screws non-removable
  7934                                  ;		caching. Maybe CHKDSK relies upon it, though....
  7935                                  ;
  7936                                  ;	ENTRY	none
  7937                                  ;	EXIT	none
  7938                                  ;	USES	all
  7939                                  ;
  7940                                  ;----------------------------------------------------------------------------
  7941                                  ;
  7942                                  
  7943                                  _$DISK_RESET:
  7944 00001D50 16                      	push	ss
  7945 00001D51 1F                      	pop	ds
  7946 00001D52 B0FF                    	MOV	AL,-1
  7947 00001D54 E80C03                  	call	EcritDisk
  7948                                  	; MSDOS 6.0
  7949                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  7950 00001D57 E8D641                  	call	FLUSHBUF
  7951                                  	; MSDOS 6.0
  7952                                  	;AND	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  7953                                  	;mov	word [SC_STATUS],0	; Throw out secondary cache M041
  7954                                  ;
  7955                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  7956                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  7957                                  ; let's do it.
  7958                                  ;
  7959                                  ; Invalidate 'last-buffer' used
  7960                                  ;
  7961 00001D5A BBFFFF                  	MOV	BX,-1
  7962 00001D5D 891E[2000]              	MOV	[LastBuffer+2],BX
  7963 00001D61 891E[1E00]              	MOV	[LastBuffer],BX
  7964                                  
  7965                                  	; MSDOS 3.3 
  7966                                  	; IBMDOS.COM, Offset 1C66h
  7967                                  	;;;;
  7968 00001D65 C536[3800]              	lds     si,[BUFFHEAD]
  7969 00001D69 B8FF20                  	mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  7970                                  				; .buf_flags, AH = 0, reset/clear
  7971                                  DRST_1:
  7972                                  	; 25/07/2019 - Retro DOS v3.2
  7973                                  	;;mov	[si+4],ax
  7974                                  	;mov	[si+BUFFINFO.buf_ID],ax
  7975                                  	;lds	si,[SI]
  7976                                  	;cmp	si,bx ; -1
  7977                                  	;je	short DRST_2
  7978                                  
  7979                                  	;mov	[si+4],ax
  7980 00001D6C 894404                  	mov	[si+BUFFINFO.buf_ID],ax
  7981 00001D6F C534                    	lds	si,[SI]
  7982 00001D71 39DE                    	cmp	si,bx
  7983 00001D73 75F7                    	jne	short DRST_1
  7984                                  	;;;;
  7985                                  DRST_2:
  7986 00001D75 E8F302                  	call	LcritDisk
  7987                                  
  7988                                  	; 20/05/2019
  7989                                  	;MOV	AX,-1
  7990                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  7991                                  	;mov	ax,0FFFFh
  7992                                  
  7993 00001D78 B82011                  	mov     ax,1120h
  7994 00001D7B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  7995                                  			; DS = DOS CS
  7996                                  			; Return: CF clear (successful)
  7997 00001D7D C3                      	retn
  7998                                  
  7999                                  	; 19/07/2018 - Retro DOS v3.0
  8000                                  
  8001                                  ;
  8002                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8003                                  ;
  8004                                  ;----------------------------------------------------------------------------
  8005                                  ;
  8006                                  ;**	$SetDPB - Create a DPB
  8007                                  ;
  8008                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8009                                  ;
  8010                                  ;	ENTRY	ES:BP Points to DPB
  8011                                  ;		DS:SI Points to BPB
  8012                                  ;	EXIT	DPB setup
  8013                                  ;	USES	ALL but BP, DS, ES
  8014                                  ;
  8015                                  ;----------------------------------------------------------------------------
  8016                                  ;
  8017                                  
  8018                                  ; MSDOS 6.0
  8019 00001D7E 0300                    word3:	dw	3			; M008 -- word value for divides
  8020                                  
  8021                                  ;procedure   $SETDPB,NEAR
  8022                                  
  8023                                  _$SETDPB:
  8024 00001D80 89EF                    	MOV	DI,BP
  8025 00001D82 83C702                  	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8026 00001D85 AD                      	LODSW
  8027 00001D86 AB                      	STOSW				; dpb_sector_size
  8028                                  	; MSDOS 6.0
  8029 00001D87 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8030 00001D8B 7507                    	JNZ	short yesfat			     ; yes		;AN000;
  8031 00001D8D 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8032 00001D92 EB50                    	JMP	short setend			     ; NO		;AN000;
  8033                                  yesfat: ; 10/08/2018
  8034 00001D94 89C2                    	MOV	DX,AX
  8035 00001D96 AC                      	LODSB
  8036 00001D97 FEC8                    	DEC	AL
  8037 00001D99 AA                      	STOSB				; dpb_cluster_mask
  8038 00001D9A FEC0                    	INC	AL
  8039 00001D9C 30E4                    	XOR	AH,AH
  8040                                  LOG2LOOP:
  8041 00001D9E A801                    	test	AL,1
  8042 00001DA0 7506                    	JNZ	short SAVLOG
  8043 00001DA2 FEC4                    	INC	AH
  8044 00001DA4 D0E8                    	SHR	AL,1
  8045 00001DA6 EBF6                    	JMP	SHORT LOG2LOOP
  8046                                  SAVLOG:
  8047 00001DA8 88E0                    	MOV	AL,AH
  8048 00001DAA AA                      	STOSB				; dpb_cluster_shift
  8049 00001DAB 88C3                    	MOV	BL,AL
  8050 00001DAD A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8051 00001DAE AC                      	LODSB
  8052 00001DAF AA                      	STOSB				; dpb_FAT_count Number of FATs
  8053                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8054                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8055 00001DB0 88C7                    	MOV	BH,AL
  8056 00001DB2 AD                      	LODSW
  8057 00001DB3 AB                      	STOSW				; dpb_root_entries Number of directory entries
  8058 00001DB4 B105                    	MOV	CL,5
  8059 00001DB6 D3EA                    	SHR	DX,CL			; Directory entries per sector
  8060 00001DB8 48                      	DEC	AX
  8061 00001DB9 01D0                    	ADD	AX,DX			; Cause Round Up
  8062 00001DBB 89D1                    	MOV	CX,DX
  8063 00001DBD 31D2                    	XOR	DX,DX
  8064 00001DBF F7F1                    	DIV	CX
  8065 00001DC1 89C1                    	MOV	CX,AX			; Number of directory sectors
  8066 00001DC3 47                      	INC	DI
  8067 00001DC4 47                      	INC	DI			; Skip dpb_first_sector
  8068 00001DC5 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8069 00001DC6 AC                      	LODSB
  8070                                  	;mov	[es:bp+16h],al
  8071 00001DC7 26884616                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8072 00001DCB AD                      	LODSW				; Number of sectors in a FAT
  8073                                  	;;;
  8074                                  	;MSDOS 6.0
  8075                                  	;
  8076                                  	;STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8077                                  	;MOV	DL,BH			;AN000;;>32mb
  8078                                  	;XOR	DH,DH			;AN000;;>32mb
  8079                                  	;MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8080                                  	
  8081                                  	;MSDOS 3.3
  8082                                  	;
  8083 00001DCC AA                      	STOSB		; DPB.FAT_SIZE
  8084 00001DCD F6E7                    	MUL	BH
  8085                                  	;;;
  8086                                  	;add	ax,[es:bp+6]
  8087 00001DCF 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8088 00001DD3 AB                      	STOSW				; dpb_dir_sector
  8089 00001DD4 01C8                    	ADD	AX,CX			; Add number of directory sectors
  8090                                  	;mov	[es:bp+0Bh],ax
  8091 00001DD6 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8092                                  	
  8093                                  	; MSDOS 6.0
  8094 00001DDA 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8095                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8096                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8097                                  	;XOR	CH,CH			;F.C. >32mb				;AN000;
  8098                                  	;MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8099                                  	;MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8100                                  	;SUB	BX,AX			;AN000;;F.C. >32mb
  8101                                  	;SBB	DX,0			;AN000;;F.C. >32mb
  8102                                  	;OR	CX,CX			;AN000;;F.C. >32mb
  8103                                  	;JZ	short norot		;AN000;;F.C. >32mb
  8104                                  ;rott:					;AN000;;F.C. >32mb
  8105                                  	;CLC				;AN000;;F.C. >32mb
  8106                                  	;RCR	DX,1			;AN000;;F.C. >32mb
  8107                                  	;RCR	BX,1			;AN000;;F.C. >32mb
  8108                                  	;LOOP	rott			;AN000;;F.C. >32mb
  8109                                  ;norot:					;AN000;
  8110                                  	;MOV	AX,BX			;AN000;;F.C. >32mb
  8111                                  	;JMP	short setend		;AN000;;F.C. >32mb
  8112                                  normal_dpb:
  8113                                  	;sub	ax,[es:bp+0Dh]
  8114 00001DDC 262B460D                	SUB	AX,[ES:BP+DSKSIZ]
  8115 00001DE0 F7D8                    	NEG	AX			; Sectors in data area
  8116                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8117 00001DE2 D3E8                    	SHR	AX,CL			; Div by sectors/cluster
  8118                                  setend:
  8119                                  
  8120                                  ;	M008 - CAS
  8121                                  ;
  8122 00001DE4 40                      	INC	AX			; +2 (reserved), -1 (count -> max)
  8123                                  ;
  8124                                  ;	There has been a bug in our fatsize calculation for so long
  8125                                  ;	  that we can't correct it now without causing some user to
  8126                                  ;	  experience data loss. There are even cases where allowing
  8127                                  ;	  the number of clusters to exceed the fats is the optimal
  8128                                  ;	  case -- where adding 2 more fat sectors would make the
  8129                                  ;	  data field smaller so that there's nothing to use the extra
  8130                                  ;	  fat sectors for.
  8131                                  ;
  8132                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8133                                  ;	  still report that there was a cluster left when the disk was
  8134                                  ;	  actually full. Very graceful failure for a corrupt system
  8135                                  ;	  configuration. There may be worse cases that were never
  8136                                  ;	  properly traced back to this bug. The problem cases only
  8137                                  ;	  occurred when partition sizes were very near FAT sector
  8138                                  ;	  rounding boundaries, which were rare cases.
  8139                                  ;
  8140                                  ;	Also, it's possible that some third-party partition program might
  8141                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8142                                  ;	  scheme. In this hypothetical case, the number of allocation
  8143                                  ;	  clusters which don't actually have FAT entries to represent
  8144                                  ;	  them might be larger and might create a more catastrophic
  8145                                  ;	  failure. So we'll provide the safeguard of limiting the
  8146                                  ;	  max_cluster to the amount that will fit in the FATs.
  8147                                  ;
  8148                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8149                                  
  8150                                  ;	make sure the number of fat sectors is actually enough to
  8151                                  ;	  hold that many clusters. otherwise, back the number of
  8152                                  ;	  clusters down
  8153                                  
  8154                                  	; 19/07/2018 - Retro DOS v3.0
  8155                                  	; MSDOS 6.0
  8156 00001DE5 89C3                    	mov	bx,ax			; remember calculated # clusters
  8157                                  	;;mov	ax,[ES:BP+0Fh]
  8158                                  	;mov	ax,[ES:BP+DPB.FAT_SIZE]
  8159                                  	; 01/08/2018 (MSDOS 3.3)
  8160 00001DE7 268A460F                	mov	al,[ES:BP+DPB.FAT_SIZE]
  8161 00001DEB 30E4                    	xor	ah,ah 	
  8162 00001DED 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8163 00001DF1 81FBF60F                	cmp	bx,4096-10		; test for 12 vs. 16 bit fat
  8164 00001DF5 720D                    	jb	short setend_fat12
  8165 00001DF7 D1EA                    	shr	dx,1
  8166                                  ;cs3 7/2/92
  8167 00001DF9 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8168                                  ;					; than enough for the maximum FAT,
  8169                                  ;					; so go ahead and use the calculated
  8170                                  ;					; number of clusters.
  8171                                  ;cs3 7/2/92
  8172                                  
  8173 00001DFB D1D8                    	rcr	ax,1			; find number of entries
  8174 00001DFD 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8175                                  ;					;  into 12-bit fatland?
  8176 00001E00 7215                    	jb	short setend_faterr	; then go ahead and let the
  8177                                  ;					;  inconsistency pass through
  8178                                  ;					;  rather than lose data by
  8179                                  ;					;  correcting the fat type
  8180 00001E02 EB0E                    	jmp	short setend_fat16
  8181                                  
  8182                                  setend_fat12:
  8183 00001E04 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8184 00001E06 11D2                    	adc	dx,dx
  8185                                  ;cs3 7/2/92
  8186 00001E08 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8187 00001E0B 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8188                                  ;					; here.  Check for it and use
  8189                                  ;					; the calcuated size in this case.
  8190                                  ;cs3 7/2/92
  8191 00001E0D 2EF736[7E1D]            	div	word [cs:word3]
  8192                                  
  8193                                  setend_fat16:
  8194 00001E12 48                      	dec	ax			; limit at 1
  8195 00001E13 39D8                    	cmp	ax,bx			; is fat big enough?
  8196 00001E15 7602                    	jbe	short setend_fat	; use max value that'll fit
  8197                                  
  8198                                  setend_faterr:
  8199 00001E17 89D8                    	mov	ax,bx			; use calculated value
  8200                                  
  8201                                  setend_fat:
  8202                                  
  8203                                  ;	now ax = maximum legal cluster
  8204                                  
  8205                                  ;	end M008
  8206                                  
  8207                                  	;mov	[es:bp+0Dh], ax
  8208 00001E19 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8209                                  	;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8210 00001E1D 26C7461C0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8211                                  					; Init so first ALLOC starts at
  8212                                  					; begining of FAT
  8213                                  	;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8214 00001E23 26C7461EFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8215                                  
  8216 00001E29 C3                      	retn
  8217                                  
  8218                                  ;EndProc $SETDPB
  8219                                  
  8220                                  
  8221                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8222                                  
  8223                                  ;
  8224                                  ;----------------------------------------------------------------------------
  8225                                  ;
  8226                                  ;**	$Dup_PDB
  8227                                  ;
  8228                                  ; Inputs:   DX is new segment address of process
  8229                                  ;	    SI is end of new allocation block
  8230                                  ;
  8231                                  ;----------------------------------------------------------------------------
  8232                                  ;
  8233                                  
  8234                                  _$DUP_PDB:
  8235                                  
  8236                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8237                                  ;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
  8238                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8239                                  
  8240 00001E2A 2EC606[5003]FF          	MOV	byte [CS:CreatePDB],0FFH  ; indicate a new process
  8241 00001E30 2E8E1E[DE02]            	MOV	DS, [CS:CurrentPDB]
  8242 00001E35 56                      	PUSH	SI
  8243 00001E36 EB0A                    	JMP	SHORT CreateCopy
  8244                                  
  8245                                  ;
  8246                                  ;----------------------------------------------------------------------------
  8247                                  ;
  8248                                  ; Inputs:
  8249                                  ;	DX = Segment number of new base
  8250                                  ; Function:
  8251                                  ;	Set up program base and copy term and ^C from int area
  8252                                  ; Returns:
  8253                                  ;	None
  8254                                  ; Called at DOS init
  8255                                  ;
  8256                                  ;----------------------------------------------------------------------------
  8257                                  ;
  8258                                  
  8259                                  _$CREATE_PROCESS_DATA_BLOCK:
  8260                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8261 00001E38 E8D0F7                  	CALL	Get_User_Stack
  8262                                  	;mov	ds,[si+14h]
  8263 00001E3B 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8264                                  	;push	word [2]
  8265 00001E3E FF360200                	PUSH	word [PDB.BLOCK_LEN]
  8266                                  CreateCopy:
  8267 00001E42 8EC2                    	MOV	ES,DX
  8268                                  
  8269 00001E44 31F6                    	XOR	SI,SI			; copy entire PDB
  8270 00001E46 89F7                    	MOV	DI,SI
  8271 00001E48 B98000                  	MOV	CX,80H
  8272 00001E4B F3A5                    	REP	MOVSW
  8273                                  
  8274                                  ; DOS 3.3 7/9/86
  8275                                  
  8276                                  	;mov	cx,20
  8277 00001E4D B91400                  	MOV	CX,FILPERPROC		; copy handles in case of
  8278                                  	;mov	di,18h
  8279 00001E50 BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8280 00001E53 1E                      	PUSH	DS
  8281                                  	;lds	si,[34h]
  8282 00001E54 C5363400                	LDS	SI,[PDB.JFN_Pointer]
  8283 00001E58 F3A4                    	REP	MOVSB
  8284 00001E5A 1F                      	POP	DS
  8285                                  
  8286                                  ; DOS 3.3 7/9/86
  8287                                  
  8288                                  	;test	byte [cs:CreatePDB],0FFh
  8289 00001E5B 2E803E[5003]00          	cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8290 00001E61 744B                    	JZ	short Create_PDB_cont 	; nope, old style call
  8291                                  ;
  8292                                  ; Here we set up for a new process...
  8293                                  ;
  8294                                  
  8295 00001E63 0E                      	PUSH    CS                      ; Called at DOSINIT time, NO SS
  8296 00001E64 1F                      	POP     DS
  8297                                  
  8298 00001E65 31DB                    	XOR	BX,BX			; dup all jfns
  8299                                  	;mov	cx,20
  8300 00001E67 B91400                  	MOV	CX,FILPERPROC		; only 20 of them
  8301                                  
  8302                                  Create_dup_jfn:
  8303 00001E6A 06                      	PUSH	ES			; save new PDB
  8304 00001E6B E89149                  	call	SFFromHandle		; get sf pointer
  8305 00001E6E B0FF                    	MOV	AL,-1			; unassigned JFN
  8306 00001E70 7225                    	JC	short CreateStash	; file was not really open
  8307                                  	;test	word [es:di+5],1000h
  8308 00001E72 26F745050010            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8309 00001E78 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8310                                  ;
  8311                                  ; We do not inherit network file handles.
  8312                                  ;
  8313                                  	;mov	ah,[es:di+2]
  8314 00001E7A 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8315                                  	;and	ah,0F0h
  8316 00001E7E 80E4F0                  	AND	AH,SHARING_MASK
  8317                                  	;cmp	ah,70h
  8318 00001E81 80FC70                  	CMP	AH,SHARING_NET_FCB
  8319 00001E84 7411                    	jz	short CreateStash
  8320                                  ;
  8321                                  ; The handle we have found is duplicatable (and inheritable).  Perform
  8322                                  ; duplication operation.
  8323                                  ;
  8324 00001E86 893E[3605]              	MOV	[THISSFT],DI
  8325 00001E8A 8C06[3805]              	MOV	[THISSFT+2],ES
  8326 00001E8E E84218                  	call	DOS_DUP 		; signal duplication
  8327                                  ;
  8328                                  ; get the old sfn for copy
  8329                                  ;
  8330 00001E91 E85349                  	call	pJFNFromHandle		; ES:DI is jfn
  8331 00001E94 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8332                                  ;
  8333                                  ; Take AL (old sfn or -1) and stash it into the new position
  8334                                  ;
  8335                                  CreateStash:
  8336 00001E97 07                      	POP	ES
  8337                                  	;mov	[es:bx+18h],al
  8338 00001E98 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8339 00001E9C 43                      	INC	BX			; next jfn...
  8340 00001E9D E2CB                    	LOOP	Create_dup_jfn
  8341                                  
  8342 00001E9F 8B1E[DE02]              	MOV	BX,[CurrentPDB]		; get current process
  8343                                  	;mov	[es:bx+16h]
  8344 00001EA3 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8345 00001EA8 8C06[DE02]              	MOV	[CurrentPDB],ES
  8346 00001EAC 8EDB                    	MOV	DS,BX
  8347                                  ;
  8348                                  ; end of new process create
  8349                                  ;
  8350                                  Create_PDB_cont:
  8351 00001EAE 2EC606[5003]00          	MOV     BYTE [CS:CreatePDB],0	; reset flag
  8352 00001EB4 58                      	POP	AX
  8353                                  
  8354                                  	;entry	SETMEM
  8355                                  
  8356                                  ;---------------------------------------------------------------------------
  8357                                  ; Inputs:
  8358                                  ;	AX = Size of memory in paragraphs
  8359                                  ;	DX = Segment
  8360                                  ; Function:
  8361                                  ;	Completely prepares a program base at the
  8362                                  ;	specified segment.
  8363                                  ; Called at DOS init
  8364                                  ; Outputs:
  8365                                  ;	DS = DX
  8366                                  ;	ES = DX
  8367                                  ;	[0] has INT int_abort
  8368                                  ;	[2] = First unavailable segment
  8369                                  ;	[5] to [9] form a long call to the entry point
  8370                                  ;	[10] to [13] have exit address (from int_terminate)
  8371                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8372                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8373                                  ; DX,BP unchanged. All other registers destroyed.
  8374                                  ;---------------------------------------------------------------------------
  8375                                  
  8376                                  SETMEM:
  8377 00001EB5 31C9                    	XOR	CX,CX
  8378 00001EB7 8ED9                    	MOV	DS,CX
  8379 00001EB9 8EC2                    	MOV	ES,DX
  8380                                  	;mov	si,88h
  8381 00001EBB BE8800                  	MOV	SI,addr_int_terminate
  8382                                  	;mov	di,10
  8383 00001EBE BF0A00                  	MOV	DI,SAVEXIT
  8384 00001EC1 B90600                  	MOV	CX,6
  8385 00001EC4 F3A5                    	REP	MOVSW
  8386 00001EC6 26A30200                	MOV	[ES:2],AX
  8387 00001ECA 29D0                    	SUB	AX,DX
  8388 00001ECC 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8389 00001ECF 7603                    	JBE	short HAVDIF
  8390 00001ED1 B8FF0F                  	MOV	AX,MAXDIF
  8391                                  HAVDIF:
  8392 00001ED4 83E810                  	SUB	AX,10H			; Allow for 100h byte "stack"
  8393 00001ED7 BB0C00                  	MOV	BX,ENTRYPOINTSEG	;	in .COM files
  8394 00001EDA 29C3                    	SUB	BX,AX
  8395 00001EDC B104                    	MOV	CL,4
  8396 00001EDE D3E0                    	SHL	AX,CL
  8397 00001EE0 8EDA                    	MOV	DS,DX
  8398                                  
  8399                                  	; (MSDOS 6.0 note)
  8400                                  	;
  8401                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8402                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8403                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8404                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8405                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8406                                  	; making this equvalnce valid for this particular case. If however
  8407                                  	; there is less than 64K remaining the address in BX:AX will not 
  8408                                  	; be the same as above. We will then stuff 0:c0 , the call 5 address
  8409                                  	; into the PSP.
  8410                                  	;
  8411                                  	; Therefore for the case where there is less than 64K remaining in 
  8412                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8413                                  	; requirements will not work. Call 5, however will continue to work
  8414                                  	; for all cases.
  8415                                  	;
  8416                                  
  8417                                  	;mov	[6],ax
  8418                                  	;mov	[8],bx
  8419                                  
  8420 00001EE2 A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8421 00001EE5 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8422                                  
  8423                                  	;cmp	ax,WRAPOFFSET		; Q: does the system have >= 64k of
  8424                                  	;				;    memory left
  8425                                  	;je	short addr_ok		; Y: the above calculated address is
  8426                                  	;				;    OK
  8427                                  	;				; N: 
  8428                                  
  8429                                  	;MOV	WORD [PDB.CPM_CALL+1],0c0h
  8430                                  	;MOV	WORD [PDB.CPM_CALL+3],0
  8431                                  
  8432                                  ;addr_ok:
  8433                                  
  8434                                  	;mov	word [0],20CDh
  8435 00001EE9 C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8436                                  	;mov	byte [5],9Ah
  8437 00001EEF C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8438                                  	;mov	word [50h],21CDh
  8439 00001EF4 C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8440                                  	;mov	byte [52h],0CBh
  8441 00001EFA C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8442                                  	;mov	word [34h],18h
  8443 00001EFF C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8444                                  	;mov	word [36h],ds
  8445 00001F05 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8446                                  	;mov	word [32h],20
  8447 00001F09 C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8448                                  ;
  8449                                  ; The server runs several PDB's without creating them VIA EXEC.  We need to
  8450                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8451                                  ; particular SFT.  We perform this by requiring that the server link together
  8452                                  ; for us all sub-PDB's that he creates.  The requirement for us, now, is to
  8453                                  ; initialize this pointer.
  8454                                  ;
  8455                                   	;mov	word [38h],-1
  8456 00001F0F C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8457                                  	;mov	word [3Ah],-1
  8458 00001F15 C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8459                                  
  8460                                  			; Set the real version number in the PSP - 5.00
  8461                                  	;mov	[ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8462                                  
  8463 00001F1B C3                      	retn
  8464                                  
  8465                                  ;============================================================================
  8466                                  ; IBMDOS.COM (MSDOS 3.3 KERNEL), 1987 - Offset 1DE6h
  8467                                  ;============================================================================
  8468                                  ; 19/07/2018 - Retro DOS v3.0
  8469                                  
  8470                                  FETCHI_CHECK:
  8471 00001F1C 9C                      	pushf
  8472 00001F1D 2E813E[8F0F]7258        	cmp	word [cs:FETCHI_TAG], 5872h
  8473 00001F24 7403                    	jz      short FETCHI_CHK_RETN
  8474 00001F26 E85854                  	call    DOSINIT
  8475                                  FETCHI_CHK_RETN:
  8476 00001F29 9D                      	popf
  8477 00001F2A C3                      	retn
  8478                                  
  8479                                  ;============================================================================
  8480                                  ; MISC2.ASM, MSDOS 6.0, 1991
  8481                                  ;============================================================================
  8482                                  ; 20/07/2018 - Retro DOS v3.0
  8483                                  
  8484                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  8485                                  ;----------------------------------------------------------------------------
  8486                                  ;
  8487                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  8488                                  ;		Strings of different lengths don't match.
  8489                                  ;   Inputs:	DS:SI - pointer to source string  ES:DI - pointer to dest string
  8490                                  ;   Outputs:	Z if strings same, NZ if different
  8491                                  ;   Registers modified: NONE
  8492                                  ;----------------------------------------------------------------------------
  8493                                  
  8494                                  StrCmp:
  8495 00001F2B 56                      	push	si
  8496 00001F2C 57                      	push	di
  8497 00001F2D 50                      	push	ax
  8498                                  
  8499                                  Cmplp:
  8500 00001F2E AC                      	LODSB
  8501 00001F2F E8DD36                  	call	UCase			; convert to upper case
  8502 00001F32 E81637                  	call	PATHCHRCMP		; convert / to 	MOV	AH,AL
  8504 00001F35 268A05                  	MOV	AL,[ES:DI]
  8505 00001F38 47                      	INC	DI
  8506 00001F39 E8D336                  	call	UCase			; convert to upper case
  8507 00001F3C E80C37                  	call	PATHCHRCMP		; convert / to 	CMP	AH,AL
  8509 00001F3F 7504                    	JNZ	short PopRet		; Strings dif
  8510                                  Tend:
  8511 00001F41 08C0                    	OR	AL,AL
  8512 00001F43 75E9                    	JNZ	short Cmplp		; More string
  8513                                  PopRet:
  8514 00001F45 58                      	pop	ax
  8515 00001F46 5F                      	pop	di
  8516 00001F47 5E                      	pop	si
  8517 00001F48 C3                      	retn
  8518                                  
  8519                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  8520                                  ;----------------------------------------------------------------------------
  8521                                  ;
  8522                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  8523                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI.  no modification of
  8524                                  ;	characters.
  8525                                  ;
  8526                                  ;   Inputs:	DS:SI - pointer to source string
  8527                                  ;		ES:DI - pointer to destination string
  8528                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  8529                                  ;		DS:SI point byte after nul byte at end of source string
  8530                                  ;   Registers modified: SI,DI
  8531                                  ;----------------------------------------------------------------------------
  8532                                  
  8533                                  StrCpy:
  8534 00001F49 50                      	push	ax
  8535                                  CPYLoop:
  8536 00001F4A AC                      	LODSB
  8537 00001F4B E8C136                  	call	UCase			; convert to upper case
  8538 00001F4E E8FA36                  	call	PATHCHRCMP		; convert / to \ ;
  8539 00001F51 AA                      	STOSB
  8540                                  Tend2:
  8541 00001F52 08C0                    	OR	AL,AL
  8542 00001F54 75F4                    	JNZ	short CPYLoop
  8543 00001F56 58                      	pop	ax
  8544 00001F57 C3                      	retn
  8545                                  
  8546                                  ;----------------------------------------------------------------------------
  8547                                  ; Procedure Name : FStrCpy
  8548                                  ;----------------------------------------------------------------------------
  8549                                  
  8550                                  FStrCpy:
  8551 00001F58 50                      	push	ax
  8552                                  FCPYLoop:
  8553 00001F59 AC                      	LODSB
  8554 00001F5A AA                      	STOSB
  8555 00001F5B 08C0                    	OR	AL,AL
  8556 00001F5D 75FA                    	JNZ	short FCPYLoop
  8557 00001F5F 58                      	pop	ax
  8558 00001F60 C3                      	retn
  8559                                  
  8560                                  ; 20/07/2018 - Retro DOS v3.0
  8561                                  ;----------------------------------------------------------------------------
  8562                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  8563                                  ;----------------------------------------------------------------------------
  8564                                  ;
  8565                                  ;UCase:	
  8566                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  8567                                  ;	retn
  8568                                  
  8569                                  ;Break <StrLen - compute length of string ES:DI>
  8570                                  ;----------------------------------------------------------------------------
  8571                                  ;**	StrLen - Compute Length of String
  8572                                  ;
  8573                                  ;	StrLen computes the length of a string, including the trailing 00
  8574                                  ;
  8575                                  ;	ENTRY	(es:di) = address of string
  8576                                  ;	EXIT	(cx) = size of string
  8577                                  ;	USES	cx, flags
  8578                                  ;----------------------------------------------------------------------------
  8579                                  
  8580                                  StrLen:
  8581 00001F61 57                      	push	di
  8582 00001F62 50                      	push	ax
  8583                                  	;MOV	CX,-1
  8584 00001F63 B9FFFF                  	mov	cx,65535
  8585 00001F66 30C0                    	XOR	AL,AL
  8586 00001F68 F2AE                    	REPNE	SCASB
  8587 00001F6A F7D1                    	NOT	CX
  8588 00001F6C 58                      	pop	ax
  8589 00001F6D 5F                      	pop	di
  8590 00001F6E C3                      	retn
  8591                                  
  8592                                  ;----------------------------------------------------------------------------
  8593                                  ;**	DStrLen - Compute Length of String
  8594                                  ;
  8595                                  ;	ENTRY	(ds:si) = address of string
  8596                                  ;	EXIT	(cx) = size of string, including trailing NUL
  8597                                  ;	USES	cx, flags
  8598                                  ;----------------------------------------------------------------------------
  8599                                  
  8600                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  8601 00001F6F E80700                  	CALL	XCHGP
  8602 00001F72 E8ECFF                  	CALL	StrLen
  8603 00001F75 E80100                  	CALL	XCHGP
  8604 00001F78 C3                      	retn
  8605                                  
  8606                                  ;----------------------------------------------------------------------------
  8607                                  ;**	XCHGP - Exchange Source and Destination Pointers
  8608                                  ;
  8609                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  8610                                  ;
  8611                                  ;	ENTRY	none
  8612                                  ;	EXIT	pairs exchanged
  8613                                  ;	USES	SI, DI, DS, ES
  8614                                  ;----------------------------------------------------------------------------
  8615                                  
  8616                                  XCHGP:
  8617 00001F79 1E                      	push	ds
  8618 00001F7A 06                      	push	es
  8619 00001F7B 1F                      	pop	ds
  8620 00001F7C 07                      	pop	es
  8621 00001F7D 87F7                    	XCHG	SI,DI
  8622                                  xchgp_retn:
  8623 00001F7F C3                      	retn
  8624                                  
  8625                                  ;Break	<Idle - wait for a specified amount of time>
  8626                                  ;----------------------------------------------------------------------------
  8627                                  ;
  8628                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  8629                                  ;   	   we spin until RetryLoop is exhausted.
  8630                                  ;
  8631                                  ;   Inputs:	RetryLoop is the number of times we spin
  8632                                  ;   Outputs:	Wait
  8633                                  ;   Registers modified: none
  8634                                  ;----------------------------------------------------------------------------
  8635                                  
  8636                                  Idle:
  8637                                  	;test	byte [SS:FSHARING],0FFh
  8638 00001F80 36803E[0D05]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  8639                                  	;retnz
  8640 00001F86 75F7                    	jnz	short xchgp_retn
  8641                                  	;SAVE	<CX>
  8642 00001F88 51                      	push	cx
  8643 00001F89 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  8644 00001F8E E308                    	JCXZ	Idle3
  8645                                  Idle1:	
  8646 00001F90 51                      	PUSH	CX
  8647 00001F91 31C9                    	XOR	CX,CX
  8648                                  Idle2:	
  8649 00001F93 E2FE                    	LOOP	Idle2
  8650 00001F95 59                      	POP	CX
  8651 00001F96 E2F8                    	LOOP	Idle1
  8652                                  Idle3:	
  8653                                  	;RESTORE <CX>
  8654 00001F98 59                      	pop	cx
  8655 00001F99 C3                      	retn
  8656                                  
  8657                                  ;Break	<TableDispatch - dispatch to a table>
  8658                                  ;----------------------------------------------------------------------------
  8659                                  ;
  8660                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  8661                                  ;   routine.  Preserve all input registers to the routine.
  8662                                  ;
  8663                                  ;   Inputs:	Push	return address
  8664                                  ;		Push	Table address
  8665                                  ;		Push	index (byte)
  8666                                  ;   Outputs:	appropriate routine gets jumped to.
  8667                                  ;		return indicates invalid index
  8668                                  ;   Registers modified: none.
  8669                                  ;----------------------------------------------------------------------------
  8670                                  
  8671                                  struc TFrame	 ; TableFrame
  8672 00000000 ????                    .OldBP:	 resw 1  ; 0
  8673 00000002 ????                    .OldRet: resw 1  ; 2
  8674 00000004 ??                      .Index:	 resb 1  ; 4
  8675 00000005 ??                      .Pad:	 resb 1  ; 5  
  8676 00000006 ????                    .Tab:	 resw 1  ; 6
  8677 00000008 ????                    .NewRet: resw 1  ; 8
  8678                                  endstruc
  8679                                  
  8680                                  TableDispatch:
  8681 00001F9A 55                      	PUSH	BP
  8682 00001F9B 89E5                    	MOV	BP,SP
  8683 00001F9D 53                      	PUSH	BX			; save BX
  8684                                  	;mov	bx,[bp+6]
  8685 00001F9E 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  8686 00001FA1 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  8687                                  	;cmp	[bp+4],bl
  8688 00001FA4 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  8689 00001FA7 7317                    	JAE	short TableError	; yes
  8690                                  	;mov	bl,[bp+4]
  8691 00001FA9 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  8692 00001FAC 30FF                    	XOR	BH,BH			; convert to word
  8693 00001FAE D1E3                    	SHL	BX,1			; convert to word pointer
  8694 00001FB0 43                      	INC	BX			; point past first length byte
  8695                                  	; 17/08/2018
  8696                                  	;add	bx,[bp+6]
  8697 00001FB1 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  8698 00001FB4 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  8699                                  	;mov	[bp+6],bx
  8700 00001FB7 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  8701 00001FBA 5B                      	POP	BX			; restore BX
  8702 00001FBB 5D                      	POP	BP			; restore BP
  8703 00001FBC 83C404                  	ADD	SP,4			; clean off Index and our return addr
  8704 00001FBF C3                      	retn				; do operation
  8705                                  TableError:
  8706 00001FC0 5B                      	POP	BX			; restore BX
  8707 00001FC1 5D                      	POP	BP			; restore BP
  8708 00001FC2 C20600                  	RETN	6			; clean off Index, Table and RetAddr
  8709                                  
  8710                                  
  8711                                  ;Break	<TestNet - determine if a CDS is for the network>
  8712                                  ;----------------------------------------------------------------------------
  8713                                  ;
  8714                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  8715                                  ;	network CDS.  This will handle NULL cds also.
  8716                                  ;
  8717                                  ;   Inputs:	ThisCDS points to CDS or NULL
  8718                                  ;   Outputs:	ES:DI = ThisCDS
  8719                                  ;		carry Set => network
  8720                                  ;		carry Clear => local
  8721                                  ;   Registers modified: none.
  8722                                  ;----------------------------------------------------------------------------
  8723                                  
  8724                                  TestNet:
  8725 00001FC5 2EC43E[3A05]            	LES	DI,[CS:THISCDS]
  8726 00001FCA 83FFFF                  	CMP	DI,-1
  8727 00001FCD 7409                    	JZ	short CMCRet		; UNC? carry is clear
  8728                                  	;test	word [es:di+43h],8000h
  8729 00001FCF 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
  8730 00001FD5 7501                    	JNZ	short CMCRet		; jump has carry clear
  8731 00001FD7 C3                      	retn				; carry is clear
  8732                                  CMCRet: 
  8733 00001FD8 F5                      	CMC
  8734 00001FD9 C3                      	retn
  8735                                  
  8736                                  ;Break	<IsSFTNet - see if an sft is for the network>
  8737                                  ;----------------------------------------------------------------------------
  8738                                  ;
  8739                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  8740                                  ;	network file.
  8741                                  ;
  8742                                  ;   Inputs:	ES:DI point to SFT
  8743                                  ;   Outputs:	Zero set if not network sft
  8744                                  ;		zero reset otherwise
  8745                                  ;		Carry CLEAR!!!
  8746                                  ;   Registers modified: none.
  8747                                  ;----------------------------------------------------------------------------
  8748                                  
  8749                                  IsSFTNet:
  8750                                  	;test	word [es:di+5],8000h
  8751 00001FDA 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  8752 00001FE0 C3                      	retn
  8753                                  
  8754                                  ;Break	<FastInit - Initialize FastTable entries >
  8755                                  ;----------------------------------------------------------------------------
  8756                                  ;   DOS 4.00   2/9/87
  8757                                  ;   FastInit  - initialize the FASTXXX routine entry
  8758                                  ;		  in the FastTable
  8759                                  ;
  8760                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  8761                                  ;		DS:SI = address of FASTXXX routine entry
  8762                                  ;		   SI = -1 for query only
  8763                                  ;   Outputs:	Carry flag clear, if success
  8764                                  ;		Carry flag set,   if failure
  8765                                  ;
  8766                                  ;
  8767                                  ;----------------------------------------------------------------------------
  8768                                  
  8769                                  ;Procedure FastInit,NEAR
  8770                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  8771                                  ;FastInit:
  8772                                  	; MSDOS 6.0
  8773                                  	;hkn; set up es to dosdataseg.
  8774                                  	;push	es
  8775                                  	;getdseg <es>			; es -> dosdata
  8776                                  
  8777                                  	;hkn; FastTable is in DOSDATA
  8778                                  	;MOV	DI,OFFSET DOSDATA:FastTable + 2 ;AN000;FO. points to fastxxx entry
  8779                                  	;DEC	BX				;AN000;FO.;; decrement index
  8780                                  	;MOV	DX,BX				;AN000;FO.;; save bx
  8781                                  	;SHL	BX,1				;AN000;FO.;; times 4 , each entry is DWORD
  8782                                  	;SHL	BX,1				;AN000;FO.
  8783                                  	;ADD	DI,BX				;AN000;FO. index to the entry
  8784                                  	;MOV	AX,WORD PTR ES:[DI+2]		;AN000;FO. get entry segment
  8785                                  ;fcheck: 					;AN000;
  8786                                  	;MOV	CX,CS				;AN000;FO.;; get DOS segment
  8787                                  	;CMP	AX,CX				;AN000;FO.;; first time installed ?
  8788                                  	;JZ	short ok_install			;AN000;FO.;; yes
  8789                                  	;OR	AX,AX				;AN000;FO.;
  8790                                  	;JZ	short ok_install		;AN000;FO.;
  8791                                  	;STC					;AN000;FO.;; already installed !
  8792                                  	;JMP	SHORT FSret			;AN000;FO. set carry
  8793                                  ;ok_install:					;AN000;
  8794                                  	;CMP	SI,-1				;AN000;FO.; Query only ?
  8795                                  	;JZ	short FSret			;AN000;FO.; yes
  8796                                  	;MOV	CX,DS				;AN000;FO.; get FASTXXX entry segment
  8797                                  	;MOV	WORD PTR ES:[DI+2],CX		;AN000;FO.; initialize routine entry
  8798                                  	;MOV	WORD PTR ES:[DI],SI		;AN000;FO.; initialize routine offset
  8799                                  
  8800                                  ;hkn; FastFlg moved to DOSDATA
  8801                                  	;MOV	DI,OFFSET DOSDATA:FastFlg	;AN000;FO.; get addr of FASTXXX flags
  8802                                  	;ADD	DI,DX				;AN000;FO.; index to a FASTXXX flag
  8803                                  	;OR	byte ptr ES:[DI],Fast_yes	;AN000;FO.; indicate installed
  8804                                  FSret:						;AN000;
  8805                                  	;pop	es
  8806                                  	;return					;AN000;FO.
  8807                                  ;EndProc FastInit				;AN000;FO.
  8808                                  
  8809                                  	; MSDOS 3.3
  8810                                  	; IBMDOS.COM (1987) - Offset 1EB3h
  8811                                  FastInit:
  8812 00001FE1 BF[430F]                	mov	di,FastTable ; FastOpenTable
  8813 00001FE4 2E8B4504                	mov	ax,[cs:di+4]		; Entry segment
  8814 00001FE8 8CCB                    	mov	bx,cs			; get DOS segment
  8815 00001FEA 39D8                    	cmp	ax,bx			; first time installed ?	
  8816 00001FEC 7402                    	je	short ok_install	; yes
  8817 00001FEE F9                      	stc				; set carry
  8818 00001FEF C3                      	retn				; (cf=1 means) already installed !
  8819                                  
  8820                                  ok_install:
  8821 00001FF0 BB[430F]                	mov	bx,FastTable ; FastOpenTable
  8822 00001FF3 8CD9                    	mov	cx,ds
  8823                                  	; set address of FASTXXX (FASTOPEN) routine entry
  8824 00001FF5 2E894F04                	mov	[cs:bx+4],cx
  8825 00001FF9 2E897702                	mov	[cs:bx+2],si
  8826 00001FFD C3                      	retn
  8827                                  
  8828                                  ;Break	<FastRet - initial routine in FastOpenTable >
  8829                                  ;----------------------------------------------------------------------------
  8830                                  ;   DOS 3.3   6/10/86
  8831                                  ;   FastRet	- indicate FASTXXXX  not in memory
  8832                                  ;
  8833                                  ;   Inputs:	None
  8834                                  ;   Outputs:	AX = -1 and carry flag set
  8835                                  ;
  8836                                  ;   Registers modified: none.
  8837                                  ;----------------------------------------------------------------------------
  8838                                  
  8839                                  FastRet:
  8840                                  	;mov	ax,-1
  8841                                  	;stc
  8842                                  	;retf
  8843 00001FFE F9                      	STC
  8844 00001FFF 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  8845 00002001 CB                      	RETF
  8846                                  
  8847                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  8848                                  ;----------------------------------------------------------------------------
  8849                                  ;   DOS 3.3   6/10/86
  8850                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  8851                                  ;
  8852                                  ;   Inputs:	Same input as $OPEN except CL = mode
  8853                                  ;   Outputs:	same output as $OPEN
  8854                                  ;
  8855                                  ;----------------------------------------------------------------------------
  8856                                  
  8857                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  8858                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  8859                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  8860                                  
  8861                                  NLS_OPEN:
  8862                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  8863                                  ;	MOV	BYTE [CPSWFLAG],0
  8864                                  ;	PUSH	BX		 ; save current state
  8865                                  
  8866 00002002 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  8867 00002004 E83050                  	call	_$OPEN
  8868                                  
  8869                                   ;	POP	BX		 ; restore current state
  8870                                   ;	MOV	[CPSWFLAG],BL
  8871 00002007 C3                      	RETN
  8872                                  
  8873                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  8874                                  ;----------------------------------------------------------------------------
  8875                                  ;   DOS 3.3   6/10/86
  8876                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  8877                                  ;
  8878                                  ;   Inputs:	BP = open mode
  8879                                  ;   Outputs:	same output as $LSEEK
  8880                                  ;
  8881                                  ;----------------------------------------------------------------------------
  8882                                  
  8883                                  NLS_LSEEK:
  8884                                  	;PUSH	word [SS:USER_SP] ; save user stack
  8885                                  	;PUSH	word [SS:USER_SS]
  8886 00002008 2EFF36[1E05]            	PUSH	word [CS:USER_SP] ; save user stack
  8887 0000200D 2EFF36[2005]            	PUSH	word [CS:USER_SS]
  8888 00002012 E81000                  	CALL	Fake_User_Stack
  8889 00002015 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  8890 00002017 E81E4F                  	call	_$LSEEK
  8891                                  	;POP	word [SS:USER_SS] ; restore user stack
  8892                                  	;POP	word [SS:USER_SP]
  8893 0000201A 2E8F06[2005]            	POP	word [cs:USER_SS] ; restore user stack
  8894 0000201F 2E8F06[1E05]            	POP	word [cs:USER_SP]
  8895 00002024 C3                      	RETN
  8896                                  
  8897                                  ;Break	<Fake_User_Stack - save user stack>
  8898                                  ;----------------------------------------------------------------------------
  8899                                  ;   DOS 3.3   6/10/86
  8900                                  ;   Fake_User_Stack - save user stack pointer
  8901                                  ;
  8902                                  ;----------------------------------------------------------------------------
  8903                                  
  8904                                  Fake_User_Stack:
  8905                                  	;MOV	AX,[ss:USER_SP_2F] ; replace with INT 2F stack
  8906 00002025 2EA1[710F]              	MOV	AX,[cs:USER_SP_2F]
  8907                                  	;MOV	[SS:USER_SP],AX
  8908 00002029 2EA3[1E05]              	MOV	[CS:USER_SP],AX
  8909 0000202D 8CC8                    	MOV	AX,CS
  8910                                  	;mov	ax,ss
  8911                                  	;MOV	[SS:USER_SS],AX
  8912 0000202F 2EA3[2005]              	MOV	[CS:USER_SS],AX
  8913 00002033 C3                      	RETN
  8914                                  
  8915                                  ;Break	<GetDevList - get device header list pointer>
  8916                                  ;----------------------------------------------------------------------------
  8917                                  ;   DOS 3.3   7/25/86
  8918                                  ;   GetDevList - get device header list pointer
  8919                                  ;
  8920                                  ;   Output: AX:BX points to the device header list
  8921                                  ;----------------------------------------------------------------------------
  8922                                  
  8923                                  GetDevList:
  8924 00002034 BE[3B0F]                	MOV	SI,SysInitTable
  8925                                  	;LDS	SI,[CS:SI+SYSINITVARS]
  8926 00002037 2EC534                  	LDS	SI,[CS:SI]
  8927                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  8928                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  8929 0000203A 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  8930 0000203D 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  8931 00002040 C3                      	RETN
  8932                                  
  8933                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
  8934                                  ;----------------------------------------------------------------------------
  8935                                  ;   DOS 3.3   7/25/86
  8936                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  8937                                  ;
  8938                                  ;   Inputs:	BP = function code 0CH
  8939                                  ;   Outputs:	same output as generic $IOCTL
  8940                                  ;
  8941                                  ;----------------------------------------------------------------------------
  8942                                  
  8943                                  NLS_IOCTL:
  8944                                  	;PUSH	word [SS:USER_SP] ; save user stack
  8945                                  	;PUSH	word [SS:USER_SS]
  8946 00002041 2EFF36[1E05]            	PUSH	word [CS:USER_SP] ; save user stack
  8947 00002046 2EFF36[2005]            	PUSH	word [CS:USER_SS]
  8948 0000204B E8D7FF                  	CALL	Fake_User_Stack
  8949 0000204E 89E8                    	MOV	AX,BP	     ; set up correct interface for $LSEEK
  8950 00002050 E85C0F                  	call	_$IOCTL
  8951                                  	;POP	word [SS:USER_SS] ; restore user stack
  8952                                  	;POP	word [SS:USER_SP]
  8953 00002053 2E8F06[2005]            	POP	word [CS:USER_SS] ; restore user stack
  8954 00002058 2E8F06[1E05]            	POP	word [CS:USER_SP]
  8955 0000205D C3                      	RETN
  8956                                  
  8957                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  8958                                  ;----------------------------------------------------------------------------
  8959                                  ;   DOS 3.3   7/25/86
  8960                                  ;   NLS_GETEXT	-
  8961                                  ;
  8962                                  ;   Inputs:	none
  8963                                  ;   Outputs:	AX = extended error
  8964                                  ;
  8965                                  ;----------------------------------------------------------------------------
  8966                                  
  8967                                  NLS_GETEXT:
  8968                                  	;MOV	AX,[SS:EXTERR]	 ; return extended error
  8969 0000205E 2EA1[D202]              	mov	AX,[CS:EXTERR]
  8970 00002062 C3                      	RETN
  8971                                  
  8972                                  ;============================================================================
  8973                                  ; EcritDisk, LcritDisk, EcritDevice, LCritDevice
  8974                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  8975                                  ;============================================================================
  8976                                  ; 20/07/2018 - Retro DOS v3.0
  8977                                  
  8978                                  	; MSDOS 3.3
  8979                                  	; 08/08/2018 - Retro DSOS v3.0
  8980                                  EcritMem:
  8981                                  EcritSFT:
  8982                                  	;
  8983                                  EcritDisk:
  8984                                  	;push	ax
  8985 00002063 C3                      	retn
  8986                                  	
  8987 00002064 B80180                  	mov	ax,8001h
  8988 00002067 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  8989                                  			; AL = critical section number (00h-0Fh)
  8990 00002069 58                      	pop	ax
  8991 0000206A C3                      	retn
  8992                                  
  8993                                  	; MSDOS 3.3
  8994                                  	; 08/08/2018 - Retro DSOS v3.0
  8995                                  LcritMem:
  8996                                  LcritSFT:
  8997                                  	;
  8998                                  LcritDisk:
  8999                                  	;push	ax
  9000 0000206B C3                      	retn
  9001                                  	
  9002 0000206C B80181                  	mov	ax,8101h
  9003 0000206F CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9004                                  			; AL = critical section number (00h-0Fh)
  9005 00002071 58                      	pop	ax
  9006 00002072 C3                      	retn
  9007                                  
  9008                                  EcritDevice:
  9009                                  	;push	ax
  9010 00002073 C3                      	retn
  9011                                  	
  9012 00002074 B80280                  	mov	ax,8002h
  9013 00002077 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9014                                  			; AL = critical section number (00h-0Fh)
  9015 00002079 58                      	pop	ax
  9016 0000207A C3                      	retn
  9017                                  
  9018                                  LcritDevice:
  9019                                  	;push	ax
  9020 0000207B C3                      	retn
  9021                                  	
  9022 0000207C B80281                  	mov	ax,8102h
  9023 0000207F CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9024                                  			; AL = critical section number (00h-0Fh)
  9025 00002081 58                      	pop	ax
  9026 00002082 C3                      	retn
  9027                                  
  9028                                  ;============================================================================
  9029                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9030                                  ;============================================================================
  9031                                  ; 20/07/2018 - Retro DOS v3.0
  9032                                  
  9033                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9034                                  
  9035                                  ; Some old versions of the 80286 have a bug in the chip.  The popf
  9036                                  ; instruction will enable interrupts.  Therefore in a section of code with
  9037                                  ; interrupts disabled and you need a popf instruction use the 'popff'
  9038                                  ; macro instead.
  9039                                  ;
  9040                                  
  9041                                  ;%macro POPFF 0
  9042                                  ;	jmp	$+3
  9043                                  ;	iret
  9044                                  ;	push	cs
  9045                                  ;	call	$-2
  9046                                  ;%endmacro
  9047                                  
  9048                                  ;**	CRIT.ASM - Critical Section Routines
  9049                                  ;
  9050                                  ;	Critical section handlers
  9051                                  ;
  9052                                  ;	Modification history:
  9053                                  ;
  9054                                  ;	    Created: ARR 30 March 1983
  9055                                  
  9056                                  ;
  9057                                  ;SR; This variable is set when the redir installs itself
  9058                                  ;
  9059                                  	;I_need redir_patch,BYTE
  9060                                  
  9061                                  ; Break	<Critical section handlers>
  9062                                  
  9063                                  ;   Each handler must leave everything untouched; including flags!
  9064                                  ;
  9065                                  ;   Sleaze for time savings:  first instruction is a return.  This is patched
  9066                                  ;   by the sharer to be a PUSH AX to complete the correct routines.
  9067                                  
  9068                                  ;Procedure  EcritDisk,NEAR
  9069                                  	;public  EcritMem
  9070                                  	;public  EcritSFT
  9071                                  ;ECritMEM    LABEL   NEAR
  9072                                  ;ECritSFT    LABEL   NEAR
  9073                                  
  9074                                  ;
  9075                                  ;SR; Check if critical section is to be entered
  9076                                  ;
  9077                                  
  9078                                  ;	pushf
  9079                                  ;	cmp	ss:[redir_patch],0
  9080                                  ;	jz	@f
  9081                                  ;	popff
  9082                                  ;
  9083                                  ;       PUSH    AX
  9084                                  ;	MOV     AX,8000h+critDisk
  9085                                  ;	INT     int_ibm
  9086                                  ;	POP     AX
  9087                                  ;	return
  9088                                  ;@@:
  9089                                  ;	popff
  9090                                  ;	ret
  9091                                  ;EndProc EcritDisk
  9092                                  
  9093                                  ;Procedure   LcritDisk,NEAR
  9094                                  ;	public  LcritMem
  9095                                  ;	public  LcritSFT
  9096                                  ;LCritMEM    LABEL   NEAR
  9097                                  ;LCritSFT    LABEL   NEAR
  9098                                  
  9099                                  ;
  9100                                  ;SR; Check if critical section is to be entered
  9101                                  ;
  9102                                  
  9103                                  ;	pushf
  9104                                  ;	cmp	ss:[redir_patch],0
  9105                                  ;	jz	@f
  9106                                  ;	popff
  9107                                  
  9108                                  ;       PUSH    AX
  9109                                  ;	MOV     AX,8100h+critDisk
  9110                                  ;	INT     int_ibm
  9111                                  ;	POP     AX
  9112                                  ;	return
  9113                                  ;@@:
  9114                                  ;	popff
  9115                                  ;	ret
  9116                                  
  9117                                  ;EndProc LcritDisk
  9118                                  
  9119                                  ;Procedure   EcritDevice,NEAR
  9120                                  ;
  9121                                  ;SR; Check if critical section is to be entered
  9122                                  ;
  9123                                  
  9124                                  ;	pushf
  9125                                  ;	cmp	ss:[redir_patch],0
  9126                                  ;	jz	@f
  9127                                  ;	popff
  9128                                  
  9129                                  ;       PUSH    AX
  9130                                  ;	MOV     AX,8000h+critDevice
  9131                                  ;	INT     int_ibm
  9132                                  ;	POP     AX
  9133                                  ;	return
  9134                                  ;@@:
  9135                                  ;	popff
  9136                                  ;	ret
  9137                                  
  9138                                  ;EndProc EcritDevice
  9139                                  
  9140                                  ;Procedure   LcritDevice,NEAR
  9141                                  ;
  9142                                  ;SR; Check if critical section is to be entered
  9143                                  ;
  9144                                  
  9145                                  ;	pushf
  9146                                  ;	cmp	ss:[redir_patch],0
  9147                                  ;	jz	@f
  9148                                  ;	popff
  9149                                  
  9150                                  ;       PUSH    AX
  9151                                  ;	MOV     AX,8100h+critDevice
  9152                                  ;	INT     int_ibm
  9153                                  ;	POP     AX
  9154                                  ;	return
  9155                                  ;@@:
  9156                                  ;	popff
  9157                                  ;	ret
  9158                                  
  9159                                  ;EndProc LcritDevice
  9160                                  
  9161                                  
  9162                                  ;============================================================================
  9163                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9164                                  ;============================================================================
  9165                                  ; 20/07/2018 - Retro DOS v3.0
  9166                                  
  9167                                  ;============================================================================
  9168                                  ; STDIO.ASM - (MSDOS 2.0)
  9169                                  ;============================================================================
  9170                                  
  9171                                  ;
  9172                                  ; Standard device IO for MSDOS (first 12 function calls)
  9173                                  ;
  9174                                  
  9175                                  ;.xlist
  9176                                  ;.xcref
  9177                                  ;INCLUDE STDSW.ASM
  9178                                  ;INCLUDE DOSSEG.ASM
  9179                                  ;.cref
  9180                                  ;.list
  9181                                  
  9182                                  ;TITLE   STDIO - device IO for MSDOS
  9183                                  ;NAME    STDIO
  9184                                  
  9185                                  ;INCLUDE IO.ASM
  9186                                  
  9187                                  ; ---------------------------------------------------------------------------
  9188                                  ;
  9189                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9190                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9191                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9192                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9193                                  ;			    to restore MSDOS 2.0 device IO source code 
  9194                                  ;
  9195                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
  9196                                  	
  9197                                  ;============================================================================
  9198                                  ; STDIO.ASM - (MSDOS 2.0)
  9199                                  ;============================================================================
  9200                                  
  9201                                  ;
  9202                                  ; Standard device IO for MSDOS (first 12 function calls)
  9203                                  ;
  9204                                  
  9205                                  ;.xlist
  9206                                  ;.xcref
  9207                                  ;INCLUDE STDSW.ASM
  9208                                  ;INCLUDE DOSSEG.ASM
  9209                                  ;.cref
  9210                                  ;.list
  9211                                  
  9212                                  ;TITLE   STDIO - device IO for MSDOS
  9213                                  ;NAME    STDIO
  9214                                  
  9215                                  ;INCLUDE IO.ASM
  9216                                  
  9217                                  ; ---------------------------------------------------------------------------
  9218                                  ;
  9219                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9220                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9221                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9222                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9223                                  ;			    to restore MSDOS 2.0 device IO source code 
  9224                                  ;
  9225                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
  9226                                  ;
  9227                                  ;============================================================================
  9228                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
  9229                                  ;============================================================================
  9230                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
  9231                                  
  9232                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
  9233                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
  9234                                  
  9235                                  ;**	Standard device IO for MSDOS (first 12 function calls)
  9236                                  ;
  9237                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
  9238                                  ;	NAME	IBMCPMIO
  9239                                  
  9240                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
  9241                                  ;
  9242                                  ;	$Std_Con_Input_No_Echo
  9243                                  ;	$Std_Con_String_Output
  9244                                  ;	$Std_Con_String_Input
  9245                                  ;	$RawConIO
  9246                                  ;	$RawConInput
  9247                                  ;	RAWOUT
  9248                                  ;	RAWOUT2
  9249                                  ;
  9250                                  
  9251                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9252                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9253                                  ; references to be SS or CS relative which is desired.
  9254                                  
  9255                                  ; ---------------------------------------------------------------------------
  9256                                  
  9257                                  ;	TITLE	CPMIO2 - device IO for MSDOS
  9258                                  ;	NAME	CPMIO2
  9259                                  
  9260                                  ;
  9261                                  ;	Microsoft Confidential
  9262                                  ;	Copyright (C) Microsoft Corporation 1991
  9263                                  ;	All Rights Reserved.
  9264                                  ;
  9265                                  
  9266                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
  9267                                  ;
  9268                                  ;	$Std_Con_Input
  9269                                  ;	$Std_Con_Output
  9270                                  ;	OUTT
  9271                                  ;	TAB
  9272                                  ;	BUFOUT
  9273                                  ;	$Std_Aux_Input
  9274                                  ;	$Std_Aux_Output
  9275                                  ;	$Std_Printer_Output
  9276                                  ;	$Std_Con_Input_Status
  9277                                  ;	$Std_Con_Input_Flush
  9278                                  ;
  9279                                  ;	Revision History:
  9280                                  ;
  9281                                  ;	  AN000	 version 4.00 - Jan. 1988
  9282                                  
  9283                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9284                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9285                                  ; references to be SS or CS relative which is desired.
  9286                                  
  9287                                  ;DOSCODE SEGMENT
  9288                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
  9289                                  
  9290                                  
  9291                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
  9292                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
  9293                                  ;hkn;	not valid. 
  9294                                  
  9295                                  ;
  9296                                  ;----------------------------------------------------------------------------
  9297                                  ;
  9298                                  ; Procedure : $Std_Con_Input_No_Echo
  9299                                  ;
  9300                                  ;----------------------------------------------------------------------------
  9301                                  ;
  9302                                  
  9303                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
  9304                                  
  9305                                  ; Inputs:
  9306                                  ;	None
  9307                                  ; Function:
  9308                                  ;	Input character from console, no echo
  9309                                  ; Returns:
  9310                                  ;	AL = character
  9311                                  
  9312 00002083 1E                      	push	ds
  9313 00002084 56                      	push	si
  9314                                  INTEST:
  9315 00002085 E86B36                  	call	STATCHK
  9316 00002088 754D                    	jnz	short GET ; 08/09/2018
  9317                                  ;*************************************************************************
  9318                                  ;hkn; SS override
  9319 0000208A 36803E[060A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
  9320 00002090 7505                    	jnz	short no_sys_wait
  9321 00002092 B405                    	mov	ah,5			; get input status with system wait
  9322 00002094 E8B92C                  	call	IOFUNC
  9323                                  no_sys_wait:
  9324                                  ;**************************************************************************
  9325 00002097 B484                    	MOV	AH,84h
  9326 00002099 CD2A                    	INT	int_IBM	 ; int 2Ah
  9327                                  
  9328                                  ;;; 7/15/86  update the date in the idle loop
  9329                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
  9330                                  ;;;;		 to shorten loop in consideration of the PC Convertible
  9331                                  
  9332                                  ;hkn; SS override
  9333 0000209B 36803E[8D0F]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
  9334 000020A1 752D                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
  9335 000020A3 50                      	PUSH	AX
  9336 000020A4 53                      	PUSH	BX			; following is tricky,
  9337 000020A5 51                      	PUSH	CX			; it may be called by critical handler
  9338 000020A6 52                      	PUSH	DX			; at that time, DEVCALL is used by
  9339                                  					; other's READ or WRITE
  9340 000020A7 1E                      	PUSH	DS			; save DS = SFT's sgement
  9341                                  
  9342                                  ;hkn; READTIME must use ds = DOSDATA
  9343                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
  9344                                  
  9345                                  	;push	ss
  9346 000020A8 0E                      	PUSH	CS
  9347 000020A9 1F                      	POP	DS
  9348                                  
  9349 000020AA B80000                  	MOV	AX,0			; therefore, we save DEVCALL
  9350 000020AD E89F02                  	CALL	Save_Restore_Packet	; save DEVCALL packet
  9351                                  	;invoke	READTIME		; readtime
  9352 000020B0 E82AF8                  	call	READTIME
  9353 000020B3 B80100                  	MOV	AX,1
  9354 000020B6 E89602                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
  9355                                  	;
  9356                                  	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
  9357                                  	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
  9358 000020B9 53                      	push	bx
  9359 000020BA BB[8D0F]                	mov	bx,DATE_FLAG
  9360 000020BD 83C302                  	add	bx,2  ; mov bx,FETCHI_FLAG
  9361 000020C0 2E813F7258              	cmp	word [cs:bx],5872h
  9362 000020C5 7403                    	jz	short FETCHI_TAG_chk_ok
  9363 000020C7 E8B752                  	call	DOSINIT
  9364                                  FETCHI_TAG_chk_ok:
  9365 000020CA 5B                      	pop	bx
  9366                                  	;
  9367 000020CB 1F                      	POP	DS			; restore DS
  9368 000020CC 5A                      	POP	DX
  9369 000020CD 59                      	POP	CX
  9370 000020CE 5B                      	POP	BX
  9371 000020CF 58                      	POP	AX
  9372                                  NoUpdate:
  9373                                  
  9374                                  ;hkn; SS override
  9375 000020D0 36FF06[8D0F]            	INC	word [SS:DATE_FLAG]
  9376                                  
  9377                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  9378 000020D5 EBAE                    	JMP	short INTEST
  9379                                  GET:
  9380 000020D7 30E4                    	XOR	AH,AH
  9381 000020D9 E8742C                  	call	IOFUNC
  9382 000020DC 5E                      	POP	SI
  9383 000020DD 1F                      	POP	DS
  9384                                  ;;; 7/15/86
  9385                                  
  9386                                  ;hkn; SS override
  9387                                  	; MSDOS 6.0
  9388 000020DE 36C606[8B0F]00          	MOV	BYTE [SS:SCAN_FLAG],0
  9389                                  	;
  9390 000020E4 3C00                    	CMP	AL,0	    ; extended code ( AL )
  9391 000020E6 7506                    	JNZ	short noscan
  9392                                  
  9393                                  ;hkn; SS override
  9394 000020E8 36C606[8B0F]01          	MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
  9395                                  
  9396                                  noscan:
  9397 000020EE C3                      	retn
  9398                                  ;
  9399                                  ;----------------------------------------------------------------------------
  9400                                  ;
  9401                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
  9402                                  ;
  9403                                  ;
  9404                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
  9405                                  ;	EXIT	none
  9406                                  ;	USES	ALL
  9407                                  ;
  9408                                  ;----------------------------------------------------------------------------
  9409                                  ;
  9410                                  
  9411                                  _$STD_CON_STRING_OUTPUT:	;System call 9
  9412                                  
  9413 000020EF 89D6                    	mov	si,dx
  9414                                  STRING_OUT1:	
  9415 000020F1 AC                      	lodsb
  9416 000020F2 3C24                    	cmp	al,'$'
  9417 000020F4 74F8                    	jz	short noscan
  9418                                  NEXT_STR1:
  9419 000020F6 E88202                  	call	OUTT
  9420 000020F9 EBF6                    	jmp	short STRING_OUT1
  9421                                  
  9422                                  ;----------------------------------------------------------------------------
  9423                                  ;
  9424                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
  9425                                  ;
  9426                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
  9427                                  ;
  9428                                  ;	ENTRY	(ds:dx) = input buffer
  9429                                  ;	EXIT	none
  9430                                  ;	USES	ALL
  9431                                  ;
  9432                                  ;----------------------------------------------------------------------------
  9433                                  
  9434                                  _$STD_CON_STRING_INPUT:		;System call 10
  9435                                  
  9436 000020FB 8CD0                    	mov	ax,ss
  9437 000020FD 8EC0                    	mov	es,ax
  9438 000020FF 89D6                    	mov	si,dx
  9439 00002101 30ED                    	xor	ch,ch
  9440 00002103 AD                      	lodsw
  9441                                  
  9442                                  ;	(AL) = the buffer length
  9443                                  ;	(AH) = the template length
  9444                                  
  9445 00002104 08C0                            or	al,al
  9446 00002106 74E6                            jz	short noscan	;Buffer is 0 length!!?
  9447 00002108 88E3                    	mov	bl,ah		;Init template counter
  9448 0000210A 88EF                            mov	bh,ch		;Init template counter
  9449                                  
  9450                                  ;	(BL) = the number of bytes in the template
  9451                                  
  9452 0000210C 38D8                            cmp	al,bl
  9453 0000210E 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
  9454 00002110 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
  9455 00002113 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
  9456                                  
  9457                                  ; The number of chars in the template is >= the number of chars in buffer or
  9458                                  ; there is no CR at the end of the template.  This is an inconsistant state
  9459                                  ; of affairs.  Pretend that the template was empty:
  9460                                  ;
  9461                                  
  9462                                  NOEDIT:	
  9463 00002115 88EB                    	mov	bl,ch		;Reset buffer
  9464                                  EDITON: 
  9465 00002117 88C2                    	mov	dl,al
  9466 00002119 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
  9467                                  
  9468                                  ;	Top level.  We begin to read a line in.
  9469                                  
  9470                                  NEWLIN: 
  9471 0000211A 36A0[A701]              	mov	al,[SS:CARPOS]
  9472 0000211E 36A2[A801]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
  9473                                  
  9474 00002122 56                      	push	si
  9475 00002123 BF[A901]                	mov	di,INBUF ;Build the new line here
  9476 00002126 36882E[1405]            	mov	byte [SS:INSMODE],ch ;Insert mode off
  9477 0000212B 88EF                    	mov	bh,ch		;No chars from template yet
  9478 0000212D 88EE                    	mov	dh,ch		;No chars to new line yet
  9479 0000212F E851FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
  9480 00002132 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
  9481 00002134 7503                    	jnz	short GOTCH
  9482                                  
  9483                                  ;	This is the main loop of reading in a character and processing it.
  9484                                  ;
  9485                                  ;	(BH) = the index of the next byte in the template
  9486                                  ;	(BL) = the length of the template
  9487                                  ;	(DH) = the number of bytes in the buffer
  9488                                  ;	(DL) = the length of the buffer
  9489                                  
  9490                                  GETCH:
  9491 00002136 E84AFF                  	call	_$STD_CON_INPUT_NO_ECHO
  9492                                  GOTCH:
  9493                                  ;
  9494                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
  9495                                  ; input queue.
  9496                                  ;
  9497 00002139 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
  9498 0000213B 74F9                    	jz	short GETCH
  9499                                  
  9500                                  ;	If the leading char is the function-key lead byte
  9501                                  
  9502 0000213D 363A06[D212]                    cmp	al,[SS:ESCCHAR]
  9503 00002142 7438                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
  9504                                  
  9505                                  ;	Rubout and ^H are both destructive backspaces.
  9506                                  
  9507 00002144 3C7F                            cmp	al,c_DEL ; 7FH
  9508 00002146 742B                            jz	short BACKSPJ
  9509 00002148 3C08                            cmp	al,c_BS  ; 8
  9510 0000214A 7427                            jz	short BACKSPJ
  9511                                  
  9512                                  	; MSDOS 6.0
  9513                                  ;;	^W deletes backward once and then backs up until a letter is before the
  9514                                  ;;	cursor
  9515                                  ;
  9516                                  ;	CMP     AL,"W"-"@" ; 17h
  9517                                  ;
  9518                                  ;;	The removal of the comment characters before the jump statement will
  9519                                  ;;	cause ^W to backup a word.
  9520                                  ;
  9521                                  ;;***	JZ	short WordDel
  9522                                  ;	NOP
  9523                                  ;	NOP
  9524                                  ;	CMP     AL,"U"-"@" ; 15h
  9525                                  ;
  9526                                  ;;	The removal of the comment characters before the jump statement will
  9527                                  ;;	cause ^U to clear a line.
  9528                                  ;
  9529                                  ;;***	JZ	short LineDel
  9530                                  ;	NOP
  9531                                  ;	NOP
  9532                                  
  9533                                  ;	CR terminates the line.
  9534                                  
  9535 0000214C 3C0D                            cmp	al,c_CR ; 0Dh
  9536 0000214E 742F                            jz	short ENDLIN
  9537                                  
  9538                                  ;	LF goes to a new line and keeps on reading.
  9539                                  
  9540 00002150 3C0A                            cmp	al,c_LF ; 0Ah
  9541 00002152 7441                    	jz	short PHYCRLF
  9542                                  
  9543                                  ;	^X (or ESC) deletes the line and starts over
  9544                                  
  9545                                  	; MSDOS 3.3
  9546                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
  9547                                  	;jz	short KILNEW
  9548                                  	;MSDOS 6.0
  9549 00002154 3C1B                    	cmp	al,CANCEL ; 1Bh
  9550 00002156 7442                    	jz	short KILNEW
  9551                                  
  9552                                  ; Otherwise, we save the input character.
  9553                                  
  9554                                  SAVCH:	
  9555 00002158 38D6                    	cmp	dh,dl
  9556 0000215A 7319                    	jnb	short BUFFUL		; buffer is full.
  9557 0000215C AA                              stosb
  9558 0000215D FEC6                    	inc	dh                      ; increment count in buffer.
  9559 0000215F E8B302                  	call	BUFOUT			;Print control chars nicely
  9560                                  
  9561 00002162 36803E[1405]00                  cmp	byte [SS:INSMODE], 0
  9562 00002168 75CC                    	jnz	short GETCH		; insertmode => don't advance template
  9563 0000216A 38DF                            cmp	bh,bl
  9564 0000216C 73C8                            jnb	short GETCH		; no more characters in template
  9565 0000216E 46                              inc	si                      ; Skip to next char in template
  9566 0000216F FEC7                            inc	bh                      ; remember position in template
  9567 00002171 EBC3                            jmp	short GETCH
  9568                                  
  9569                                  BACKSPJ: 
  9570 00002173 EB38                    	jmp	short BACKSP
  9571                                  
  9572                                  BUFFUL: 
  9573 00002175 B007                    	mov	al, 7			; Bell to signal full buffer
  9574 00002177 E80102                  	call	OUTT
  9575 0000217A EBBA                    	jmp	short GETCH
  9576                                  
  9577                                  ESCAPE: 
  9578                                  	;transfer OEMFunctionKey
  9579 0000217C E98EF6                  	JMP	OEMFunctionKey
  9580                                  
  9581                                  ENDLIN:
  9582 0000217F AA                              stosb				; Put the CR in the buffer
  9583 00002180 E8F801                  	call	OUTT                    ; Echo it
  9584 00002183 5F                              pop	di                      ; Get start of user buffer
  9585 00002184 8875FF                          mov	[di-1], dh		; Tell user how many bytes
  9586 00002187 FEC6                            inc	dh			; DH is length including CR
  9587                                  
  9588                                  COPYNEW:
  9589                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
  9590                                  	;mov	bp, es
  9591                                  	;mov	bx, ds
  9592                                  	;mov	es, bx
  9593                                  	;mov	ds, bp
  9594                                  	;mov	si, INBUF
  9595                                  	;mov	cl, dh
  9596                                  	;rep	movsb
  9597                                  	;retn
  9598                                  
  9599                                  	; CPMIO.ASM (MSDOS 6.0)
  9600                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
  9601                                  	;SAVE	<DS,ES>
  9602 00002189 1E                      	PUSH	DS
  9603 0000218A 06                      	PUSH	ES
  9604                                  	;RESTORE <DS,ES>		; XCHG ES,DS
  9605 0000218B 1F                      	POP	DS
  9606 0000218C 07                      	POP	ES
  9607                                  
  9608                                  ;;hkn; INBUF is in DOSDATA
  9609 0000218D BE[A901]                        MOV     SI,INBUF
  9610 00002190 88F1                            MOV     CL,DH                   ; set up count
  9611 00002192 F3A4                            REP     MOVSB                   ; Copy final line to user buffer
  9612                                  OLDBAK_RETN:
  9613 00002194 C3                              RETN
  9614                                  
  9615                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
  9616                                  
  9617                                  PHYCRLF:
  9618 00002195 E82001                  	CALL	CRLF
  9619 00002198 EB9C                            JMP	short GETCH
  9620                                  
  9621                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
  9622                                  
  9623                                  	; Note: Following routines were not used in IBMDOS.COM
  9624                                  	;	-CRTL+W, CRTL+U is not activated-
  9625                                  	;	but they were in the kernel code!?)
  9626                                  ;
  9627                                  ; Delete the previous line
  9628                                  ;
  9629                                  ;LineDel:
  9630                                  ;	OR      DH,DH
  9631                                  ;	JZ	short GetCh
  9632                                  ;	Call    BackSpace
  9633                                  ;	JMP	short LineDel
  9634                                  
  9635                                  ;
  9636                                  ; delete the previous word.
  9637                                  ;
  9638                                  ;WordDel:
  9639                                  ;WordLoop:
  9640                                  ;	Call    BackSpace               ; backspace the one spot
  9641                                  ;	OR      DH,DH
  9642                                  ;	JZ	short GetChJ
  9643                                  ;	MOV     AL,[ES:DI-1]
  9644                                  ;	cmp     al,'0'
  9645                                  ;	jb	short GetChj
  9646                                  ;	cmp     al,'9'
  9647                                  ;	jbe	short WordLoop
  9648                                  ;	OR      AL,20h
  9649                                  ;	CMP     AL,'a'
  9650                                  ;	JB	short GetChJ
  9651                                  ;	CMP     AL,'z'
  9652                                  ;	JBE	short WordLoop
  9653                                  ;getchj: 
  9654                                  ;	JMP	GetCh
  9655                                  
  9656                                  ; The user wants to throw away what he's typed in and wants to start over.
  9657                                  ; We print the backslash and then go to the next line and tab to the correct
  9658                                  ; spot to begin the buffered input.
  9659                                  
  9660                                  KILNEW:
  9661 0000219A B05C                            mov	al,'\'
  9662 0000219C E8DC01                          call	OUTT            ;Print the CANCEL indicator
  9663 0000219F 5E                              pop	si		;Remember start of edit buffer
  9664                                  PUTNEW:
  9665 000021A0 E81501                  	call	CRLF            ;Go to next line on screen
  9666 000021A3 36A0[A801]              	mov	al,[SS:STARTPOS]
  9667 000021A7 E84702                  	call	TAB             ;Tab over
  9668 000021AA E96DFF                          JMP     NEWLIN		;Start over again
  9669                                  
  9670                                  ;	Destructively back up one character position
  9671                                  
  9672                                  BACKSP:
  9673                                  	; 09/09/2018
  9674 000021AD E80200                  	Call    BackSpace
  9675 000021B0 EB84                    	JMP     GETCH
  9676                                  
  9677                                  BackSpace:
  9678 000021B2 08F6                    	or	dh,dh
  9679 000021B4 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
  9680 000021B6 E85800                  	call	BACKUP          ;Do the backup
  9681 000021B9 268A05                  	mov	al,[es:di]	;Get the deleted char
  9682 000021BC 3C20                            cmp	al,20h	; ' '
  9683 000021BE 730F                    	jnb	short OLDBAK	;Was a normal char
  9684 000021C0 3C09                            cmp	al,c_HT ; 9
  9685 000021C2 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
  9686                                  ;; 9/27/86 fix for ctrl-U backspace
  9687 000021C4 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
  9688 000021C6 7407                    	JZ	short OLDBAK
  9689 000021C8 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
  9690 000021CA 7403                    	JZ	short OLDBAK
  9691                                  ;; 9/27/86 fix for ctrl-U backspace
  9692 000021CC E84500                          call	BACKMES         ;Was a control char, zap the '^'
  9693                                  OLDBAK:
  9694 000021CF 36803E[1405]00                  cmp	byte [SS:INSMODE], 0
  9695 000021D5 75BD                    	jnz	short OLDBAK_RETN ;In insert mode, done
  9696 000021D7 08FF                    	or	bh,bh
  9697 000021D9 74B9                            jz	short OLDBAK_RETN 
  9698                                  				;Not advanced in template, stay where we are
  9699 000021DB FECF                    	dec	bh		;Go back in template
  9700 000021DD 4E                              dec	si
  9701 000021DE C3                      	retn
  9702                                  
  9703                                  BAKTAB:
  9704 000021DF 57                              push	di
  9705 000021E0 4F                              dec	di		;Back up one char
  9706 000021E1 FD                              std			;Go backward
  9707 000021E2 88F1                            mov	cl,dh		;Number of chars currently in line
  9708 000021E4 B020                            mov	al,20h	; ' '
  9709 000021E6 53                              push	bx
  9710 000021E7 B307                            mov	bl,7		;Max
  9711 000021E9 E30E                            jcxz	FIGTAB		;At start, do nothing
  9712                                  FNDPOS:
  9713 000021EB AE                              scasb			;Look back
  9714 000021EC 7609                    	jbe	short CHKCNT
  9715 000021EE 26807D0109              	cmp	byte [es:di+1],9
  9716 000021F3 7409                    	jz	short HAVTAB	;Found a tab
  9717 000021F5 FECB                    	dec	bl		;Back one char if non tab control char
  9718                                  CHKCNT:
  9719 000021F7 E2F2                            loop	FNDPOS
  9720                                  FIGTAB:		
  9721 000021F9 362A1E[A801]            	sub	bl,[SS:STARTPOS]
  9722                                  HAVTAB:
  9723 000021FE 28F3                    	sub	bl,dh
  9724 00002200 00D9                    	add	cl,bl
  9725 00002202 80E107                  	and	cl,7		;CX has correct number to erase
  9726 00002205 FC                      	cld			;Back to normal
  9727 00002206 5B                      	pop	bx
  9728 00002207 5F                      	pop	di
  9729 00002208 74C5                    	jz	short OLDBAK	;Nothing to erase
  9730                                  TABBAK:
  9731 0000220A E80700                  	call	BACKMES
  9732 0000220D E2FB                    	loop	TABBAK		;Erase correct number of chars
  9733 0000220F EBBE                    	jmp	short OLDBAK
  9734                                  
  9735                                  BACKUP:
  9736 00002211 FECE                            dec	dh             ;Back up in line
  9737 00002213 4F                              dec	di
  9738                                  BACKMES:
  9739 00002214 B008                            mov	al,c_BS ; 8	;Backspace
  9740 00002216 E86201                          call	OUTT
  9741 00002219 B020                            mov	al,20h ; ' '	;Erase
  9742 0000221B E85D01                          call	OUTT
  9743 0000221E B008                            mov	al,c_BS ; 8	;Backspace
  9744 00002220 E95801                  	jmp	OUTT		;Done
  9745                                  
  9746                                  ;User really wants an ESC character in his line
  9747                                  TWOESC:	
  9748 00002223 36A0[D212]              	mov	al,[SS:ESCCHAR]
  9749 00002227 E92EFF                  	jmp	SAVCH
  9750                                  
  9751                                  ;Copy the rest of the template
  9752                                  COPYLIN:
  9753 0000222A 88D9                            mov	cl,bl		;Total size of template
  9754 0000222C 28F9                    	sub	cl,bh		;Minus position in template, is number to move
  9755 0000222E EB07                            jmp	short COPYEACH
  9756                                  
  9757                                  COPYSTR:
  9758 00002230 E83400                  	call	FINDOLD         ;Find the char
  9759 00002233 EB02                    	jmp	short COPYEACH  ;Copy up to it
  9760                                  
  9761                                  ;Copy one char from template to line
  9762                                  COPYONE:
  9763 00002235 B101                            mov	cl,1
  9764                                  ;Copy CX chars from template to line
  9765                                  COPYEACH:
  9766 00002237 36C606[1405]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
  9767 0000223D 38D6                    	cmp	dh,dl
  9768 0000223F 740F                            jz	short GETCH2		;At end of line, can't do anything
  9769 00002241 38DF                            cmp	bh,bl
  9770 00002243 740B                            jz	short GETCH2		;At end of template, can't do anything
  9771 00002245 AC                              lodsb
  9772 00002246 AA                              stosb
  9773 00002247 E8CB01                  	call	BUFOUT
  9774 0000224A FEC7                            inc	bh			;Ahead in template
  9775 0000224C FEC6                            inc	dh			;Ahead in line
  9776 0000224E E2E7                            loop	COPYEACH
  9777                                  GETCH2:
  9778 00002250 E9E3FE                          jmp	GETCH
  9779                                  
  9780                                  ;Skip one char in template
  9781                                  SKIPONE:
  9782 00002253 38DF                    	cmp	bh,bl
  9783 00002255 74F9                    	jz	short GETCH2		;At end of template
  9784 00002257 FEC7                    	inc	bh			;Ahead in templat
  9785 00002259 46                      	inc	si
  9786 0000225A E9D9FE                  	jmp	GETCH
  9787                                  
  9788                                  SKIPSTR:
  9789 0000225D E80700                  	call	FINDOLD                 ;Find out how far to go
  9790 00002260 01CE                            add	si,cx			;Go there
  9791 00002262 00CF                            add	bh,cl
  9792 00002264 E9CFFE                          jmp	GETCH
  9793                                  
  9794                                  ;Get the next user char, and look ahead in template for a match
  9795                                  ;CX indicates how many chars to skip to get there on output
  9796                                  ;NOTE: WARNING: If the operation cannot be done, the return
  9797                                  ;       address is popped off and a jump to GETCH is taken.
  9798                                  ;       Make sure nothing extra on stack when this routine
  9799                                  ;       is called!!! (no PUSHes before calling it).
  9800                                  FINDOLD:
  9801 00002267 E819FE                          call	_$STD_CON_INPUT_NO_ECHO
  9802                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
  9803 0000226A 363A06[D212]            	CMP     AL,[SS:ESCCHAR]	; did he type a function key?
  9804                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
  9805                                  	;CMP	AL,[CS:ESCCHAR]
  9806 0000226F 7505                    	JNZ     SHORT FINDSETUP		; no, set up for scan
  9807 00002271 E80FFE                          CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
  9808 00002274 EB1D                            JMP     SHORT NOTFND		; go try again
  9809                                  FINDSETUP:
  9810 00002276 88D9                    	mov	cl,bl
  9811 00002278 28F9                            sub	cl,bh		;CX is number of chars to end of template
  9812 0000227A 7417                    	jz	short NOTFND	;At end of template
  9813 0000227C 49                              dec	cx		;Cannot point past end, limit search
  9814 0000227D 7414                            jz	short NOTFND	 ;If only one char in template, forget it
  9815 0000227F 06                      	push	es
  9816 00002280 1E                      	push	ds
  9817 00002281 07                      	pop	es
  9818 00002282 57                      	push	di
  9819 00002283 89F7                    	mov	di,si		;Template to ES:DI
  9820 00002285 47                      	inc	di
  9821 00002286 F2AE                    	repne	scasb		;Look
  9822 00002288 5F                      	pop	di
  9823 00002289 07                      	pop	es
  9824 0000228A 7507                    	jnz	short NOTFND	;Didn't find the char
  9825 0000228C F6D1                            not	cl		;Turn how far to go into how far we went
  9826 0000228E 00D9                            add	cl,bl		;Add size of template
  9827 00002290 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
  9828                                  FINDOLD_RETN:
  9829 00002292 C3                      	retn
  9830                                  
  9831                                  NOTFND:
  9832 00002293 5D                              pop	bp              ;Chuck return address
  9833 00002294 E99FFE                          jmp	GETCH
  9834                                  
  9835                                  REEDIT:
  9836 00002297 B040                    	mov	al,'@'		;Output re-edit character
  9837 00002299 E8DF00                  	call	OUTT
  9838 0000229C 5F                      	pop	di
  9839 0000229D 57                      	push	di
  9840 0000229E 06                      	push	es
  9841 0000229F 1E                      	push	ds
  9842 000022A0 E8E6FE                  	call	COPYNEW		;Copy current line into template
  9843 000022A3 1F                      	pop	ds
  9844 000022A4 07                      	pop	es
  9845 000022A5 5E                      	pop	si
  9846 000022A6 88F3                    	mov	bl,dh		;Size of line is new size template
  9847 000022A8 E9F5FE                  	jmp	PUTNEW		;Start over again
  9848                                  
  9849                                  EXITINS:
  9850                                  ENTERINS:
  9851 000022AB 36F616[1405]            	not	byte [SS:INSMODE]
  9852 000022B0 E983FE                  	jmp	GETCH
  9853                                  
  9854                                  ;Put a real live ^Z in the buffer (embedded)
  9855                                  CTRLZ:
  9856 000022B3 B01A                    	mov	al,"Z"-"@" ; 1Ah
  9857 000022B5 E9A0FE                          jmp	SAVCH
  9858                                  
  9859                                  ;Output a CRLF
  9860                                  CRLF:
  9861 000022B8 B00D                    	mov	al,c_CR ; 0Dh 
  9862 000022BA E8BE00                  	call	OUTT
  9863 000022BD B00A                    	mov	al,c_LF ; 0Ah
  9864 000022BF E9B900                  	jmp	OUTT
  9865                                  
  9866                                  ;
  9867                                  ;----------------------------------------------------------------------------
  9868                                  ;
  9869                                  ;**	$RAW_CON_IO - Do Raw Console I/O
  9870                                  ;
  9871                                  ;	Input or output raw character from console, no echo
  9872                                  ;
  9873                                  ;	ENTRY	DL = -1 if input
  9874                                  ;		   =  output character if output
  9875                                  ;	EXIT	(AL) = input character if input
  9876                                  ;	USES	all
  9877                                  ;
  9878                                  ;----------------------------------------------------------------------------
  9879                                  ; 20/07/2018 - Retro DOS v3.0
  9880                                  
  9881                                  _$RAW_CON_IO:			; System call 6
  9882                                  
  9883 000022C2 88D0                            MOV     AL,DL
  9884 000022C4 3CFF                            CMP     AL,-1
  9885 000022C6 7542                            JNZ     SHORT RAWOUT
  9886                                          ;LES 	DI,[USER_SP]	; Get pointer to register save area
  9887 000022C8 36C43E[1E05]                    LES     DI,[SS:USER_SP] ; 12/03/2018
  9888 000022CD 31DB                    	XOR     BX,BX
  9889                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
  9890 000022CF E8E41D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
  9891                                          ;JC	SHORT RET17
  9892 000022D2 72BE                            jc	short FINDOLD_RETN
  9893 000022D4 B401                    	MOV     AH,1
  9894 000022D6 E8772A                          CALL	IOFUNC
  9895 000022D9 750B                            JNZ     SHORT RESFLG
  9896 000022DB E8F633                          CALL	SPOOLINT
  9897                                          ;OR	BYTE [ES:DI+16H],40H
  9898 000022DE 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
  9899 000022E3 30C0                            XOR     AL,AL
  9900                                  RET17:
  9901 000022E5 C3                              RETN
  9902                                  
  9903                                  RESFLG:
  9904                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
  9905 000022E6 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
  9906                                  				; Reset user's zero flag
  9907                                  ;RILP:
  9908                                  rci0:
  9909 000022EB E8E633                       	CALL	SPOOLINT
  9910                                  
  9911                                  ;
  9912                                  ;----------------------------------------------------------------------------
  9913                                  ;
  9914                                  ;**	$Raw_CON_INPUT - Raw Console Input
  9915                                  ;
  9916                                  ;	Input raw character from console, no echo
  9917                                  ;
  9918                                  ;	ENTRY	none
  9919                                  ;	EXIT	(al) = character
  9920                                  ;	USES	all
  9921                                  ;
  9922                                  ;----------------------------------------------------------------------------
  9923                                  ;
  9924                                  
  9925                                  ;rci0:	invoke	SPOOLINT
  9926                                  
  9927                                  	;entry	$RAW_CON_INPUT
  9928                                  
  9929                                  _$RAW_CON_INPUT:		; System call 7
  9930 000022EE 53                      	push	bx
  9931 000022EF 31DB                            XOR     BX,BX
  9932                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
  9933 000022F1 E8C21D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
  9934 000022F4 5B                              pop	bx
  9935 000022F5 72EE                    	JC	SHORT RET17
  9936 000022F7 B401                            MOV     AH,1
  9937 000022F9 E8542A                          CALL	IOFUNC
  9938                                  	;JZ	SHORT RILP	; MSDOS 2.11
  9939                                  	;XOR     AH,AH
  9940                                          ;CALL	IOFUNC
  9941                                          ;RETN
  9942 000022FC 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
  9943 000022FE B484                    	MOV	AH,84h
  9944 00002300 CD2A                    	INT	int_IBM  ; int 2Ah
  9945 00002302 EBE7                    	JMP	short rci0
  9946                                  rci5:	
  9947 00002304 30E4                            XOR     AH,AH
  9948 00002306 E8472A                          CALL	IOFUNC
  9949 00002309 C3                              RETN
  9950                                  
  9951                                  ;
  9952                                  ;       Output the character in AL to stdout
  9953                                  ;
  9954                                  	;entry   RAWOUT
  9955                                  
  9956                                  RAWOUT:
  9957 0000230A 53                              PUSH    BX
  9958 0000230B BB0100                          MOV     BX,1
  9959                                  
  9960                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
  9961 0000230E E8A51D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
  9962 00002311 721B                            JC      SHORT RAWRET1
  9963                                  	;
  9964                                  	; MSDOS 2.11
  9965                                          ;TEST	BYTE [SI+18H],080H	; output to file?
  9966                                          ;JZ	SHORT RAWNORM		; if so, do normally
  9967                                          ;PUSH	DS
  9968                                          ;PUSH	SI
  9969                                          ;LDS	SI,[SI+19H]		; output to special?
  9970                                  	;TEST	BYTE [SI+4],ISSPEC
  9971                                  	;POP	SI
  9972                                  	;
  9973                                          
  9974                                  	; MSDOS 3.3 & MSDOS 6.0
  9975                                  	;mov	bx,[si+5]
  9976 00002313 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
  9977                                   ;
  9978                                   ; If we are a network handle OR if we are not a local device then go do the
  9979                                   ; output the hard way.
  9980                                   ;	
  9981                                  	;and	bx,8080h
  9982 00002316 81E38080                	AND	BX,sf_isnet+devid_device
  9983                                  	;cmp	bx,80h
  9984 0000231A 81FB8000                	CMP	BX,devid_device
  9985 0000231E 7510                    	jnz     short RAWNORM
  9986 00002320 1E                      	push    ds
  9987                                  	;lds	bx,[si+7]
  9988 00002321 C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
  9989                                  	;test	byte [bx+4],10h
  9990 00002324 F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
  9991                                  	;
  9992                                  
  9993 00002328 1F                              POP     DS
  9994 00002329 7405                            JZ      SHORT RAWNORM		; if not, do normally
  9995 0000232B CD29                            INT     int_fastcon   ; int 29h	; quickly output the char
  9996                                  
  9997                                          ;JMP     SHORT RAWRET
  9998                                  ;RAWNORM:
  9999                                  ;	CALL    RAWOUT3
 10000                                  
 10001                                  RAWRET: 
 10002 0000232D F8                      	CLC
 10003                                  RAWRET1:
 10004 0000232E 5B                              POP     BX
 10005                                  RAWRET2:
 10006 0000232F C3                      	RETN
 10007                                  
 10008                                  RAWNORM:
 10009 00002330 E80700                  	CALL    RAWOUT3
 10010 00002333 EBF8                    	jmp	short RAWRET
 10011                                  
 10012                                  ;
 10013                                  ;       Output the character in AL to handle in BX
 10014                                  ;
 10015                                  ;	entry   RAWOUT2
 10016                                  
 10017                                  RAWOUT2:
 10018                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10019                                  	;JC	SHORT RET18
 10020 00002335 E87E1D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10021 00002338 72F5                    	JC	SHORT RAWRET2
 10022                                  RAWOUT3:
 10023 0000233A 50                              PUSH    AX
 10024 0000233B EB03                            JMP     SHORT RAWOSTRT
 10025                                  ROLP:
 10026 0000233D E89433                          CALL	SPOOLINT
 10027                                  
 10028                                  	; MSDOS 6.0
 10029                                  	;OR	word [DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 10030                                  				;AN002; set control break
 10031                                  	;;invoke DSKSTATCHK
 10032                                  	;call	DSKSTATCHK	;AN002; check control break
 10033                                  
 10034                                  RAWOSTRT:
 10035 00002340 B403                            MOV     AH,3
 10036 00002342 E80B2A                          CALL    IOFUNC
 10037 00002345 74F6                            JZ      SHORT ROLP
 10038                                  
 10039                                  	; MSDOS 6.0
 10040                                  ;SR;
 10041                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 10042                                  ;the user failed. We do not send a char if this happens. We however return 
 10043                                  ;to the caller with carry clear because this DOS call does not return any
 10044                                  ;status. 
 10045                                  ;
 10046                                  	;inc	ax		;fail on I24 if ax = -1
 10047                                  	;POP	AX
 10048                                  	;jz	short nosend	;yes, do not send char
 10049                                  	;MOV	AH,2
 10050                                  	;call	IOFUNC
 10051                                  ;nosend:
 10052                                  	;CLC			; Clear carry indicating successful
 10053                                  	;retn
 10054                                  
 10055                                  	; MSDOS 3.3 & MSDOS 2.11
 10056 00002347 58                              POP     AX
 10057 00002348 B402                            MOV     AH,2
 10058 0000234A E8032A                          CALL    IOFUNC
 10059 0000234D F8                              CLC                     ; Clear carry indicating successful
 10060                                  RET18:    
 10061 0000234E C3                      	RETN
 10062                                  
 10063                                  ;;10/08/2018
 10064                                  ; 20/07/2018 - Retro DOS v3.0
 10065                                  ; ---------------------------------------------------------------------------
 10066                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 10067                                  ; ---------------------------------------------------------------------------
 10068                                  
 10069                                  ; This routine is called at DOS init
 10070                                  
 10071                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 10072                                  ;;OUTMES:
 10073                                  ;;	;LODS	CS:BYTE PTR [SI]
 10074                                  ;;	CS	LODSB
 10075                                  ;;	CMP     AL,"$" ; 24h
 10076                                  ;;	JZ	SHORT RET18
 10077                                  ;;	CALL	OUTT
 10078                                  ;;	JMP     SHORT OUTMES
 10079                                  
 10080                                  ; ---------------------------------------------------------------------------
 10081                                  
 10082                                  ; 20/07/2018 - Retro DOS v3.0
 10083                                  
 10084                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 10085                                  
 10086                                  ;
 10087                                  ;----------------------------------------------------------------------------
 10088                                  ;
 10089                                  ; Inputs:
 10090                                  ;	AX=0 save the DEVCALL request packet
 10091                                  ;	  =1 restore the DEVCALL request packet
 10092                                  ; Function:
 10093                                  ;	save or restore the DEVCALL packet
 10094                                  ; Returns:
 10095                                  ;	none
 10096                                  ;
 10097                                  ;----------------------------------------------------------------------------
 10098                                  ;
 10099                                  
 10100                                  Save_Restore_Packet:
 10101 0000234F 1E                      	PUSH	DS
 10102 00002350 06                      	PUSH	ES
 10103 00002351 56                      	PUSH	SI
 10104 00002352 57                      	PUSH	DI
 10105                                  
 10106                                  	; 09/09/2018
 10107 00002353 BF[730F]                	mov	di,FAKE_STACK_2F 
 10108 00002356 BE[0603]                	mov	si,DEVCALL
 10109                                  	;
 10110 00002359 83F800                  	CMP	AX,0		; save packet
 10111                                  	;JZ	short save_packet
 10112 0000235C 7402                    	je	short set_seg 
 10113                                  
 10114                                  	; MSDOS 6.0
 10115                                  restore_packet:
 10116                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	 ;sourec
 10117                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	 ;destination
 10118                                  	; MSDOS 3.3
 10119                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10120                                  	;mov	di,DEVCALL  ; 09/09/2018
 10121                                  	;
 10122                                  	;JMP	short set_seg
 10123                                  	
 10124                                  	; 09/09/2018
 10125 0000235E 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 10126                                  
 10127                                  	; MSDOS 6.0
 10128                                  save_packet:
 10129                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	 ;destination
 10130                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	 ;source
 10131                                  	; 09/09/2018
 10132                                  	; MSDOS 3.3
 10133                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10134                                  	;mov	si,DEVCALL ; 09/09/2018
 10135                                  
 10136                                  set_seg:
 10137                                  	; MSDOS 6.0
 10138                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 10139                                  	; MSDOS 3.3
 10140 00002360 8CC8                    	mov	ax,cs
 10141                                  	;
 10142 00002362 8ED8                    	MOV	DS,AX
 10143 00002364 8EC0                    	MOV	ES,AX
 10144 00002366 B90B00                  	MOV	CX,11		; 11 words to move
 10145 00002369 F3A5                    	REP	MOVSW
 10146                                  
 10147 0000236B 5F                      	POP	DI
 10148 0000236C 5E                      	POP	SI
 10149 0000236D 07                      	POP	ES
 10150 0000236E 1F                      	POP	DS
 10151 0000236F C3                      	retn
 10152                                  
 10153                                  ;============================================================================
 10154                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 10155                                  ;============================================================================
 10156                                  ; 20/07/2018 - Retro DOS v3.0
 10157                                  
 10158                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10159                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10160                                  ;hkn;	not valid. 
 10161                                  
 10162                                  ;
 10163                                  ;----------------------------------------------------------------------------
 10164                                  ;
 10165                                  ;**	$STD_CON_INPUT - System Call 1
 10166                                  ;
 10167                                  ;	Input character from console, echo
 10168                                  ;
 10169                                  ;	ENTRY	none
 10170                                  ;	EXIT	(al) = character
 10171                                  ;	USES	ALL
 10172                                  ;
 10173                                  ;----------------------------------------------------------------------------
 10174                                  ;
 10175                                  
 10176                                  _$STD_CON_INPUT:	;System call 1
 10177                                  	
 10178 00002370 E810FD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 10179 00002373 50                      	PUSH	AX
 10180 00002374 E80400                  	CALL	OUTT
 10181 00002377 58                      	POP	AX
 10182                                  CON_INPUT_RETN:	
 10183 00002378 C3                      	RETN
 10184                                  
 10185                                  ;
 10186                                  ;----------------------------------------------------------------------------
 10187                                  ;
 10188                                  ;**	$STD_CON_OUTPUT - System Call 2
 10189                                  ;
 10190                                  ;	Output character to console
 10191                                  ;
 10192                                  ;	ENTRY	(dl) = character
 10193                                  ;	EXIT	none
 10194                                  ;	USES	all
 10195                                  ;
 10196                                  ;----------------------------------------------------------------------------
 10197                                  ;
 10198                                  
 10199                                  _$STD_CON_OUTPUT:	;System call 2
 10200                                  
 10201 00002379 88D0                    	MOV	AL,DL
 10202                                  
 10203                                  OUTT:
 10204 0000237B 3C20                    	CMP	AL,20H ; " "
 10205 0000237D 725E                    	JB	SHORT CTRLOUT
 10206 0000237F 3C7F                    	CMP	AL,c_DEL ; 7Fh
 10207 00002381 7405                    	JZ	SHORT OUTCH
 10208                                  OUTCHA:	
 10209                                  	;INC	BYTE PTR [CARPOS]
 10210 00002383 36FE06[A701]            	INC	BYTE [SS:CARPOS]
 10211                                  OUTCH:
 10212 00002388 1E                      	PUSH	DS
 10213 00002389 56                      	PUSH	SI
 10214                                  	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
 10215                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 10216 0000238A 36FE06[AE02]            	INC	BYTE [SS:CHARCO]	
 10217                                  	;AND	BYTE [SS:CHARCO],00111111B
 10218                                  	; 14/03/2018
 10219 0000238F 368026[AE02]03          	and	byte [SS:CHARCO],3  ; IBMDOS.COM, MSDOS 3.3, MSDOS 2.11
 10220 00002395 7505                    	JNZ	SHORT OUTSKIP
 10221 00002397 50                      	PUSH	AX
 10222 00002398 E85833                  	CALL	STATCHK
 10223 0000239B 58                      	POP	AX
 10224                                  OUTSKIP:
 10225 0000239C E86BFF                  	CALL	RAWOUT				;output the character
 10226 0000239F 5E                      	POP	SI
 10227 000023A0 1F                      	POP	DS
 10228                                  
 10229                                  	;TEST	BYTE PTR [PFLAG],-1
 10230                                  	;retz
 10231 000023A1 36F606[AC02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 10232 000023A7 74CF                    	JZ	SHORT CON_INPUT_RETN
 10233                                  
 10234 000023A9 53                      	PUSH	BX
 10235 000023AA 1E                      	PUSH	DS
 10236 000023AB 56                      	PUSH	SI
 10237 000023AC BB0100                  	MOV	BX,1
 10238                                  	; 20/07/2018 - Retro DOS v3.0
 10239                                  	; MSDOS 3.3
 10240                                  	; MSDOS 6.0 (CPMIO2.ASM)
 10241 000023AF E8041D                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
 10242                                  					;hkn; to sft entry
 10243 000023B2 7226                    	JC	SHORT TRIPOPJ
 10244                                  	;mov	bx,[si+5]
 10245 000023B4 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 10246                                  	;test	bx,8000h
 10247 000023B7 F7C30080                	TEST	BX,sf_isnet	; 8000H		; output to NET?
 10248 000023BB 751D                    	JNZ	short TRIPOPJ 			; if so, no echo
 10249                                  	;test	bx,80h
 10250 000023BD F7C38000                	TEST	BX,devid_device ; 80H		; output to file?
 10251 000023C1 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 10252                                  	; 14/03/2018
 10253                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 10254                                  	;jc	short TRIPOPJ
 10255                                  	; MSDOS 2.11
 10256                                  	;test	byte [SI+18H], 80h
 10257                                  	;jz	short TRIPOPJ
 10258 000023C3 BB0400                  	MOV	BX,4
 10259 000023C6 E8ED1C                  	CALL	GET_IO_SFT
 10260 000023C9 720F                    	JC	SHORT TRIPOPJ
 10261                                  	;test	word [si+5], 800h
 10262 000023CB F744050008              	TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H 
 10263                                  						; StdPrn redirected?
 10264                                  	;JZ	SHORT LISSTRT2J			; No, OK to echo
 10265 000023D0 0F848E00                	jz	LISSTRT2 ; 10/08/2018 
 10266                                  	;MOV	BYTE [PFLAG],0			
 10267 000023D4 36C606[AC02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 10268                                  	; MSDOS 2.11
 10269                                  	;mov	bx,4
 10270                                  	;jmp	short LISSTRT2
 10271                                  	
 10272                                  TRIPOPJ:
 10273                                  	; 20/07/2018
 10274 000023DA E98800                  	JMP	TRIPOP
 10275                                  
 10276                                  ;LISSTRT2J:
 10277                                  ;	JMP	LISSTRT2
 10278                                  
 10279                                  CTRLOUT:
 10280 000023DD 3C0D                    	CMP	AL,c_CR ; 0Dh
 10281 000023DF 7420                    	JZ	SHORT ZERPOS
 10282 000023E1 3C08                    	CMP	AL,c_BS ; 8
 10283 000023E3 7428                    	JZ	SHORT BACKPOS
 10284 000023E5 3C09                    	CMP	AL,c_HT ; 9
 10285 000023E7 759F                    	JNZ	SHORT OUTCH
 10286                                  	;MOV	AL,[CARPOS]
 10287 000023E9 36A0[A701]              	MOV	AL,[SS:CARPOS]
 10288 000023ED 0CF8                    	OR	AL,0F8H
 10289 000023EF F6D8                    	NEG	AL
 10290                                  
 10291                                  TAB:
 10292 000023F1 51                      	PUSH	CX
 10293 000023F2 88C1                    	MOV	CL,AL
 10294 000023F4 B500                    	MOV	CH,0
 10295 000023F6 E307                    	JCXZ	POPTAB
 10296                                  TABLP:
 10297 000023F8 B020                    	MOV	AL," "
 10298 000023FA E87EFF                  	CALL	OUTT
 10299 000023FD E2F9                    	LOOP	TABLP
 10300                                  POPTAB:
 10301 000023FF 59                      	POP	CX
 10302 00002400 C3                      	RETN
 10303                                  
 10304                                  ZERPOS:
 10305                                  	;MOV	BYTE PTR [CARPOS],0
 10306 00002401 36C606[A701]00          	MOV	BYTE [SS:CARPOS],0
 10307                                  	; 10/08/2018
 10308 00002407 E97EFF                  	JMP	OUTCH
 10309                                  OUTJ:	
 10310 0000240A E96EFF                  	JMP	OUTT
 10311                                  
 10312                                  BACKPOS:
 10313                                  	;DEC	BYTE PTR [CARPOS]
 10314 0000240D 36FE0E[A701]            	DEC	BYTE [SS:CARPOS]
 10315 00002412 E973FF                  	JMP	OUTCH
 10316                                  
 10317                                  BUFOUT:
 10318 00002415 3C20                    	CMP	AL," "
 10319 00002417 73F1                    	JAE	SHORT OUTJ		;Normal char
 10320 00002419 3C09                    	CMP	AL,9
 10321 0000241B 74ED                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 10322                                  	;DOS 3.3  7/14/86
 10323 0000241D 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 10324 0000241F 740D                    	JZ	short CTRLU
 10325 00002421 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 10326 00002423 7409                    	JZ	short CTRLU
 10327                                  NOT_CTRLU:
 10328                                  	;DOS 3.3  7/14/86
 10329 00002425 50                      	PUSH	AX
 10330 00002426 B05E                    	MOV	AL,"^"
 10331 00002428 E850FF                  	CALL	OUTT		;Print '^' before control chars
 10332 0000242B 58                      	POP	AX
 10333 0000242C 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 10334                                  CTRLU:
 10335 0000242E E84AFF                  	CALL	OUTT
 10336                                  BUFOUT_RETN:
 10337 00002431 C3                      	RETN
 10338                                  
 10339                                  ;
 10340                                  ;----------------------------------------------------------------------------
 10341                                  ;
 10342                                  ;**	$STD_AUX_INPUT - System Call 3
 10343                                  ;
 10344                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 10345                                  ;
 10346                                  ;	ENTRY	none
 10347                                  ;	EXIT	(al) = character
 10348                                  ;	USES	all
 10349                                  ;
 10350                                  ;----------------------------------------------------------------------------
 10351                                  ;
 10352                                  
 10353                                  _$STD_AUX_INPUT:	;System call 3
 10354                                  
 10355 00002432 E8BE32                  	CALL	STATCHK
 10356 00002435 BB0300                  	MOV	BX,3
 10357 00002438 E87B1C                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 10358                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 10359                                  	;retc
 10360 0000243B 72F4                    	JC	SHORT BUFOUT_RETN
 10361 0000243D EB03                    	JMP	SHORT TAISTRT
 10362                                  AUXILP:
 10363 0000243F E89232                  	CALL	SPOOLINT
 10364                                  TAISTRT:
 10365 00002442 B401                    	MOV	AH,1
 10366 00002444 E80929                  	CALL	IOFUNC
 10367 00002447 74F6                    	JZ	SHORT AUXILP
 10368 00002449 30E4                    	XOR	AH,AH
 10369 0000244B E80229                  	CALL	IOFUNC
 10370 0000244E C3                      	RETN
 10371                                  
 10372                                  ;
 10373                                  ;----------------------------------------------------------------------------
 10374                                  ;
 10375                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 10376                                  ;
 10377                                  ;	ENTRY	(dl) = character
 10378                                  ;	EXIT	none
 10379                                  ;	USES	all
 10380                                  ;
 10381                                  ;----------------------------------------------------------------------------
 10382                                  ;
 10383                                  
 10384                                  _$STD_AUX_OUTPUT:	;System call 4
 10385                                  
 10386 0000244F 53                      	PUSH	BX
 10387 00002450 BB0300                  	MOV	BX,3
 10388 00002453 EB04                    	JMP	SHORT SENDOUT
 10389                                  
 10390                                  ;
 10391                                  ;----------------------------------------------------------------------------
 10392                                  ;
 10393                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 10394                                  ;
 10395                                  ;	ENTRY	(dl) = character
 10396                                  ;	EXIT	none
 10397                                  ;	USES	all
 10398                                  ;
 10399                                  ;----------------------------------------------------------------------------
 10400                                  ;
 10401                                  
 10402                                  _$STD_PRINTER_OUTPUT:	;System call 5
 10403                                  
 10404 00002455 53                      	PUSH	BX
 10405 00002456 BB0400                  	MOV	BX,4
 10406                                  
 10407                                  SENDOUT:
 10408 00002459 88D0                    	MOV	AL,DL
 10409 0000245B 50                      	PUSH	AX
 10410 0000245C E89432                  	CALL	STATCHK
 10411 0000245F 58                      	POP	AX
 10412 00002460 1E                      	PUSH	DS
 10413 00002461 56                      	PUSH	SI
 10414                                  LISSTRT2:
 10415 00002462 E8D0FE                  	CALL	RAWOUT2
 10416                                  TRIPOP:
 10417 00002465 5E                      	POP	SI
 10418 00002466 1F                      	POP	DS
 10419 00002467 5B                      	POP	BX
 10420                                  SCIS_RETN:	; 20/07/2018
 10421 00002468 C3                      	RETN
 10422                                  ;
 10423                                  ;----------------------------------------------------------------------------
 10424                                  ;
 10425                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 10426                                  ;
 10427                                  ;	Check console input status
 10428                                  ;
 10429                                  ;	ENTRY	none
 10430                                  ;	EXIT	AL = -1 character available, = 0 no character
 10431                                  ;	USES	all
 10432                                  ;
 10433                                  ;----------------------------------------------------------------------------
 10434                                  ;
 10435                                  
 10436                                  _$STD_CON_INPUT_STATUS:		 ;System call 11
 10437                                  
 10438 00002469 E88732                  	CALL	STATCHK
 10439 0000246C B000                    	MOV	AL,0			; no xor!!
 10440                                  	;retz
 10441 0000246E 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 10442 00002470 0CFF                    	OR	AL,-1
 10443                                  ;SCIS_RETN:
 10444 00002472 C3                      	RETN
 10445                                  
 10446                                  ;
 10447                                  ;----------------------------------------------------------------------------
 10448                                  ;
 10449                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 10450                                  ;
 10451                                  ;	Flush console input buffer and perform call in AL
 10452                                  ;
 10453                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 10454                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 10455                                  ;		return arguments for the fcn supplied in (AL)
 10456                                  ;	USES	all
 10457                                  ;
 10458                                  ;----------------------------------------------------------------------------
 10459                                  ;
 10460                                  
 10461                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 10462                                  
 10463 00002473 50                      	PUSH	AX
 10464 00002474 52                      	PUSH	DX
 10465 00002475 31DB                    	XOR	BX,BX
 10466 00002477 E83C1C                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 10467                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 10468 0000247A 7205                    	JC	SHORT BADJFNCON
 10469 0000247C B404                    	MOV	AH,4
 10470 0000247E E8CF28                  	CALL	IOFUNC
 10471                                  
 10472                                  BADJFNCON:
 10473 00002481 5A                      	POP	DX
 10474 00002482 58                      	POP	AX
 10475 00002483 88C4                    	MOV	AH,AL
 10476 00002485 3C01                    	CMP	AL,1
 10477 00002487 7413                    	JZ	SHORT REDISPJ
 10478 00002489 3C06                    	CMP	AL,6
 10479 0000248B 740F                    	JZ	SHORT REDISPJ
 10480 0000248D 3C07                    	CMP	AL,7
 10481 0000248F 740B                    	JZ	SHORT REDISPJ
 10482 00002491 3C08                    	CMP	AL,8
 10483 00002493 7407                    	JZ	SHORT REDISPJ
 10484 00002495 3C0A                    	CMP	AL,10
 10485 00002497 7403                    	JZ	SHORT REDISPJ
 10486 00002499 B000                    	MOV	AL,0
 10487 0000249B C3                      	RETN
 10488                                  
 10489                                  REDISPJ:
 10490 0000249C FA                      	CLI
 10491                                  	;transfer REDISP
 10492 0000249D E9A5F0                  	JMP	REDISP
 10493                                  
 10494                                  ;============================================================================
 10495                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 10496                                  ;============================================================================
 10497                                  ; 20/07/2018 - Retro DOS v3.0
 10498                                  
 10499                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 10500                                  ;
 10501                                  ;	$GET_FCB_POSITION
 10502                                  ;	$FCB_DELETE
 10503                                  ;	$GET_FCB_FILE_LENGTH
 10504                                  ;	$FCB_CLOSE
 10505                                  ;	$FCB_RENAME
 10506                                  ;	SaveFCBInfo
 10507                                  ;	ResetLRU
 10508                                  ;	SetOpenAge
 10509                                  ;	LRUFCB
 10510                                  ;	FCBRegen
 10511                                  ;	BlastSFT
 10512                                  ;	CheckFCB
 10513                                  ;	SFTFromFCB
 10514                                  ;	FCBHardErr
 10515                                  ;
 10516                                  ;	Revision history:
 10517                                  ;
 10518                                  ;		Created: ARR 4 April 1983"
 10519                                  ;			 MZ  6 June  1983 completion of functions
 10520                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 10521                                  ;					  times.  Change so successive closes work by
 10522                                  ;					  always returning OK.	Also, detect I/O to
 10523                                  ;					  already closed FCB and return EOF.
 10524                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 10525                                  ;					  out of sft into FCB for reconnection
 10526                                  ;
 10527                                  ;		A000	 version 4.00  Jan. 1988
 10528                                  
 10529                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 10530                                  ;----------------------------------------------------------------------------
 10531                                  ;
 10532                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 10533                                  ;	extent and next record field and set the random record field to point
 10534                                  ;	to that record
 10535                                  ;
 10536                                  ;   Inputs:	DS:DX point to a possible extended FCB
 10537                                  ;   Outputs:	The random record field of the FCB is set to the current record
 10538                                  ;   Registers modified: all
 10539                                  ;
 10540                                  ;----------------------------------------------------------------------------
 10541                                  ;
 10542                                  
 10543                                  _$GET_FCB_POSITION:
 10544 000024A0 E81D05                  	call	GetExtended		; point to FCB
 10545 000024A3 E8ED04                  	call	GetExtent		; DX:AX is current record
 10546                                  	;mov	[si+21h],ax
 10547 000024A6 894421                  	MOV	[SI+SYS_FCB.RR],AX ; drop in low order piece
 10548                                  	;mov	[si+23h],dl
 10549 000024A9 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 10550                                  	;cmp	word [si+0Eh],64
 10551 000024AC 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 10552 000024B0 7303                    	JAE	short GetFCBBye
 10553                                  	;mov	[si+24h],dh
 10554 000024B2 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 10555                                  GetFCBBye:
 10556 000024B5 E961F2                  	jmp	FCB_RET_OK
 10557                                  
 10558                                  
 10559                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 10560                                  ;----------------------------------------------------------------------------
 10561                                  ;
 10562                                  ;**	$FCB_Delete - Delete from FCB Template
 10563                                  ;
 10564                                  ;	given an FCB, remove all directory entries in the current
 10565                                  ;	directory that have names that match the FCB's ?  marks.
 10566                                  ;
 10567                                  ;	ENTRY	(DS:DX) = address of FCB
 10568                                  ;	EXIT	entries matching the FCB are deleted
 10569                                  ;		(al) = ff iff no entries were deleted
 10570                                  ;	USES	all
 10571                                  ;
 10572                                  ;----------------------------------------------------------------------------
 10573                                  ;
 10574                                  
 10575                                  _$FCB_DELETE:		; System call 19
 10576                                  					; OpenBuf is in DOSDATA
 10577 000024B8 BF[6003]                	MOV	DI,OPENBUF 		; appropriate place 
 10578                                  
 10579 000024BB E82D45                  	call	TransFCB		; convert FCB to path
 10580 000024BE 720A                    	JC	short BadPath 		; signal no deletions
 10581                                  
 10582 000024C0 16                      	push	SS
 10583 000024C1 1F                      	pop	DS			; SS is DOSDATA
 10584                                  
 10585 000024C2 E8A30D                  	call	DOS_DELETE		; wham
 10586 000024C5 7203                    	JC	short BadPath
 10587                                  GoodPath:
 10588 000024C7 E94FF2                  	jmp	FCB_RET_OK		; do a good return
 10589                                  BadPath:
 10590                                  	; Error code is in AX
 10591                                  
 10592 000024CA E94FF2                  	jmp	FCB_RET_ERR		; let someone else signal the error
 10593                                  
 10594                                  
 10595                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 10596                                  ;----------------------------------------------------------------------------
 10597                                  ;
 10598                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 10599                                  ;	file in records (rounded up if partial).
 10600                                  ;
 10601                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 10602                                  ;   Outputs:	Random record field updated to reflect the number of records
 10603                                  ;   Registers modified: all
 10604                                  ;
 10605                                  ;----------------------------------------------------------------------------
 10606                                  ;
 10607                                  
 10608                                  _$GET_FCB_FILE_LENGTH:
 10609                                  
 10610 000024CD E8F004                  	call	GetExtended		; get real FCB pointer
 10611                                  					; DX points to Input FCB
 10612                                  
 10613                                  					; OpenBuf is in DOSDATA
 10614 000024D0 BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 10615                                  
 10616 000024D3 1E                      	push	ds			; save pointer to true FCB
 10617 000024D4 56                      	push	si
 10618 000024D5 E81345                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 10619 000024D8 5E                      	pop	si
 10620 000024D9 1F                      	pop	ds
 10621 000024DA 72EE                    	JC	short BadPath
 10622 000024DC 1E                      	push	ds			; save pointer
 10623 000024DD 56                      	push	si
 10624 000024DE 16                      	push	ss		
 10625 000024DF 1F                      	pop	ds
 10626 000024E0 E80811                  	call	GET_FILE_INFO		; grab the info
 10627 000024E3 5E                      	pop	si			; get pointer back
 10628 000024E4 1F                      	pop	ds
 10629 000024E5 72E3                    	JC	short BadPath 		; invalid something
 10630 000024E7 89DA                    	MOV	DX,BX			; get high order size
 10631 000024E9 89F8                    	MOV	AX,DI			; get low order size
 10632                                  	;mov	 bx,[si+0Eh]
 10633 000024EB 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 10634 000024EE 09DB                    	OR	BX,BX			; empty record => 0 size for file
 10635 000024F0 7503                    	JNZ	short GetSize 		; not empty
 10636 000024F2 BB8000                  	MOV	BX,128
 10637                                  GetSize:
 10638 000024F5 89C7                    	MOV	DI,AX			; save low order word
 10639 000024F7 89D0                    	MOV	AX,DX			; move high order for divide
 10640 000024F9 31D2                    	XOR	DX,DX			; clear out high
 10641 000024FB F7F3                    	DIV	BX			; wham
 10642 000024FD 50                      	PUSH	AX			; save dividend
 10643 000024FE 89F8                    	MOV	AX,DI			; get low order piece
 10644 00002500 F7F3                    	DIV	BX			; wham
 10645 00002502 89D1                    	MOV	CX,DX			; save remainder
 10646 00002504 5A                      	POP	DX			; get high order dividend
 10647 00002505 E306                    	JCXZ	LengthStore		; no roundup
 10648 00002507 83C001                  	ADD	AX,1
 10649 0000250A 83D200                  	ADC	DX,0			; 32-bit increment
 10650                                  LengthStore:
 10651                                  	;mov	[si+21h],ax
 10652 0000250D 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 10653                                  	;mov	[si+23h],dl
 10654 00002510 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 10655 00002513 08F6                    	OR	DH,DH
 10656 00002515 74B0                    	JZ	short GoodPath		; not storing insignificant zero
 10657                                  	;mov	[si+24h],dh
 10658 00002517 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 10659                                  GoodRet:
 10660                                  	;jmp	FCB_RET_OK
 10661 0000251A EBAB                    	jmp	short GoodPath
 10662                                  
 10663                                  ;Break <$FCB_Close - close a file>
 10664                                  ;----------------------------------------------------------------------------
 10665                                  ;
 10666                                  ;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
 10667                                  ;	as the FCB may be used for further I/O
 10668                                  ;
 10669                                  ;   Inputs:	DS:DX point to FCB
 10670                                  ;   Outputs:	AL = FF if file was not found on disk
 10671                                  ;   Registers modified: all
 10672                                  ;
 10673                                  ;----------------------------------------------------------------------------
 10674                                  ;
 10675                                  
 10676                                  _$FCB_CLOSE:		; System call 16
 10677                                  
 10678 0000251C 30C0                    	XOR	AL,AL			; default search attributes
 10679 0000251E E89F04                  	call	GetExtended		; DS:SI point to real FCB
 10680 00002521 7403                    	JZ	short NoAttr		; not extended
 10681 00002523 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 10682                                  NoAttr:
 10683                                  					; SS override
 10684 00002526 36A2[0605]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 10685 0000252A E80804                  	call	SFTFromFCB
 10686 0000252D 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 10687                                  
 10688                                  	;
 10689                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 10690                                  	; there is no need to set the SFT's attribute.
 10691                                  	;
 10692                                  
 10693                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 10694                                  	;;; done
 10695                                  
 10696                                  	;mov	al,[es:di+4]
 10697 0000252F 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 10698 00002533 30E4                    	XOR	AH,AH
 10699 00002535 50                      	PUSH	AX
 10700                                  
 10701                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 10702                                  	;;; done
 10703                                  
 10704 00002536 E8E84D                  	call	CheckShare
 10705 00002539 7508                    	JNZ	short NoStash
 10706 0000253B 36A0[0605]              	MOV	AL,[SS:ATTRIB]
 10707                                  	;mov	[es:di+4],al
 10708 0000253F 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 10709                                  NoStash:
 10710                                  	;mov	ax,[si+14h]
 10711 00002543 8B4414                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 10712                                  	;mov	[es:di+0Fh],ax
 10713 00002546 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 10714                                  	;mov	ax,[si+16h]
 10715 0000254A 8B4416                  	MOV	AX,[SI+SYS_FCB.FTIME]
 10716                                  	;mov	[es:di+0Dh],ax
 10717 0000254D 2689450D                	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 10718                                  	;mov	ax,[si+10h]
 10719 00002551 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 10720                                  	;mov	[es:di+11h],ax
 10721 00002554 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 10722                                  	;mov	ax,[si+12h]
 10723 00002558 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 10724                                  	;mov	[es:di+13h],ax
 10725 0000255B 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 10726                                  	;or	word [es:di+5],4000h
 10727 0000255F 26814D050040            	OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 10728 00002565 16                      	push	ss
 10729 00002566 1F                      	pop	ds
 10730 00002567 E85015                  	call	DOS_CLOSE	; wham
 10731 0000256A C43E[3605]              	LES	DI,[THISSFT]
 10732                                  
 10733                                  	;;; 9/8/86 F.C. restore SFT attribute
 10734 0000256E 59                      	POP	CX
 10735                                  	;mov	[es:di+4],cl
 10736 0000256F 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 10737                                  	;;; 9/8/86 F.C. restore SFT attribute
 10738                                  
 10739 00002573 9C                      	PUSHF
 10740                                  	;test	word [es:di],0FFFFh
 10741                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 10742                                  				; zero ref count gets blasted
 10743 00002574 26833D00                	cmp	word [ES:DI],0
 10744 00002578 7507                    	jnz     short CloseOK
 10745 0000257A 50                      	PUSH	AX
 10746 0000257B B04D                    	MOV	AL,'M'
 10747 0000257D E8DA02                  	call	BlastSFT
 10748 00002580 58                      	POP	AX
 10749                                  CloseOK:
 10750 00002581 9D                      	POPF
 10751 00002582 7396                    	JNC	short GoodRet
 10752                                  	;cmp	al,6
 10753 00002584 3C06                    	CMP	AL,error_invalid_handle
 10754 00002586 7492                    	JZ	short GoodRet
 10755                                  	;mov	al,2
 10756 00002588 B002                    	MOV	AL,error_file_not_found
 10757                                  fcb_close_err:
 10758 0000258A E98FF1                  	jmp	FCB_RET_ERR
 10759                                  
 10760                                  ;
 10761                                  ;----------------------------------------------------------------------------
 10762                                  ;
 10763                                  ;**	$FCB_Rename - Rename a File
 10764                                  ;
 10765                                  ;	$FCB_Rename - rename a file in place within a directory.  Renames
 10766                                  ;	multiple files copying from the meta characters.
 10767                                  ;
 10768                                  ;	ENTRY	DS:DX point to an FCB.	The normal name field is the source
 10769                                  ;		    name of the files to be renamed.  Starting at offset 11h
 10770                                  ;		    in the FCB is the destination name.
 10771                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 10772                                  ;		AL = FF -> some files may have been renamed but:
 10773                                  ;			rename to existing file or source file not found
 10774                                  ;	USES	ALL
 10775                                  ;
 10776                                  ;----------------------------------------------------------------------------
 10777                                  ;
 10778                                  
 10779                                  _$FCB_RENAME:		; System call 23
 10780                                  
 10781 0000258D E83004                  	call	GetExtended		; get pointer to real FCB
 10782 00002590 52                      	push	dx
 10783 00002591 8A04                    	MOV	AL,[SI] 		; get drive byte
 10784 00002593 83C610                  	ADD	SI,10h			; point to destination
 10785                                  
 10786                                  					; RenBuf is in DOSDATA
 10787 00002596 BF[E003]                	MOV	DI,RENBUF		; point to destination buffer
 10788 00002599 FF34                    	push	word [SI]
 10789 0000259B 1E                      	push	ds
 10790 0000259C 57                      	push	di			; save source pointer for TransFCB
 10791 0000259D 8804                    	MOV	[SI],AL			; drop in real drive
 10792 0000259F 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 10793 000025A1 E84744                  	call	TransFCB		; munch this pathname
 10794 000025A4 5E                      	pop	si
 10795 000025A5 1F                      	pop	ds	
 10796 000025A6 8F04                    	pop	WORD [SI]		; get path back
 10797 000025A8 5A                      	pop	dx			; Original FCB pointer
 10798 000025A9 721A                    	JC	short fren90		; bad path -> error
 10799                                  
 10800                                  					; SS override for WFP_Start & Ren_WFP
 10801 000025AB 368B36[4A05]            	MOV	SI,[ss:WFP_START]	; get pointer
 10802 000025B0 368936[4C05]            	MOV	[ss:REN_WFP],SI		; stash it
 10803                                  
 10804                                  					; OpenBuf is in DOSDATA
 10805 000025B5 BF[6003]                	MOV	DI,OPENBUF		; appropriate spot
 10806 000025B8 E83044                  	call	TransFCB		; wham
 10807                                  					; NOTE that this call is pointing
 10808                                  					;  back to the ORIGINAL FCB so
 10809                                  					;  SATTRIB gets set correctly
 10810 000025BB 7208                    	JC	short fren90		; error
 10811 000025BD E8530E                  	call	DOS_RENAME
 10812 000025C0 7203                    	JC	short fren90
 10813 000025C2 E954F1                  	jmp	FCB_RET_OK
 10814                                  
 10815                                  ;	Error -
 10816                                  ;
 10817                                  ;	(al) = error code
 10818                                  
 10819                                  fren90:	
 10820 000025C5 E954F1                  	jmp	FCB_RET_ERR
 10821                                  
 10822                                  
 10823                                  ;Break <Misbehavior fixers>
 10824                                  ;
 10825                                  ;   FCBs suffer from several problems.	First, they are maintained in the
 10826                                  ;   user's space so he may move them at will.  Second, they have a small
 10827                                  ;   reserved area that may be used for system information.  Third, there was
 10828                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 10829                                  ;   usage.
 10830                                  ;
 10831                                  ;   This results in the following misbehavior:
 10832                                  ;
 10833                                  ;	infinite opens of the same file:
 10834                                  ;
 10835                                  ;	While (TRUE) {			While (TRUE) {
 10836                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 10837                                  ;	    Read (FCB); 		    Write (FCB);
 10838                                  ;	    }				    }
 10839                                  ;
 10840                                  ;	infinite opens of different files:
 10841                                  ;
 10842                                  ;	While (TRUE) {			While (TRUE) {
 10843                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 10844                                  ;	    Read (FCB); 		    Write (FCB);
 10845                                  ;	    }				    }
 10846                                  ;
 10847                                  ;	multiple closes of the same file:
 10848                                  ;
 10849                                  ;	FCBOpen (FCB);
 10850                                  ;	while (TRUE)
 10851                                  ;	    FCBClose (FCB);
 10852                                  ;
 10853                                  ;	I/O after closing file:
 10854                                  ;
 10855                                  ;	FCBOpen (FCB);
 10856                                  ;	while (TRUE) {
 10857                                  ;	    FCBWrite (FCB);
 10858                                  ;	    FCBClose (FCB);
 10859                                  ;	    }
 10860                                  ;
 10861                                  ;   The following is am implementation of a methodology for emulating the
 10862                                  ;   above with the exception of I/O after close.  We are NOT attempting to
 10863                                  ;   resolve that particular misbehavior.  We will enforce correct behaviour in
 10864                                  ;   FCBs when they refer to a network file or when there is file sharing on
 10865                                  ;   the local machine.
 10866                                  ;
 10867                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 10868                                  ;   structures depending on the file itself and the state of operations of the
 10869                                  ;   OS.  The information contained in this reserved field is enough to
 10870                                  ;   regenerate the SFT for the local non-shared file.  It is assumed that this
 10871                                  ;   regeneration procedure may be expensive.  The SFT for the FCB is
 10872                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 10873                                  ;
 10874                                  ;   No regeneration of SFTs is attempted for network FCBs.
 10875                                  ;
 10876                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 10877                                  ;   file sharer is working.  If the file sharer is present then the SFT is not
 10878                                  ;   regenerated.
 10879                                  ;
 10880                                  ;   Finally, if there is no local sharing, the full name of the file is no
 10881                                  ;   longer available.  We can make up for this by using the following
 10882                                  ;   information:
 10883                                  ;
 10884                                  ;	The Drive number (from the DPB).
 10885                                  ;	The physical sector of the directory that contains the entry.
 10886                                  ;	The relative position of the entry in the sector.
 10887                                  ;	The first cluster field.
 10888                                  ;	The last used SFT.
 10889                                  ;      OR In the case of a device FCB
 10890                                  ;	The low 6 bits of sf_flags (indicating device type)
 10891                                  ;	The pointer to the device header
 10892                                  ;
 10893                                  ;
 10894                                  ;   We read in the particular directory sector and examine the indicated
 10895                                  ;   directory entry.  If it matches, then we are kosher; otherwise, we fail.
 10896                                  ;
 10897                                  ;   Some key items need to be remembered:
 10898                                  ;
 10899                                  ;	Even though we are caching SFTs, they may contain useful sharing
 10900                                  ;	information.  We enforce good behavior on the FCBs.
 10901                                  ;
 10902                                  ;	Network support must not treat FCBs as impacting the ref counts on
 10903                                  ;	open VCs.  The VCs may be closed only at process termination.
 10904                                  ;
 10905                                  ;	If this is not an installed version of the DOS, file sharing will
 10906                                  ;	always be present.
 10907                                  ;
 10908                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 10909                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 10910                                  ;
 10911                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 10912                                  ;	and open_for_both.  This is so the FCB code in the sharer can find the
 10913                                  ;	proper OI record.
 10914                                  ;
 10915                                  ;   The test bits are:
 10916                                  ;
 10917                                  ;	00 -> local file
 10918                                  ;	40 -> sharing local
 10919                                  ;	80 -> network
 10920                                  ;	C0 -> local device
 10921                                  
 10922                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 10923                                  ;----------------------------------------------------------------------------
 10924                                  ;
 10925                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 10926                                  ;	pieces of information into the FCB to allow for subsequent
 10927                                  ;	regeneration. Poke LRU also.
 10928                                  ;
 10929                                  ;   Inputs:	ThisSFT points to a complete SFT.
 10930                                  ;		DS:SI point to the FCB (not an extended one)
 10931                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 10932                                  ;		DS:SI preserved
 10933                                  ;		ES:DI point to sft
 10934                                  ;   Registers modified: All
 10935                                  ;
 10936                                  ;
 10937                                  ;----------------------------------------------------------------------------
 10938                                  ;
 10939                                  
 10940                                  SaveFCBInfo:
 10941                                  
 10942 000025C8 36C43E[3605]            	LES	DI,[SS:THISSFT]		; SS override
 10943 000025CD E80AFA                  	call	IsSFTNet
 10944 000025D0 7419                    	JZ	short SaveLocal		; if not network then save local info
 10945                                  ;
 10946                                  ;----- In net support -----
 10947                                  ;
 10948                                  	; MSDOS 6.0
 10949                                  	;MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 10950                                  	;MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 10951                                  	; MSDOS 3.3
 10952                                  	;mov	ax,[es:di+1Dh]
 10953 000025D2 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 10954                                  	;mov	[si+1Ah],ax
 10955 000025D6 89441A                  	mov	[si+fcb_net_handle],ax
 10956                                  
 10957                                  	; MSDOS 3.3
 10958 000025D9 06                      	push	es
 10959 000025DA 57                      	push	di
 10960                                  	;les	di,[es:di+19h]
 10961 000025DB 26C47D19                	LES	DI,[ES:DI+sf_netid]
 10962                                  	;mov	[si+1Ch],di
 10963 000025DF 897C1C                  	MOV	[SI+fcb_netID],DI	; save net ID
 10964                                  	;mov 	[si+1Eh],es
 10965 000025E2 8C441E                  	MOV	[SI+fcb_netID+2],ES
 10966 000025E5 5F                      	pop	di
 10967 000025E6 07                      	pop	es
 10968                                  
 10969                                  	;mov	bl,80h
 10970 000025E7 B380                    	MOV	BL,FCBNETWORK
 10971                                  ;
 10972                                  ;----- END In net support -----
 10973                                  ;
 10974 000025E9 EB4C                    	jmp	SHORT SaveSFN
 10975                                  
 10976                                  SaveLocal:
 10977                                  	;IF	Installed
 10978 000025EB E8334D                  	call	CheckShare
 10979 000025EE 7402                    	JZ	short SaveNoShare	; no sharer
 10980 000025F0 EB40                    	JMP	short SaveShare		; sharer present
 10981                                  
 10982                                  SaveNoShare:
 10983                                  	;test 	word [es:di+5],80h
 10984 000025F2 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 10985 000025F8 7526                    	JNZ	short SaveNoShareDev	; Device
 10986                                  	;
 10987                                  	; Save no sharing local file information
 10988                                  	;
 10989                                  	;mov	ax,[es:di+1Dh]
 10990 000025FA 268B451D                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 10991                                  	;mov	[si+1Dh],ax
 10992 000025FE 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 10993                                  
 10994                                  	; MSDOS 6.0
 10995                                  	;SR; Store high byte of directory sector
 10996                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 10997                                  	;
 10998                                  	; SR;
 10999                                  	; We have to store the read-only and archive attributes of the file.
 11000                                  	; We extract it from the SFT and store it in the top two bits of the 
 11001                                  	; sector number ( sector number == 22 bits only )
 11002                                  	;
 11003                                  	;mov	bl,[es:di+SF_ENTRY.sf_attr]
 11004                                  	;mov	bh,bl
 11005                                  	;ror	bl,1
 11006                                  	;shl	bh,1
 11007                                  	;or	bl,bh
 11008                                  	;and	bl,0C0h
 11009                                  	;
 11010                                  	;or	al,bl
 11011                                  	;mov	[si+fcb_sfn],al	;sector number = 22-bits
 11012                                  
 11013                                  	; MSDOS 3.3 ($ MSDOS 6.0)
 11014                                  	;mov	al,[es:di+1Fh]
 11015 00002601 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 11016                                  	;mov	[si+1Fh],al
 11017 00002605 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 11018                                  	;mov	ax,[es:di+0Bh]
 11019 00002608 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 11020                                  	;mov	[si+1Bh],ax
 11021 0000260C 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 11022 0000260F B300                    	MOV	BL,0
 11023                                  
 11024                                  	; Create the bits field from the dirty/device bits of the flags word 
 11025                                  	; and the mode byte
 11026                                  
 11027                                  SetFCBBits:
 11028                                  	;mov	ax,[es:di+5]
 11029 00002611 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11030 00002615 24C0                    	AND	AL,0C0h 		; mask off drive bits
 11031                                  	;or	al,[es:di+2]
 11032 00002617 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 11033                                  	;mov	[si+1Ah], al
 11034 0000261B 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 11035                                  
 11036                                  	; MSDOS 6.0
 11037                                  	; SR;
 11038                                  	; Check if we came here for local file or device. If for local file, 
 11039                                  	; skip setting of SFT index
 11040                                  	;
 11041                                  	;or	bl,bl
 11042                                  	;jz	short SaveNoSFN		; do not save SFN if local file
 11043                                  
 11044 0000261E EB17                    	JMP	short SaveSFN 		; go and save SFN
 11045                                  
 11046                                  	; Save no sharing local device information
 11047                                  
 11048                                  SaveNoShareDev:
 11049                                  	;mov	ax,[es:di+7]
 11050 00002620 268B4507                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 11051                                  	;mov	[si+1Ah],ax
 11052 00002624 89441A                  	MOV	[SI+fcb_nsld_drvptr],AX
 11053                                  	;mov	ax,[es:di+9]
 11054 00002627 268B4509                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 11055 0000262B 89441C                  	MOV	[SI+fcb_nsld_drvptr+2],AX
 11056                                  	;mov	bl,40h
 11057 0000262E B340                    	MOV	BL,FCBDEVICE
 11058 00002630 EBDF                    	JMP	SetFCBBits		; go and save SFN
 11059                                  
 11060                                  SaveShare:
 11061                                  	;ENDIF
 11062                                  ;
 11063                                  ;----- In share support -----
 11064                                  ;
 11065                                  	;call	far [ss:ShSave]
 11066 00002632 36FF1E[8400]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 11067                                  ;
 11068                                  ;----- end in share support -----
 11069                                  ;
 11070                                  SaveSFN:
 11071                                  	; MSDOS 3.3
 11072                                  	;mov	ax,[es:di+5]
 11073                                  	;and	al,3Fh
 11074                                  	;or	al,bl
 11075                                  	;mov	[si+19h],al
 11076                                  
 11077                                  	;lea	ax, [di-6]
 11078 00002637 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 11079                                  	
 11080                                  	; Adjust for offset to table.
 11081                                  	
 11082 0000263A 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 11083                                  
 11084 0000263F 53                      	push	bx			;bx = FCB type (net/Share or local)
 11085 00002640 B335                    	mov	bl,53
 11086 00002642 B335                    	MOV	BL,SF_ENTRY.size
 11087 00002644 F6F3                    	DIV	BL
 11088 00002646 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 11089 00002649 5B                      	pop	bx			;restore bx
 11090                                  
 11091                                  SaveNoSFN:
 11092                                  	;mov	ax,[es:di+5]
 11093 0000264A 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11094 0000264E 243F                    	AND	AL,3Fh			; get real drive
 11095 00002650 08D8                    	OR	AL,BL
 11096                                  	;mov	[si+19h],al
 11097 00002652 884419                  	MOV	[SI+fcb_l_drive],AL
 11098                                  
 11099 00002655 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 11100 00002659 40                      	INC	AX
 11101                                  	;mov	[es:di+15h],ax
 11102 0000265A 26894515                	MOV	[ES:DI+sf_LRU],AX
 11103 0000265E 7506                    	JNZ	short SimpleStuff
 11104                                  	
 11105                                  	; lru flag overflowed.	Run through all FCB sfts and adjust:  
 11106                                  	; LRU < 8000H get set to 0.  Others -= 8000h.  This LRU = 8000h
 11107                                  	
 11108                                  	;mov	bx,15h
 11109 00002660 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 11110 00002663 E80500                  	call	ResetLRU
 11111                                  
 11112                                  	;	Set new LRU to AX
 11113                                  SimpleStuff:
 11114 00002666 36A3[1000]              	MOV	[SS:FCBLRU],AX
 11115 0000266A C3                      	retn
 11116                                  
 11117                                  ;Break	<ResetLRU - reset overflowed lru counts>
 11118                                  ;----------------------------------------------------------------------------
 11119                                  ;
 11120                                  ;   ResetLRU - during lru updates, we may wrap at 64K.	We must walk the
 11121                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 11122                                  ;   at 0.
 11123                                  ;
 11124                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 11125                                  ;		ES:DI point to SFT currently being updated
 11126                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 11127                                  ;		AX has 8000h
 11128                                  ;   Registers modified: none
 11129                                  ;
 11130                                  ;----------------------------------------------------------------------------
 11131                                  ;
 11132                                  
 11133                                  ResetLRU:
 11134                                  
 11135                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 11136                                  	; DOSDATA
 11137                                  
 11138 0000266B B80080                  	MOV	AX,8000h
 11139 0000266E 06                      	push	es
 11140 0000266F 57                      	push	di
 11141 00002670 2EC43E[4000]            	LES	DI,[CS:SFTFCB]		; get pointer to head
 11142                                  	;mov	cx,[es:di+4]
 11143 00002675 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 11144                                  	;lea	di,[di+6]
 11145 00002679 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 11146                                  ovScan:
 11147 0000267C 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 11148 0000267F 7703                    	JA	short ovLoop
 11149 00002681 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 11150                                  ovLoop:
 11151                                  	;add	di,53
 11152 00002684 83C735                  	ADD	DI,SF_ENTRY.size	; advance to next
 11153 00002687 E2F3                    	LOOP	ovScan
 11154 00002689 5F                      	pop	di
 11155 0000268A 07                      	pop	es
 11156 0000268B 268901                  	MOV	[ES:DI+BX],AX
 11157 0000268E C3                      	retn
 11158                                  
 11159                                  ;IF  0  ; We dont need this routine any more.
 11160                                  
 11161                                  ;Break	<SetOpenAge - update the open age of a SFT>
 11162                                  ;----------------------------------------------------------------------------
 11163                                  ;
 11164                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 11165                                  ;   we keep the 'open age' or an LRU count based on opens.  We update the
 11166                                  ;   count here and fill in the appropriate field.
 11167                                  ;
 11168                                  ;   Inputs:	ES:DI point to SFT
 11169                                  ;   Outputs:	ES:DI has the open age field filled in.
 11170                                  ;		If open age has wraparound, we will have subtracted 8000h
 11171                                  ;		    from all open ages.
 11172                                  ;   Registers modified: AX
 11173                                  ;
 11174                                  ;----------------------------------------------------------------------------
 11175                                  ;
 11176                                  
 11177                                  SetOpenAge:
 11178                                  
 11179                                  	; 20/07/2018 - Retro DOS v3.0
 11180                                  	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 11181                                  	; (& MSDOS 6.0, FCBIO.ASM)
 11182                                  
 11183                                  	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 11184                                  
 11185 0000268F 2EA1[1200]              	MOV	AX,[CS:OpenLRU]	; SS override
 11186 00002693 40                      	INC	AX
 11187                                  	;mov	[es:di+17h],ax
 11188 00002694 26894517                	MOV	[ES:DI+sf_OpenAge],AX
 11189 00002698 7506                    	JNZ	short SetDone
 11190                                  	;mov	bx,17h
 11191 0000269A BB1700                  	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 11192 0000269D E8CBFF                  	call	ResetLRU
 11193                                  SetDone:
 11194 000026A0 2EA3[1200]              	MOV	[CS:OpenLRU],AX
 11195 000026A4 C3                      	retn
 11196                                  
 11197                                  ;ENDIF	; SetOpenAge no longer needed
 11198                                  
 11199                                  
 11200                                  ; 21/07/2018 - Retro DOS v3.0
 11201                                  
 11202                                  ; LRUFCB for MSDOS 3.3 !
 11203                                  
 11204                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 11205                                  ;----------------------------------------------------------------------------
 11206                                  ;
 11207                                  ;   LRUFCB - find LRU fcb in cache.  Set ThisSFT and return it.  We preserve
 11208                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 11209                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 11210                                  ;
 11211                                  ;   Inputs:	none
 11212                                  ;   Outputs:	ES:DI point to SFT
 11213                                  ;		ThisSFT points to SFT
 11214                                  ;		SFT is zeroed
 11215                                  ;		Carry set of closes failed
 11216                                  ;   Registers modified: none
 11217                                  ;
 11218                                  ;----------------------------------------------------------------------------
 11219                                  ;
 11220                                  
 11221                                  ; MSDOS 6.0
 11222                                  ;IF 0	; rewritten this routine
 11223                                  
 11224                                  LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 11225 000026A5 E850EF                  	call	save_world
 11226                                  	
 11227                                  ; Find nth oldest NET/SHARE FCB.  We want to find its age for the second scan
 11228                                  ; to find the lease recently used one that is younger than the open age.  We
 11229                                  ; operate be scanning the list n times finding the least age that is greater
 11230                                  ; or equal to the previous minimum age.
 11231                                  ;
 11232                                  ;   BP is the count of times we need to go through this loop.
 11233                                  ;   AX is the current acceptable minimum age to consider
 11234                                  ;
 11235 000026A8 2E8B2E[4400]            	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 11236 000026AD 31C0                    	XOR	AX,AX			; low = 0;
 11237                                  ;
 11238                                  ; If we've scanned the table n times, then we are done.
 11239                                  ;
 11240                                  lru1:
 11241 000026AF 83FD00                  	CMP	bp,0			; while (k--) {
 11242 000026B2 7451                    	JZ	short lru75
 11243 000026B4 4D                      	DEC	bp
 11244                                  ;
 11245                                  ; Set up for scan.
 11246                                  ;
 11247                                  ;   AX is the minimum age for consideration
 11248                                  ;   BX is the minimum age found during the scan
 11249                                  ;   SI is the position of the entry that corresponds to BX
 11250                                  ;
 11251 000026B5 BBFFFF                  	MOV	BX,-1			;     min = 0xffff;
 11252 000026B8 89DE                    	MOV	si,BX			;     pos = 0xffff;
 11253 000026BA 2EC43E[4000]            	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 11254                                  	;mov	cx,[es:di+4]
 11255 000026BF 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 11256                                  	;lea	di,[di+6]
 11257 000026C3 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 11258                                  ;
 11259                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 11260                                  ; current entry is busy (indicating a previous aborted allocation), then we
 11261                                  ; are done.  In both cases, we use the found entry.
 11262                                  ;
 11263                                  lru2:
 11264 000026C6 26833D00                	cmp	word [es:di],0
 11265                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 11266 000026CA 7406                    	jz	short lru25
 11267                                  	;cmp	word [es:di],-1
 11268                                  	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
 11269 000026CC 26833DFF                	cmp	word [es:di],sf_busy
 11270 000026D0 7504                    	jnz	short lru3
 11271                                  ;
 11272                                  ; The entry is usable without further scan.  Go and use it.
 11273                                  ;
 11274                                  lru25:
 11275 000026D2 89FE                    	MOV	si,DI			;	      pos = i;
 11276 000026D4 EB69                    	JMP	short lru11		;	      goto got;
 11277                                  ;
 11278                                  ; See if the entry is for the network or for the sharer.
 11279                                  ;
 11280                                  ;  If for the sharer or network then
 11281                                  ;	if the age < current minimum AND >= allowed minimum then
 11282                                  ;	    this entry becomes current minimum
 11283                                  ;
 11284                                  lru3:
 11285                                  	;test	word [es:di+5],8000h
 11286 000026D6 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 11287                                  					;	  if (!net[i]
 11288 000026DC 7505                    	JNZ	short lru35
 11289                                  ;if installed
 11290 000026DE E8404C                  	call	CheckShare		;		&& !sharing)
 11291 000026E1 7410                    	JZ	short lru5		;	  else
 11292                                  ;ENDIF
 11293                                  ;
 11294                                  ; This SFT is for the net or is for the sharer.  See if it less than the
 11295                                  ; current minimum.
 11296                                  ;
 11297                                  lru35:
 11298                                  	;mov	dx,[es:di+17h]
 11299 000026E3 268B5517                	MOV	DX,[ES:DI+sf_OpenAge]
 11300 000026E7 39C2                    	CMP	DX,AX			;	  if (age[i] >= low &&
 11301 000026E9 7208                    	JB	short lru5
 11302 000026EB 39DA                    	CMP	DX,BX
 11303 000026ED 7304                    	JAE	short lru5		;	      age[i] < min) {
 11304                                  ;
 11305                                  ; entry is new minimum.  Remember his age.
 11306                                  ;
 11307 000026EF 89D3                    	mov	bx,DX			;	      min = age[i];
 11308 000026F1 89FE                    	mov	si,di			;	      pos = i;
 11309                                  ;
 11310                                  ; End of loop.	gp back for more
 11311                                  ;
 11312                                  lru5:
 11313                                  	;add	di,53
 11314 000026F3 83C735                  	add	di,SF_ENTRY.size
 11315 000026F6 E2CE                    	loop	lru2			;	      }
 11316                                  ;
 11317                                  ; The scan is complete.  If we have successfully found a new minimum (pos != -1)
 11318                                  ; set then threshold value to this new minimum + 1.  Otherwise, the scan is
 11319                                  ; complete.  Go find LRU.
 11320                                  ;
 11321                                  lru6:	
 11322 000026F8 83FEFF                  	cmp	si,-1			; position not -1?
 11323 000026FB 7408                    	jz	short lru75		; no, done with everything
 11324 000026FD 8D4701                  	lea	ax,[bx+1]		; set new threshold age
 11325 00002700 EBAD                    	jmp	short lru1		; go and loop for more
 11326                                  lru65:	
 11327 00002702 F9                      	stc
 11328 00002703 EB70                    	jmp	short LRUDead		;	  return -1;
 11329                                  ;
 11330                                  ; Main loop is done.  We have AX being the age+1 of the nth oldest sharer or
 11331                                  ; network entry.  We now make a second pass through to find the LRU entry
 11332                                  ; that is local-no-share or has age >= AX
 11333                                  ;
 11334                                  lru75:
 11335 00002705 BBFFFF                  	mov	bx,-1			; min = 0xffff;
 11336 00002708 89DE                    	mov	si,bx			; pos = 0xffff;
 11337 0000270A 2EC43E[4000]            	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 11338                                  	;mov	cx,[es:di+4]
 11339 0000270F 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 11340                                  	;lea	di,[di+6]
 11341 00002713 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 11342                                  ;
 11343                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 11344                                  ; then check for lru.
 11345                                  ;
 11346                                  lru8:
 11347                                  	;test	word [es:di+5],8000h
 11348 00002716 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11349 0000271C 7505                    	jnz	short lru85		; is for network, go check age
 11350 0000271E E8004C                  	call	CheckShare		; sharer here?
 11351 00002721 7406                    	jz	short lru86		; no, go check lru
 11352                                  ;
 11353                                  ; Network or sharer.  Check age
 11354                                  ;
 11355                                  lru85:
 11356                                  	;cmp	[es:di+17h],ax
 11357 00002723 26394517                	cmp	[es:di+sf_OpenAge],ax
 11358 00002727 720C                    	jb	short lru9		; age is before threshold, skip it
 11359                                  ;
 11360                                  ; Check LRU
 11361                                  ;
 11362                                  lru86:
 11363                                  	;cmp	[es:di+15h],bx
 11364 00002729 26395D15                	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 11365 0000272D 7306                    	jae	short lru9		; no, skip this
 11366 0000272F 89FE                    	mov	si,di			; remember position
 11367                                  	;mov	bx,[es:di+15h]
 11368 00002731 268B5D15                	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 11369                                  ;
 11370                                  ; Done with this entry, go back for more.
 11371                                  ;
 11372                                  lru9:
 11373                                  	;add	di, 53
 11374 00002735 83C735                  	add	di,SF_ENTRY.size
 11375 00002738 E2DC                    	loop	lru8
 11376                                  ;
 11377                                  ; Scan is complete.  If we found NOTHING that satisfied us then we bomb
 11378                                  ; out.	The conditions here are:
 11379                                  ;
 11380                                  ;   No local-no-shares AND all net/share entries are older than threshold
 11381                                  ;
 11382                                  lru10:
 11383 0000273A 83FEFF                  	cmp	si,-1			; if no one f
 11384 0000273D 74C3                    	jz	short lru65		;     return -1;
 11385                                  lru11:
 11386 0000273F 89F7                    	mov	di,si
 11387 00002741 2E893E[3605]            	MOV	[CS:THISSFT],DI		; set thissft
 11388 00002746 2E8C06[3805]            	MOV	[CS:THISSFT+2],ES
 11389                                  ;
 11390                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 11391                                  ; is 0.
 11392                                  ;
 11393                                  	;test	word [es:di+5],8000h
 11394 0000274B 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11395 00002751 7505                    	JNZ	short LRUClose
 11396                                  ;IF INSTALLED
 11397 00002753 E8CB4B                  	call	CheckShare
 11398 00002756 7418                    	JZ	short LRUDone
 11399                                  ;ENDIF
 11400                                  ;
 11401                                  ; Repeat close until ref count is 0
 11402                                  ;
 11403                                  LRUClose:
 11404 00002758 16                      	push	ss
 11405 00002759 1F                      	pop	ds
 11406 0000275A C43E[3605]              	LES	DI,[THISSFT]
 11407 0000275E 26833D00                	cmp     word [es:di],0
 11408                                  	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 11409 00002762 740C                    	JZ	short LRUDone 		; nope, all done
 11410 00002764 E85313                  	call	DOS_CLOSE
 11411 00002767 73EF                    	jnc	short LRUClose		; no error => clean up
 11412                                  	;cmp	al,6
 11413 00002769 3C06                    	cmp	al,error_invalid_handle
 11414 0000276B 74EB                    	jz	short LRUClose
 11415 0000276D F9                      	stc
 11416 0000276E EB05                    	JMP	short LRUDead
 11417                                  LRUDone:
 11418 00002770 30C0                    	XOR	AL,AL
 11419 00002772 E8E500                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 11420                                  
 11421                                  LRUDead:
 11422 00002775 E86DEE                  	call	restore_world
 11423 00002778 2EC43E[3605]             	LES     DI,[CS:THISSFT]
 11424 0000277D 7302                    	jnc	short LRUFCB_retn
 11425                                  LRUFCB_err:
 11426                                  	; mov	al, 23h	
 11427 0000277F B023                    	MOV	AL,error_FCB_unavailable
 11428                                  LRUFCB_retn:	
 11429                                  	retn:
 11430                                  
 11431                                  ;ENDIF
 11432                                  
 11433                                  FCBRegen:
 11434                                  	; called from SFTFromFCB. SS already DOSDATA
 11435                                  
 11436                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 11437                                  	; we do not fill, size we do no fill, position we do not fill,
 11438                                  	; bit 14 of flags = TRUE, other bits = FALSE
 11439                                  
 11440                                  	;mov	al,[si+19h]
 11441 00002781 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 11442                                  
 11443                                  	; We discriminate based on the first two bits in the reserved field.
 11444                                  	
 11445                                  	;test	al,80h
 11446 00002784 A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 11447 00002786 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 11448                                  
 11449                                  	;
 11450                                  	; The FCB is for a network or a sharing based system.  At this point 
 11451                                  	; we have already closed the SFT for this guy and reconnection is 
 11452                                  	; impossible.
 11453                                  	;
 11454                                  	; Remember that he may have given us a FCB with bogus information in
 11455                                  	; it. Check to see if sharing is present or if the redir is present.
 11456                                  	; If either is around, presume that we have cycled out the FCB and 
 11457                                  	; give the hard error. Otherwise, just return with carry set.
 11458                                  	;
 11459                                  
 11460 00002788 E8964B                  	call	CheckShare		; test for sharer
 11461 0000278B 7509                    	JNZ	short RegenFail		; yep, fail this.
 11462                                  	;mov	ax,1100h
 11463 0000278D B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 11464 00002790 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 11465                                  			; Return: AL = 00h  not installed, OK to install
 11466                                  			; 01h  not installed, not OK to install
 11467                                  			; FFh  installed
 11468 00002792 08C0                    	OR	AL,AL			; is it there?
 11469 00002794 740C                    	JZ	short RegenDead		; no, just fail the operation
 11470                                  RegenFail:
 11471 00002796 2EA1[E602]              	MOV     AX,[CS:USER_IN_AX]	; SS override
 11472                                  	;cmp	ah,10h
 11473 0000279A 80FC10                  	cmp	AH,FCB_CLOSE
 11474 0000279D 7403                    	jz	short RegenDead
 11475 0000279F E8C701                  	call	FCBHardErr		; massive hard error.
 11476                                  RegenDead:
 11477 000027A2 F9                      	STC				; carry set
 11478                                  FCBRegen_retn:
 11479 000027A3 C3                      	retn
 11480                                  
 11481                                  	;
 11482                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 11483                                  	; so fail the operation.
 11484                                  	;
 11485                                  RegenNoSharing:
 11486 000027A4 E87A4B                  	call	CheckShare		; Sharing around?
 11487 000027A7 75ED                    	JNZ	short RegenFail
 11488                                  	
 11489                                  	; Find an SFT for this guy.
 11490                                  	
 11491                                  	; MSDOS 6.0
 11492                                  	;push	ax
 11493                                  	;mov	al,0			;indicate it is a regen operation
 11494                                  	;call	LRUFCB
 11495                                  	;pop	ax
 11496                                  	;jc	short FCBRegen_retn
 11497                                  
 11498                                  	; MSDOS 3.3
 11499 000027A9 E8F9FE                  	call	LRUFCB
 11500 000027AC 72F5                    	jc	short FCBRegen_retn
 11501                                  
 11502                                  	;mov	word [es:di+2],8002h
 11503 000027AE 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 11504 000027B4 243F                    	AND	AL,3Fh			; get drive number for flags
 11505 000027B6 98                      	CBW
 11506                                  	;or	ax,4000h
 11507 000027B7 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 11508                                  
 11509                                  	;
 11510                                  	; The bits field consists of the upper two bits (dirty and device) 
 11511                                  	; from the SFT and the low 4 bits from the open mode.
 11512                                  	;
 11513                                  
 11514                                  	;mov	cl,[si+1Ah]
 11515 000027BA 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 11516 000027BD 88CD                    	MOV	CH,CL
 11517 000027BF 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 11518 000027C2 08E8                    	OR	AL,CH
 11519                                  	;and	cl,0Fh
 11520 000027C4 80E10F                  	AND	CL,access_mask		; get the mode bits
 11521                                  	;mov	[es:di+2],cl
 11522 000027C7 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 11523                                  	;mov	[es:di+5],ax
 11524 000027CB 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 11525 000027CF 2EA1[E802]              	MOV     AX,[CS:PROC_ID]		; SS override
 11526                                  	;mov	[es:di+31h],ax
 11527 000027D3 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 11528 000027D7 1E                      	push	ds
 11529 000027D8 56                      	push	si
 11530 000027D9 06                      	push	es
 11531 000027DA 57                      	push	di
 11532 000027DB 16                      	push	ss
 11533 000027DC 07                      	pop	es
 11534 000027DD BF[E604]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 11535                                  
 11536 000027E0 B90800                  	MOV	CX,8
 11537 000027E3 46                      	INC	SI			; Skip past drive byte to name in FCB
 11538                                  
 11539                                  	; MSDOS 6.0
 11540                                  	;call	RegenCopyName		;copy the name to NAME1
 11541                                  
 11542                                  	; MSDOS 3.3
 11543                                  RegenCopyName:
 11544 000027E4 AC                      	lodsb
 11545 000027E5 E8272E                  	call	UCase
 11546 000027E8 AA                      	stosb
 11547 000027E9 E2F9                    	loop	RegenCopyName
 11548                                  
 11549 000027EB 16                      	push	ss	; SS is DOSDATA
 11550 000027EC 1F                      	pop	ds
 11551                                  
 11552                                  	;mov	byte [ATTRIB],16h
 11553 000027ED C606[0605]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 11554                                  					; Must set this to something interesting
 11555                                  					; to call DEVNAME.
 11556 000027F2 E8EA22                  	call	DEVNAME 		; check for device
 11557 000027F5 5E                      	pop	si
 11558 000027F6 07                      	pop	es
 11559 000027F7 5E                      	pop	si
 11560 000027F8 1F                      	pop	ds
 11561 000027F9 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 11562                                  
 11563                                  	;
 11564                                  	; Device found.  We can ignore disk-specific info
 11565                                  	;
 11566                                  
 11567                                  	;mov	[es:di+5],bh
 11568 000027FB 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 11569                                  	;mov	byte [es:di+4],0
 11570 000027FF 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 11571                                  					; SS override
 11572 00002804 2EC536[3205]            	LDS	SI,[CS:DEVPT]		; get device driver
 11573                                  	;mov	[es:di+7],si
 11574 00002809 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 11575                                  	;mov	[es:di+9],ds
 11576 0000280D 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 11577 00002811 C3                      	retn				; carry is clear
 11578                                  
 11579                                  RegenDeadJ:
 11580 00002812 EB8E                    	JMP	RegenDead
 11581                                  
 11582                                  	;
 11583                                  	; File found.  Just copy in the remaining pieces.
 11584                                  	;
 11585                                  
 11586                                  RegenFileNoSharing:
 11587                                  	;mov	ax,[es:di+5]
 11588 00002814 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11589 00002818 83E03F                  	AND	AX,03Fh
 11590 0000281B 1E                      	push	ds
 11591 0000281C 56                      	push	si
 11592 0000281D E88540                  	call	FIND_DPB
 11593                                  	;mov	[es:di+7],si
 11594 00002820 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 11595                                  	;mov	[es:di+9],ds
 11596 00002824 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 11597 00002828 5E                      	pop	si
 11598 00002829 1F                      	pop	ds
 11599 0000282A 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 11600                                  					; indicator was bogus
 11601                                  	;mov	ax,[si+1Dh]
 11602 0000282C 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 11603                                  	;mov	[es:di+1Dh],ax
 11604 0000282F 2689451D                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 11605                                  
 11606                                  	;MSDOS6.0
 11607                                  	; SR;
 11608                                  	; Update the higher word of the directory sector from the FCB
 11609                                  	;
 11610                                  
 11611                                  	;MOV	word [ES:DI+SF_ENTRY.sf_dirsec+2],0	;AN000;>32mb
 11612                                  
 11613                                  	; SR;
 11614                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 11615                                  	; number
 11616                                  	;
 11617                                  
 11618                                  	;mov	al,[si+fcb_sfn]
 11619                                  	;and	al,0C0h		;get the 2 attribute bits
 11620                                  	;mov	ah,al
 11621                                  	;rol	ah,1
 11622                                  	;shr	al,1
 11623                                  	;or	al,ah
 11624                                  	;and	al,03Fh		;mask off unused bits
 11625                                  	;mov	[es:di+SF_ENTRY.sf_attr],al
 11626                                  
 11627                                  	;mov	al,[si+fcb_sfn]
 11628                                  	;and	al,03Fh		;mask off top 2 bits -- attr bits
 11629                                  	;sub	ah,ah
 11630                                  	;mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 11631                                  
 11632                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11633                                  	;mov	ax,[si+1Bh]
 11634 00002833 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 11635                                  	;mov	[es:di+0Bh],ax
 11636 00002836 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 11637                                  	;mov	[es:di+1Bh],ax
 11638 0000283A 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 11639                                  	;mov	al,[si+1Fh]
 11640 0000283E 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 11641                                  	;mov  	[es:di+1Fh], al
 11642 00002841 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 11643                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 11644 00002845 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 11645                                  					; Existing FCB entries would be
 11646                                  					; flushed unnecessarily because of
 11647                                  					; check in CheckFCB of the ref_count.
 11648                                  					; July 22/85 - BAS
 11649                                  	;lea	si,[si+1]
 11650 00002848 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 11651                                  	;lea	di,[di+20h] ; MSDOS 3.3 
 11652 0000284B 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 11653                                  	;mov	cx,11
 11654 0000284E B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 11655                                  	
 11656                                  	; 17/05/2019
 11657                                  	; MSDOS 6.0
 11658                                  	;call	RegenCopyName	;copy name to SFT 
 11659                                  	;
 11660                                  	; MSDOS3.3
 11661                                  RegenCopyName2:
 11662 00002851 AC                      	lodsb
 11663 00002852 E8BA2D                  	call    UCase
 11664 00002855 AA                      	stosb
 11665 00002856 E2F9                    	loop    RegenCopyName2
 11666                                  
 11667 00002858 F8                      	clc
 11668 00002859 C3                      	retn
 11669                                  
 11670                                  ;**	BlastSFT - FIll SFT with Garbage
 11671                                  ;
 11672                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 11673                                  ;	various garbage values to put into the SFT.  I don't know why,
 11674                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 11675                                  ;	necessary to show that the SFT is free after filling it.
 11676                                  ;
 11677                                  ;	ENTRY	(es:di) = address of SFT
 11678                                  ;		(al) = fill character
 11679                                  ;	EXIT	(ax) = -1
 11680                                  ;		'C' clear
 11681                                  ;	USES	AX, CX, Flags
 11682                                  
 11683                                  BlastSFT:
 11684 0000285A 57                      	push	di
 11685                                  	;mov	cx,53
 11686 0000285B B93500                  	mov	cx,SF_ENTRY.size
 11687 0000285E F3AA                    	rep	stosb
 11688 00002860 5F                      	pop	di
 11689 00002861 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 11690 00002863 268905                  	mov	[es:di],ax
 11691                                  	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
 11692                                  	;mov	[es:di+15h],ax
 11693 00002866 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 11694 0000286A 48                      	dec	ax	; -1					    ;
 11695                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 11696 0000286B 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 11697                                  BlastSFT_retn:
 11698 0000286F C3                      	retn				; return with 'C' clear     ;
 11699                                  
 11700                                  
 11701                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 11702                                  ;----------------------------------------------------------------------------
 11703                                  ;
 11704                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 11705                                  ;   regenerated.
 11706                                  ;
 11707                                  ;   Inputs:	DS:SI point to FCB (not extended)
 11708                                  ;		AL is SFT index
 11709                                  ;   Outputs:	Carry Set - FCB needs to be regened
 11710                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 11711                                  ;   Registers modified: AX and BX
 11712                                  ;
 11713                                  ;----------------------------------------------------------------------------
 11714                                  ;
 11715                                  
 11716                                  CheckFCB:
 11717                                  		
 11718                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 11719                                  
 11720                                  	; MSDOS6.0
 11721                                  	; SR;
 11722                                  	; We check if the given FCB is for a local file. If so, we return a 
 11723                                  	; bad SFT status forcing the caller to regenerate the SFT.
 11724                                  
 11725                                  	;test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 11726                                  	;jz	short BadSFT		;Local file, return bad SFT
 11727                                  
 11728                                  	; MSDOS 3.3 (& MSDOS6.0)
 11729 00002870 2EC43E[4000]            	LES     DI,[CS:SFTFCB]		; SS override
 11730                                  	;cmp	[es:di+4],al
 11731 00002875 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 11732 00002879 7248                    	JC	short BadSFT
 11733 0000287B B335                    	MOV	BL,SF_ENTRY.size
 11734 0000287D F6E3                    	MUL	BL
 11735                                  	;lea	di,[di+6]
 11736 0000287F 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 11737 00002882 01C7                    	ADD	DI,AX
 11738 00002884 2EA1[E802]              	MOV     AX,[CS:PROC_ID]		; SS override
 11739                                  	;cmp	[es:di+31h],ax
 11740 00002888 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 11741 0000288C 7535                    	JNZ	short BadSFT		; must match process
 11742 0000288E 26833D00                	cmp	word [es:di],0
 11743                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 11744 00002892 742F                    	JZ	short BadSFT		; must also be in use
 11745                                  	;mov	al,[si+19h]
 11746 00002894 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 11747                                  	;test	al,80h
 11748 00002897 A880                    	test	AL,FCBSPECIAL		; a special FCB?
 11749 00002899 7443                    	JZ	short CheckNoShare	; No. try local or device
 11750                                  
 11751                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 11752                                  	; FCBSHARE is a superset of FCBNETWORK.
 11753                                  
 11754 0000289B 50                      	PUSH	AX
 11755                                  	;and	al,0C0h
 11756 0000289C 24C0                    	AND	AL,FCBMASK
 11757                                  	;cmp	al,0C0h
 11758 0000289E 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 11759 000028A0 58                      	POP	AX
 11760 000028A1 7522                    	JNZ	short CheckNet		; yes
 11761                                  ;
 11762                                  ;----- In share support -----
 11763                                  ;
 11764                                  	; 26/07/2019
 11765 000028A3 2EFF1E[8800]            	call	far [cs:JShare+(11*4)]  ; 11 = ShChk
 11766                                  	;Call	far [ss:JShare+(11*4)]	; SS Override
 11767 000028A8 7219                    	JC	short BadSFT
 11768 000028AA EB0A                    	JMP	SHORT CheckD
 11769                                  ;
 11770                                  ;----- End in share support -----
 11771                                  ;
 11772                                  CheckFirClus:
 11773 000028AC 263B5D0B                	cmp     bx,[es:di+0Bh]
 11774 000028B0 263B5D0B                	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 11775 000028B4 750D                    	JNZ	short BadSFT
 11776                                  CheckD: 
 11777 000028B6 243F                    	AND	AL,3Fh
 11778                                  	;mov	ah,[es:di+5]
 11779 000028B8 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 11780 000028BC 80E43F                  	AND	AH,3Fh
 11781 000028BF 38C4                    	CMP	AH,AL
 11782 000028C1 74AC                    	jz	short BlastSFT_retn	; carry is clear
 11783                                  BadSFT: 
 11784 000028C3 F9                      	STC
 11785 000028C4 C3                      	retn				; carry is clear
 11786                                  CheckNet:
 11787                                  ;
 11788                                  ;----- In net support -----
 11789                                  ;
 11790                                  	; MSDOS 6.0
 11791                                  	;MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 11792                                  	;CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 11793                                  	;JNZ	short BadSFT
 11794                                  
 11795                                  	; MSDOS 3.3
 11796                                  	;mov	ax,[si+1Ah]
 11797 000028C5 8B441A                  	mov	ax,[si+fcb_net_handle]
 11798                                  	;cmp	ax,[es:di+1Dh]
 11799 000028C8 263B451D                	cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 11800 000028CC 75F5                    	jnz	short BadSFT
 11801                                  	;cmp	ax,[es:di+19h]
 11802 000028CE 263B4519                	cmp	ax,[ES:DI+sf_netid]
 11803 000028D2 75EF                    	jnz     short BadSFT
 11804                                  	;mov	ax,[si+1Eh]
 11805 000028D4 8B441E                  	mov	ax,[si+fcb_l_attr]
 11806                                  	;cmp	ax,[es:di+1Bh]
 11807 000028D7 263B451B                	cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 11808 000028DB 75E6                    	jnz     short BadSFT
 11809                                  ;
 11810                                  ;----- END In net support -----
 11811                                  ;
 11812                                  CheckNet_retn:
 11813 000028DD C3                      	retn
 11814                                  
 11815                                  CheckNoShare:
 11816                                  	;test	al,40h
 11817 000028DE A840                    	test	AL,FCBDEVICE		; Device?
 11818 000028E0 753F                    	JNZ	short CheckNoShareDev 	; Yes
 11819                                  
 11820                                  	; MSDOS6.0
 11821                                  	; SR;
 11822                                  	; The code below to match a local FCB with its SFT can no longer be
 11823                                  	; used. We just return a no-match status. This check is done right
 11824                                  	; at the top.
 11825                                  	;
 11826                                  
 11827                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 11828                                  	;mov	bx,[si+1Dh]
 11829 000028E2 8B5C1D                  	MOV	BX,[SI+fcb_nsl_dirsec]
 11830                                  	;cmp	bx,[es:di+1Dh]
 11831 000028E5 263B5D1D                	cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 11832 000028E9 75D8                    	jnz	short BadSFT
 11833                                  	;mov	bl,[si+1Fh]
 11834 000028EB 8A5C1F                  	MOV	bl,[SI+fcb_nsl_dirpos]
 11835                                  	;cmp	bl,[es:di+1Fh]
 11836 000028EE 263A5D1F                	cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 11837 000028F2 75CF                    	jnz     short BadSFT
 11838                                  	;mov	bl,[si+1Ah]
 11839 000028F4 8A5C1A                  	MOV	bl,[SI+fcb_nsl_bits]
 11840                                  	;mov	bh,[es:di+5]
 11841 000028F7 268A7D05                	MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 11842 000028FB 30DF                    	xor     bh,bl
 11843 000028FD 80E7C0                  	and     bh,0C0h
 11844 00002900 75C1                    	jnz     short BadSFT
 11845                                  	;xor	bl,[es:di+2]
 11846 00002902 26325D02                	xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 11847 00002906 80E30F                  	and     bl,0Fh
 11848 00002909 75B8                    	jnz     short BadSFT
 11849 0000290B 57                      	push    di
 11850 0000290C 56                      	push    si
 11851                                  	;lea	di,[di+20h]  ; MSDOS 3.3
 11852 0000290D 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 11853                                  	;lea	si,[si+1]
 11854 00002910 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 11855                                  	;mov	cx,11
 11856 00002913 B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 11857 00002916 F3A6                    	repe	cmpsb
 11858 00002918 5E                      	pop     si
 11859 00002919 5F                      	pop     di
 11860 0000291A 75A7                    	jnz     short BadSFT
 11861                                  	;mov	bx,[si+1Bh]
 11862 0000291C 8B5C1B                  	MOV	bX,[SI+fcb_nsl_firclus]
 11863 0000291F EB8B                    	jmp     short CheckFirClus
 11864                                  
 11865                                  CheckNoShareDev:
 11866                                  	;mov	bx,[si+1Ah]
 11867 00002921 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 11868                                  	;cmp	bx,[es:di+7]
 11869 00002924 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 11870 00002928 7599                    	JNZ	short BadSFT
 11871                                  	;mov	bx,[si+1Ch]
 11872 0000292A 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 11873                                  	;cmp	bx,[es:di+9]
 11874 0000292D 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 11875 00002931 7590                    	JNZ	short BadSFT
 11876 00002933 EB81                    	JMP	CheckD
 11877                                  
 11878                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 11879                                  ;----------------------------------------------------------------------------
 11880                                  ;
 11881                                  ;   SFTFromFCB - the workhorse of this compatability crap.  Check to see if
 11882                                  ;	the SFT for the FCB is Good.  If so, make ThisSFT point to it.	If not
 11883                                  ;	good, get one from the cache and regenerate it.  Overlay the LRU field
 11884                                  ;	with PID
 11885                                  ;
 11886                                  ;   Inputs:	DS:SI point to FCB
 11887                                  ;   Outputs:	ThisSFT point to appropriate SFT
 11888                                  ;		Carry clear -> OK ES:DI -> SFT
 11889                                  ;		Carry set -> error in ax
 11890                                  ;   Registers modified: ES,DI, AX
 11891                                  ;
 11892                                  ;----------------------------------------------------------------------------
 11893                                  
 11894                                  SFTFromFCB:
 11895                                  
 11896                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 11897                                  
 11898 00002935 50                      	push	ax
 11899 00002936 53                      	push	bx
 11900                                  	;mov	al,[si+18h]
 11901 00002937 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 11902 0000293A E833FF                  	call	CheckFCB
 11903 0000293D 5B                      	pop	bx
 11904 0000293E 58                      	pop	ax
 11905 0000293F 2E893E[3605]            	MOV	[CS:THISSFT],DI		; SS override
 11906 00002944 2E8C06[3805]            	MOV	[CS:THISSFT+2],ES
 11907 00002949 730F                    	JNC	short Set_SFT		; no problems, just set thissft
 11908 0000294B E8AAEC                  	call	save_world
 11909 0000294E E830FE                  	call	FCBRegen
 11910 00002951 E891EC                  	call	restore_world		; use macro restore world
 11911 00002954 2EA1[D202]              	MOV     AX,[CS:EXTERR]		; SS override
 11912 00002958 7283                    	jc	short CheckNet_retn
 11913                                  
 11914                                  Set_SFT: 
 11915 0000295A 2EC43E[3605]            	LES     DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 11916 0000295F 2EFF36[E802]            	PUSH    word [CS:PROC_ID]	; set process id
 11917                                  	;pop	word [es:di+31h]
 11918 00002964 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 11919 00002968 C3                      	retn				; carry is clear
 11920                                  
 11921                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 11922                                  ;----------------------------------------------------------------------------
 11923                                  ;
 11924                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 11925                                  ;	unavailable FCB.
 11926                                  ;
 11927                                  ;   Inputs:	none.
 11928                                  ;   Outputs:	none.
 11929                                  ;   Registers modified: all
 11930                                  ;
 11931                                  ;----------------------------------------------------------------------------
 11932                                  ;
 11933                                  
 11934                                  FCBHardErr:
 11935                                  	;mov	ax,23h
 11936 00002969 B82300                  	MOV	AX,error_FCB_unavailable
 11937                                  	;mov	byte [cs:ALLOWED],8
 11938 0000296C 2EC606[F702]08          	MOV	byte [CS:ALLOWED],Allowed_FAIL
 11939 00002972 2EC42E[2405]            	LES	BP,[CS:THISDPB]
 11940 00002977 BF0100                  	MOV	DI,1			; Fake some registers
 11941 0000297A 89F9                    	MOV	CX,DI
 11942                                  	;mov	dx,[es:bp+0Bh]
 11943 0000297C 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 11944 00002980 E8C82E                  	call	HARDERR
 11945 00002983 F9                      	STC
 11946 00002984 C3                      	retn
 11947                                  
 11948                                  ;============================================================================
 11949                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 11950                                  ;============================================================================
 11951                                  ; 21/07/2018 - Retro DOS v3.0
 11952                                  
 11953                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 11954                                  ;
 11955                                  ;	GetRR
 11956                                  ;	GetExtent
 11957                                  ;	SetExtent
 11958                                  ;	GetExtended
 11959                                  ;	GetRecSize
 11960                                  ;	FCBIO
 11961                                  ;	$FCB_OPEN
 11962                                  ;	$FCB_CREATE
 11963                                  ;	$FCB_RANDOM_WRITE_BLOCK
 11964                                  ;	$FCB_RANDOM_READ_BLOCK
 11965                                  ;	$FCB_SEQ_READ
 11966                                  ;	$FCB_SEQ_WRITE
 11967                                  ;	$FCB_RANDOM_READ
 11968                                  ;	$FCB_RANDOM_WRITE
 11969                                  ;
 11970                                  ;	Revision history:
 11971                                  ;
 11972                                  ;		Created: ARR 4 April 1983
 11973                                  ;			 MZ  6 June  1983 completion of functions
 11974                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 11975                                  ;				  times.  Change so successive closes work by
 11976                                  ;				  always returning OK.	Also, detect I/O to
 11977                                  ;				  already closed FCB and return EOF.
 11978                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 11979                                  ;				  out of sft into FCB for reconnection
 11980                                  ;
 11981                                  ;	    A000   version 4.00	Jan. 1988
 11982                                  
 11983                                  ; Defintions for FCBOp flags
 11984                                  
 11985                                  RANDOM	equ 2				; random operation
 11986                                  FCBREAD equ 4				; doing a read
 11987                                  BLOCK	equ 8				; doing a block I/O
 11988                                  
 11989                                  ;Break <GetRR - return the random record field in DX:AX>
 11990                                  ;---------------------------------------------------------------------------
 11991                                  ;
 11992                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 11993                                  ;	from the FCB pointed to by DS:SI
 11994                                  ;
 11995                                  ;   Inputs:	DS:SI point to an FCB
 11996                                  ;		BX has record size
 11997                                  ;   Outputs:	DX:AX contain the contents of the random record field
 11998                                  ;   Registers modified: none
 11999                                  ;---------------------------------------------------------------------------
 12000                                  
 12001                                  GetRR:
 12002                                  	;mov	ax,[si+21h]
 12003 00002985 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 12004                                  	;mov	dx,[si+23h]
 12005 00002988 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 12006 0000298B 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 12007 0000298E 7202                    	JB	short GetRRBye
 12008 00002990 30F6                    	XOR	DH,DH
 12009                                  GetRRBye:
 12010 00002992 C3                      	retn
 12011                                  
 12012                                  ;Break <GetExtent - retrieve next location for sequential IO>
 12013                                  ;---------------------------------------------------------------------------
 12014                                  ;
 12015                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 12016                                  ;	NR fields in the FCB.
 12017                                  ;
 12018                                  ;   Inputs:	DS:SI - point to FCB
 12019                                  ;   Outputs:	DX:AX contain the contents of the random record field
 12020                                  ;   Registers modified: none
 12021                                  ;---------------------------------------------------------------------------
 12022                                  
 12023                                  GetExtent:
 12024                                  	;mov	al,[si+20h]
 12025 00002993 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 12026                                  	;mov	dx,[si+0Ch]
 12027 00002996 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 12028 00002999 D0E0                    	SHL	AL,1
 12029 0000299B D1EA                    	SHR	DX,1
 12030 0000299D D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 12031 0000299F 88D4                    	MOV	AH,DL
 12032 000029A1 88F2                    	MOV	DL,DH
 12033 000029A3 30F6                    	XOR	DH,DH
 12034 000029A5 C3                      	retn
 12035                                  
 12036                                  ;Break <SetExtent - update the extent/NR field>
 12037                                  ;---------------------------------------------------------------------------
 12038                                  ;
 12039                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 12040                                  ;	fields
 12041                                  ;
 12042                                  ;   Inputs:	DS:SI point to FCB
 12043                                  ;		DX:AX is a record location in file
 12044                                  ;   Outputs:	Extent/NR fields are filled in
 12045                                  ;   Registers modified: CX
 12046                                  ;---------------------------------------------------------------------------
 12047                                  
 12048                                  SetExtent:
 12049 000029A6 50                      	push	ax
 12050 000029A7 52                      	push	dx
 12051 000029A8 89C1                    	MOV	CX,AX
 12052 000029AA 247F                    	AND	AL,7FH			; next rec field
 12053                                  	;mov	[si+20h],al
 12054 000029AC 884420                  	MOV	[SI+SYS_FCB.NR],AL
 12055 000029AF 80E180                  	AND	CL,80H			; save upper bit
 12056 000029B2 D1E1                    	SHL	CX,1
 12057 000029B4 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 12058 000029B6 88E8                    	MOV	AL,CH
 12059 000029B8 88D4                    	MOV	AH,DL
 12060                                  	;mov	[si+0Ch], ax
 12061 000029BA 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 12062 000029BD 5A                      	pop	dx
 12063 000029BE 58                      	pop	ax
 12064 000029BF C3                      	retn
 12065                                  
 12066                                  ;Break <GetExtended - find FCB in potential extended fcb>
 12067                                  ;---------------------------------------------------------------------------
 12068                                  ;
 12069                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 12070                                  ;
 12071                                  ;   Inputs:	DS:DX point to a possible extended FCB
 12072                                  ;   Outputs:	DS:SI point to the FCB part
 12073                                  ;		zeroflag set if not extended fcb
 12074                                  ;   Registers modified: SI
 12075                                  ;---------------------------------------------------------------------------
 12076                                  
 12077                                  GetExtended:
 12078 000029C0 89D6                    	MOV	SI,DX			; point to Something
 12079 000029C2 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 12080 000029C5 7503                    	JNZ	short GetBye		; not there
 12081 000029C7 83C607                  	ADD	SI,7			; point to FCB
 12082                                  GetBye:
 12083 000029CA 39D6                    	CMP	SI,DX			; set condition codes
 12084                                  getextd_retn:
 12085 000029CC C3                      	retn
 12086                                  
 12087                                  ;Break <GetRecSize - return in BX the FCB record size>
 12088                                  ;---------------------------------------------------------------------------
 12089                                  ;
 12090                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 12091                                  ;
 12092                                  ;   Inputs:	DS:SI point to a non-extended FCB
 12093                                  ;   Outputs:	BX contains the record size
 12094                                  ;   Registers modified: None
 12095                                  ;---------------------------------------------------------------------------
 12096                                  
 12097                                  GetRecSize:
 12098 000029CD 8B5C0E                  	mov	bx,[si+0Eh]
 12099 000029D0 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 12100 000029D3 09DB                    	OR	BX,BX			; is it nul?
 12101 000029D5 74F5                    	jz	short getextd_retn
 12102 000029D7 BB8000                  	MOV	BX,128			; use default size
 12103                                  	;mov	[si+0Eh],bx
 12104 000029DA 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 12105 000029DD C3                      	retn
 12106                                  
 12107                                  ;BREAK <FCBIO - do internal FCB I/O>
 12108                                  ;---------------------------------------------------------------------------
 12109                                  ;
 12110                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 12111                                  ;
 12112                                  ;   Inputs:	FCBOP flags which operations need to be performed
 12113                                  ;		DS:DX point to FCB
 12114                                  ;		CX may have count of number of records to xfer
 12115                                  ;   Outputs:	AL has error code
 12116                                  ;   Registers modified: all
 12117                                  ;---------------------------------------------------------------------------
 12118                                  
 12119                                  FCBIO:
 12120                                  
 12121                                  FEOF	EQU	1
 12122                                  FTRIM	EQU	2
 12123                                  
 12124                                  %define	FCBErr	byte [bp-1]  ; byte	
 12125                                  %define	cRec	word [bp-3]  ; word	
 12126                                  ;%define RecPos	word [bp-7]  ; dword
 12127                                  %define RecPosL	word [bp-7]  ; word
 12128                                  %define RecPosH	word [bp-5]  ; word
 12129                                  %define	RecSize	word [bp-9]  ; word
 12130                                  ;%define bPos	word [bp-13] ; dword
 12131                                  %define bPosL	word [bp-13] ; word
 12132                                  %define bPosH	word [bp-11] ; word
 12133                                  %define cByte	word [bp-15] ; word	
 12134                                  %define cResult word [bp-17] ; word	
 12135                                  %define	cRecRes	word [bp-19] ; word
 12136                                  %define	FCBOp	byte [bp-20] ; byte
 12137                                  
 12138                                  	;Enter
 12139                                  
 12140 000029DE 55                      	push	bp
 12141 000029DF 89E5                    	mov	bp,sp
 12142 000029E1 83EC14                  	sub	sp,20
 12143                                  	;mov	[bp-20],al
 12144 000029E4 8846EC                  	MOV	FCBOp,AL
 12145                                  	;mov	byte [bp-1],0
 12146 000029E7 C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 12147 000029EB E8D2FF                  	call	GetExtended		;   FCB = GetExtended ();
 12148                                  	;test	byte [bp-20],8
 12149 000029EE F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 12150 000029F2 7503                    	JNZ	short GetPos
 12151 000029F4 B90100                  	MOV	CX,1			;	cRec = 1;
 12152                                  GetPos:
 12153                                  	;mov	[bp-3],cx
 12154 000029F7 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 12155 000029FA E896FF                  	call	GetExtent		;   RecPos = GetExtent ();
 12156 000029FD E8CDFF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 12157                                  	;mov	[bp-9],bx
 12158 00002A00 895EF7                  	MOV	RecSize,BX
 12159                                  	;test	byte [bp-20],2
 12160 00002A03 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 12161 00002A07 7403                    	JZ	short GetRec
 12162 00002A09 E879FF                  	call	GetRR			;	RecPos = GetRR ();
 12163                                  GetRec:
 12164                                  	;mov	[bp-7],ax
 12165 00002A0C 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 12166                                  	;mov	[bp-5],dx
 12167 00002A0F 8956FB                  	MOV	RecPosH,DX
 12168 00002A12 E891FF                  	call	SetExtent		;   SetExtent (RecPos);
 12169                                  	;mov	ax,[bp-5]
 12170 00002A15 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 12171 00002A18 F7E3                    	MUL	BX
 12172 00002A1A 89C7                    	MOV	DI,AX
 12173                                  	;mov	ax,[bp-7]
 12174 00002A1C 8B46F9                  	MOV	AX,RecPosL
 12175 00002A1F F7E3                    	MUL	BX
 12176 00002A21 01FA                    	ADD	DX,DI
 12177                                  	;mov	[bp-13],ax
 12178 00002A23 8946F3                  	MOV	bPosL,AX
 12179                                  	;mov	[bp-11],dx
 12180 00002A26 8956F5                  	MOV	bPosH,DX
 12181                                  	;mov	ax,[bp-3]
 12182 00002A29 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 12183 00002A2C F7E3                    	MUL	BX
 12184                                  	;mov	[bp-15],ax
 12185 00002A2E 8946F1                  	MOV	cByte,AX
 12186                                  
 12187                                  ;hkn; 	SS override
 12188 00002A31 360306[DA02]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 12189 00002A36 83D200                  	ADC	DX,0
 12190 00002A39 7419                    	JZ	short DoOper
 12191                                  	;mov	byte [bp-1],2
 12192 00002A3B C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 12193                                  
 12194                                  ;hkn; 	SS override
 12195 00002A3F 36A1[DA02]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 12196 00002A43 F7D8                    	NEG	AX
 12197 00002A45 7501                    	JNZ	short DoDiv
 12198 00002A47 48                      	DEC	AX
 12199                                  DoDiv:
 12200 00002A48 31D2                    	XOR	DX,DX
 12201 00002A4A F7F3                    	DIV	BX
 12202                                  	;mov	[bp-3],ax
 12203 00002A4C 8946FD                  	MOV	cRec,AX
 12204 00002A4F F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 12205                                  	;mov	[bp-15],ax
 12206 00002A51 8946F1                  	MOV	cByte,AX		;	}
 12207                                  DoOper:
 12208 00002A54 31DB                    	XOR	BX,BX
 12209                                  	;mov	[bp-17],bx
 12210 00002A56 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 12211                                  	;cmp	[bp-15],bx
 12212 00002A59 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 12213 00002A5C 7506                    	JNZ	short DoGetExt
 12214                                  	;test	byte [bp-1],2
 12215 00002A5E F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 12216                                  	;JZ	short DoGetExt
 12217                                  	;JMP	short SkipOp
 12218 00002A62 7576                    	jnz	short SkipOp
 12219                                  DoGetExt:
 12220 00002A64 E8CEFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 12221 00002A67 730F                    	JNC	short ContinueOp
 12222                                  FCBDeath:
 12223 00002A69 E8B0EC                  	call	FCB_RET_ERR		; signal error, map for extended
 12224                                  	;mov	word [bp-19],0
 12225 00002A6C C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 12226                                  	;mov	byte [bp-1],1
 12227 00002A71 C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 12228 00002A75 E9F000                  	JMP	FCBSave 		; bam!
 12229                                  ContinueOp:
 12230                                  	;mov	di,offset DOS_READ
 12231                                  	;test	byte [bp-14h],4
 12232                                  	;jnz	short DoContext
 12233                                  	;mov	di,DOS_WRITE
 12234                                  
 12235                                  	;mov	ax,[si+10h]
 12236 00002A78 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 12237                                  	;mov	[es:di+11h],ax
 12238 00002A7B 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 12239                                  	;mov	ax,[si+12h]
 12240 00002A7F 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 12241                                  	;mov	[es:di+13h],ax
 12242 00002A82 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 12243                                  	;mov	ax,[bp-13]
 12244 00002A86 8B46F3                  	MOV	AX,bPosL
 12245                                  	;mov	dx,[bp-11]
 12246 00002A89 8B56F5                  	MOV	DX,bPosH
 12247                                  	;mov	[es:di+15h],ax
 12248 00002A8C 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 12249                                  	;xchg	dx,[es:di+17h]
 12250 00002A90 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 12251 00002A94 52                      	PUSH	DX			; save away Open age.
 12252                                  	;mov	cx,[bp-15]
 12253 00002A95 8B4EF1                  	MOV	CX,cByte		;	cResult =
 12254                                  
 12255                                  ;hkn; DOS_Read is in DOSCODE
 12256 00002A98 BF[FC3D]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 12257                                  	;test	byte [bp-20],4
 12258 00002A9B F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 12259 00002A9F 7503                    	JNZ	short DoContext
 12260                                  
 12261                                  ;hkn; DOS_Write is in DOSCODE
 12262 00002AA1 BF[7D3F]                	MOV	DI,DOS_WRITE
 12263                                  DoContext:
 12264 00002AA4 55                      	push	bp
 12265 00002AA5 1E                      	push	ds
 12266 00002AA6 56                      	push	si
 12267                                  
 12268                                  ;hkn; SS is DOSDATA
 12269 00002AA7 16                      	push	ss
 12270 00002AA8 1F                      	pop	ds
 12271                                  
 12272                                  ;; Fix for disk full
 12273 00002AA9 FFD7                    	CALL	DI
 12274                                  	
 12275 00002AAB 5E                      	pop	si
 12276 00002AAC 1F                      	pop	ds
 12277 00002AAD 5D                      	pop	bp
 12278 00002AAE 72B9                    	JC	short FCBDeath
 12279                                  	
 12280 00002AB0 36803E[8C0F]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 12281 00002AB6 740A                    	JZ	short NODSKFULL
 12282 00002AB8 36C606[8C0F]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 12283                                  	;mov	byte [bp-1],1 
 12284 00002ABE C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 12285                                  NODSKFULL:
 12286                                  ;; Fix for disk full
 12287                                  	;mov	[bp-17],cx
 12288 00002AC2 894EEF                  	MOV	cResult,CX
 12289 00002AC5 E800FB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 12290                                  	;pop	word [es:di+17h]	
 12291 00002AC8 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 12292                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
 12293                                  	;mov	ax,[es:di+11h]
 12294 00002ACC 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 12295                                  	;mov	[si+10h],ax
 12296 00002AD0 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 12297                                  	;mov	ax,[es:di+13h]
 12298 00002AD3 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 12299                                  	;mov	[si+12h],ax
 12300 00002AD7 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 12301                                  					;	}
 12302                                  SkipOp:
 12303                                  	;mov	ax,[bp-17]
 12304 00002ADA 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 12305 00002ADD 31D2                    	XOR	DX,DX
 12306                                  	;div	word [bp-9]
 12307 00002ADF F776F7                  	DIV	RecSize
 12308                                  	;mov	[bp-19],ax
 12309 00002AE2 8946ED                  	MOV	cRecRes,AX
 12310                                  	;add	[bp-7],ax
 12311 00002AE5 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 12312                                  	;adc	word [bp-5],0
 12313 00002AE8 8356FB00                	ADC	RecPosH,0
 12314                                  ;
 12315                                  ; If we have not gotten the expected number of records, we signal an EOF
 12316                                  ; condition.  On input, this is EOF.  On output this is usually disk full.
 12317                                  ; BUT...  Under 2.0 and before, all device output IGNORED this condition.  So
 12318                                  ; do we.
 12319                                  ;
 12320                                  	;cmp	ax,[bp-3]
 12321 00002AEC 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 12322 00002AEF 7412                    	JZ	short TryBlank
 12323                                  	;test	byte [bp-20],4
 12324 00002AF1 F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 12325 00002AF5 7508                    	JNZ	short SetEOF
 12326                                  	;test	word [es:di+5],80h
 12327 00002AF7 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 12328 00002AFD 7504                    	JNZ	short TryBlank
 12329                                  SetEOF:
 12330                                  	;mov	byte [bp-1],1
 12331 00002AFF C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 12332                                  TryBlank:				;
 12333 00002B03 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 12334 00002B05 7426                    	JZ	short SetExt
 12335                                  	;add	word [bp-7],1
 12336 00002B07 8346F901                	ADD	RecPosL,1		;	RecPos++;
 12337                                  	;adc	word [bp-5],0
 12338 00002B0B 8356FB00                	ADC	RecPosH,0
 12339                                  	;test	byte [bp-20],4
 12340 00002B0F F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 12341 00002B13 7418                    	JZ	short SetExt
 12342                                  	;inc	word [bp-19]
 12343 00002B15 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 12344                                  	;mov	byte [bp-1],3
 12345 00002B18 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 12346                                  	;mov	cx,[bp-9]
 12347 00002B1C 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 12348 00002B1F 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 12349 00002B21 30C0                    	XOR	AL,AL
 12350                                  ;hkn; 	SS override
 12351 00002B23 36C43E[DA02]            	les     di,[ss:DMAADD]
 12352                                  	;add	di,[bp-17]
 12353 00002B28 037EEF                  	ADD	DI,cResult
 12354 00002B2B F3AA                    	REP	STOSB			;   }	}
 12355                                  SetExt:
 12356                                  	;mov	dx,[bp-5]
 12357 00002B2D 8B56FB                  	MOV	DX,RecPosH
 12358                                  	;mov	ax,[bp-7]
 12359 00002B30 8B46F9                  	MOV	AX,RecPosL
 12360                                  	;test	byte [bp-20],2
 12361 00002B33 F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 12362 00002B37 7406                    	JZ	short DoSetExt
 12363                                  	;test	byte [bp-20],8
 12364 00002B39 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 12365 00002B3D 7403                    	JZ	short TrySetRR
 12366                                  DoSetExt:
 12367 00002B3F E864FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 12368                                  TrySetRR:
 12369                                  	;test	byte [bp-20],8
 12370 00002B42 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 12371 00002B46 740F                    	JZ	short TryReturn
 12372                                  	;mov	[si+21h],ax
 12373 00002B48 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 12374                                  	;mov	[si+23h],dl
 12375 00002B4B 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 12376                                  	;cmp	word [si+0Eh],64
 12377 00002B4E 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 12378 00002B52 7303                    	JAE	short TryReturn
 12379                                  	;mov	[si+24h],dh
 12380 00002B54 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 12381                                  TryReturn: 
 12382                                  	;test	byte [bp-20],4
 12383 00002B57 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 12384 00002B5B 750B                    	JNZ	short FCBSave
 12385 00002B5D 1E                      	push	ds			;	FCB->FDate = date;
 12386 00002B5E E855ED                  	call	DATE16			;	FCB->FTime = time;
 12387 00002B61 1F                      	pop	ds
 12388                                  	;mov	[si+14h],ax
 12389 00002B62 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 12390                                  	;mov	[si+16h],dx
 12391 00002B65 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 12392                                  FCBSave: 
 12393                                  	;test	byte [bp-20],8
 12394 00002B68 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 12395 00002B6C 7409                    	jz	short DoReturn
 12396                                  	;mov	cx,[bp-19]
 12397 00002B6E 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 12398 00002B71 E897EA                  	call    Get_User_Stack
 12399                                  	;mov	[si+4],cx
 12400 00002B74 894C04                  	MOV	[SI+user_env.user_CX],CX
 12401                                  DoReturn:
 12402                                  	;mov	al,[bp-1]
 12403 00002B77 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 12404                                  	;Leave	
 12405 00002B7A 89EC                    	mov     sp,bp
 12406 00002B7C 5D                      	pop     bp
 12407 00002B7D C3                      	retn
 12408                                  
 12409                                  ; 22/07/2018 - Retro DOS v3.0
 12410                                  
 12411                                  ;Break <$FCB_Open - open an old-style FCB>
 12412                                  ;---------------------------------------------------------------------------
 12413                                  ;
 12414                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 12415                                  ;	for us and asked to have the rest filled in.
 12416                                  ;
 12417                                  ;   Inputs:	DS:DX point to an unopenned FCB
 12418                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 12419                                  ;		FCB has the following fields filled in:
 12420                                  ;		    Time/Date Extent/NR Size
 12421                                  ;---------------------------------------------------------------------------
 12422                                  
 12423                                  _$FCB_OPEN:			; System call 15
 12424                                  
 12425 00002B7E B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 12426                                  
 12427                                  ;hkn; DOS_Open is in DOSCODE
 12428 00002B81 B9[7A37]                	MOV	CX,DOS_OPEN
 12429                                  ;
 12430                                  ; The following is common code for Creation and openning of FCBs.  AX is
 12431                                  ; either attributes (for create) or open mode (for open)...  DS:DX points to
 12432                                  ; the FCB
 12433                                  ;
 12434                                  DoAccess:
 12435 00002B84 3E                      	pushj	ds
 12436 00002B85 52                      	push	dx
 12437 00002B86 51                      	push	cx
 12438 00002B87 50                      	push	ax			; save FCB pointer away
 12439                                  
 12440                                  ;hkn; 	OpenBuf is in DOSDATA
 12441 00002B88 BF[6003]                	MOV	DI,OPENBUF
 12442 00002B8B E85D3E                  	call	TransFCB		; crunch the fcb
 12443 00002B8E 58                      	pop	ax
 12444 00002B8F 59                      	pop	cx
 12445 00002B90 5A                      	pop	dx
 12446 00002B91 1F                      	pop	ds			; get fcb
 12447 00002B92 7303                    	JNC	short FindFCB		; everything seems ok
 12448                                  FCBOpenErr:
 12449                                  ;
 12450                                  ; AL has error code
 12451                                  ;
 12452 00002B94 E985EB                  	jmp	FCB_RET_ERR
 12453                                  FindFCB:
 12454 00002B97 E826FE                  	call	GetExtended		; DS:SI will point to FCB
 12455                                  
 12456                                  	; MSDOS 6.0
 12457                                  	;push	ax
 12458                                  	;mov	al,1			;indicate Open/Create operation
 12459                                  	;call	LRUFCB			; get a sft entry (no error)
 12460                                  	;pop	ax
 12461                                  	;jc	short HardMessage
 12462                                  	
 12463                                  	; MSDOS 3.3
 12464 00002B9A E808FB                  	call	LRUFCB
 12465 00002B9D 722A                    	JC	short HardMessage
 12466                                  
 12467                                  	;mov	word [es:di+2],8000h
 12468 00002B9F 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 12469 00002BA5 1E                      	push	ds
 12470 00002BA6 56                      	push	si
 12471 00002BA7 53                      	push	bx			; save fcb pointer
 12472 00002BA8 89CE                    	MOV	SI,CX
 12473                                  
 12474                                  ;hkn; SS is DOSDATA
 12475 00002BAA 16                      	push	ss
 12476 00002BAB 1F                      	pop	ds			; let DOS_Open see variables
 12477 00002BAC FFD6                    	CALL	SI			; go open the file
 12478 00002BAE 5B                      	pop	bx
 12479 00002BAF 5E                      	pop	si
 12480 00002BB0 1F                      	pop	ds			; get fcb
 12481                                  
 12482                                  ;hkn; SS override
 12483 00002BB1 36C43E[3605]            	LES	DI,[SS:THISSFT]		; get sf pointer
 12484 00002BB6 7319                    	JNC	short FCBOK		; operation succeeded
 12485                                  failopen:
 12486 00002BB8 50                      	PUSH	AX
 12487 00002BB9 B052                    	MOV	AL,"R"                  ; clear out field (free sft)
 12488 00002BBB E89CFC                  	call	BlastSFT
 12489 00002BBE 58                      	POP	AX
 12490                                  	;cmp	ax,4
 12491 00002BBF 83F804                  	CMP	AX,error_too_many_open_files
 12492 00002BC2 7405                    	JZ	short HardMessage
 12493                                  	;cmp	ax,24h
 12494 00002BC4 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 12495 00002BC7 7505                    	jnz	short DeadFCB
 12496                                  HardMessage:
 12497 00002BC9 50                      	PUSH	AX
 12498 00002BCA E89CFD                  	call	FCBHardErr
 12499 00002BCD 58                      	POP	AX
 12500                                  DeadFCB:
 12501 00002BCE E94BEB                  	jmp	FCB_RET_ERR
 12502                                  FCBOK:
 12503                                  	; MSDOS 6.0
 12504                                  	;call	IsSFTNet		       ;AN007;F.C. >32mb  Non Fat file?
 12505                                  	;JNZ	short FCBOK2		       ;AN007;F.C. >32mb  yes
 12506                                  	;call	CheckShare		       ;AN000;F.C. >32mb  share around?
 12507                                  	;JNZ	short FCBOK2		       ;AN000;F.C. >32mb  yes
 12508                                  ;SR;
 12509                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 12510                                  ; LocalSFT variable to reflect this.
 12511                                  ;
 12512                                  	;mov	[cs:LocalSFT],di	;
 12513                                  	;mov	[cs:LocalSFT+2],es; Store the SFT address
 12514                                  ;;SR;
 12515                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 12516                                  ;;
 12517                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 12518                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 12519                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 12520                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 12521                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 12522                                  
 12523                                  FCBOK2:
 12524                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12525 00002BD1 26FF05                  	inc	word [es:di]
 12526                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 12527 00002BD4 E8F1F9                  	call	SaveFCBInfo
 12528                                  	; MSDOS 3.3
 12529 00002BD7 E8B5FA                  	call	SetOpenAge
 12530                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12531                                  	;test	word [es:di+5],80h
 12532 00002BDA 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 12533 00002BE0 7509                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 12534 00002BE2 8A04                    	MOV	AL,[SI]			; get drive byte
 12535 00002BE4 E88D3D                  	call	GETTHISDRV		; convert
 12536 00002BE7 FEC0                    	INC	AL
 12537 00002BE9 8804                    	MOV	[SI],AL			; stash in good drive letter
 12538                                  FCBNoDrive:
 12539                                  	;mov	word [si+0Eh],128
 12540 00002BEB C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 12541                                  
 12542                                  	;mov	ax,[es:di+0Dh]
 12543 00002BF0 268B450D                	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 12544                                  	;mov	[si+16h],ax
 12545 00002BF4 894416                  	MOV	[SI+SYS_FCB.FTIME],AX
 12546                                  	;mov	ax,[es:di+0Fh]
 12547 00002BF7 268B450F                	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 12548                                  	;mov	[si+14h],ax
 12549 00002BFB 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 12550                                  	;mov	ax,[es:di+11h]
 12551 00002BFE 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 12552                                  	;mov	[si+10h],ax
 12553 00002C02 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 12554                                  	;mov	ax,[es:di+13h]
 12555 00002C05 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 12556                                  	;mov	[si+12h],ax
 12557 00002C09 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 12558 00002C0C 31C0                    	XOR	AX,AX			; convenient zero
 12559                                  	;mov	[si+0Ch],ax
 12560 00002C0E 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 12561                                  ;
 12562                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 12563                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 12564                                  ;
 12565                                  
 12566                                  ;hkn; 	SS override
 12567 00002C11 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 12568                                  	;mov	ah,[es:di+4]
 12569 00002C16 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 12570                                  OpenScan:
 12571                                  	;cmp	al,[si+18h]
 12572 00002C1A 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 12573 00002C1D 7407                    	JZ	short SkipCheck
 12574 00002C1F 50                      	push	ax			; preserve count
 12575 00002C20 E84DFC                  	call	CheckFCB		; do they match
 12576 00002C23 58                      	pop	ax			; get count back
 12577 00002C24 7309                    	JNC	short OpenFound		; found a match!
 12578                                  SkipCheck:
 12579 00002C26 FEC0                    	INC	AL			; advance to next FCB
 12580 00002C28 38E0                    	CMP	AL,AH			; table full?
 12581 00002C2A 75EE                    	JNZ	short OpenScan		; no, go for more
 12582                                  OpenDone:
 12583 00002C2C 30C0                    	xor	al,al			; return success
 12584 00002C2E C3                      	retn
 12585                                  ;
 12586                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 12587                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 12588                                  ; Consider:
 12589                                  ;
 12590                                  ;   open (foo)	delete (foo) open (bar)
 12591                                  ;
 12592                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 12593                                  ; foo even though foo is no longer needed; this is due to the server closing
 12594                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 12595                                  ; If we were to CLOSE bar, the server would then close the only reference to
 12596                                  ; bar and subsequent I/O would be lost to the redirector.
 12597                                  ;
 12598                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 12599                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 12600                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 12601                                  ; around.  This will allow us to access the same file through multiple network
 12602                                  ; connections and NOT prematurely terminate when the ref count on one
 12603                                  ; connection goes to zero.
 12604                                  ;
 12605                                  OpenFound:
 12606                                  	;mov	[si+18h],al
 12607 00002C2F 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 12608 00002C32 26FF05                  	inc	word [es:di]
 12609                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] 
 12610                                  					; remember this new invocation
 12611 00002C35 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; update LRU counts
 12612                                  	;mov	[es:di+15h],ax
 12613 00002C39 26894515                	MOV	[ES:DI+sf_LRU],AX
 12614                                  ;
 12615                                  ; We have an FCB sft that is now of no use.  We release sharing info and then
 12616                                  ; blast it to prevent other reuse.
 12617                                  ;
 12618 00002C3D 16                      	push	ss
 12619 00002C3E 1F                      	pop	ds
 12620 00002C3F C43E[3605]              	LES	DI,[THISSFT]
 12621 00002C43 26FF0D                  	dec	word [es:di]
 12622                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 12623                                  					; free the newly allocated SFT
 12624 00002C46 E80A47                  	call	ShareEnd
 12625 00002C49 B043                    	MOV	AL,'C'
 12626 00002C4B E80CFC                  	call	BlastSFT
 12627 00002C4E EBDC                    	JMP	short OpenDone
 12628                                  
 12629                                  ;BREAK	<$FCB_Create - create a new directory entry>
 12630                                  ;----------------------------------------------------------------------------
 12631                                  ;
 12632                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 12633                                  ;	FCB for us and asked to have the rest filled in.
 12634                                  ;
 12635                                  ;   Inputs:	DS:DX point to an unopenned FCB
 12636                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 12637                                  ;		FCB has the following fields filled in:
 12638                                  ;		    Time/Date Extent/NR Size
 12639                                  ;----------------------------------------------------------------------------
 12640                                  
 12641                                  _$FCB_CREATE:		; System call 22
 12642                                  
 12643                                  ;hkn; DOS_Create is in DOSCODE
 12644 00002C50 B9[E436]                	MOV	CX,DOS_CREATE		; routine to call
 12645 00002C53 31C0                    	XOR	AX,AX			; attributes to create
 12646 00002C55 E868FD                  	call	GetExtended		; get extended FCB
 12647 00002C58 7403                    	JZ	short DoAccessJ		; not an extended FCB
 12648 00002C5A 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 12649                                  DoAccessJ:
 12650 00002C5D E924FF                  	JMP	DoAccess		; do dirty work
 12651                                  
 12652                                  ; 22/07/2018 - Retro DOS v3.0
 12653                                  
 12654                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 12655                                  ;----------------------------------------------------------------------------
 12656                                  ;
 12657                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 12658                                  ;	and write a number of blocks from it.
 12659                                  ;
 12660                                  ;   Inputs:	DS:DX point to an FCB
 12661                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 12662                                  ;		AL <> 0 Not enough room on disk for the output
 12663                                  ;
 12664                                  ;----------------------------------------------------------------------------
 12665                                  
 12666                                  _$FCB_RANDOM_WRITE_BLOCK:
 12667                                  	;mov	AL,0Ah	
 12668 00002C60 B00A                    	MOV	AL,RANDOM+BLOCK
 12669 00002C62 E979FD                  	JMP	FCBIO
 12670                                  
 12671                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 12672                                  ;----------------------------------------------------------------------------
 12673                                  ;
 12674                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 12675                                  ;	and read a number of blocks from it.
 12676                                  ;
 12677                                  ;   Inputs:	DS:DX point to an FCB
 12678                                  ;   Outputs:	AL = error codes defined above
 12679                                  ;
 12680                                  ;----------------------------------------------------------------------------
 12681                                  
 12682                                  _$FCB_RANDOM_READ_BLOCK:
 12683                                  	;mov	AL,0Eh	
 12684 00002C65 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 12685 00002C67 E974FD                  	JMP	FCBIO
 12686                                  
 12687                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 12688                                  ;----------------------------------------------------------------------------
 12689                                  ;
 12690                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 12691                                  ;	memory
 12692                                  ;
 12693                                  ;   Inputs:	DS:DX point to an FCB
 12694                                  ;   Outputs:	AL = error codes defined above
 12695                                  ;
 12696                                  ;----------------------------------------------------------------------------
 12697                                  
 12698                                  _$FCB_SEQ_READ:
 12699                                  	;mov	AL,4	
 12700 00002C6A B004                    	MOV	AL,FCBREAD
 12701 00002C6C E96FFD                  	JMP	FCBIO
 12702                                  
 12703                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 12704                                  ;----------------------------------------------------------------------------
 12705                                  ;
 12706                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 12707                                  ;	file
 12708                                  ;
 12709                                  ;   Inputs:	DS:DX point to an FCB
 12710                                  ;   Outputs:	AL = error codes defined above
 12711                                  ;
 12712                                  ;----------------------------------------------------------------------------
 12713                                  
 12714                                  _$FCB_SEQ_WRITE:
 12715 00002C6F B000                    	MOV	AL,0
 12716 00002C71 E96AFD                  	jmp	FCBIO
 12717                                  
 12718                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 12719                                  ;----------------------------------------------------------------------------
 12720                                  ;
 12721                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 12722                                  ;	record from it.
 12723                                  ;
 12724                                  ;   Inputs:	DS:DX point to an FCB
 12725                                  ;   Outputs:	AL = error codes defined above
 12726                                  ;
 12727                                  ;----------------------------------------------------------------------------
 12728                                  
 12729                                  _$FCB_RANDOM_READ:
 12730                                  	;mov	AL,6	
 12731 00002C74 B006                    	MOV	AL,RANDOM+FCBREAD
 12732 00002C76 E965FD                  	jmp	FCBIO			; single block
 12733                                  
 12734                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 12735                                  ;----------------------------------------------------------------------------
 12736                                  ;
 12737                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 12738                                  ;	a record to it.
 12739                                  ;
 12740                                  ;   Inputs:	DS:DX point to an FCB
 12741                                  ;   Outputs:	AL = error codes defined above
 12742                                  ;
 12743                                  ;----------------------------------------------------------------------------
 12744                                  
 12745                                  _$FCB_RANDOM_WRITE:
 12746                                  	;mov	AL,2	
 12747 00002C79 B002                    	MOV	AL,RANDOM
 12748 00002C7B E960FD                  	jmp	FCBIO
 12749                                  
 12750                                  ;============================================================================
 12751                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 12752                                  ;============================================================================
 12753                                  ; 22/07/2018 - Retro DOS v3.0
 12754                                  
 12755                                  ;**	Search.asm
 12756                                  ;
 12757                                  ;	Directory search system calls.
 12758                                  ;	These will be passed direct text of the pathname from the user. 
 12759                                  ;	They will need to be passed through the macro expander prior to
 12760                                  ;	being sent through the low-level stuff. 
 12761                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 12762                                  ;
 12763                                  ;	$Dir_Search_First	  written
 12764                                  ;	$Dir_Search_Next	  written
 12765                                  ;	$Find_First	  written
 12766                                  ;	$Find_Next		  written
 12767                                  ;	PackName		  written
 12768                                  ;
 12769                                  ;	Modification history:
 12770                                  ;
 12771                                  ;	  Created: ARR 4 April 1983
 12772                                  
 12773                                  ;----------------------------------------------------------------------------
 12774                                  ; Procedure Name : $DIR_SEARCH_FIRST
 12775                                  ;
 12776                                  ; Inputs:
 12777                                  ;	DS:DX Points to unopenned FCB
 12778                                  ; Function:
 12779                                  ;	Directory is searched for first matching entry and the directory
 12780                                  ;	entry is loaded at the disk transfer address
 12781                                  ; Returns:
 12782                                  ;	AL = -1 if no entries matched, otherwise 0
 12783                                  ;----------------------------------------------------------------------------
 12784                                  
 12785                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 12786                                  
 12787                                  _$DIR_SEARCH_FIRST:
 12788 00002C7E 368916[3E05]            	MOV	[SS:THISFCB],DX
 12789 00002C83 368C1E[4005]            	MOV	[SS:THISFCB+2],DS
 12790 00002C88 89D6                    	MOV	SI,DX
 12791 00002C8A 803CFF                  	CMP	BYTE [SI],0FFH
 12792 00002C8D 7503                    	JNZ	short NORMFCB4
 12793 00002C8F 83C607                  	ADD	SI,7			; Point to drive select byte
 12794                                  NORMFCB4:
 12795 00002C92 FF34                    	push	word [SI]		; Save original drive byte for later
 12796                                  
 12797 00002C94 16                      	push	ss
 12798 00002C95 07                      	pop	es			; get es to address DOSGroup
 12799                                  
 12800 00002C96 BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 12801 00002C99 E84F3D                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 12802 00002C9C 7304                    	JNC	short SearchIt		; no error, go and look
 12803 00002C9E 5B                      	pop	bx			; Clean stack
 12804                                  ;
 12805                                  ; Error code is in AX
 12806                                  ;
 12807 00002C9F E97AEA                  	jmp	FCB_RET_ERR		; error
 12808                                  
 12809                                  SearchIt:
 12810 00002CA2 16                      	push	ss
 12811 00002CA3 1F                      	pop	ds			; get ready for search
 12812 00002CA4 FF36[DA02]              	push	word [DMAADD]
 12813 00002CA8 FF36[DC02]              	push	word [DMAADD+2]
 12814 00002CAC C706[DA02][6004]        	MOV	WORD [DMAADD],SEARCHBUF
 12815 00002CB2 8C1E[DC02]              	MOV	WORD [DMAADD+2],DS
 12816                                  	; MSDOS 6.0
 12817                                  	;call	GET_FAST_SEARCH 	; search
 12818                                  	; MSDOS 3.3
 12819 00002CB6 E8570C                  	call	DOS_SEARCH_FIRST
 12820 00002CB9 8F06[DC02]              	pop	word [DMAADD+2]
 12821 00002CBD 8F06[DA02]              	pop	word [DMAADD]
 12822 00002CC1 7304                    	JNC	short SearchSet		; no error, transfer info
 12823 00002CC3 5B                      	pop	bx			; Clean stack
 12824                                  ;
 12825                                  ; Error code is in AX
 12826                                  ;
 12827 00002CC4 E955EA                  	jmp	FCB_RET_ERR
 12828                                  
 12829                                  ;
 12830                                  ; The search was successful (or the search-next).  We store the information
 12831                                  ; into the user's FCB for continuation.
 12832                                  ;
 12833                                  SearchSet:
 12834 00002CC7 BE[6004]                	MOV	SI,SEARCHBUF
 12835 00002CCA C43E[3E05]              	LES	DI,[THISFCB]		; point to the FCB
 12836 00002CCE F606[0705]FF            	TEST	byte [EXTFCB],0FFh		;
 12837 00002CD3 7403                    	JZ	short NORMFCB1
 12838 00002CD5 83C707                  	ADD	DI,7			; Point past the extension
 12839                                  NORMFCB1:
 12840 00002CD8 5B                      	pop	bx			; Get original drive byte
 12841 00002CD9 08DB                    	OR	BL,BL
 12842 00002CDB 7506                    	JNZ	short SearchDrv
 12843 00002CDD 8A1E[E402]              	MOV	BL,[CURDRV]
 12844 00002CE1 FEC3                    	INC	BL
 12845                                  SearchDrv:
 12846 00002CE3 AC                      	LODSB				; Get correct search contin drive byte
 12847 00002CE4 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 12848 00002CE6 47                      	INC	DI
 12849                                  	;STOSB				; Store the correct "user" drive byte
 12850                                  					;  at the start of the search info
 12851 00002CE7 B90A00                  	MOV	CX,20/2
 12852 00002CEA F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 12853 00002CEC 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 12854                                  					;   byte to AL
 12855 00002CEE AA                      	STOSB				; Search contin drive byte at end of
 12856                                  					;   contin info
 12857 00002CEF C43E[DA02]              	LES	DI,[DMAADD]
 12858 00002CF3 F606[0705]FF            	TEST	byte [EXTFCB],0FFh
 12859 00002CF8 740E                    	JZ	short NORMFCB2
 12860 00002CFA B0FF                    	MOV	AL,0FFh
 12861 00002CFC AA                      	STOSB
 12862 00002CFD FEC0                    	INC	AL
 12863 00002CFF B90500                  	MOV	CX,5
 12864 00002D02 F3AA                    	REP	STOSB
 12865 00002D04 A0[0805]                	MOV	AL,[SATTRIB]
 12866 00002D07 AA                      	STOSB
 12867                                  NORMFCB2:
 12868 00002D08 88D8                    	MOV	AL,BL			; User Drive byte
 12869 00002D0A AA                      	STOSB
 12870 00002D0B B91000                  	MOV	CX,16			; 32 / 2 words of dir entry
 12871 00002D0E F3A5                    	REP	MOVSW
 12872 00002D10 E906EA                  	jmp	FCB_RET_OK
 12873                                  
 12874                                  ;----------------------------------------------------------------------------
 12875                                  ;
 12876                                  ; Procedure Name : $DIR_SEARCH_NEXT
 12877                                  ;
 12878                                  ; Inputs:
 12879                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 12880                                  ; Function:
 12881                                  ;	Directory is searched for the next matching entry and the directory
 12882                                  ;	entry is loaded at the disk transfer address
 12883                                  ; Returns:
 12884                                  ;	AL = -1 if no entries matched, otherwise 0
 12885                                  ;----------------------------------------------------------------------------
 12886                                  
 12887                                  _$DIR_SEARCH_NEXT:
 12888 00002D13 368916[3E05]            	MOV	[SS:THISFCB],DX
 12889 00002D18 368C1E[4005]            	MOV	[SS:THISFCB+2],DS
 12890 00002D1D 36C606[0805]00          	MOV	byte [SS:SATTRIB],0
 12891 00002D23 36C606[0705]00          	MOV	byte [SS:EXTFCB],0
 12892                                  
 12893 00002D29 16                      	push	ss
 12894 00002D2A 07                      	pop	es
 12895                                  
 12896 00002D2B BF[6004]                	MOV	DI,SEARCHBUF
 12897                                  
 12898 00002D2E 89D6                    	MOV	SI,DX
 12899 00002D30 803CFF                  	CMP	BYTE [SI],0FFh
 12900 00002D33 750D                    	JNZ	short NORMFCB6
 12901 00002D35 83C606                  	ADD	SI,6
 12902 00002D38 AC                      	LODSB
 12903                                  
 12904 00002D39 36A2[0805]              	MOV	[SS:SATTRIB],AL
 12905 00002D3D 36FE0E[0705]            	DEC	byte [SS:EXTFCB]
 12906                                  NORMFCB6:
 12907 00002D42 AC                      	LODSB				; Get original user drive byte
 12908 00002D43 50                      	push	ax			; Put it on stack
 12909 00002D44 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 12910 00002D47 AA                      	STOSB				; Put in correct place
 12911 00002D48 B90A00                  	MOV	CX,20/2
 12912 00002D4B F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 12913                                  
 12914 00002D4D 16                      	push	ss
 12915 00002D4E 1F                      	pop	ds
 12916                                  
 12917 00002D4F FF36[DA02]              	push	word [DMAADD]
 12918 00002D53 FF36[DC02]              	push	word [DMAADD+2]
 12919 00002D57 C706[DA02][6004]        	MOV	WORD [DMAADD],SEARCHBUF
 12920 00002D5D 8C1E[DC02]              	MOV	WORD [DMAADD+2],DS
 12921 00002D61 E8610C                  	call	DOS_SEARCH_NEXT 	; Find it
 12922 00002D64 8F06[DC02]              	pop	word [DMAADD+2]
 12923 00002D68 8F06[DA02]              	pop	word [DMAADD]
 12924 00002D6C 7203                    	JC	short SearchNoMore
 12925 00002D6E E956FF                  	JMP	SearchSet		; Ok set return
 12926                                  
 12927                                  SearchNoMore:
 12928 00002D71 C43E[3E05]              	LES	DI,[THISFCB]
 12929 00002D75 F606[0705]FF            	TEST	byte [EXTFCB],0FFh
 12930 00002D7A 7403                    	JZ	short NORMFCB8
 12931 00002D7C 83C707                  	ADD	DI,7			; Point past the extension
 12932                                  NORMFCB8:
 12933 00002D7F 5B                      	pop	bx			; Get original drive byte
 12934 00002D80 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 12935                                  					;  at the right spot
 12936                                  ;
 12937                                  ; error code is in AX
 12938                                  ;
 12939 00002D83 E996E9                  	jmp	FCB_RET_ERR
 12940                                  
 12941                                  ;---------------------------------------------------------------------------
 12942                                  ;
 12943                                  ;   Procedure Name : $FIND_FIRST
 12944                                  ; 
 12945                                  ;   Assembler usage:
 12946                                  ;	    MOV AH, FindFirst
 12947                                  ;	    LDS DX, name
 12948                                  ;	    MOV CX, attr
 12949                                  ;	    INT 21h
 12950                                  ;	; DMA address has datablock
 12951                                  ;
 12952                                  ;   Error Returns:
 12953                                  ;	    AX = error_path_not_found
 12954                                  ;	       = error_no_more_files
 12955                                  ;---------------------------------------------------------------------------
 12956                                  
 12957                                  _$FIND_FIRST:
 12958 00002D86 89D6                    	MOV	SI,DX			; get name in appropriate place
 12959 00002D88 36880E[0805]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 12960                                  
 12961 00002D8D BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 12962                                  
 12963 00002D90 E8C03C                  	call	TransPathSet		; convert the path
 12964 00002D93 7305                    	JNC	short Find_it 		; no error, go and look
 12965                                  FindError:
 12966                                  	;mov	al,3
 12967 00002D95 B003                    	mov	al, error_path_not_found ; error and map into one.
 12968 00002D97 E96CE9                  	jmp	SYS_RET_ERR
 12969                                  Find_it:
 12970 00002D9A 16                      	push	ss
 12971 00002D9B 1F                      	pop	ds
 12972                                  
 12973 00002D9C FF36[DA02]              	push	word [DMAADD]
 12974 00002DA0 FF36[DC02]              	push	word [DMAADD+2]
 12975 00002DA4 C706[DA02][6004]        	MOV	WORD [DMAADD],SEARCHBUF
 12976 00002DAA 8C1E[DC02]              	MOV	WORD [DMAADD+2],DS
 12977                                  	; MSDOS 6.0
 12978                                  	;call	GET_FAST_SEARCH 	; search
 12979                                  	; MSDOS 3.3
 12980 00002DAE E85F0B                  	call	DOS_SEARCH_FIRST
 12981 00002DB1 8F06[DC02]              	pop	word [DMAADD+2]
 12982 00002DB5 8F06[DA02]              	pop	word [DMAADD]
 12983 00002DB9 7303                    	JNC	short FindSet 		; no error, transfer info
 12984 00002DBB E948E9                  	jmp	SYS_RET_ERR
 12985                                  
 12986                                  FindSet:
 12987 00002DBE BE[6004]                	MOV	SI,SEARCHBUF
 12988 00002DC1 C43E[DA02]              	LES	DI,[DMAADD]
 12989 00002DC5 B91500                  	MOV	CX,21
 12990 00002DC8 F3A4                    	REP	MOVSB
 12991 00002DCA 56                      	PUSH	SI			; Save pointer to start of entry
 12992                                  	;mov	al,[si+0Bh]
 12993 00002DCB 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 12994 00002DCE AA                      	STOSB
 12995                                  	;add	si,16h
 12996 00002DCF 83C616                  	ADD	SI,dir_entry.dir_time
 12997 00002DD2 A5                      	MOVSW				; dir_time
 12998 00002DD3 A5                      	MOVSW				; dir_date
 12999 00002DD4 46                      	INC	SI
 13000 00002DD5 46                      	INC	SI			; Skip dir_first
 13001 00002DD6 A5                      	MOVSW				; dir_size (2 words)
 13002 00002DD7 A5                      	MOVSW
 13003 00002DD8 5E                      	POP	SI			; Point back to dir_name
 13004 00002DD9 E83600                   	CALL	PackName
 13005 00002DDC E91EE9                  	jmp	SYS_RET_OK		; bye with no errors
 13006                                  
 13007                                  ;---------------------------------------------------------------------------
 13008                                  ;
 13009                                  ;   Procedure Name : $FIND_NEXT
 13010                                  ;
 13011                                  ;   Assembler usage:
 13012                                  ;	; dma points at area returned by find_first
 13013                                  ;	    MOV AH, findnext
 13014                                  ;	    INT 21h
 13015                                  ;	; next entry is at dma
 13016                                  ;
 13017                                  ;   Error Returns:
 13018                                  ;	    AX = error_no_more_files
 13019                                  ;---------------------------------------------------------------------------
 13020                                  
 13021                                  _$FIND_NEXT:
 13022 00002DDF 16                      	push	ss
 13023 00002DE0 07                      	pop	es
 13024                                  
 13025 00002DE1 BF[6004]                	MOV	DI,SEARCHBUF
 13026                                  
 13027 00002DE4 36C536[DA02]            	LDS	SI,[SS:DMAADD]
 13028                                  
 13029 00002DE9 B91500                  	MOV	CX,21
 13030 00002DEC F3A4                    	REP	MOVSB			; Put the search continuation info
 13031                                  					;  in the right place
 13032 00002DEE 16                      	push	ss
 13033 00002DEF 1F                      	pop	ds			; get ready for search
 13034                                  	
 13035 00002DF0 FF36[DA02]              	push	word [DMAADD]
 13036 00002DF4 FF36[DC02]              	push	word [DMAADD+2]
 13037 00002DF8 C706[DA02][6004]        	MOV	WORD [DMAADD],SEARCHBUF
 13038 00002DFE 8C1E[DC02]              	MOV	WORD [DMAADD+2],DS
 13039 00002E02 E8C00B                  	call	DOS_SEARCH_NEXT 	; Find it
 13040 00002E05 8F06[DC02]              	pop	word [DMAADD+2]
 13041 00002E09 8F06[DA02]              	pop	word [DMAADD]
 13042 00002E0D 73AF                    	JNC	short FindSet 		; No error, set info
 13043 00002E0F E9F4E8                  	jmp	SYS_RET_ERR
 13044                                  
 13045                                  ;---------------------------------------------------------------------------
 13046                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 13047                                  ;
 13048                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 13049                                  ;	the ASCIZ format.
 13050                                  ;
 13051                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 13052                                  ;		(ES:DI) = destination area (13 bytes)
 13053                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 13054                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 13055                                  ;---------------------------------------------------------------------------
 13056                                  
 13057                                  PackName:
 13058                                  ;	Move over 8 characters to cover the name component, then trim it's
 13059                                  ;	trailing blanks.
 13060                                  
 13061 00002E12 B90800                  	MOV	CX,8			; Pack the name
 13062 00002E15 F3A4                    	REP	MOVSB			; Move all of it
 13063                                  main_kill_tail:
 13064 00002E17 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 13065 00002E1C 7507                    	JNZ	short find_check_dot
 13066 00002E1E 4F                      	DEC	DI			; Back up over trailing space
 13067 00002E1F 41                      	INC	CX
 13068 00002E20 83F908                  	CMP	CX,8
 13069 00002E23 72F2                    	JB	short main_kill_tail
 13070                                  find_check_dot:
 13071                                  	;CMP	WORD [SI],(" " << 8) | " "
 13072 00002E25 813C2020                	cmp     word [si],2020h 
 13073 00002E29 7506                    	JNZ	short got_ext 		; Some chars in extension
 13074 00002E2B 807C0220                	CMP	BYTE [SI+2]," "
 13075 00002E2F 7412                    	JZ	short find_done		; No extension
 13076                                  got_ext:
 13077 00002E31 B02E                    	MOV	AL,"."
 13078 00002E33 AA                      	STOSB
 13079 00002E34 B90300                  	MOV	CX,3
 13080 00002E37 F3A4                    	REP	MOVSB
 13081                                  ext_kill_tail:
 13082 00002E39 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 13083 00002E3E 7503                    	JNZ	short find_done
 13084 00002E40 4F                      	DEC	DI			; Back up over trailing space
 13085 00002E41 EBF6                    	JMP	short ext_kill_tail
 13086                                  find_done:
 13087 00002E43 31C0                    	XOR	AX,AX
 13088 00002E45 AA                      	STOSB				; NUL terminate
 13089 00002E46 C3                      	retn
 13090                                  
 13091                                  ;GET_FAST_SEARCH:
 13092                                  ;	; 22/07/2018
 13093                                  ;	; MSDOS 6.0
 13094                                  ;	OR	word [DOS34_FLAG],SEARCH_FASTOPEN 
 13095                                  ;					;FO.trigger fastopen ;AN000;
 13096                                  ;	call	DOS_SEARCH_FIRST
 13097                                  ;	retn
 13098                                  
 13099                                  
 13100                                  ;============================================================================
 13101                                  ; PATH.ASM, MSDOS 6.0, 1991
 13102                                  ;============================================================================
 13103                                  ; 06/08/2018 - Retro DOS v3.0
 13104                                  
 13105                                  ;**	Directory related system calls. These will be passed direct text of the
 13106                                  ;	pathname from the user. They will need to be passed through the macro
 13107                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 13108                                  ;	defined in DISPATCH. The system calls are:
 13109                                  ;
 13110                                  ;	$CURRENT_DIR  Written
 13111                                  ;	$RMDIR	  Written
 13112                                  ;	$CHDIR	  Written
 13113                                  ;	$MKDIR	  Written
 13114                                  ;
 13115                                  ;
 13116                                  ;	Modification history:
 13117                                  ;
 13118                                  ;	    Created: ARR 4 April 1983
 13119                                  ;		 MZ 10 May 1983     CurrentDir implemented
 13120                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 13121                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 13122                                  ;				    current directory.
 13123                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 13124                                  
 13125                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 13126                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 13127                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 13128                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 13129                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 13130                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 13131                                  ;	I_Need	cMeta,BYTE
 13132                                  ;	I_Need	DrvErr,BYTE					;AN000;
 13133                                  
 13134                                  
 13135                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 13136                                  ;---------------------------------------------------------------------------
 13137                                  ;
 13138                                  ;   Procedure Name : $CURRENT_DIR
 13139                                  ;
 13140                                  ;   Assembler usage:
 13141                                  ;		LDS	SI,area
 13142                                  ;		MOV	DL,drive
 13143                                  ;		INT	21h
 13144                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 13145                                  ;	    ; current directory.
 13146                                  ;   Error returns:
 13147                                  ;	    AX = error_invalid_drive
 13148                                  ;
 13149                                  ;---------------------------------------------------------------------------
 13150                                  
 13151                                  _$CURRENT_DIR:
 13152                                  	;06/08/2018 - Retro DOS v3.0
 13153                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 13154 00002E47 E819F2                  	call	EcritDisk
 13155 00002E4A 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 13156 00002E4C E80E3B                  	call	GetVisDrv		; grab it
 13157 00002E4F 7308                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 13158                                  CurdirErr:
 13159 00002E51 E817F2                  	call	LcritDisk
 13160                                  	
 13161                                  	; MSDOS 6.0
 13162                                  	;MOV	AL,[CS:DrvErr]		;IFS.			;AN000;
 13163                                  
 13164                                  	; MSDOS 3.3
 13165 00002E54 B00F                    	mov	al,0Fh
 13166                                  
 13167                                  curdir_errj:
 13168 00002E56 E9ADE8                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 13169                                  
 13170                                  CurrentValidate:
 13171 00002E59 1E                      	push	ds		; save destination
 13172 00002E5A 56                      	push	si
 13173 00002E5B 2EC536[3A05]            	LDS	SI,[CS:THISCDS]
 13174                                  	;TEST	word [SI+curdir.flags],curdir_isnet
 13175                                  	;JNZ	short DoCheck
 13176                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 13177                                  ; media check.
 13178                                  ;	CMP	word [SI+curdir.ID],0
 13179                                  ;	JZ	short GetDst
 13180                                  DoCheck:
 13181 00002E60 2EC606[F802]00          	MOV	byte [cs:NoSetDir],0	; interested only in contents
 13182                                  
 13183 00002E66 BF[6003]                	MOV	DI,OPENBUF
 13184                                  
 13185 00002E69 E8011D                  	call	ValidateCDS		; output is ES:DI -> CDS
 13186 00002E6C 06                      	push	es	 		; swap source and destination
 13187 00002E6D 57                      	push	di
 13188 00002E6E 5E                      	pop	si
 13189 00002E6F 1F                      	pop	ds
 13190                                  GetDst:
 13191 00002E70 5F                      	pop	di
 13192 00002E71 07                      	pop	es			; get real destination
 13193 00002E72 72DD                    	JC	short CurdirErr
 13194                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 13195 00002E74 03744F                  	ADD	SI,[SI+curdir.end]
 13196 00002E77 803C5C                  	CMP	BYTE [SI],'\'		; root or subdirs present?
 13197 00002E7A 7501                    	JNZ	short CurrentCopy
 13198 00002E7C 46                      	INC	SI
 13199                                  CurrentCopy:
 13200                                  ;	call	FStrCpy
 13201                                  ;; 10/29/86 E5 char
 13202 00002E7D 50                      	PUSH	AX
 13203 00002E7E AC                      	LODSB				; get char
 13204 00002E7F 08C0                    	OR	AL,AL
 13205 00002E81 7413                    	JZ	short FOK
 13206 00002E83 3C05                    	CMP	AL,05
 13207 00002E85 740D                    	JZ	short FCHANGE
 13208 00002E87 EB01                    	JMP	short FFF
 13209                                  FCPYNEXT:
 13210 00002E89 AC                      	LODSB				; get char
 13211                                  FFF:
 13212 00002E8A 3C5C                    	CMP	AL,'\'			; beginning of directory
 13213 00002E8C 7508                    	JNZ	short FOK		; no
 13214 00002E8E AA                      	STOSB				; put into user's buffer
 13215 00002E8F AC                      	LODSB				; 1st char of dir is 05?
 13216 00002E90 3C05                    	CMP	AL,05H
 13217 00002E92 7502                    	JNZ	short FOK		; no
 13218                                  FCHANGE:
 13219 00002E94 B0E5                    	MOV	AL,0E5H			; make it E5
 13220                                  FOK:
 13221 00002E96 AA                      	STOSB				; put into user's buffer
 13222 00002E97 08C0                    	OR	AL,AL			; final char
 13223 00002E99 75EE                    	JNZ	short FCPYNEXT		; no
 13224 00002E9B 58                      	POP	AX
 13225                                  
 13226                                  ;; 10/29/86 E5 char
 13227 00002E9C 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 13228 00002E9E E8CAF1                  	call	LcritDisk
 13229 00002EA1 E959E8                  	jmp	SYS_RET_OK		; no more, bye!
 13230                                  
 13231                                  
 13232                                  ;BREAK <$RmDir -- Remove a directory>
 13233                                  ;---------------------------------------------------------------------------
 13234                                  ;
 13235                                  ; Procedure Name : $RmDir
 13236                                  ;
 13237                                  ; Inputs:
 13238                                  ;	DS:DX Points to asciz name
 13239                                  ; Function:
 13240                                  ;	Delete directory if empty
 13241                                  ; Returns:
 13242                                  ;	STD XENIX Return
 13243                                  ;	AX = error_path_not_found If path bad
 13244                                  ;	AX = error_access_denied If
 13245                                  ;		Directory not empty
 13246                                  ;		Path not directory
 13247                                  ;		Root directory specified
 13248                                  ;		Directory malformed (. and .. not first two entries)
 13249                                  ;		User tries to delete a current directory
 13250                                  ;	AX = error_current_directory
 13251                                  ;
 13252                                  ;----------------------------------------------------------------------------
 13253                                  
 13254                                  _$RMDIR:
 13255 00002EA4 52                      	push	dx			; Save ptr to name
 13256 00002EA5 1E                      	push	ds
 13257 00002EA6 89D6                    	mov	si,dx			; Load ptr into si
 13258 00002EA8 BF[6003]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 13259 00002EAB 57                      	push	di
 13260 00002EAC E8AC3B                  	call	TransPathNoSet		; Translate the name
 13261 00002EAF 5F                      	pop	di			; di = ptr to buf for trans name
 13262 00002EB0 7307                    	jnc	short rmlset		; If transpath succeeded, continue
 13263 00002EB2 1F                      	pop	ds
 13264 00002EB3 5A                      	pop	dx			; Restore the	 name
 13265 00002EB4 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 13266                                  	;jmp	short curdir_errj
 13267                                  rmdir_errj: ; 10/08/2018
 13268 00002EB6 E94DE8                  	jmp	SYS_RET_ERR
 13269                                  rmlset:
 13270 00002EB9 36803E[1505]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 13271 00002EBF 7512                    	Jnz	short rmerr		;	return (-1);
 13272 00002EC1 16                      	push	ss
 13273 00002EC2 07                      	pop	es
 13274 00002EC3 30C0                    	xor	al,al			; al = 0 , ie drive a:
 13275                                  rmloop: 
 13276 00002EC5 E8FF3A                  	call	GetCDSFromDrv		; Get curdir for drive in al
 13277 00002EC8 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 13278 00002ECA E85EF0                  	call	StrCmp			; Are the 2 paths the same?
 13279 00002ECD 7404                    	jz	short rmerr		; Yes, report error.
 13280 00002ECF FEC0                    	inc	al			; No, inc al to next drive number
 13281 00002ED1 EBF2                    	jmp	short rmloop		; Go check next drive.
 13282                                  rmerr:
 13283 00002ED3 1F                      	pop	ds
 13284 00002ED4 5A                      	pop	dx			; Restore the name
 13285 00002ED5 B010                    	mov	al,error_current_directory ;  error
 13286                                  	;jmp	short curdir_errj
 13287 00002ED7 EBDD                    	jmp	short rmdir_errj
 13288                                  rmcont:
 13289 00002ED9 1F                      	pop	ds
 13290 00002EDA 5A                      	pop	dx			; Restore the name
 13291 00002EDB BE[1B3D]                	MOV	SI,DOS_RMDIR
 13292 00002EDE EB75                    	JMP	short DoDirCall ; 07/09/2018
 13293                                  
 13294                                  ;BREAK <$ChDir -- Change current directory on a drive>
 13295                                  ;----------------------------------------------------------------------------
 13296                                  ;
 13297                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 13298                                  ; for setting up the CDS for the specified drive appropriately.  There are
 13299                                  ; several cases to consider:
 13300                                  ;
 13301                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 13302                                  ;	it into a WFP.	We verify the existance of this directory and then
 13303                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 13304                                  ;	directory cluster.
 13305                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 13306                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 13307                                  ;	WFP back into the CDS.
 13308                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 13309                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 13310                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 13311                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 13312                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 13313                                  ;	to process the path but to return the logical CDS and the logical
 13314                                  ;	path.  We then copy the logical path into the logical CDS.
 13315                                  ;
 13316                                  ; Inputs:
 13317                                  ;	DS:DX Points to asciz name
 13318                                  ; Returns:
 13319                                  ;	STD XENIX Return
 13320                                  ;	AX = chdir_path_not_found if error
 13321                                  ;
 13322                                  ;----------------------------------------------------------------------------
 13323                                  
 13324                                  _$CHDIR:
 13325 00002EE0 BF[6003]                	MOV	DI,OPENBUF		; spot for translated name
 13326 00002EE3 89D6                    	MOV	SI,DX			; get source
 13327 00002EE5 E8673B                  	call	TransPath		; go munge the path and get real CDS
 13328 00002EE8 7305                    	JNC	short ChDirCrack	; no errors, try path
 13329                                  ChDirErrP:
 13330 00002EEA B003                    	MOV	AL,error_path_not_found
 13331                                  ChDirErr:
 13332 00002EEC E917E8                  	jmp	SYS_RET_ERR 	; oops!
 13333                                  
 13334                                  ChDirCrack:
 13335 00002EEF 803E[1505]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 13336 00002EF4 75F4                    	JNZ	short ChDirErrP
 13337                                  ;
 13338                                  ; We cannot do a ChDir (yet) on a raw CDS.  This is treated as a path not
 13339                                  ; found.
 13340                                  ;
 13341 00002EF6 C43E[3A05]              	LES	DI,[THISCDS]
 13342 00002EFA 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 13343 00002EFD 74EB                    	JZ	short ChDirErrP		;	error ();
 13344                                   ;
 13345                                   ; Find out if the directory exists.
 13346                                   ;
 13347 00002EFF E8E40D                  	call	DOS_CHDIR
 13348 00002F02 72E8                    	Jc	short ChDirErr
 13349                                  ;
 13350                                  ; Get back CDS to see if a join as seen.  Set the currency pointer (only if
 13351                                  ; not network).  If one was seen, all we need to do is copy in the text
 13352                                  ;
 13353 00002F04 C43E[3A05]              	LES	DI,[THISCDS]
 13354 00002F08 26F745430020            	TEST	word [ES:DI+curdir.flags],curdir_splice
 13355 00002F0E 7425                    	JZ	short GotCDS
 13356                                  ;
 13357                                  ; The CDS was joined.  Let's go back and grab the logical CDS.
 13358                                  ;
 13359 00002F10 06                      	push	es	
 13360 00002F11 57                      	push	di
 13361 00002F12 51                      	push	cx			; save CDS and cluster...
 13362 00002F13 E8F5E6                  	call	Get_User_Stack		; get original text
 13363 00002F16 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 13364 00002F19 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 13365 00002F1C BE[6003]                	MOV	SI,OPENBUF		; spot for translated name
 13366 00002F1F 87F7                    	XCHG	SI,DI
 13367 00002F21 30C0                    	XOR	AL,AL			; do no splicing
 13368 00002F23 57                      	push	di
 13369 00002F24 E8343B                  	call	TransPathNoSet		; Munge path
 13370 00002F27 5E                      	pop	si
 13371                                  ;
 13372                                  ; There should NEVER be an error here.
 13373                                  ;
 13374                                  
 13375                                  ;IF FALSE
 13376                                  ;	JNC SKipErr
 13377                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 13378                                  ;SkipErr:
 13379                                  ;ENDIF
 13380 00002F28 C43E[3A05]              	LES	DI,[THISCDS]		; get new CDS
 13381 00002F2C 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 13382                                  					; no valid cluster here...
 13383 00002F32 59                      	pop	cx
 13384 00002F33 5F                      	pop	di
 13385 00002F34 07                      	pop	es
 13386                                  ;
 13387                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 13388                                  ;
 13389                                  GotCDS:
 13390                                  ;
 13391                                  ; wfp_start points to the text. See if it is long enough
 13392                                  ;
 13393                                  	; MSDOS 3.3
 13394                                  	;push	ss
 13395                                  	;pop	ds
 13396                                  	;mov	si,[WFP_START]
 13397                                  	;push	cx
 13398                                  	;call	DStrLen
 13399                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 13400                                  	;pop	cx
 13401                                  	;ja	short ChDirErrP
 13402                                  
 13403                                  	; MSDOS 6.0
 13404 00002F35 E84800                  	CALL	Check_PathLen		;PTM.		;AN000;
 13405 00002F38 77B0                    	JA	short ChDirErrP
 13406                                  	; MSDOS 3.3 (& MSDOS 6.0)
 13407 00002F3A 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 13408 00002F40 7508                    	JNZ	short SkipRecency
 13409                                  	; MSDOS 6.0
 13410                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 13411                                  	;				;PTM. for Join and Subst ;AN000;
 13412                                  	;JZ	short setdirclus	;PTM.		;AN000;
 13413                                  	;MOV	CX,-1			;PTM.		;AN000;
 13414                                  ;setdirclus:
 13415 00002F42 26894D49                	MOV	[ES:DI+curdir.ID],CX
 13416 00002F46 C43E[3A05]              	LES	DI,[THISCDS]		; get logical CDS
 13417                                  SkipRecency:
 13418 00002F4A E80BF0                  	call	FStrCpy
 13419 00002F4D 30C0                    	XOR	AL,AL
 13420                                  mkdir_ok:
 13421 00002F4F E9ABE7                  	jmp	SYS_RET_OK
 13422                                  
 13423                                  
 13424                                  ;BREAK <$MkDir - Make a directory entry>
 13425                                  ;---------------------------------------------------------------------------
 13426                                  ;
 13427                                  ; Procedure Name : $MkDir
 13428                                  ; Inputs:
 13429                                  ;	DS:DX Points to asciz name
 13430                                  ; Function:
 13431                                  ;	Make a new directory
 13432                                  ; Returns:
 13433                                  ;	STD XENIX Return
 13434                                  ;	AX = mkdir_path_not_found if path bad
 13435                                  ;	AX = mkdir_access_denied  If
 13436                                  ;		Directory cannot be created
 13437                                  ;		Node already exists
 13438                                  ;		Device name given
 13439                                  ;		Disk or directory(root) full
 13440                                  ;---------------------------------------------------------------------------
 13441                                  
 13442                                  _$MKDIR:
 13443 00002F52 BE[043C]                	MOV	SI,DOS_MKDIR
 13444                                  DoDirCall:
 13445 00002F55 BF[6003]                	MOV	DI,OPENBUF		; spot for translated name
 13446                                  
 13447 00002F58 56                      	push	si
 13448 00002F59 89D6                    	MOV	SI,DX			; get source
 13449 00002F5B E8F13A                  	call	TransPath		; go munge the path
 13450 00002F5E 5E                      	pop	si
 13451 00002F5F 7305                    	JNC	short MkDirCrack	; no errors, try path
 13452                                  MkErrP:
 13453 00002F61 B003                    	MOV	AL,error_path_not_found	; oops!
 13454                                  MkErr:
 13455 00002F63 E9A0E7                  	jmp	SYS_RET_ERR
 13456                                  MkDirCrack:
 13457 00002F66 36803E[1505]FF          	CMP	byte [SS:CMETA],-1
 13458 00002F6C 75F3                    	JNZ	short MkErrP
 13459                                  
 13460                                  	; MSDOS 3.3
 13461                                  	;push	ss
 13462                                  	;pop	ds
 13463                                  	;call	si
 13464                                  	;jb	short MkErr
 13465                                  	;;jmp	short mkdir_ok
 13466                                  	;jmp	SYS_RET_OK
 13467                                  
 13468                                  	; MSDOS 6.0
 13469 00002F6E 56                      	PUSH	SI			;PTM.			;AN000;
 13470 00002F6F E80E00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 13471 00002F72 5E                      	POP	SI			;PTM.			;AN000;
 13472 00002F73 7604                    	JBE	short pathok		;PTM.			;AN000;
 13473 00002F75 B005                    	MOV	AL,error_access_denied	;PTM. ops!
 13474                                  	;jmp	SYS_RET_ERR		;PTM.
 13475 00002F77 EBEA                    	jmp	short MkErr
 13476                                  pathok:
 13477 00002F79 FFD6                    	CALL	SI			; go get file
 13478 00002F7B 72E6                    	JC	short MkErr		; no errors
 13479                                  	;jmp	short mkdir_ok
 13480 00002F7D E97DE7                  	jmp	SYS_RET_OK
 13481                                  
 13482                                  ;----------------------------------------------------------------------------
 13483                                  ;
 13484                                  ; Procedure Name : Check_PathLen
 13485                                  ;
 13486                                  ; Inputs:
 13487                                  ;	nothing
 13488                                  ; Function:
 13489                                  ;	check if final path length greater than 67
 13490                                  ; Returns:
 13491                                  ;	Above flag set if > 67
 13492                                  ;
 13493                                  ;---------------------------------------------------------------------------
 13494                                  
 13495                                  Check_PathLen:
 13496                                  	; 09/09/2018
 13497                                  	;;MOV	SI,[WFP_START]
 13498                                  	;MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 13499                                  ;check_PathLen2:
 13500 00002F80 16                      	push	ss
 13501 00002F81 1F                      	pop	ds
 13502 00002F82 8B36[4A05]              	mov	SI,[WFP_START] ; MSDOS 3.3
 13503 00002F86 51                      	push	CX	
 13504 00002F87 E8E5EF                  	CALL	DStrLen
 13505 00002F8A 83F943                  	CMP	CX,DIRSTRLEN
 13506 00002F8D 59                      	POP	CX
 13507 00002F8E C3                      	retn
 13508                                  
 13509                                  ;============================================================================
 13510                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 13511                                  ;============================================================================
 13512                                  ; 07/08/2018 - Retro DOS v3.0
 13513                                  
 13514                                  ;**	IOCTL system call.
 13515                                  ;
 13516                                  ;	$IOCTL
 13517                                  ;
 13518                                  ;	  Revision history:
 13519                                  ;
 13520                                  ;		Created: ARR 4 April 1983
 13521                                  ;
 13522                                  ;		GenericIOCTL added:		KGS	22 April 1985
 13523                                  ;
 13524                                  ;		A000	version 4.00	Jan. 1988
 13525                                  ;
 13526                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 13527                                  ;
 13528                                  
 13529                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 13530                                  ;---------------------------------------------------------------------------
 13531                                  ;
 13532                                  ;   Assembler usage:
 13533                                  ;	    MOV     BX, Handle
 13534                                  ;	    MOV     DX, Data
 13535                                  ;
 13536                                  ;	(or LDS     DX,BUF
 13537                                  ;	    MOV     CX,COUNT)
 13538                                  ;
 13539                                  ;	    MOV     AH, Ioctl
 13540                                  ;	    MOV     AL, Request
 13541                                  ;	    INT     21h
 13542                                  ;
 13543                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 13544                                  ;	    attribute word in DX, handle in BX:
 13545                                  ;	    DH = high word of device driver attributes
 13546                                  ;	    DL = low byte of sf_flags
 13547                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 13548                                  ;	    in BX.
 13549                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 13550                                  ;	    into DS:DX.  Return number read in AX.
 13551                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 13552                                  ;	    DS:DX.  Return bytes written in AX.
 13553                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 13554                                  ;	    into DS:DX.  Return number read in AX.
 13555                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 13556                                  ;	    DS:DX.  Return bytes written in AX.
 13557                                  ;	 6  Return input status of handle in BX. If a read will go to the
 13558                                  ;	    device, AL = 0FFh, otherwise 0.
 13559                                  ;	 7  Return output status of handle in BX. If a write will go to the
 13560                                  ;	    device, AL = 0FFh, otherwise 0.
 13561                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 13562                                  ;	    removable media, 0 otherwise.
 13563                                  ;	 9  Return the contents of the device attribute word in DX for the
 13564                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 13565                                  ;	    network. 8000h is the bit for local use.
 13566                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 13567                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 13568                                  ;	    the count and CX is the delay.
 13569                                  ;
 13570                                  ;   Error returns:
 13571                                  ;	    AX = error_invalid_handle
 13572                                  ;	       = error_invalid_function
 13573                                  ;	       = error_invalid_data
 13574                                  ;
 13575                                  ;-------------------------------------------------------------------------------
 13576                                  ;
 13577                                  ;   This is the documentation copied from DOS 4.0 it is much better
 13578                                  ;   than the above
 13579                                  ;
 13580                                  ;	There are several basic forms of IOCTL calls:
 13581                                  ;
 13582                                  ;
 13583                                  ;	** Get/Set device information:	**
 13584                                  ;
 13585                                  ;	ENTRY	(AL) = function code
 13586                                  ;		  0 - Get device information
 13587                                  ;		  1 - Set device information
 13588                                  ;		(BX) = file handle
 13589                                  ;		(DX) = info for "Set Device Information"
 13590                                  ;	EXIT	'C' set if error
 13591                                  ;		  (AX) = error code
 13592                                  ;		'C' clear if OK
 13593                                  ;		  (DX) = info for "Get Device Information"
 13594                                  ;	USES	ALL
 13595                                  ;
 13596                                  ;
 13597                                  ;	**  Read/Write Control Data From/To Handle  **
 13598                                  ;
 13599                                  ;	ENTRY	(AL) = function code
 13600                                  ;		  2 - Read device control info
 13601                                  ;		  3 - Write device control info
 13602                                  ;		(BX) = file handle
 13603                                  ;		(CX) = transfer count
 13604                                  ;		(DS:DX) = address for data
 13605                                  ;	EXIT	'C' set if error
 13606                                  ;		  (AX) = error code
 13607                                  ;		'C' clear if OK
 13608                                  ;		  (AX) = count of bytes transfered
 13609                                  ;	USES	ALL
 13610                                  ;
 13611                                  ;
 13612                                  ;	**  Read/Write Control Data From/To Block Device  **
 13613                                  ;
 13614                                  ;	ENTRY	(AL) = function code
 13615                                  ;		  4 - Read device control info
 13616                                  ;		  5 - Write device control info
 13617                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 13618                                  ;		(CX) = transfer count
 13619                                  ;		(DS:DX) = address for data
 13620                                  ;	EXIT	'C' set if error
 13621                                  ;		  (AX) = error code
 13622                                  ;		'C' clear if OK
 13623                                  ;		  (AX) = count of bytes transfered
 13624                                  ;	USES	ALL
 13625                                  ;
 13626                                  ;
 13627                                  ;	**  Get Input/Output Status  **
 13628                                  ;
 13629                                  ;	ENTRY	(AL) = function code
 13630                                  ;		  6 - Get Input status
 13631                                  ;		  7 - Get Output Status
 13632                                  ;		(BX) = file handle
 13633                                  ;	EXIT	'C' set if error
 13634                                  ;		  (AX) = error code
 13635                                  ;		'C' clear if OK
 13636                                  ;		  (AL) = 00 if not ready
 13637                                  ;		  (AL) = FF if ready
 13638                                  ;	USES	ALL
 13639                                  ;
 13640                                  ;
 13641                                  ;	**  Get Drive Information  **
 13642                                  ;
 13643                                  ;	ENTRY	(AL) = function code
 13644                                  ;		  8 - Check for removable media
 13645                                  ;		  9 - Get device attributes
 13646                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 13647                                  ;	EXIT	'C' set if error
 13648                                  ;		  (AX) = error code
 13649                                  ;		'C' clear if OK
 13650                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 13651                                  ;		  (DX) = device attribute word (func. 9)
 13652                                  ;	USES	ALL
 13653                                  ;
 13654                                  ;
 13655                                  ;	**  Get Redirected bit	**
 13656                                  ;
 13657                                  ;	ENTRY	(AL) = function code
 13658                                  ;		  0Ah - Network stuff
 13659                                  ;		(BX) = file handle
 13660                                  ;	EXIT	'C' set if error
 13661                                  ;		  (AX) = error code
 13662                                  ;		'C' clear if OK
 13663                                  ;		  (DX) = SFT flags word, 8000h set if network file
 13664                                  ;	USES	ALL
 13665                                  ;
 13666                                  ;
 13667                                  ;	**  Change sharer retry parameters  **
 13668                                  ;
 13669                                  ;	ENTRY	(AL) = function code
 13670                                  ;		  0Bh - Set retry parameters
 13671                                  ;		(CX) = retry loop count
 13672                                  ;		(DX) = number of retries
 13673                                  ;	EXIT	'C' set if error
 13674                                  ;		  (AX) = error code
 13675                                  ;		'C' clear if OK
 13676                                  ;	USES	ALL
 13677                                  ;
 13678                                  ;
 13679                                  ;   =================================================================
 13680                                  ;
 13681                                  ;	**  New Standard Control  **
 13682                                  ;
 13683                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 13684                                  ;	FORMS ARE OBSOLETE.
 13685                                  ;
 13686                                  ;   =================================================================
 13687                                  ;
 13688                                  ;	ENTRY	(AL) = function code
 13689                                  ;		  0Ch - Control Function subcode
 13690                                  ;		(BX) = File Handle
 13691                                  ;		(CH) = Category Indicator
 13692                                  ;		(CL) = Function within category
 13693                                  ;		(DS:DX) = address for data, if any
 13694                                  ;		(SI) = Passed to device as argument, use depends upon function
 13695                                  ;		(DI) = Passed to device as argument, use depends upon function
 13696                                  ;	EXIT	'C' set if error
 13697                                  ;		  (AX) = error code
 13698                                  ;		'C' clear if OK
 13699                                  ;		  (SI) = Return value, meaning is function dependent
 13700                                  ;		  (DI) = Return value, meaning is function dependent
 13701                                  ;		  (DS:DX) = Return address, use is function dependent
 13702                                  ;	USES	ALL
 13703                                  ;
 13704                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 13705                                  ;     (See inc\ioctl.inc for more info)
 13706                                  ;
 13707                                  ;	ENTRY	(AL) = function code
 13708                                  ;		  0Dh - Control Function subcode
 13709                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 13710                                  ;		(CH) = Category Indicator
 13711                                  ;		(CL) = Function within category
 13712                                  ;		(DS:DX) = address for data, if any
 13713                                  ;		(SI) = Passed to device as argument, use depends upon function
 13714                                  ;		(DI) = Passed to device as argument, use depends upon function
 13715                                  ;
 13716                                  ;	EXIT	'C' set if error
 13717                                  ;		  (AX) = error code
 13718                                  ;		'C' clear if OK
 13719                                  ;		  (DS:DX) = Return address, use is function dependent
 13720                                  ;	USES	ALL
 13721                                  ;
 13722                                  ;---------------------------------------------------------------------------
 13723                                  	
 13724                                  	; MSDOS 6.0
 13725                                  IOCTLJMPTABLE:	;label	word
 13726                                  	; MSDOS 3.3 (& MSDOS 6.0)
 13727 00002F8F [C72F]                  	dw	ioctl_getset_data	; 0
 13728 00002F91 [C72F]                  	dw	ioctl_getset_data   	; 1
 13729 00002F93 [1730]                  	dw	ioctl_control_string	; 2
 13730 00002F95 [1730]                  	dw	ioctl_control_string	; 3
 13731 00002F97 [6F31]                  	dw	ioctl_get_dev		; 4
 13732 00002F99 [6F31]                  	dw	ioctl_get_dev		; 5
 13733 00002F9B [3230]                  	dw	ioctl_status		; 6
 13734 00002F9D [3230]                  	dw	ioctl_status		; 7
 13735 00002F9F [C830]                  	dw	ioctl_rem_media		; 8
 13736 00002FA1 [0731]                  	dw	Ioctl_Drive_attr	; 9
 13737 00002FA3 [5E31]                  	dw	IOCTL_Handle_Redir	; A
 13738 00002FA5 [5130]                  	dw	Set_Retry_Parameters	; B
 13739 00002FA7 [6030]                  	dw	GENERICIOCTLHANDLE	; C
 13740 00002FA9 [7830]                  	dw	GENERICIOCTL		; D
 13741                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13742 00002FAB [2232]                  	dw	ioctl_drive_owner	; E
 13743 00002FAD [2232]                  	dw	ioctl_drive_owner	; F
 13744                                  	; MSDOS 6.0
 13745                                  	;dw	query_handle_support	; 10h
 13746                                  	;dw	query_device_support	; 11h
 13747                                  
 13748                                  _$IOCTL:
 13749 00002FAF 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 13750 00002FB1 16                      	push	ss
 13751 00002FB2 1F                      	pop	ds			;hkn; SS is DOSDATA
 13752                                  
 13753                                  	; MSDOS 3.3
 13754 00002FB3 3C0F                    	cmp	al,0Fh 
 13755                                  	; MSDOS 6.0
 13756                                  	;cmp	al,11h			; al must be between 0 & 11h
 13757 00002FB5 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 13758                                  
 13759                                  	; 09/09/2018
 13760                                  	;push	AX			; Need to save AL for generic IOCTL
 13761 00002FB7 89C7                    	mov	di,ax			; di NOT a PARM
 13762 00002FB9 81E7FF00                	and	di,0FFh			; di = al
 13763 00002FBD D1E7                    	shl	di,1			; di = index into jmp table
 13764                                  	;pop	AX			; Restore AL for generic IOCTL
 13765                                  
 13766 00002FBF 2EFFA5[8F2F]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 13767                                  
 13768                                  
 13769                                  ioctl_bad_funj2:
 13770 00002FC4 E9F900                  	JMP	ioctl_bad_fun  ; 10/08/2018
 13771                                  
 13772                                  ;--------------------------------------------------------------------------
 13773                                  ;
 13774                                  ; IOCTL: AL= 0,1
 13775                                  ;
 13776                                  ; ENTRY : DS = DOSDATA
 13777                                  ;
 13778                                  ;---------------------------------------------------------------------
 13779                                  
 13780                                  ioctl_getset_data:
 13781                                  	; MSDOS 6.0
 13782 00002FC7 E83538                  	call	SFFromHandle		; ES:DI -> SFT
 13783 00002FCA 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 13784                                  ioctl_bad_handle:
 13785 00002FCC B006                    	mov	al,error_invalid_handle
 13786                                  ioctl_error:
 13787 00002FCE E935E7                  	jmp	SYS_RET_ERR
 13788                                  
 13789                                  ioctl_check_permissions:
 13790 00002FD1 3C00                    	CMP	AL,0
 13791 00002FD3 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 13792 00002FD7 741B                    	JZ	short ioctl_read	; read the byte
 13793                                  
 13794 00002FD9 08F6                    	or	dh, dh
 13795 00002FDB 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 13796 00002FDD B00D                    	mov	al,error_invalid_data	; no DH <> 0
 13797                                  	;jmp	SYS_RET_ERR
 13798 00002FDF EBED                    	jmp	short ioctl_error
 13799                                  
 13800                                  ioctl_check_device:
 13801 00002FE1 A880                    	test	AL,devid_device 	; can I set this handle?
 13802 00002FE3 74DF                    	jz	short ioctl_bad_funj2
 13803 00002FE5 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 13804                                  					;   device bit!! He can muck with the
 13805                                  					;   others at will.
 13806 00002FE8 C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 13807 00002FED 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 13808                                  
 13809                                  ioctl_ok:
 13810 00002FF1 E909E7                  	jmp	SYS_RET_OK
 13811                                  
 13812                                  ioctl_read:
 13813 00002FF4 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 13814 00002FF9 30E4                    	XOR	AH,AH
 13815 00002FFB A880                    	test	AL,devid_device 	; Should I set high byte
 13816 00002FFD 740D                    	JZ	short ioctl_no_high	; no
 13817 00002FFF C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 13818 00003004 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 13819 00003008 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 13820                                  ioctl_no_high:
 13821 0000300C 89C2                    	MOV	DX,AX
 13822 0000300E E8FAE5                  	call	Get_User_Stack
 13823 00003011 895406                  	MOV	[SI+user_env.user_DX],DX
 13824                                  	;;jmp	SYS_RET_OK
 13825                                  	;jmp	short ioctl_ok
 13826                                  	; 26/07/2019
 13827 00003014 E9E9E6                  	jmp	SYS_RET_OK_clc
 13828                                  
 13829                                  ;--------------------------------------------------------------------------
 13830                                  ;
 13831                                  ; IOCTL: 2,3
 13832                                  ;
 13833                                  ; ENTRY : DS = DOSDATA
 13834                                  ;	  SI = user's DS
 13835                                  ;
 13836                                  ;--------------------------------------------------------------------------
 13837                                  
 13838                                  ioctl_control_string:
 13839                                  
 13840 00003017 E8E537                  	call	SFFromHandle		; ES:DI -> SFT
 13841 0000301A 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 13842 0000301C 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 13843 00003022 74A0                    	jz	short ioctl_bad_funj2			; No it is a file
 13844 00003024 C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 13845 00003029 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 13846 0000302D 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 13847 0000302F E94201                  	JMP	ioctl_do_string
 13848                                  
 13849                                  ;--------------------------------------------------------------------------
 13850                                  ;
 13851                                  ; IOCTL: AL = 6,7
 13852                                  ;
 13853                                  ; ENTRY: DS = DOSDATA
 13854                                  ;
 13855                                  ;--------------------------------------------------------------------------
 13856                                  
 13857                                  ioctl_status:
 13858                                  
 13859 00003032 B401                    	MOV	AH,1
 13860 00003034 2C06                    	SUB	AL,6			; 6=0,7=1
 13861 00003036 7402                    	JZ	short ioctl_get_status
 13862 00003038 B403                    	MOV	AH,3
 13863                                  ioctl_get_status:
 13864 0000303A 50                      	PUSH	AX
 13865 0000303B E87810                  	call	GET_IO_SFT
 13866 0000303E 58                      	POP	AX
 13867 0000303F 7302                    	JNC	short DO_IOFUNC
 13868 00003041 EB89                    	JMP	short ioctl_bad_handle	; invalid SFT
 13869                                  
 13870                                  DO_IOFUNC:
 13871 00003043 E80A1D                  	call	IOFUNC
 13872 00003046 88C4                    	MOV	AH,AL
 13873 00003048 B0FF                    	MOV	AL,0FFH
 13874 0000304A 7502                    	JNZ	short ioctl_status_ret
 13875 0000304C FEC0                    	INC	AL
 13876                                  ioctl_status_ret:
 13877 0000304E E9ACE6                  	jmp	SYS_RET_OK
 13878                                  
 13879                                  ;------------------------------------------------------------------------
 13880                                  ;
 13881                                  ; IOCTL: AL = B
 13882                                  ;
 13883                                  ; ENTRY: DS = DOSDATA
 13884                                  ;
 13885                                  ;-------------------------------------------------------------------------
 13886                                  
 13887                                  Set_Retry_Parameters:
 13888                                  	; 09/09/2018
 13889 00003051 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 13890 00003055 09D2                    	OR	DX,DX			; zero retries not allowed
 13891 00003057 7467                    	JZ	short ioctl_bad_fun
 13892 00003059 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 13893                                  doneok:
 13894 0000305D E99DE6                  	jmp	SYS_RET_OK		; Done
 13895                                  
 13896                                  ;--------------------------------------------------------------------------
 13897                                  ;
 13898                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 13899                                  ;
 13900                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 13901                                  ;	SI:DX -> Users Device Parameter Table
 13902                                  ;	IOCALL -> IOCTL_Req structure
 13903                                  ;
 13904                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 13905                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 13906                                  ;	call.
 13907                                  ;
 13908                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 13909                                  ;         the call to Check_If_Net because Check_If_Net gets our
 13910                                  ;         return address off the stack if the drive is invalid.
 13911                                  ;
 13912                                  ;----------------------------------------------------------------------------
 13913                                  
 13914                                  query_handle_support:	; Entry point for handles
 13915                                  GENERICIOCTLHANDLE:
 13916                                  
 13917 00003060 E89C37                  	call	SFFromHandle		; Get SFT for device.
 13918 00003063 7260                    	jc	short ioctl_bad_handlej
 13919                                  
 13920 00003065 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 13921 0000306B 7553                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 13922                                  
 13923 0000306D C606[D102]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev
 13924 00003072 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 13925 00003076 EB0F                    	jmp	short Do_GenIOCTL
 13926                                  
 13927                                  query_device_support:	; Entry point for devices:
 13928                                  GENERICIOCTL:
 13929                                  
 13930 00003078 C606[D102]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk
 13931 0000307D 80FD08                  	cmp	ch,IOC_DC		; Only disk devices are allowed to use
 13932 00003080 753E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 13933                                  
 13934 00003082 E88001                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 13935 00003085 7539                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 13936                                  
 13937                                  Do_GenIOCTL:
 13938                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 ; Can device handle Generic IOCTL funcs
 13939                                  	; 09/09/2018
 13940 00003087 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 13941 0000308C 7432                    	jz	short ioctl_bad_fun
 13942                                  
 13943                                  	; MSDOS 6.0
 13944                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ;Assume real Request
 13945                                  	;cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 13946                                  	;jl	short SetIOCtlBlock
 13947                                  	;
 13948                                  	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 13949                                  	;jz	short ioctl_bad_fun	; No support for query 
 13950                                  	;
 13951                                  	;mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 13952                                  
 13953                                  ;SetIOCtlBlock:
 13954 0000308E 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 13955 0000308F 57                      	PUSH	DI			; in DS:SI
 13956                                  					; Setup Generic IOCTL Request Block
 13957 00003090 C606[2403]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
 13958                                  	; 07/09/2018 (MSDOS 3.3)
 13959                                  	;mov	byte [IOCALL_REQFUNC],19
 13960 00003095 C606[2603]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 13961                                  	;
 13962 0000309A 881E[2503]              	MOV	byte [IOCALL_REQUNIT],BL
 13963 0000309E 882E[3103]              	MOV	byte [IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 13964 000030A2 880E[3203]              	MOV	byte [IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 13965 000030A6 8936[3303]              	MOV	word [IOCALL+IOCTL_REQ.REG_SI],SI
 13966 000030AA 893E[3503]              	MOV	word [IOCALL+IOCTL_REQ.REG_DI],DI
 13967 000030AE 8916[3703]              	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 13968 000030B2 8936[3903]              	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 13969                                  
 13970                                  ;hkn; IOCALL is in DOSDATA
 13971 000030B6 BB[2403]                	MOV	BX,IOCALL
 13972                                  
 13973 000030B9 16                      	PUSH	SS
 13974 000030BA 07                      	POP	ES
 13975                                  					; DS:SI -> Device header.
 13976 000030BB 5E                      	POP	SI
 13977 000030BC 1F                      	POP	DS
 13978                                  	; 10/08/2018
 13979 000030BD E9EE00                  	jmp	ioctl_do_IO		; Perform Call to device driver
 13980                                  
 13981                                  ioctl_bad_fun:
 13982 000030C0 B001                    	mov	al, error_invalid_function
 13983 000030C2 E941E6                  	jmp	SYS_RET_ERR	
 13984                                  
 13985                                  ioctl_bad_handlej:
 13986 000030C5 E904FF                  	jmp	ioctl_bad_handle
 13987                                  
 13988                                  ;---------------------------------------------------------------------------
 13989                                  ;
 13990                                  ; IOCTL AL = 8
 13991                                  ;
 13992                                  ; ENTRY:  DS = DOSDATA
 13993                                  ;
 13994                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 13995                                  ;         the call to Check_If_Net because Check_If_Net gets our
 13996                                  ;         return address off the stack if the drive is invalid.
 13997                                  ;
 13998                                  ;-------------------------------------------------------------------------
 13999                                  
 14000                                  ioctl_rem_media:
 14001                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14002 000030C8 E83A01                  	CALL	Check_If_Net
 14003 000030CB 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 14004                                  					;   certainly don't know how to do this
 14005                                  					;   call.
 14006 000030CD 26F745040008            	TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 14007 000030D3 74EB                    	JZ	short ioctl_bad_fun		; NO
 14008                                  
 14009                                  ;hkn; SS override for IOCALL
 14010 000030D5 36C606[2603]0F          	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD
 14011 000030DB B00D                    	MOV	AL,REMHL
 14012 000030DD 88DC                    	MOV	AH,BL			; Unit number
 14013 000030DF 36A3[2403]              	MOV	[SS:IOCALL_REQLEN],AX
 14014 000030E3 31C0                    	XOR	AX,AX
 14015 000030E5 36A3[2703]              	MOV	[SS:IOCALL_REQSTAT],AX
 14016 000030E9 06                      	PUSH	ES
 14017 000030EA 1F                      	POP	DS
 14018 000030EB 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14019 000030ED 16                      	PUSH	SS
 14020 000030EE 07                      	POP	ES
 14021                                  
 14022                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 14023 000030EF BB[2403]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14024 000030F2 1E                      	push	ds
 14025 000030F3 56                      	push	si
 14026 000030F4 E8061E                  	call	DEVIOCALL2
 14027 000030F7 5E                      	pop	si
 14028 000030F8 1F                      	pop	ds
 14029                                  
 14030                                  ;hkn; SS override
 14031 000030F9 36A1[2703]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 14032 000030FD 250002                  	AND	AX,STBUI		; Mask to busy bit
 14033 00003100 B109                    	MOV	CL,9
 14034 00003102 D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 14035 00003104 E9F6E5                  	jmp	SYS_RET_OK
 14036                                  
 14037                                  ;-------------------------------------------------------------------------
 14038                                  ;
 14039                                  ; IOCTL: AL = 9
 14040                                  ;
 14041                                  ; ENTRY: DS = DOSDATA
 14042                                  ;
 14043                                  ;-------------------------------------------------------------------------
 14044                                  
 14045                                  Ioctl_Drive_attr:
 14046                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14047 00003107 88D8                    	mov	al, bl
 14048 00003109 E86838                  	call	GETTHISDRV
 14049 0000310C 724B                    	jc	short ioctl_drv_err
 14050 0000310E E8C500                  	call	Get_Driver_BL
 14051                                  	; MSDOS 6.0
 14052 00003111 7246                    	JC	short ioctl_drv_err	; drive not valid
 14053                                  
 14054 00003113 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 14055                                  					; get device attribute word
 14056 00003117 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 14057                                  
 14058                                  ;hkn; SS override
 14059 00003119 36C43E[3A05]            	LES	DI,[SS:THISCDS]
 14060 0000311E 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 14061 00003124 7403                    	JZ	short IOCTLShare
 14062                                  
 14063                                  	;or	dx,1000h ; msdos 3.3
 14064                                  
 14065                                  ;	Net devices don't return a device attribute word.
 14066                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 14067                                  
 14068 00003126 BA0010                  	MOV	DX,1000h ;  MSDOS 6.0
 14069                                  IOCTLShare:
 14070 00003129 16                      	push	ss
 14071 0000312A 1F                      	pop	ds
 14072 0000312B BE[6003]                	MOV	SI,OPENBUF
 14073 0000312E 80C341                  	ADD	BL,"A"
 14074 00003131 881C                    	MOV	[SI],BL
 14075 00003133 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 14076 00003138 B80003                  	MOV	AX,0300h
 14077 0000313B F8                      	CLC
 14078                                  	;INT	int_IBM
 14079 0000313C CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 14080                                  			; DS:SI -> ASCIZ disk device name (may be full path or only drive
 14081                                  			; specifier--must include the colon)
 14082                                  			; Return: CF clear if absolute disk access allowed
 14083 0000313E 7304                    	JNC	short IOCTLLocal	; Not shared
 14084 00003140 81CA0002                	OR	DX,0200H		; Shared, bit 9
 14085                                  IOCTLLocal:
 14086 00003144 26F745430010            	TEST	word [ES:DI+curdir.flags],curdir_local
 14087 0000314A 7404                    	JZ	short ioctl_set_DX
 14088 0000314C 81CA0080                	OR	DX,8000h
 14089                                  ioctl_set_DX:
 14090 00003150 E8B8E4                  	call	Get_User_Stack
 14091 00003153 895406                  	MOV	[SI+user_env.user_DX],DX
 14092                                  	;jmp	SYS_RET_OK
 14093                                  	; 26/07/2019
 14094 00003156 E9A7E5                  	jmp	SYS_RET_OK_clc
 14095                                  
 14096                                  ioctl_drv_err:
 14097 00003159 B00F                    	mov	al, error_invalid_drive
 14098 0000315B E9A8E5                  	jmp	SYS_RET_ERR
 14099                                  
 14100                                  ;--------------------------------------------------------------------------
 14101                                  ; IOCTL: AL = A
 14102                                  ;
 14103                                  ; ENTRY: DS = DOSDATA
 14104                                  ;
 14105                                  ;--------------------------------------------------------------------------
 14106                                  
 14107                                  IOCTL_Handle_Redir:
 14108 0000315E E89E36                  	call	SFFromHandle		; ES:DI -> SFT
 14109 00003161 7303                    	JNC	short ioctl_got_sft	; have valid handle
 14110 00003163 E966FE                  	jmp	ioctl_bad_handle ; 10/08/2018
 14111                                  
 14112                                  ioctl_got_sft:
 14113 00003166 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 14114 0000316A EBE4                    	JMP	short ioctl_set_DX	; pass dx to user and return
 14115                                  
 14116                                  ioctl_bad_funj:
 14117 0000316C E951FF                  	JMP	ioctl_bad_fun
 14118                                  
 14119                                  ;--------------------------------------------------------------------------
 14120                                  ;
 14121                                  ; IOCTL: AL= 4,5
 14122                                  ;
 14123                                  ; ENTRY: DS = DOSDATA
 14124                                  ;	 SI = user's DS
 14125                                  ;
 14126                                  ;
 14127                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 14128                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14129                                  ;         return address off the stack if the drive is invalid.
 14130                                  ;
 14131                                  ;-------------------------------------------------------------------------
 14132                                  
 14133                                  ioctl_get_dev:
 14134 0000316F E89300                  	CALL	Check_If_Net
 14135 00003172 75F8                    	JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 14136                                  					;   certainly don't know how to do this
 14137                                  					;   call.
 14138                                  ioctl_do_string:
 14139 00003174 26F745040040            	TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 14140 0000317A 74F0                    	JZ	short ioctl_bad_funj		; NO
 14141                                  					; assume IOCTL read
 14142 0000317C C606[2603]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL
 14143                                  
 14144 00003181 A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 14145 00003183 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 14146                                  
 14147                                  					; it is an IOCTL write
 14148 00003185 C606[2603]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL
 14149                                  
 14150                                  ioctl_control_call:
 14151 0000318A B016                    	MOV	AL,DRDWRHL
 14152                                  ioctl_setup_pkt:
 14153 0000318C 88DC                    	MOV	AH,BL			; Unit number
 14154 0000318E A3[2403]                	MOV	[IOCALL_REQLEN],AX
 14155 00003191 31C0                    	XOR	AX,AX
 14156 00003193 A3[2703]                	MOV	[IOCALL_REQSTAT],AX
 14157 00003196 A2[3103]                	MOV	[IOMED],AL
 14158 00003199 890E[3603]              	MOV	[IOSCNT],CX
 14159 0000319D 8916[3203]              	MOV	[IOXAD],DX
 14160 000031A1 8936[3403]              	MOV	[IOXAD+2],SI
 14161 000031A5 06                      	PUSH	ES
 14162 000031A6 1F                      	POP	DS
 14163 000031A7 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14164 000031A9 16                      	PUSH	SS
 14165 000031AA 07                      	POP	ES
 14166                                  
 14167 000031AB BB[2403]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14168                                  ioctl_do_IO:
 14169 000031AE E84C1D                  	call	DEVIOCALL2
 14170                                  
 14171                                  ;hkn; SS override for IOCALL
 14172 000031B1 36F706[2703]0080        	TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 14173 000031B8 7507                    	JNZ	short ioctl_string_err
 14174                                  
 14175                                  ;hkn; SS override
 14176 000031BA 36A1[3603]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 14177 000031BE E93CE5                  	jmp	SYS_RET_OK
 14178                                  
 14179                                  ioctl_string_err:
 14180 000031C1 368B3E[2703]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 14181                                  device_err:
 14182 000031C6 81E7FF00                	AND	DI,STECODE		; mask out irrelevant bits
 14183 000031CA 89F8                    	MOV	AX,DI
 14184 000031CC E84828                  	call	SET_I24_EXTENDED_ERROR
 14185                                  
 14186                                  ;hkn; use SS override
 14187                                  ;hkn;	mov	ax,[CS:EXTERR]
 14188 000031CF 36A1[D202]              	mov	ax,[SS:EXTERR]
 14189 000031D3 E930E5                  	jmp	SYS_RET_ERR
 14190                                  
 14191                                  ;--------------------------------------------------------------------------
 14192                                  ; Proc name : Get_Driver_BL
 14193                                  ;
 14194                                  ;	DS is DOSDATA
 14195                                  ;	BL is drive number (0=default)
 14196                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 14197                                  ;	No regs modified
 14198                                  ;
 14199                                  ;---------------------------------------------------------------------------
 14200                                  
 14201                                  Get_Driver_BL:
 14202 000031D6 50                      	PUSH	AX
 14203 000031D7 88D8                    	MOV	AL,BL			; Drive
 14204 000031D9 E89837                  	call	GETTHISDRV
 14205 000031DC 7225                    	jc	short ioctl_bad_drv
 14206 000031DE 30DB                    	XOR	BL,BL			; Unit zero on Net device
 14207 000031E0 C606[D102]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net
 14208 000031E5 C43E[3A05]              	LES	DI,[THISCDS]
 14209 000031E9 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 14210 000031EF 26C47D45                	LES	DI,[ES:DI+curdir.devptr]; ES:DI -> Dpb or net dev
 14211 000031F3 750D                    	JNZ	short got_dev_ptr	; Is net
 14212 000031F5 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 14213 000031FA 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 14214 000031FE 26C47D12                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 14215                                  got_dev_ptr:
 14216 00003202 F8                      	CLC
 14217                                  ioctl_bad_drv:
 14218 00003203 58                      	POP	AX
 14219 00003204 C3                      	retn
 14220                                  
 14221                                  ;-------------------------------------------------------------------------
 14222                                  ; Proc Name : Check_If_Net:
 14223                                  ;
 14224                                  ;
 14225                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 14226                                  ; If no device is found, the return address is popped off the stack, and a
 14227                                  ; jump is made to ioctl_drv_err.
 14228                                  ;
 14229                                  ; On Entry:
 14230                                  ; Registers same as those for Get_Driver_BL
 14231                                  ;
 14232                                  ; On Exit:
 14233                                  ; ZERO flag	- set if not a net device
 14234                                  ;		- reset if net device
 14235                                  ; ES:DI -> the device
 14236                                  ;
 14237                                  ;
 14238                                  ; BUGBUG: This function assumes the following stack setup on entry
 14239                                  ;
 14240                                  ;	  SP+2 -> Error return address
 14241                                  ;	  SP   -> Normal return address
 14242                                  ;
 14243                                  ;-------------------------------------------------------------------------
 14244                                  
 14245                                  Check_If_Net:
 14246                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14247 00003205 E8CEFF                  	CALL	Get_Driver_BL
 14248 00003208 720F                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 14249 0000320A 06                      	PUSH	ES
 14250 0000320B 57                      	PUSH	DI
 14251 0000320C C43E[3A05]              	LES	DI,[THISCDS]
 14252 00003210 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 14253 00003216 5F                      	POP	DI
 14254 00003217 07                      	POP	ES
 14255 00003218 C3                      	retn
 14256                                  
 14257                                  ioctl_drv_err_pop:
 14258 00003219 58                      	pop	ax			; pop off return address
 14259 0000321A E93CFF                  	jmp	ioctl_drv_err
 14260                                  
 14261                                  ioctl_bad_funj3:
 14262 0000321D E9A0FE                  	jmp	ioctl_bad_fun
 14263                                  
 14264                                  ioctl_string_errj:
 14265 00003220 EB9F                    	jmp	ioctl_string_err
 14266                                  
 14267                                  ;--------------------------------------------------------------------------
 14268                                  ;
 14269                                  ; IOCTL: AL = E, F
 14270                                  ;
 14271                                  ; ENTRY: DS = DOSDATA
 14272                                  ;
 14273                                  ;
 14274                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 14275                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14276                                  ;         return address off the stack if the drive is invalid.
 14277                                  ;
 14278                                  ;--------------------------------------------------------------------------
 14279                                  
 14280                                  ioctl_drive_owner:
 14281                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14282 00003222 E8E0FF                  	Call	Check_If_Net
 14283 00003225 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 14284                                  					;   certainly don't know how to do this
 14285                                  					;   call.
 14286                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 14287                                  	; 09/09/2018
 14288 00003227 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 14289 0000322C 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 14290 0000322E C606[2603]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 14291 00003233 3C0E                    	cmp	al,0Eh			; Get Owner ?
 14292 00003235 7405                    	jz	short GetOwner
 14293                                  SetOwner:
 14294 00003237 C606[2603]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN
 14295                                  GetOwner:
 14296 0000323C B00D                    	MOV	AL,OWNHL
 14297 0000323E 88DC                    	MOV	AH,BL			; Unit number
 14298 00003240 A3[2403]                	MOV	[IOCALL_REQLEN],AX
 14299 00003243 31C0                    	XOR	AX,AX
 14300 00003245 A3[2703]                	MOV	[IOCALL_REQSTAT],AX
 14301 00003248 06                      	PUSH	ES
 14302 00003249 1F                      	POP	DS
 14303 0000324A 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14304 0000324C 16                      	PUSH	SS
 14305 0000324D 07                      	POP	ES
 14306 0000324E BB[2403]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14307 00003251 1E                      	push	ds
 14308 00003252 56                      	push	si
 14309 00003253 E8A71C                  	call	DEVIOCALL2
 14310 00003256 5E                      	pop	si
 14311 00003257 1F                      	pop	ds
 14312                                  ;hkn; SS override
 14313 00003258 36F706[2703]0080        	TEST	word [SS:IOCALL_REQSTAT],STERR
 14314 0000325F 75BF                    	jnz	short ioctl_string_errj
 14315 00003261 36A0[2503]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 14316                                  					; owner returned is 1-based.
 14317 00003265 E995E4                  	jmp	SYS_RET_OK
 14318                                  
 14319                                  ;============================================================================
 14320                                  ; DELETE.ASM, MSDOS 6.0, 1991
 14321                                  ;============================================================================
 14322                                  ; 07/08/2018 - Retro DOS v3.0
 14323                                  
 14324                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 14325                                  ;	NAME	DOS_DELETE
 14326                                  
 14327                                  ;
 14328                                  ;	Microsoft Confidential
 14329                                  ;	Copyright (C) Microsoft Corporation 1991
 14330                                  ;	All Rights Reserved.
 14331                                  ;
 14332                                  
 14333                                  ;**	DELETE.ASM - Low level routine for deleting files
 14334                                  ;
 14335                                  ;		DOS_DELETE
 14336                                  ;		REN_DEL_Check
 14337                                  ;		FastOpen_Delete	       ; DOS 3.3
 14338                                  ;		FastOpen_Update	       ; DOS 3.3
 14339                                  
 14340                                  
 14341                                  ;   Revision history:
 14342                                  ;
 14343                                  ;   A000  version 4.00	Jan. 1988
 14344                                  ;   A001  Fastopen Rename fix	April 1989
 14345                                  
 14346                                  
 14347                                  ;Installed = TRUE
 14348                                  
 14349                                  ;	i_need	NoSetDir,BYTE
 14350                                  ;	i_need	Creating,BYTE
 14351                                  ;	i_need	DELALL,BYTE
 14352                                  ;	i_need	THISDPB,DWORD
 14353                                  ;	i_need	THISSFT,DWORD
 14354                                  ;	i_need	THISCDS,DWORD
 14355                                  ;	i_need	CURBUF,DWORD
 14356                                  ;	i_need	ATTRIB,BYTE
 14357                                  ;	i_need	SATTRIB,BYTE
 14358                                  ;	i_need	WFP_START,WORD
 14359                                  ;	i_need	REN_WFP,WORD			 ;BN001
 14360                                  ;	i_need	NAME1,BYTE			 ;BN001
 14361                                  ;	i_need	FoundDel,BYTE
 14362                                  ;	i_need	AUXSTACK,BYTE
 14363                                  ;	i_need	VOLCHNG_FLAG,BYTE
 14364                                  ;	i_need	JShare,DWORD
 14365                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 14366                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 14367                                  ;
 14368                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 14369                                  ;
 14370                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 14371                                  ;	i_need	DMAADD,DWORD
 14372                                  ;	i_need	RENAMEDMA,BYTE
 14373                                  
 14374                                  ;---------------------------------------------------------------------------
 14375                                  ;
 14376                                  ; Procedure Name : DOS_DELETE
 14377                                  ;
 14378                                  ; Inputs:
 14379                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 14380                                  ;		terminated)
 14381                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 14382                                  ;		( = -1 if current dir not involved, else
 14383                                  ;		 Points to first char after last "/" of current dir part)
 14384                                  ;	[THISCDS] Points to CDS being used
 14385                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 14386                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 14387                                  ; Function:
 14388                                  ;	Delete the specified file(s)
 14389                                  ; Outputs:
 14390                                  ;	CARRY CLEAR
 14391                                  ;		OK
 14392                                  ;	CARRY SET
 14393                                  ;	    AX is error code
 14394                                  ;		error_file_not_found
 14395                                  ;			Last element of path not found
 14396                                  ;		error_path_not_found
 14397                                  ;			Bad path (not in curr dir part if present)
 14398                                  ;		error_bad_curr_dir
 14399                                  ;			Bad path in current directory part of path
 14400                                  ;		error_access_denied
 14401                                  ;			Attempt to delete device or directory
 14402                                  ;		***error_sharing_violation***
 14403                                  ;			Deny both access required, generates an INT 24.
 14404                                  ;			This error is NOT returned. The INT 24H is generated,
 14405                                  ;			  and the file is ignored (not deleted). Delete will
 14406                                  ;			  simply continue on looking for more files.
 14407                                  ;			  Carry will NOT be set in this case.
 14408                                  ; DS preserved, others destroyed
 14409                                  ;
 14410                                  ;---------------------------------------------------------------------------
 14411                                  
 14412                                  FILEFOUND   equ 01h
 14413                                  FILEDELETED equ 10h
 14414                                  
 14415                                  DOS_DELETE:
 14416                                  
 14417                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 14418                                  ;hkn; appropriately at this point.
 14419                                  
 14420 00003268 E85AED                  	call	TestNet
 14421 0000326B 7306                    	JNC	short LOCAL_DELETE
 14422                                  
 14423                                  ;IF NOT Installed
 14424                                  ;	transfer NET_DELETE
 14425                                  ;ELSE
 14426                                  	;MOV	AX,(MultNET SHL 8) | 19
 14427                                  	;INT	2FH
 14428                                  	;return
 14429                                  
 14430 0000326D B81311                  	mov	ax,1113h
 14431 00003270 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 14432                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 14433                                  			;		fully-qualified filename in DOS CS
 14434                                  			; SDA CDS pointer -> current directory structure for drive with file
 14435                                  			; Return: CF set on error
 14436 00003272 C3                      	retn
 14437                                  
 14438                                  ;ENDIF
 14439                                  
 14440                                  LOCAL_DELETE:
 14441 00003273 C606[0A05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 14442 00003278 E8E8ED                  	call	EcritDisk
 14443 0000327B C706[1805]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 14444 00003281 8B36[4A05]              	MOV	SI,[WFP_START]
 14445                                  SKPNUL:
 14446 00003285 AC                      	LODSB
 14447 00003286 08C0                    	OR	AL,AL
 14448 00003288 75FB                    	JNZ	short SKPNUL		; go to end
 14449 0000328A 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 14450 0000328D 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 14451 00003291 7506                    	JNZ	short TEST_QUEST
 14452 00003293 807C022A                	CMP	BYTE [SI+2],"*"
 14453 00003297 741F                    	JZ	short CHECK_ATTS
 14454                                  TEST_QUEST:
 14455 00003299 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 14456 0000329C 87FE                    	XCHG	DI,SI
 14457                                  
 14458 0000329E 16                      	push	ss
 14459                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 14460 0000329F 07                      	pop	es ; 17/05/2019 (BugFix)
 14461                                  
 14462 000032A0 B83F3F                  	MOV	AX,"??"
 14463 000032A3 B90400                  	MOV	CX,4		; four sets of "??"
 14464 000032A6 F3AF                    	REPE	SCASW
 14465 000032A8 751C                    	JNZ	short NOT_ALL
 14466 000032AA 87FE                    	XCHG	DI,SI
 14467 000032AC AD                      	LODSW
 14468 000032AD 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 14469 000032B0 7514                    	JNZ	short NOT_ALL
 14470 000032B2 AD                      	LODSW
 14471 000032B3 3D3F3F                  	CMP	AX,"??"
 14472 000032B6 750E                    	JNZ	short NOT_ALL
 14473                                  CHECK_ATTS:
 14474 000032B8 A0[0805]                	MOV	AL,[SATTRIB]
 14475 000032BB 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 14476                                  					; Look only at hidden bits
 14477 000032BD 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 14478                                  					; All must be set
 14479 000032BF 7505                    	JNZ	short NOT_ALL
 14480                                  
 14481                                  ; NOTE WARNING DANGER-----
 14482                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 14483                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 14484                                  
 14485 000032C1 C606[1905]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 14486                                  NOT_ALL:
 14487 000032C6 C606[F802]01            	MOV	byte [NoSetDir],1
 14488 000032CB E86C15                  	call	GetPathNoSet
 14489 000032CE 7313                    	JNC	short Del_found
 14490 000032D0 750C                    	JNZ	short _bad_path
 14491 000032D2 08C9                    	OR	CL,CL
 14492 000032D4 7408                    	JZ	short _bad_path
 14493                                  No_file:
 14494 000032D6 B80200                  	MOV	AX,error_file_not_found
 14495                                  ErrorReturn:
 14496 000032D9 F9                      	STC
 14497 000032DA E88EED                  	call	LcritDisk
 14498 000032DD C3                      	retn
 14499                                  
 14500                                  _bad_path:
 14501 000032DE B80300                  	MOV	AX,error_path_not_found
 14502 000032E1 EBF6                    	JMP	short ErrorReturn
 14503                                  
 14504                                  Del_found:
 14505 000032E3 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 14506 000032E5 803E[1905]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 14507 000032EA 7405                    	JZ	short NOT_DIR
 14508                                  Del_access_err:
 14509 000032EC B80500                  	MOV	AX,error_access_denied
 14510 000032EF EBE8                    	JMP	short ErrorReturn
 14511                                  
 14512                                  NOT_DIR:
 14513 000032F1 08E4                    	OR	AH,AH			; Check if device name
 14514 000032F3 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 14515                                  
 14516                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 14517                                  
 14518                                  DELFILE:
 14519 000032F5 800E[0A05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 14520                                  
 14521                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 14522                                  ; DOS issue a build BPB call the next time this drive is accessed.
 14523                                  
 14524 000032FA 1E                      	PUSH	DS
 14525 000032FB 8A26[1905]              	MOV	AH,[DELALL]
 14526 000032FF C53E[7405]              	LDS	DI,[CURBUF]
 14527                                  	
 14528                                  ;hkn; SS override
 14529 00003303 36F606[0605]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 14530 00003309 7509                    	JNZ	short DoDelete		; yes
 14531                                  
 14532 0000330B F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 14533 0000330F 7403                    	JZ	short DoDelete		; not read only
 14534                                  
 14535 00003311 1F                      	POP	DS
 14536 00003312 EB29                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 14537                                  
 14538                                  DoDelete:
 14539 00003314 E87700                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 14540 00003317 7303                    	JNC	short DEL_SHARE_OK
 14541 00003319 1F                      	POP	DS
 14542 0000331A EB21                    	JMP	SHORT DELNXT		; Skip it
 14543                                  
 14544                                  DEL_SHARE_OK:
 14545                                  	; MSDOS 6.0
 14546                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 14547                                  	;				;LB. if already dirty		  ;AN000;
 14548                                  	;JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 14549                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 14550 0000331C 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 14551                                  ;yesdirty:
 14552 00003320 8827                    	MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 14553 00003322 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 14554 00003324 1F                      	POP	DS
 14555 00003325 800E[0A05]10            	OR	byte [FOUNDDEL],FILEDELETED ; Deleted file
 14556                                  
 14557 0000332A 83FB02                  	CMP	BX,2
 14558 0000332D 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 14559 0000332F 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 14560 00003333 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 14561                                  
 14562 00003335 E8B421                  	call	RELEASE 		; Free file data
 14563 00003338 724E                    	JC	short No_fileJ
 14564                                  
 14565                                  ; DOS 3.3  FastOpen
 14566                                  
 14567 0000333A E8BA00                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 14568                                  
 14569                                  ; DOS 3.3  FastOpen
 14570                                  
 14571                                  DELNXT:
 14572 0000333D C42E[2405]              	LES	BP,[THISDPB]		; Possible to get here without this set
 14573 00003341 E86A14                  	call	GETENTRY		; Registers need to be reset
 14574 00003344 7242                    	JC	short No_fileJ
 14575 00003346 E8AC13                  	call	NEXTENT
 14576 00003349 73AA                    	JNC	short DELFILE
 14577 0000334B C42E[2405]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 14578                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 14579 0000334F 268A4600                	MOV	AL,[ES:BP]
 14580 00003353 E8DA2B                  	call	FLUSHBUF
 14581 00003356 7230                    	JC	short No_fileJ
 14582                                  ;
 14583                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 14584                                  ;
 14585                                  ;   not found not deleted		file not found
 14586                                  ;   not found	  deleted		*** impossible ***
 14587                                  ;	found not deleted		access denied (read-only)
 14588                                  ;	found	  deleted		no error
 14589                                  ;
 14590 00003358 F606[0A05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 14591 0000335D 7422                    	JZ	short DelError		; no, figure out what's wrong.
 14592                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 14593                                  ; and to force the DOS to issue a media check.
 14594 0000335F F606[0605]08            	TEST	byte [ATTRIB],attr_volume_id
 14595 00003364 7417                    	jz	short No_Set_Flag
 14596 00003366 50                      	PUSH	AX
 14597 00003367 06                      	PUSH	ES
 14598 00003368 57                      	PUSH	DI
 14599 00003369 C43E[3A05]              	LES	DI,[THISCDS]
 14600 0000336D 268A25                  	MOV	AH,[ES:DI]		; Get drive
 14601 00003370 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 14602 00003373 8826[070A]              	mov	[VOLCHNG_FLAG],AH
 14603                                  	
 14604                                  	; MSDOS 6.0
 14605                                  	;XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 14606                                  	;call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
 14607                                  	 
 14608 00003377 E84428                  	call	FATREAD_CDS		; force media check
 14609 0000337A 5F                      	POP	DI
 14610 0000337B 07                      	POP	ES
 14611 0000337C 58                      	POP	AX
 14612                                  No_Set_Flag:
 14613 0000337D E8EBEC                  	call	LcritDisk		; carry is clear
 14614 00003380 C3                      	retn
 14615                                  DelError:
 14616 00003381 F606[0A05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 14617 00003386 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 14618                                  No_fileJ:
 14619 00003388 E94BFF                  	JMP	No_file ; 10/08/2018 		; Nope
 14620                                  Del_access_errJ:
 14621 0000338B E95EFF                  	JMP	Del_access_err ; 10/08/2018
 14622                                  
 14623                                  ; 08/08/2018 - Retro DOS v3.0
 14624                                  
 14625                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 14626                                  ;---------------------------------------------------------------------------
 14627                                  ; Procedure Name : REN_DEL_Check
 14628                                  ;
 14629                                  ; Inputs:
 14630                                  ;	[THISDPB] set
 14631                                  ;	[CURBUF+2]:BX points to entry
 14632                                  ;	[CURBUF+2]:SI points to firclus field of entry
 14633                                  ;	[WFP_Start] points to name
 14634                                  ; Function:
 14635                                  ;	Check for Exclusive access on given file.
 14636                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 14637                                  ; Outputs:
 14638                                  ;	ES:BP = [THISDPB]
 14639                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 14640                                  ;		last element will be loaded from the directory entry.  This is
 14641                                  ;		so the name given to the sharer doesn't have any meta chars in
 14642                                  ;		it.
 14643                                  ;	Carry set if sharing violation, INT 24H generated
 14644                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 14645                                  ;		This is because input AX is preserved.
 14646                                  ;		Caller must set the error if needed.
 14647                                  ;	Carry clear
 14648                                  ;		OK
 14649                                  ; AX,DS,BX,SI,DI preserved
 14650                                  ;---------------------------------------------------------------------------
 14651                                  
 14652                                  REN_DEL_Check:
 14653                                  
 14654 0000338E 1E                      	PUSH	DS
 14655 0000338F 57                      	PUSH	DI
 14656 00003390 50                      	PUSH	AX
 14657 00003391 53                      	PUSH	BX
 14658 00003392 56                      	PUSH	SI		; Save CURBUF pointers
 14659                                  	
 14660 00003393 16                      	push	ss
 14661 00003394 07                      	pop	es
 14662                                  
 14663                                  ;hkn; context ES will assume ES to DOSDATA
 14664                                  ;hkn; ASSUME	ES:DOSGROUP
 14665                                  
 14666                                  ;hkn; SS override
 14667 00003395 368B3E[4A05]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 14668 0000339A 89DE                    	MOV	SI,BX
 14669                                  
 14670                                  ;hkn; SS override
 14671 0000339C 368E1E[7605]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 14672 000033A1 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 14673 000033A3 83C302                  	ADD	BX,2		; Skip over d: to point to leading '\'
 14674 000033A6 E8B8EB                  	call	StrLen		; CX is length of ES:DI including NUL
 14675 000033A9 49                      	DEC	CX		; Don't include nul in count
 14676 000033AA 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 14677 000033AC E88838                  	call	SkipBack	; Back up one element
 14678 000033AF 47                      	INC	DI		; Point to start of last element
 14679                                  
 14680                                  ;hkn; SS override
 14681                                  	; MSDOS 6.0
 14682                                  	;MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 14683                                  	;
 14684 000033B0 E85FFA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 14685 000033B3 5E                      	POP	SI		; Get back entry pointers
 14686 000033B4 5B                      	POP	BX
 14687 000033B5 53                      	PUSH	BX
 14688 000033B6 56                      	PUSH	SI		; Back on stack
 14689                                  	
 14690 000033B7 16                      	push	ss
 14691 000033B8 1F                      	pop	ds
 14692                                  
 14693                                  ;hkn; context DS will assume ES to DOSDATA
 14694                                  ;hkn; ASSUME	DS:DOSGROUP
 14695                                  
 14696                                  ;
 14697                                  ; Close the file if possible by us.
 14698                                  ;
 14699                                  ;if installed
 14700 000033B9 FF1E[9000]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 14701                                  ;else
 14702                                  ;	Call	ShCloseFile
 14703                                  ;endif
 14704 000033BD 8C1E[3805]              	MOV	[THISSFT+2],DS
 14705                                  
 14706                                  ;hkn; AUXSTACK is in DOSDATA
 14707 000033C1 C706[3605][D106]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size
 14708                                  				; Scratch space
 14709 000033C7 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 14710 000033C9 E8F71D                  	call	DOOPEN		; Fill in SFT for share check
 14711 000033CC C43E[3605]              	LES	DI,[THISSFT]
 14712 000033D0 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH
 14713                                  				; requires exclusive access
 14714                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 14715 000033D6 26C7050100              	mov	word [ES:DI],1
 14716 000033DB E87A3F                  	call	ShareEnter
 14717 000033DE 720D                    	jc	short CheckDone
 14718 000033E0 C43E[3605]              	LES	DI,[THISSFT]
 14719                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 14720 000033E4 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 14721                                  	
 14722 000033E9 E8673F                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 14723 000033EC F8                      	CLC
 14724                                  CheckDone:
 14725 000033ED C42E[2405]              	LES	BP,[THISDPB]
 14726 000033F1 5E                      	POP	SI
 14727 000033F2 5B                      	POP	BX
 14728 000033F3 58                      	POP	AX
 14729 000033F4 5F                      	POP	DI
 14730 000033F5 1F                      	POP	DS
 14731 000033F6 C3                      	retn
 14732                                  
 14733                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 14734                                  ;---------------------------------------------------------------------------
 14735                                  ; Procedure Name : FastOpen_Delete
 14736                                  ; Inputs:
 14737                                  ;	None
 14738                                  ; Function:
 14739                                  ;	Call FastOpen to delete the dir info.
 14740                                  ; Outputs:
 14741                                  ;	None
 14742                                  ;---------------------------------------------------------------------------
 14743                                  
 14744                                  FastOpen_Delete:
 14745 000033F7 9C                      	PUSHF			; save flag
 14746 000033F8 56                      	PUSH	SI		; save registers
 14747 000033F9 53                      	PUSH	BX
 14748 000033FA 50                      	PUSH	AX
 14749                                  ;hkn; SS override
 14750 000033FB 8B36[4A05]              	MOV	SI,[WFP_START]	; ds:si points to path name
 14751 000033FF B003                    	MOV	AL,FONC_delete	; al = 3
 14752                                  fastinvoke:
 14753                                  ;hkn; FastTable is in DOSDATA
 14754 00003401 BB[450F]                	MOV	BX,FastTable+2
 14755 00003404 FF1F                    	CALL	far [BX]	; call fastopen
 14756 00003406 58                      	POP	AX		; restore registers
 14757 00003407 5B                      	POP	BX
 14758 00003408 5E                      	POP	SI
 14759 00003409 9D                      	POPF			; restore flag
 14760 0000340A C3                      	retn
 14761                                  
 14762                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 14763                                  ;---------------------------------------------------------------------------
 14764                                  ; Procedure Name : FastOpen_Update
 14765                                  ;
 14766                                  ; Inputs:
 14767                                  ;	DL     drive number (A=0,B=1,,,)
 14768                                  ;	CX     first cluster #
 14769                                  ;	AH     0 updates dir entry
 14770                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 14771                                  ;	ES:DI  directory entry
 14772                                  ; Function:
 14773                                  ;	Call FastOpen to update the dir info.
 14774                                  ; Outputs:
 14775                                  ;	None
 14776                                  ;---------------------------------------------------------------------------
 14777                                  
 14778                                  FastOpen_Update:
 14779 0000340B 9C                      	PUSHF			; save flag
 14780 0000340C 56                      	PUSH	SI
 14781 0000340D 53                      	PUSH	BX		; save regs
 14782 0000340E 50                      	PUSH	AX
 14783 0000340F B004                    	MOV	AL,FONC_update	; al = 4
 14784 00003411 EBEE                    	JMP	short fastinvoke
 14785                                  
 14786                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 14787                                  ;---------------------------------------------------------------------------
 14788                                  ; PROCEDURE Name : FastOpen_Rename
 14789                                  ;
 14790                                  ; Inputs:
 14791                                  ;	 REN_WFP   = Path Name
 14792                                  ;	 NAME1	   = New Name
 14793                                  ; Function:
 14794                                  ;	Call FastOpen to rename the dir entry in the cache
 14795                                  ; Outputs:
 14796                                  ;	None
 14797                                  ;---------------------------------------------------------------------------
 14798                                  
 14799                                  FastOpen_Rename:
 14800                                  	; 08/08/2018 - Retro DOS v3.0
 14801                                  	; MSDOS 6.0
 14802                                  	;PUSHF			;AN001 save flag
 14803                                  	;PUSH	SI		;AN001 save registers
 14804                                  	;PUSH	DI		;AN001
 14805                                  	;PUSH	BX		;AN001
 14806                                  	;PUSH	AX		;AN001
 14807                                  	;
 14808                                  ;hkn; SS override
 14809                                  	;;MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 14810                                  	;
 14811                                  	; ? - 08/08/2018 - Retro DOS v3.0
 14812                                  	;push	ss
 14813                                  	;pop	ds
 14814                                  	;mov	si,[REN_WFP]
 14815                                  	;
 14816                                  ;hkn; NAME1 is in DOSDATA
 14817                                  	;MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 14818                                  	;MOV	AL,FONC_Rename	;;AN001  al = 6
 14819                                  	;
 14820                                  ;hkn; FastTable is in DOSDATA
 14821                                  	;MOV	BX,FastTable+2
 14822                                  	;CALL	far [BX]	;;AN001  call fastopen
 14823                                  	;
 14824                                  	;POP	AX		; restore registers  ;AN001
 14825                                  	;POP	BX				     ;AN001
 14826                                  	;POP	DI				     ;AN001
 14827                                  	;POP	SI				     ;AN001
 14828                                  	;POPF			; restore flag	     ;AN001
 14829                                  	;retn					     ;AN001
 14830                                  
 14831                                  	; MSDOS 6.0
 14832                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 14833                                  Fast_Dispatch:
 14834                                  ;hkn; FastTable is in DOSDATA
 14835                                  	;MOV	SI,FastTable+2	; index to the	     ;AN000;
 14836                                  ;hkn; use SS override
 14837                                  	;CALL	far [SS:SI]	; RMFD call fastopen
 14838                                  	;retn
 14839                                  
 14840                                  ;============================================================================
 14841                                  ; RENAME.ASM, MSDOS 6.0, 1991
 14842                                  ;============================================================================
 14843                                  ; 08/08/2018 - Retro DOS v3.0
 14844                                  
 14845                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 14846                                  ;	NAME	DOS_RENAME
 14847                                  
 14848                                  ;**	Low level routine for renaming files
 14849                                  ;
 14850                                  ;	DOS_RENAME
 14851                                  ;
 14852                                  ;	Modification history:
 14853                                  ;
 14854                                  ;	    Created: ARR 30 March 1983
 14855                                  
 14856                                  ;----------------------------------------------------------------------------
 14857                                  ;
 14858                                  ; Procedure Name : DOS_RENAME
 14859                                  ;
 14860                                  ; Inputs:
 14861                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 14862                                  ;		chars, NUL terminated)
 14863                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 14864                                  ;		( = -1 if current dir not involved, else
 14865                                  ;		 Points to first char after last "/" of current dir part)
 14866                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 14867                                  ;		chars, NUL terminated)
 14868                                  ;	[THISCDS] Points to CDS being used
 14869                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 14870                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 14871                                  ; Function:
 14872                                  ;	Rename the specified file(s)
 14873                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 14874                                  ; Outputs:
 14875                                  ;	CARRY CLEAR
 14876                                  ;	    OK
 14877                                  ;	CARRY SET
 14878                                  ;	    AX is error code
 14879                                  ;		error_file_not_found
 14880                                  ;			No match for source, or dest path invalid
 14881                                  ;		error_not_same_device
 14882                                  ;			Source and dest are on different devices
 14883                                  ;		error_access_denied
 14884                                  ;			Directory specified (not simple rename),
 14885                                  ;			Device name given, Destination exists.
 14886                                  ;			NOTE: In third case some renames may have
 14887                                  ;			 been done if metas.
 14888                                  ;		error_path_not_found
 14889                                  ;			Bad path (not in curr dir part if present)
 14890                                  ;			SOURCE ONLY
 14891                                  ;		error_bad_curr_dir
 14892                                  ;			Bad path in current directory part of path
 14893                                  ;			SOURCE ONLY
 14894                                  ;		error_sharing_violation
 14895                                  ;			Deny both access required, generates an INT 24.
 14896                                  ; DS preserved, others destroyed
 14897                                  ;
 14898                                  ;----------------------------------------------------------------------------
 14899                                  
 14900                                  DOS_RENAME:
 14901                                  
 14902                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 14903                                  ;hkn; at this point to DOSDATA.
 14904                                  
 14905 00003413 E8AFEB                  	call	TestNet
 14906 00003416 7306                    	JNC	short LOCAL_RENAME
 14907                                  
 14908                                  ;IF NOT Installed
 14909                                  ;	transfer NET_RENAME
 14910                                  ;ELSE
 14911                                  	;MOV	AX,(MultNET SHL 8) OR 17
 14912                                  	;INT	2FH
 14913                                  	;return
 14914                                  
 14915 00003418 B81111                  	mov     ax, 1111h
 14916 0000341B CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 14917                                  			; SS = DS = DOS CS, 
 14918                                  			; SDA first filename pointer = offset of fully-qualified old name
 14919                                  			; SDA CDS pointer -> current directory
 14920                                  			; Return: CF set on error
 14921 0000341D C3                      	retn
 14922                                  ;ENDIF
 14923                                  
 14924                                  LOCAL_RENAME:
 14925 0000341E C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 14926 00003423 8B36[4A05]              	MOV	SI,[WFP_START]
 14927 00003427 8B3E[4C05]              	MOV	DI,[REN_WFP]
 14928 0000342B 8A04                    	MOV	AL,[SI]
 14929 0000342D 8A25                    	MOV	AH,[DI]
 14930 0000342F 0D2020                  	OR	AX,2020H		; Lower case
 14931 00003432 38E0                    	CMP	AL,AH
 14932 00003434 7405                    	JZ	short SAMEDRV
 14933 00003436 B81100                  	MOV	AX,error_not_same_device
 14934 00003439 F9                      	STC
 14935 0000343A C3                      	retn
 14936                                  
 14937                                  SAMEDRV:
 14938 0000343B FF36[DC02]              	PUSH	WORD [DMAADD+2]
 14939 0000343F FF36[DA02]              	PUSH	WORD [DMAADD]
 14940 00003443 8C1E[DC02]              	MOV	[DMAADD+2],DS
 14941                                  
 14942                                  ;hkn; RENAMEDMA is in DOSDATA
 14943 00003447 C706[DA02][8605]        	MOV	WORD [DMAADD],RENAMEDMA
 14944 0000344D C606[0B05]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 14945 00003452 E80EEC                  	call	EcritDisk
 14946 00003455 E8B804                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 14947                                  					;    points to entry
 14948 00003458 7315                    	JNC	short Check_Dev
 14949 0000345A 83F812                  	CMP	AX,error_no_more_files
 14950 0000345D 7503                    	JNZ	short GOTERR
 14951 0000345F B80200                  	MOV	AX,error_file_not_found
 14952                                  GOTERR:
 14953 00003462 F9                      	STC
 14954                                  RENAME_POP:
 14955 00003463 8F06[DA02]              	POP	WORD [DMAADD]
 14956 00003467 8F06[DC02]              	POP	WORD [DMAADD+2]
 14957 0000346B E8FDEB                  	call	LcritDisk
 14958 0000346E C3                      	retn
 14959                                  
 14960                                  Check_Dev:
 14961 0000346F B80500                  	MOV	AX,error_access_denied	; Assume error
 14962                                  	;
 14963                                  	; MSDOS 6.0
 14964                                  	;PUSH	DS			      ;PTM.			    ;AN000;
 14965                                  	;LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
 14966                                  	;!?;ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 14967                                  	;!?;TEST byte [SI+dir_entry.dir_attr],attr_directory  ;PTM.	    ;AN000;
 14968                                  	;JZ	short notdir		      ;PTM.			    ;AN000;
 14969                                  	;MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 14970                                  	;call	Check_Pathlen2		      ;PTM.   length < 67	    ;AN000;
 14971                                  ;notdir:
 14972                                  	;POP	DS			      ;PTM.			    ;AN000;
 14973                                  	;JA	short GOTERR		      ;PTM.			    ;AN000;
 14974                                  	;
 14975                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14976 00003472 803E[0B05]00            	CMP	byte [FOUND_DEV],0
 14977 00003477 75E9                    	JNZ	short GOTERR
 14978                                  ; At this point a source has been found. There is search continuation info (a
 14979                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 14980                                  ; directory entry found.
 14981                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 14982                                  ; throughout the RENAME since it is known at this point that the source and
 14983                                  ; destination are both on the same device.
 14984                                  ; [SATTRIB] is also set.
 14985 00003479 89DE                    	MOV	SI,BX
 14986 0000347B 83C61A                  	ADD	SI,dir_entry.dir_first
 14987 0000347E E80DFF                  	call	REN_DEL_Check
 14988 00003481 7305                    	JNC	short REN_OK1
 14989 00003483 B82000                  	MOV	AX,error_sharing_violation
 14990 00003486 EBDB                    	JMP	short RENAME_POP
 14991                                  
 14992                                  ;------------------------------------------------------------------------------
 14993                                  ; Check if the source is a file or directory. If file, delete the entry
 14994                                  ; from the Fastopen cache. If directory, rename it later
 14995                                  ;------------------------------------------------------------------------------
 14996                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 14997                                  	; MSDOS 6.0
 14998                                  	;PUSH	SI
 14999                                  	;LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 15000                                  	;!?;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		   ;AN000;
 15001                                  	;!?;TEST byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.   ;AN000;
 15002                                  	;JZ	short NOT_DIR1		;;BN00XPTM.			   ;AN000;
 15003                                  	;POP	SI			;BN00X
 15004                                  	;JMP	SHORT SWAP_SOURCE	;BN00X
 15005                                  	;
 15006                                  ;NOT_DIR1:				;;BN00X it is a file, delete the entry
 15007                                  	;POP	SI
 15008                                  	;
 15009                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 15010 00003488 E86CFF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 15011                                  
 15012                                  ;SWAP_SOURCE:
 15013                                  	; MSDOS 3.3
 15014                                  	;MOV	SI,[REN_WFP]
 15015                                  	;MOV	[WFP_START],SI
 15016                                  	; MSDOS 6.0
 15017 0000348B A1[4A05]                	MOV	AX,[WFP_START]		; Swap source and destination
 15018 0000348E 8B36[4C05]              	MOV	SI,[REN_WFP]		; Swap source and destination
 15019 00003492 8936[4A05]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 15020 00003496 A3[4C05]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 15021                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15022 00003499 C706[4E05]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 15023 0000349F C706[1805]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 15024                                  					; A rename is like a CREATE_NEW as far
 15025                                  					; as the destination is concerned.
 15026 000034A5 E89213                  	call	GetPathNoSet
 15027                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 15028                                  ;   since no files match the destination name. If it fails for any other
 15029                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 15030                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 15031                                  ;   if the rename should fail because we haven't built an explicit name by
 15032                                  ;   substituting for the meta chars in it. In this case the destination file
 15033                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 15034                                  ;   in the directory entry part.
 15035 000034A8 7223                    	JC	short NODEST
 15036                                  	;; MSDOS 6.0
 15037                                  	;; JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 15038                                  	; !! MSDOS 3.3 !!
 15039 000034AA 7404                    	JZ	short BAD_ACC ; !!	; Dest string is a directory
 15040                                  	;
 15041 000034AC 08E4                    	OR	AH,AH			; Device?
 15042 000034AE 7930                    	JNS	short SAVEDEST		; No, continue
 15043                                  BAD_ACC:
 15044 000034B0 B80500                  	MOV	AX,error_access_denied
 15045 000034B3 F9                      	STC
 15046                                  RENAME_CLEAN:
 15047 000034B4 9C                      	PUSHF				; Save carry state
 15048 000034B5 50                      	PUSH	AX			; and error code (if carry set)
 15049 000034B6 A0[1105]                	MOV	AL,[THISDRV]
 15050 000034B9 E8742A                  	call	FLUSHBUF
 15051 000034BC 58                      	POP	AX
 15052 000034BD 803E[F602]00            	CMP	byte [FAILERR],0
 15053 000034C2 7503                    	JNZ	short BAD_ERR		; User FAILed to I 24
 15054 000034C4 9D                      	POPF
 15055 000034C5 EB9C                    	JMP	short RENAME_POP
 15056                                  
 15057                                  BAD_ERR:
 15058 000034C7 58                      	POP	AX			; Saved flags
 15059 000034C8 B80300                  	MOV	AX,error_path_not_found
 15060 000034CB EB95                    	JMP	short GOTERR
 15061                                  
 15062                                  NODEST:
 15063 000034CD 750B                    	JNZ	short BAD_PATH
 15064 000034CF 803E[F602]00            	CMP	byte [FAILERR],0
 15065 000034D4 7504                    	JNZ	short BAD_PATH	; Search for dest failed because user FAILed on
 15066                                  				;	I 24
 15067 000034D6 08C9                    	OR	CL,CL
 15068 000034D8 7506                    	JNZ	short SAVEDEST
 15069                                  BAD_PATH:
 15070 000034DA B80300                  	MOV	AX,error_path_not_found
 15071 000034DD F9                      	STC
 15072 000034DE EB83                    	JMP	short RENAME_POP
 15073                                  
 15074                                  SAVEDEST:
 15075 000034E0 16                      	push	ss
 15076 000034E1 07                      	pop	es
 15077                                  
 15078                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 15079 000034E2 BF[F204]                	MOV	DI,NAME2
 15080 000034E5 BE[E604]                	MOV	SI,NAME1
 15081                                  
 15082 000034E8 B90B00                  	MOV	CX,11
 15083 000034EB F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 15084 000034ED A1[5805]                	MOV	AX,[DIRSTART]
 15085 000034F0 A3[FF04]                	MOV	[DESTSTART],AX
 15086                                  BUILDDEST:
 15087 000034F3 16                      	push	ss
 15088 000034F4 07                      	pop	es			; needed due to JMP BUILDDEST below
 15089                                  
 15090                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 15091 000034F5 BB[9B05]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 15092 000034F8 BF[E604]                	MOV	DI,NAME1		; Real dest name goes here
 15093 000034FB BE[F204]                	MOV	SI,NAME2		; Raw dest
 15094                                  
 15095 000034FE B90B00                  	MOV	CX,11
 15096                                  	
 15097                                  	; MSDOS 6.0
 15098                                  	;CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 15099                                  
 15100                                  	; MSDOS 3.3
 15101                                  
 15102                                  ; 08/08/2018 - Retro DOS v3.0
 15103                                  ; MSDOS 6.0 
 15104                                  ;---------------------------------------------------------------------------
 15105                                  ;Procedure: NEW_RENAME
 15106                                  ;
 15107                                  ;Input: DS:SI -> raw string with ?
 15108                                  ;	ES:DI -> destination string
 15109                                  ;	DS:BX -> source string
 15110                                  ;Function: replace ? chars of raw string with chars in source string and
 15111                                  ;	   put in destination string
 15112                                  ;Output: ES:DI-> new string
 15113                                  ;---------------------------------------------------------------------------
 15114                                  
 15115                                  NEW_RENAME:
 15116                                  NEWNAM:
 15117                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 15118 00003501 AC                      	LODSB
 15119 00003502 3C3F                    	CMP	AL,"?"
 15120 00003504 7502                    	JNZ	short NOCHG
 15121 00003506 8A07                    	MOV	AL,[BX] 		; Get replace char
 15122                                  NOCHG:
 15123 00003508 AA                      	STOSB
 15124 00003509 43                      	INC	BX			; Next replace char
 15125 0000350A E2F5                    	LOOP	NEWNAM
 15126                                  	; MSSOS 6.0
 15127                                  	;retn
 15128                                  
 15129                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15130 0000350C C606[0605]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 15131 00003511 C606[1805]FF            	MOV	byte [CREATING],0FFH
 15132 00003516 E8C615                  	call	DEVNAME 		; Check if we built a device name
 15133 00003519 7395                    	JNC	short BAD_ACC
 15134 0000351B 8B1E[FF04]              	MOV	BX,[DESTSTART]
 15135 0000351F C42E[2405]              	LES	BP,[THISDPB]
 15136 00003523 E8B912                  	call	SETDIRSRCH		; Reset search to start of dir
 15137 00003526 7288                    	JC	short BAD_ACC 		; Screw up
 15138 00003528 E87911                  	call	FINDENTRY		; See if new name already exists
 15139 0000352B 7383                    	JNC	short BAD_ACC 		; Error if found
 15140 0000352D 803E[F602]00            	CMP	byte [FAILERR],0
 15141 00003532 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 15142 00003534 A1[FF04]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 15143 00003537 3B06[9505]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 15144 0000353B 7453                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 15145                                  
 15146 0000353D A0[A605]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 15147 00003540 A810                    	TEST	AL,attr_directory
 15148 00003542 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 15149                                  					; otherwise the . and .. entries get
 15150                                  					; wiped.
 15151 00003544 A2[0605]                	MOV	[ATTRIB],AL
 15152 00003547 8C1E[3805]              	MOV	[THISSFT+2],DS
 15153                                  
 15154                                  ;hkn; AUXSTACK is in DOSDATA
 15155 0000354B BE[D106]                	MOV	SI,AUXSTACK-SF_ENTRY.size
 15156 0000354E 8936[3605]              	MOV	[THISSFT],SI
 15157 00003552 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 15158 00003557 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 15159 00003559 E8F91A                  	call	RENAME_MAKE		; This is in mknode
 15160 0000355C 7303                    	JNC	short GOT_DEST
 15161                                  BAD_ACCJ:
 15162 0000355E E94FFF                  	JMP	BAD_ACC
 15163                                  
 15164                                  GOT_DEST:
 15165 00003561 53                      	push	bx
 15166 00003562 C43E[3605]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 15167 00003566 E8EA3D                  	call	ShareEnd		; we need to remove it.
 15168 00003569 5B                      	pop	bx
 15169                                  ; A zero length entry with the correct new name has now been made at
 15170                                  ;   [CURBUF+2]:BX.
 15171 0000356A C43E[7405]              	LES	DI,[CURBUF]
 15172                                  
 15173                                  	; MSDOS 6.0
 15174                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 15175                                  	;				;LB. if already dirty		  ;AN000;
 15176                                  	;JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 15177                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 15178                                  	
 15179 0000356E 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 15180                                  ;yesdirty:
 15181 00003573 89DF                    	MOV	DI,BX
 15182 00003575 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 15183                                  
 15184                                  ;hkn; RENAMEDMA is in DOSDATA
 15185 00003578 BE[A605]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 15186 0000357B B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr ; mov cx,21
 15187 0000357E F3A4                    	REP	MOVSB
 15188 00003580 E85100                  	CALL	GET_SOURCE
 15189 00003583 724B                    	JC	short RENAME_OVER
 15190 00003585 89DF                    	MOV	DI,BX
 15191 00003587 8E06[7605]              	MOV	ES,[CURBUF+2]
 15192 0000358B B0E5                    	MOV	AL,DIRFREE
 15193 0000358D AA                      	STOSB				; "free" the source
 15194 0000358E EB13                    	JMP	SHORT DIRTY_IT
 15195                                  
 15196                                  SIMPLE_RENAME:
 15197 00003590 E84100                  	CALL	GET_SOURCE		; Get the source back
 15198 00003593 723B                    	JC	short RENAME_OVER
 15199 00003595 89DF                    	MOV	DI,BX
 15200 00003597 8E06[7605]              	MOV	ES,[CURBUF+2]
 15201                                  
 15202                                  ;hkn; NAME1 is in DOSDATA
 15203 0000359B BE[E604]                	MOV	SI,NAME1		; New Name
 15204 0000359E B90B00                  	MOV	CX,11
 15205 000035A1 F3A4                    	REP	MOVSB
 15206                                  DIRTY_IT:
 15207 000035A3 8B3E[7405]              	MOV	DI,[CURBUF]
 15208                                  
 15209                                  	; MSDOS 6.0
 15210                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 15211                                  	;				;LB. if already dirty		  ;AN000;
 15212                                  	;JNZ	short Yesdirty2		;LB.  don't increment dirty count ;AN000;
 15213                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 15214                                  	
 15215 000035A7 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 15216                                  ;------------------------------------------------------------------------------
 15217                                  ; Check if the source is a directory of file. If directory rename it to the
 15218                                  ; the new name in the Fastopen cache buffer.  If file name it has been
 15219                                  ; previously deleted.
 15220                                  ;------------------------------------------------------------------------------
 15221                                  ;Yesdirty2:
 15222                                  	; MSDOS 6.0
 15223                                  	;PUSH	SI
 15224                                  	;LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 15225                                  	;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 15226                                  	;TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 15227                                  	;JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 15228                                  	;call	FASTOPEN_RENAME		;;BN00X rename dir entry in fastopen
 15229                                  	;POP	SI
 15230                                  	;JMP	SHORT NOT_DIRTY1
 15231                                  ;NOT_DIR2:				;;BN00X it is a file, delete the entry
 15232                                  	;POP	SI
 15233                                  ;NOT_DIRTY1:				;;BN00X
 15234                                  NEXT_SOURCE:
 15235                                  ;hkn; RENAMEDMA is in DOSDATA
 15236 000035AC BE[8705]                	MOV	SI,RENAMEDMA+1		;Name
 15237                                  ;
 15238                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 15239                                  ; to enter it before going to RENAME_Next.
 15240                                  ;
 15241 000035AF E8B1EA                  	call	EcritDisk
 15242 000035B2 C606[1805]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 15243                                  				  ;  to FF when we made the prev new file).
 15244 000035B7 E85704                  	call	RENAME_NEXT
 15245                                  ;
 15246                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 15247                                  ; we were before.
 15248                                  ;
 15249 000035BA 7214                    	JC	short RENAME_OVER
 15250 000035BC 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 15251 000035BF E8CCFD                  	call	REN_DEL_Check
 15252 000035C2 7306                    	JNC	short REN_OK2
 15253 000035C4 B82000                  	MOV	AX,error_sharing_violation
 15254 000035C7 E9EAFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 15255                                  
 15256                                  ;------------------------------------------------------------------------------
 15257                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 15258                                  ; if directory, rename directory name in the Fastopen cache.
 15259                                  ;-----------------------------------------------------------------------------
 15260                                  REN_OK2:
 15261                                  	; MSDOS 6.0
 15262                                  	;MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 15263                                  	;TEST	AL,attr_directory	;;BN00X directory
 15264                                  	;JZ	short Ren_Directory	;;BN00X no - file, delete it
 15265                                  	
 15266                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15267 000035CA E82AFE                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 15268 000035CD E923FF                  	JMP	BUILDDEST		;;BN00X
 15269                                  
 15270                                  	; MSDOS 6.0
 15271                                  ;Ren_Directory:
 15272                                  	;call	FASTOPEN_RENAME 	;;BN00X delete dir info in fastopen DOS 3.3
 15273                                  	;JMP	BUILDDEST
 15274                                  
 15275                                  RENAME_OVER:
 15276 000035D0 F8                      	CLC
 15277 000035D1 E9E0FE                  	JMP	RENAME_CLEAN ; 10/08/2018
 15278                                  
 15279                                  ;----------------------------------------------------------------------------
 15280                                  ; Procedure: GET_SOURCE
 15281                                  ;
 15282                                  ; Inputs:
 15283                                  ;	RENAMEDMA has source info
 15284                                  ; Function:
 15285                                  ;	Re-find the source
 15286                                  ; Output:
 15287                                  ;	[CURBUF] set
 15288                                  ;	[CURBUF+2]:BX points to entry
 15289                                  ;	Carry set if error (currently user FAILed to I 24)
 15290                                  ; DS preserved, others destroyed
 15291                                  ;----------------------------------------------------------------------------
 15292                                  
 15293                                  GET_SOURCE:
 15294 000035D4 8B1E[9505]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 15295 000035D8 C42E[2405]              	LES	BP,[THISDPB]
 15296 000035DC E80012                  	call	SETDIRSRCH
 15297 000035DF 7209                    	JC	short gs_ret_label	; retc
 15298 000035E1 E8DA14                  	call	STARTSRCH
 15299 000035E4 A1[9305]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 15300 000035E7 E8C711                  	call	GETENT
 15301                                  
 15302                                  gs_ret_label:
 15303 000035EA C3                      	retn
 15304                                  
 15305                                  ;============================================================================
 15306                                  ; FINFO.ASM, MSDOS 6.0, 1991
 15307                                  ;============================================================================
 15308                                  ; 08/08/2018 - Retro DOS v3.0
 15309                                  
 15310                                  ;**	Low level routines for returning file information and setting file
 15311                                  ;	attributes
 15312                                  ;
 15313                                  ;	GET_FILE_INFO
 15314                                  ;	SET_FILE_ATTRIBUTE
 15315                                  ;
 15316                                  ;	Modification history:
 15317                                  ;
 15318                                  ;	    Created: ARR 30 March 1983
 15319                                  ;
 15320                                  ;	M025: Return access_denied if attempting to set
 15321                                  ;	      attribute of root directory.
 15322                                  ;
 15323                                  
 15324                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 15325                                  
 15326                                  ;---------------------------------------------------------------------------
 15327                                  ; Procedure Name : GET_FILE_INFO
 15328                                  ;
 15329                                  ; Inputs:
 15330                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15331                                  ;		terminated)
 15332                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15333                                  ;		( = -1 if current dir not involved, else
 15334                                  ;		 Points to first char after last "/" of current dir part)
 15335                                  ;	[THISCDS] Points to CDS being used
 15336                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15337                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15338                                  ; Function:
 15339                                  ;	Get Information about a file
 15340                                  ; Returns:
 15341                                  ;	CARRY CLEAR
 15342                                  ;	    AX = Attribute of file
 15343                                  ;	    CX = Time stamp of file
 15344                                  ;	    DX = Date stamp of file
 15345                                  ;	    BX:DI = Size of file (32 bit)
 15346                                  ;	CARRY SET
 15347                                  ;	    AX is error code
 15348                                  ;		error_file_not_found
 15349                                  ;			Last element of path not found
 15350                                  ;		error_path_not_found
 15351                                  ;			Bad path (not in curr dir part if present)
 15352                                  ;		error_bad_curr_dir
 15353                                  ;			Bad path in current directory part of path
 15354                                  ; DS preserved, others destroyed
 15355                                  ;---------------------------------------------------------------------------
 15356                                  
 15357                                  GET_FILE_INFO:
 15358                                  
 15359                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 15360                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 15361                                  
 15362 000035EB E8D7E9                  	call	TestNet
 15363 000035EE 7306                    	JNC	short LOCAL_INFO
 15364                                  
 15365                                  ;IF NOT Installed
 15366                                  ;	transfer NET_GET_FILE_INFO
 15367                                  ;ELSE
 15368                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 15369                                  ;	INT	2FH
 15370                                  ;	return
 15371                                  
 15372 000035F0 B80F11                  	mov     ax, 110Fh
 15373 000035F3 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 15374                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 15375                                  			; SDA CDS pointer -> current directory
 15376                                  			; Return: CF set on error, AX = file attributes
 15377 000035F5 C3                      	retn
 15378                                  ;ENDIF
 15379                                  
 15380                                  LOCAL_INFO:
 15381 000035F6 E86AEA                  	call	EcritDisk
 15382 000035F9 C606[F802]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 15383                                  	; MSDOS 6.0
 15384                                  	;call	Get_FAST_PATH
 15385                                  	; MSDOS 3.3
 15386 000035FE E83312                  	call	GETPATH
 15387                                  info_check:
 15388 00003601 7313                    	JNC	short info_check_dev
 15389                                  NO_PATH:
 15390 00003603 750C                    	JNZ	short bad_path1
 15391 00003605 08C9                    	OR	CL,CL
 15392 00003607 7408                    	JZ	short bad_path1
 15393                                  info_no_file:
 15394 00003609 B80200                  	MOV	AX,error_file_not_found
 15395                                  BadRet:
 15396 0000360C F9                      	STC
 15397                                  JustRet:
 15398 0000360D E85BEA                  	call	LcritDisk
 15399 00003610 C3                      	retn
 15400                                  
 15401                                  bad_path1:
 15402 00003611 B80300                  	MOV	AX,error_path_not_found
 15403 00003614 EBF6                    	jmp	short BadRet
 15404                                  
 15405                                  info_check_dev:
 15406 00003616 08E4                    	OR	AH,AH
 15407 00003618 78EF                    	JS	short info_no_file	; device
 15408                                  
 15409                                  	; MSDOS 6.0
 15410                                  ;SR;
 15411                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 15412                                  ;for a root dir
 15413                                  ;
 15414 0000361A 833E[7405]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 15415 0000361F 7507                    	jne	short not_root		;no, CurBuf ptr is valid
 15416                                  
 15417 00003621 30E4                    	xor	ah,ah
 15418 00003623 B010                    	mov	al,attr_directory
 15419 00003625 F8                      	clc
 15420 00003626 EBE5                    	jmp	short JustRet
 15421                                  
 15422                                  not_root:
 15423                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15424 00003628 1E                      	PUSH	DS
 15425 00003629 8E1E[7605]              	MOV	DS,[CURBUF+2]
 15426 0000362D 89DE                    	MOV	SI,BX
 15427 0000362F 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 15428 00003631 89DF                    	MOV	DI,BX
 15429 00003633 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 15430 00003636 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 15431 00003639 30E4                    	XOR	AH,AH
 15432 0000363B 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 15433 0000363E A810                    	TEST	AL,attr_directory
 15434 00003640 7506                    	JNZ	short NO_SIZE
 15435 00003642 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 15436 00003645 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 15437                                  NO_SIZE:
 15438 00003648 1F                      	POP	DS
 15439 00003649 F8                      	CLC
 15440 0000364A EBC1                    	jmp	short JustRet
 15441                                  
 15442                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 15443                                  ;-------------------------------------------------------------------------------
 15444                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 15445                                  ; Inputs:
 15446                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15447                                  ;		terminated)
 15448                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15449                                  ;		( = -1 if current dir not involved, else
 15450                                  ;		 Points to first char after last "/" of current dir part)
 15451                                  ;	[THISCDS] Points to CDS being used
 15452                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15453                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 15454                                  ;	AX is new attributes to give to file
 15455                                  ; Function:
 15456                                  ;	Set File Attributes
 15457                                  ; Returns:
 15458                                  ;	CARRY CLEAR
 15459                                  ;	    No error
 15460                                  ;	CARRY SET
 15461                                  ;	    AX is error code
 15462                                  ;		error_file_not_found
 15463                                  ;			Last element of path not found
 15464                                  ;		error_path_not_found
 15465                                  ;			Bad path (not in curr dir part if present)
 15466                                  ;		error_bad_curr_dir
 15467                                  ;			Bad path in current directory part of path
 15468                                  ;		error_access_denied
 15469                                  ;			Attempt to set an attribute which cannot be set
 15470                                  ;			(attr_directory, attr_volume_ID)
 15471                                  ;		error_sharing_violation
 15472                                  ;			Sharing mode of file did not allow the change
 15473                                  ;			(this request requires exclusive write/read access)
 15474                                  ;			(INT 24H generated)
 15475                                  ; DS preserved, others destroyed
 15476                                  ;----------------------------------------------------------------------------
 15477                                  
 15478                                  SET_FILE_ATTRIBUTE:
 15479                                  
 15480                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 15481                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 15482                                  
 15483 0000364C A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 15484 0000364F 7414                    	JZ	short set_look
 15485                                  _BAD_ACC:
 15486 00003651 C606[D102]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk
 15487 00003656 C606[D502]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr
 15488 0000365B C606[D402]04            	MOV	byte [EXTERR_ACTION],errACT_Abort
 15489 00003660 B80500                  	MOV	AX,error_access_denied
 15490 00003663 F9                      	STC
 15491 00003664 C3                      	retn
 15492                                  
 15493                                  set_look:
 15494 00003665 E85DE9                  	call	TestNet
 15495 00003668 7308                    	JNC	short LOCAL_SET
 15496                                  
 15497                                  ;IF NOT Installed
 15498                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 15499                                  ;ELSE
 15500 0000366A 50                      	PUSH	AX
 15501                                  	
 15502                                  	;MOV	AX,(MultNET SHL 8) OR 14
 15503                                  	;INT	2FH
 15504                                  
 15505 0000366B B80E11                  	mov     ax, 110Eh
 15506 0000366E CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 15507                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 15508                                  			; SDA CDS pointer -> current directory
 15509                                  			; STACK: WORD new file attributes
 15510                                  			; Return: CF set on error
 15511                                  
 15512 00003670 5B                      	POP	BX			; clean stack
 15513 00003671 C3                      	retn
 15514                                  ;ENDIF
 15515                                  
 15516                                  LOCAL_SET:
 15517 00003672 E8EEE9                  	call	EcritDisk
 15518 00003675 50                      	PUSH	AX			; Save new attributes
 15519 00003676 C606[F802]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 15520 0000367B E8B611                  	call	GETPATH 		; get path through fastopen if there	 ;AC000;
 15521 0000367E 7303                    	JNC	short set_check_device
 15522 00003680 5B                      	POP	BX			; Clean stack (don't zap AX)
 15523 00003681 EB80                    	JMP	short NO_PATH
 15524                                  
 15525                                  set_check_device:
 15526 00003683 08E4                    	OR	AH,AH
 15527 00003685 7906                    	JNS	short set_check_share
 15528 00003687 58                      	POP	AX
 15529 00003688 E8E0E9                  	call	LcritDisk
 15530 0000368B EBC4                    	JMP	short _BAD_ACC 		; device
 15531                                  
 15532                                  set_check_share:
 15533 0000368D 58                      	POP	AX			; Get new attributes
 15534                                  
 15535                                  	; MSDOS 6.0
 15536 0000368E 833E[7405]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 15537 00003693 740A                    	je	short cannot_set_root	; M025: Y: return error
 15538                                  
 15539                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15540 00003695 E8F6FC                  	call	REN_DEL_Check
 15541 00003698 730B                    	JNC	short set_do
 15542 0000369A B82000                  	MOV	AX,error_sharing_violation
 15543 0000369D EB30                    	jmp	short OK_BYE
 15544                                  
 15545                                  	; MSDOS 6.0
 15546                                  cannot_set_root:			; M025:
 15547 0000369F B80500                  	mov	ax, error_access_denied	; M025: return error is attempting
 15548 000036A2 F9                      	stc				; M025: to set attr. of root
 15549 000036A3 EB2A                    	jmp	short OK_BYE		; M025:
 15550                                  
 15551                                  set_do:
 15552                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15553 000036A5 C43E[7405]              	LES	DI,[CURBUF]
 15554 000036A9 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 15555 000036AE 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 15556                                  
 15557                                  	; MSDOS 6.0
 15558                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 15559                                  	;				;LB. if already dirty		  ;AN000;
 15560                                  	;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 15561                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 15562                                  	
 15563 000036B2 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 15564                                  ;yesdirty3:
 15565 000036B7 A0[1105]                	MOV	AL,[THISDRV]
 15566                                  ;;;; 10/1/86 F.C update fastopen cache
 15567 000036BA 52                      	PUSH	DX
 15568 000036BB 57                      	PUSH	DI
 15569 000036BC B400                    	MOV	AH,0		  ; dir entry update
 15570 000036BE 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 15571 000036C0 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 15572 000036C2 E846FD                  	call	FastOpen_Update
 15573 000036C5 5F                      	POP	DI
 15574 000036C6 5A                      	POP	DX
 15575                                  ;;;; 9/11/86 F.C update fastopen cache
 15576 000036C7 E86628                  	call	FLUSHBUF
 15577 000036CA 7303                    	JNC	short OK_BYE
 15578 000036CC B80200                  	MOV	AX,error_file_not_found
 15579                                  OK_BYE:
 15580 000036CF E899E9                  	call	LcritDisk
 15581 000036D2 C3                      	retn
 15582                                  
 15583                                  	; MSDOS 6.0
 15584                                  ;GET_FAST_PATH:
 15585                                  ;hkn; use SS override for FastOpenFlg
 15586                                  	;OR	byte [FastOpenFlg],FastOpen_Set
 15587                                  	;				;FO. trigger fastopen	;AN000;
 15588                                  	;call	GETPATH
 15589                                  	;PUSHF			 	;FO.			;AN000;
 15590                                  	;AND	byte [FastOpenFlg],Fast_yes 
 15591                                  	;				;FO. clear all fastopen flags ;AN000;
 15592                                  	;POPF				;FO.			;AN000;
 15593                                  	;retn
 15594                                  
 15595                                  ;============================================================================
 15596                                  ; DUP.ASM, MSDOS 6.0, 1991
 15597                                  ;============================================================================
 15598                                  ; 08/08/2018 - Retro DOS v3.0
 15599                                  
 15600                                  ;**	Low level DUP routine for use by EXEC when creating a new process. Exports
 15601                                  ;	  the DUP to the server machine and increments the SFT ref count
 15602                                  ;
 15603                                  ;	DOS_DUP
 15604                                  ;
 15605                                  ;	Modification history:
 15606                                  ;
 15607                                  ;	  Created: ARR 30 March 1983
 15608                                  
 15609                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 15610                                  ;---------------------------------------------------------------------------
 15611                                  ; Procedure Name : DOS_DUP
 15612                                  ;
 15613                                  ; Inputs:
 15614                                  ;	[THISSFT] set to the SFT for the file being DUPed
 15615                                  ;		(a non net SFT is OK, in this case the ref
 15616                                  ;		 count is simply incremented)
 15617                                  ; Function:
 15618                                  ;	Signal to the devices that a logical open is occurring
 15619                                  ; Returns:
 15620                                  ;	ES:DI point to SFT
 15621                                  ;    Carry clear
 15622                                  ;	SFT ref_count is incremented
 15623                                  ; Registers modified: None.
 15624                                  ; NOTE:
 15625                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 15626                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 15627                                  ;	that time.
 15628                                  ;---------------------------------------------------------------------------
 15629                                  
 15630                                  DOS_DUP:
 15631 000036D3 2EC43E[3605]            	LES	DI,[CS:THISSFT]
 15632                                  
 15633                                  	;Entry	Dos_Dup_Direct
 15634                                  DOS_Dup_Direct:
 15635 000036D8 E8FFE8                  	call	IsSFTNet
 15636 000036DB 7503                    	JNZ	short DO_INC
 15637 000036DD E89817                  	call	DEV_OPEN_SFT
 15638                                  DO_INC:
 15639                                  
 15640                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 15641 000036E0 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 15642                                  					;   we're in big trouble anyway)
 15643 000036E3 C3                      	retn
 15644                                  
 15645                                  ;============================================================================
 15646                                  ; CREATE.ASM, MSDOS 6.0, 1991
 15647                                  ;============================================================================
 15648                                  ; 08/08/2018 - Retro DOS v3.0
 15649                                  
 15650                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 15651                                  ;NAME	DOS_CREATE
 15652                                  
 15653                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 15654                                  ;
 15655                                  ;	DOS_CREATE
 15656                                  ;	DOS_CREATE_NEW
 15657                                  ;	SET_MKND_ERR
 15658                                  ;	SET_Media_ID
 15659                                  ;	SET_EXT_Mode
 15660                                  ;
 15661                                  ;	Revision history:
 15662                                  ;
 15663                                  ;	    A000 version 4.00	  Jan. 1988
 15664                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 15665                                  
 15666                                  ;Installed = TRUE
 15667                                  
 15668                                  ;	i_need	THISSFT,DWORD
 15669                                  ;	i_need	THISCDS,DWORD
 15670                                  ;	I_need	EXTERR,WORD
 15671                                  ;	I_Need	ExtErr_locus,BYTE
 15672                                  ;	I_need	JShare,DWORD
 15673                                  ;	I_need	VOLCHNG_FLAG,BYTE
 15674                                  ;	I_need	SATTRIB,BYTE
 15675                                  ;	I_need	CALLVIDM,DWORD
 15676                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 15677                                  ;	I_need	NAME1,BYTE			  ;AN000;
 15678                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 15679                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 15680                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 15681                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 15682                                  
 15683                                  ;***	DOS_CREATE - Create a File
 15684                                  ;----------------------------------------------------------------------------
 15685                                  ;	DOS_Create is called to create the specified file, truncating
 15686                                  ;	the old one if it exists.
 15687                                  ;
 15688                                  ;
 15689                                  ;	ENTRY	AX is Attribute to create
 15690                                  ;		(ds) = DOSDATA
 15691                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15692                                  ;			terminated)
 15693                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 15694                                  ;			( = -1 if current dir not involved, else
 15695                                  ;			 Points to first char after last "/" of current dir part)
 15696                                  ;		[THISCDS] Points to CDS being used
 15697                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 15698                                  ;		[THISSFT] Points to SFT to fill in if file created
 15699                                  ;			(sf_mode field set so that FCB may be detected)
 15700                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 15701                                  ;
 15702                                  ;	EXIT	sf_ref_count is NOT altered
 15703                                  ;		CARRY CLEAR
 15704                                  ;		    THISSFT filled in.
 15705                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 15706                                  ;		CARRY SET
 15707                                  ;		    AX is error code
 15708                                  ;			error_path_not_found
 15709                                  ;				Bad path (not in curr dir part if present)
 15710                                  ;			error_bad_curr_dir
 15711                                  ;				Bad path in current directory part of path
 15712                                  ;			error_access_denied
 15713                                  ;				Attempt to re-create read only file , or
 15714                                  ;				create a second volume id or create a dir
 15715                                  ;			error_sharing_violation
 15716                                  ;				The sharing mode was correct but not allowed
 15717                                  ;				generates an INT 24
 15718                                  ;	USES	all but DS
 15719                                  ;----------------------------------------------------------------------------
 15720                                  
 15721                                  DOS_CREATE:
 15722                                  
 15723                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 15724                                  ;hkn; this point.
 15725                                  
 15726 000036E4 30E4                    	XOR	AH,AH		; Truncate is OK
 15727                                  
 15728                                  ;	Enter here from Dos_Create_New
 15729                                  ;
 15730                                  ;	(ah) = 0 iff truncate OK
 15731                                  
 15732                                  Create_inter:
 15733 000036E6 A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 15734                                  				; Mask out any meaningless bits
 15735 000036E8 750C                    	JNZ	short AttErr
 15736 000036EA A808                    	TEST	AL,attr_volume_id
 15737 000036EC 7402                    	JZ	short NoReset
 15738                                  	;
 15739                                  	; MSDOS 6.0
 15740                                  	;OR	[DOS34_FLAG],DBCS_VOLID      ;AN000;FOR dbcs volid
 15741                                  	;
 15742 000036EE B008                    	MOV	AL,attr_volume_id
 15743                                  NoReset:
 15744 000036F0 0C20                    	OR	AL,attr_archive ; File changed
 15745 000036F2 A850                    	TEST	AL,attr_directory+attr_device
 15746 000036F4 740A                    	JZ	short ATT_OK
 15747                                  AttErr:
 15748 000036F6 B80500                  	MOV	AX,5		; Attribute problem
 15749 000036F9 C606[D102]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk
 15750 000036FE EB3D                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 15751                                  				   ;	attr_device to be set.
 15752                                  ATT_OK:
 15753 00003700 C43E[3605]              	LES	DI,[THISSFT]
 15754 00003704 06                      	PUSH	ES
 15755 00003705 C436[3A05]              	LES	SI,[THISCDS]
 15756 00003709 83FEFF                  	CMP	SI,-1
 15757 0000370C 7509                    	JNE	short TEST_RE_NET
 15758                                  
 15759                                  ;	No CDS, it must be redirected.
 15760                                  
 15761 0000370E 07                      	POP	ES
 15762                                  
 15763                                  	; MSDOS 6.0
 15764                                  ;Extended open hooks
 15765                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
 15766                                  	;JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 15767                                  ;IFS_extopen:				    ;AN000;EO.
 15768                                  	;PUSH	AX			    ;AN000;EO. pass create attr
 15769                                  	;;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 15770                                  	;mov	ax,112Eh
 15771                                  	;INT	2FH			    ;AN000;EO.
 15772                                  	;POP	BX			    ;AN000;EO. trash bx
 15773                                  	;MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 15774                                  	;retn				    ;AN000;EO.
 15775                                  ;NOEXTOP:				    ;AN000;
 15776                                  ;Extended open hooks
 15777                                  
 15778                                  ;IF NOT Installed
 15779                                  ;	transfer NET_SEQ_CREATE
 15780                                  ;ELSE
 15781 0000370F 50                      	PUSH	AX
 15782                                  
 15783                                  	;MOV	AX,(MultNET SHL 8) OR 24
 15784                                  	;INT	2FH
 15785                                  
 15786 00003710 B81811                  	mov     ax,1118h
 15787 00003713 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 15788                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 15789                                  			; SDA first filename pointer -> fully-qualified name of file
 15790                                  			; STACK: WORD file creation mode???
 15791                                  
 15792 00003715 5B                      	POP	BX			; BX is trashed anyway
 15793 00003716 C3                      	retn
 15794                                  ;ENDIF
 15795                                  
 15796                                  ;	We have a CDS. See if it's network
 15797                                  
 15798                                  TEST_RE_NET:
 15799 00003717 26F744430080            	TEST	word [ES:SI+curdir.flags],curdir_isnet
 15800 0000371D 07                      	POP	ES
 15801 0000371E 7408                    	JZ	short LOCAL_CREATE
 15802                                  
 15803                                  	; MSDOS 6.0
 15804                                  	;CALL	Set_EXT_mode		    ;AN000;EO.
 15805                                  	;JC	SHORT dochk		    ;AN000;EO.
 15806                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 15807                                  
 15808                                  ;Extended open hooks
 15809                                  ;dochk:
 15810                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
 15811                                  	;JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 15812                                  ;Extended open hooks
 15813                                  
 15814                                  ;IF NOT Installed
 15815                                  ;	transfer NET_CREATE
 15816                                  ;ELSE
 15817 00003720 50                      	PUSH	AX
 15818                                  	
 15819                                  	;MOV	AX,(MultNET SHL 8) OR 23
 15820                                  	;INT	2FH
 15821                                  	
 15822 00003721 B81711                  	mov     ax, 1117h
 15823 00003724 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 15824                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 15825                                  			; SDA first filename pointer -> fully-qualified name of file to open
 15826                                  			; SDA CDS pointer -> current directory
 15827                                  			; Return: CF set on error
 15828                                  
 15829 00003726 5B                      	POP	BX			; BX is trashed anyway
 15830                                  ;nomore:
 15831 00003727 C3                      	retn
 15832                                  ;ENDIF
 15833                                  
 15834                                  
 15835                                  ;**	It's a local create.  We have a local CDS for it.
 15836                                  
 15837                                  LOCAL_CREATE:
 15838                                  	; MSDOS 6.0
 15839                                  	;CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 15840                                  	;JC	short setdone	;AN000;EO.
 15841                                  	
 15842                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15843 00003728 26834D0202              	OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 15844                                  ;setdone:
 15845 0000372D E833E9                  	call	EcritDisk
 15846 00003730 E8FC18                  	call	MakeNode
 15847 00003733 730E                    	JNC	short Create_ok
 15848 00003735 C606[070A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 15849 0000373A E82EE9                  	call	LcritDisk
 15850                                  
 15851                                  	;entry	SET_MKND_ERR
 15852                                  SET_MKND_ERR:
 15853                                  
 15854                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 15855                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 15856                                  
 15857                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 15858 0000373D BB[FD12]                	MOV     BX,CRTERRTAB
 15859 00003740 D7                      	XLAT
 15860                                  	;XLAT	byte [CS:BX]
 15861                                  CreatBadRet:
 15862 00003741 F9                      	STC
 15863 00003742 C3                      	retn
 15864                                  
 15865                                  ; We have just created a new file. This results in the truncation of old
 15866                                  ; files. We must inform the sharer to slash all the open SFT's for this
 15867                                  ; file to the current size.
 15868                                  
 15869                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 15870                                  ; drive number to force a Build BPB after Media Check.
 15871                                  
 15872                                  ;;; FASTOPEN 8/29/86
 15873                                  Create_ok:
 15874 00003743 E8B1FC                  	call	FastOpen_Delete
 15875                                  ;;; FASTOPEN 8/29/86
 15876 00003746 A0[0805]                	mov	al,[SATTRIB]
 15877 00003749 A808                    	test	al,attr_volume_id
 15878 0000374B 7417                    	jz	short NoVolLabel
 15879 0000374D C43E[3A05]              	LES	DI,[THISCDS]
 15880                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 15881 00003751 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 15882 00003754 80EC41                  	sub	ah,'A'                  ; convert to drive letter
 15883 00003757 8826[070A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 15884                                  	
 15885                                  	; MSDOS 6.0
 15886                                  	;MOV	BH,1			;AN000;>32mb set volume id to boot record
 15887                                  	;CALL	Set_Media_ID		;AN000;>32mb
 15888                                  	
 15889 0000375B E805E9                  	call	EcritDisk
 15890 0000375E E85D24                  	call	FATREAD_CDS		; force a media check
 15891 00003761 E807E9                  	call	LcritDisk
 15892                                  
 15893                                  NoVolLabel:
 15894 00003764 B80200                  	MOV	ax,2
 15895 00003767 C43E[3605]              	LES	DI,[THISSFT]
 15896                                  ;if installed
 15897                                  	;call	JShare + 14 * 4
 15898 0000376B FF1E[9400]              	call	far [JShare+(14*4)] ; 14 = ShSU
 15899                                  ;else
 15900                                  ;	Call	ShSU
 15901                                  ;endif
 15902 0000376F E8F9E8                  	call	LcritDisk
 15903 00003772 E9D800                  	jmp	SET_SFT_MODE
 15904                                  
 15905                                  ;---------------------------------------------------------------------------
 15906                                  ; Procedure Name : Dos_Create_New
 15907                                  ;
 15908                                  ; Inputs:
 15909                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15910                                  ;		terminated)
 15911                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15912                                  ;		( = -1 if current dir not involved, else
 15913                                  ;		 Points to first char after last "/" of current dir part)
 15914                                  ;	[THISCDS] Points to CDS being used
 15915                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15916                                  ;	[THISSFT] Points to SFT to fill in if file created
 15917                                  ;		(sf_mode field set so that FCB may be detected)
 15918                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15919                                  ;	AX is Attribute to create
 15920                                  ; Function:
 15921                                  ;	Try to create the specified file truncating an old one that exists
 15922                                  ; Outputs:
 15923                                  ;	sf_ref_count is NOT altered
 15924                                  ;	CARRY CLEAR
 15925                                  ;	    THISSFT filled in.
 15926                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 15927                                  ;	CARRY SET
 15928                                  ;	    AX is error code
 15929                                  ;		error_path_not_found
 15930                                  ;			Bad path (not in curr dir part if present)
 15931                                  ;		error_bad_curr_dir
 15932                                  ;			Bad path in current directory part of path
 15933                                  ;		error_access_denied
 15934                                  ;			Create a second volume id or create a dir
 15935                                  ;		error_file_exists
 15936                                  ;			Already a file by this name
 15937                                  ; DS preserved, others destroyed
 15938                                  ;---------------------------------------------------------------------------
 15939                                  
 15940                                  DOS_Create_New:
 15941 00003775 B401                    	MOV	AH,1		; Truncate is NOT OK
 15942 00003777 E96CFF                  	JMP	Create_inter
 15943                                  
 15944                                  ; MSDOS 6.0
 15945                                  ;---------------------------------------------------------------------------
 15946                                  ; Procedure Name : Set_Media_ID
 15947                                  ;
 15948                                  ; Inputs:
 15949                                  ;	NAME1= Volume ID
 15950                                  ;	BH= 0, delete volume id
 15951                                  ;	    1, set new volume id
 15952                                  ;	DS= DOSGROUP
 15953                                  ; Function:
 15954                                  ;	Set Volume ID to DOS 4.00 Boot record.
 15955                                  ; Outputs:
 15956                                  ;	CARRY CLEAR
 15957                                  ;	    volume id set
 15958                                  ;	CARRY SET
 15959                                  ;	    AX is error code
 15960                                  ;---------------------------------------------------------------------------
 15961                                  ;
 15962                                  ;procedure   Set_Media_ID,NEAR
 15963                                  ;	DOSAssume   <DS>,"SetMedID"
 15964                                  ;
 15965                                  ;	PUSH	AX		;AN000;;>32mb
 15966                                  ;	PUSH	ES		;AN000;;>32mb
 15967                                  ;	PUSH	DI		;AN000;;>32mb
 15968                                  ;
 15969                                  ;	INC	AH		;AN000;;>32mb  bl=drive #
 15970                                  ;	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 15971                                  ;	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 15972                                  ;	MOV	CX,0866H	;AN001;;>32mb  get media id
 15973                                  ;
 15974                                  ;hkn; PACKET_TEMP is in DOSDATA
 15975                                  ;	MOV	DX,OFFSET DOSDATA:PACKET_TEMP	;AN000;>32mb
 15976                                  ;
 15977                                  ;	PUSH	BX		;AN000;;>32mb
 15978                                  ;	PUSH	DX		;AN000;;>32mb
 15979                                  ;	XOR	BH,BH		;AN000;;>32mb
 15980                                  ;
 15981                                  ;	invoke	$IOCTL		;AN000;;>32mb
 15982                                  ;	POP	DX		;AN000;;>32mb
 15983                                  ;	POP	BX		;AN000;;>32mb
 15984                                  ;	JC	geterr		;AN000;;>32mb
 15985                                  ;
 15986                                  ;	OR	BH,BH		;AN000;;>32mb delete volume id
 15987                                  ;	JZ	NoName		;AN000;>32mb yes
 15988                                  ;
 15989                                  ;hkn; NAME1 is in DOSDATA
 15990                                  ;	MOV	SI,OFFSET DOSDATA:NAME1   ;AN000;>32mb
 15991                                  ;
 15992                                  ;	JMP	SHORT doset	;AN000;>32mb yes
 15993                                  ;Noname: 			;AN000;
 15994                                  ;
 15995                                  ;hkn; NO_NAME_ID is in DOSDATA
 15996                                  ;	MOV	SI,OFFSET DOSDATA:NO_NAME_ID  ;AN000;>32mb
 15997                                  ;
 15998                                  ;doset:					       ;AN000;
 15999                                  ;	MOV	DI,DX		;AN000;;>32mb
 16000                                  ;	ADD	DI,MEDIA_LABEL	;AN000;;>32mb
 16001                                  ;
 16002                                  ;hkn; ES & DS must point to SS
 16003                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 16004                                  ;	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 16005                                  ;
 16006                                  ;	POP	DS		;AN000;;>32mb
 16007                                  ;
 16008                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 16009                                  ;	PUSH	SS		;AN000;;>32mb
 16010                                  ;
 16011                                  ;	POP	ES		;AN000;;>32mb
 16012                                  ;	MOV	CX,11		;AN000;;>32mb
 16013                                  ;	REP	MOVSB		;AN000;;>32mb
 16014                                  ;	MOV	CX,0846H	;AN001;;>32mb
 16015                                  ;	MOV	AL,0DH		;AN000;;>32mb
 16016                                  ;	XOR	BH,BH		;AN000;;>32mb
 16017                                  ;	invoke	$IOCTL		;AN000;;>32mb  set volume id
 16018                                  ;geterr: 			;AN000;
 16019                                  ;
 16020                                  ;hkn;	PUSH	CS		;AN000;>32mb
 16021                                  ;	PUSH	SS		;AN000;>32mb
 16022                                  ;
 16023                                  ;	POP	DS		;AN000;>32mb   ds= dosgroup
 16024                                  ;
 16025                                  ;	POP	DI		;AN000;;>32mb
 16026                                  ;	POP	ES		;AN000;;>32mb
 16027                                  ;	POP	AX		;AN000;;>32mb
 16028                                  ;	return			;AN000;>32mb
 16029                                  ;
 16030                                  ;EndProc Set_Media_ID		;AN000;
 16031                                  
 16032                                  ; MSDOS 6.0
 16033                                  ;---------------------------------------------------------------------------
 16034                                  ; Procedure Name : Set_EXT_mode
 16035                                  ;
 16036                                  ; Inputs:
 16037                                  ;	[EXTOPEN_ON]= flag for extended open
 16038                                  ;	SAVE_BX= mode specified in Extended Open
 16039                                  ; Function:
 16040                                  ;	Set mode in ThisSFT
 16041                                  ; Outputs:
 16042                                  ;	carry set,mode is set if from Extended Open
 16043                                  ;	carry clear, mode not set yet
 16044                                  ;---------------------------------------------------------------------------
 16045                                  ;
 16046                                  ;procedure   Set_EXT_mode,NEAR
 16047                                  ;
 16048                                  ;hkn; SS override
 16049                                  ;	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extended open
 16050                                  ;	JZ	NOTEX			    ;AN000;EO. no, do normal
 16051                                  ;	PUSH	AX			    ;AN000;EO.
 16052                                  ;
 16053                                  ;hkn; SS override
 16054                                  ;	MOV	AX,[SAVE_BX]		    ;AN000;EO.
 16055                                  ;	OR	ES:[DI.sf_mode],AX	    ;AN000;EO.
 16056                                  ;	POP	AX			    ;AN000;EO.
 16057                                  ;	STC				    ;AN000;EO.
 16058                                  ;NOTEX:					    ;AN000;
 16059                                  ;	return				    ;AN000;EO.
 16060                                  ;
 16061                                  ;EndProc Set_EXT_mode			    ;AN000;
 16062                                  
 16063                                  ;============================================================================
 16064                                  ; OPEN.ASM, MSDOS 6.0, 1991
 16065                                  ;============================================================================
 16066                                  ; 08/08/2018 - Retro DOS v3.0
 16067                                  
 16068                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 16069                                  ;	NAME	DOS_OPEN
 16070                                  
 16071                                  ;**	OPEN.ASM - File Open
 16072                                  ;----------------------------------------------------------------------------
 16073                                  ;	Low level routines for openning a file from a file spec.
 16074                                  ;	Also misc routines for sharing errors
 16075                                  ;
 16076                                  ;	DOS_Open
 16077                                  ;	Check_Access_AX
 16078                                  ;	SHARE_ERROR
 16079                                  ;	SET_SFT_MODE
 16080                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 16081                                  ;
 16082                                  ;	Revision history:
 16083                                  ;
 16084                                  ;	    Created: ARR 30 March 1983
 16085                                  ;	    A000	version 4.00   Jan. 1988
 16086                                  ;
 16087                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 16088                                  ; 	       remote extended opens and not save_cx.
 16089                                  ;
 16090                                  ;	M035 - if open made from exec then we must set the appropriate bits
 16091                                  ;	       on the stack before calling off to the redir.
 16092                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 16093                                  ;	       to handle open from exec. In this case set the appropriate bit
 16094                                  ;	       else do not.
 16095                                  ;----------------------------------------------------------------------------	
 16096                                  
 16097                                  ;Installed = TRUE
 16098                                  
 16099                                  ;	i_need	NoSetDir,BYTE
 16100                                  ;	i_need	THISSFT,DWORD
 16101                                  ;	i_need	THISCDS,DWORD
 16102                                  ;	i_need	CURBUF,DWORD
 16103                                  ;	i_need	CurrentPDB,WORD
 16104                                  ;	i_need	CURR_DIR_END,WORD
 16105                                  ;	I_need	RetryCount,WORD
 16106                                  ;	I_need	Open_Access,BYTE
 16107                                  ;	I_need	fSharing,BYTE
 16108                                  ;	i_need	JShare,DWORD
 16109                                  ;	I_need	FastOpenFlg,byte
 16110                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 16111                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 16112                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 16113                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 16114                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 16115                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 16116                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 16117                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 16118                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 16119                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 16120                                  ;	I_need	SAVE_BX,WORD			  ;M034
 16121                                  ;
 16122                                  ;	I_need	DOS_FLAG,BYTE
 16123                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 16124                                  
 16125                                  ;Break	<DOS_Open - internal file access>
 16126                                  ;---------------------------------------------------------------------------
 16127                                  ; Procedure Name : DOS_Open
 16128                                  ;
 16129                                  ; Inputs:
 16130                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16131                                  ;		terminated)
 16132                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16133                                  ;		( = -1 if current dir not involved, else
 16134                                  ;		 Points to first char after last "/" of current dir part)
 16135                                  ;	[THISCDS] Points to CDS being used
 16136                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16137                                  ;	[THISSFT] Points to SFT to fill in if file found
 16138                                  ;		(sf_mode field set so that FCB may be detected)
 16139                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16140                                  ;	AX is Access and Sharing mode
 16141                                  ;	  High NIBBLE of AL (Sharing Mode)
 16142                                  ;		sharing_compat	   file is opened in compatibility mode
 16143                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 16144                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 16145                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 16146                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 16147                                  ;	  Low NIBBLE of AL (Access Mode)
 16148                                  ;		open_for_read	file is opened for reading
 16149                                  ;		open_for_write	file is opened for writing
 16150                                  ;		open_for_both	file is opened for both reading and writing.
 16151                                  ;
 16152                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 16153                                  ;		(not checked)
 16154                                  ; Function:
 16155                                  ;	Try to open the specified file
 16156                                  ; Outputs:
 16157                                  ;	sf_ref_count is NOT altered
 16158                                  ;	CARRY CLEAR
 16159                                  ;	    THISSFT filled in.
 16160                                  ;	CARRY SET
 16161                                  ;	    AX is error code
 16162                                  ;		error_file_not_found
 16163                                  ;			Last element of path not found
 16164                                  ;		error_path_not_found
 16165                                  ;			Bad path (not in curr dir part if present)
 16166                                  ;		error_bad_curr_dir
 16167                                  ;			Bad path in current directory part of path
 16168                                  ;		error_invalid_access
 16169                                  ;			Bad sharing mode or bad access mode or bad combination
 16170                                  ;		error_access_denied
 16171                                  ;			Attempt to open read only file for writting, or
 16172                                  ;			open a directory
 16173                                  ;		error_sharing_violation
 16174                                  ;			The sharing mode was correct but not allowed
 16175                                  ;			generates an INT 24 on compatibility mode SFTs
 16176                                  ; DS preserved, others destroyed
 16177                                  ;----------------------------------------------------------------------------
 16178                                  
 16179                                  DOS_OPEN:
 16180                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 16181                                  
 16182 0000377A C606[F802]00            	MOV	byte [NoSetDir],0
 16183 0000377F E80001                  	CALL	Check_Access_AX
 16184 00003782 721C                    	JC	short do_ret_label		    ; retc
 16185                                  
 16186 00003784 C43E[3605]              	LES	DI,[THISSFT]
 16187 00003788 30E4                    	XOR	AH,AH
 16188                                  
 16189                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 16190                                  
 16191 0000378A 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 16192 0000378E 06                      	PUSH	ES
 16193 0000378F C436[3A05]              	LES	SI,[THISCDS]
 16194                                  	; 18/08/2018
 16195 00003793 83FEFF                  	CMP	SI,-1
 16196 00003796 7509                    	JNZ	short TEST_RE_NET1
 16197 00003798 07                      	POP	ES
 16198                                  
 16199                                  	; MSDOS 6.0
 16200                                  ;Extended open hooks
 16201                                  	;TEST	byte [EXTOPEN_ON],ext_open_on	;FT. from extnded open		;AN000;
 16202                                  	;JZ	short NOEXTOP 		    ;FT. no, do normal			;AN000;
 16203                                  IFS_extopen:									;AN000;
 16204                                  	;MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 16205                                  	;				    ; with which call was made. This
 16206                                  	;				    ; has the open access bits. 
 16207                                  	;;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 16208                                  	;
 16209                                  	;PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 16210                                  	;;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 16211                                  	;mov	ax,(MultNET*256)+46 
 16212                                  	;INT	2FH			    ;FT.				;AN000;
 16213                                  	;POP	BX			    ;FT. trash bx			;AN000;
 16214                                  	;MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 16215                                  
 16216                                  ;do_ret_label:
 16217                                  	;retn				    ;FT.				;AN000;
 16218                                  ;NOEXTOP:
 16219                                  ;Extended open hooks
 16220                                  	;
 16221                                  ;IF NOT Installed
 16222                                  	;transfer NET_SEQ_OPEN
 16223                                  ;ELSE
 16224                                  	;
 16225                                  do_net_int2f:
 16226                                  	;
 16227                                  	;test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 16228                                  	;jz	short not_exec_open	; N: just do net open
 16229                                  	;				; Y: check to see if redir is aware
 16230                                  	;				;    of this 
 16231                                  	;
 16232                                  	;				; M042 - start
 16233                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR
 16234                                  	;				; Q: does this redir know how to 
 16235                                  	;				;    this
 16236                                  	;jz	short not_exec_open	; N: just do net open
 16237                                  	;				; Y: set bit 3 of access byte and 
 16238                                  	;				;    set sharing mode to DENY_WRITE
 16239                                  	;				; M042 - end
 16240                                  	;
 16241                                  	; NOTE: This specific mode has not been set for the code assembled
 16242                                  	; under the "NOT Installed" conditional. Currently Installed is 
 16243                                  	; always one.
 16244                                  	;				; M035 - set the bits on the stack
 16245                                  	;mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 16246                                  	;
 16247                                  ;not_exec_open:
 16248                                  
 16249                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16250 00003799 50                      	PUSH	AX
 16251                                  
 16252                                  	;MOV	AX,(MultNET SHL 8) OR 22
 16253                                  	;INT	2FH
 16254                                  
 16255 0000379A B81611                  	mov     ax,1116h
 16256 0000379D CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 16257                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 16258                                  			; SDA first filename pointer -> fully-qualified name of file to open
 16259                                  			; STACK: WORD file open mode
 16260                                  			; Return: CF set on error
 16261                                  
 16262 0000379F 5B                      	POP	BX			; clean stack
 16263                                  do_ret_label: ; 09/08/2018
 16264 000037A0 C3                      	retn
 16265                                  ;ENDIF
 16266                                  
 16267                                  TEST_RE_NET1:
 16268 000037A1 26F744430080            	TEST	word [ES:SI+curdir.flags],curdir_isnet
 16269                                  	; 18/08/2018
 16270 000037A7 07                      	POP	ES
 16271                                  	;JZ	short LOCAL_OPEN
 16272                                  
 16273 000037A8 75EF                    	jnz	short do_net_int2f ; (*)
 16274                                  
 16275                                  ;Extended open hooks
 16276                                  	; MSDOS 6.0
 16277                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;FT. from extended open	;AN000;
 16278                                  	;JNZ	short IFS_extopen	      ;FT. isuue extended open	;AN000;
 16279                                  ;Extended open hooks
 16280                                  
 16281                                  ;IF NOT Installed
 16282                                  ;	transfer NET_OPEN
 16283                                  ;ELSE
 16284                                  	;jmp	short do_net_int2f (*)
 16285                                  ;ENDIF
 16286                                  
 16287                                  LOCAL_OPEN:
 16288                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16289 000037AA E8B6E8                  	call	EcritDisk
 16290                                  
 16291                                  ; DOS 3.3 FastOPen 6/16/86
 16292                                  
 16293 000037AD 800E[6E0F]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 16294                                  
 16295 000037B2 E87F10                  	call	GETPATH
 16296                                  
 16297                                  ; DOS 3.3 FastOPen 6/16/86
 16298                                  
 16299 000037B5 731E                    	JNC	short Open_found
 16300 000037B7 7512                    	JNZ	short bad_path2
 16301 000037B9 08C9                    	OR	CL,CL
 16302 000037BB 740E                    	JZ	short bad_path2
 16303                                  
 16304                                  OpenFNF:
 16305 000037BD B80200                  	MOV	AX,error_file_not_found
 16306                                  
 16307                                  OpenBadRet:
 16308                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 16309                                  	; 12/08/2018
 16310                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 16311                                  	; MSDOS 6.0
 16312 000037C0 368026[6E0F]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 16313 000037C6 F9                      	STC
 16314 000037C7 E8A1E8                  	call	LcritDisk
 16315                                  	;JMP	Clear_FastOpen ; 10/08/2018
 16316 000037CA C3                      	retn 	; 08/09/2018
 16317                                  
 16318                                  bad_path2:
 16319 000037CB B80300                  	MOV	AX,error_path_not_found
 16320 000037CE EBF0                    	JMP	short OpenBadRet
 16321                                  
 16322                                  Open_Bad_Access:
 16323 000037D0 B80500                  	MOV	AX,error_access_denied
 16324 000037D3 EBEB                    	JMP	short OpenBadRet
 16325                                  
 16326                                  Open_found:
 16327 000037D5 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 16328 000037D7 08E4                    	OR	AH,AH
 16329 000037D9 783F                    	JS	short open_ok		; Devices don't have attributes
 16330 000037DB 8E06[7605]              	MOV	ES,[CURBUF+2]		; get buffer location
 16331 000037DF 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 16332 000037E3 A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 16333 000037E5 75E9                    	JNZ	short Open_Bad_Access
 16334 000037E7 A801                    	TEST	AL,attr_read_only	; check write on read only
 16335 000037E9 742F                    	JZ	short open_ok
 16336                                  ;
 16337                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 16338                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 16339                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 16340                                  ; processing until the actual write operation:
 16341                                  ;
 16342                                  ; If FCB, then we change the mode to be read_only.
 16343                                  ; If net_FCB, then we change the mode to be read_only.
 16344                                  ; If not open for read then error.
 16345                                  ;
 16346 000037EB 1E                      	push	ds
 16347 000037EC 56                      	push	si
 16348 000037ED C536[3605]              	LDS	SI,[THISSFT]
 16349 000037F1 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 16350 000037F4 F7C10080                	TEST	CX,sf_isFCB		; is it FCB?
 16351 000037F8 750A                    	JNZ	short ResetAccess	; yes, reset the access
 16352 000037FA 88CA                    	MOV	DL,CL
 16353 000037FC 80E2F0                  	AND	DL,SHARING_MASK
 16354 000037FF 80FA70                  	CMP	DL,SHARING_NET_FCB	; is it net FCB?
 16355 00003802 7508                    	JNZ	short NormalOpen	; no
 16356                                  ResetAccess:
 16357 00003804 83E1F0                  	AND	CX,~access_mask	;0FFF0h	; clear access
 16358                                  ;	OR	CX,open_for_read	; stick in open_for_read
 16359 00003807 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 16360 0000380A EB0C                    	JMP	SHORT FillSFT
 16361                                  ;
 16362                                  ; The SFT is normal.  See if the requested access is open_for_read
 16363                                  ;
 16364                                  NormalOpen:
 16365 0000380C 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 16366 0000380F 80F900                  	CMP	CL,open_for_read	; is it open for read?
 16367 00003812 7404                    	JZ	short FillSFT
 16368 00003814 5E                      	pop	si
 16369 00003815 1F                      	pop	ds
 16370 00003816 EBB8                    	JMP	short Open_Bad_Access
 16371                                  ;
 16372                                  ; All done, restore registers and fill the SFT.
 16373                                  ;
 16374                                  FillSFT:
 16375 00003818 5E                      	pop	si
 16376 00003819 1F                      	pop	ds
 16377                                  open_ok:
 16378 0000381A E8A619                  	call	DOOPEN			; Fill in SFT
 16379                                  
 16380                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 16381                                  	;12/08/2018
 16382                                  	;AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 16383 0000381D 8026[6E0F]80            	and	byte [FastOpenFlg],Fast_yes	
 16384                                  
 16385                                  	; MSDOS 6.0
 16386                                  	;CALL	DO_SHARE_CHECK
 16387                                  	;JNC	short SHARE_OK
 16388                                  	;call	LcritDisk
 16389                                  	;JMP	short Clear_FastOpen	
 16390                                  
 16391                                  	; MSDOS 3.3
 16392                                  DO_SHARE_CHECK:
 16393 00003822 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 16394                                  OpenShareRetry:
 16395 00003826 51                      	push	cx			; Save number left to do
 16396 00003827 E8FE3A                  	call	SHARE_CHECK		; Final Check
 16397 0000382A 59                      	pop	cx			; CX = # left
 16398 0000382B 7312                    	JNC	short SHARE_OK		; No problem with access
 16399 0000382D E850E7                  	call	Idle
 16400 00003830 E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 16401                                  OpenShareFail:
 16402 00003832 C43E[3605]              	LES	DI,[THISSFT]
 16403 00003836 E82B00                  	call	SHARE_ERROR
 16404 00003839 73E7                    	JNC	short DO_SHARE_CHECK	; User wants more retry
 16405                                  	
 16406                                  	;12/08/2018
 16407                                  	;mov	byte [ss:FastOpenFlg],0
 16408                                  	;08/09/2018
 16409                                  	;mov	byte [FastOpenFlg],0
 16410 0000383B E82DE8                  	call	LcritDisk
 16411                                  	;JMP	short Clear_FastOpen
 16412 0000383E C3                      	retn
 16413                                  
 16414                                  SHARE_OK:
 16415                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16416 0000383F B80300                  	MOV	AX,3
 16417 00003842 C43E[3605]              	LES	DI,[THISSFT]
 16418                                  ;if installed
 16419                                  	;call	JShare + 14 * 4
 16420 00003846 FF1E[9400]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 16421                                  ;else
 16422                                  ;	Call	ShSU
 16423                                  ;endif
 16424 0000384A E81EE8                  	call	LcritDisk
 16425                                  	
 16426                                  	;FallThru Set_SFT_Mode
 16427                                  
 16428                                  ;----------------------------------------------------------------------------
 16429                                  ; Procedure Name : SET_SFT_MODE
 16430                                  ;
 16431                                  ; Finish SFT initialization for new reference. Set the correct mode.
 16432                                  ;
 16433                                  ;   Inputs:
 16434                                  ;	ThisSFT points to SFT
 16435                                  ;
 16436                                  ;   Outputs:
 16437                                  ;	Carry clear
 16438                                  ;   Registers modified: AX.
 16439                                  ;---------------------------------------------------------------------------
 16440                                  
 16441                                  ;hkn; called from create. DS already set up to DOSDATA.
 16442                                  
 16443                                  SET_SFT_MODE:
 16444 0000384D C43E[3605]              	LES	DI,[THISSFT]
 16445 00003851 E82416                  	call	DEV_OPEN_SFT
 16446 00003854 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 16447 0000385A 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 16448 0000385C A1[DE02]                	MOV	AX,[CurrentPDB]
 16449 0000385F 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 16450                                  
 16451                                  Clear_FastOpen:
 16452 00003863 C3                      	retn			       ;;;;; DOS 3.3
 16453                                  
 16454                                  ;----------------------------------------------------------------------------
 16455                                  ; Procedure Name : SHARE_ERROR
 16456                                  ;
 16457                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 16458                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 16459                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 16460                                  ; really ignore).  Carry clear
 16461                                  ; if user wants a retry. ES, DI, DS preserved
 16462                                  ;---------------------------------------------------------------------------
 16463                                  
 16464                                  SHARE_ERROR:
 16465 00003864 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 16466 0000386A 750C                    	JNZ	short _HARD_ERR
 16467 0000386C 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 16468 00003870 80E1F0                  	AND	CL,SHARING_MASK
 16469 00003873 80F900                  	CMP	CL,SHARING_COMPAT
 16470 00003876 7505                    	JNE	short _NO_HARD_ERR
 16471                                  _HARD_ERR:
 16472 00003878 E8B23A                  	call	SHARE_VIOLATION
 16473                                  	;retnc				; User wants retry
 16474 0000387B 73E6                    	jnc	short Clear_FastOpen
 16475                                  _NO_HARD_ERR:
 16476 0000387D B82000                  	MOV	AX,error_sharing_violation
 16477 00003880 F9                      	STC
 16478 00003881 C3                      	retn
 16479                                  
 16480                                  ; MSDOS 6.0
 16481                                  ;----------------------------------------------------------------------------
 16482                                  ; Procedure Name : DO_SHARE_CHECK
 16483                                  ;
 16484                                  ; Input: THISDPB, WFP_Start, THISSFT set
 16485                                  ; Functions: check file sharing mode is valid
 16486                                  ; Output: carry set, error
 16487                                  ;	  carry clear, share ok
 16488                                  ;----------------------------------------------------------------------------
 16489                                  ;
 16490                                  ;DO_SHARE_CHECK:
 16491                                  ;	call	EcritDisk		; enter critical section
 16492                                  ;OPN_RETRY:
 16493                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 16494                                  ;OpenShareRetry:
 16495                                  ;	push	cx			; Save number left to do
 16496                                  ;	call	SHARE_CHECK		; Final Check
 16497                                  ;	pop	cx			; CX = # left
 16498                                  ;	JNC	short Share_Ok2		; No problem with access
 16499                                  ;	call	Idle
 16500                                  ;	LOOP	OpenShareRetry		; One more retry used up
 16501                                  ;OpenShareFail:
 16502                                  ;	LES	DI,[THISSFT]
 16503                                  ;	call	SHARE_ERROR
 16504                                  ;	JNC	short OPN_RETRY		; User wants more retry
 16505                                  ;Share_Ok2:
 16506                                  ;	call	LcritDisk		; leave critical section
 16507                                  ;	retn
 16508                                  
 16509                                  ;-----------------------------------------------------------------------------
 16510                                  ; Procedure Name : Check_Access
 16511                                  ;
 16512                                  ; Inputs:
 16513                                  ;	AX is mode
 16514                                  ;	  High NIBBLE of AL (Sharing Mode)
 16515                                  ;		sharing_compat	   file is opened in compatibility mode
 16516                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 16517                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 16518                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 16519                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 16520                                  ;	  Low NIBBLE of AL (Access Mode)
 16521                                  ;		open_for_read	file is opened for reading
 16522                                  ;		open_for_write	file is opened for writing
 16523                                  ;		open_for_both	file is opened for both reading and writing.
 16524                                  ; Function:
 16525                                  ;	Check this access mode for correctness
 16526                                  ; Outputs:
 16527                                  ;	[open_access] = AL input
 16528                                  ;	Carry Clear
 16529                                  ;		Mode is correct
 16530                                  ;		AX unchanged
 16531                                  ;	Carry Set
 16532                                  ;		Mode is bad
 16533                                  ;		AX = error_invalid_access
 16534                                  ; No other registers effected
 16535                                  ;----------------------------------------------------------------------------
 16536                                  
 16537                                  Check_Access_AX:
 16538                                  
 16539 00003882 A2[0905]                	MOV	[OPEN_ACCESS],AL
 16540 00003885 53                      	PUSH	BX
 16541                                  
 16542                                  ;	If sharing, then test for special sharing mode for FCBs
 16543                                  
 16544 00003886 88C3                    	MOV	BL,AL
 16545 00003888 80E3F0                  	AND	BL,SHARING_MASK
 16546 0000388B 803E[0D05]FF            	CMP	byte [FSHARING],-1
 16547 00003890 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 16548 00003892 80FB70                  	CMP	BL,SHARING_NET_FCB
 16549 00003895 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 16550                                  CheckShareMode:
 16551 00003897 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 16552 0000389A 770D                    	JA	short Make_Bad_Access
 16553                                  CheckAccessMode:
 16554 0000389C 88C3                    	MOV	BL,AL
 16555 0000389E 80E30F                  	AND	BL,access_mask
 16556 000038A1 80FB02                  	CMP	BL,2
 16557 000038A4 7703                    	JA	short Make_Bad_Access
 16558 000038A6 5B                      	POP	BX
 16559 000038A7 F8                      	CLC
 16560 000038A8 C3                      	retn
 16561                                  
 16562                                  Make_Bad_Access:
 16563 000038A9 B80C00                  	MOV	AX,error_invalid_access
 16564 000038AC 5B                      	POP	BX
 16565 000038AD F9                      	STC
 16566 000038AE C3                      	retn
 16567                                  
 16568                                  ;============================================================================
 16569                                  ; DINFO.ASM, MSDOS 6.0, 1991
 16570                                  ;============================================================================
 16571                                  ; 08/08/2018 - Retro DOS v3.0
 16572                                  
 16573                                  ;**	Low level routine for returning disk drive information from a local
 16574                                  ;	  or NET device
 16575                                  ;
 16576                                  ;	DISK_INFO
 16577                                  ;
 16578                                  ;	  Modification history:
 16579                                  ;
 16580                                  ;		Created: ARR 30 March 1983
 16581                                  
 16582                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 16583                                  ;---------------------------------------------------------------------------
 16584                                  ; Procedure Name : DISK_INFO
 16585                                  ;
 16586                                  ; Inputs:
 16587                                  ;	[THISCDS] Points to the Macro List Structure of interest
 16588                                  ;		(It MAY NOT be NUL, error not detected)
 16589                                  ; Function:
 16590                                  ;	Get Interesting Drive Information
 16591                                  ; Returns:
 16592                                  ;	DX = Number of free allocation units
 16593                                  ;	BX = Total Number of allocation units on disk
 16594                                  ;	CX = Sector size
 16595                                  ;	AL = Sectors per allocation unit
 16596                                  ;	AH = FAT ID BYTE
 16597                                  ;	Carry set if error (currently user FAILed to I 24)
 16598                                  ; Segs except ES preserved, others destroyed
 16599                                  ;----------------------------------------------------------------------------
 16600                                  
 16601                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 16602                                  ;hkn; DOSDATA. 
 16603                                  
 16604                                  DISK_INFO:
 16605                                  	; 08/08/2018 - Retro DOS v3.0
 16606                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 16607                                  
 16608 000038AF E813E7                  	call	TestNet
 16609 000038B2 7306                    	JNC	short LOCAL_DSK_INFO
 16610                                  
 16611                                  ;IF NOT Installed
 16612                                  ;	transfer NET_DISK_INFO
 16613                                  ;ELSE
 16614                                  	;MOV	AX,(MultNET SHL 8) OR 12
 16615                                  	;INT	2FH
 16616                                  	;return
 16617                                  
 16618 000038B4 B80C11                  	mov     ax,110Ch
 16619 000038B7 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 16620                                  			; ES:DI -> current directory
 16621                                  			; Return: AL = sectors per cluster, BX = total clusters
 16622                                  			; CX = bytes per sector, DX = number of available clusters
 16623 000038B9 C3                      	retn
 16624                                  ;ENDIF
 16625                                  
 16626                                  LOCAL_DSK_INFO:
 16627 000038BA C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 16628 000038BF E8A1E7                  	call	EcritDisk
 16629 000038C2 E8F922                  	call	FATREAD_CDS		; perform media check.
 16630 000038C5 7241                    	JC	short CRIT_LEAVE
 16631 000038C7 BB0200                  	MOV	BX,2
 16632 000038CA E88321                  	call	UNPACK			; Get first FAT sector into CURBUF
 16633 000038CD 7239                    	JC	short CRIT_LEAVE
 16634 000038CF C536[7405]              	LDS	SI,[CURBUF]
 16635 000038D3 8A6410                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 16636                                  
 16637                                  ;hkn; SS is DOSDATA
 16638 000038D6 16                      	push	ss
 16639 000038D7 1F                      	pop	ds
 16640 000038D8 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 16641                                  ;
 16642                                  ; Examine the current free count.  If it indicates that we have an invalid
 16643                                  ; count, do the expensive calculation.
 16644                                  ;
 16645 000038DC 268B561E                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 16646 000038E0 83FAFF                  	CMP	DX,-1			; is it valid?
 16647 000038E3 7404                    	JZ	short DoScan
 16648                                  ;
 16649                                  ; Check to see if it is in a reasonalbe range.	If so, trust it and return.
 16650                                  ; Otherwise, we need to blast out an internal error message and then recompute
 16651                                  ; the count.
 16652                                  ;
 16653 000038E5 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 16654 000038E7 7223                    	JB	short GotVal		; yes, trust it.
 16655                                  DoScan:
 16656 000038E9 31D2                    	XOR	DX,DX
 16657 000038EB 49                      	DEC	CX
 16658                                  SCANFREE:
 16659 000038EC E86121                  	call	UNPACK
 16660 000038EF 7217                    	JC	short CRIT_LEAVE
 16661 000038F1 7501                    	JNZ	short NOTFREECLUS
 16662 000038F3 42                      	INC	DX			; A free one
 16663                                  NOTFREECLUS:
 16664 000038F4 43                      	INC	BX			; Next cluster
 16665 000038F5 E2F5                    	LOOP	SCANFREE
 16666 000038F7 4B                      	DEC	BX			; BX was next cluster.	Convert to
 16667                                  ReturnVals:
 16668 000038F8 4B                      	DEC	BX			; count
 16669 000038F9 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK] 
 16670 000038FD FEC0                    	INC	AL			; Sectors/cluster
 16671 000038FF 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 16672 00003903 2689561E                	MOV	[ES:BP+DPB.FREE_CNT],DX
 16673 00003907 F8                      	CLC
 16674                                  CRIT_LEAVE:
 16675 00003908 E860E7                  	call	LcritDisk
 16676 0000390B C3                      	retn
 16677                                  ;
 16678                                  ; We have correctly computed everything previously. Load up registers for
 16679                                  ; return.
 16680                                  ;
 16681                                  GotVal: 
 16682 0000390C 89CB                    	MOV	BX,CX			; get cluster count
 16683 0000390E EBE8                    	JMP	short ReturnVals
 16684                                  
 16685                                  ;============================================================================
 16686                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 16687                                  ;============================================================================
 16688                                  ; 22/07/2018 - Retro DOS v3.0
 16689                                  
 16690                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 16691                                  ;	NAME	DOS_SEARCH
 16692                                  
 16693                                  ;**	Low level routines for doing local and NET directory searches
 16694                                  ;
 16695                                  ;	DOS_SEARCH_FIRST
 16696                                  ;	DOS_SEARCH_NEXT
 16697                                  ;	RENAME_NEXT
 16698                                  ;
 16699                                  ;	Revision history:
 16700                                  ;
 16701                                  ;	    Created: ARR 30 March 1983
 16702                                  ;	    A000	version 4.00  Jan. 1988
 16703                                  ;	    A001	PTM 3564 -- search for fastopen
 16704                                  
 16705                                  ;Installed = TRUE
 16706                                  
 16707                                  ;--------------------------------------------------------------------------
 16708                                  ;
 16709                                  ; Procedure Name : DOS_SEARCH_FIRST
 16710                                  ;
 16711                                  ; Inputs:
 16712                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16713                                  ;		terminated)
 16714                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16715                                  ;		( = -1 if current dir not involved, else
 16716                                  ;		 Points to first char after last "/" of current dir part)
 16717                                  ;	[THISCDS] Points to CDS being used
 16718                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16719                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16720                                  ;	[DMAADD] Points to 53 byte buffer
 16721                                  ; Function:
 16722                                  ;	Initiate a search for the given file spec
 16723                                  ; Outputs:
 16724                                  ;	CARRY CLEAR
 16725                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 16726                                  ;
 16727                                  ;	LOCAL
 16728                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 16729                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 16730                                  ;	    11 byte search name with Meta chars in it
 16731                                  ;	    Search Attribute Byte, attribute of search
 16732                                  ;	    WORD LastEnt value
 16733                                  ;	    WORD DirStart
 16734                                  ;	    4 byte pad
 16735                                  ;	    32 bytes of the directory entry found
 16736                                  ;	NET
 16737                                  ;	    21 bytes First byte has high bit set
 16738                                  ;	    32 bytes of the directory entry found
 16739                                  ;
 16740                                  ;	CARRY SET
 16741                                  ;	    AX = error code
 16742                                  ;		error_no_more_files
 16743                                  ;			No match for this file
 16744                                  ;		error_path_not_found
 16745                                  ;			Bad path (not in curr dir part if present)
 16746                                  ;		error_bad_curr_dir
 16747                                  ;			Bad path in current directory part of path
 16748                                  ; DS preserved, others destroyed
 16749                                  ;---------------------------------------------------------------------------
 16750                                  
 16751                                  DOS_SEARCH_FIRST:
 16752                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 16753                                  
 16754 00003910 C43E[3A05]              	LES	DI,[THISCDS]
 16755 00003914 83FFFF                  	CMP	DI,-1
 16756 00003917 7506                    	JNZ	short TEST_RE_NET2
 16757                                  
 16758                                  ;IF NOT Installed
 16759                                  ;	transfer NET_SEQ_SEARCH_FIRST
 16760                                  ;ELSE
 16761                                  	;mov	ax,1119h
 16762 00003919 B81911                  	MOV	AX,(MultNET<<8)|25
 16763 0000391C CD2F                    	INT	2Fh
 16764 0000391E C3                      	retn
 16765                                  ;ENDIF
 16766                                  
 16767                                  TEST_RE_NET2:
 16768                                  	;test	word [es:di+43h],8000h
 16769 0000391F 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 16770 00003925 7406                    	JZ	short LOCAL_SEARCH_FIRST
 16771                                  
 16772                                  ;IF NOT Installed
 16773                                  ;	transfer NET_SEARCH_FIRST
 16774                                  ;ELSE
 16775                                  	;mov	ax,111Bh
 16776 00003927 B81B11                  	MOV	AX,(MultNET<<8)|27
 16777 0000392A CD2F                    	INT	2FH
 16778 0000392C C3                      	retn
 16779                                  ;ENDIF
 16780                                  
 16781                                  LOCAL_SEARCH_FIRST:
 16782 0000392D E833E7                  	call	EcritDisk
 16783                                  	; MSDOS 6.0
 16784                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 16785                                  	;JZ	short NOFN			;AN000;
 16786                                  	;OR	byte [FastOpenflg],Fastopen_Set	;AN000;
 16787                                  ;NOFN:						;AN000;
 16788 00003930 C606[F802]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 16789                                  	; MSDOS 6.0
 16790                                  	;CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 16791                                  	;JNC	short norm_GETPATH	;AN000;;FO. no
 16792                                  	;AND	byte [FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
 16793                                  ;norm_GETPATH:
 16794 00003935 E8FC0E                  	call	GETPATH
 16795                                  	; BX = offset NAME1
 16796                                  ;_getdone:
 16797 00003938 7313                    	JNC	short find_check_dev
 16798 0000393A 750C                    	JNZ	short bad_path3
 16799 0000393C 08C9                    	OR	CL,CL
 16800 0000393E 7408                    	JZ	short bad_path3
 16801                                  find_no_more:
 16802                                  	;mov	ax,12h
 16803 00003940 B81200                  	MOV	AX,error_no_more_files
 16804                                  BadBye:
 16805                                  	; MSDOS 6.0
 16806                                  	;AND	[SS:FastOpenflg],Fast_yes  ;AN000;;FO. reset fastopen
 16807                                  
 16808 00003943 F9                      	STC
 16809 00003944 E824E7                  	call	LcritDisk
 16810 00003947 C3                      	retn
 16811                                  
 16812                                  bad_path3:
 16813                                  	;mov	ax,3
 16814 00003948 B80300                  	MOV	AX,error_path_not_found
 16815 0000394B EBF6                    	JMP	short BadBye
 16816                                  
 16817                                  find_check_dev:
 16818 0000394D 08E4                    	OR	AH,AH
 16819 0000394F 790A                    	JNS	short found_entry
 16820 00003951 C706[F402]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 16821 00003957 FE06[0B05]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 16822                                  found_entry:
 16823                                  ;
 16824                                  ; We set the physical drive byte here Instead of after found_it; Doing
 16825                                  ; a search-next may not have wfp_start set correctly
 16826                                  ;
 16827 0000395B C43E[DA02]              	LES	DI,[DMAADD]
 16828 0000395F 8B36[4A05]              	MOV	SI,[WFP_START]		; get pointer to beginning
 16829 00003963 AC                      	LODSB
 16830 00003964 2C40                    	SUB	AL,'A'-1                ; logical drive
 16831 00003966 AA                      	STOSB				; High bit not set (local)
 16832                                  found_it:
 16833 00003967 C43E[DA02]              	LES	DI,[DMAADD]
 16834 0000396B 47                      	INC	DI
 16835                                  
 16836                                  	; MSDOS 6.0
 16837                                  	;PUSH	DS				  ;FO.;AN001; save ds
 16838                                  	;TEST	byte [Fastopenflg],Set_For_Search ;FO.;AN001; from fastopen
 16839                                  	;JZ	short notfast 			  ;FO.;AN001;
 16840                                  	;MOV	SI,BX				  ;FO.;AN001;
 16841                                  	;MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 16842                                  	;JMP	SHORT movmov			  ;FO.;AN001;
 16843                                  
 16844                                  notfast:
 16845 0000396C BE[E604]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 16846                                  movmov:
 16847                                  ; Special E5 code
 16848 0000396F A4                      	MOVSB
 16849 00003970 26807DFF05              	CMP	BYTE [ES:DI-1],5
 16850 00003975 7505                    	JNZ	short NOTKANJB
 16851 00003977 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 16852                                  NOTKANJB:
 16853 0000397C B90A00                  	MOV	CX,10
 16854 0000397F F3A4                    	REP	MOVSB
 16855                                  
 16856                                  	; 08/09/2018
 16857                                  	;POP	DS			;FO.;AN001; restore ds
 16858                                  
 16859 00003981 A0[0605]                	MOV	AL,[ATTRIB]
 16860 00003984 AA                      	STOSB
 16861 00003985 50                      	PUSH	AX			; Save AH device info
 16862 00003986 A1[F402]                	MOV	AX,[LASTENT]
 16863 00003989 AB                      	STOSW
 16864 0000398A A1[5805]                	MOV	AX,[DIRSTART]
 16865 0000398D AB                      	STOSW
 16866                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 16867 0000398E 83C704                  	ADD	DI,4
 16868 00003991 58                      	POP	AX			; Recover AH device info
 16869 00003992 08E4                    	OR	AH,AH
 16870 00003994 7813                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 16871 00003996 833E[7405]FF            	CMP	WORD [CURBUF],-1
 16872 0000399B 7508                    	JNZ	short OKSTORE
 16873                                  
 16874                                  	; MSDOS 6.0
 16875                                  	;TEST	byte [FastOPenFlg],Set_For_Search
 16876                                  					;AN000;;FO. from fastopen and is good
 16877                                  	;JNZ	short OKSTORE		;AN000;;FO.
 16878                                  
 16879                                  	; The user has specified the root directory itself, rather than some
 16880                                  	; contents of it. We can't "find" that.
 16881 0000399D 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 16882                                  					;   stuffing a -1 at Lastent
 16883 000039A3 EB9B                    	JMP	short find_no_more
 16884                                  
 16885                                  OKSTORE:
 16886 000039A5 8E1E[7605]              	MOV	DS,[CURBUF+2]
 16887                                  DOSREL:
 16888                                  	; BX = offset NAME1 (from GETPATH)
 16889 000039A9 89DE                    	MOV	SI,BX			; SI-> start of entry
 16890                                  
 16891                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 16892                                  
 16893                                  	;mov	cx,32
 16894 000039AB B92000                  	MOV	CX,dir_entry.size
 16895                                  ;;;;; 7/29/86
 16896 000039AE 89F8                    	MOV	AX,DI			; save the 1st byte addr
 16897 000039B0 F3A4                    	REP	MOVSB
 16898 000039B2 89C7                    	MOV	DI,AX			; restore 1st byte addr
 16899 000039B4 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 16900 000039B8 7504                    	JNZ	short NO05
 16901 000039BA 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 16902                                  NO05:
 16903                                  
 16904                                  ;;;;; 7/29/86
 16905                                  
 16906                                  ;hkn; FastOpenflg is in DOSDATA use SS
 16907                                  	; MSDOS 6.0
 16908                                  	;AND	byte [SS:FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
 16909                                  	;push	ss
 16910                                  	;pop	ds
 16911                                  	;AND	byte [FastOpenflg],Fast_yes
 16912                                  
 16913                                  ;hkn; SS is DOSDATA
 16914 000039BE 16                      	push	ss
 16915 000039BF 1F                      	pop	ds
 16916 000039C0 F8                      	CLC
 16917 000039C1 E8A7E6                  	call	LcritDisk
 16918 000039C4 C3                      	retn
 16919                                  
 16920                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 16921                                  ;----------------------------------------------------------------------------
 16922                                  ;
 16923                                  ; Procedure Name : DOS_SEARCH_NEXT
 16924                                  ;
 16925                                  ; Inputs:
 16926                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 16927                                  ;	    (only first 21 bytes must have valid information)
 16928                                  ; Function:
 16929                                  ;	Look for subsequent matches
 16930                                  ; Outputs:
 16931                                  ;	CARRY CLEAR
 16932                                  ;	    The 53 bytes at DMAADD are updated for next call
 16933                                  ;		(see DOS_SEARCH_FIRST)
 16934                                  ;	CARRY SET
 16935                                  ;	    AX = error code
 16936                                  ;		error_no_more_files
 16937                                  ;			No more files to find
 16938                                  ; DS preserved, others destroyed
 16939                                  ;---------------------------------------------------------------------------
 16940                                  
 16941                                  ;hkn; called from search.asm. DS already set up at this point.
 16942                                  
 16943                                  DOS_SEARCH_NEXT:
 16944 000039C5 C43E[DA02]              	LES	DI,[DMAADD]
 16945 000039C9 268A05                  	MOV	AL,[ES:DI]
 16946 000039CC A880                    	TEST	AL,80H			; Test for NET
 16947 000039CE 7406                    	JZ	short LOCAL_SEARCH_NEXT
 16948                                  ;IF NOT Installed
 16949                                  ;	transfer NET_SEARCH_NEXT
 16950                                  ;ELSE
 16951                                  	;mov	ax,111Ch
 16952 000039D0 B81C11                  	MOV	AX,(MultNET<<8)|28
 16953 000039D3 CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 16954                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 16955                                  		     ; Return: CF set on error, AX = DOS error code
 16956                                  		     ; CF clear if successful
 16957 000039D5 C3                      	retn
 16958                                  ;ENDIF
 16959                                  
 16960                                  LOCAL_SEARCH_NEXT:
 16961                                  	;AL is drive A=1
 16962                                  	;mov	byte [EXTERR_LOCUS],2
 16963 000039D6 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 16964 000039DB E885E6                  	call	EcritDisk
 16965                                  
 16966                                  ;hkn; DummyCDS is in DOSDATA
 16967 000039DE C706[3A05][9504]        	MOV     word [THISCDS],DUMMYCDS
 16968                                  ;hkn; Segment address is DOSDATA - use ds
 16969                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 16970 000039E4 8C1E[3C05]              	mov	[THISCDS+2],DS
 16971                                  
 16972 000039E8 0440                    	ADD	AL,'A'-1
 16973 000039EA E8CD2E                  	call	InitCDS
 16974                                  
 16975                                  ;	call	GETTHISDRV		; Set CDS pointer
 16976                                  
 16977 000039ED 7236                    	JC	short No_files		; Bogus drive letter
 16978 000039EF C43E[3A05]              	LES	DI,[THISCDS]		; Get CDS pointer
 16979                                  	;les	bp,[es:di+45h]
 16980 000039F3 26C46D45                	LES	BP,[ES:DI+curdir.devptr]; Get DPB pointer
 16981 000039F7 E8FADC                  	call	GOTDPB			; [THISDPB] = ES:BP
 16982                                  
 16983 000039FA 268A4600                	mov	al,[ES:BP]
 16984                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 16985 000039FE A2[1105]                	mov	[THISDRV],AL
 16986                                  	;mov	word [CREATING], 0E500h
 16987 00003A01 C706[1805]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 16988 00003A07 C606[F802]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 16989 00003A0C C536[DA02]              	LDS	SI,[DMAADD]
 16990 00003A10 AC                      	LODSB				; Drive Byte
 16991                                  
 16992                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 16993                                  RENAME_NEXT:
 16994                                  	;context ES
 16995 00003A11 16                      	push	ss
 16996 00003A12 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 16997                                  
 16998                                  ;hkn; NAME1 is in DOSDATA
 16999 00003A13 BF[E604]                	MOV	DI,NAME1
 17000                                  
 17001 00003A16 B90B00                  	MOV	CX,11
 17002 00003A19 F3A4                    	REP	MOVSB			; Search name
 17003 00003A1B AC                      	LODSB				; Attribute
 17004                                  
 17005                                  ;hkn; SS override
 17006 00003A1C 36A2[0605]              	MOV	[SS:ATTRIB],AL
 17007 00003A20 AD                      	LODSW				; LastEnt
 17008 00003A21 09C0                    	OR	AX,AX
 17009 00003A23 7903                    	JNS	short cont_load
 17010                                  No_files:
 17011 00003A25 E918FF                  	JMP	find_no_more
 17012                                  
 17013                                  cont_load:
 17014 00003A28 50                      	PUSH	AX			; Save LastEnt
 17015 00003A29 AD                      	LODSW				; DirStart
 17016 00003A2A 89C3                    	MOV	BX,AX
 17017                                  
 17018                                  ;hkn; SS is DOSDATA
 17019                                  	;context DS
 17020 00003A2C 16                      	push	ss
 17021 00003A2D 1F                      	pop	ds
 17022 00003A2E C42E[2405]              	LES	BP,[THISDPB]		; Recover ES:BP
 17023                                  	;invoke	SetDirSrch
 17024 00003A32 E8AA0D                  	call	SETDIRSRCH
 17025 00003A35 7303                    	JNC	short SEARCH_GOON
 17026 00003A37 58                      	POP	AX			; Clean stack
 17027 00003A38 EBEB                    	JMP	short No_files
 17028                                  
 17029                                  SEARCH_GOON:
 17030 00003A3A E88110                  	call	STARTSRCH
 17031 00003A3D 58                      	POP	AX
 17032 00003A3E E8700D                  	call	GETENT
 17033 00003A41 72E2                    	JC	short No_files
 17034 00003A43 E8AF0C                  	call	NEXTENT
 17035 00003A46 72DD                    	JC	short No_files
 17036 00003A48 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 17037 00003A4A E91AFF                  	JMP	found_it ; 10/08/2018
 17038                                  
 17039                                  ; MSDOS6.0
 17040                                  ;---------------------------------------------------------------------------
 17041                                  ;
 17042                                  ; Procedure Name : CHECK_QUESTION
 17043                                  ;
 17044                                  ; Input: [WFP_START]= pointer to final path
 17045                                  ; Function: check '?' char
 17046                                  ; Output: carry clear, if no '?'
 17047                                  ;	 carry set, if '?' exists
 17048                                  ;---------------------------------------------------------------------------
 17049                                  
 17050                                  ;CHECK_QUESTION:
 17051                                  ;;hkn;	wfp_start is in DOSDATA;hkn;	MOV     WORD PTR ThisCDS+2,CS
 17052                                  ;;hkn;	PUSH	CS			;AN000;;FO.
 17053                                  ;	push	ss
 17054                                  ;
 17055                                  ;	POP	DS			;AN000;;FO. ds:si -> final path
 17056                                  ;	MOV	SI,[WFP_START]		;AN000;;FO.
 17057                                  ;getnext:				;AN000;
 17058                                  ;	LODSB				;AN000;;FO. get char
 17059                                  ;	OR	AL,AL			;AN000;;FO. is it null
 17060                                  ;	JZ	short NO_Question	;AN000;;FO. yes
 17061                                  ;	CMP	AL,'?'                  ;AN000;;FO. is '?'
 17062                                  ;	JNZ	short getnext 		;AN000;;FO. no
 17063                                  ;	STC				;AN000;;FO.
 17064                                  ;NO_Question:				;AN000;
 17065                                  ;	retn				;AN000;;FO.
 17066                                  
 17067                                  ;============================================================================
 17068                                  ; ABORT.ASM, MSDOS 6.0, 1991
 17069                                  ;============================================================================
 17070                                  ; 23/07/2018 - Retro DOS v3.0
 17071                                  
 17072                                  ;**
 17073                                  ;
 17074                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 17075                                  ;  If process has NET resources a close all is sent out over the net.
 17076                                  ;
 17077                                  ;   DOS_ABORT
 17078                                  ;
 17079                                  ;   Modification history:
 17080                                  ;
 17081                                  ;       Created: ARR 30 March 1983
 17082                                  ;
 17083                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 17084                                  ;				being terminated only if it is busy.
 17085                                  ;
 17086                                  
 17087                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 17088                                  ;--------------------------------------------------------------------------
 17089                                  ;
 17090                                  ; Procedure Name : DOS_ABORT
 17091                                  ;
 17092                                  ; Inputs:
 17093                                  ;       [CurrentPDB] set to PID of process aborting
 17094                                  ; Function:
 17095                                  ;       Close all files and free all SFTs for this PID
 17096                                  ; Returns:
 17097                                  ;       None
 17098                                  ; All destroyed except stack
 17099                                  ;---------------------------------------------------------------------------
 17100                                  
 17101                                  DOS_ABORT:
 17102 00003A4D 368E06[DE02]            	MOV     ES,[SS:CurrentPDB]	; SS override
 17103 00003A52 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 17104                                  reset_free_jfn:
 17105 00003A57 89CB                    	MOV     BX,CX
 17106 00003A59 51                      	PUSH    CX
 17107 00003A5A 4B                      	DEC     BX                      ; get jfn (start with last one)
 17108                                  
 17109 00003A5B E86833                  	CALL	_$CLOSE
 17110 00003A5E 59                      	POP     CX
 17111 00003A5F E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 17112                                  ;
 17113                                  ; Note:  We do need to explicitly close FCBs. Reasons are as follows: If we
 17114                                  ; are running in the no-sharing no-network environment, we are simulating the
 17115                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 17116                                  ; BUT...  the cache remains in a state with garbage that may be reused by the
 17117                                  ; next process.  We scan the set and blast the ref counts of the FCBs we own.
 17118                                  ;
 17119                                  ; If sharing is loaded, then the following call to close process will
 17120                                  ; correctly close all FCBs.  We will then need to walk the list AFTER here.
 17121                                  ;
 17122                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 17123                                  ; known network resources.  These resources are then responsible for cleaning
 17124                                  ; up after this process.
 17125                                  ;
 17126                                  ; Sleazy, eh?
 17127                                  ;
 17128                                  	;context DS			; SS is DOSDATA
 17129 00003A61 16                      	push	ss
 17130 00003A62 1F                      	pop	ds  ; 09/09/2018
 17131                                  
 17132                                  	;CallInstall Net_Abort, MultNET, 29
 17133 00003A63 B81D11                  	mov	ax, 111Dh
 17134 00003A66 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 17135                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 17136                                  			; DS???, SS = DOS CS
 17137                                  ;if installed
 17138 00003A68 FF1E[6C00]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 17139                                  ;else
 17140                                  ;	call 	mftCloseP
 17141                                  ;endif
 17142                                  
 17143                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 17144                                  ; counts.
 17145                                  					; SS override
 17146 00003A6C 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 17147                                  	;mov	cx,[es:di+4]
 17148 00003A71 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 17149 00003A75 E317                    	jcxz    FCBScanDone
 17150                                  	;lea	di,[di+6]
 17151 00003A77 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 17152 00003A7A 36A1[E802]              	mov     ax,[SS:PROC_ID]		; SS override
 17153                                  FCBTest:
 17154                                  	;cmp	[es:di+31h],ax
 17155 00003A7E 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 17156 00003A82 7505                    	jnz	short FCBNext		; no, skip it
 17157 00003A84 26C7050000              	mov	word [es:di],0
 17158                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 17159                                  FCBNext:
 17160 00003A89 83C735                  	add     di,SF_ENTRY.size
 17161 00003A8C E2F0                    	loop    FCBTest
 17162                                  FCBScanDone:
 17163                                  
 17164                                  ;
 17165                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 17166                                  ;
 17167 00003A8E 31DB                    	XOR     BX,BX
 17168                                  Scan:
 17169 00003A90 53                      	push    bx
 17170 00003A91 E8812D                  	call	SFFromSFN
 17171 00003A94 5B                      	pop     bx
 17172 00003A95 7301                    	jnc     short Scan1
 17173 00003A97 C3                      	retn
 17174                                  
 17175                                  ;M038
 17176                                  ; Do what the comment above says, check for busy state
 17177                                  ;
 17178                                  Scan1:
 17179                                  	;cmp	word [es:di],0
 17180                                  	;jz	short scan_next  ; MSDOS 3.3
 17181                                  	; MSDOS6.0
 17182 00003A98 26833DFF                	cmp	word [es:di],sf_busy ; -1
 17183                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 17184                                  				; Is Sft busy? ;M038
 17185 00003A9C 7519                    	jnz	short scan_next
 17186                                  ;
 17187                                  ; we have a SFT that is busy. See if it is for the current process
 17188                                  ;
 17189 00003A9E 36A1[E802]              	mov     ax,[SS:PROC_ID]		; SS override
 17190                                  	;cmp	[es:di+31h],ax
 17191 00003AA2 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 17192 00003AA6 750F                    	jnz	short scan_next
 17193 00003AA8 36A1[EA02]              	mov     ax,[SS:USER_ID]		; SS override
 17194                                  	;cmp	[es:di+2Fh],ax
 17195 00003AAC 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 17196 00003AB0 7505                    	jnz	short scan_next
 17197                                  ;
 17198                                  ; This SFT is labelled as ours.
 17199                                  ;
 17200 00003AB2 26C7050000              	mov	word [es:di],0
 17201                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 17202                                  scan_next:
 17203 00003AB7 43                      	inc     bx
 17204 00003AB8 EBD6                    	jmp     short Scan
 17205                                  
 17206                                  
 17207                                  ;============================================================================
 17208                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 17209                                  ;============================================================================
 17210                                  ; 23/07/2018 - Retro DOS v3.0
 17211                                  
 17212                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 17213                                  ;
 17214                                  ;	DOS_CLOSE
 17215                                  ;	DOS_COMMIT
 17216                                  ;	FREE_SFT
 17217                                  ;	SetSFTTimes
 17218                                  ;
 17219                                  ;	Revision history:
 17220                                  ;
 17221                                  ;	   AN000  version 4.00	Jan. 1988
 17222                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 17223                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 17224                                  
 17225                                  ;Installed = TRUE
 17226                                  
 17227                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 17228                                  ;---------------------------------------------------------------------------
 17229                                  ;
 17230                                  ; Procedure Name : DOS_CLOSE
 17231                                  ;
 17232                                  ; Inputs:
 17233                                  ;	[THISSFT] set to the SFT for the file being used
 17234                                  ; Function:
 17235                                  ;	Close the indicated file via the SFT
 17236                                  ; Returns:
 17237                                  ;	sf_ref_count decremented otherwise
 17238                                  ;	ES:DI point to SFT
 17239                                  ;	Carry set if error
 17240                                  ;	    AX has error code
 17241                                  ; DS preserved, others destroyed
 17242                                  ;---------------------------------------------------------------------------
 17243                                  
 17244                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 17245                                  
 17246                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 17247                                  
 17248                                  DOS_CLOSE:
 17249 00003ABA C43E[3605]              	LES	DI,[THISSFT]
 17250                                  	;mov	bx,[ES:DI+5]
 17251 00003ABE 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 17252                                  
 17253                                  ;	Network closes are handled entirely by the net code.
 17254                                  
 17255                                  	;test	bx,8000h
 17256 00003AC2 F7C30080                	TEST	BX,sf_isnet
 17257 00003AC6 7406                    	JZ	short LocalClose
 17258                                  
 17259                                  	;CallInstall Net_Close,MultNET,6
 17260 00003AC8 B80611                  	mov     ax, 1106h
 17261 00003ACB CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 17262                                  			; ES:DI -> SFT
 17263                                  			; SFT DPB field -> DPB of drive containing file
 17264                                  			; Return: CF set on error, AX = DOS error code
 17265                                  			; CF clear if successful
 17266 00003ACD C3                      	retn
 17267                                  
 17268                                  ;
 17269                                  ; All closes release the sharing information.
 17270                                  ; No commit releases sharing information
 17271                                  ;
 17272                                  ; All closes decrement the ref count.
 17273                                  ; No commit decrements the ref count.
 17274                                  ;
 17275                                  LocalClose:
 17276 00003ACE E892E5                  	call	EcritDisk
 17277 00003AD1 E80E01                  	CALL	SetSFTTimes
 17278 00003AD4 E89D00                  	CALL	FREE_SFT		; dec ref count or mark as busy
 17279                                  
 17280                                  ;hkn; SS is DOSDATA
 17281                                  	;Context DS
 17282 00003AD7 16                      	push	ss
 17283 00003AD8 1F                      	pop	ds
 17284                                  
 17285 00003AD9 50                      	push	ax
 17286 00003ADA 53                      	push	bx
 17287 00003ADB E87538                  	call	ShareEnd
 17288 00003ADE 5B                      	pop	bx
 17289 00003ADF 58                      	pop	ax
 17290                                  ;
 17291                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 17292                                  ;
 17293                                  CloseEntry:
 17294 00003AE0 50                      	PUSH	AX
 17295                                  ;
 17296                                  ; File clean or device does not get stamped nor disk looked at.
 17297                                  ;
 17298                                  	;test	bx,0C0h
 17299 00003AE1 F7C3C000                	TEST	BX,devid_file_clean+devid_device
 17300                                  	;JZ	short rdir
 17301                                  	;JMP	FREE_SFT_OK		; either clean or device
 17302 00003AE5 757A                    	jnz	short FREE_SFT_OK
 17303                                  ;
 17304                                  ; Retrieve the directory entry for the file
 17305                                  ;
 17306                                  rdir:
 17307 00003AE7 E89700                  	CALL	DirFromSFT
 17308                                  	;mov	al,5
 17309 00003AEA B005                    	MOV	AL,error_access_denied
 17310                                  	;JNC	short clook
 17311                                  	;JMP	CloseFinish		; pretend the close worked.
 17312 00003AEC 7274                    	jc	short CloseFinish
 17313                                  clook:
 17314                                  ;
 17315                                  ; ES:DI points to entry
 17316                                  ; DS:SI points to SFT
 17317                                  ; ES:BX points to buffer header
 17318                                  ;
 17319 00003AEE 57                      	push	di
 17320 00003AEF 56                      	push	si
 17321                                  	;lea	si,[si+20h] ; MSDOS 3.3
 17322 00003AF0 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 17323                                  ;
 17324                                  ; ES:DI point to directory entry
 17325                                  ; DS:SI point to unpacked name
 17326                                  ;
 17327 00003AF3 E883E4                  	call	XCHGP
 17328                                  ;
 17329                                  ; ES:DI point to unpacked name
 17330                                  ; DS:SI point to directory entry
 17331                                  ;
 17332 00003AF6 E85A0C                  	call	MetaCompare
 17333 00003AF9 E87DE4                  	call	XCHGP
 17334 00003AFC 5E                      	pop	si
 17335 00003AFD 5F                      	pop	di
 17336 00003AFE 740B                    	JZ	short CLOSE_GO		; Name OK
 17337                                  Bye:	
 17338 00003B00 89F7                    	MOV	DI,SI
 17339 00003B02 1E                      	PUSH	DS
 17340 00003B03 07                      	POP	ES			; ES:DI points to SFT
 17341 00003B04 16                      	PUSH	SS
 17342 00003B05 1F                      	POP	DS
 17343 00003B06 F9                      	STC
 17344                                  	;mov	al,2
 17345 00003B07 B002                    	MOV	AL,error_file_not_found
 17346 00003B09 EB57                    	JMP	short CloseFinish
 17347                                  
 17348                                  CLOSE_GO:
 17349                                  	; MSDOS 6.0
 17350                                  	;TEST	[SI+SF_ENTRY.sf_mode],sf_isFCB	; FCB ?
 17351                                  	;JZ	short nofcb		; no, set dir attr, sf_attr
 17352                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17353                                  	;mov	ch,[es:di+0Bh]
 17354 00003B0B 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 17355                                  	;mov	al,[si+4]
 17356 00003B0F 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr]
 17357                                  
 17358                                  ;hkn; SS override
 17359 00003B12 36A2[0605]              	MOV	[SS:ATTRIB],AL
 17360                                  	; MSDOS 3.3
 17361 00003B16 E8B90F                  	call	MatchAttributes
 17362 00003B19 75E5                    	JNZ	short Bye		; attributes do not match
 17363                                  	;JMP	SHORT setattr		;FT.
 17364                                  	; MSDOS 6.0
 17365                                  ;nofcb:
 17366                                  	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 17367                                  	;MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 17368                                  setattr:
 17369                                  	; MSDOS 3.3 (& MSDOS6.0)
 17370                                  	;or	byte [es:di+0Bh],20h
 17371 00003B1B 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 17372                                  	; MSDOS6.0
 17373                                  	;MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 17374                                  					;F.O. save old first cluster
 17375                                  ;hkn; SS override
 17376                                  	;MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 17377                                  
 17378                                  	;mov	ax,[si+0Bh]
 17379 00003B20 8B440B                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 17380                                  	;mov	[es:di+1Ah],ax
 17381 00003B23 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 17382                                  	;mov	ax,[si+11h]
 17383 00003B27 8B4411                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 17384                                  	;mov	[es:di+1Ch],ax
 17385 00003B2A 2689451C                	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 17386                                  	;mov	ax,[si+13h]
 17387 00003B2E 8B4413                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 17388                                  	;mov	[es:di+1Eh],ax
 17389 00003B31 2689451E                	MOV	[ES:DI+dir_entry.dir_size_h],AX
 17390                                  	;mov	ax,[si+0Fh]
 17391 00003B35 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 17392                                  	;mov	[es:di+18h],ax
 17393 00003B38 26894518                	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 17394                                  	;mov	ax,[si+0Dh]
 17395 00003B3C 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 17396                                  	;mov	[es:di+16h],ax
 17397 00003B3F 26894516                	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 17398                                  
 17399                                  	; MSDOS 6.0
 17400                                  ;; File Tagging
 17401                                  	;TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
 17402                                  	;			  ;LB. if already dirty		    ;AN000;
 17403                                  	;JNZ	short yesdirty	  ;LB.  don't increment dirty count ;AN000;
 17404                                  	;call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 17405                                  	; MSDOS 3.3 (& MSDOS6.0)
 17406                                  	;or	byte [es:bx+5],40h
 17407 00003B43 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 17408                                  yesdirty:
 17409 00003B48 1E                      	push	ds
 17410 00003B49 56                      	push	si
 17411                                  	; MSDOS 6.0
 17412                                  	;MOV	CX,[SI.sf_firclus]	; do this for Fastopen
 17413                                  
 17414                                  ;hkn; SS override
 17415                                  	;MOV	AL,[SS:THISDRV]
 17416                                  	; MSDOS3.3 
 17417 00003B4A 16                      	push	ss
 17418 00003B4B 1F                      	pop	ds
 17419 00003B4C A0[1105]                	MOV	AL,[THISDRV]
 17420                                  ;;; 10/1/86  update fastopen cache
 17421                                  	; MSDOS 3.3 (& MSDOS6.0)
 17422 00003B4F 52                      	PUSH	DX
 17423 00003B50 B400                    	MOV	AH,0			; dir entry update
 17424 00003B52 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 17425                                  	; MSDOS 6.0
 17426                                  	;OR	CX,CX			;AN005; first cluster 0; may be truncated
 17427                                  	;JNZ	short do_update2	;AN005; no, do update
 17428                                  	;MOV	AH,3			;AN005; do a delete cache entry
 17429                                  	;MOV	DI,[SI+SF_ENTRY.sf_dirsec]   ;AN005; cx:di = dir sector
 17430                                  	;MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 17431                                  	;MOV	DH,[SI+SF_ENTRY.sf_dirpos]   ;AN005; dh= dir pos
 17432                                  	;JMP	SHORT do_update 	;AN011;F.O.
 17433                                  ;do_update2:				;AN011;F.O.
 17434                                  ;hkn; SS override fort OLD_FIRSTCLUS
 17435                                  	;CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 17436                                  	;JZ	short do_update		;AN011;F.O. yes
 17437                                  	;MOV	AH,2			;AN011;F.O. delete the old entry
 17438                                  	;MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 17439                                  do_update:				;AN005;
 17440                                  ;hkn; SS is DOSDATA
 17441                                  	;Context DS
 17442                                  	;push	ss
 17443                                  	;pop	ds	
 17444                                  	; MSDOS 3.3 (& MSDOS6.0)
 17445 00003B54 E8B4F8                  	call	FastOpen_Update 	; invoke fastopen
 17446 00003B57 5A                      	POP	DX
 17447                                  
 17448                                  ;;; 10/1/86  update fastopen cache
 17449 00003B58 E8D523                  	call	FLUSHBUF		; flush all relevant buffers
 17450 00003B5B 5F                      	pop	di
 17451 00003B5C 07                      	pop	es
 17452                                  	;mov	al,5
 17453 00003B5D B005                    	MOV	AL,error_access_denied
 17454 00003B5F 7201                    	JC	short CloseFinish
 17455                                  FREE_SFT_OK:
 17456 00003B61 F8                      	CLC				; signal no error.
 17457                                  CloseFinish:
 17458                                  ;
 17459                                  ; Indicate to the device that the SFT is being closed.
 17460                                  ;
 17461                                  ;;;; 7/21/86
 17462 00003B62 9C                      	PUSHF				; save flag from DirFromSFT
 17463 00003B63 E81913                  	call	DEV_CLOSE_SFT
 17464 00003B66 9D                      	POPF
 17465                                  ;;;; 7/21/86
 17466                                  ;
 17467                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 17468                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 17469                                  ; going to be moving from busy to free.
 17470                                  ;
 17471 00003B67 59                      	POP	CX			; get old ref count
 17472 00003B68 9C                      	PUSHF
 17473 00003B69 49                      	DEC	CX			; if cx != 1
 17474 00003B6A 7503                    	JNZ	short NoFree		; then do NOT free SFT
 17475 00003B6C 26890D                  	mov	[es:di],cx
 17476                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 17477                                  NoFree:
 17478 00003B6F E8F9E4                  	call	LcritDisk
 17479 00003B72 9D                      	POPF
 17480 00003B73 C3                      	retn
 17481                                  
 17482                                  ;---------------------------------------------------------------------------
 17483                                  ;
 17484                                  ; Procedure Name : FREE_SFT
 17485                                  ;
 17486                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 17487                                  ; Flags preserved. Return old ref count in AX
 17488                                  ;
 17489                                  ; Note that busy is indicated by the SFT ref count being -1.
 17490                                  ;
 17491                                  ;---------------------------------------------------------------------------
 17492                                  
 17493                                  FREE_SFT:
 17494 00003B74 9C                      	PUSHF		; Save carry state
 17495 00003B75 268B05                  	mov	ax,[es:di]
 17496                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 17497 00003B78 48                      	DEC	AX
 17498 00003B79 7501                    	JNZ	short SetCount
 17499 00003B7B 48                      	DEC	AX
 17500                                  SetCount:
 17501 00003B7C 268705                  	xchg	ax,[es:di]
 17502                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 17503 00003B7F 9D                      	POPF
 17504 00003B80 C3                      	retn
 17505                                  
 17506                                  ;----------------------------------------------------------------------------
 17507                                  ;
 17508                                  ; Procedure Name : DirFromSFT
 17509                                  ;
 17510                                  ;   DirFromSFT - locate a directory entry given an SFT.
 17511                                  ;
 17512                                  ;   Inputs:	ES:DI point to SFT
 17513                                  ;		DS = DOSDATA
 17514                                  ;   Outputs:
 17515                                  ;		EXTERR_LOCUS = errLOC_Disk
 17516                                  ;		CurBuf points to buffer
 17517                                  ;		Carry Clear -> operation OK
 17518                                  ;		    ES:DI point to entry
 17519                                  ;		    ES:BX point to buffer
 17520                                  ;		    DS:SI point to SFT
 17521                                  ;		Carry SET   -> operation failed
 17522                                  ;		    registers trashified
 17523                                  ;   Registers modified: ALL
 17524                                  ;----------------------------------------------------------------------------
 17525                                  
 17526                                  DirFromSFT:
 17527                                  	;mov	byte [EXTERR_LOCUS],2
 17528 00003B81 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 17529 00003B86 06                      	push	es
 17530 00003B87 57                      	push	di
 17531                                  	; MSDOS 3.3
 17532                                  	;mov	dx,[es:di+1Dh]
 17533 00003B88 268B551D                	MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 17534                                  	; MSDOS 6.0
 17535                                  	;MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 17536                                  	;MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 17537                                  	;MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 17538                                  	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 17539                                  	; MSDOS 3.3 (& MSDOS6.0)
 17540 00003B8C 52                      	PUSH	DX
 17541 00003B8D E81C20                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 17542                                  					; [THISDPB] set
 17543 00003B90 5A                      	POP	DX
 17544                                  	;POP	word [HIGH_SECTOR]	;F.C. >32mb
 17545 00003B91 7225                    	JC	short PopDone
 17546 00003B93 30C0                    	XOR	AL,AL			; Pre read
 17547                                  	;mov	byte [ALLOWED],18h
 17548 00003B95 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 17549 00003B9A E8EB22                  	call	GETBUFFR
 17550 00003B9D 7219                    	JC	short PopDone
 17551 00003B9F 5E                      	pop	si
 17552 00003BA0 1F                      	pop	ds			; Get back SFT pointer
 17553                                  
 17554                                  ;hkn; SS override
 17555 00003BA1 36C43E[7405]            	LES	DI,[SS:CURBUF]
 17556                                  	;or	byte [es:di+5],4
 17557 00003BA6 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 17558 00003BAB 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 17559                                  	;lea	di,[di+10h]
 17560 00003BAD 8D7D10                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 17561                                  	;mov	al,32
 17562 00003BB0 B020                    	MOV	AL,dir_entry.size
 17563 00003BB2 F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 17564 00003BB5 01C7                    	ADD	DI,AX			; Point at the entry
 17565 00003BB7 C3                      	retn				; carry is clear
 17566                                  
 17567                                  PopDone:
 17568 00003BB8 5F                      	pop	di
 17569 00003BB9 07                      	pop	es
 17570                                  PopDone_retn:
 17571 00003BBA C3                      	retn
 17572                                  
 17573                                  ;----------------------------------------------------------------------------
 17574                                  ;
 17575                                  ;**	DOS_Commit - UPdate Directory Entries
 17576                                  ;
 17577                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 17578                                  ;		(DS) = DOSGROUP
 17579                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 17580                                  ;	USES	all but DS
 17581                                  ;
 17582                                  ;----------------------------------------------------------------------------
 17583                                  ;
 17584                                  
 17585                                  DOS_COMMIT:
 17586                                  	;hkn; called from srvcall. DS already set up.
 17587 00003BBB C43E[3605]              	LES	DI,[THISSFT]
 17588                                  	;mov	bx,[es:di+5]
 17589 00003BBF 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 17590                                  	;test	bx,0C0h
 17591 00003BC3 F7C3C000                	TEST	BX,devid_file_clean+devid_device ;Clears carry
 17592 00003BC7 75F1                    	jnz	short PopDone_retn
 17593                                  	;test	bx,8000h
 17594 00003BC9 F7C30080                	TEST	BX,sf_isnet
 17595 00003BCD 7406                    	JZ	short LOCAL_COMMIT
 17596                                  
 17597                                  ;IF NOT Installed
 17598                                  ;	transfer NET_COMMIT
 17599                                  ;ELSE
 17600                                  	;mov	ax,1107h
 17601 00003BCF B80711                  	MOV	AX,(MultNET<<8)|7
 17602 00003BD2 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 17603                                  			; ES:DI -> SFT
 17604                                  			; SFT DPB field -> DPB of drive containing file
 17605                                  			; Return: CF set on error, AX = DOS error code
 17606                                  			; CF clear if successful
 17607 00003BD4 C3                      	retn
 17608                                  ;ENDIF
 17609                                  
 17610                                  ;
 17611                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 17612                                  ; There are three ways we can do this.	One is to enter a critical section to
 17613                                  ; protect a potential free.  The second is to increment the ref count to mask
 17614                                  ; the close decrementing.
 17615                                  ;
 17616                                  ; The proper way is to let the caller's of close decide if a decrement should
 17617                                  ; be done.  We do this by providing another entry into close after the
 17618                                  ; decrement and after the share information release.
 17619                                  ;
 17620                                  LOCAL_COMMIT:
 17621 00003BD5 E88BE4                  	call	EcritDisk
 17622                                  	; MSDOS6.0
 17623                                  	;call	EcritDisk	;PTM.
 17624 00003BD8 E80700                  	call	SetSFTTimes
 17625 00003BDB B8FFFF                  	MOV	AX,-1
 17626 00003BDE E8FFFE                  	call	CloseEntry
 17627                                  	; MSDOS 6.0
 17628                                  	;PUSHF			;PTM.				;AN000;
 17629                                  	;call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 17630                                  	;POPF			;PTM.				;AN000;
 17631                                  	;call	LcritDisk	;PTM.				;AN000;
 17632                                  localcommit_retn:
 17633 00003BE1 C3                      	retn
 17634                                  
 17635                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 17636                                  ;----------------------------------------------------------------------------
 17637                                  ;
 17638                                  ; Procedure Name : SetSFTTimes
 17639                                  ;
 17640                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 17641                                  ;   Reflect these times in other SFT's for the same file.
 17642                                  ;
 17643                                  ;   Inputs:	ES:DI point to SFT
 17644                                  ;		BX = sf_flags set apprpriately
 17645                                  ;   Outputs:	Set sft times to current time iff File & dirty & !nodate
 17646                                  ;   Registers modified: All except ES:DI, BX, AX
 17647                                  ;
 17648                                  ;----------------------------------------------------------------------------
 17649                                  
 17650                                  SetSFTTimes:
 17651                                  ;	File clean or device does not get stamped nor disk looked at.
 17652                                  	
 17653                                  	;test	bx,0C0h
 17654 00003BE2 F7C3C000                	TEST	BX,devid_file_clean+devid_device
 17655                                  	;retnz				; clean or device => no timestamp
 17656 00003BE6 75F9                    	jnz	short localcommit_retn
 17657                                  
 17658                                  ;	file and dirty. See if date is good
 17659                                  
 17660                                  	;test	bx,4000h
 17661 00003BE8 F7C30040                	TEST	BX,sf_close_nodate
 17662                                  	;retnz				; nodate => no timestamp
 17663 00003BEC 75F3                    	jnz	short localcommit_retn
 17664                                  
 17665 00003BEE 50                      	push	ax
 17666 00003BEF 53                      	push	bx
 17667 00003BF0 E8C3DC                  	call	DATE16			; Date/Time to AX/DX
 17668                                  	;mov	[es:di+0Fh],ax
 17669 00003BF3 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 17670                                  	;mov	[es:di+0Dh],dx
 17671 00003BF7 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 17672 00003BFB 31C0                    	XOR	AX,AX
 17673                                  ;if installed
 17674                                  	;call	JShare + 14 * 4
 17675 00003BFD FF1E[9400]              	call	far [JShare+(14*4)]	; 14 = ShSU
 17676                                  ;else
 17677                                  ;	call	ShSU
 17678                                  ;endif
 17679 00003C01 5B                      	pop	bx
 17680 00003C02 58                      	pop	ax
 17681 00003C03 C3                      	retn
 17682                                  
 17683                                  ;============================================================================
 17684                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 17685                                  ;============================================================================
 17686                                  ; 23/07/2018 - Retro DOS v3.0
 17687                                  
 17688                                  ;TITLE DIRCALL - Directory manipulation internal calls
 17689                                  ;NAME  DIRCALL
 17690                                  
 17691                                  ;**	Low level directory manipulation routines for making removing and
 17692                                  ;	  verifying local or NET directories
 17693                                  ;
 17694                                  ;	DOS_MKDIR
 17695                                  ;	DOS_CHDIR
 17696                                  ;	DOS_RMDIR
 17697                                  ;
 17698                                  ;	Modification history:
 17699                                  ;
 17700                                  ;		Created: ARR 30 March 1983
 17701                                  
 17702                                  ;BREAK <DOS_MkDir - Make a directory entry>
 17703                                  ;---------------------------------------------------------------------------
 17704                                  ;
 17705                                  ; Procedure Name : DOS_MkDir
 17706                                  ;
 17707                                  ; Inputs:
 17708                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17709                                  ;		terminated)
 17710                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17711                                  ;		( = -1 if current dir not involved, else
 17712                                  ;		 Points to first char after last "/" of current dir part)
 17713                                  ;	[THISCDS] Points to CDS being used
 17714                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17715                                  ; Function:
 17716                                  ;	Make a new directory
 17717                                  ; Returns:
 17718                                  ;	Carry Clear
 17719                                  ;		No error
 17720                                  ;	Carry Set
 17721                                  ;	    AX is error code
 17722                                  ;		error_path_not_found
 17723                                  ;			Bad path (not in curr dir part if present)
 17724                                  ;		error_bad_curr_dir
 17725                                  ;			Bad path in current directory part of path
 17726                                  ;		error_access_denied
 17727                                  ;			Already exists, device name
 17728                                  ; DS preserved, Others destroyed
 17729                                  ;---------------------------------------------------------------------------
 17730                                  
 17731                                  ;hkn; called from path.asm. DS already set up.
 17732                                  
 17733                                  DOS_MKDIR:
 17734 00003C04 E8BEE3                  	call	TestNet
 17735 00003C07 7314                    	JNC	short LOCAL_MKDIR
 17736                                  
 17737                                  ;IF NOT Installed
 17738                                  ;	transfer NET_MKDIR
 17739                                  ;ELSE
 17740                                  	;mov	ax,1103h
 17741 00003C09 B80311                  	MOV	AX,(MultNET<<8)|3
 17742 00003C0C CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 17743                                  			; SS = DOS CS
 17744                                  			; SDA first filename pointer -> fully-qualified directory name
 17745                                  			; SDA CDS pointer -> current directory
 17746                                  			; Return: CF set on error, AX = DOS error code
 17747                                  			; CF clear if successful
 17748 00003C0E C3                      	retn
 17749                                  ;ENDIF
 17750                                  
 17751                                  NODEACCERRJ:
 17752                                  	;mov	ax,5
 17753 00003C0F B80500                  	MOV	AX,error_access_denied
 17754                                  _BadRet:
 17755 00003C12 F9                      	STC
 17756 00003C13 E855E4                  	call	LcritDisk
 17757 00003C16 C3                      	retn
 17758                                  
 17759                                  PATHNFJ:
 17760 00003C17 E851E4                  	call	LcritDisk
 17761 00003C1A E920FB                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 17762                                  
 17763                                  LOCAL_MKDIR:
 17764 00003C1D E843E4                  	call	EcritDisk
 17765                                  ;
 17766                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 17767                                  ;
 17768 00003C20 8C16[3805]              	MOV	[THISSFT+2],SS
 17769                                  
 17770                                  ;hkn; DOSDATA
 17771 00003C24 C706[3605][E003]        	MOV	WORD [THISSFT],RENBUF
 17772                                  ;
 17773                                  ;  NOTE: Need WORD PTR because MASM takes type of
 17774                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 17775                                  ;
 17776 00003C2A C706[1304]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 17777                                  				; make sure SHARER won't complain.
 17778                                  	;mov	al,10h
 17779 00003C30 B010                    	MOV	AL,attr_directory
 17780 00003C32 E8FA13                  	call	MakeNode
 17781 00003C35 72E0                    	JC	short PATHNFJ
 17782 00003C37 83F803                  	CMP	AX,3
 17783 00003C3A 74D3                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 17784 00003C3C C42E[2405]              	LES	BP,[THISDPB]	; Makenode zaps this
 17785 00003C40 C53E[7405]              	LDS	DI,[CURBUF]
 17786 00003C44 29FE                    	SUB	SI,DI
 17787 00003C46 56                      	PUSH	SI		; Pointer to dir_first
 17788                                  	; MSDOS 6.0
 17789                                  	;PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 17790                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17791                                  	;push	word [di+6]
 17792 00003C47 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 17793 00003C4A 16                      	push	ss
 17794 00003C4B 1F                      	pop	ds
 17795 00003C4C FF36[5805]              	PUSH	word [DIRSTART]	; Parent for .. entry
 17796 00003C50 31C0                    	XOR	AX,AX
 17797 00003C52 A3[5805]                	MOV	[DIRSTART],AX	; Null directory
 17798 00003C55 E81B13                  	call	NEWDIR
 17799 00003C58 7260                    	JC	short NODEEXISTSPOPDEL ; No room
 17800 00003C5A E8540B                  	call	GETENT		; First entry
 17801 00003C5D 725B                    	JC	short NODEEXISTSPOPDEL ; Screw up
 17802 00003C5F C43E[7405]              	LES	DI,[CURBUF]
 17803                                  
 17804                                  	; MSDOS 6.0
 17805                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 17806                                  	;			 ;LB. if already dirty		    ;AN000;
 17807                                  	;JNZ	short yesdirty_	 ;LB.   don't increment dirty count ;AN000;
 17808                                  	;call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 17809                                  	
 17810                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17811                                  	;or	byte [es:di+5],40h
 17812 00003C63 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 17813                                  ;yesdirty_:
 17814                                  	;add	di,16
 17815 00003C68 83C710                  	ADD	DI,BUFINSIZ	; Point at buffer
 17816 00003C6B B82E20                  	MOV	AX,202EH	; ". "
 17817 00003C6E 8B16[5805]              	MOV	DX,[DIRSTART]	; Point at itself
 17818 00003C72 E89613                  	call	SETDOTENT
 17819 00003C75 B82E2E                  	MOV	AX,2E2EH	; ".."
 17820 00003C78 5A                      	POP	DX		; Parent
 17821 00003C79 E88F13                  	call	SETDOTENT
 17822 00003C7C C42E[2405]              	LES	BP,[THISDPB]
 17823                                  	;mov	byte [ALLOWED],18h
 17824 00003C80 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 17825 00003C85 5A                      	POP	DX		; Entry sector
 17826                                  	; MSDOS 6.0
 17827                                  	;POP	word [HIGH_SECTOR] ;F.C. >32mb
 17828                                  
 17829 00003C86 30C0                    	XOR	AL,AL		; Pre read
 17830 00003C88 E8FD21                  	call	GETBUFFR
 17831 00003C8B 7256                    	JC	short NODEEXISTSP
 17832 00003C8D 8B16[5805]              	MOV	DX,[DIRSTART]
 17833 00003C91 C53E[7405]              	LDS	DI,[CURBUF]
 17834                                  	;or	byte [di+5],4
 17835 00003C95 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 17836 00003C99 5E                      	POP	SI		; dir_first pointer
 17837 00003C9A 01FE                    	ADD	SI,DI
 17838 00003C9C 8914                    	MOV	[SI],DX
 17839 00003C9E 31D2                    	XOR	DX,DX
 17840 00003CA0 895402                  	MOV	[SI+2],DX	; Zero size
 17841 00003CA3 895404                  	MOV	[SI+4],DX
 17842                                  DIRUP:
 17843                                  	; MSDOS 6.0
 17844                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 17845                                  	;			 ;LB. if already dirty 		   ;AN000;
 17846                                  	;JNZ	short yesdirty2	 ;LB.  don't increment dirty count ;AN000;
 17847                                  	;call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 17848                                  	
 17849                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17850                                  	;or	byte [di+5],40h
 17851 00003CA6 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 17852                                  ;yesdirty2:
 17853 00003CAA 16                      	push	ss
 17854 00003CAB 1F                      	pop	ds
 17855 00003CAC 268A4600                	mov	al,[es:bp]
 17856                                  	; 18/05/2019
 17857                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 17858 00003CB0 E87D22                  	call	FLUSHBUF
 17859                                  	;mov	ax,5
 17860 00003CB3 B80500                  	MOV	AX,error_access_denied
 17861 00003CB6 E8B2E3                  	call	LcritDisk
 17862 00003CB9 C3                      	retn
 17863                                  
 17864                                  NODEEXISTSPOPDEL:
 17865 00003CBA 5A                      	POP	DX		; Parent
 17866 00003CBB 5A                      	POP	DX		; Entry sector
 17867                                  	; MSDOS 6.0 
 17868                                  	;POP	word [HIGH_SECTOR] ; F.C. >32mb
 17869 00003CBC C42E[2405]              	LES	BP,[THISDPB]
 17870                                  	;mov	byte [ALLOWED],18h
 17871 00003CC0 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 17872 00003CC5 30C0                    	XOR	AL,AL		; Pre read
 17873 00003CC7 E8BE21                  	call	GETBUFFR
 17874 00003CCA 7217                    	JC	short NODEEXISTSP
 17875 00003CCC C53E[7405]              	LDS	DI,[CURBUF]
 17876                                  	;or	byte [di+5],4
 17877 00003CD0 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 17878 00003CD4 5E                      	POP	SI		; dir_first pointer
 17879 00003CD5 01FE                    	ADD	SI,DI
 17880                                  	;sub	si,1Ah ; 26
 17881 00003CD7 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 17882 00003CDA C604E5                  	MOV	BYTE [SI],0E5H	; Free the entry
 17883 00003CDD E8C6FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 17884                                  NODEEXISTS:
 17885 00003CE0 E92CFF                  	JMP	NODEACCERRJ ; 10/08/2018
 17886                                  
 17887                                  NODEEXISTSP:
 17888 00003CE3 5E                      	POP	SI		; Clean stack
 17889 00003CE4 EBFA                    	JMP	short NODEEXISTS
 17890                                  
 17891                                  ;BREAK <DOS_ChDir -- Verify a directory>
 17892                                  ;----------------------------------------------------------------------------
 17893                                  ;
 17894                                  ; Procedure Name : DOS_ChDir
 17895                                  ;
 17896                                  ; Inputs:
 17897                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17898                                  ;		terminated)
 17899                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17900                                  ;		( = -1 if current dir not involved, else
 17901                                  ;		 Points to first char after last "/" of current dir part)
 17902                                  ;	[THISCDS] Points to CDS being used May not be NUL
 17903                                  ; Function:
 17904                                  ;	Validate the path for potential new current directory
 17905                                  ; Returns:
 17906                                  ;	NOTE:
 17907                                  ;	    [SATTRIB] is modified by this call
 17908                                  ;	Carry Clear
 17909                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 17910                                  ;		Caller must NOT set ID fields on a NET CDS.
 17911                                  ;	Carry Set
 17912                                  ;	    AX is error code
 17913                                  ;		error_path_not_found
 17914                                  ;			Bad path
 17915                                  ;		error_access_denied
 17916                                  ;			device or file name
 17917                                  ; DS preserved, Others destroyed
 17918                                  ;----------------------------------------------------------------------------
 17919                                  
 17920                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 17921                                  
 17922                                  DOS_CHDIR:
 17923 00003CE6 E8DCE2                  	call	TestNet
 17924 00003CE9 7306                    	JNC	short LOCAL_CHDIR
 17925                                  
 17926                                  ;IF NOT Installed
 17927                                  ;	transfer NET_CHDIR
 17928                                  ;ELSE
 17929                                  	;mov	ax,1105h
 17930 00003CEB B80511                  	MOV	AX,(MultNET<<8)|5
 17931 00003CEE CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 17932                                  			; SS = DOS CS
 17933                                  			; SDA first filename pointer -> fully-qualified directory name
 17934                                  			; SDA CDS pointer -> current directory
 17935                                  			; Return: CF set on error, AX = DOS error code
 17936                                  			; CF clear if successful
 17937 00003CF0 C3                      	retn
 17938                                  ;ENDIF
 17939                                  
 17940                                  LOCAL_CHDIR:
 17941 00003CF1 E86FE3                  	call	EcritDisk
 17942                                  	; MSDOS 6.0
 17943                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 17944                                  	;JZ	short nojoin			   ;PTM.
 17945                                  	;MOV	word [ES:DI+curdir.ID],0FFFFH	   ;PTM.
 17946                                  ;nojoin:
 17947                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17948 00003CF4 C606[F802]00            	MOV	byte [NoSetDir],0 ; FALSE
 17949                                  	;mov	byte [SATTRIB],16h
 17950 00003CF9 C606[0805]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 17951                                  				; Dir calls can find these
 17952                                  ; DOS 3.3  6/24/86 FastOpen
 17953 00003CFE 800E[6E0F]01            	OR	byte [FastOpenFlg],FastOpen_Set	   ; set fastopen flag
 17954 00003D03 E82E0B                  	call	GETPATH
 17955                                  	;PUSHF							;AN000;
 17956                                  	;AND	byte [FastOpenFlg],Fast_yes	   ; clear it all ;AC000;
 17957                                  	;POPF							;AN000;
 17958                                  ; DOS 3.3  6/24/86 FastOpen
 17959                                  
 17960                                  	; MSDOS 3.3
 17961 00003D06 C606[6E0F]00            	mov	byte [FastOpenFlg],0
 17962                                  	;mov	ax,3
 17963 00003D0B B80300                  	MOV	AX,error_path_not_found
 17964 00003D0E 7207                    	JC	short ChDirDone
 17965 00003D10 753A                    	JNZ	short NOTDIRPATH	; Path not a DIR
 17966 00003D12 8B0E[5805]              	MOV	CX,[DIRSTART]		; Get cluster number
 17967 00003D16 F8                      	CLC
 17968                                  ChDirDone:
 17969 00003D17 E851E3                  	call	LcritDisk
 17970 00003D1A C3                      	retn
 17971                                  
 17972                                  ;BREAK <DOS_RmDir -- Remove a directory>
 17973                                  ;----------------------------------------------------------------------------
 17974                                  ;
 17975                                  ; Procedure Name : DOS_RmDir
 17976                                  ;
 17977                                  ; Inputs:
 17978                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17979                                  ;		terminated)
 17980                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17981                                  ;		( = -1 if current dir not involved, else
 17982                                  ;		 Points to first char after last "/" of current dir part)
 17983                                  ;	[THISCDS] Points to CDS being used
 17984                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17985                                  ; Function:
 17986                                  ;	Remove a directory
 17987                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 17988                                  ; Returns:
 17989                                  ;	NOTE:
 17990                                  ;	    [SATTRIB] is modified by this call
 17991                                  ;	Carry Clear
 17992                                  ;		No error
 17993                                  ;	Carry Set
 17994                                  ;	    AX is error code
 17995                                  ;		error_path_not_found
 17996                                  ;			Bad path (not in curr dir part if present)
 17997                                  ;		error_bad_curr_dir
 17998                                  ;			Bad path in current directory part of path
 17999                                  ;		error_access_denied
 18000                                  ;			device or file name, root directory
 18001                                  ;			Bad directory ('.' '..' messed up)
 18002                                  ; DS preserved, Others destroyed
 18003                                  ;----------------------------------------------------------------------------
 18004                                  
 18005                                  ;hkn; called from path.asm. DS already set up.
 18006                                  
 18007                                  DOS_RMDIR:
 18008 00003D1B E8A7E2                  	call	TestNet
 18009 00003D1E 7306                    	JNC	short LOCAL_RMDIR
 18010                                  
 18011                                  ;IF NOT Installed
 18012                                  ;	transfer NET_RMDIR
 18013                                  ;ELSE
 18014                                  	;mov	ax,1101h
 18015 00003D20 B80111                  	MOV	AX,(MultNET<<8)|1
 18016 00003D23 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 18017                                  			; SS = DOS CS
 18018                                  			; SDA first filename pointer -> fully-qualified directory name
 18019                                  			; SDA CDS pointer -> current directory
 18020                                  			; Return: CF set on error, AX = DOS error code
 18021                                  			; CF clear if successful
 18022 00003D25 C3                      	retn
 18023                                  ;ENDIF
 18024                                  
 18025                                  LOCAL_RMDIR:
 18026 00003D26 E83AE3                  	call	EcritDisk
 18027 00003D29 C606[F802]00            	MOV	byte [NoSetDir],0
 18028                                  	;mov	byte [SATTRIB],16h
 18029 00003D2E C606[0805]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 18030                                  					; Dir calls can find these
 18031 00003D33 E8FE0A                  	call	GETPATH
 18032 00003D36 720C                    	JC	short NOPATH		; Path not found
 18033 00003D38 7512                    	JNZ	short NOTDIRPATH	; Path not a DIR
 18034 00003D3A 8B3E[5805]              	MOV	DI,[DIRSTART]
 18035 00003D3E 09FF                    	OR	DI,DI			; Root ?
 18036 00003D40 750D                    	JNZ	short rmdir_get_buf	; No
 18037 00003D42 EB08                    	JMP	SHORT NOTDIRPATH
 18038                                  
 18039                                  NOPATH:
 18040                                  	;mov	ax,3
 18041 00003D44 B80300                  	MOV	AX,error_path_not_found
 18042 00003D47 E9C8FE                  	JMP	_BadRet
 18043                                  
 18044                                  NOTDIRPATHPOP:
 18045                                  	; MSDOS 6.0
 18046                                  	;POP	AX			  ;F.C. >32mb
 18047 00003D4A 58                      	POP	AX
 18048                                  NOTDIRPATHPOP2:
 18049 00003D4B 58                      	POP	AX
 18050                                  NOTDIRPATH:
 18051 00003D4C E9C0FE                  	JMP	NODEACCERRJ
 18052                                  
 18053                                  rmdir_get_buf:
 18054 00003D4F C53E[7405]              	LDS	DI,[CURBUF]
 18055 00003D53 29FB                    	SUB	BX,DI		; Compute true offset
 18056 00003D55 53                      	PUSH	BX		; Save entry pointer
 18057                                  	
 18058                                  	; MSDOS 6.0
 18059                                  	;PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 18060                                  	
 18061                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18062                                  	;push	word [di+6]
 18063 00003D56 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 18064                                  
 18065                                  ;hkn; SS is DOSDATA
 18066                                  	;context DS
 18067 00003D59 16                      	push	ss
 18068 00003D5A 1F                      	pop	ds
 18069                                  	;context ES
 18070 00003D5B 16                      	push	ss
 18071 00003D5C 07                      	pop	es
 18072                                  
 18073                                  ;hkn; NAME1 is in DOSDATA
 18074 00003D5D BF[E604]                	MOV	DI,NAME1
 18075 00003D60 B03F                    	MOV	AL,'?'
 18076 00003D62 B90B00                  	MOV	CX,11
 18077 00003D65 F3AA                    	REP	STOSB
 18078 00003D67 30C0                    	XOR	AL,AL
 18079 00003D69 AA                      	STOSB				; Nul terminate it
 18080 00003D6A E8510D                  	call	STARTSRCH		; Set search
 18081 00003D6D E83E0A                  	call	GETENTRY		; Get start of directory
 18082 00003D70 72D8                    	JC	short NOTDIRPATHPOP	; Screw up
 18083 00003D72 8E1E[7605]              	MOV	DS,[CURBUF+2]
 18084 00003D76 89DE                    	MOV	SI,BX
 18085 00003D78 AD                      	LODSW
 18086                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 18087 00003D79 3D2E20                  	cmp	ax,202Eh ; ". "
 18088 00003D7C 75CC                    	JNZ	short NOTDIRPATHPOP	; Nope
 18089                                  	;add     si,30
 18090 00003D7E 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 18091 00003D81 AD                      	LODSW
 18092                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 18093                                  	;cmp	ax, '..'
 18094 00003D82 3D2E2E                  	cmp	ax,2E2Eh
 18095 00003D85 75C3                    	JNZ	short NOTDIRPATHPOP	; Nope
 18096                                  
 18097                                  ;hkn; SS is DOSDATA
 18098                                  	;context DS
 18099 00003D87 16                      	push	ss
 18100 00003D88 1F                      	pop	ds
 18101 00003D89 C706[F402]0200          	MOV	word [LASTENT],2	; Skip . and ..
 18102 00003D8F E81C0A                  	call	GETENTRY		; Get next entry
 18103 00003D92 72B6                    	JC	short NOTDIRPATHPOP	; Screw up
 18104                                  	;mov	byte [ATTRIB],16h
 18105 00003D94 C606[0605]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 18106 00003D99 E81F09                  	call	SRCH			; Do a search
 18107 00003D9C 73AC                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 18108 00003D9E 803E[F602]00            	CMP	byte [FAILERR],0
 18109 00003DA3 75A5                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 18110 00003DA5 C42E[2405]              	LES	BP,[THISDPB]
 18111 00003DA9 8B1E[5805]              	MOV	BX,[DIRSTART]
 18112 00003DAD E83C17                  	call	RELEASE 		; Release data in sub dir
 18113 00003DB0 7298                    	JC	short NOTDIRPATHPOP	; Screw up
 18114 00003DB2 5A                      	POP	DX			; Sector # of entry
 18115                                  	;POP	word [HIGH_SECTOR]	; F.C. >32mb
 18116                                  	;mov	byte [ALLOWED],18h
 18117 00003DB3 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 18118 00003DB8 30C0                    	XOR	AL,AL			; Pre read
 18119 00003DBA E8CB20                  	call	GETBUFFR		; Get sector back
 18120 00003DBD 728C                    	JC	short NOTDIRPATHPOP2	; Screw up
 18121 00003DBF C53E[7405]              	LDS	DI,[CURBUF]
 18122                                  	;or	byte [di+5],4
 18123 00003DC3 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 18124 00003DC7 5B                      	POP	BX			; Pointer to start of entry
 18125 00003DC8 01FB                    	ADD	BX,DI			; Corrected
 18126 00003DCA C607E5                  	MOV	BYTE [BX],0E5H		; Free the entry
 18127                                  
 18128                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 18129 00003DCD 1E                      	PUSH	DS
 18130                                  
 18131                                  ;hkn; SS is DOSDATA
 18132                                  	;context DS
 18133 00003DCE 16                      	push	ss
 18134 00003DCF 1F                      	pop	ds
 18135                                  
 18136                                  	; MSDOS 6.0
 18137                                  	;call	FastOpen_Delete 	; call fastopen to delete an entry
 18138                                  
 18139                                  	; MSDOS 3.3
 18140                                  _FastOpen_Delete:
 18141 00003DD0 50                      	push	ax
 18142 00003DD1 8B36[4A05]              	mov	si,[WFP_START]
 18143 00003DD5 BB[430F]                	mov	bx,FastTable
 18144                                  	;mov	al,3  ; FONC_delete
 18145 00003DD8 B003                    	mov	al,FONC_delete
 18146 00003DDA FF5F02                  	call	far [BX+2]  ; FastTable+2
 18147 00003DDD 58                      	pop	ax
 18148                                  
 18149 00003DDE 1F                      	POP	DS
 18150                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 18151                                  
 18152 00003DDF E9C4FE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 18153                                  
 18154                                  ;============================================================================
 18155                                  ; DISK.ASM, MSDOS 6.0, 1991
 18156                                  ;============================================================================
 18157                                  ; 23/07/2018 - Retro DOS v3.0 
 18158                                  
 18159                                  ;	TITLE	DISK - Disk utility routines
 18160                                  ;	NAME	Disk
 18161                                  
 18162                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 18163                                  ;
 18164                                  ;	SWAPCON
 18165                                  ;	SWAPBACK
 18166                                  ;	DOS_READ
 18167                                  ;	DOS_WRITE
 18168                                  ;	get_io_sft
 18169                                  ;	DirRead
 18170                                  ;	FIRSTCLUSTER
 18171                                  ;	SET_BUF_AS_DIR
 18172                                  ;	FATSecRd
 18173                                  ;	DREAD
 18174                                  ;	CHECK_WRITE_LOCK
 18175                                  ;	CHECK_READ_LOCK
 18176                                  ;
 18177                                  ;	Revision history:
 18178                                  ;
 18179                                  ;		A000   version 4.00  Jan. 1988
 18180                                  ;
 18181                                  ;----------------------------------------------------------------------------
 18182                                  ;
 18183                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 18184                                  ;		error happens, DOS retries the entire block assuming that
 18185                                  ;		zero characters were transferred. Modified the code to take
 18186                                  ;		into account the number of characters transfered before
 18187                                  ;		retrying the operation.
 18188                                  ;
 18189                                  ;----------------------------------------------------------------------------
 18190                                  ;
 18191                                  
 18192                                  ;Installed = TRUE
 18193                                  
 18194                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 18195                                  
 18196                                  ; **** Drivers for file input from devices ****
 18197                                  ;----------------------------------------------------------------------------
 18198                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 18199                                  ;   of handles 0 and 1
 18200                                  ;
 18201                                  ;   Inputs:	DS is DOSDATA
 18202                                  ;   Outputs:	CONSWAP is set to false.
 18203                                  ;   Registers modified: none
 18204                                  ;----------------------------------------------------------------------------
 18205                                  
 18206                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 18207                                  
 18208                                  SWAPBACK:
 18209 00003DE2 C606[0303]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 18210 00003DE7 C3                      	retn
 18211                                  
 18212                                  ;----------------------------------------------------------------------------
 18213                                  ;
 18214                                  ; Procedure Name : SWAPCON
 18215                                  ;
 18216                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 18217                                  ;
 18218                                  ;   Inputs:	ThisSFT as the sft of the desired file
 18219                                  ;		DS is DOSDATA
 18220                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 18221                                  ;   Registers modified: none
 18222                                  ;--------------------------------------------------------------------------
 18223                                  
 18224                                  SWAPCON:
 18225                                  	; MSDOS 3.3
 18226                                  	;push	es
 18227                                  	;push	di
 18228                                  	;mov	byte [CONSWAP],1
 18229                                  	;les	di,[THISSFT]
 18230                                  	;mov	word [CONSFT],di
 18231                                  	;mov	word [CONSFT+2],es
 18232                                  	;pop	di
 18233                                  	;pop	es
 18234                                  	;retn
 18235                                  
 18236                                  	; MSDOS 6.0
 18237 00003DE8 C606[0303]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 18238 00003DED 50                      	push	ax
 18239 00003DEE A1[3605]                	mov	ax,[THISSFT]
 18240 00003DF1 A3[7805]                	mov	[CONSFT],ax
 18241 00003DF4 A1[3805]                	mov	ax,[THISSFT+2]
 18242 00003DF7 A3[7A05]                	mov	[CONSFT+2],ax
 18243 00003DFA 58                      	pop	ax
 18244 00003DFB C3                      	retn
 18245                                  
 18246                                  
 18247                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 18248                                  ;-----------------------------------------------------------------------------
 18249                                  ;
 18250                                  ; Inputs:
 18251                                  ;	ThisSFT set to the SFT for the file being used
 18252                                  ;	[DMAADD] contains transfer address
 18253                                  ;	CX = No. of bytes to read
 18254                                  ;	DS = DOSDATA
 18255                                  ; Function:
 18256                                  ;	Perform read operation
 18257                                  ; Outputs:
 18258                                  ;    Carry clear
 18259                                  ;	SFT Position and cluster pointers updated
 18260                                  ;	CX = No. of bytes read
 18261                                  ;	ES:DI point to SFT
 18262                                  ;    Carry set
 18263                                  ;	AX is error code
 18264                                  ;	CX = 0
 18265                                  ;	ES:DI point to SFT
 18266                                  ; DS preserved, all other registers destroyed
 18267                                  ;
 18268                                  ;-----------------------------------------------------------------------------
 18269                                  
 18270                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 18271                                  
 18272                                  DOS_READ:
 18273 00003DFC C43E[3605]              	LES	DI,[THISSFT]
 18274                                  
 18275                                  ; Verify that the sft has been opened in a mode that allows reading.
 18276                                  
 18277                                  	;mov	al,[es:di+2]
 18278 00003E00 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 18279                                  	;and	al,0Fh
 18280 00003E04 240F                    	AND	AL,access_mask
 18281                                  	;cmp	al,1
 18282 00003E06 3C01                    	CMP	AL,open_for_write
 18283 00003E08 7503                    	JNE	short READ_NO_MODE		;Is read or both
 18284 00003E0A E94205                  	jmp	SET_ACC_ERR
 18285                                  
 18286                                  READ_NO_MODE:
 18287 00003E0D E81904                  	call	SETUP
 18288 00003E10 E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 18289 00003E12 E8C5E1                  	call	IsSFTNet
 18290 00003E15 7408                    	JZ	short LOCAL_READ
 18291                                  
 18292                                  ;IF NOT Installed
 18293                                  ;	transfer NET_READ
 18294                                  ;ELSE
 18295                                  	;mov	ax,1108h
 18296 00003E17 B80811                  	MOV	AX,(MultNET<<8)|8
 18297 00003E1A CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 18298                                  			; ES:DI -> SFT
 18299                                  			; SFT DPB field -> DPB of drive containing file
 18300                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 18301                                  			; Return: CF set on error, CX = bytes read
 18302 00003E1C C3                      	retn
 18303                                  ;ENDIF
 18304                                  
 18305                                  ; The user ended up requesting 0 bytes of input.  We do nothing for this case
 18306                                  ; except return immediately.
 18307                                  
 18308                                  NoIORet:
 18309 00003E1D F8                      	CLC
 18310 00003E1E C3                      	retn
 18311                                  
 18312                                  LOCAL_READ:
 18313                                  	;test	word [es:di+5],80h
 18314 00003E1F 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 18315 00003E25 750F                    	JNZ	short READDEV
 18316                                  	;mov	byte [EXTERR_LOCUS],2
 18317 00003E27 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18318 00003E2C E834E2                  	call	EcritDisk
 18319 00003E2F E8D804                  	call	DISKREAD
 18320                                  
 18321                                  critexit:
 18322 00003E32 E836E2                  	call	LcritDisk
 18323 00003E35 C3                      	retn
 18324                                  
 18325                                  ; We are reading from a device. Examine the status of the device to see if we
 18326                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 18327                                  ; null device, we can safely indicate no transfer.
 18328                                  
 18329                                  READDEV:
 18330                                  	;mov	byte [EXTERR_LOCUS],4
 18331 00003E36 C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 18332                                  	;mov	bl,[es:di+5]
 18333 00003E3B 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 18334 00003E3F C43E[DA02]              	LES	DI,[DMAADD]
 18335                                  	;test	bl,40h
 18336 00003E43 F6C340                  	test	BL,devid_device_EOF	; End of file?
 18337 00003E46 7407                    	JZ	short ENDRDDEVJ3
 18338                                  	;test	bl,4
 18339 00003E48 F6C304                  	test	BL,devid_device_null	; NUL device?
 18340 00003E4B 7405                    	JZ	short TESTRAW 		; NO
 18341 00003E4D 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 18342                                  ENDRDDEVJ3:
 18343 00003E4F E9BC00                  	JMP	ENDRDDEVJ2
 18344                                  
 18345                                  ;
 18346                                  ; We need to hit the device.  Figure out if we do a raw read or we do the
 18347                                  ; bizarre std_con_string_input.
 18348                                  ;
 18349                                  TESTRAW:
 18350                                  	;test	bl,20h
 18351 00003E52 F6C320                  	test	BL,devid_device_raw	; Raw mode?
 18352 00003E55 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 18353                                  	;test	bl,1
 18354 00003E57 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 18355 00003E5A 7447                    	JZ	short NOTRDCON
 18356 00003E5C E9E500                  	JMP	READCON
 18357                                  
 18358                                  DVRDRAW:
 18359 00003E5F 06                      	PUSH	ES
 18360 00003E60 1F                      	POP	DS			; Xaddr to DS:DI
 18361                                  
 18362                                  	; MSDOS 6.0
 18363                                  ;SR;
 18364                                  ;Check for win386 presence -- if present, do polled read of characters
 18365                                  ;
 18366                                  	;test	byte [ss:IsWIN386],1
 18367                                  	;jz	short ReadRawRetry	;not present
 18368                                  	;test	bl,devid_device_con_in	;is it console device
 18369                                  	;jz	short ReadRawRetry	;no, do normal read
 18370                                  	;jmp	do_polling		;yes, do win386 polling loop
 18371                                  
 18372                                  ReadRawRetry:
 18373 00003E61 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 18374 00003E63 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 18375 00003E65 89C2                    	MOV	DX,AX			; Start at 0
 18376 00003E67 E8B710                  	call	SETREAD
 18377 00003E6A 1E                      	PUSH	DS			; Save Seg part of Xaddr
 18378                                  
 18379                                  ;hkn; SS override
 18380 00003E6B 36C536[3605]            	LDS	SI,[SS:THISSFT]
 18381 00003E70 E88710                  	call	DEVIOCALL
 18382 00003E73 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 18383 00003E75 B486                    	MOV	AH,86H			; Read error
 18384                                  
 18385                                  ;hkn; SS override
 18386 00003E77 368B3E[0903]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 18387                                  	; MSDOS 3.3
 18388                                  	;test	di,8000h
 18389                                  	;jz	short CRDROK
 18390                                  	; MSDOS 6.0
 18391 00003E7C 09FF                    	or	di,di
 18392 00003E7E 7919                    	jns	short CRDROK		; no errors
 18393                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18394 00003E80 E8AA19                  	call	CHARHARD
 18395 00003E83 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 18396                                  
 18397                                  	; MSDOS 6.0
 18398                                  	;add	di,[ss:callscnt]	; update ptr and count to reflect the	M065
 18399                                  	;sub	cx,[ss:callscnt]	; number of chars xferred		M065
 18400                                  
 18401                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18402 00003E85 08C0                    	OR	AL,AL
 18403 00003E87 7410                    	JZ	short CRDROK		; Ignore
 18404 00003E89 3C03                    	CMP	AL,3
 18405 00003E8B 7403                    	JZ	short CRDFERR 		; fail.
 18406 00003E8D 1F                      	POP	DS			; Recover saved seg part of Xaddr
 18407                                  	; 19/05/2019
 18408 00003E8E EBD1                    	JMP	short ReadRawRetry	; Retry
 18409                                  
 18410                                  ;
 18411                                  ; We have encountered a device-driver error.  We have informed the user of it
 18412                                  ; and he has said for us to fail the system call.
 18413                                  ;
 18414                                  CRDFERR:
 18415 00003E90 5F                      	POP	DI			; Clean stack
 18416                                  DEVIOFERR:
 18417                                  
 18418                                  ;hkn; SS override
 18419 00003E91 36C43E[3605]            	LES	DI,[SS:THISSFT]
 18420 00003E96 E9B404                  	jmp	SET_ACC_ERR_DS
 18421                                  
 18422                                  CRDROK:
 18423 00003E99 5F                      	POP	DI			; Chuck saved seg of Xaddr
 18424 00003E9A 89D7                    	MOV	DI,DX
 18425                                  
 18426                                  ;hkn; SS override
 18427 00003E9C 36033E[1803]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 18428 00003EA1 EBAC                    	JMP	SHORT ENDRDDEVJ3
 18429                                  
 18430                                  ; We are going to do a cooked read on some character device. There is a
 18431                                  ; problem here, what does the data look like? Is it a terminal device, line
 18432                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 18433                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 18434                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 18435                                  ; included in data). this "simulates" the way con works in cooked mode
 18436                                  ; reading one line at a time. With file data, however, the lines will look
 18437                                  ; like, LF line CR. This is a little weird.
 18438                                  
 18439                                  NOTRDCON:
 18440 00003EA3 8CC0                    	MOV	AX,ES
 18441 00003EA5 8ED8                    	MOV	DS,AX
 18442 00003EA7 89FB                    	MOV	BX,DI
 18443 00003EA9 31D2                    	XOR	DX,DX
 18444 00003EAB 89D0                    	MOV	AX,DX
 18445 00003EAD 51                      	PUSH	CX
 18446 00003EAE B90100                  	MOV	CX,1
 18447 00003EB1 E86D10                  	call	SETREAD
 18448 00003EB4 59                      	POP	CX
 18449                                  
 18450                                  ;hkn; SS override
 18451 00003EB5 36C536[3605]            	LDS	SI,[SS:THISSFT]
 18452                                  	;lds	si,[si+7]
 18453 00003EBA C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 18454                                  DVRDLP:
 18455 00003EBD E89817                  	call	DSKSTATCHK
 18456 00003EC0 E83A10                  	call	DEVIOCALL2
 18457 00003EC3 57                      	PUSH	DI		; Save "count" done
 18458 00003EC4 B486                    	MOV	AH,86H
 18459                                  
 18460                                  ;hkn; SS override
 18461 00003EC6 368B3E[0903]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 18462                                  	
 18463                                  	; MSDOS 3.3
 18464                                  	;test	di, 8000h
 18465                                  	;jz	short CRDOK
 18466                                  	; MSDOS 6.0
 18467 00003ECB 09FF                    	or	di,di
 18468 00003ECD 7917                    	jns	short CRDOK
 18469                                  	
 18470 00003ECF E85B19                  	call	CHARHARD
 18471 00003ED2 5F                      	POP	DI
 18472                                  
 18473                                  ;hkn; SS override
 18474 00003ED3 36C706[1803]0100        	MOV	word [SS:CALLSCNT],1
 18475 00003EDA 3C01                    	CMP	AL,1
 18476 00003EDC 74DF                    	JZ	short DVRDLP		;Retry
 18477 00003EDE 3C03                    	CMP	AL,3
 18478 00003EE0 74AF                    	JZ	short DEVIOFERR		; FAIL
 18479 00003EE2 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 18480 00003EE4 EB12                    	JMP	SHORT DVRDIGN
 18481                                  
 18482                                  CRDOK:
 18483 00003EE6 5F                      	POP	DI
 18484                                  
 18485                                  ;hkn; SS override
 18486 00003EE7 36833E[1803]01          	CMP	word [SS:CALLSCNT],1
 18487 00003EED 751F                    	JNZ	short ENDRDDEVJ2
 18488 00003EEF 1E                      	PUSH	DS
 18489                                  
 18490                                  ;hkn; SS override
 18491 00003EF0 368E1E[1603]            	MOV	DS,[SS:CALLXAD+2]
 18492 00003EF5 8A05                    	MOV	AL,[DI]			; Get the character we just read
 18493 00003EF7 1F                      	POP	DS
 18494                                  DVRDIGN:
 18495                                  
 18496                                  ;hkn; SS override
 18497 00003EF8 36FF06[1403]            	INC	WORD [SS:CALLXAD]	; Next character
 18498 00003EFD 36C706[0903]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 18499 00003F04 47                      	INC	DI			; Next character
 18500 00003F05 3C1A                    	CMP	AL,1AH			; ^Z?
 18501 00003F07 7405                    	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 18502 00003F09 3C0D                    	CMP	AL,c_CR 		; CR?
 18503 00003F0B E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 18504 00003F0D 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 18505                                  					;  AX=FFFF which is not likely
 18506                                  ENDRDDEVJ2:
 18507 00003F0E EB1F                    	JMP	short ENDRDDEV		;changed short to long for win386
 18508                                  
 18509                                  	;  MSDOS 6.0
 18510                                  ;;SR;
 18511                                  ;;Polling code for raw read on CON when WIN386 is present
 18512                                  ;;
 18513                                  ;;At this point -- ds:di is transfer address
 18514                                  ;;		  cx is count
 18515                                  ;;
 18516                                  ;
 18517                                  ;do_polling:
 18518                                  ;	mov	bx,di			;ds:bx is Xfer address
 18519                                  ;	xor	ax,ax
 18520                                  ;	mov	dx,ax
 18521                                  ;	call	setread			;prepare device packet
 18522                                  ;
 18523                                  ;do_io:
 18524                                  ;;
 18525                                  ;;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 18526                                  ;;
 18527                                  ;	mov	byte ptr es:[bx+2],DEVRDND	;Change command code
 18528                                  ;	push	ds
 18529                                  ;	lds	si,[THISSFT]		;get device header
 18530                                  ;	call	deviocall		;call device driver
 18531                                  ;	pop	ds
 18532                                  ;	
 18533                                  ;	test	es:[bx.REQSTAT],STERR	;check if error
 18534                                  ;	jz	check_busy		;no
 18535                                  ;
 18536                                  ;	push	ds
 18537                                  ;	mov	dx,di
 18538                                  ;	invoke 	charhard		;invoke int 24h handler
 18539                                  ;	mov	di,dx
 18540                                  ;	or	al,al
 18541                                  ;	jz	pop_done_read		;ignore by user, assume read done
 18542                                  ;	cmp	al,3
 18543                                  ;	jz	devrderr		;user asked to fail
 18544                                  ;	pop	ds
 18545                                  ;	jmp	do_io			;user asked to retry
 18546                                  ;
 18547                                  ;check_busy:
 18548                                  ;	test	es:[bx.REQSTAT],0200h	;see if busy bit set
 18549                                  ;	jnz	no_char			;yes, no character available
 18550                                  ;;
 18551                                  ;;Character is available. Read in 1 character at a time until all characters
 18552                                  ;;are read in or no character is available
 18553                                  ;;
 18554                                  ;	mov	byte ptr es:[bx+2],DEVRD	;command code is READ now
 18555                                  ;	mov	word ptr es:[bx+18],1		;change count to 1 character
 18556                                  ;	push	ds
 18557                                  ;	lds	si,[THISSFT]
 18558                                  ;	call	deviocall
 18559                                  ;
 18560                                  ;	mov	dx,di
 18561                                  ;	mov	ah,86h
 18562                                  ;	mov	di,es:[bx.REQSTAT]	;get returned status
 18563                                  ;	test	di,STERR		;was there an error during read?
 18564                                  ;	jz	next_char		;no,read next character
 18565                                  ;
 18566                                  ;	invoke	charhard		;invoke int 24h handler
 18567                                  ;	mov	di,dx			;restore di
 18568                                  ;	or	al,al			;
 18569                                  ;	jz	pop_done_read		;ignore by user,assume read is done
 18570                                  ;	cmp	al,3
 18571                                  ;	jz	devrderr		;user issued a 'fail',indicate error
 18572                                  ;	pop	ds
 18573                                  ;	jmp	do_io			;user issued a retry
 18574                                  ;
 18575                                  ;next_char:
 18576                                  ;	pop	ds
 18577                                  ;	mov	di,dx
 18578                                  ;	dec	cx			;decrement count
 18579                                  ;	jcxz	done_read		;all characters read in
 18580                                  ;	inc	word ptr es:[bx+14]	;update transfer address
 18581                                  ;	jmp	do_io			;read next character in
 18582                                  ;
 18583                                  ;devrderr:
 18584                                  ;	pop	di			;discard segment address
 18585                                  ;	les	di,[THISSFT]
 18586                                  ;	transfer SET_ACC_ERR_DS		;indicate error
 18587                                  ;
 18588                                  ;no_char:
 18589                                  ;;
 18590                                  ;;Since no character is available, we let win386 switch the VM out
 18591                                  ;;
 18592                                  ;	push	ax
 18593                                  ;	mov	ah,84h
 18594                                  ;	int	2ah			;indicate idle to WIN386
 18595                                  ;;
 18596                                  ;;When control returns from WIN386, we continue the raw read
 18597                                  ;;
 18598                                  ;	pop	ax
 18599                                  ;	jmp	do_io
 18600                                  ;
 18601                                  ;pop_done_read:
 18602                                  ;	pop	ds
 18603                                  ;done_read:
 18604                                  ;	add	di,[CALLSCNT]
 18605                                  ;	jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 18606                                  
 18607                                  TRANBUF:
 18608 00003F10 AC                      	LODSB
 18609 00003F11 AA                      	STOSB
 18610 00003F12 3C0D                    	CMP	AL,c_CR 	; Check for carriage return
 18611 00003F14 7503                    	JNZ	short NORMCH
 18612 00003F16 C6040A                  	MOV	BYTE [SI],c_LF
 18613                                  NORMCH:
 18614 00003F19 3C0A                    	CMP	AL,c_LF
 18615 00003F1B E0F3                    	LOOPNZ	TRANBUF
 18616 00003F1D 7507                    	JNZ	short ENDRDCON
 18617 00003F1F 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 18618 00003F21 E857E4                  	call	OUTT		; Transmit linefeed
 18619 00003F24 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 18620                                  ENDRDCON:
 18621                                  
 18622                                  ;hkn; SS is DOSDATA
 18623 00003F26 16                      	push	ss
 18624 00003F27 1F                      	pop	ds
 18625 00003F28 E8B7FE                  	CALL	SWAPBACK
 18626 00003F2B 8936[2200]              	MOV	[CONTPOS],SI
 18627                                  ENDRDDEV:
 18628                                  
 18629                                  ;hkn; SS is DOSDATA
 18630 00003F2F 16                      	push	ss
 18631 00003F30 1F                      	pop	ds
 18632                                  
 18633 00003F31 893E[5005]              	MOV	[NEXTADD],DI
 18634 00003F35 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 18635 00003F37 C43E[3605]              	LES	DI,[THISSFT]
 18636                                  	;and	byte [es:di+5],0BFh
 18637 00003F3B 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 18638                                  					; Mark as no more data available
 18639                                  SETSFTC:
 18640 00003F40 E8ED04                  	call	SETSFT
 18641 00003F43 C3                      	retn
 18642                                  
 18643                                  READCON:
 18644 00003F44 E8A1FE                  	CALL	SWAPCON
 18645 00003F47 8B36[2200]              	MOV	SI,[CONTPOS]
 18646 00003F4B 09F6                    	OR	SI,SI
 18647 00003F4D 75C1                    	JNZ	short TRANBUF
 18648 00003F4F 803E[2902]80            	CMP	BYTE [CONBUF],128
 18649 00003F54 7406                    	JZ	short GETBUF
 18650 00003F56 C706[2902]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 18651                                  GETBUF:
 18652 00003F5C 51                      	PUSH	CX
 18653 00003F5D 06                      	PUSH	ES
 18654 00003F5E 57                      	PUSH	DI
 18655                                  
 18656                                  ;hkn; CONBUF is in DOSDATA
 18657 00003F5F BA[2902]                	MOV	DX,CONBUF
 18658                                  
 18659 00003F62 E896E1                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 18660 00003F65 5F                      	POP	DI
 18661 00003F66 07                      	POP	ES
 18662 00003F67 59                      	POP	CX
 18663                                  
 18664                                  ;hkn; CONBUF is in DOSDATA
 18665 00003F68 BE[2B02]                	MOV	SI,CONBUF+2
 18666                                  
 18667 00003F6B 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 18668 00003F6E 75A0                    	JNZ	short TRANBUF
 18669 00003F70 B01A                    	MOV	AL,1AH
 18670 00003F72 AA                      	STOSB
 18671 00003F73 4F                      	DEC	DI
 18672 00003F74 B00A                    	MOV	AL,c_LF
 18673 00003F76 E802E4                  	call	OUTT		; Send linefeed
 18674 00003F79 31F6                    	XOR	SI,SI
 18675 00003F7B EBA9                    	JMP	ENDRDCON
 18676                                  
 18677                                  ; 24/07/2018 - Retro DOS v3.0
 18678                                  
 18679                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 18680                                  ;---------------------------------------------------------------------------
 18681                                  ;
 18682                                  ; Procedure Name : DOS_WRITE
 18683                                  ;
 18684                                  ; Inputs:
 18685                                  ;	ThisSFT set to the SFT for the file being used
 18686                                  ;	[DMAADD] contains transfer address
 18687                                  ;	CX = No. of bytes to write
 18688                                  ; Function:
 18689                                  ;	Perform write operation
 18690                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 18691                                  ;		to current sf_position
 18692                                  ; Outputs:
 18693                                  ;    Carry clear
 18694                                  ;	SFT Position and cluster pointers updated
 18695                                  ;	CX = No. of bytes written
 18696                                  ;	ES:DI point to SFT
 18697                                  ;    Carry set
 18698                                  ;	AX is error code
 18699                                  ;	CX = 0
 18700                                  ;	ES:DI point to SFT
 18701                                  ; DS preserved, all other registers destroyed
 18702                                  ;---------------------------------------------------------------------------
 18703                                  
 18704                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 18705                                  ;hkn; point to DOSDATA.
 18706                                  
 18707                                  DOS_WRITE:
 18708 00003F7D C43E[3605]              	LES	DI,[THISSFT]
 18709                                  	;mov	al,[ES:DI+2]
 18710 00003F81 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 18711                                  	;and	al,0Fh
 18712 00003F85 240F                    	AND	AL,access_mask
 18713                                  	;cmp	al,0
 18714 00003F87 3C00                    	CMP	AL,open_for_read
 18715 00003F89 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 18716                                  BadMode:
 18717 00003F8B E9C103                  	jmp	SET_ACC_ERR
 18718                                  
 18719                                  ;
 18720                                  ; NOTE: The following check for writting to a Read Only File is performed
 18721                                  ;	    ONLY on FCBs!!!!
 18722                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 18723                                  ;	    of a read only file which can then be written to.
 18724                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 18725                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 18726                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 18727                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 18728                                  ;	    to a read-only file.
 18729                                  ;
 18730                                  Check_FCB_RO:
 18731                                  	;test	word [es:di+2],8000h
 18732 00003F8E 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 18733 00003F94 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 18734                                  	;test	byte [es:di+4],1
 18735 00003F96 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 18736 00003F9B 75EE                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 18737                                  WRITE_NO_MODE:
 18738 00003F9D E88902                  	call	SETUP
 18739 00003FA0 E837E0                  	call	IsSFTNet
 18740 00003FA3 7406                    	JZ	short LOCAL_WRITE
 18741                                  
 18742                                  ;IF NOT Installed
 18743                                  ;	transfer NET_WRITE
 18744                                  ;ELSE
 18745                                  	;mov	ax,1109h
 18746 00003FA5 B80911                  	MOV	AX,(MultNET<<8)|9
 18747 00003FA8 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 18748                                  			; ES:DI -> SFT
 18749                                  			; SFT DPB field -> DPB of drive containing file
 18750                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 18751                                  			; Return: CF set on error, CX = bytes written
 18752 00003FAA C3                      	retn
 18753                                  ;ENDIF
 18754                                  
 18755                                  LOCAL_WRITE:
 18756                                  	;test	word [es:di+5],80h
 18757 00003FAB 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 18758 00003FB1 7552                    	jnz	short WRTDEV
 18759                                  	;mov	byte [EXTERR_LOCUS],2
 18760 00003FB3 C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18761 00003FB8 E8A8E0                  	call	EcritDisk
 18762                                  
 18763 00003FBB E8A104                  	call	DISKWRITE
 18764                                  
 18765                                  	; MSDOS 6.0
 18766                                  ;; Extended Open
 18767                                  	;JC	short nocommit
 18768                                  	;LES	DI,[THISSFT]
 18769                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],auto_commit_write
 18770                                  	;JZ	short nocommit
 18771                                  	;PUSH	CX
 18772                                  	;call	DOS_COMMIT
 18773                                  	;POP	CX
 18774                                  ;nocommit:
 18775                                  ;; Extended Open
 18776 00003FBE E8AAE0                  	call	LcritDisk
 18777 00003FC1 C3                      	retn
 18778                                  
 18779                                  DVWRTRAW:
 18780 00003FC2 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 18781 00003FC4 E88D0F                  	call	SETWRITE
 18782 00003FC7 1E                      	PUSH	DS			; Save seg of transfer
 18783                                  
 18784                                  ;hkn; SS override
 18785 00003FC8 36C536[3605]            	LDS	SI,[SS:THISSFT]
 18786 00003FCD E82A0F                  	call	DEVIOCALL		; DS:SI -> DEVICE
 18787                                  
 18788 00003FD0 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 18789 00003FD2 B487                    	MOV	AH,87H
 18790                                  
 18791                                  ;hkn; SS override
 18792 00003FD4 368B3E[0903]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 18793                                  
 18794                                  	; MSDOS 3.3
 18795                                  	;test	di,8000h
 18796                                  	;jz	short CWRTROK
 18797                                  
 18798                                  	; MSDOS 6.0
 18799 00003FD9 09FF                    	or	di,di
 18800 00003FDB 7914                    	jns	short CWRTROK
 18801                                  	
 18802                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18803 00003FDD E84D18                  	call	CHARHARD
 18804                                  
 18805                                  	; MSDOS 6.0
 18806                                  	;sub	cx,[ss:callscnt]	; update ptr & count to reflect	M065
 18807                                  	;mov	bx,dx			; number of chars xferred	M065
 18808                                  	;add	bx,[ss:callscnt]		;				M065
 18809                                  	;mov	di,bx			;				M065
 18810                                  	
 18811                                  	; MSDOS 3.3
 18812 00003FE0 89D3                    	MOV	BX,DX			; Recall transfer addr		M065
 18813                                  
 18814                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18815 00003FE2 08C0                    	OR	AL,AL
 18816 00003FE4 740B                    	JZ	short CWRTROK 		; Ignore
 18817 00003FE6 3C03                    	CMP	AL,3
 18818 00003FE8 7403                    	JZ	short CWRFERR
 18819 00003FEA 1F                      	POP	DS			; Recover saved seg of transfer
 18820 00003FEB EBD5                    	JMP	short DVWRTRAW		; Try again
 18821                                  
 18822                                  CWRFERR:
 18823 00003FED 58                      	POP	AX			; Chuck saved seg of transfer
 18824 00003FEE E99FFE                  	JMP	CRDFERR 		; Will pop one more stack element
 18825                                  
 18826                                  CWRTROK:
 18827 00003FF1 58                      	POP	AX			; Chuck saved seg of transfer
 18828 00003FF2 1F                      	POP	DS
 18829 00003FF3 A1[1803]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 18830                                  ENDWRDEV:
 18831 00003FF6 C43E[3605]              	LES	DI,[THISSFT]
 18832 00003FFA 89C1                    	MOV	CX,AX
 18833 00003FFC E85304                  	call	ADDREC
 18834 00003FFF C3                      	retn
 18835                                  
 18836                                  WRTNUL:
 18837 00004000 89CA                    	MOV	DX,CX			;Entire transfer done
 18838                                  WRTCOOKJ:
 18839 00004002 E98D00                  	JMP	WRTCOOKDONE
 18840                                  
 18841                                  WRTDEV:
 18842                                  	;mov	byte [EXTERR_LOCUS],4
 18843 00004005 C606[D102]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 18844                                  	;or	byte [es:di+5],40h
 18845 0000400A 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 18846                                  					; Reset EOF for input
 18847                                  	;mov	bl,[es:di+5]
 18848 0000400F 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 18849 00004013 31C0                    	XOR	AX,AX
 18850 00004015 E3DF                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 18851 00004017 1E                      	PUSH	DS
 18852 00004018 88D8                    	MOV	AL,BL
 18853 0000401A C51E[DA02]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 18854 0000401E 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 18855 00004020 31D2                    	XOR	DX,DX			; Set starting point
 18856                                  	;test	al,20h
 18857 00004022 A820                    	test	AL,devid_device_raw	; Raw?
 18858                                  	;JZ	short TEST_DEV_CON
 18859                                  	;JMP	DVWRTRAW
 18860 00004024 759C                    	jnz	short DVWRTRAW
 18861                                  
 18862                                  TEST_DEV_CON:
 18863                                  	;test	al,2
 18864 00004026 A802                    	test	AL,devid_device_con_out ; Console output device?
 18865 00004028 756E                    	jnz	short WRITECON
 18866                                  	;test	al,4
 18867 0000402A A804                    	test	AL,devid_device_null
 18868 0000402C 75D2                    	JNZ	short WRTNUL
 18869 0000402E 89D0                    	MOV	AX,DX
 18870 00004030 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 18871 00004033 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 18872 00004035 51                      	PUSH	CX
 18873 00004036 B90100                  	MOV	CX,1
 18874 00004039 E8180F                  	call	SETWRITE
 18875 0000403C 59                      	POP	CX
 18876                                  
 18877                                  ;hkn; SS override
 18878 0000403D 36C536[3605]            	LDS	SI,[SS:THISSFT]
 18879                                  ;
 18880                                  ;SR; Removed X25 support from here
 18881                                  ;
 18882                                  	;lds	si,[si+7]
 18883 00004042 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 18884                                  DVWRTLP:
 18885 00004045 E81016                  	call	DSKSTATCHK
 18886 00004048 E8B20E                  	call	DEVIOCALL2
 18887 0000404B 57                      	PUSH	DI
 18888 0000404C B487                    	MOV	AH,87H
 18889                                  
 18890                                  ;hkn; SS override
 18891 0000404E 368B3E[0903]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 18892                                  	
 18893                                  	; MSDOS 3.3
 18894                                  	;test	di,8000h
 18895                                  	;jz	short CWROK
 18896                                  
 18897                                  	; MSDOS 6.0
 18898 00004053 09FF                    	or	di,di
 18899 00004055 7916                    	jns	short CWROK
 18900                                  	
 18901                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18902 00004057 E8D317                  	call	CHARHARD
 18903 0000405A 5F                      	POP	DI
 18904                                  
 18905                                  ;hkn; SS override
 18906 0000405B 36C706[1803]0100        	MOV	word [SS:CALLSCNT],1
 18907 00004062 3C01                    	CMP	AL,1
 18908 00004064 74DF                    	JZ	short DVWRTLP 	; Retry
 18909 00004066 08C0                    	OR	AL,AL
 18910 00004068 740C                    	JZ	short DVWRTIGN	; Ignore
 18911                                  	; 10/08/2018
 18912 0000406A E923FE                  	JMP	CRDFERR 	; Fail, pops one stack element
 18913                                  
 18914                                  CWROK:
 18915 0000406D 5F                      	POP	DI
 18916                                  
 18917                                  ;hkn; SS override
 18918 0000406E 36833E[1803]00          	CMP	word [SS:CALLSCNT],0
 18919 00004074 741C                    	JZ	short WRTCOOKDONE
 18920                                  DVWRTIGN:
 18921 00004076 42                      	INC	DX
 18922                                  
 18923                                  ;hkn; SS override for CALLXAD
 18924 00004077 36FF06[1403]            	INC	WORD [SS:CALLXAD]
 18925 0000407C 47                      	INC	DI
 18926 0000407D 1E                      	PUSH	DS
 18927 0000407E 368E1E[1603]            	MOV	DS,[SS:CALLXAD+2]
 18928 00004083 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 18929 00004086 1F                      	POP	DS
 18930 00004087 7409                    	JZ	short WRTCOOKDONE
 18931                                  
 18932                                  ;hkn; SS override
 18933 00004089 36C706[0903]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 18934 00004090 E2B3                    	LOOP	DVWRTLP
 18935                                  WRTCOOKDONE:
 18936 00004092 89D0                    	MOV	AX,DX
 18937 00004094 1F                      	POP	DS
 18938 00004095 E95EFF                  	JMP	ENDWRDEV ; 10/08/2018
 18939                                  
 18940                                  WRITECON:
 18941 00004098 1E                      	PUSH	DS
 18942                                  
 18943                                  ;hkn; SS is DOSDATA
 18944 00004099 16                      	push	ss
 18945 0000409A 1F                      	pop	ds
 18946 0000409B E84AFD                  	CALL	SWAPCON
 18947 0000409E 1F                      	POP	DS
 18948 0000409F 89DE                    	MOV	SI,BX
 18949 000040A1 51                      	PUSH	CX
 18950                                  WRCONLP:
 18951 000040A2 AC                      	LODSB
 18952 000040A3 3C1A                    	CMP	AL,1Ah		; ^Z?
 18953 000040A5 7405                    	JZ	short CONEOF
 18954 000040A7 E8D1E2                  	call	OUTT
 18955 000040AA E2F6                    	LOOP	WRCONLP
 18956                                  CONEOF:
 18957 000040AC 58                      	POP	AX			; Count
 18958 000040AD 29C8                    	SUB	AX,CX			; Amount actually written
 18959 000040AF 1F                      	POP	DS
 18960 000040B0 E82FFD                  	CALL	SWAPBACK
 18961 000040B3 E940FF                  	JMP	ENDWRDEV
 18962                                  
 18963                                  ;---------------------------------------------------------------------------
 18964                                  ;
 18965                                  ; Procedure Name : get_io_sft
 18966                                  ;
 18967                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 18968                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more.  Otherwise, we
 18969                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 18970                                  ;
 18971                                  ;---------------------------------------------------------------------------
 18972                                  
 18973                                  GET_IO_SFT:
 18974                                  	;test	byte [SS:CONSWAP],0FFh
 18975 000040B6 36803E[0303]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 18976 000040BC 7512                    	JNZ	short GetRedir
 18977                                  GetNormal:
 18978 000040BE 16                      	push	ss
 18979 000040BF 1F                      	pop	ds
 18980 000040C0 06                      	PUSH	ES
 18981 000040C1 57                      	PUSH	DI
 18982 000040C2 E83A27                  	call	SFFromHandle
 18983 000040C5 7206                    	JC	short RET44P
 18984 000040C7 8CC6                    	MOV	SI,ES
 18985 000040C9 8EDE                    	MOV	DS,SI
 18986 000040CB 89FE                    	MOV	SI,DI
 18987                                  RET44P:
 18988 000040CD 5F                      	POP	DI
 18989 000040CE 07                      	POP	ES
 18990 000040CF C3                      	retn
 18991                                  GetRedir:
 18992 000040D0 83FB01                  	CMP	BX,1
 18993 000040D3 77E9                    	JA	short GetNormal
 18994 000040D5 36C536[7805]            	LDS	SI,[SS:CONSFT]
 18995 000040DA F8                      	CLC
 18996                                  get_io_sft_retn:
 18997 000040DB C3                      	retn
 18998                                  
 18999                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 19000                                  ;---------------------------------------------------------------------------
 19001                                  ;
 19002                                  ; Procedure Name : DIRREAD
 19003                                  ;
 19004                                  ; Inputs:
 19005                                  ;	AX = Directory block number (relative to first block of directory)
 19006                                  ;	ES:BP = Base of drive parameters
 19007                                  ;	[DIRSEC] = First sector of first cluster of directory
 19008                                  ;	[CLUSNUM] = Next cluster
 19009                                  ;	[CLUSFAC] = Sectors/Cluster
 19010                                  ; Function:
 19011                                  ;	Read the directory block into [CURBUF].
 19012                                  ; Outputs:
 19013                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 19014                                  ;	[SECCLUSPOS] Set
 19015                                  ;	ES:BP unchanged
 19016                                  ;	[CURBUF] Points to Buffer with dir sector
 19017                                  ;	Carry set if error (user said FAIL to I 24)
 19018                                  ; DS preserved, all other registers destroyed.
 19019                                  ;---------------------------------------------------------------------------
 19020                                  
 19021                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 19022                                  
 19023                                  DIRREAD:
 19024                                  
 19025                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 19026                                  ; the same as what is in the DPB! In the case of the root directory, we have
 19027                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 19028                                  ; by DIRStart = 0.
 19029                                  
 19030 000040DC 31D2                    	XOR	DX,DX
 19031 000040DE 833E[5805]00            	CMP	word [DIRSTART],0
 19032 000040E3 7503                    	jnz	short SubDir
 19033 000040E5 92                      	XCHG	AX,DX
 19034 000040E6 EB0C                    	JMP	short DoRead
 19035                                  
 19036                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 19037                                  
 19038                                  SubDir:
 19039 000040E8 88C2                    	MOV	DL,AL
 19040                                  	;and	dl,[es:bp+4]
 19041 000040EA 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 19042                                  
 19043                                  ;	(DX) = sector-in-cluster
 19044                                  
 19045                                  	;mov	cl,[es:bp+5]
 19046 000040EE 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 19047 000040F2 D3E8                    	SHR	AX,CL
 19048                                  
 19049                                  ;	(DX) = position in cluster
 19050                                  ;	(AX) = number of clusters to skip
 19051                                  
 19052                                  DoRead:
 19053 000040F4 8816[0E05]              	MOV	[SECCLUSPOS],DL
 19054 000040F8 89C1                    	MOV	CX,AX
 19055 000040FA 88D4                    	MOV	AH,DL
 19056                                  
 19057                                  ;	(CX) = number of clusters to skip.
 19058                                  ;	(AH) = remainder
 19059                                  
 19060                                  	; MSDOS 6.0
 19061                                  	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
 19062                                  	;MOV	[HIGH_SECTOR],DX	  ;>32mb
 19063 000040FC 8B16[5605]              	MOV	DX,[DIRSEC]
 19064 00004100 00E2                    	ADD	DL,AH
 19065 00004102 80D600                  	ADC	DH,0
 19066                                  	;ADC	word [HIGH_SECTOR],0	  ;>32mb
 19067                                  
 19068 00004105 8B1E[5405]              	MOV	BX,[CLUSNUM]
 19069 00004109 891E[6E05]              	MOV	[NXTCLUSNUM],BX
 19070 0000410D E319                    	JCXZ	FIRSTCLUSTER
 19071                                  SKPCLLP:
 19072 0000410F E83E19                  	call	UNPACK
 19073 00004112 72C7                    	jc	short get_io_sft_retn
 19074 00004114 87DF                    	XCHG	BX,DI
 19075 00004116 E82019                  	call	IsEOF			; test for eof based on fat size
 19076 00004119 7302                    	JAE	short HAVESKIPPED
 19077 0000411B E2F2                    	LOOP	SKPCLLP
 19078                                  HAVESKIPPED:
 19079 0000411D 891E[6E05]              	MOV	[NXTCLUSNUM],BX
 19080 00004121 89FA                    	MOV	DX,DI
 19081 00004123 88E3                    	MOV	BL,AH
 19082 00004125 E80C13                  	call	FIGREC
 19083                                  
 19084                                  	;entry	FIRSTCLUSTER
 19085                                  
 19086                                  FIRSTCLUSTER:
 19087                                  	;mov	byte [ALLOWED],18h
 19088 00004128 C606[F702]18            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 19089 0000412D 30C0                    	XOR	AL,AL		; Indicate pre-read
 19090 0000412F E8561D                  	call	GETBUFFR
 19091 00004132 72A7                    	jc	short get_io_sft_retn
 19092                                  
 19093                                  	;entry	SET_BUF_AS_DIR
 19094                                  
 19095                                  SET_BUF_AS_DIR:
 19096                                  
 19097                                  ;	Set the type of CURBUF to be a directory sector.
 19098                                  ;	Only flags are modified.
 19099                                  
 19100 00004134 1E                      	PUSH	DS
 19101 00004135 56                      	PUSH	SI
 19102 00004136 C536[7405]              	LDS	SI,[CURBUF]
 19103                                  	;or	byte [si+5],4
 19104 0000413A 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 19105 0000413E 5E                      	POP	SI
 19106 0000413F 1F                      	POP	DS
 19107                                  dirread_retn:
 19108 00004140 C3                      	retn
 19109                                  
 19110                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 19111                                  ;----------------------------------------------------------------------------
 19112                                  ;
 19113                                  ; Procedure Name : FATSECRD
 19114                                  ; Inputs:
 19115                                  ;	Same as DREAD
 19116                                  ;	DS:BX = Transfer address
 19117                                  ;	CX = Number of sectors
 19118                                  ;	DX = Absolute record number
 19119                                  ;	ES:BP = Base of drive parameters
 19120                                  ; Function:
 19121                                  ;	Calls BIOS to perform FAT read.
 19122                                  ; Outputs:
 19123                                  ;	Same as DREAD
 19124                                  ;---------------------------------------------------------------------------
 19125                                  
 19126                                  FATSECRD:
 19127                                  ;hkn; SS override
 19128                                  	;mov	byte [ss:ALLOWED],18h
 19129 00004141 36C606[F702]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 19130 00004147 89CF                    	MOV	DI,CX
 19131                                  	;mov	cl,[es:bp+8]
 19132 00004149 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 19133                                  	; MSDOS 6.0
 19134                                  	;MOV	AX,[ES:BP+DPB.FAT_SIZE] 	;>32mb
 19135                                  	; MSDOS 3.3
 19136                                  	;mov	al,[es:bp+0Fh]
 19137 0000414D 268A460F                	MOV	AL,[ES:BP+DPB.FAT_SIZE] 
 19138 00004151 30E4                    	XOR	AH,AH
 19139 00004153 30ED                    	XOR	CH,CH				;>32mb
 19140 00004155 52                      	PUSH	DX
 19141                                  NXTFAT:
 19142                                  	; MSDOS 6.0
 19143                                  ;hkn; SS override
 19144                                  	;MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 19145 00004156 51                      	PUSH	CX			;32mb
 19146 00004157 50                      	PUSH	AX
 19147 00004158 89F9                    	MOV	CX,DI
 19148 0000415A E85A00                  	call	DSKREAD
 19149 0000415D 58                      	POP	AX
 19150 0000415E 59                      	POP	CX
 19151 0000415F 7420                    	JZ	short RET41P		; Carry clear
 19152 00004161 01C2                    	ADD	DX,AX
 19153 00004163 E2F1                    	LOOP	NXTFAT
 19154 00004165 5A                      	POP	DX
 19155 00004166 89F9                    	MOV	CX,DI
 19156                                  
 19157                                  ; NOTE FALL THROUGH
 19158                                  
 19159                                  ;Break	<DREAD -- DO A DISK READ>
 19160                                  ;---------------------------------------------------------------------------
 19161                                  ;
 19162                                  ; Procedure Name : DREAD
 19163                                  ;
 19164                                  ; Inputs:
 19165                                  ;	DS:BX = Transfer address
 19166                                  ;	CX = Number of sectors
 19167                                  ;	DX = Absolute record number	      (LOW)
 19168                                  ;	[HIGH_SECTOR]= Absolute record number (HIGH)
 19169                                  ;	ES:BP = Base of drive parameters
 19170                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 19171                                  ; Function:
 19172                                  ;	Calls BIOS to perform disk read. If BIOS reports
 19173                                  ;	errors, will call HARDERRRW for further action.
 19174                                  ; Outputs:
 19175                                  ;	Carry set if error (currently user FAILED to INT 24)
 19176                                  ; DS,ES:BP preserved. All other registers destroyed.
 19177                                  ;---------------------------------------------------------------------------
 19178                                  
 19179                                  	;entry	DREAD
 19180                                  DREAD:
 19181 00004168 E84C00                  	call	DSKREAD
 19182 0000416B 74D3                    	jz	short dirread_retn	; Carry clear
 19183                                  ;hkn; SS override
 19184 0000416D 36C606[1005]00          	MOV	BYTE [SS:READOP],0
 19185 00004173 E89900                  	call	HARDERRRW
 19186 00004176 3C01                    	CMP	AL,1		; Check for retry
 19187 00004178 74EE                    	JZ	short DREAD
 19188 0000417A 3C03                    	CMP	AL,3		; Check for FAIL
 19189 0000417C F8                      	CLC
 19190 0000417D 7501                    	JNZ	short NO_CAR		; Ignore
 19191 0000417F F9                      	STC
 19192                                  NO_CAR:
 19193 00004180 C3                      	retn
 19194                                  RET41P: 
 19195 00004181 5A                      	POP	DX
 19196 00004182 C3                      	retn
 19197                                  
 19198                                  ; 24/07/2018 - Retro DOS v3.0
 19199                                  
 19200                                  ;Break	<CHECK_WRITE_LOCK>
 19201                                  ;---------------------------------------------------------------------------
 19202                                  ;
 19203                                  ; Procedure Name : CHECK_WRITE_LOCK
 19204                                  ;
 19205                                  ; Inputs:
 19206                                  ;	output of SETUP
 19207                                  ;	ES:DI -> SFT
 19208                                  ; Function:
 19209                                  ;	check write lock
 19210                                  ; Outputs:
 19211                                  ;	Carry set if error
 19212                                  ;	Carry clear if ok
 19213                                  ;
 19214                                  ;----------------------------------------------------------------------------
 19215                                  
 19216                                  CHECK_WRITE_LOCK:
 19217                                  	; MSDOS 6.0
 19218                                  	;test	byte [es:di+4],8
 19219 00004183 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 19220                                  	;JZ	short write_cont			     ;no
 19221                                  	;call	SET_ACC_ERR_DS		;
 19222                                  	;retn
 19223                                  	;jnz	SET_ACC_ERR_DS
 19224                                  	; 19/08/2018
 19225 00004188 7403                    	jz	short write_cont
 19226 0000418A E9C001                  	jmp	SET_ACC_ERR_DS
 19227                                  write_cont:				;
 19228 0000418D 51                      	PUSH	CX			;save reg
 19229 0000418E 09C9                    	OR	CX,CX			;
 19230 00004190 7501                    	JNZ	short Not_Truncate	;
 19231 00004192 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 19232                                  Not_Truncate:				;
 19233 00004193 B080                    	MOV	AL,80H			;check write access
 19234 00004195 E84F31                  	call	LOCK_CHECK		;check lock
 19235 00004198 59                      	POP	CX			;restore reg
 19236 00004199 7305                    	JNC	short WRITE_OK		;lock ok
 19237 0000419B E86501                  	call	WRITE_LOCK_VIOLATION	;issue I24
 19238 0000419E 73ED                    	JNC	short write_cont	;retry
 19239                                  WRITE_OK:				;
 19240 000041A0 C3                      	retn				;
 19241                                  
 19242                                  ;Break	<CHECK_READ_LOCK>
 19243                                  ;---------------------------------------------------------------------------
 19244                                  ;
 19245                                  ; Procedure Name : CHECK_READ_LOC
 19246                                  ;
 19247                                  ; Inputs:
 19248                                  ;	ES:DI -> SFT
 19249                                  ;	output of SETUP
 19250                                  ; Function:
 19251                                  ;	check read lock
 19252                                  ; Outputs:
 19253                                  ;	Carry set if error
 19254                                  ;	Carry clear if ok
 19255                                  ;----------------------------------------------------------------------------
 19256                                  
 19257                                  CHECK_READ_LOCK:
 19258                                  	; MSDOS 6.0
 19259                                  	;test	byte [es:di+4],8
 19260 000041A1 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 19261                                  	;JZ	short do_retry			   	     ; no
 19262                                  	;call	SET_ACC_ERR		;
 19263                                  	;retn
 19264 000041A6 0F85A501                	jnz	SET_ACC_ERR		;
 19265                                  do_retry:				;
 19266 000041AA 30C0                    	xor	al,al			;check read access
 19267 000041AC E83831                  	call	LOCK_CHECK		;check lock
 19268 000041AF 7305                    	JNC	short READLOCK_OK 	;lock ok
 19269 000041B1 E82801                  	call	READ_LOCK_VIOLATION	;issue I24
 19270 000041B4 73F4                    	JNC	short do_retry		;retry
 19271                                  READLOCK_OK:				;
 19272 000041B6 C3                      	retn				;
 19273                                  
 19274                                  ;============================================================================
 19275                                  ; DISK2.ASM, MSDOS 6.0, 1991
 19276                                  ;============================================================================
 19277                                  ; 24/07/2018 - Retro DOS v3.0 
 19278                                  
 19279                                  ;	TITLE	DISK2 - Disk utility routines
 19280                                  ;	NAME	Disk2
 19281                                  
 19282                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 19283                                  ;
 19284                                  ;	DskRead
 19285                                  ;	DWRITE
 19286                                  ;	DSKWRITE
 19287                                  ;	HarderrRW
 19288                                  ;	SETUP
 19289                                  ;	BREAKDOWN
 19290                                  ;	READ_LOCK_VIOLATION
 19291                                  ;	WRITE_LOCK_VIOLATION
 19292                                  ;	DISKREAD
 19293                                  ;	SET_ACC_ERR_DS
 19294                                  ;	SET_ACC_ERR
 19295                                  ;	SETSFT
 19296                                  ;	SETCLUS
 19297                                  ;	AddRec
 19298                                  ;
 19299                                  ;	Revision history:
 19300                                  ;
 19301                                  ;		AN000 version 4.00 Jan. 1988
 19302                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 19303                                  
 19304                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 19305                                  ;---------------------------------------------------------------------------
 19306                                  ;
 19307                                  ; Procedure Name : DSKREAD
 19308                                  ;
 19309                                  ; Inputs:
 19310                                  ;	DS:BX = Transfer addr
 19311                                  ;	CX = Number of sectors
 19312                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 19313                                  ;	DX = Absolute record number	       (LOW)
 19314                                  ;	ES:BP = Base of drive parameters
 19315                                  ; Function:
 19316                                  ;	Call BIOS to perform disk read
 19317                                  ; Outputs:
 19318                                  ;	DI = CX on entry
 19319                                  ;	CX = Number of sectors unsuccessfully transfered
 19320                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 19321                                  ;	Zero set if OK (from BIOS) (carry clear)
 19322                                  ;	Zero clear if error (carry clear)
 19323                                  ; SI Destroyed, others preserved
 19324                                  ;---------------------------------------------------------------------------
 19325                                  
 19326                                  DSKREAD:
 19327 000041B7 51                      	PUSH	CX
 19328                                  	;mov	ah,[es:bp+16h]
 19329 000041B8 268A6616                	MOV	AH,[ES:BP+DPB.MEDIA]
 19330                                  	;mov	al,[es:bp+1]
 19331 000041BC 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 19332 000041C0 53                      	PUSH	BX
 19333 000041C1 06                      	PUSH	ES
 19334 000041C2 E85C0D                  	call	SETREAD
 19335 000041C5 EB27                    	JMP	short DODSKOP
 19336                                  
 19337                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 19338                                  ;--------------------------------------------------------------------------
 19339                                  ;
 19340                                  ; Procedure Name : DWRITE
 19341                                  ;
 19342                                  ; Inputs:
 19343                                  ;	DS:BX = Transfer address
 19344                                  ;	CX = Number of sectors
 19345                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 19346                                  ;	DX = Absolute record number	       (LOW)
 19347                                  ;	ES:BP = Base of drive parameters
 19348                                  ;	[ALLOWED] must be set in case HARDERR called
 19349                                  ; Function:
 19350                                  ;	Calls BIOS to perform disk write. If BIOS reports
 19351                                  ;	errors, will call HARDERRRW for further action.
 19352                                  ; Output:
 19353                                  ;	Carry set if error (currently, user FAILed to I 24)
 19354                                  ; BP preserved. All other registers destroyed.
 19355                                  ;----------------------------------------------------------------------------
 19356                                  
 19357                                  
 19358                                  	;entry	DWRITE
 19359                                  DWRITE:
 19360 000041C7 E81600                  	CALL	DSKWRITE
 19361 000041CA 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 19362                                  
 19363                                  ;hkn; SS override
 19364 000041CC 36C606[1005]01          	MOV	BYTE [SS:READOP],1
 19365 000041D2 E83A00                  	call	HARDERRRW
 19366 000041D5 3C01                    	CMP	AL,1		; Check for retry
 19367 000041D7 74EE                    	JZ	short DWRITE
 19368 000041D9 3C03                    	CMP	AL,3		; Check for FAIL
 19369 000041DB F8                      	CLC
 19370 000041DC 7501                    	JNZ	short NO_CAR2 	; Ignore
 19371 000041DE F9                      	STC
 19372                                  NO_CAR2:
 19373                                  dw_ret_label:
 19374 000041DF C3                      	retn
 19375                                  
 19376                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 19377                                  ;---------------------------------------------------------------------------
 19378                                  ;
 19379                                  ; Procedure Name : DSKWRITE
 19380                                  ;
 19381                                  ; Inputs:
 19382                                  ;	DS:BX = Transfer addr
 19383                                  ;	CX = Number of sectors
 19384                                  ;	DX = Absolute record number	       (LOW)
 19385                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 19386                                  ;	ES:BP = Base of drive parameters
 19387                                  ; Function:
 19388                                  ;	Call BIOS to perform disk read
 19389                                  ; Outputs:
 19390                                  ;	DI = CX on entry
 19391                                  ;	CX = Number of sectors unsuccessfully transfered
 19392                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 19393                                  ;	Zero set if OK (from BIOS) (carry clear)
 19394                                  ;	Zero clear if error (carry clear)
 19395                                  ; SI Destroyed, others preserved
 19396                                  ;
 19397                                  ;----------------------------------------------------------------------------
 19398                                  
 19399                                  	;entry	DSKWRITE
 19400                                  DSKWRITE:
 19401 000041E0 51                      	PUSH	CX
 19402                                  	;mov	ah,[es:bp+16h]
 19403 000041E1 268A6616                	MOV	AH,[ES:BP+DPB.MEDIA]
 19404                                  	;mov	al,[es:bp+1]
 19405 000041E5 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 19406 000041E9 53                      	PUSH	BX
 19407 000041EA 06                      	PUSH	ES
 19408 000041EB E8660D                  	call	SETWRITE
 19409                                  DODSKOP:
 19410 000041EE 8CD9                    	MOV	CX,DS		; Save DS
 19411 000041F0 1F                      	POP	DS		; DS:BP points to DPB
 19412 000041F1 1E                      	PUSH	DS
 19413                                  	;lds	si,[ds:bp+12h]
 19414 000041F2 3EC57612                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 19415 000041F6 E8040D                  	call	DEVIOCALL2
 19416 000041F9 8ED9                    	MOV	DS,CX		; Restore DS
 19417 000041FB 07                      	POP	ES		; Restore ES
 19418 000041FC 5B                      	POP	BX
 19419                                  
 19420                                  ;hkn; SS override
 19421 000041FD 368B0E[1803]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 19422 00004202 5F                      	POP	DI
 19423 00004203 29F9                    	SUB	CX,DI
 19424 00004205 F7D9                    	NEG	CX		; Number of sectors not transferred
 19425                                  
 19426                                  ;hkn; SS override
 19427 00004207 36A1[0903]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 19428                                  	;test	ax,8000h
 19429 0000420B A90080                  	test	AX,STERR
 19430 0000420E C3                      	retn
 19431                                  
 19432                                  ;Break	<HardErrRW - map extended errors and call harderr>
 19433                                  ;---------------------------------------------------------------------------
 19434                                  ;
 19435                                  ; Procedure Name : HardErrRW
 19436                                  ;
 19437                                  ; Inputs:
 19438                                  ;	AX is error code from read or write
 19439                                  ;	Other registers set as per HARDERR
 19440                                  ; Function:
 19441                                  ;	Checks the error code for special extended
 19442                                  ;	errors and maps them if needed. Then invokes
 19443                                  ;	Harderr
 19444                                  ; Outputs:
 19445                                  ;	Of HARDERR
 19446                                  ; AX may be modified prior to call to HARDERR.
 19447                                  ; No other registers altered.
 19448                                  ;
 19449                                  ;---------------------------------------------------------------------------
 19450                                  
 19451                                  HARDERRRW:
 19452                                  	;cmp	al,0Fh
 19453 0000420F 3C0F                    	CMP	AL,error_I24_wrong_disk
 19454 00004211 7512                    	JNZ	short DO_ERR				; Nothing to do
 19455                                  
 19456                                  	; MSDOS 3.3
 19457                                  	;push	ds
 19458                                  	;push	si
 19459                                  	;lds	si,[ss:CALLVIDRW]
 19460                                  	;mov	[ss:EXTERRPT+2], ds
 19461                                  	;mov	[ss:EXTERRPT], si
 19462                                  	;pop	si
 19463                                  	;pop	ds
 19464                                  
 19465                                  	; MSDOS 6.0
 19466 00004213 50                      	push	ax
 19467 00004214 36A1[1C03]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 19468 00004218 36A3[D602]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 19469 0000421C 36A1[1E03]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 19470 00004220 36A3[D802]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 19471 00004224 58                      	pop	ax
 19472                                  DO_ERR:
 19473 00004225 E82316                  	call	HARDERR
 19474 00004228 C3                      	retn
 19475                                  
 19476                                  ; 24/07/2018 - Retro DOS v3.0
 19477                                  
 19478                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 19479                                  ;----------------------------------------------------------------------------
 19480                                  ;
 19481                                  ; Procedure Name : SETUP
 19482                                  ;
 19483                                  ; Inputs:
 19484                                  ;	ES:DI point to SFT (value also in THISSFT)
 19485                                  ;	DMAAdd contains transfer address
 19486                                  ;	CX = Byte count
 19487                                  ;	DS = DOSDATA
 19488                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 19489                                  ;		2nd of caller of caller.
 19490                                  ; Outputs:
 19491                                  ;	    CX = byte count
 19492                                  ;	    [THISDPB] = Base of drive parameters if file
 19493                                  ;		      = Pointer to device header if device or NET
 19494                                  ;	    ES:DI Points to SFT
 19495                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 19496                                  ;	    [TRANS] = 0 (No transfers yet)
 19497                                  ;	    BytPos = Byte position in file
 19498                                  ;
 19499                                  ;	The following fields are relevant to local files (not devices) only:
 19500                                  ;
 19501                                  ;	    SecPos = Position of first sector (local files only)
 19502                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 19503                                  ;	    [CLUSNUM] = First cluster (local files only)
 19504                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 19505                                  ;	    [THISDRV] = Physical unit number (local files only)
 19506                                  ;
 19507                                  ;      RETURNS ONE LEVEL UP WITH:
 19508                                  ;	   CX = 0
 19509                                  ;	   CARRY = Clear
 19510                                  ;	IF AN ERROR IS DETECTED
 19511                                  ; All other registers destroyed
 19512                                  ;----------------------------------------------------------------------------
 19513                                  
 19514                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 19515                                  
 19516                                  SETUP:
 19517                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 19518                                  
 19519                                  	;lds 	si,[es:di+7]
 19520 00004229 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 19521                                  
 19522                                  ;hkn; SS override
 19523 0000422D 368C1E[2605]            	MOV	[SS:THISDPB+2],DS
 19524                                  
 19525                                  ;hkn; SS is DOSDATA
 19526 00004232 16                      	push	ss
 19527 00004233 1F                      	pop	ds
 19528                                  
 19529 00004234 8936[2405]              	MOV	[THISDPB],SI
 19530                                  
 19531 00004238 8B1E[DA02]              	MOV	BX,[DMAADD]
 19532 0000423C 891E[5005]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 19533 00004240 C606[0F05]00            	MOV	BYTE [TRANS],0		;No transferes
 19534                                  	;mov	ax,[es:di+15h]
 19535 00004245 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 19536                                  	;mov	dx,[es:di+17h]
 19537 00004249 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 19538 0000424D 8916[6205]              	MOV	[BYTPOS+2],DX	;Set it
 19539 00004251 A3[6005]                	MOV	[BYTPOS],AX
 19540                                  	;test	word [es:di+5],8080h
 19541 00004254 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 19542 0000425A 7536                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 19543 0000425C 06                      	PUSH	ES
 19544 0000425D C42E[2405]              	LES	BP,[THISDPB]		;Point at the DPB
 19545                                  	;mov	bl,[es:bp+0]
 19546                                  	;MOV	BL,[ES:BP+DPB.drive]
 19547 00004261 268A5E00                	mov	bl,[es:bp]
 19548 00004265 881E[1105]              	MOV	[THISDRV],BL		;Set THISDRV
 19549                                  	;mov	bx,[es:bp+2]
 19550 00004269 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 19551                                  
 19552                                  	; MSDOS 3.3
 19553 0000426D 39DA                    	cmp	dx, bx
 19554 0000426F 7336                    	jnb	short EOFERR
 19555 00004271 F7F3                    	div	bx
 19556 00004273 A3[5A05]                	mov	[SECPOS],ax
 19557 00004276 8916[5E05]              	mov	[BYTSECPOS],dx
 19558 0000427A 89C2                    	mov	dx,ax
 19559                                  	;and	al,[es:bp+4]
 19560 0000427C 26224604                	AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 19561 00004280 A2[0E05]                	mov	[SECCLUSPOS],al
 19562 00004283 89C8                    	mov	ax,cx
 19563                                  	;mov	cl,[es:bp+5]
 19564 00004285 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 19565 00004289 D3EA                    	shr	dx,cl
 19566 0000428B 8916[5405]              	mov	[CLUSNUM],dx
 19567 0000428F 07                      	pop	es
 19568 00004290 89C1                    	mov	cx,ax
 19569                                  
 19570                                  	; MSDOS 6.0
 19571                                  ;M039: Optimized this section.
 19572                                          ;PUSH    CX                            ;SHR32 and DIV32 use CX.
 19573                                  	;call	DIV32			      ;DX:AX/BX = CX:AX + DX (rem)
 19574                                  	;MOV	[BYTSECPOS],DX
 19575                                  	;MOV	[SecPos],AX
 19576                                  	;MOV	[SecPos+2],CX
 19577                                  	;MOV	DX,CX
 19578                                  
 19579                                  	;MOV	BX,AX
 19580                                  	;;and	bl,[es:bp+4]
 19581                                  	;AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 19582                                  	;MOV	[SECCLUSPOS],BL
 19583                                  
 19584                                  	;call	SHR32			     ;(DX:AX SHR dpb_cluster_shift)
 19585                                  	;POP	CX			     ;CX = byte count.
 19586                                  	;JNZ	short EOFERR		     ;cluster number above 64k
 19587                                  	;CMP	AX,[ES:BP+DPB.MAX_CLUSTER]   ;>32mb    if > disk size ;AN000;
 19588                                  	;JA	short EOFERR		     ;>32mb    then EOF       ;AN000;
 19589                                  
 19590                                  	;MOV	[CLUSNUM],AX
 19591                                  	;POP	ES			     ; ES:DI point to SFT
 19592                                  ;M039
 19593                                  
 19594                                  NOSETSTUFF:
 19595 00004292 89C8                    	MOV	AX,CX		; AX = Byte count.
 19596 00004294 0306[DA02]              	ADD	AX,[DMAADD]	 ; See if it will fit in one segment
 19597 00004298 730C                    	JNC	short setup_OK		; Must be less than 64K
 19598 0000429A A1[DA02]                	MOV	AX,[DMAADD]
 19599 0000429D F7D8                    	NEG	AX		; Amount of room left in segment (know
 19600                                  				;    less than 64K since max value of CX
 19601                                  				;    is FFFF).
 19602 0000429F 7501                    	JNZ	short NoDec
 19603 000042A1 48                      	DEC	AX
 19604                                  NoDec:
 19605 000042A2 89C1                    	MOV	CX,AX		; Can do this much
 19606 000042A4 E309                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 19607                                  setup_OK:
 19608 000042A6 C3                      	retn
 19609                                  
 19610                                  EOFERR:
 19611 000042A7 07                      	POP	ES		; ES:DI point to SFT
 19612 000042A8 31C9                    	XOR	CX,CX		; No bytes read
 19613                                  ;;;;;;;;;;; 7/18/86
 19614                                  	; MSDOS 3.3
 19615 000042AA C606[8C0F]01            	MOV	BYTE [DISK_FULL],1 ; set disk full flag
 19616                                  ;;;;;;;;;;;
 19617                                  NOROOM:
 19618 000042AF 5B                      	POP	BX		; Kill return address
 19619 000042B0 F8                      	CLC
 19620 000042B1 C3                      	retn			; RETURN TO CALLER OF CALLER
 19621                                  
 19622                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 19623                                  ;---------------------------------------------------------------------------
 19624                                  ;
 19625                                  ; Procedure Name : BREAKDOWN
 19626                                  ;
 19627                                  ; Inputs:
 19628                                  ;	CX = Length of disk transfer in bytes
 19629                                  ;	ES:BP = Base of drive parameters
 19630                                  ;	[BYTSECPOS] = Byte position within first sector
 19631                                  ;	DS = DOSDATA
 19632                                  ; Outputs:
 19633                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 19634                                  ;	[SECCNT] = No. of whole sectors to transfer
 19635                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 19636                                  ; AX, BX, DX destroyed. No other registers affected.
 19637                                  ;---------------------------------------------------------------------------
 19638                                  
 19639                                  BREAKDOWN:
 19640 000042B2 A1[5E05]                	MOV	AX,[BYTSECPOS]
 19641 000042B5 89CB                    	MOV	BX,CX
 19642 000042B7 09C0                    	OR	AX,AX
 19643 000042B9 740E                    	JZ	short SAVFIR	; Partial first sector?
 19644                                  	;sub	ax,[es:bp+2]
 19645 000042BB 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 19646 000042BF F7D8                    	NEG	AX		; Max number of bytes left in first sector
 19647 000042C1 29C3                    	SUB	BX,AX		; Subtract from total length
 19648 000042C3 7304                    	JAE	short SAVFIR
 19649 000042C5 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 19650 000042C7 31DB                    	XOR	BX,BX		; And no bytes are left
 19651                                  SAVFIR:
 19652 000042C9 A3[6405]                	MOV	[BYTCNT1],AX
 19653 000042CC 89D8                    	MOV	AX,BX
 19654 000042CE 31D2                    	XOR	DX,DX
 19655                                  	;div	word [ES:BP+2]
 19656 000042D0 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 19657 000042D4 A3[6805]                	MOV	[SECCNT],AX
 19658 000042D7 8916[6605]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 19659                                  	; MSDOS 3.3
 19660                                  ;	OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 19661                                  ;	retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 19662                                  ;	CMP	AX,1
 19663                                  ;	retnz
 19664                                  ;	MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 19665                                  ;	MOV	[BYTCNT2],AX
 19666                                  ;	MOV	[SECCNT],DX	; DX = 0
 19667                                  _RET45:
 19668 000042DB C3                      	retn
 19669                                  
 19670                                  ;----------------------------------------------------------------------------
 19671                                  ;
 19672                                  ; Procedure Name : READ_LOCK_VIOLATION
 19673                                  ;
 19674                                  ; ES:DI points to SFT. This entry used by NET_READ
 19675                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 19676                                  ; Else do retrys.
 19677                                  ; ES:DI,DS,CX preserved
 19678                                  ;
 19679                                  ;----------------------------------------------------------------------------
 19680                                  
 19681                                  READ_LOCK_VIOLATION:
 19682 000042DC C606[1005]00            	MOV	byte [READOP],0
 19683                                  ERR_ON_CHECK:
 19684                                  	;test	word [es:di+2],8000h
 19685 000042E1 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 19686 000042E7 750E                    	JNZ	short HARD_ERR
 19687 000042E9 51                      	PUSH	CX
 19688 000042EA 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 19689                                  	;and	cl,0F0h
 19690 000042EE 80E1F0                  	AND	CL,SHARING_MASK
 19691                                  	;cmp	cl,0
 19692 000042F1 80F900                  	CMP	CL,SHARING_COMPAT
 19693 000042F4 59                      	POP	CX
 19694 000042F5 7505                    	JNE	short NO_HARD_ERR
 19695                                  HARD_ERR:
 19696 000042F7 E80130                  	call	LOCK_VIOLATION
 19697 000042FA 73DF                    	jnc	short _RET45		; User wants Retrys
 19698                                  NO_HARD_ERR:
 19699 000042FC 31C9                    	XOR	CX,CX			;No bytes transferred
 19700                                  	;mov	ax, 21h
 19701 000042FE B82100                  	MOV	AX,error_lock_violation
 19702 00004301 F9                      	STC
 19703 00004302 C3                      	retn
 19704                                  
 19705                                  ;----------------------------------------------------------------------------
 19706                                  ;
 19707                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 19708                                  ;
 19709                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 19710                                  ; This entry used by NET_WRITE
 19711                                  ;
 19712                                  ;----------------------------------------------------------------------------
 19713                                  
 19714                                  WRITE_LOCK_VIOLATION:
 19715 00004303 C606[1005]01            	MOV	byte [READOP],1
 19716 00004308 EBD7                    	JMP	short ERR_ON_CHECK
 19717                                  
 19718                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 19719                                  ;----------------------------------------------------------------------------
 19720                                  ;
 19721                                  ; Procedure Name : DISKREAD
 19722                                  ;
 19723                                  ; Inputs:
 19724                                  ;	Outputs of SETUP
 19725                                  ; Function:
 19726                                  ;	Perform disk read
 19727                                  ; Outputs:
 19728                                  ;    Carry clear
 19729                                  ;	CX = No. of bytes read
 19730                                  ;	ES:DI point to SFT
 19731                                  ;	SFT offset and cluster pointers updated
 19732                                  ;    Carry set
 19733                                  ;	CX = 0
 19734                                  ;	ES:DI point to SFT
 19735                                  ;	AX has error code
 19736                                  ;----------------------------------------------------------------------------
 19737                                  
 19738                                  ;hkn; called from disk.asm. DS already set up.
 19739                                  
 19740                                  DISKREAD:
 19741                                  	;mov	ax,[es:di+11h]
 19742 0000430A 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 19743                                  	;mov	bx,[es:di+13h]
 19744 0000430E 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 19745 00004312 2B06[6005]              	SUB	AX,[BYTPOS]
 19746 00004316 1B1E[6205]              	SBB	BX,[BYTPOS+2]
 19747 0000431A 7226                    	JB	short RDERR		;Read starts past EOF
 19748 0000431C 750A                    	JNZ	short ENUF		;More than 64k to EOF
 19749 0000431E 09C0                    	OR	AX,AX
 19750 00004320 7420                    	JZ	short RDERR		;Read starts at EOF
 19751 00004322 39C8                    	CMP	AX,CX
 19752 00004324 7302                    	JAE	short ENUF		;I/O fits
 19753 00004326 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 19754                                  ENUF:
 19755                                  	; MSDOS 3.3
 19756                                  	;test	byte [es:di+4],8
 19757                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 19758                                  	;jnz	short SET_ACC_ERR
 19759                                  	;call	LOCK_CHECK
 19760                                  	;jnb	short _READ_OK
 19761                                  	;call	READ_LOCK_VIOLATION
 19762                                  	;jnb	short ENUF
 19763                                  	;retn
 19764                                  
 19765                                  	; MSDOS 6.0
 19766 00004328 E876FE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 19767 0000432B 7301                    	JNC	short _READ_OK 		; There are no locks
 19768 0000432D C3                      	retn
 19769                                  
 19770                                  _READ_OK:
 19771 0000432E C42E[2405]              	LES	BP,[THISDPB]
 19772 00004332 E87DFF                  	CALL	BREAKDOWN
 19773 00004335 8B0E[5405]              	MOV	CX,[CLUSNUM]
 19774 00004339 E8750F                  	call	FNDCLUS
 19775                                       	; MSDOS 6.0			;M022 conditional removed here
 19776 0000433C 720F                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 19777                                  					; migrated from 330a - HKN
 19778 0000433E 09C9                    	OR	CX,CX
 19779 00004340 7414                    	JZ	short SKIPERR
 19780                                  RDERR:
 19781 00004342 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 19782 00004344 E9A101                  	jmp	WRTERR22
 19783                                  
 19784                                  ;RDLASTJ: 
 19785                                  	;JMP	RDLAST                  ;M039
 19786                                  
 19787                                  SETSFTJ2: 
 19788 00004347 E9E600                  	JMP	SETSFT
 19789                                  
 19790                                  CANOT_READ:
 19791                                  	; MSDOS 3.3
 19792 0000434A 59                      	POP	CX		;M039.
 19793                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19794 0000434B 59                      	POP	CX              ;Clean stack.
 19795 0000434C 5B                      	POP	BX
 19796                                  
 19797                                  	;entry	SET_ACC_ERR_DS
 19798                                  SET_ACC_ERR_DS:
 19799                                  ;hkn; SS is DOSDATA
 19800                                  	;Context DS
 19801 0000434D 16                      	push	ss
 19802 0000434E 1F                      	pop	ds
 19803                                  
 19804                                  	;entry	SET_ACC_ERR
 19805                                  SET_ACC_ERR:
 19806 0000434F 31C9                    	XOR	CX,CX
 19807                                  	;mov	ax,5
 19808 00004351 B80500                  	MOV	AX,error_access_denied
 19809 00004354 F9                      	STC
 19810 00004355 C3                      	retn
 19811                                  
 19812                                  SKIPERR:
 19813 00004356 8916[5205]              	MOV	[LASTPOS],DX
 19814 0000435A 891E[5405]              	MOV	[CLUSNUM],BX
 19815 0000435E 833E[6405]00            	CMP	word [BYTCNT1],0
 19816 00004363 7405                    	JZ	short RDMID
 19817 00004365 E8BF0F                  	call	BUFRD
 19818 00004368 72E3                    	JC	short SET_ACC_ERR_DS
 19819                                  RDMID:
 19820 0000436A 833E[6805]00            	CMP	word [SECCNT],0
 19821 0000436F 0F84A000                	JZ	RDLAST ; 10/08/2018
 19822 00004373 E82D10                  	call	NEXTSEC
 19823 00004376 72CF                    	JC	short SETSFTJ2
 19824 00004378 C606[0F05]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 19825                                  ONSEC:
 19826 0000437D 8A16[0E05]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 19827 00004381 8B0E[6805]              	MOV	CX,[SECCNT]
 19828 00004385 8B1E[5405]              	MOV	BX,[CLUSNUM]
 19829                                  RDLP:
 19830 00004389 E84810                  	call	OPTIMIZE
 19831 0000438C 72BF                    	JC	short SET_ACC_ERR_DS
 19832 0000438E 57                      	PUSH	DI                      ;DI = Next physical cluster.
 19833 0000438F 50                      	PUSH	AX                      ;AX = # of sectors remaining.
 19834 00004390 53                      	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
 19835                                  	;mov	byte [ALLOWED],38h
 19836 00004391 C606[F702]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 19837 00004396 8E1E[DC02]              	MOV	DS,[DMAADD+2]
 19838                                  
 19839 0000439A 52                      	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
 19840 0000439B 51                      	PUSH	CX                      ;CX = # of contiguous sectors to read.
 19841                                  
 19842                                  	; MSDOS 6.0
 19843                                  	;call	SET_RQ_SC_PARMS 	 ;LB. do this for SC ;AN000;
 19844                                  
 19845                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19846 0000439C E8C9FD                  	call	DREAD
 19847                                  
 19848                                  	; MSDOS 3.3 
 19849 0000439F 5B                      	pop	bx
 19850 000043A0 5A                      	pop	dx
 19851 000043A1 72A7                    	jc	short CANOT_READ
 19852 000043A3 01D3                    	add	bx,dx	; (bx = Extent end)
 19853 000043A5 268A4600                	mov	al,[es:bp] ; mov al,[es:bp+0]
 19854                                  	;mov	al,[ES:BP+DPB.DRIVE] 
 19855 000043A9 E8F819                  	call	SETVISIT
 19856                                  	; ->***
 19857                                  
 19858                                  ;M039
 19859                                  	; MSDOS 6.0 
 19860                                  	;pop	cx
 19861                                  	;pop	dx
 19862                                  	;pop	WORD [TEMP_VAR]
 19863                                  	;jc	short CANOT_READ
 19864                                  
 19865                                  	;mov	[TEMP_VAR2],ds
 19866                                  
 19867                                  ;       CX = # of contiguous sectors read.  (These constitute a block of
 19868                                  ;            sectors, also termed an "Extent".)
 19869                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 19870                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 19871                                  ;       ES:BP -> Drive Parameter Block (DPB).
 19872                                  ;
 19873                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 19874                                  ;	buffers must be "read" into the transfer memory block, so that the
 19875                                  ;       transfer memory reflects the most recent data.
 19876                                  
 19877                                  	;call    DskRdBufScan
 19878                                  
 19879                                  	;;Context DS
 19880                                  	;push	ss
 19881                                  	;pop	ds
 19882                                          
 19883                                  	;pop	cx
 19884                                          ;pop	bx
 19885                                  
 19886                                  ;       CX = # of sector remaining.
 19887                                  ;       BX = Next physical cluster.
 19888                                  ;M039
 19889                                  	; 25/07/2018 - Retro DOS v3.0
 19890                                  	; ***->
 19891                                  	; MSDOS 3.3
 19892                                  	; IBMDOS.COM (1987) - Offset 42BDh
 19893                                  bufq:
 19894                                  ;	DX = Extent start.
 19895                                  ;	BX = Extent end.
 19896                                  ;	 AL = Drive #.
 19897                                  ;     DS:DI-> 1st buffer in queue.
 19898                                  
 19899                                  	;or	byte [di+5],20h
 19900 000043AC 804D0520                	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 19901                                  	;cmp	al,[di+4]	
 19902 000043B0 3A4504                  	cmp	al,[DI+BUFFINFO.buf_ID]
 19903 000043B3 7544                    	jnz	short bufq3
 19904                                  	;cmp	[di+6],dx
 19905 000043B5 395506                  	cmp	[DI+BUFFINFO.buf_sector],dx
 19906 000043B8 723F                    	jb	short bufq3	; Jump if Extent start > buffer sector.
 19907                                  	;cmp	[di+6],bx
 19908 000043BA 395D06                  	cmp	[DI+BUFFINFO.buf_sector],bx
 19909 000043BD 733A                    	jnb	short bufq3	; Jump if Extent end >= buffer sector.
 19910                                  	
 19911                                  	; Buffer sector is in the Extent (contiguous sectors to read)
 19912                                  
 19913                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 19914                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 19915                                  ;       as MRU (Most Recently Used).
 19916                                  
 19917                                  	;test	byte [di+5],40h
 19918 000043BF F6450540                	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 19919 000043C3 7431                    	jz	short bufq2	; clear buffer, check the next buff sec
 19920 000043C5 58                      	pop	ax ; transfer address
 19921 000043C6 50                      	push	ax
 19922 000043C7 57                      	push	di
 19923 000043C8 52                      	push	dx
 19924                                  	;sub	dx,[di+6]
 19925 000043C9 2B5506                  	sub	dx,[DI+BUFFINFO.buf_sector]
 19926 000043CC F7DA                    	neg	dx
 19927                                  
 19928                                  ;       DX = offset (in sectors) of buffer sector within Transfer memory
 19929                                  ;            block.
 19930                                  
 19931 000043CE 89FE                    	mov	si,di
 19932 000043D0 89C7                    	mov	di,ax
 19933 000043D2 89D0                    	mov	ax,dx
 19934                                  	;mov	cx,[es:bp+6]	
 19935 000043D4 268B4E02                	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 19936 000043D8 F7E1                    	mul	cx
 19937 000043DA 01C7                    	add	di,ax
 19938                                  
 19939 000043DC 8D7410                  	lea	si,[si+16]
 19940 000043DF 8D7410                  	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 19941 000043E2 D1E9                           	shr	cx,1
 19942 000043E4 06                      	push	es
 19943 000043E5 368E06[DC02]            	mov	es,[SS:DMAADD+2]
 19944                                  
 19945                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 19946                                  ;       DS:SI-> Buffer sector data.
 19947                                  ;       ES:DI-> Destination within Transfer memory block.
 19948                                  
 19949 000043EA F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 19950                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 19951                                  	;rep	movsb                   ;Copy last byte.
 19952 000043EC 7301                    	jnc	short bufq1
 19953 000043EE A4                      	movsb
 19954                                  bufq1:
 19955 000043EF 07                      	pop	es
 19956 000043F0 5A                      	pop	dx
 19957 000043F1 5F                      	pop	di
 19958 000043F2 268A4600                	mov	al,[es:bp]  ; mov al,[es:bp+0]
 19959                                  	;mov	al,[ES:BP+DPB.DRIVE]
 19960                                  bufq2:
 19961 000043F6 E8D819                  	call	SCANPLACE
 19962                                  bufq3:
 19963 000043F9 E8C119                  	call	SKIPVISIT
 19964 000043FC 75AE                    	jnz	short bufq
 19965                                  	
 19966 000043FE 16                      	push	ss
 19967 000043FF 1F                      	pop	ds
 19968 00004400 59                      	pop	cx
 19969 00004401 59                      	pop	cx
 19970 00004402 5B                      	pop	bx	
 19971                                  bufq4:
 19972 00004403 E30E                    	JCXZ	RDLAST
 19973 00004405 E83116                  	call	IsEOF			; test for eof on fat size
 19974 00004408 7326                    	JAE	short SETSFT
 19975 0000440A B200                    	MOV	DL,0
 19976 0000440C FF06[5205]              	INC	word [LASTPOS]		; We'll be using next cluster
 19977 00004410 E976FF                  	JMP	RDLP
 19978                                  
 19979                                  RDLAST:
 19980 00004413 A1[6605]                	MOV	AX,[BYTCNT2]
 19981 00004416 09C0                    	OR	AX,AX
 19982 00004418 7416                    	JZ	short SETSFT
 19983 0000441A A3[6405]                	MOV	[BYTCNT1],AX
 19984 0000441D E8830F                  	call	NEXTSEC
 19985 00004420 720E                    	JC	short SETSFT
 19986 00004422 C706[5E05]0000          	MOV	word [BYTSECPOS],0
 19987 00004428 E8FC0E                  	call	BUFRD
 19988                                  	; 10/08/2018
 19989 0000442B 7303                    	JNC	short SETSFT
 19990 0000442D E91DFF                  	JMP	SET_ACC_ERR_DS
 19991                                  
 19992                                  ;------------------------------------------------------------------------------
 19993                                  ;
 19994                                  ; Procedure Name : SETSFT
 19995                                  ; Inputs:
 19996                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 19997                                  ;		and set cluster fields
 19998                                  ; Function:
 19999                                  ;	Update [THISSFT] based on the transfer
 20000                                  ; Outputs:
 20001                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 20002                                  ;	ES:DI points to [THISSFT]
 20003                                  ;	CX No. of bytes transferred
 20004                                  ;	Carry clear
 20005                                  ;
 20006                                  ;----------------------------------------------------------------------------
 20007                                  
 20008                                  	;entry	SETSFT
 20009                                  
 20010                                  ; 26/07/2018 - Retro DOS v3.0
 20011                                  SETSFT:
 20012 00004430 C43E[3605]              	LES	DI,[THISSFT]
 20013                                  
 20014                                  ; Same as SETSFT except ES:DI already points to SFT
 20015                                  	;entry	SETCLUS
 20016                                  SETCLUS:	
 20017 00004434 8B0E[5005]              	MOV	CX,[NEXTADD]
 20018 00004438 2B0E[DA02]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 20019                                  	;test	word [es:di+5],80h
 20020 0000443C 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 20021 00004442 750E                    	JNZ	short ADDREC		; don't set clusters if device
 20022 00004444 A1[5405]                	MOV	AX,[CLUSNUM]
 20023                                  	;mov	[es:di+1Bh],ax
 20024 00004447 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 20025 0000444B A1[5205]                	MOV	AX,[LASTPOS]
 20026                                  	;mov	[es:di+19h],ax
 20027 0000444E 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 20028                                  
 20029                                  ;----------------------------------------------------------------------------
 20030                                  ;
 20031                                  ; Procedure : AddRec
 20032                                  ; Inputs:
 20033                                  ;	ES:DI points to SFT
 20034                                  ;	CX is No. Bytes transferred
 20035                                  ; Function:
 20036                                  ;	Update the SFT offset based on the transfer
 20037                                  ; Outputs:
 20038                                  ;	sf_position updated to point to first byte after transfer
 20039                                  ;	ES:DI points to SFT
 20040                                  ;	CX No. of bytes transferred
 20041                                  ;	Carry clear
 20042                                  ;----------------------------------------------------------------------------
 20043                                  
 20044                                  	;entry	AddRec
 20045                                  ADDREC:
 20046 00004452 E309                    	JCXZ	RET28		; If no records read,  don't change position
 20047                                  	;add	[es:di+15h],cx
 20048 00004454 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 20049                                  	;adc	word [es:di+17h], 0
 20050 00004458 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 20051                                  RET28:	
 20052 0000445D F8                      	CLC
 20053 0000445E C3                      	retn
 20054                                  
 20055                                  ; 25/07/2018
 20056                                  ; MSDOS 6.0
 20057                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 20058                                  ;----------------------------------------------------------------------------
 20059                                  ;
 20060                                  ; Procedure Name : DskRdBufScan
 20061                                  ;
 20062                                  ; Inputs:
 20063                                  ;       CX = # of contiguous sectors read.  (These constitute a block of
 20064                                  ;            sectors, also termed an "Extent".)
 20065                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 20066                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 20067                                  ;       ES:BP -> Drive Parameter Block (DPB).
 20068                                  ;
 20069                                  ; Function:
 20070                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 20071                                  ;	"read" into the transfer memory block, so that the transfer memory
 20072                                  ;	reflects the most recent data.
 20073                                  ;
 20074                                  ; Outputs:
 20075                                  ;       Transfer memory updated as required.
 20076                                  ;
 20077                                  ; Uses:
 20078                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 20079                                  ;       SS override for all global variables.
 20080                                  ;
 20081                                  ; Notes:
 20082                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 20083                                  ;	than the FIRST.
 20084                                  ;----------------------------------------------------------------------------
 20085                                  ;M039: Created
 20086                                  
 20087                                  ;procedure   DskRdBufScan,NEAR
 20088                                  ;
 20089                                  ;ASSUME  DS:NOTHING
 20090                                  ;
 20091                                  ;	cmp	[DirtyBufferCount],0	;Any dirty buffers?
 20092                                  ;	je	bufx			; -no, skip all work.
 20093                                  ;
 20094                                  ;       mov     bx,[HIGH_SECTOR]
 20095                                  ;       mov     si,bx
 20096                                  ;       add     cx,dx
 20097                                  ;       adc     si,0
 20098                                  ;
 20099                                  ;	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 20100                                  ;       mov     ax,[di].buf_prev
 20101                                  ;       mov     [FIRST_BUFF_ADDR],ax
 20102                                  ;
 20103                                  ;       Assert  ISDPB,<ES,BP>,"DISKREAD/bufchk"
 20104                                  ;	mov	al,es:[bp].dpb_drive
 20105                                  ;
 20106                                  ;;            BX:DX = Extent start.
 20107                                  ;;            SI:CX = Extent end + 1.
 20108                                  ;;               AL = Drive #.
 20109                                  ;;            DS:DI-> 1st buffer in queue.
 20110                                  ;;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 20111                                  ;
 20112                                  ;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
 20113                                  ;	jne     bufq1        		;  -no, jump.
 20114                                  ;
 20115                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20116                                  ;       ja	bufq1			;Jump if Extent start > buffer sector.
 20117                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20118                                  ;       ja	bufq2                   ;Jump if Extent end >= buffer sector.
 20119                                  ;
 20120                                  ;bufq1:	cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
 20121                                  ;       mov     di,[di].buf_next        ; Set-up for next buffer.
 20122                                  ;       jne     bufq                    ; -no, do next buffer
 20123                                  ;
 20124                                  ;bufx:   return                          ;Exit.
 20125                                  ;
 20126                                  ;;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 20127                                  ;;	transfer memory; otherwise, just re-position it in the buffer queue
 20128                                  ;;       as MRU (Most Recently Used).
 20129                                  ;
 20130                                  ;bufq2:	SaveReg <ax>
 20131                                  ;	testb   [di.buf_flags],buf_dirty ;Buffer dirty?
 20132                                  ;	jz      bufq3                    ; -no, jump.
 20133                                  ;
 20134                                  ;        SaveReg <cx,dx,si,di,es>
 20135                                  ;
 20136                                  ;	mov     ax,dx
 20137                                  ;	sub	ax, word ptr [di].buf_sector
 20138                                  ;	neg	ax
 20139                                  ;
 20140                                  ;;       AX = offset (in sectors) of buffer sector within Transfer memory
 20141                                  ;;            block.  (Note: the upper word of the sector # may be ignored
 20142                                  ;;	     since no more than 64k bytes will ever be read.  This 64k limit
 20143                                  ;;            is imposed by the input parameters of the disk read operation.)
 20144                                  ;
 20145                                  ;	lea	si,[di].BUFINSIZ	;DS:SI -> buffer data.
 20146                                  ;	mov     cx,es:[bp].dpb_sector_size ;CX = sector size (in bytes).
 20147                                  ;	mul     cx			;AX = offset (in bytes) of buf. sector
 20148                                  ;	mov     di,WORD PTR [TEMP_VAR]
 20149                                  ;	add	di,ax
 20150                                  ;	mov	es,WORD PTR [TEMP_VAR2]
 20151                                  ;	shr	cx,1
 20152                                  ;
 20153                                  ;;	   CX = sector size (in WORDs); CF=1 if odd # of bytes.
 20154                                  ;;       DS:SI-> Buffer sector data.
 20155                                  ;;       ES:DI-> Destination within Transfer memory block.
 20156                                  ;
 20157                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 20158                                  ;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 20159                                  ;	rep	movsb                   ;Copy last byte.
 20160                                  ;	RestoreReg <es,di,si,dx,cx>
 20161                                  ;
 20162                                  ;       DS:DI -> current buffer.
 20163                                  ;
 20164                                  ;bufq3:	mov     ax,di			;DS:AX -> Current buffer.
 20165                                  ;       invoke  SCANPLACE
 20166                                  ;       cmp	ax,[FIRST_BUFF_ADDR]    ;Last buffer?
 20167                                  ;       RestoreReg <ax>
 20168                                  ;       jnz    	bufq                   	; -no, jump.
 20169                                  ;       jmp     short bufx              ; -yes, exit.
 20170                                  ;
 20171                                  ;EndProc DskRdBufScan
 20172                                  
 20173                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 20174                                  ;----------------------------------------------------------------------------
 20175                                  ;
 20176                                  ; Procedure Name : DISKWRITE
 20177                                  ;
 20178                                  ; Inputs:
 20179                                  ;       Outputs of SETUP
 20180                                  ; Function:
 20181                                  ;       Perform disk write
 20182                                  ; Outputs:
 20183                                  ;    Carry clear
 20184                                  ;       CX = No. of bytes read
 20185                                  ;       ES:DI point to SFT
 20186                                  ;       SFT offset and cluster pointers updated
 20187                                  ;    Carry set
 20188                                  ;       CX = 0
 20189                                  ;       ES:DI point to SFT
 20190                                  ;       AX has error code
 20191                                  ;----------------------------------------------------------------------------
 20192                                  
 20193                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 20194                                  
 20195                                  DISKWRITE:
 20196                                  	; MSDOS 3.3
 20197                                  	; IBMDOS.COM - Offset 436Dh
 20198                                  	;;test	byte [es:di+4],8
 20199                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 20200                                  	;jz	short write_cont
 20201                                  	;jmp	SET_ACC_ERR_DS
 20202                                  ;write_cont:
 20203                                  	;push	cx
 20204                                  	;or	cx, cx
 20205                                  	;jnz	short Not_Truncate
 20206                                  	;;mov	cx,-1
 20207                                  	;dec	cx
 20208                                  ;Not_Truncate:
 20209                                  	;call	LOCK_CHECK
 20210                                  	;pop	cx
 20211                                  	;jnb	short _WRITE_OK
 20212                                  	;call	WRITE_LOCK_VIOLATION
 20213                                  	;jnb	short DISKWRITE
 20214                                  	;retn
 20215                                  
 20216                                  	; MSDOS 6.0
 20217 0000445F E821FD                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 20218                                  	; 19/08/2018
 20219 00004462 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 20220 00004464 C3                      	retn
 20221                                  
 20222                                  WRTEOFJ:
 20223 00004465 E99501                  	JMP     WRTEOF
 20224                                  
 20225                                  _WRITE_OK:
 20226                                   	; 27/07/2018
 20227                                  	; IBMDOS.COM - Offset 438Eh
 20228                                  	
 20229                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20230                                  	;and	word [es:di+5],0BFBFh
 20231 00004468 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 20232                                  				; Mark file as dirty, clear no date on close
 20233                                  	; MSDOS 6.0
 20234                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 20235                                          ;MOV	[TEMP_VAR],AX                           ;M039
 20236                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 20237                                          ;MOV	[TEMP_VAR2],AX                          ;M039
 20238                                  
 20239                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 20240                                  
 20241                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20242 0000446E C42E[2405]              	LES     BP,[THISDPB]
 20243                                  
 20244 00004472 E83DFE                  	call	BREAKDOWN
 20245                                  
 20246 00004475 A1[6005]                	MOV     AX,[BYTPOS]
 20247 00004478 8B16[6205]              	MOV     DX,[BYTPOS+2]
 20248 0000447C E3E7                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 20249 0000447E 01C8                    	ADD     AX,CX
 20250 00004480 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 20251                                  
 20252                                  	;mov	bx,[es:bp+2]
 20253 00004483 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 20254                                  
 20255                                  	; MSDOS 6.0
 20256                                  	;CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 20257                                  	;MOV	SI,AX
 20258                                          ;MOV	[HIGH_SECTOR],CX
 20259                                  
 20260                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 20261                                  
 20262                                  	;OR	DX,DX
 20263                                  	;PUSH	DX			;M039: Free DX for use by SHR32
 20264                                  	;MOV	DX,CX			;M039
 20265                                  	;JNZ	short CALCLUS
 20266                                  	;SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 20267                                  	;SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 20268                                  
 20269                                  	; MSDOS 3.3
 20270 00004487 39DA                    	cmp	dx,bx
 20271 00004489 7360                    	jnb	short WRTERR33
 20272 0000448B F7F3                    	div	bx
 20273 0000448D 89C3                    	mov	bx,ax
 20274 0000448F 09D2                    	OR	DX,DX
 20275 00004491 7501                    	JNZ	short CALCLUS
 20276 00004493 48                      	dec	ax
 20277                                  
 20278                                  CALCLUS:
 20279                                  	; MSDOS 3.3
 20280                                  	;mov	cl,[es:bp+5]
 20281 00004494 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 20282 00004498 D3E8                    	shr	ax,cl
 20283 0000449A 50                      	push	ax
 20284 0000449B 52                      	push	dx
 20285 0000449C 06                      	push	es
 20286 0000449D C43E[3605]              	les	di,[THISSFT]
 20287                                  	;mov	ax,[es:di+11h]
 20288                                  	;mov	dx,[es:di+13h]
 20289 000044A1 268B4511                	mov	ax,[ES:DI+SF_ENTRY.sf_size]
 20290 000044A5 268B5513                	mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 20291 000044A9 07                      	pop	es
 20292                                  	;DX:AX = current file size (in bytes).
 20293                                  	;div	word [es:bp+2]
 20294 000044AA 26F77602                	div	word [ES:BP+DPB.SECTOR_SIZE]
 20295 000044AE 89C1                    	mov	cx,ax
 20296 000044B0 09D2                    	or	dx,dx
 20297 000044B2 7401                    	jz	short NORND
 20298 000044B4 40                      	inc	ax
 20299                                  
 20300                                  	; MSDOS 6.0
 20301                                  	;CALL	SHR32                   ;F.C. >32mb			;AN000;
 20302                                  	;POP	DX
 20303                                  
 20304                                  ;       AX = Last cluster to write.
 20305                                  ;       DX = # of bytes in last sector to write (the "tail").
 20306                                  ;       BX = ES:[BP.dpb_sector_size]
 20307                                  
 20308                                  	;PUSH	AX
 20309                                  	;PUSH	DX
 20310                                  ;M039
 20311                                  	;mov	dx,[TEMP_VAR2]
 20312                                  	;mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 20313                                  	;call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 20314                                  	;mov	[TEMP_VAR2],cx
 20315                                  	;mov	[VALSEC+2],cx
 20316                                  	;mov	cx,ax
 20317                                  	;mov	bx,si
 20318                                  
 20319                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 20320                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 20321                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 20322                                  ;                     DX = # of bytes in last sector of current file.
 20323                                  ;M039
 20324                                  	;OR	DX,DX
 20325                                  	;JZ	short NORND
 20326                                  	;ADD	AX,1            	;Round up if any remainder	;AC000;
 20327                                  	;ADC	word [VALSEC+2],0
 20328                                  NORND:	
 20329                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20330 000044B5 A3[5C05]                	MOV     [VALSEC],AX
 20331                                  
 20332                                  ;       [VALSEC] = Last sector of current file.
 20333                                  
 20334 000044B8 31C0                    	XOR     AX,AX
 20335 000044BA A3[7005]                	MOV     [GROWCNT],AX
 20336 000044BD A3[7205]                	MOV     [GROWCNT+2],AX
 20337 000044C0 58                      	POP     AX
 20338                                  
 20339                                  	; MSDOS 6.0
 20340                                  	;MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 20341                                  	;CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb			;AN000;
 20342                                  	;JB	short NOGROW		;F.C. >32mb                             ;AN000;
 20343                                  	;JZ	short lowsec		;F.C. >32mb                             ;AN000;
 20344                                  	;SUB	BX,CX                   ;F.C. >32mb                             ;AN000;
 20345                                  	;SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors	;AN000;
 20346                                  	;JMP	short yesgrow           ;F.C. >32mb                             ;AN000;
 20347                                  ;lowsec:
 20348                                  	;MOV	DI,0			;F.C. >32mb
 20349                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20350 000044C1 29CB                    	SUB	BX,CX			; Number of full sectors
 20351 000044C3 723D                    	JB	short NOGROW
 20352 000044C5 742E                    	JZ	short TESTTAIL
 20353                                  ;yesgrow:
 20354                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20355 000044C7 89D1                    	MOV     CX,DX
 20356 000044C9 93                      	XCHG    AX,BX
 20357                                  	;mul	word [es:bp+2]
 20358 000044CA 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 20359                                  	
 20360                                  	; MSDOS 6.0
 20361                                  	;MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 20362                                  	;MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 20363                                  	;MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 20364                                  	;;mul	word [es:bp+2]
 20365                                  	;MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 20366                                  	
 20367                                  	;ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 20368                                  	;MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 20369                                  	;MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 20370                                  
 20371                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20372 000044CE 29C8                    	SUB     AX,CX           ; Take off current "tail"
 20373 000044D0 83DA00                  	SBB     DX,0            ; 32-bit extension
 20374 000044D3 01D8                    	ADD     AX,BX           ; Add on new "tail"
 20375 000044D5 83D200                  	ADC     DX,0            ; ripple tim's head off
 20376 000044D8 EB21                    	JMP     SHORT SETGRW
 20377                                  
 20378                                  HAVSTART:
 20379                                  	;int 3
 20380 000044DA 89C1                    	MOV     CX,AX
 20381 000044DC E8F20D                  	call	SKPCLP
 20382                                  	;JCXZ	DOWRTJ
 20383 000044DF E357                    	jcxz	DOWRT
 20384                                  
 20385 000044E1 E8610F                  	call	ALLOCATE
 20386                                  	;JNC	short DOWRTJ
 20387 000044E4 7352                    	jnc	short DOWRT
 20388                                  
 20389                                  	;entry   WRTERR
 20390                                  WRTERR:
 20391 000044E6 B40F                    	MOV     AH,0FH                          ;MS. write/data/fail/abort      ;AN000;
 20392                                  
 20393                                  	;entry WRTERR22
 20394                                  WRTERR22:
 20395 000044E8 A0[1105]                	MOV     AL,[THISDRV]                    ;MS.                            ;AN000;
 20396                                  
 20397                                  	; 27/07/2018
 20398                                  WRTERR33:
 20399                                  	;MOV	CX,0                    	;No bytes transferred
 20400 000044EB 31C9                    	XOR     CX,CX
 20401                                  					
 20402 000044ED C43E[3605]              	LES     DI,[THISSFT]
 20403                                  	;CLC	; 19/05/2019
 20404 000044F1 C3                      	retn
 20405                                  
 20406                                  ;DOWRTJ: 
 20407                                  ;	JMP     short DOWRT
 20408                                  
 20409                                  ACC_ERRWJ:
 20410                                  	; 10/08/2018
 20411                                  	;JMP	SET_ACC_ERRW
 20412 000044F2 E958FE                  	jmp	SET_ACC_ERR_DS
 20413                                  
 20414                                  TESTTAIL:
 20415 000044F5 29D0                    	SUB     AX,DX
 20416 000044F7 7609                    	JBE	short NOGROW
 20417 000044F9 31D2                    	XOR     DX,DX
 20418                                  SETGRW:
 20419 000044FB A3[7005]                	MOV	[GROWCNT],AX
 20420 000044FE 8916[7205]              	MOV	[GROWCNT+2],DX
 20421                                  NOGROW:
 20422 00004502 58                      	POP     AX
 20423 00004503 8B0E[5405]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 20424 00004507 E8A70D                  	call	FNDCLUS
 20425 0000450A 72E6                    	JC	short ACC_ERRWJ
 20426 0000450C 891E[5405]              	MOV     [CLUSNUM],BX
 20427 00004510 8916[5205]              	MOV     [LASTPOS],DX
 20428                                  
 20429 00004514 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 20430 00004516 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 20431 00004518 E3C0                    	JCXZ    HAVSTART        ; See if no more data
 20432 0000451A 51                      	PUSH    CX              ; No. of clusters short of first
 20433 0000451B 89C1                    	MOV     CX,AX
 20434 0000451D E8250F                  	call	ALLOCATE
 20435 00004520 59                      	POP     CX
 20436 00004521 72C3                    	JC	short WRTERR
 20437 00004523 8B16[5205]              	MOV     DX,[LASTPOS]
 20438 00004527 42                      	INC     DX
 20439 00004528 49                      	DEC     CX
 20440 00004529 7405                    	JZ	short NOSKIP
 20441 0000452B E8A30D                  	call	SKPCLP
 20442 0000452E 72C2                    	JC	short ACC_ERRWJ
 20443                                  NOSKIP:
 20444 00004530 891E[5405]              	MOV     [CLUSNUM],BX
 20445 00004534 8916[5205]              	MOV     [LASTPOS],DX
 20446                                  DOWRT:
 20447 00004538 833E[6405]00            	CMP     word [BYTCNT1],0
 20448 0000453D 7409                    	JZ	short WRTMID
 20449 0000453F 8B1E[5405]              	MOV     BX,[CLUSNUM]
 20450 00004543 E8180E                  	call	BUFWRT
 20451 00004546 72AA                    	JC	short ACC_ERRWJ
 20452                                  	;JC	short SET_ACC_ERRW
 20453                                  WRTMID:
 20454 00004548 A1[6805]                	MOV     AX,[SECCNT]
 20455 0000454B 09C0                    	OR      AX,AX
 20456 0000454D 7471                    	JZ	short WRTLAST		;M039
 20457 0000454F 0106[5A05]              	ADD     [SECPOS],AX
 20458                                  	; MSDOS 6.0
 20459                                  	;ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 20460 00004553 E84D0E                  	call	NEXTSEC
 20461 00004556 729A                    	JC	short ACC_ERRWJ
 20462                                  	;JC	short SET_ACC_ERRW	;M039
 20463 00004558 C606[0F05]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 20464 0000455D 8A16[0E05]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 20465 00004561 8B1E[5405]              	MOV     BX,[CLUSNUM]
 20466 00004565 8B0E[6805]              	MOV     CX,[SECCNT]
 20467                                  WRTLP:
 20468 00004569 E8680E                  	call	OPTIMIZE
 20469 0000456C 7284                    	JC	short ACC_ERRWJ
 20470                                  	;JC	short SET_ACC_ERRW
 20471                                  
 20472                                  ;M039
 20473                                  ;       DI = Next physical cluster.
 20474                                  ;       AX = # sectors remaining.
 20475                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 20476                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 20477                                  ;	     sectors, also termed an "Extent".)
 20478                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 20479                                  ;       ES:BP -> Drive Parameter Block (DPB).
 20480                                  ;
 20481                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 20482                                  ;	are in Extent; they are being over-written.
 20483                                  
 20484 0000456E 57                      	push    di
 20485 0000456F 50                      	push    ax
 20486                                  
 20487                                          ; MSDOS 6.0
 20488                                  	;call	DskWrtBufPurge          ;DS trashed.
 20489                                  ;ASSUME DS:NOTHING
 20490                                  ;M039
 20491                                  	; MSDOS 3.3
 20492                                  	; IBMDOS.COM (1987) - Offset 4497h
 20493 00004570 52                      	push	dx
 20494 00004571 53                      	push	bx
 20495 00004572 268A4600                	mov	al,[es:bp]
 20496                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 20497 00004576 89CB                    	mov	bx,cx
 20498 00004578 01D3                    	add	bx,dx	; (bx = Extent end)
 20499                                  
 20500                                  ;	DX = Extent start.
 20501                                  ;	BX = Extent end.
 20502                                  ;	 AL = Drive #.
 20503                                  
 20504 0000457A E82718                  	call	SETVISIT
 20505                                  
 20506                                  wbufq1:
 20507                                  	;or	byte [di+5],20h
 20508 0000457D 804D0520                	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 20509                                  	;cmp	al,[di+4]	
 20510 00004581 3A4504                  	cmp	al,[DI+BUFFINFO.buf_ID]
 20511 00004584 7512                    	jnz	short wbufq2	; Jump if Extent start > buffer sector.
 20512                                  	;cmp	[di+6],dx
 20513 00004586 395506                  	cmp	[DI+BUFFINFO.buf_sector],dx
 20514 00004589 720D                    	jb	short wbufq2
 20515                                  	;cmp	[di+6],bx
 20516 0000458B 395D06                  	cmp	[DI+BUFFINFO.buf_sector],bx
 20517 0000458E 7308                    	jnb	short wbufq2	; Jump if Extent end >= buffer sector.
 20518                                  
 20519                                  	; Buffer sector is in the Extent
 20520                                  
 20521                                  	;mov	word [di+4],20FFh
 20522 00004590 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],20FFh
 20523                                  					; .buf_ID,    AL = FFh (Free buffer)
 20524                                  					; .buf_flags, AH = 0, reset/clear
 20525 00004595 E83918                  	call	SCANPLACE
 20526                                  wbufq2:
 20527 00004598 E82218                  	call	SKIPVISIT
 20528 0000459B 75E0                    	jnz	short wbufq1
 20529 0000459D 5B                      	pop	bx
 20530 0000459E 5A                      	pop	dx
 20531                                  	
 20532                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20533                                  ;hkn; SS override for DMAADD and ALLOWED
 20534 0000459F 368E1E[DC02]            	MOV     DS,[SS:DMAADD+2]
 20535                                  	;mov	byte [ss:ALLOWED],38h
 20536 000045A4 36C606[F702]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 20537                                  
 20538                                  ;	put logic from DWRITE in-line here so we can modify it
 20539                                  ;	for DISK FULL conditions.
 20540                                  
 20541                                  DWRITE_LUP:
 20542                                  	; MSDOS 6.0
 20543                                  	;call	DSKWRITE
 20544                                  	;jz	short DWRITE_OKAY
 20545                                  
 20546                                  ;;	int	3
 20547                                  	;cmp	al,error_handle_Disk_Full	; compressed volume full?
 20548                                  	;jz	short DWRITE_DISK_FULL
 20549                                  
 20550                                  ;;hkn; SS override
 20551                                  	;MOV	BYTE [SS:READOP],1
 20552                                  	;call	HARDERRRW
 20553                                  	;CMP	AL,1		; Check for retry
 20554                                  	;JZ	short DWRITE_LUP
 20555                                  	;CMP	AL,3		; Check for FAIL
 20556                                  	;CLC
 20557                                  	;JNZ	short DWRITE_OKAY ; Ignore
 20558                                  	;STC
 20559                                  
 20560                                  	; MSDOS 3.3
 20561 000045AA E81AFC                  	call	DWRITE
 20562                                  
 20563                                  DWRITE_OKAY:
 20564                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20565                                  
 20566 000045AD 59                      	POP     CX
 20567 000045AE 5B                      	POP     BX
 20568                                  
 20569                                  ;       CX = # sectors remaining.
 20570                                  ;       BX = Next physical cluster.
 20571                                  
 20572                                  ;hkn; SS override
 20573                                          ;Context DS
 20574 000045AF 16                      	push	ss
 20575 000045B0 1F                      	pop	ds
 20576                                  
 20577 000045B1 720A                    	JC      SET_ACC_ERRW
 20578 000045B3 E30B                    	JCXZ    WRTLAST
 20579 000045B5 B200                    	MOV     DL,0
 20580 000045B7 FF06[5205]              	INC     word [LASTPOS]	; We'll be using next cluster
 20581 000045BB EBAC                    	JMP     short WRTLP
 20582                                  
 20583                                  	; 09/08/2018
 20584                                  	; MSDOS 6.0
 20585                                  ;DWRITE_DISK_FULL:
 20586                                  	;;Context DS		;SQ 3-5-93 DS must be setup on return!
 20587                                  	;push	ss
 20588                                  	;pop	ds
 20589                                  	;pop	cx		; unjunk stack
 20590                                  	;pop	bx
 20591                                  	;mov	byte [DISK_FULL],1
 20592                                  	;stc
 20593                                  	;jmp	short WRTERR	; go to disk full exit
 20594                                  
 20595                                  SET_ACC_ERRW:
 20596 000045BD E98DFD                  	jmp	SET_ACC_ERR_DS
 20597                                  
 20598                                  WRTLAST:
 20599 000045C0 A1[6605]                	MOV     AX,[BYTCNT2]
 20600 000045C3 09C0                    	OR      AX,AX
 20601 000045C5 7413                    	JZ	short FINWRT
 20602 000045C7 A3[6405]                	MOV     [BYTCNT1],AX
 20603 000045CA E8D60D                  	call	NEXTSEC
 20604 000045CD 72EE                    	JC	short SET_ACC_ERRW
 20605 000045CF C706[5E05]0000          	MOV     word [BYTSECPOS],0
 20606 000045D5 E8860D                  	call	BUFWRT
 20607 000045D8 72E3                    	JC	short SET_ACC_ERRW
 20608                                  FINWRT:
 20609 000045DA C43E[3605]              	LES     DI,[THISSFT]
 20610 000045DE A1[7005]                	MOV     AX,[GROWCNT]
 20611 000045E1 8B0E[7205]              	MOV     CX,[GROWCNT+2]
 20612 000045E5 09C0                    	OR      AX,AX
 20613 000045E7 7502                    	JNZ	short UPDATE_size
 20614 000045E9 E30F                    	JCXZ    SAMSIZ
 20615                                  UPDATE_size:
 20616                                  	;add	[es:di+11h],ax
 20617 000045EB 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 20618                                  	;adc	[es:di+13h],cx
 20619 000045EF 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 20620                                  ;
 20621                                  ; Make sure that all other SFT's see this growth also.
 20622                                  ;
 20623 000045F3 B80100                  	MOV     AX,1
 20624                                  ;if installed
 20625                                  	;Call	JShare + 14 * 4
 20626 000045F6 FF1E[9400]              	call    far [JShare+(14*4)]	; 14 = ShSU
 20627                                  ;else
 20628                                  ;	Call    ShSU
 20629                                  ;endif
 20630                                  
 20631                                  SAMSIZ:
 20632 000045FA E937FE                  	jmp	SETCLUS	; ES:DI already points to SFT
 20633                                  
 20634                                  WRTEOF:
 20635 000045FD 89C1                    	MOV     CX,AX
 20636 000045FF 09D1                    	OR      CX,DX
 20637 00004601 7464                    	JZ	short KILLFIL
 20638 00004603 83E801                  	SUB     AX,1
 20639 00004606 83DA00                  	SBB     DX,0
 20640                                  
 20641                                  	; MSDOS 3.3
 20642                                  	;div	word [es:bp+2]
 20643 00004609 26F77602                	div	word [ES:BP+DPB.SECTOR_SIZE]
 20644                                  	;mov	cl,[es:bp+5]
 20645 0000460D 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 20646 00004611 D3E8                    	shr     ax,cl
 20647                                  
 20648                                  	; MSDOS 6.0
 20649                                  	;PUSH	BX
 20650                                  	;MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 20651                                  	;CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 20652                                  	;POP	BX			      ;F.C. >32mb			;AN000;
 20653                                  	;MOV	DX,CX			      ;M039
 20654                                          ;MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 20655                                  	;CALL	SHR32                         ;F.C. >32mb                       ;AN000;
 20656                                  
 20657 00004613 89C1                    	MOV     CX,AX
 20658 00004615 E8990C                  	call	FNDCLUS
 20659                                  SET_ACC_ERRWJ2:
 20660 00004618 72A3                    	JC	short SET_ACC_ERRW
 20661                                  
 20662 0000461A E326                    	JCXZ    RELFILE
 20663 0000461C E8260E                  	call	ALLOCATE
 20664 0000461F 721E                    	JC	short WRTERRJ              ;;;;;;;;; disk full
 20665                                  
 20666                                  UPDATE:
 20667 00004621 C43E[3605]              	LES	DI,[THISSFT]
 20668 00004625 A1[6005]                	MOV	AX,[BYTPOS]
 20669                                  	;mov	[es:di+11h],ax
 20670 00004628 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 20671 0000462C A1[6205]                	MOV	AX,[BYTPOS+2]
 20672                                  	;mov	[es:di+13h],ax
 20673 0000462F 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 20674                                  ;
 20675                                  ; Make sure that all other SFT's see this growth also.
 20676                                  ;
 20677 00004633 B80200                  	MOV     AX,2
 20678                                  ;if installed
 20679                                  	;Call	JShare + 14 * 4
 20680 00004636 FF1E[9400]              	call    far [JShare+(14*4)]	; 14 = ShSU
 20681                                  ;else
 20682                                  ;	Call    ShSU
 20683                                  ;endif
 20684 0000463A 31C9                    	XOR     CX,CX
 20685 0000463C E913FE                  	jmp	ADDREC
 20686                                  
 20687                                  WRTERRJ: 
 20688 0000463F E9A4FE                  	JMP     WRTERR
 20689                                  
 20690                                  ;;;;;;;;;;;;;;;; 7/18/86
 20691                                  ;;;;;;;;;;;;;;;;
 20692                                  
 20693                                  RELFILE:
 20694                                  	; MSDOS 6.0
 20695 00004642 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 20696 00004643 C43E[3605]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 20697 00004647 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 20698 0000464B 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 20699 0000464D 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 20700 00004653 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 20701 00004657 2689551B                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 20702                                  SKIPRESET:                            		;AN002; BL
 20703 0000465B 07                      	POP     ES                    		;AN002; BL
 20704                                  ;
 20705 0000465C BAFFFF                  	MOV     DX,0FFFFH
 20706 0000465F E88C0E                  	call	RELBLKS
 20707 00004662 73BD                    	jnc	short UPDATE
 20708                                  SET_ACC_ERRWJJ:
 20709                                  	;JC	short SET_ACC_ERRWJ2
 20710                                  	;JMP	SHORT UPDATE
 20711 00004664 E9E6FC                  	jmp	SET_ACC_ERR_DS
 20712                                  
 20713                                  KILLFIL:
 20714 00004667 31DB                    	XOR     BX,BX
 20715 00004669 06                      	PUSH    ES
 20716 0000466A C43E[3605]              	LES     DI,[THISSFT]
 20717 0000466E 26895D19                	mov	[es:di+19h],bx
 20718 00004672 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 20719                                  	;mov	[es:di+1Bh],bx
 20720 00004676 26895D1B                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 20721                                  	;xchg	bx,[es:di+0Bh]
 20722 0000467A 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 20723 0000467E 07                      	POP	ES
 20724                                  
 20725 0000467F 09DB                    	OR	BX,BX
 20726                                  	;JZ	short UPDATEJ
 20727 00004681 749E                    	jz	short UPDATE
 20728                                  ;; 10/23/86 FastOpen update
 20729 00004683 06                      	PUSH	ES              ; since first cluster # is 0
 20730 00004684 55                      	PUSH	BP              ; we must delete the old cache entry
 20731 00004685 50                      	PUSH	AX
 20732 00004686 51                      	PUSH	CX
 20733 00004687 52                      	PUSH	DX
 20734 00004688 C42E[2405]              	LES	BP,[THISDPB]             ; get current DPB
 20735 0000468C 268A5600                	mov	dl,[ES:BP] ; mov al,[es:bp+0]
 20736                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 20737 00004690 89D9                    	MOV	CX,BX                    ; first cluster #
 20738 00004692 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 20739 00004694 E874ED                  	call	FastOpen_Update          ; call fastopen
 20740 00004697 5A                      	POP	DX
 20741 00004698 59                      	POP	CX
 20742 00004699 58                      	POP	AX
 20743 0000469A 5D                      	POP	BP
 20744 0000469B 07                      	POP	ES
 20745                                  ;; 10/23/86 FastOpen update
 20746                                  
 20747 0000469C E84D0E                  	call	RELEASE
 20748 0000469F 72C3                    	JC	short SET_ACC_ERRWJJ
 20749                                  UpDateJ:
 20750 000046A1 E97DFF                  	JMP	UPDATE ; 10/08/2018
 20751                                  
 20752                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 20753                                  ;----------------------------------------------------------------------------
 20754                                  ;
 20755                                  ; Procedure Name : DskWrtBufPurge
 20756                                  ;
 20757                                  ; Inputs:
 20758                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 20759                                  ;	     sectors, also termed an "Extent".)
 20760                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 20761                                  ;       ES:BP -> Drive Parameter Block (DPB).
 20762                                  ;
 20763                                  ; Function:
 20764                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 20765                                  ;	are in Extent; they are being over-written.
 20766                                  ;
 20767                                  ; Outputs:
 20768                                  ;       (Same as Input.)
 20769                                  ; Uses:
 20770                                  ;       All registers except DS,AX,SI,DI preserved.
 20771                                  ;       SS override for all global variables.
 20772                                  ;----------------------------------------------------------------------------
 20773                                  ;M039: Created
 20774                                  
 20775                                  ;procedure   DskWrtBufPurge,NEAR
 20776                                  ;
 20777                                  ;ASSUME  DS:NOTHING
 20778                                  ;
 20779                                  ;       SaveReg <bx,cx>
 20780                                  ;       mov	bx,[HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 20781                                  ;       mov     si,bx
 20782                                  ;       add     cx,dx
 20783                                  ;       adc     si,0                    ;SI:CX = Extent end + 1.
 20784                                  ;
 20785                                  ;	Assert  ISDPB,<ES,BP>,"DskWrtBufPurge"
 20786                                  ;	mov     al,es:[bp.dpb_drive]
 20787                                  ;
 20788                                  ;;      BX:DX = Extent start.
 20789                                  ;;      SI:CX = Extent end + 1.
 20790                                  ;;      AL = Drive #
 20791                                  ;
 20792                                  ;	cmp     [SC_CACHE_COUNT],0      ;Secondary cache in-use?
 20793                                  ;	je      nosc                    ; -no, jump.
 20794                                  ;
 20795                                  ;;      If any of the sectors to be written are in the secondary cache (SC),
 20796                                  ;;      invalidate the entire SC. (This is an optimization; we really only
 20797                                  ;;	need to invalidate those sectors which intersect, but that's slower.)
 20798                                  ;
 20799                                  ;       cmp     al,[CURSC_DRIVE]        ;Same drive?
 20800                                  ;       jne     nosc                    ; -no, jump.
 20801                                  ;
 20802                                  ;       push    ax
 20803                                  ;       mov     ax,[CURSC_SECTOR]
 20804                                  ;       mov     di,[CURSC_SECTOR+2]     ;DI:AX = SC start.
 20805                                  ;       Cmp32   si,cx,di,ax             ;Extent end < SC start?
 20806                                  ;       jbe     sc5                     ; -yes, jump.
 20807                                  ;       add     ax,[SC_CACHE_COUNT]
 20808                                  ;       adc     di,0                    ;DI:AX = SC end + 1.
 20809                                  ;       Cmp32   bx,dx,di,ax             ;Extent start > SC end?
 20810                                  ;       jae     sc5                     ; -yes, jump.
 20811                                  ;       mov     [SC_STATUS],0           ;Extent intersects SC: invalidate SC.
 20812                                  ;sc5:	pop     ax
 20813                                  ;
 20814                                  ;;	Free any buffered sectors which are in Extent; they are being over-
 20815                                  ;;	written.
 20816                                  ;
 20817                                  ;nosc:	invoke  GETCURHEAD              ;DS:DI -> first buffer in queue.
 20818                                  ;
 20819                                  ;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
 20820                                  ;	jne     bufq5                   ; -no, jump.
 20821                                  ;
 20822                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20823                                  ;       ja	bufq5			;Jump if Extent start > buffer sector.
 20824                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20825                                  ;       jbe	bufq5                   ;Jump if Extent end < buffer sector.
 20826                                  ;
 20827                                  ;;      Buffer's sector is in Extent, so free it; it is being over-written.
 20828                                  ;
 20829                                  ;       testb   [di.buf_flags],buf_dirty ;Buffer dirty?
 20830                                  ;       jz      bufq2                    ; -no, jump.
 20831                                  ;       invoke  DEC_DIRTY_COUNT          ; -yes, decrement dirty count.
 20832                                  ;bufq2: mov     WORD PTR [di.buf_ID],((buf_visit SHL 8) OR 0FFh)
 20833                                  ;
 20834                                  ;       invoke  SCANPLACE
 20835                                  ;       jmp     short bufq6
 20836                                  ;
 20837                                  ;bufq5: mov     di,[di.buf_next]
 20838                                  ;bufq6: cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
 20839                                  ;       jne     bufq	                ; --no, go do next buffer.
 20840                                  ;
 20841                                  ;       RestoreReg <cx,bx>
 20842                                  ;       return
 20843                                  ;
 20844                                  ;EndProc DskWrtBufPurge
 20845                                  
 20846                                  
 20847                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 20848                                  ;----------------------------------------------------------------------------
 20849                                  ;
 20850                                  ; Procedure Name : DIV32
 20851                                  ;
 20852                                  ; Inputs:
 20853                                  ;       DX:AX = 32 bit dividend   BX= divisor
 20854                                  ; Function:
 20855                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 20856                                  ; Outputs:
 20857                                  ;       CX:AX = quotient , DX= remainder
 20858                                  ; Uses:
 20859                                  ;       All registers except AX,CX,DX preserved.
 20860                                  ;----------------------------------------------------------------------------
 20861                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 20862                                  
 20863                                  ;DIV32:
 20864                                  ;
 20865                                  ;       cmp     bx,512
 20866                                  ;       jne    	short div5
 20867                                  ;
 20868                                  ;	mov     cx,dx
 20869                                  ;       mov     dx,ax           ; CX:AX = Dividend
 20870                                  ;       and     dx,(512-1)      ; DX = Remainder
 20871                                  ;       mov     al,ah
 20872                                  ;       mov     ah,cl
 20873                                  ;       mov     cl,ch
 20874                                  ;       xor     ch,ch
 20875                                  ;       shr     cx,1
 20876                                  ;       rcr     ax,1
 20877                                  ;       retn
 20878                                  ;
 20879                                  ;div5:	mov     cx,ax
 20880                                  ;       mov     ax,dx
 20881                                  ;       xor     dx,dx
 20882                                  ;       div     bx              ; 0:AX/BX
 20883                                  ;       xchg    cx,ax
 20884                                  ;       div     bx              ; DX:AX/BX
 20885                                  ;       retn
 20886                                  
 20887                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 20888                                  ;----------------------------------------------------------------------------
 20889                                  ;
 20890                                  ; Procedure Name : SHR32
 20891                                  ;
 20892                                  ; Inputs:
 20893                                  ;	DX:AX = 32 bit sector number
 20894                                  ; Function:
 20895                                  ;       Perform 32 bit shift right
 20896                                  ; Outputs:
 20897                                  ;	AX = cluster number
 20898                                  ;	ZF = 1 if no error
 20899                                  ;	   = 0 if error (cluster number > 64k)
 20900                                  ; Uses:
 20901                                  ;       DX,CX
 20902                                  ;---------------------------------------------------------------------------
 20903                                  ; M017	- SHR32 rewritten for better performance
 20904                                  ; M039	- Additional optimization
 20905                                  
 20906                                  ;SHR32:
 20907                                  ;
 20908                                  ;	mov     cl,[ES:BP+DPB.CLUSTER_SHIFT]
 20909                                  ;	xor	ch,ch	    ;ZF=1
 20910                                  ;	jcxz	norota
 20911                                  ;
 20912                                  ;rotashft2:
 20913                                  ;	shr	dx,1	    ;ZF reflects state of DX.
 20914                                  ;	rcr	ax,1	    ;ZF not affected.
 20915                                  ;	loop	rotashft2
 20916                                  ;
 20917                                  ;norota:
 20918                                  ;	retn
 20919                                  
 20920                                  ;============================================================================
 20921                                  ; DIR.ASM, MSDOS 6.0, 1991
 20922                                  ;============================================================================
 20923                                  ; 27/07/2018 - Retro DOS v3.0 
 20924                                  
 20925                                  ;	TITLE	DIR - Directory and path cracking
 20926                                  ;	NAME	Dir
 20927                                  
 20928                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 20929                                  ;---------------------------------------------------------------------------
 20930                                  ;
 20931                                  ; Procedure Name : FINDENTRY,SEARCH
 20932                                  ;
 20933                                  ; Inputs:
 20934                                  ;	[THISDPB] set
 20935                                  ;	[SECCLUSPOS] = 0
 20936                                  ;	[DIRSEC] = Starting directory sector number
 20937                                  ;	[CLUSNUM] = Next cluster of directory
 20938                                  ;	[CLUSFAC] = Sectors/Cluster
 20939                                  ;	[NAME1] = Name to look for
 20940                                  ; Function:
 20941                                  ;	Find file name in disk directory.
 20942                                  ;	"?" matches any character.
 20943                                  ; Outputs:
 20944                                  ;	Carry set if name not found
 20945                                  ;	ELSE
 20946                                  ;	Zero set if attributes match (always except when creating)
 20947                                  ;	AH = Device ID (bit 7 set if not disk)
 20948                                  ;	[THISDPB] = Base of drive parameters
 20949                                  ;	DS = DOSGROUP
 20950                                  ;	ES = DOSGROUP
 20951                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 20952                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 20953                                  ;	[CURBUF] has directory record with match
 20954                                  ;	[NAME1] has file name
 20955                                  ;	[LASTENT] is entry number of the entry
 20956                                  ; All other registers destroyed.
 20957                                  ;----------------------------------------------------------------------------
 20958                                  
 20959                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 20960                                  ;hkn; this point.
 20961                                  
 20962                                  SEARCH:
 20963                                  	; 27/07/2018 - Retro DOS v3.0
 20964                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 20965                                  	; 15/03/2018 - Retro DOS v2.0
 20966                                  
 20967                                  	;entry	FindEntry
 20968                                  FINDENTRY:
 20969 000046A4 E81704                  	call	STARTSRCH
 20970 000046A7 A0[0605]                	MOV	AL,[ATTRIB]
 20971                                  	;and	al,9Eh
 20972 000046AA 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 20973                                  	;cmp	al,8
 20974 000046AC 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 20975 000046AE 7503                    	JNZ	short NOTVOLSRCH	; No
 20976 000046B0 E86201                  	CALL	SETROOTSRCH		; Yes force search of root
 20977                                  NOTVOLSRCH:
 20978 000046B3 E8F800                  	CALL	GETENTRY
 20979 000046B6 7303                    	JNC	short SRCH
 20980 000046B8 E99500                  	JMP	SETESRET
 20981                                  
 20982                                  	;entry	Srch
 20983                                  SRCH:
 20984 000046BB 1E                      	PUSH	DS
 20985 000046BC 8E1E[7605]              	MOV	DS,[CURBUF+2]
 20986                                  
 20987                                  ;	(DS:BX) = directory entry address
 20988                                  
 20989 000046C0 8A27                    	mov	ah,[BX]
 20990                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 20991 000046C2 08E4                    	OR	AH,AH			; End of directory?
 20992 000046C4 743A                    	JZ	short FREE
 20993                                  
 20994                                  ;hkn; SS override
 20995 000046C6 363A26[1905]            	CMP	AH,[SS:DELALL]		; Free entry?
 20996 000046CB 7433                    	JZ	short FREE
 20997                                  	;test	byte [bx+0Bh],8
 20998 000046CD F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 20999                                  					; Volume ID file?
 21000 000046D1 7405                    	JZ	short CHKFNAM 		; NO
 21001                                  
 21002                                  ;hkn; SS override
 21003 000046D3 36FE06[1605]            	INC	BYTE [SS:VOLID]
 21004                                  CHKFNAM:
 21005                                  ;	Context ES
 21006 000046D8 8CD6                    	MOV	SI,SS
 21007 000046DA 8EC6                    	MOV	ES,SI
 21008 000046DC 89DE                    	MOV	SI,BX
 21009                                  
 21010                                  ;hkn; NAME1 is in DOSDATA
 21011 000046DE BF[E604]                	MOV	DI,NAME1
 21012                                  ;;;;; 7/29/86
 21013                                  
 21014                                  ;hkn; SS override for NAME1
 21015 000046E1 36803E[E604]E5          	CMP	BYTE [SS:NAME1],0E5H	; special char check
 21016 000046E7 7506                    	JNZ	short NO_E5
 21017 000046E9 36C606[E604]05          	MOV	BYTE [SS:NAME1],05H
 21018                                  NO_E5:
 21019                                  ;;;;; 7/29/86
 21020 000046EF E86100                  	CALL	MetaCompare
 21021 000046F2 7428                    	JZ	short FOUND
 21022 000046F4 1F                      	POP	DS
 21023                                  
 21024                                  	;entry	NEXTENT
 21025                                  NEXTENT:
 21026 000046F5 C42E[2405]              	LES	BP,[THISDPB]
 21027 000046F9 E86600                  	CALL	NEXTENTRY
 21028 000046FC 73BD                    	JNC	short SRCH
 21029 000046FE EB50                    	JMP	SHORT SETESRET
 21030                                  
 21031                                  FREE:
 21032 00004700 1F                      	POP	DS
 21033 00004701 8B0E[F402]              	MOV	CX,[LASTENT]
 21034 00004705 3B0E[6A05]              	CMP	CX,[ENTFREE]
 21035 00004709 7304                    	JAE	short TSTALL
 21036 0000470B 890E[6A05]              	MOV	[ENTFREE],CX
 21037                                  TSTALL:
 21038 0000470F 3A26[1905]              	CMP	AH,[DELALL]		; At end of directory?
 21039                                  NEXTENTJ:
 21040 00004713 74E0                    	je	short NEXTENT 		; No - continue search
 21041 00004715 890E[6C05]              	MOV	[ENTLAST],CX
 21042 00004719 F9                      	STC
 21043 0000471A EB34                    	JMP	SHORT SETESRET
 21044                                  
 21045                                  FOUND:
 21046                                  ;
 21047                                  ; We have a file with a matching name.	We must now consider the attributes:
 21048                                  ; ATTRIB	Action
 21049                                  ; ------	------
 21050                                  ; Volume_ID	Is Volume_ID in test?
 21051                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 21052                                  ;		If create then Is ATTRIB equal to test?
 21053                                  ;
 21054 0000471C 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 21055 0000471E 1F                      	POP	DS
 21056 0000471F 8A26[0605]              	MOV	AH,[ATTRIB]		; Attributes of search
 21057                                  	;and	ah,9Eh
 21058 00004723 80E4DE                  	AND	AH,~attr_ignore
 21059                                  	;lea	si,[si+15]
 21060 00004726 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 21061                                  					; point to first cluster field
 21062                                  	;test	ch,8
 21063 00004729 F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 21064 0000472C 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 21065                                  	;test	ah,8
 21066 0000472E F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 21067                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 21068 00004731 74C2                    	jz	short NEXTENT ; 19/05/2019
 21069 00004733 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 21070 00004735 EB11                    	JMP	SHORT RETFF		; Found Volume ID
 21071                                  check_one_volume_id:
 21072                                  	;CMP	ah,8
 21073 00004737 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 21074                                  	;JZ	short NEXTENTJ		; Yes, continue search
 21075 0000473A 74B9                    	je	short NEXTENT ; 19/05/2019
 21076 0000473C E89303                  	CALL	MatchAttributes
 21077 0000473F 7407                    	JZ	SHORT RETFF
 21078 00004741 F606[1805]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 21079                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 21080 00004746 74AD                    	jz	short NEXTENT ; 19/05/2019
 21081                                  RETFF:
 21082 00004748 C42E[2405]              	LES	BP,[THISDPB]
 21083 0000474C 268A6600                	MOV	AH,[ES:BP]
 21084                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 21085                                  SETESRET:
 21086 00004750 16                      	PUSH	SS
 21087 00004751 07                      	POP	ES
 21088 00004752 C3                      	retn
 21089                                  
 21090                                  ;----------------------------------------------------------------------------
 21091                                  ;
 21092                                  ; Procedure Name : MetaCompare
 21093                                  ;
 21094                                  ; Inputs:
 21095                                  ;	DS:SI -> 11 character FCB style name NO '?'
 21096                                  ;	    Typically this is a directory entry.  It MUST be in upper case
 21097                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 21098                                  ;	    Typically this is a FCB or SFT.  It MUST be in upper case
 21099                                  ; Function:
 21100                                  ;	Compare FCB style names allowing for ? match to any char
 21101                                  ; Outputs:
 21102                                  ;	Zero if match else NZ
 21103                                  ; Destroys CX,SI,DI all others preserved
 21104                                  ;----------------------------------------------------------------------------
 21105                                  
 21106                                  MetaCompare:
 21107 00004753 B90B00                  	MOV	CX,11
 21108                                  WILDCRD:
 21109 00004756 F3A6                    	REPE	CMPSB
 21110 00004758 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 21111                                  CHECK_META:
 21112 0000475A 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 21113 0000475F 74F5                    	JZ	short WILDCRD
 21114                                  MetaRet:
 21115 00004761 C3                       	retn				; Zero set, Match
 21116                                  
 21117                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 21118                                  ;----------------------------------------------------------------------------
 21119                                  ;
 21120                                  ; Procedure Name : NEXTENTRY
 21121                                  ;
 21122                                  ; Inputs:
 21123                                  ;	Same as outputs of GETENTRY, above
 21124                                  ; Function:
 21125                                  ;	Update BX, and [LASTENT] for next directory entry.
 21126                                  ;	Carry set if no more.
 21127                                  ;----------------------------------------------------------------------------
 21128                                  
 21129                                  NEXTENTRY:
 21130                                  	; 27/07/2018 - Retro DOS v3.0
 21131                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 21132                                  	; 15/03/2018 - Retro DOS v2.0
 21133                                  
 21134 00004762 A1[F402]                	MOV	AX,[LASTENT]
 21135 00004765 3B06[6C05]              	CMP	AX,[ENTLAST]
 21136 00004769 7424                    	JZ	short NONE
 21137 0000476B 40                      	INC	AX
 21138                                  	;ADD	BX,32
 21139 0000476C 8D5F20                  	LEA	BX,[BX+32]
 21140 0000476F 39D3                    	CMP	BX,DX
 21141 00004771 721E                    	JB	short HAVIT
 21142 00004773 8A1E[0E05]              	MOV	BL,[SECCLUSPOS]
 21143 00004777 FEC3                    	INC	BL
 21144 00004779 3A1E[1205]              	CMP	BL,[CLUSFAC]
 21145 0000477D 7217                    	JB	short SAMECLUS
 21146 0000477F 8B1E[6E05]              	MOV	BX,[NXTCLUSNUM]
 21147 00004783 E8B312                  	call	IsEOF
 21148 00004786 7307                    	JAE	short NONE
 21149 00004788 83FB02                  	CMP	BX,2
 21150 0000478B 7202                    	JB	short NONE
 21151 0000478D EB22                    	JMP	short GETENT
 21152                                  NONE:
 21153 0000478F F9                      	STC
 21154 00004790 C3                      	retn
 21155                                  HAVIT:
 21156 00004791 A3[F402]                	MOV	[LASTENT],AX
 21157 00004794 F8                      	CLC
 21158                                  nextentry_retn:
 21159 00004795 C3                      	retn
 21160                                  SAMECLUS:
 21161 00004796 881E[0E05]              	MOV	[SECCLUSPOS],BL
 21162 0000479A A3[F402]                	MOV	[LASTENT],AX
 21163 0000479D 1E                      	PUSH	DS
 21164 0000479E C53E[7405]              	LDS	DI,[CURBUF]
 21165                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 21166                                  ;hkn; SS override
 21167                                  	;MOV	[HIGH_SECTOR],DX		;AN000; >32mb
 21168                                  	;mov	dx,[di+6]
 21169 000047A2 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 21170                                  	;ADD	DX,1				;AN000; >32mb
 21171                                  	;ADC	word [HIGH_SECTOR],0 		;AN000; >32mb
 21172 000047A5 42                      	inc	dx
 21173 000047A6 1F                      	POP	DS
 21174 000047A7 E87EF9                  	call	FIRSTCLUSTER
 21175 000047AA 31DB                    	XOR	BX,BX
 21176 000047AC EB23                    	JMP	short SETENTRY
 21177                                  
 21178                                  ;----------------------------------------------------------------------------
 21179                                  ;
 21180                                  ; Procedure Name : GETENTRY
 21181                                  ;
 21182                                  ; Inputs:
 21183                                  ;	[LASTENT] has directory entry
 21184                                  ;	ES:BP points to drive parameters
 21185                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 21186                                  ; Function:
 21187                                  ;	Locates directory entry in preparation for search
 21188                                  ;	GETENT provides entry for passing desired entry in AX
 21189                                  ; Outputs:
 21190                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 21191                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 21192                                  ;	[LASTENT] = New directory entry number
 21193                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 21194                                  ;	Carry set if error (currently user FAILed to I 24)
 21195                                  ;----------------------------------------------------------------------------
 21196                                  
 21197                                  GETENTRY:
 21198                                  	; 27/07/2018 - Retro DOS v3.0
 21199 000047AE A1[F402]                	MOV	AX,[LASTENT]
 21200                                  
 21201                                  	;entry	GETENT
 21202                                  GETENT:
 21203 000047B1 A3[F402]                	MOV	[LASTENT],AX
 21204                                  ;
 21205                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 21206                                  ; directory.
 21207                                  ;
 21208 000047B4 B105                    	mov	cl,5			; shift left by 5 = mult by 32
 21209 000047B6 D3C0                    	rol	ax,cl			; keep hight order bits
 21210 000047B8 89C2                    	mov	dx,ax
 21211                                  	;and	ax,0FFE0h
 21212                                  	;;and	ax,~(32-1)		; mask off high order bits
 21213 000047BA 24E0                    	and	al,0E0h ; ~31 ; 19/05/2019
 21214 000047BC 83E21F                  	and	dx,1Fh
 21215                                  	;and	dx,32-1			; mask off low order bits
 21216                                  ;
 21217                                  ; DX:AX contain the byte offset of the required directory entry from the
 21218                                  ; beginning of the directory. Convert this to a sector number. Round the
 21219                                  ; sector size down to a multiple of 32.
 21220                                  ;
 21221                                  	;mov	bx,[es:bp+2]
 21222 000047BF 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 21223 000047C3 80E3E0                  	and	bl,0E0h
 21224                                  	;AND	BL,255-31		; Must be multiple of 32
 21225 000047C6 F7F3                    	DIV	BX
 21226 000047C8 89D3                    	MOV	BX,DX			; Position within sector
 21227 000047CA 53                      	PUSH	BX
 21228 000047CB E80EF9                  	call	DIRREAD
 21229 000047CE 5B                      	POP	BX
 21230                                  	;retc
 21231 000047CF 72C4                    	jc	short nextentry_retn	
 21232                                  SETENTRY:
 21233 000047D1 8B16[7405]              	MOV	DX,[CURBUF]
 21234                                  	;add	dx,16
 21235 000047D5 83C210                  	ADD	DX,BUFINSIZ
 21236 000047D8 01D3                    	ADD	BX,DX
 21237                                  	;add	dx,[es:bp+2]
 21238 000047DA 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 21239 000047DE C3                      	retn
 21240                                  
 21241                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 21242                                  ;----------------------------------------------------------------------------
 21243                                  ;
 21244                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 21245                                  ;
 21246                                  ; Inputs:
 21247                                  ;	BX cluster number of start of directory
 21248                                  ;	ES:BP Points to DPB
 21249                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 21250                                  ; Function:
 21251                                  ;	Set up a directory search
 21252                                  ; Outputs:
 21253                                  ;	[DIRSTART] = BX
 21254                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 21255                                  ;	Carry set if error (currently user FAILed to I 24)
 21256                                  ; destroys AX,DX,BX
 21257                                  ;----------------------------------------------------------------------------
 21258                                  
 21259                                  SETDIRSRCH:
 21260 000047DF 09DB                    	OR	BX,BX
 21261 000047E1 7432                    	JZ	short SETROOTSRCH
 21262 000047E3 891E[5805]              	MOV	[DIRSTART],BX
 21263                                  	;mov	al,[es:bp+4]
 21264 000047E7 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 21265 000047EB FEC0                    	INC	AL
 21266 000047ED A2[1205]                	MOV	[CLUSFAC],AL
 21267                                  
 21268                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 21269                                  	;SAVE	<SI>
 21270 000047F0 56                      	push	si
 21271                                  	;test	byte [FastOpenFlg],2
 21272 000047F1 F606[6E0F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 21273 000047F6 7507                    	JNZ	short UNP_OK
 21274                                  
 21275                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 21276                                  	;invoke	UNPACK
 21277 000047F8 E85512                  	call	UNPACK
 21278 000047FB 7302                    	JNC	short UNP_OK
 21279                                  	;RESTORE <SI>
 21280 000047FD 5E                      	pop	si
 21281                                  	;return
 21282 000047FE C3                      	retn
 21283                                  
 21284                                  UNP_OK:
 21285 000047FF 893E[5405]              	MOV	[CLUSNUM],DI
 21286 00004803 89DA                    	MOV	DX,BX
 21287 00004805 30DB                    	XOR	BL,BL
 21288 00004807 881E[0E05]              	MOV	[SECCLUSPOS],BL
 21289                                  	;invoke	FIGREC
 21290 0000480B E8260C                  	call	FIGREC
 21291                                  	;RESTORE <SI>
 21292 0000480E 5E                      	pop	si
 21293                                  	
 21294                                  	; MSDOS 6.0
 21295                                  	;PUSH	DX			   ;AN000; >32mb
 21296                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 21297                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 21298                                  	;POP	DX			   ;AN000; >32mb
 21299                                  	
 21300 0000480F 8916[5605]              	MOV	[DIRSEC],DX
 21301 00004813 F8                      	CLC
 21302 00004814 C3                      	retn
 21303                                  
 21304                                  	;entry	SETROOTSRCH
 21305                                  SETROOTSRCH:
 21306 00004815 31C0                    	XOR	AX,AX
 21307 00004817 A3[5805]                	MOV	[DIRSTART],AX
 21308 0000481A A2[0E05]                	MOV	[SECCLUSPOS],AL
 21309 0000481D 48                      	DEC	AX
 21310 0000481E A3[5405]                	MOV	[CLUSNUM],AX
 21311                                  	;mov	ax,[es:bp+0Bh]
 21312 00004821 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 21313                                  	;mov	dx,[es:bp+10h]
 21314 00004825 268B5610                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 21315 00004829 29D0                    	SUB	AX,DX
 21316 0000482B A2[1205]                	MOV	[CLUSFAC],AL
 21317 0000482E 8916[5605]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 21318                                  	; MSDOS 6.0
 21319                                  	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 21320 00004832 F8                      	CLC
 21321 00004833 C3                      	retn
 21322                                  
 21323                                  ;============================================================================
 21324                                  ; DIR2.ASM, MSDOS 6.0, 1991
 21325                                  ;============================================================================
 21326                                  ; 27/07/2018 - Retro DOS v3.0 
 21327                                  
 21328                                  ;	TITLE	DIR2 - Directory and path cracking
 21329                                  ;	NAME	Dir2
 21330                                  
 21331                                  ;Break	<GETPATH -- PARSE A WFP>
 21332                                  ;----------------------------------------------------------------------------
 21333                                  ;
 21334                                  ; Procedure Name : GETPATH
 21335                                  ;
 21336                                  ; Inputs:
 21337                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 21338                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 21339                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 21340                                  ;		( = -1 if current dir not involved, else
 21341                                  ;		 Points to first char after last "/" of current dir part)
 21342                                  ;	[THISCDS] Points to CDS being used
 21343                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 21344                                  ;	[NoSetDir] set
 21345                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 21346                                  ; Function:
 21347                                  ;	Crack the path
 21348                                  ; Outputs:
 21349                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 21350                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 21351                                  ;	ID1 field of [THISCDS] updated appropriately
 21352                                  ;	[ATTRIB] = [SATTRIB]
 21353                                  ;	ES:BP Points to DPB
 21354                                  ;	Carry set if bad path
 21355                                  ;	   SI Points to path element causing failure
 21356                                  ;	   Zero set
 21357                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 21358                                  ;	      start a search on the last directory
 21359                                  ;	      CL is zero if there is a bad name in the path
 21360                                  ;	      CL is non-zero if the name was simply not found
 21361                                  ;		 [ENTFREE] may have free spot in directory
 21362                                  ;		 [NAME1] is the name.
 21363                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 21364                                  ;	   Zero reset
 21365                                  ;	      File in middle of path or bad name in path or attribute mismatch
 21366                                  ;		or path too long or malformed path
 21367                                  ;	ELSE
 21368                                  ;	   [CurBuf] = -1 if root directory
 21369                                  ;	   [CURBUF] contains directory record with match
 21370                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 21371                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 21372                                  ;	   AH = device ID
 21373                                  ;	      bit 7 of AH set if device SI and BX
 21374                                  ;	      will point DOSGROUP relative The firclus
 21375                                  ;	      field of the device entry contains the device pointer
 21376                                  ;	   [NAME1] Has name looked for
 21377                                  ;	   If last element is a directory zero is set and:
 21378                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 21379                                  ;	      are set up to start a search on it.
 21380                                  ;	      unless [NoSetDir] is non zero in which case the return is
 21381                                  ;	      like that for a file (except for zero flag)
 21382                                  ;	   If last element is a file zero is reset
 21383                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 21384                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 21385                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 21386                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 21387                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 21388                                  ; DS preserved, Others destroyed
 21389                                  ;---------------------------------------------------------------------------
 21390                                  
 21391                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 21392                                  ;hkn; DS already set up at this point.
 21393                                  
 21394                                  GETPATH:
 21395                                  	;mov	word [CREATING],0E500h
 21396 00004834 C706[1805]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 21397                                  
 21398                                  ; Same as GetPath only CREATING and DELALL already set
 21399                                  
 21400                                  	;entry	GetPathNoSet
 21401                                  GetPathNoSet:
 21402                                  	;mov	byte [EXTERR_LOCUS],2	
 21403 0000483A C606[D102]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 21404 0000483F C706[7405]FFFF          	MOV	word [CURBUF],-1	; initial setting
 21405                                  
 21406                                  ; See if the input indicates a device that has already been detected. If so,
 21407                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 21408                                  
 21409 00004845 8B3E[4A05]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 21410                                  	;cmp	word [DI+1],5C3Ah
 21411                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 21412 00004849 817D013A5C              	cmp	word [DI+1],':\'
 21413 0000484E 7438                    	JZ	short CrackIt
 21414                                  
 21415                                  ; Let ChkDev find it in the device list
 21416                                  
 21417 00004850 83C703                  	ADD	DI,3
 21418                                  	; 18/08/2018
 21419                                  	;MOV	SI,DI			; let CHKDEV see the original name
 21420 00004853 E8B000                  	CALL	CHKDEV
 21421 00004856 722E                    	JC	short InternalError
 21422                                  Build_devJ:
 21423                                  
 21424 00004858 A0[0805]                	MOV	AL,[SATTRIB]
 21425 0000485B A2[0605]                	MOV	[ATTRIB],AL
 21426                                  	;mov	byte [EXTERR_LOCUS],1
 21427 0000485E C606[D102]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 21428                                  					; "finding" a char device
 21429                                  					; set LOCUS to Unknown. This makes
 21430                                  					; certain idiotic problems reported
 21431                                  					; by a certain 3 letter OEM go away.
 21432                                  
 21433                                  ; Take name in name1 and pack it back into where wfp_start points. This
 21434                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 21435                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 21436                                  ; wfp into the share set.
 21437                                  ;
 21438                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 21439                                  ; non-space seen +1.  This position is kept in DX.
 21440                                  
 21441                                  ;hkn; SS is DOSDATA
 21442 00004863 16                      	push	ss
 21443 00004864 07                      	pop	es
 21444                                  
 21445                                  ;hkn; NAME1 is in DOSDATA
 21446 00004865 BE[E604]                	mov	si,NAME1
 21447 00004868 8B3E[4A05]              	mov	di,[WFP_START]
 21448 0000486C 89FA                    	mov	dx,di
 21449 0000486E B90800                  	mov	cx,8			; 8 chars in device name
 21450                                  MoveLoop:
 21451 00004871 AC                      	lodsb
 21452 00004872 AA                      	stosb
 21453 00004873 3C20                    	cmp	al," "
 21454 00004875 7402                    	jz	short NoSave
 21455                                  
 21456 00004877 89FA                    	mov	dx,di
 21457                                  NoSave:
 21458 00004879 E2F6                    	loop	MoveLoop
 21459                                  ;
 21460                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 21461                                  ; at this point.
 21462                                  ;
 21463 0000487B 89D7                    	mov	di,dx
 21464 0000487D C60500                  	mov	byte [di],0		; end of string
 21465 00004880 E8BC02                  	call	Build_device_ent	; Clears carry sets zero
 21466 00004883 FEC0                    	INC	AL			; reset zero
 21467 00004885 C3                      	retn
 21468                                  
 21469                                  InternalError:
 21470                                  InternalError_loop:
 21471 00004886 EBFE                    	JMP	short InternalError_loop	; freeze
 21472                                  
 21473                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 21474                                  
 21475                                  CrackIt:
 21476 00004888 8B36[4E05]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 21477 0000488C 83FEFF                  	CMP	SI,-1			; valid?
 21478 0000488F 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 21479 00004891 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 21480                                  LOOK_SING:
 21481                                  	;mov	byte [ATTRIB],16h
 21482 00004894 C606[0605]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 21483                                  					; Attributes to search through Dirs
 21484 00004899 C43E[3A05]              	LES	DI,[THISCDS]
 21485 0000489D B8FFFF                  	MOV	AX,-1
 21486                                  	;mov	bx,[es:di+73]
 21487 000048A0 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 21488 000048A4 8B36[4E05]              	MOV	SI,[CURR_DIR_END]
 21489                                  
 21490                                  ; AX = -1
 21491                                  ; BX = cluster number of current directory.  THis number is -1 if the media
 21492                                  ;      has been uncertainly changed.
 21493                                  ; SI = offset in DOSGroup into path to end of current directory text.  This
 21494                                  ;      may be -1 if no current directory part has been used.
 21495                                  
 21496 000048A8 39C6                    	CMP	SI,AX			; if Current directory is not part
 21497 000048AA 7440                    	JZ	short NO_CURR_D		; then we must crack from root
 21498 000048AC 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 21499                                  
 21500                                  ; DOS 3.3  6/25/86
 21501 000048AE 743C                    	JZ	short NO_CURR_D		; no, crack form the root
 21502                                  	;test	byte [FastOpenFlg],1
 21503 000048B0 F606[6E0F]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 21504 000048B5 7442                    	JZ	short GOT_SEARCH_CLUSTER	; no
 21505 000048B7 06                      	PUSH	ES			; save registers
 21506 000048B8 57                      	PUSH	DI
 21507 000048B9 51                      	PUSH	CX
 21508 000048BA FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 21509 000048BD 56                      	PUSH	SI
 21510 000048BE 53                      	PUSH	BX
 21511                                  
 21512 000048BF C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 21513 000048C3 8B36[4A05]              	MOV	SI,[WFP_START]
 21514                                  
 21515                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 21516 000048C7 BB[430F]                	MOV	BX,FastOpenTable
 21517 000048CA BF[4E0F]                	MOV	DI,Dir_Info_Buff
 21518 000048CD B9[490F]                	MOV	CX,FastOpen_Ext_Info
 21519                                  	;mov	al,1
 21520 000048D0 B001                    	MOV	AL,FONC_Look_up
 21521 000048D2 1E                      	PUSH	DS
 21522 000048D3 07                      	POP	ES
 21523                                  	;call	far [BX+2]
 21524 000048D4 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 21525 000048D7 7208                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 21526                                  					; Go to Got_Srch_cluster
 21527 000048D9 803C00                  	CMP	BYTE [SI],0		;fastopen has current dir info?
 21528 000048DC 7404                    	JE	short GO_Chk_end	;yes. Go to got_search_cluster
 21529 000048DE F9                      	stc
 21530 000048DF EB01                    	jmp	short GO_Chk_end	;Go to No_Curr_D
 21531                                  GO_Chk_end1:
 21532 000048E1 F8                      	clc
 21533                                  GO_Chk_end:				; restore registers
 21534 000048E2 5B                      	POP	BX
 21535 000048E3 5E                      	POP	SI
 21536 000048E4 8F44FF                  	POP	word [SI-1]
 21537 000048E7 59                      	POP	CX
 21538 000048E8 5F                      	POP	DI
 21539 000048E9 07                      	POP	ES
 21540 000048EA 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 21541                                  
 21542                                  ; DOS 3.3  6/25/86
 21543                                  ;
 21544                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 21545                                  ; of path and go crack from root.
 21546                                  
 21547                                  NO_CURR_D:
 21548 000048EC 8B36[4A05]              	MOV	SI,[WFP_START]
 21549 000048F0 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 21550 000048F3 C42E[2405]              	LES	BP,[THISDPB]		; Get ES:BP
 21551 000048F7 EB3D                    	JMP	short ROOTPATH
 21552                                  
 21553                                  ; We are able to crack from the current directory part. Go set up for search
 21554                                  ; of specified cluster.
 21555                                  
 21556                                  GOT_SEARCH_CLUSTER:
 21557 000048F9 C42E[2405]              	LES	BP,[THISDPB]		; Get ES:BP
 21558 000048FD E8DFFE                  	call	SETDIRSRCH
 21559                                  	;JC	short SETFERR
 21560                                  	;JMP	short FINDPATH
 21561 00004900 7345                    	jnc	short FINDPATH ; 17/08/2018
 21562                                  SETFERR:
 21563 00004902 30C9                    	XOR	CL,CL			; set zero
 21564 00004904 F9                      	STC
 21565 00004905 C3                      	retn
 21566                                  
 21567                                  ;---------------------------------------------------------------------------
 21568                                  ;
 21569                                  ; Procedure Name : ChkDev
 21570                                  ;
 21571                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 21572                                  ;   device.
 21573                                  ; Blasts CX,SI,DI,AX,BX
 21574                                  ;---------------------------------------------------------------------------
 21575                                  
 21576                                  CHKDEV:
 21577 00004906 89FE                    	MOV	SI,DI
 21578 00004908 8CD7                    	MOV	DI,SS
 21579 0000490A 8EC7                    	MOV	ES,DI
 21580                                  
 21581 0000490C BF[E604]                	MOV	DI,NAME1
 21582 0000490F B90900                  	MOV	CX,9
 21583                                  TESTLOOP:
 21584 00004912 E8F90C                  	call	GETLET
 21585                                  
 21586 00004915 3C2E                    	CMP	AL,'.'
 21587 00004917 740E                    	JZ	short TESTDEVICE
 21588 00004919 E82F0D                  	call	PATHCHRCMP
 21589 0000491C 7407                    	JZ	short NOTDEV
 21590 0000491E 08C0                    	OR	AL,AL
 21591 00004920 7405                    	JZ	short TESTDEVICE
 21592                                  
 21593 00004922 AA                      	STOSB
 21594 00004923 E2ED                    	LOOP	TESTLOOP
 21595                                  NOTDEV:
 21596 00004925 F9                      	STC
 21597 00004926 C3                      	retn
 21598                                  
 21599                                  TESTDEVICE:
 21600 00004927 83C102                  	ADD	CX,2
 21601 0000492A B020                    	MOV	AL,' '
 21602 0000492C F3AA                    	REP	STOSB
 21603 0000492E 8CD0                    	MOV	AX,SS
 21604 00004930 8ED8                    	MOV	DS,AX
 21605 00004932 E8AA01                  	call	DEVNAME
 21606 00004935 C3                      	retn
 21607                                  
 21608                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 21609                                  ;----------------------------------------------------------------------------
 21610                                  ;
 21611                                  ; Procedure Name : ROOTPATH,FINDPATH
 21612                                  ;
 21613                                  ; Inputs:
 21614                                  ;	Same as FINDPATH but,
 21615                                  ;	SI Points to asciz string of path which is assumed to start at
 21616                                  ;		the root (no leading '/').
 21617                                  ; Function:
 21618                                  ;	Search from root for path
 21619                                  ; Outputs:
 21620                                  ;	Same as FINDPATH but:
 21621                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 21622                                  ;	[NoSetDir] is ignored.
 21623                                  ;----------------------------------------------------------------------------
 21624                                  
 21625                                  ROOTPATH:
 21626 00004936 E8DCFE                  	call	SETROOTSRCH
 21627 00004939 803C00                  	CMP	BYTE [SI],0
 21628 0000493C 7509                    	JNZ	short FINDPATH
 21629                                  
 21630                                  ; Root dir specified
 21631 0000493E A0[0805]                	MOV	AL,[SATTRIB]
 21632 00004941 A2[0605]                	MOV	[ATTRIB],AL
 21633 00004944 30E4                    	XOR	AH,AH			; Sets "device ID" byte, sets zero
 21634                                  					; (dir), clears carry.
 21635 00004946 C3                      	retn
 21636                                  
 21637                                  ; Inputs:
 21638                                  ;	[ATTRIB] Set to get through directories
 21639                                  ;	[SATTRIB] Set to find last element
 21640                                  ;	ES:BP Points to DPB
 21641                                  ;	SI Points to asciz string of path (no leading '/').
 21642                                  ;	[SECCLUSPOS] = 0
 21643                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 21644                                  ;	[CLUSNUM] = Cluster # of next cluster
 21645                                  ;	[CLUSFAC] = Sectors per cluster
 21646                                  ;	[NoSetDir] set
 21647                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 21648                                  ;		( = -1 if current dir not involved, else
 21649                                  ;		 Points to first char after last "/" of current dir part)
 21650                                  ;	[THISCDS] Points to CDS being used
 21651                                  ;	[CREATING] and [DELALL] set
 21652                                  ; Function:
 21653                                  ;	Parse path name
 21654                                  ; Outputs:
 21655                                  ;	ID1 field of [THISCDS] updated appropriately
 21656                                  ;	[ATTRIB] = [SATTRIB]
 21657                                  ;	ES:BP Points to DPB
 21658                                  ;	[THISDPB] = ES:BP
 21659                                  ;	Carry set if bad path
 21660                                  ;	   SI Points to path element causing failure
 21661                                  ;	   Zero set
 21662                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 21663                                  ;	      start a search on the last directory
 21664                                  ;	      CL is zero if there is a bad name in the path
 21665                                  ;	      CL is non-zero if the name was simply not found
 21666                                  ;		 [ENTFREE] may have free spot in directory
 21667                                  ;		 [NAME1] is the name.
 21668                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 21669                                  ;	   Zero reset
 21670                                  ;	      File in middle of path or bad name in path
 21671                                  ;		or path too long or malformed path
 21672                                  ;	ELSE
 21673                                  ;	   [CURBUF] contains directory record with match
 21674                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 21675                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 21676                                  ;	   [NAME1] Has name looked for
 21677                                  ;	   AH = device ID
 21678                                  ;	      bit 7 of AH set if device SI and BX
 21679                                  ;	      will point DOSGROUP relative The firclus
 21680                                  ;	      field of the device entry contains the device pointer
 21681                                  ;	   If last element is a directory zero is set and:
 21682                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 21683                                  ;	      are set up to start a search on it,
 21684                                  ;	      unless [NoSetDir] is non zero in which case the return is
 21685                                  ;	      like that for a file (except for zero flag)
 21686                                  ;	   If last element is a file zero is reset
 21687                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 21688                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 21689                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 21690                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 21691                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 21692                                  ; Destroys all other registers
 21693                                  
 21694                                      	;entry	FINDPATH
 21695                                  FINDPATH:
 21696 00004947 06                      	PUSH	ES			; Save ES:BP
 21697 00004948 56                      	PUSH	SI
 21698 00004949 89F7                    	MOV	DI,SI
 21699 0000494B 8B0E[5805]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 21700 0000494F 833E[4E05]FF            	CMP	word [CURR_DIR_END],-1
 21701 00004954 740E                    	JZ	short NOIDS		; No current dir part
 21702 00004956 3B3E[4E05]              	CMP	DI,[CURR_DIR_END]
 21703 0000495A 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 21704 0000495C C43E[3A05]              	LES	DI,[THISCDS]
 21705                                  	;mov	[es:di+73],cx
 21706 00004960 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 21707                                  NOIDS:
 21708                                  
 21709                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 21710                                  ; character in the string. CX,DI may be destroyed.
 21711                                  ;
 21712                                  ;	invoke	NAMETRANS
 21713                                  ;	MOV	CL,AL
 21714                                  ;
 21715                                  ; The above is the slow method. The name has *already* been munged by
 21716                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 21717                                  ; the name until ., \ or 0 is hit.
 21718                                  
 21719 00004964 8CD0                    	MOV	AX,SS
 21720 00004966 8EC0                    	MOV	ES,AX
 21721                                  
 21722                                  ;hkn; Name1 is in DOSDATA
 21723 00004968 BF[E604]                	MOV	DI,NAME1
 21724 0000496B B82020                  	MOV	AX,'  ' ; 2020h
 21725 0000496E AA                      	STOSB
 21726 0000496F AB                      	STOSW
 21727 00004970 AB                      	STOSW
 21728 00004971 AB                      	STOSW
 21729 00004972 AB                      	STOSW
 21730 00004973 AB                      	STOSW
 21731                                  
 21732                                  ;hkn; Name1 is in DOSDATA
 21733 00004974 BF[E604]                	MOV	DI,NAME1
 21734 00004977 30E4                    	XOR	AH,AH			; bits for CL
 21735                                  GetNam:
 21736                                  	;INC	CL			;AN000; KK incrment volid count
 21737 00004979 AC                      	LODSB
 21738 0000497A 3C2E                    	CMP	AL,'.'
 21739 0000497C 7412                    	JZ	short _SetExt
 21740 0000497E 08C0                    	OR	AL,AL
 21741 00004980 7424                    	JZ	short _GetDone
 21742 00004982 3C5C                    	CMP	AL,'\'
 21743 00004984 7420                    	JZ	short _GetDone
 21744 00004986 3C3F                    	CMP	AL,'?'
 21745 00004988 7503                    	JNZ	short StoNam
 21746 0000498A 80CC01                  	OR	AH,1
 21747                                  StoNam: 
 21748 0000498D AA                      	STOSB
 21749 0000498E EBE9                    	JMP	short GetNam
 21750                                  _SetExt:
 21751 00004990 BF[EE04]                	MOV	DI,NAME1+8
 21752                                  GetExt:
 21753 00004993 AC                      	LODSB
 21754 00004994 08C0                    	OR	AL,AL
 21755 00004996 740E                    	JZ	short _GetDone
 21756 00004998 3C5C                    	CMP	AL,'\'
 21757 0000499A 740A                    	JZ	short _GetDone
 21758 0000499C 3C3F                    	CMP	AL,'?'
 21759 0000499E 7503                    	JNZ	short StoExt
 21760 000049A0 80CC01                  	OR	AH,1
 21761                                  StoExt: 
 21762 000049A3 AA                      	STOSB
 21763 000049A4 EBED                    	JMP	short GetExt
 21764                                  _GetDone:
 21765 000049A6 4E                      	DEC	SI
 21766 000049A7 88E1                    	MOV	CL,AH
 21767 000049A9 80C980                  	OR	CL,80H
 21768 000049AC 5F                      	POP	DI			; Start of this element
 21769 000049AD 07                      	POP	ES			; Restore ES:BP
 21770 000049AE 39FE                    	CMP	SI,DI
 21771 000049B0 7503                    	JNZ	short check_device
 21772 000049B2 E9D100                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 21773                                  check_device:
 21774 000049B5 56                      	PUSH	SI			; Start of next element
 21775 000049B6 8A04                    	MOV	AL,[SI]
 21776 000049B8 08C0                    	OR	AL,AL
 21777 000049BA 7508                    	JNZ	short NOT_LAST
 21778                                  
 21779                                  ; for last element of the path switch to the correct search attributes
 21780                                  
 21781 000049BC 8A3E[0805]              	MOV	BH,[SATTRIB]
 21782 000049C0 883E[0605]              	MOV	[ATTRIB],BH
 21783                                  
 21784                                  NOT_LAST:
 21785                                  
 21786                                  ; check name1 to see if we have a device...
 21787                                  
 21788 000049C4 06                      	PUSH	ES			; Save ES:BP
 21789                                  
 21790                                  ;hkn; SS is DOSDATA
 21791                                  	;context ES
 21792 000049C5 16                      	push	ss
 21793 000049C6 07                      	pop	es
 21794 000049C7 E81501                  	call	DEVNAME 		; blast BX
 21795 000049CA 07                      	POP	ES			; Restore ES:BP
 21796 000049CB 720B                    	JC	short FindFile		; Not a device
 21797 000049CD 08C0                    	OR	AL,AL			; Test next char again
 21798 000049CF 7403                    	JZ	short GO_BDEV
 21799 000049D1 E9B600                  	JMP	FILEINPATH		; Device name in middle of path
 21800                                  
 21801                                  GO_BDEV:
 21802 000049D4 5E                      	POP	SI			; Points to NUL at end of path
 21803 000049D5 E980FE                  	JMP	Build_devJ
 21804                                  
 21805                                  FindFile:
 21806                                  ;;;; 7/28/86
 21807 000049D8 803E[E604]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 21808 000049DD 7505                    	JNZ	short NOE5		; no
 21809 000049DF C606[E604]05            	MOV	BYTE [NAME1],05H	; change it to 05
 21810                                  NOE5:
 21811                                  ;;;; 7/28/86
 21812 000049E4 57                      	PUSH	DI			; Start of this element
 21813 000049E5 06                      	PUSH	ES			; Save ES:BP
 21814 000049E6 51                      	PUSH	CX			; CL return from NameTrans
 21815                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 21816                                  
 21817 000049E7 E87C02                  	CALL	LookupPath		; call fastopen to get dir entry
 21818 000049EA 7303                    	JNC	short DIR_FOUND		; found dir entry
 21819                                  
 21820                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 21821 000049EC E8B5FC                  	call	FINDENTRY
 21822                                  DIR_FOUND:
 21823 000049EF 59                      	POP	CX
 21824 000049F0 07                      	POP	ES
 21825 000049F1 5F                      	POP	DI
 21826 000049F2 7303                    	JNC	short LOAD_BUF
 21827 000049F4 E9B800                  	JMP	BADPATHPOP
 21828                                  
 21829                                  LOAD_BUF:
 21830 000049F7 C53E[7405]              	LDS	DI,[CURBUF]
 21831                                  	;test	byte [bx+0Bh],10h
 21832 000049FB F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 21833 000049FF 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 21834 00004A01 E98600                  	JMP	FILEINPATH		; Error or end of path
 21835                                  
 21836                                  ; if we are not setting the directory, then check for end of string
 21837                                  
 21838                                  GO_NEXT:
 21839                                  ;hkn; SS override
 21840 00004A04 36803E[F802]00          	CMP	BYTE [SS:NoSetDir],0
 21841 00004A0A 7412                    	JZ	short SetDir
 21842 00004A0C 89FA                    	MOV	DX,DI			; Save pointer to entry
 21843 00004A0E 8CD9                    	MOV	CX,DS
 21844                                  
 21845                                  ;hkn; SS is DOSDATA
 21846                                  	;context DS
 21847 00004A10 16                      	push	ss
 21848 00004A11 1F                      	pop	ds
 21849 00004A12 5F                      	POP	DI			; Start of next element
 21850                                  	; MSDOS 6.0
 21851                                  	;TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 21852                                  	;JZ	short nofast			; the FastOpen
 21853                                  	;TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 21854                                  	;JZ	short nofast			; no
 21855                                  	;MOV	DI,[Next_Element_Start]	; no need to insert it again
 21856                                  ;nofast:
 21857 00004A13 803D00                  	CMP	BYTE [DI],0
 21858 00004A16 7501                    	JNZ	short NEXT_ONE		; DOS 3.3
 21859                                  	;JMP	_SETRET			; Got it
 21860 00004A18 C3                      	retn	; 05/09/2018
 21861                                  NEXT_ONE:
 21862 00004A19 57                      	PUSH	DI			; Put start of next element back on stack
 21863 00004A1A 89D7                    	MOV	DI,DX
 21864 00004A1C 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 21865                                  SetDir:
 21866 00004A1E 8B14                    	MOV	DX,[SI] 		; Dir_first
 21867                                  
 21868                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 21869 00004A20 1E                      	PUSH	DS		      ; save [curbuf+2]
 21870                                  ;hkn; SS is DOSDATA
 21871 00004A21 16                      	push	ss
 21872 00004A22 1F                      	pop	ds		      ; set DS Dosgroup
 21873                                  	;test	byte [FastOpenFlg],2
 21874 00004A23 F606[6E0F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 21875 00004A28 7410                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 21876 00004A2A 89D3                    	MOV	BX,DX		      ; not found
 21877 00004A2C 8B3E[5405]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 21878 00004A30 50                      	PUSH	AX		      ; save device id (AH)
 21879 00004A31 E8ABFD                  	call	SETDIRSRCH
 21880 00004A34 58                      	POP	AX		      ; restore device id (AH)
 21881 00004A35 83C402                  	ADD	SP,2		      ; pop ds in stack
 21882 00004A38 EB36                    	JMP	short FAST_OPEN_SKIP
 21883                                  
 21884                                  DO_NORMAL:
 21885 00004A3A 1F                      	POP	DS			; DS = [curbuf + 2]
 21886                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 21887                                  
 21888 00004A3B 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 21889 00004A3D 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 21890 00004A3F 53                      	PUSH	BX
 21891 00004A40 50                      	PUSH	AX
 21892 00004A41 56                      	PUSH	SI
 21893 00004A42 51                      	PUSH	CX
 21894                                  	;push	word [di+6]
 21895 00004A43 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 21896                                  	; MSDOS 6.0
 21897                                  	;PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 21898 00004A46 89D3                    	MOV	BX,DX
 21899                                  
 21900                                  ;hkn; SS is DOSDATA
 21901                                  	;context DS
 21902 00004A48 16                      	push	ss
 21903 00004A49 1F                      	pop	ds
 21904                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 21905 00004A4A E892FD                  	call	SETDIRSRCH		; the entry sector buffer
 21906                                  	; MSDOS 6.0
 21907                                  	;POP	word [HIGH_SECTOR]
 21908 00004A4D 5A                      	POP	DX
 21909 00004A4E 720A                    	JC	short SKIP_GETB
 21910                                  	;mov	byte [ALLOWED],18h
 21911 00004A50 C606[F702]18            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 21912 00004A55 30C0                    	XOR	AL,AL
 21913                                  	;invoke	GETBUFFR		; Get the entry buffer back
 21914 00004A57 E82E14                  	call	GETBUFFR
 21915                                  SKIP_GETB:
 21916 00004A5A 59                      	POP	CX
 21917 00004A5B 5E                      	POP	SI
 21918 00004A5C 58                      	POP	AX
 21919 00004A5D 5B                      	POP	BX
 21920 00004A5E 7305                    	JNC	short SET_THE_BUF ; 19/05/2019
 21921 00004A60 5F                      	POP	DI			; Start of next element
 21922 00004A61 89FE                    	MOV	SI,DI			; Point with SI
 21923 00004A63 EB21                    	JMP	SHORT _BADPATH
 21924                                  
 21925                                  SET_THE_BUF:
 21926 00004A65 E8CCF6                  	call	SET_BUF_AS_DIR
 21927 00004A68 8B3E[7405]              	MOV	DI,[CURBUF]
 21928 00004A6C 01FE                    	ADD	SI,DI			; Get the offsets back
 21929 00004A6E 01FB                    	ADD	BX,DI
 21930                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 21931                                  FAST_OPEN_SKIP:
 21932 00004A70 5F                      	POP	DI			; Start of next element
 21933 00004A71 E86802                  	CALL	InsertPath		; insert dir entry info
 21934                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 21935 00004A74 8A05                    	MOV	AL,[DI]
 21936 00004A76 08C0                    	OR	AL,AL
 21937 00004A78 7434                    	JZ	short _SETRET		; At end
 21938 00004A7A 47                      	INC	DI			; Skip over "/"
 21939 00004A7B 89FE                    	MOV	SI,DI			; Point with SI
 21940 00004A7D E8CB0B                  	call	PATHCHRCMP
 21941 00004A80 7503                    	JNZ	short find_bad_name	; oops
 21942 00004A82 E9C2FE                  	JMP	FINDPATH		; Next element
 21943                                  
 21944                                  find_bad_name:
 21945 00004A85 4E                      	DEC	SI			; Undo above INC to get failure point
 21946                                  _BADPATH:
 21947 00004A86 30C9                    	XOR	CL,CL			; Set zero
 21948 00004A88 EB2C                    	JMP	SHORT BADPRET
 21949                                  
 21950                                  FILEINPATH:
 21951 00004A8A 5F                      	POP	DI			; Start of next element
 21952                                  
 21953                                  ;hkn; SS is DOSDATA
 21954                                  	;context DS			; Got to from one place with DS gone
 21955 00004A8B 16                      	push	ss
 21956 00004A8C 1F                      	pop	ds
 21957                                  
 21958                                  ; DOS 3.3 FastOpen
 21959                                  	;test	byte [FastOpenFlg],1
 21960 00004A8D F606[6E0F]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 21961 00004A92 740B                    	JZ	short NO_FAST		; device info to fastopen
 21962                                  	;test	byte [FastOpenFlg],2
 21963 00004A94 F606[6E0F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 21964 00004A99 7404                    	JZ	short NO_FAST
 21965 00004A9B 8B3E[6F0F]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 21966                                  					 ; success
 21967                                  NO_FAST:
 21968                                  ; DOS 3.3 FastOpen
 21969                                  
 21970 00004A9F 8A05                    	MOV	AL,[DI]
 21971 00004AA1 08C0                    	OR	AL,AL
 21972 00004AA3 7404                    	JZ	short INCRET
 21973 00004AA5 89FE                    	MOV	SI,DI			; Path too long
 21974 00004AA7 EB0D                    	JMP	SHORT BADPRET
 21975                                  
 21976                                  INCRET:
 21977                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 21978                                  
 21979 00004AA9 E83002                  	CALL   InsertPath		; insert dir entry info
 21980                                  
 21981                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 21982 00004AAC FEC0                    	INC	AL			; Reset zero
 21983                                  _SETRET:
 21984 00004AAE C3                      	retn
 21985                                  
 21986                                  BADPATHPOP:
 21987 00004AAF 5E                      	POP	SI			; Start of next element
 21988 00004AB0 8A04                    	MOV	AL,[SI]
 21989 00004AB2 89FE                    	MOV	SI,DI			; Start of bad element
 21990 00004AB4 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 21991                                  BADPRET:
 21992 00004AB6 A0[0805]                	MOV	AL,[SATTRIB]
 21993 00004AB9 A2[0605]                	MOV	[ATTRIB],AL		; Make sure return correct
 21994 00004ABC F9                      	STC
 21995 00004ABD C3                      	retn
 21996                                  
 21997                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 21998                                  ;---------------------------------------------------------------------------
 21999                                  ;
 22000                                  ; Procedure Name : STARTSRCH
 22001                                  ;
 22002                                  ; Inputs:
 22003                                  ;	[THISDPB] Set
 22004                                  ; Function:
 22005                                  ;	Set up a search for GETENTRY and NEXTENTRY
 22006                                  ; Outputs:
 22007                                  ;	ES:BP = Drive parameters
 22008                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 22009                                  ; Destroys ES,BP,AX
 22010                                  ;--------------------------------------------------------------------------
 22011                                  
 22012                                  STARTSRCH:
 22013 00004ABE C42E[2405]              	LES	BP,[THISDPB]
 22014 00004AC2 31C0                    	XOR	AX,AX
 22015 00004AC4 A3[F402]                	MOV	[LASTENT],AX
 22016 00004AC7 A2[1605]                	MOV	[VOLID],AL		; No volume ID found
 22017 00004ACA 48                      	DEC	AX
 22018 00004ACB A3[6A05]                	MOV	[ENTFREE],AX
 22019 00004ACE A3[6C05]                	MOV	[ENTLAST],AX
 22020 00004AD1 C3                      	retn
 22021                                  
 22022                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 22023                                  ;----------------------------------------------------------------------------
 22024                                  ; Procedure Name : MatchAttributes
 22025                                  ;
 22026                                  ; Input:    [Attrib] = attribute to search for
 22027                                  ;	    CH = found attribute
 22028                                  ; Output:   JZ <match>
 22029                                  ;	    JNZ <nomatch>
 22030                                  ; Registers modified: noneski
 22031                                  ;----------------------------------------------------------------------------
 22032                                  
 22033                                  MatchAttributes:
 22034 00004AD2 50                      	PUSH	AX
 22035                                  
 22036                                  ;hkn; SS override
 22037 00004AD3 36A0[0605]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 22038 00004AD7 F6D0                    	NOT	AL			; AL <- SearchSet'
 22039 00004AD9 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 22040                                  	;and	al,16h
 22041 00004ADB 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 22042                                  ;
 22043                                  ; the result is non-zero if an attribute is not in the search set
 22044                                  ; and in the found set and in the important set. This means that we do not
 22045                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 22046                                  ;
 22047 00004ADD 58                      	POP	AX
 22048 00004ADE C3                      	retn
 22049                                  
 22050                                  ;Break <DevName - Look for name of device>
 22051                                  ;---------------------------------------------------------------------------
 22052                                  ;
 22053                                  ; Procedure Name : DevName
 22054                                  ;
 22055                                  ; Inputs:
 22056                                  ;	DS,ES:DOSDATA
 22057                                  ;	Filename in NAME1
 22058                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 22059                                  ; Function:
 22060                                  ;	Determine if file is in list of I/O drivers
 22061                                  ; Outputs:
 22062                                  ;	Carry set if not a device
 22063                                  ;	ELSE
 22064                                  ;	Zero flag set
 22065                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 22066                                  ;	     bits 0-4 set from low byte of attribute word
 22067                                  ;	DEVPT = DWORD pointer to Device header of device
 22068                                  ; BX destroyed, others preserved
 22069                                  ;---------------------------------------------------------------------------
 22070                                  
 22071                                  DEVNAME:
 22072                                  	; 28/07/2018 - Retro DOS v3.0
 22073                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 22074                                  
 22075 00004ADF 56                      	PUSH	SI
 22076 00004AE0 57                      	PUSH	DI
 22077 00004AE1 51                      	PUSH	CX
 22078 00004AE2 50                      	PUSH	AX
 22079                                  
 22080                                  ; E5 special code
 22081 00004AE3 FF36[E604]              	PUSH	WORD [NAME1]
 22082 00004AE7 803E[E604]05            	CMP	byte [NAME1],5
 22083 00004AEC 7505                    	JNZ	short NOKTR
 22084 00004AEE C606[E604]E5            	MOV	byte [NAME1],0E5h
 22085                                  NOKTR:
 22086                                  	;test	byte [ATTRIB],8
 22087 00004AF3 F606[0605]08            	TEST	byte [ATTRIB],attr_volume_id
 22088                                  					; If looking for VOL id don't find devs
 22089 00004AF8 7522                    	JNZ	short RET31
 22090                                  
 22091                                  ;hkn; NULDEV is in DOSDATA
 22092 00004AFA BE[4800]                	MOV	SI,NULDEV
 22093                                  LOOKIO:
 22094                                  	;test	word [si+4],8000h
 22095 00004AFD F744040080              	TEST	word [SI+SYSDEV.ATT],DEVTYP
 22096 00004B02 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 22097 00004B04 89F0                    	MOV	AX,SI
 22098                                  	;add	si,10
 22099 00004B06 83C60A                  	ADD	SI,SYSDEV.NAME
 22100                                  
 22101                                  ;hkn; NAME1 is in DOSDATA
 22102 00004B09 BF[E604]                	MOV	DI,NAME1
 22103 00004B0C B90400                  	MOV	CX,4			; All devices are 8 letters
 22104 00004B0F F3A7                    	REPE	CMPSW			; Check for name in list
 22105 00004B11 89C6                    	MOV	SI,AX
 22106 00004B13 7415                    	JZ	short IOCHK		; Found it?
 22107                                  SKIPDEV:
 22108 00004B15 C534                    	LDS	SI,[SI]			; Get address of next device
 22109 00004B17 83FEFF                  	CMP	SI,-1			; At end of list?
 22110 00004B1A 75E1                    	JNZ	short LOOKIO
 22111                                  RET31:	
 22112 00004B1C F9                      	STC				; Not found
 22113                                  RETNV:	
 22114 00004B1D 8CD1                    	MOV	CX,SS
 22115 00004B1F 8ED9                    	MOV	DS,CX
 22116                                  
 22117 00004B21 8F06[E604]              	POP	WORD [NAME1]
 22118 00004B25 58                      	POP	AX
 22119 00004B26 59                      	POP	CX
 22120 00004B27 5F                      	POP	DI
 22121 00004B28 5E                      	POP	SI
 22122 00004B29 C3                      	RETN
 22123                                  
 22124                                  IOCHK:
 22125                                  ;hkn; SS override for DEVPT
 22126 00004B2A 368C1E[3405]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 22127                                  	;mov	bh,[si+4]
 22128 00004B2F 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 22129 00004B32 80CFC0                  	OR	BH,0C0h
 22130 00004B35 80E7DF                  	and	bh,0DFh
 22131                                  	;AND	BH,~(020h)		; Clears Carry
 22132 00004B38 368936[3205]            	MOV	[SS:DEVPT],SI
 22133 00004B3D EBDE                    	JMP	short RETNV
 22134                                  
 22135                                  ;BREAK <Build_device_ent - Make a Directory entry>
 22136                                  ;---------------------------------------------------------------------------
 22137                                  ; Procedure Name : Build_device_ent
 22138                                  ;
 22139                                  ; Inputs:
 22140                                  ;	[NAME1] has name
 22141                                  ;	BH is attribute field (supplied by DEVNAME)
 22142                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 22143                                  ; Function:
 22144                                  ;	Build a directory entry for a device at DEVFCB
 22145                                  ; Outputs:
 22146                                  ;	BX points to DEVFCB
 22147                                  ;	SI points to dir_first field
 22148                                  ;	AH = input BH
 22149                                  ;	AL = 0
 22150                                  ;	dir_first = DEVPT
 22151                                  ;	Zero Set, Carry Clear
 22152                                  ; DS,ES,BP preserved, others destroyed
 22153                                  ;--------------------------------------------------------------------------
 22154                                  
 22155                                  Build_device_ent:
 22156 00004B3F B82020                  	MOV	AX,"  " ; 2020h
 22157                                  
 22158                                  ;hkn; DEVFCB is in DOSDATA
 22159 00004B42 BF[EE04]                	MOV	DI,DEVFCB+8		; Point to extent field
 22160                                  
 22161                                  ;	Fill dir_ext	BUGBUG - use ERRNZs for this stuff!
 22162                                  
 22163 00004B45 AB                      	STOSW
 22164 00004B46 AA                      	STOSB				; Blank out extent field
 22165                                  	;mov	al,40h
 22166 00004B47 B040                    	MOV	AL,attr_device
 22167                                  
 22168                                  ;	Fill Dir_attr
 22169                                  
 22170 00004B49 AA                      	STOSB				; Set attribute field
 22171 00004B4A 31C0                    	XOR	AX,AX
 22172 00004B4C B90A00                  	MOV	CX,10
 22173                                  
 22174                                  ; Fill dir_pad
 22175                                  
 22176 00004B4F F3AB                    	REP	STOSW			; Fill rest with zeros
 22177 00004B51 E862CD                  	call	DATE16
 22178                                  
 22179                                  ;hkn; DEVFCB is in DOSDATA
 22180 00004B54 BF[FC04]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 22181 00004B57 92                      	XCHG	AX,DX
 22182                                  
 22183                                  ; Fill dir_time
 22184                                  
 22185 00004B58 AB                      	STOSW
 22186 00004B59 92                      	XCHG	AX,DX
 22187                                  
 22188                                  ; Fill dir_date
 22189                                  
 22190 00004B5A AB                      	STOSW
 22191 00004B5B 89FE                    	MOV	SI,DI			; SI points to dir_first field
 22192 00004B5D A1[3205]                	MOV	AX,[DEVPT]
 22193                                  
 22194                                  ; Fill dir_first
 22195                                  
 22196 00004B60 AB                      	STOSW				; Dir_first points to device
 22197 00004B61 A1[3405]                	MOV	AX,[DEVPT+2]
 22198                                  ;
 22199                                  ; Fill dir_size_l
 22200                                  ;
 22201 00004B64 AB                      	STOSW
 22202 00004B65 88FC                    	MOV	AH,BH			; Put device atts in AH
 22203                                  
 22204                                  ;hkn; DEVFCB is in DOSDATA
 22205 00004B67 BB[E604]                	MOV	BX,DEVFCB
 22206 00004B6A 30C0                    	XOR	AL,AL			; Set zero, clear carry
 22207 00004B6C C3                      	retn
 22208                                  
 22209                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 22210                                  ;----------------------------------------------------------------------------
 22211                                  ;
 22212                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 22213                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 22214                                  ;   If invalid, reset original CDS to root.
 22215                                  ;
 22216                                  ;   Inputs:	ThisCDS points to CDS of interest
 22217                                  ;		SS:DI points to temp buffer
 22218                                  ;   Outputs:	The current directory string is validated on the appropriate
 22219                                  ;		    drive
 22220                                  ;		ThisDPB changed
 22221                                  ;		ES:DI point to CDS
 22222                                  ;		Carry set if error (currently user FAILed to I 24)
 22223                                  ;   Registers modified: all
 22224                                  ;----------------------------------------------------------------------------
 22225                                  
 22226                                  ValidateCDS:
 22227                                  	; 28/07/2018 - Retro DOS v3.0
 22228                                  
 22229                                     %define  Temp	[bp-2]	; word
 22230                                     %define  SaveCDS	[bp-6]	; dword
 22231                                     %define  SaveCDSL	[bp-6]	; word
 22232                                     %define  SaveCDSH	[bp-4]	; word
 22233                                  
 22234                                  	;Enter
 22235 00004B6D 55                      	push	bp
 22236 00004B6E 89E5                    	mov	bp,sp
 22237 00004B70 83EC06                  	sub	sp,6
 22238                                  
 22239 00004B73 897EFE                  	MOV	Temp,DI
 22240                                  
 22241                                  ;hkn; SS override
 22242 00004B76 36C536[3A05]            	LDS	SI,[SS:THISCDS]
 22243 00004B7B 8976FA                  	MOV	SaveCDSL,SI
 22244 00004B7E 8C5EFC                  	MOV	SaveCDSH,DS
 22245                                  	;EnterCrit critDisk
 22246 00004B81 E8DFD4                  	call	EcritDisk
 22247                                  	;test	word [si+67],8000h
 22248 00004B84 F744430080              	TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 22249 00004B89 7403                    	JZ	short _DoSplice
 22250 00004B8B E98900                  	JMP	FatFail
 22251                                  _DoSplice:
 22252 00004B8E 30D2                    	XOR	DL,DL
 22253 00004B90 368616[F802]            	XCHG	DL,[SS:NoSetDir]
 22254                                  
 22255                                  ;hkn; SS is DOSDATA
 22256                                  	;Context ES
 22257 00004B95 16                      	push	ss
 22258 00004B96 07                      	pop	es
 22259                                  	;Invoke	FStrcpy
 22260 00004B97 E8BED3                  	call	FStrCpy
 22261 00004B9A 8B76FE                  	MOV	SI,Temp
 22262                                  
 22263                                  ;hkn; SS is DOSDATA
 22264                                  	;Context DS
 22265 00004B9D 16                      	push	ss
 22266 00004B9E 1F                      	pop	ds	
 22267                                  	;Invoke	Splice
 22268 00004B9F E83621                  	call	Splice
 22269                                  
 22270                                   ;hkn; SS is DOSDATA
 22271                                  	;Context DS			;   FatReadCDS (ThisCDS);
 22272 00004BA2 16                      	push	ss
 22273 00004BA3 1F                      	pop	ds
 22274 00004BA4 8816[F802]              	MOV	[NoSetDir],DL
 22275 00004BA8 C43E[3A05]              	LES	DI,[THISCDS]
 22276                                  	;SAVE	<BP>
 22277 00004BAC 55                      	push	bp
 22278                                  	;Invoke	FATREAD_CDS
 22279 00004BAD E80E10                  	call	FATREAD_CDS	
 22280                                  	;RESTORE <BP>
 22281 00004BB0 5D                      	pop	bp
 22282 00004BB1 7264                    	JC	short FatFail
 22283                                  
 22284 00004BB3 C536[3A05]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 22285                                  	;cmp	word [si+73], -1
 22286 00004BB7 837C49FF                	CMP	word [SI+curdir.ID],-1
 22287 00004BBB 754C                    	JNZ	short RestoreCDS
 22288                                  
 22289                                  ;hkn; SS is DOSDATA
 22290                                  	;Context ES
 22291 00004BBD 16                      	push	ss
 22292 00004BBE 07                      	pop	es
 22293                                  
 22294                                  ;hkn; SS override
 22295                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 22296 00004BBF 36FF36[4A05]            	push	word [SS:WFP_START]
 22297                                  	;cmp	si,[bp-6]
 22298 00004BC4 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 22299 00004BC7 750B                    	JNZ	short DoChdir
 22300                                  	;mov	di,[bp-2]
 22301 00004BC9 8B7EFE                  	MOV	DI,Temp
 22302                                  
 22303                                  ;hkn; SS override
 22304 00004BCC 36893E[4A05]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 22305                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 22306 00004BD1 E884D3                  	call	FStrCpy
 22307                                  DoChdir:
 22308                                  ;hkn; SS is DOSDATA
 22309                                  	;Context DS
 22310 00004BD4 16                      	push	ss
 22311 00004BD5 1F                      	pop	ds
 22312                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 22313 00004BD6 FF36[0805]              	push	word [SATTRIB]
 22314 00004BDA 55                      	push	bp
 22315                                  	;Invoke	DOS_ChDir
 22316 00004BDB E808F1                  	call	DOS_CHDIR
 22317                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 22318 00004BDE 5D                      	pop	bp
 22319 00004BDF 5B                      	pop	bx
 22320 00004BE0 8F06[4A05]              	pop	word [WFP_START]
 22321 00004BE4 881E[0805]              	MOV	[SATTRIB],BL
 22322 00004BE8 C576FA                  	LDS	SI,SaveCDS
 22323 00004BEB 730F                    	JNC	short SetCluster	;	if (c == -1) {
 22324                                  
 22325                                  ;hkn; SS override for THISCDS
 22326 00004BED 368936[3A05]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 22327 00004BF2 368C1E[3C05]            	MOV	[SS:THISCDS+2],DS
 22328 00004BF7 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 22329 00004BF9 884C03                  	MOV	[SI+3],CL		;	    }
 22330                                  SetCluster:
 22331                                  	;mov	word [si+73],0FFFFh
 22332 00004BFC C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 22333 00004C01 36C536[3A05]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 22334                                  	; MSDOS 6.0
 22335                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 22336                                  	;JZ	short setdirclus		     ;AN000;;MS.
 22337                                  	;MOV	CX,-1				     ;AN000;;MS.
 22338                                  setdirclus:
 22339                                  	;mov	[si+73],cx
 22340 00004C06 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 22341                                  RestoreCDS:
 22342 00004C09 C47EFA                  	LES	DI,SaveCDS
 22343 00004C0C 36893E[3A05]            	MOV	[SS:THISCDS],DI
 22344 00004C11 368C06[3C05]            	MOV	[SS:THISCDS+2],ES
 22345 00004C16 F8                      	CLC
 22346                                  FatFail:
 22347                                  	;LeaveCrit critDisk
 22348 00004C17 E851D4                  	call	LcritDisk
 22349                                  
 22350                                  	;les	di,[bp-6]
 22351 00004C1A C47EFA                  	LES	DI,SaveCDS
 22352                                  	;Leave
 22353 00004C1D 89EC                    	mov	sp,bp
 22354 00004C1F 5D                      	pop	bp
 22355 00004C20 C3                      	retn
 22356                                  
 22357                                  ; 28/07/2018 - Retro DOS v3.0
 22358                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 22359                                  
 22360                                  ;Break	<CheckThisDevice - Check for being a device>
 22361                                  ;---------------------------------------------------------------------------
 22362                                  ;
 22363                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 22364                                  ;   device specified. We will return carry if there is a device present. 
 22365                                  ;   The forms of devices we will recognize are:
 22366                                  ;
 22367                                  ;	[path]device
 22368                                  ;
 22369                                  ;   Note that the drive letter has *already* been removed. All other forms
 22370                                  ;   are not considered to be devices. If such a device is found we change
 22371                                  ;   the source pointer to point to the device component.
 22372                                  ;
 22373                                  ;   Inputs:	ES is DOSDATA
 22374                                  ;		DS:SI contains name
 22375                                  ;   Outputs:	ES is DOSDATA
 22376                                  ;		DS:SI point to name or device
 22377                                  ;		Carry flag set if device was found
 22378                                  ;		Carry flag reset otherwise
 22379                                  ;   Registers Modified: all except ES:DI, DS
 22380                                  ;----------------------------------------------------------------------------
 22381                                  
 22382                                  CheckThisDevice:
 22383 00004C21 57                      	push	di
 22384 00004C22 56                      	push	si
 22385 00004C23 89F7                    	MOV	DI,SI
 22386                                  ;
 22387                                  ; Check for presence of \dev\ (Dam multiplan!)
 22388                                  ;
 22389 00004C25 8A04                    	MOV	AL,[SI]
 22390 00004C27 E8210A                  	call	PATHCHRCMP		; is it a path char?
 22391 00004C2A 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 22392 00004C2C 46                      	INC	SI			; simulate LODSB
 22393                                  ;
 22394                                  ; We have the leading path separator. Look for DEV part.
 22395                                  ;
 22396 00004C2D AD                      	LODSW
 22397 00004C2E 0D2020                  	OR	AX,2020h
 22398 00004C31 3D6465                  	cmp	ax,"de"
 22399                                  	;CMP	AX,"e"<< 8 + "d"
 22400 00004C34 752D                    	JNZ	short NotDevice		; not "de", assume not device
 22401 00004C36 AC                      	LODSB
 22402 00004C37 0C20                    	OR	AL,20h
 22403 00004C39 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 22404 00004C3B 7526                    	JNZ	short NotDevice
 22405 00004C3D AC                      	LODSB
 22406 00004C3E E80A0A                  	call	PATHCHRCMP		; do we have the last path separator?
 22407 00004C41 7520                    	JNZ	short NotDevice		; no. go for it.
 22408                                  ;
 22409                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 22410                                  ; SI and DevName may destroy DS.
 22411                                  ;
 22412                                  ParseDev:
 22413 00004C43 1E                      	push	ds
 22414 00004C44 56                      	push	si			; preserve the source pointer
 22415 00004C45 E89909                  	call	NameTrans		; advance DS:SI
 22416 00004C48 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 22417 00004C4B F9                      	STC				; simulate a Carry return from DevName
 22418 00004C4C 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 22419                                  
 22420                                  ;hkn; SS is DOSDATA
 22421 00004C4E 16                      	push	ss
 22422 00004C4F 1F                      	pop	ds
 22423                                  
 22424                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 22425                                  ;
 22426                                  ; SR;
 22427                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 22428                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 22429                                  ; old call set the volume attribute bit.
 22430                                  ;
 22431 00004C50 A0[0805]                	mov	al,[SATTRIB]
 22432 00004C53 A2[0605]                	mov	[ATTRIB],al		;set Attrib for DevName
 22433                                  
 22434                                  ; M026 - end
 22435                                  
 22436 00004C56 E886FE                  	call	DEVNAME
 22437                                  
 22438                                  SkipSearch:
 22439 00004C59 5E                      	pop	si
 22440 00004C5A 1F                      	pop	ds
 22441                                  ;
 22442                                  ; SI points to the beginning of the potential device. If we have a device
 22443                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 22444                                  ; original value. At this point Carry set indicates FILE.
 22445                                  ;
 22446                                  CheckReturn:
 22447 00004C5B 5F                      	pop	di			; get original SI
 22448 00004C5C 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 22449 00004C5E 89FE                    	MOV	SI,DI
 22450                                  Check_Done:
 22451 00004C60 5F                      	pop	di
 22452 00004C61 F5                      	CMC				; invert carry. Carry => device
 22453 00004C62 C3                      	retn
 22454                                  NotDevice:
 22455 00004C63 F9                      	STC
 22456 00004C64 EBF5                    	JMP	short CheckReturn
 22457                                  
 22458                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 22459                                  ;-----------------------------------------------------------------------------
 22460                                  ;
 22461                                  ; Procedure Name : LookupPath
 22462                                  ;
 22463                                  ; Output  DS:SI -> path name,
 22464                                  ;	  ES:DI -> dir entry info buffer
 22465                                  ;	  ES:CX -> extended dir info buffer
 22466                                  ;
 22467                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 22468                                  ;			     FastOpen, DS:SI points to char just one after
 22469                                  ;			     the last char of path name which is fully or
 22470                                  ;			     partially found in FastOPen
 22471                                  ;	  carry flag set : FastOpen not in memory or path name not found
 22472                                  ;
 22473                                  ;----------------------------------------------------------------------------
 22474                                  
 22475                                  LookupPath:
 22476                                  ;	PUSH	AX
 22477                                  
 22478                                  ;hkn; SS override
 22479                                  	;test	byte [ss:FastOpenFlg],1
 22480 00004C66 36F606[6E0F]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSPEN
 22481 00004C6C 7502                    	JNZ	short FASTINST			    ; and this routine is
 22482                                  NOLOOK:
 22483 00004C6E EB6A                    	JMP	NOLOOKUP			    ; executed once
 22484                                  
 22485                                  FASTINST:
 22486                                  ;hkn; SS override
 22487                                  	;test	byte [ss:FastOpenFlg],8
 22488 00004C70 36F606[6E0F]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 22489 00004C76 75F6                    	JNZ	short NOLOOK			    ; yes
 22490                                  
 22491 00004C78 BB[430F]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 22492                                  
 22493                                  ;hkn; SS override
 22494 00004C7B 368B36[4A05]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 22495 00004C80 BF[4E0F]                	MOV	DI,Dir_Info_Buff
 22496 00004C83 B9[490F]                	MOV	CX,FastOpen_Ext_Info
 22497 00004C86 B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 22498 00004C88 1E                      	PUSH	DS
 22499 00004C89 07                      	POP	ES
 22500                                  
 22501                                  ;hkn; SS override
 22502                                  	;call	far [bx+2]
 22503 00004C8A FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 22504 00004C8D 723A                    	JC	short NOTFOUND			    ; fastopen not in memory
 22505                                  
 22506 00004C8F 8D5CFE                  	LEA	BX,[SI-2]
 22507                                  
 22508                                  ;hkn; SS override
 22509 00004C92 363B1E[4A05]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 22510 00004C97 7430                    	JZ	short NOTFOUND			    ; no
 22511                                  
 22512                                  	; MSDOSD 6.0				    ; fully or partially found
 22513                                  	;CMP	BYTE [SI],0			    ;AN000;FO.
 22514                                  	;JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 22515                                  	;PUSH	CX				    ;AN000;FO.; is attribute matched ?
 22516                                  
 22517                                  ;hkn; SS override for attrib/sattrib
 22518                                  	;MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 22519                                  	;MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 22520                                  	;MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 22521                                  	;MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 22522                                  	;call	Matchattributes 		    ;AN000;FO.;
 22523                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 22524                                  	;POP	CX				    ;AN000;FO.;
 22525                                  	;JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 22526                                  ;parfnd:
 22527                                  
 22528                                  ;hkn; SS override
 22529 00004C99 368936[6F0F]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 22530 00004C9E 89CB                    	MOV	BX,CX
 22531                                  	; MSDOS 6.0
 22532                                  	;MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 22533                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 22534                                  	;MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 22535                                  	;MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 22536                                  	;MOV	[SS:DIRSTART],AX			    ;AN001;;FO.
 22537                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22538                                  	;mov	ax,[bx+3] ; MSDOS 3.3
 22539 00004CA0 8B4703                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 22540 00004CA3 36A3[5405]              	MOV	[SS:CLUSNUM],AX			    ;
 22541                                  
 22542 00004CA7 06                      	PUSH	ES				    ; save ES
 22543                                  ;hkn; SS override
 22544 00004CA8 36C41E[2405]            	LES	BX,[SS:THISDPB]			    ; put drive id
 22545 00004CAD 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 22546                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 22547 00004CB0 07                      	POP	ES				    ; pop ES
 22548                                  ;SR;
 22549                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 22550                                  ;indicate it is not a root dir
 22551                                  ;
 22552 00004CB1 36C706[7405]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 22553                                  
 22554 00004CB8 368C06[7605]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 22555 00004CBD 89FB                    	MOV	BX,DI				    ; start of entry
 22556                                  	;lea	si,[di+1Ah]
 22557 00004CBF 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 22558                                  						    ; dir_first field in the
 22559                                  						    ; dir entry
 22560                                  ;hkn; SS override for FastOpenFlg
 22561                                  	;or	byte [ss:FastOpenFlg],2
 22562 00004CC2 36800E[6E0F]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 22563                                  ;	POP	AX
 22564 00004CC8 C3                      	RETN
 22565                                  NOTFOUND:
 22566 00004CC9 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 22567 00004CCC 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 22568 00004CCE 36C606[6E0F]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 22569                                  Partial_Success:
 22570                                  	;and	byte [SS:FastOpenFlg],0FBh
 22571 00004CD4 368026[6E0F]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 22572                                  NOLOOKUP:
 22573                                  ;	POP	AX
 22574 00004CDA F9                      	STC
 22575 00004CDB C3                      	RETN
 22576                                  
 22577                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 22578                                  ;-----------------------------------------------------------------------------
 22579                                  ;
 22580                                  ; Procedure Name : InsertPath
 22581                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 22582                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 22583                                  ;	  DS = DOSDATA
 22584                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 22585                                  ;
 22586                                  ;-----------------------------------------------------------------------------
 22587                                  
 22588                                  InsertPath:
 22589 00004CDC 9C                      	PUSHF
 22590                                  ;hkn; SS override for FastOpenFlag
 22591                                  	;test	byte [SS:FastOpenFlg], 1
 22592 00004CDD 36F606[6E0F]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 22593 00004CE3 7469                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 22594                                  	;test	byte [ss:FastOpenFlg],2
 22595 00004CE5 36F606[6E0F]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 22596 00004CEB 740D                    	JZ	short INSERT_DIR_INFO		; no
 22597                                  	;and	byte [ss:FastOpenFlg],0FDh
 22598 00004CED 368026[6E0F]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 22599 00004CF3 368B3E[6F0F]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 22600 00004CF8 EB4E                    	JMP	short GET_NEXT2
 22601                                  INSERT_DIR_INFO:				; save registers
 22602 00004CFA 1E                      	PUSH	DS
 22603 00004CFB 06                      	PUSH	ES
 22604 00004CFC 53                      	PUSH	BX
 22605 00004CFD 56                      	PUSH	SI
 22606 00004CFE 57                      	PUSH	DI
 22607 00004CFF 51                      	PUSH	CX
 22608 00004D00 50                      	PUSH	AX
 22609                                  
 22610                                  ;hkn; SS override
 22611 00004D01 36C53E[7405]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 22612 00004D06 BE[490F]                	MOV	SI,FastOpen_Ext_Info
 22613                                  	;mov	ax,[di+6]
 22614 00004D09 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 22615                                  	; MSDOS 6.0
 22616 00004D0C 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 22617                                  	;MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 22618                                  
 22619                                  ;hkn; SS is DOSDATA
 22620 00004D10 16                      	push	ss
 22621 00004D11 1F                      	pop	ds
 22622                                  	; MSDOS6.0
 22623                                  	;MOV	[SI+FEI.dirsec+2],AX  ;AN000;>32mb save high dir sector
 22624                                  	; MSDOS 3.3	
 22625                                  	;mov	[si+1],ax	
 22626 00004D12 894401                  	MOV	[SI+FEI.dirsec],AX
 22627                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22628 00004D15 A1[5405]                	MOV	AX,[CLUSNUM]		; save next cluster number
 22629                                  	;;mov	[si+5],ax ; MSDOS 6.0
 22630                                  	;mov	[si+3],ax ; MSDOS 3.3
 22631 00004D18 894403                  	MOV	[SI+FEI.clusnum],AX
 22632                                  	;MSDOS 6.0
 22633                                  	;MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 22634                                  	;MOV	[SI+FEI.lastent],AX	;AN000;FO.
 22635                                  	;MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 22636                                  	;MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 22637                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22638 00004D1B 89D8                    	MOV	AX,BX
 22639                                  	;add	di,16
 22640 00004D1D 83C710                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 22641 00004D20 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 22642                                  	;mov	cl,32
 22643 00004D22 B120                    	MOV	CL,dir_entry.size
 22644 00004D24 F6F1                    	DIV	CL
 22645                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 22646 00004D26 8804                    	mov	[si],al
 22647                                  
 22648 00004D28 1E                      	PUSH	DS
 22649 00004D29 07                      	POP	ES
 22650                                  
 22651 00004D2A 8E1E[7605]              	MOV	DS,[CURBUF+2]
 22652 00004D2E 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 22653                                  	;cmp	word [di+1Ah],0
 22654 00004D30 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 22655                                  					; never insert info when file is empty
 22656 00004D34 740B                    	JZ	short SKIP_INSERT	; e.g. newly created file
 22657                                  
 22658 00004D36 56                      	PUSH	SI			; ES:BX -> extended info
 22659 00004D37 5B                      	POP	BX
 22660                                  
 22661                                  	;mov	al,2
 22662 00004D38 B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 22663 00004D3A BE[430F]                	MOV	SI,FastOpenTable
 22664                                  	;call	far [es:si+2]
 22665 00004D3D FF5C02                  	CALL	far [SI+fastopen_entry.name_caching]
 22666                                  
 22667 00004D40 F8                      	CLC
 22668                                  SKIP_INSERT:
 22669 00004D41 58                      	POP	AX
 22670 00004D42 59                      	POP	CX			; restore registers
 22671 00004D43 5F                      	POP	DI
 22672 00004D44 5E                      	POP	SI
 22673 00004D45 5B                      	POP	BX
 22674 00004D46 07                      	POP	ES
 22675 00004D47 1F                      	POP	DS
 22676                                  GET_NEXT2:
 22677                                  	;or	[ss:FastOpenFlg],8
 22678 00004D48 36800E[6E0F]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 22679                                  					; we got dir info from fastopen so
 22680                                  GET_NEXT_ELEMENT:
 22681 00004D4E 9D                      	POPF
 22682 00004D4F C3                      	RETN
 22683                                  
 22684                                  
 22685                                  ;============================================================================
 22686                                  ; DEV.ASM, MSDOS 6.0, 1991
 22687                                  ;============================================================================
 22688                                  ; 28/07/2018 - Retro DOS v3.0
 22689                                  
 22690                                  ; DEV.ASM: Retro DOS v2.0 - 14/03/2018
 22691                                  
 22692                                  ;TITLE   DEV - Device call routines
 22693                                  ;NAME    Dev
 22694                                  
 22695                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 22696                                  ;----------------------------------------------------------------------------
 22697                                  ;
 22698                                  ; Procedure Name : IOFUNC
 22699                                  ;
 22700                                  ; Inputs:
 22701                                  ;	DS:SI Points to SFT
 22702                                  ;	AH is function code
 22703                                  ;		= 0 Input
 22704                                  ;		= 1 Input Status
 22705                                  ;		= 2 Output
 22706                                  ;		= 3 Output Status
 22707                                  ;		= 4 Flush
 22708                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 22709                                  ;				   present.
 22710                                  ;	AL = character if output
 22711                                  ; Function:
 22712                                  ;	Perform indicated I/O to device or file
 22713                                  ; Outputs:
 22714                                  ;	AL is character if input
 22715                                  ;	If a status call
 22716                                  ;		zero set if not ready
 22717                                  ;		zero reset if ready (character in AL for input status)
 22718                                  ; For regular files:
 22719                                  ;	Input Status
 22720                                  ;		Gets character but restores position
 22721                                  ;		Zero set on EOF
 22722                                  ;	Input
 22723                                  ;		Gets character advances position
 22724                                  ;		Returns ^Z on EOF
 22725                                  ;	Output Status
 22726                                  ;		Always ready
 22727                                  ; AX altered, all other registers preserved
 22728                                  ;----------------------------------------------------------------------------
 22729                                  
 22730                                  IOFUNC:
 22731 00004D50 368C16[3403]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 22732                                  					; DEVIOBUF
 22733 00004D55 36C706[3203][5E03]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 22734 00004D5C 36C706[3603]0100        	MOV	WORD [SS:IOSCNT],1
 22735 00004D63 36A3[5E03]              	MOV	WORD [SS:DEVIOBUF],AX
 22736                                  	;test	word [si+5],8000h
 22737 00004D67 F744050080              	TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet
 22738 00004D6C 7403                    	JZ	short IOTO22		;AN000;
 22739 00004D6E E98500                  	JMP	IOTOFILE		;AN000;
 22740                                  IOTO22:
 22741                                  	;test	word [si+5],80h ; 17/05/2019
 22742 00004D71 F744058000              	TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 22743 00004D76 7502                    	JNZ	short IOTO33		;AN000;
 22744 00004D78 EB7C                    	JMP	IOTOFILE		;AN000;
 22745                                  IOTO33:
 22746 00004D7A E87BC8                  	call	save_world
 22747 00004D7D 8CDA                    	MOV	DX,DS
 22748 00004D7F 8CD3                    	MOV	BX,SS
 22749 00004D81 8EDB                    	MOV	DS,BX
 22750 00004D83 8EC3                    	MOV	ES,BX
 22751 00004D85 31DB                    	XOR	BX,BX
 22752 00004D87 80FC05                  	cmp	ah,5		    ; system wait enabled?
 22753 00004D8A 7504                    	jnz	short _no_sys_wait
 22754 00004D8C 81CB0004                	or	bx,0400H	    ; Set bit 10 in status word for driver
 22755                                  				    ; It is up to device driver to carry out
 22756                                  				    ; appropriate action.
 22757                                  _no_sys_wait:
 22758 00004D90 891E[2703]              	MOV	[IOCALL_REQSTAT],BX
 22759 00004D94 31DB                    	XOR	BX,BX
 22760 00004D96 881E[3103]              	MOV	[IOMED],BL
 22761                                  
 22762 00004D9A 88E3                    	MOV	BL,AH		 	; get function
 22763 00004D9C 8AA7[0413]              	MOV	AH,[BX+LenTab]
 22764 00004DA0 D1E3                    	SHL	BX,1
 22765 00004DA2 8B8F[0A13]              	MOV	CX,[BX+CmdTab]
 22766 00004DA6 BB[2403]                	MOV	BX,IOCALL
 22767 00004DA9 8826[2403]              	MOV	[IOCALL_REQLEN],AH
 22768 00004DAD 882E[2603]              	MOV	[IOCALL_REQFUNC],CH
 22769                                  
 22770 00004DB1 8EDA                    	MOV	DS,DX
 22771 00004DB3 E84401                  	CALL	DEVIOCALL
 22772 00004DB6 368B3E[2703]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 22773                                  	;test	di,8000h
 22774                                  	;jnz	short DevErr
 22775 00004DBB 21FF                    	and	di,di
 22776 00004DBD 7820                    	js	short DevErr
 22777                                  
 22778                                  OKDevIO:
 22779 00004DBF 8CD0                    	MOV	AX,SS
 22780 00004DC1 8ED8                    	MOV	DS,AX
 22781                                  
 22782                                  	;cmp	ch, 5
 22783 00004DC3 80FD05                  	CMP	CH,DEVRDND
 22784 00004DC6 7506                    	JNZ	short DNODRD
 22785 00004DC8 A0[3103]                	MOV	AL,[IORCHR]
 22786 00004DCB A2[5E03]                	MOV	[DEVIOBUF],AL
 22787                                  
 22788                                  DNODRD: 
 22789 00004DCE 8A26[2803]              	MOV	AH,[IOCALL_REQSTAT+1]
 22790 00004DD2 F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 22791                                  	;and	ah,2
 22792 00004DD4 80E402                  	AND	AH,STBUI>>8
 22793                                  
 22794                                  QuickReturn:				;AN000; 2/13/KK
 22795 00004DD7 E80BC8                  	call	restore_world
 22796                                  
 22797                                  	; SR;
 22798                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 22799                                  	; IoStatFail = -1 (set after return from the I24)
 22800                                  	;
 22801                                  
 22802                                  	; MSDOS 6.0
 22803                                  	;pushf
 22804                                  	;mov	al,[ss:IoStatFail]	;assume fail error
 22805                                  	;cbw				;sign extend to word
 22806                                  	;cmp	ax,-1
 22807                                  	;jne	short not_fail_ret
 22808                                  	;inc	byte [ss:IoStatFail]
 22809                                  	;popf
 22810                                  	;retn
 22811                                  
 22812                                  ;not_fail_ret:
 22813 00004DDA 36A1[5E03]              	MOV	AX,[SS:DEVIOBUF]	;ss override
 22814                                  	;popf
 22815 00004DDE C3                      	retn
 22816                                  
 22817                                  ;IOTOFILEJ:
 22818                                  ;	JMP	SHORT IOTOFILE
 22819                                  
 22820                                  DevErr:
 22821 00004DDF 88CC                    	MOV	AH,CL
 22822 00004DE1 E8490A                  	call	CHARHARD
 22823 00004DE4 3C01                    	CMP	AL,1
 22824 00004DE6 7506                    	JNZ	short NO_RETRY
 22825 00004DE8 E8FAC7                  	call	restore_world		
 22826 00004DEB E962FF                  	JMP	IOFUNC	; 10/08/2018
 22827                                  
 22828                                  NO_RETRY:
 22829                                  
 22830                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 22831                                  	; ready so that DOS doesn't get caught in a status loop when user 
 22832                                  	; simply wants to ignore the error.
 22833                                  	;
 22834                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 22835                                  	; should be checked by the caller on return
 22836                                  	;
 22837                                  
 22838                                  					; SS override
 22839 00004DEE 368026[2803]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 22840                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI >> 8)
 22841                                  
 22842                                  	; SR;
 22843                                  	; Check if user failed
 22844                                  	;
 22845                                  
 22846                                  	; MSDOS 6.0
 22847                                  	;cmp	al,3
 22848                                  	;jnz	short not_fail
 22849                                  	;dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 22850                                  ;not_fail:
 22851 00004DF4 EBC9                    	JMP	short OKDevIO
 22852                                  
 22853                                  IOTOFILE:
 22854 00004DF6 08E4                    	OR	AH,AH
 22855 00004DF8 7423                    	JZ	short IOIN
 22856 00004DFA FECC                    	DEC	AH
 22857 00004DFC 7405                    	JZ	short IOIST
 22858 00004DFE FECC                    	DEC	AH
 22859 00004E00 7411                    	JZ	short IOUT
 22860 00004E02 C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 22861                                  
 22862                                  IOIST:
 22863                                  	;push	word [si+15h]
 22864 00004E03 FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 22865                                  	;push	word [si+17h]
 22866 00004E06 FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 22867 00004E09 E81100                  	CALL	IOIN
 22868                                  	;pop	word [si+17h]
 22869 00004E0C 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 22870                                  	;pop	word [si+15h]
 22871 00004E0F 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 22872 00004E12 C3                      	retn
 22873                                  
 22874                                  IOUT:
 22875 00004E13 E81B00                  	CALL	SETXADDR
 22876 00004E16 E864F1                  	call	DOS_WRITE
 22877 00004E19 E84800                  	CALL	RESTXADDR	; If you change this into a jmp don't
 22878                                  IOUT_retn:
 22879 00004E1C C3                      	retn			; come crying to me when things don't
 22880                                  				; work ARR
 22881                                  IOIN:
 22882 00004E1D E81100                  	CALL	SETXADDR
 22883                                  					; SS override for DOS34_FLAG
 22884                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 22885 00004E20 E8D9EF                  	CALL	DOS_READ
 22886                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 22887 00004E23 09C9                    	OR	CX,CX			; Check EOF
 22888 00004E25 E83C00                  	CALL	RESTXADDR
 22889                                  					; SS override
 22890 00004E28 36A0[5E03]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 22891 00004E2C 75EE                    	jnz	short IOUT_retn	
 22892 00004E2E B01A                    	MOV	AL,1AH			; ^Z if no bytes
 22893 00004E30 C3                      	retn
 22894                                  
 22895                                  SETXADDR:
 22896                                  					; SS override
 22897 00004E31 368F06[1803]            	POP	WORD [SS:CALLSCNT]	; Return address
 22898                                  
 22899 00004E36 E8BFC7                  	call	save_world
 22900                                  
 22901                                  					; SS override for DMAADD and THISSFT
 22902 00004E39 36FF36[DA02]            	PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 22903 00004E3E 36FF36[DC02]            	PUSH	WORD [SS:DMAADD+2]
 22904 00004E43 368C1E[3805]            	MOV	[SS:THISSFT+2],DS
 22905                                  
 22906 00004E48 16                      	push	ss
 22907 00004E49 1F                      	pop	ds
 22908                                  
 22909 00004E4A 8936[3605]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 22910 00004E4E 8B0E[3403]              	MOV	CX,[IOXAD+2]
 22911 00004E52 890E[DC02]              	MOV	[DMAADD+2],CX
 22912 00004E56 8B0E[3203]              	MOV	CX,[IOXAD]
 22913 00004E5A 890E[DA02]              	MOV	[DMAADD],CX		; Set byte trans addr
 22914 00004E5E 8B0E[3603]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 22915 00004E62 EB0F                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 22916                                  
 22917                                  RESTXADDR:
 22918 00004E64 8F06[1803]              	POP	WORD [CALLSCNT]		; Return address
 22919 00004E68 8F06[DC02]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 22920 00004E6C 8F06[DA02]              	POP	WORD [DMAADD]
 22921                                  
 22922 00004E70 E872C7                  	call	restore_world
 22923                                  					; SS override
 22924                                  RESTRET:
 22925 00004E73 36FF26[1803]            	JMP	WORD [SS:CALLSCNT]	; Return address
 22926                                  
 22927                                  
 22928                                  ; 29/07/2018 - Retro DOS v3.0
 22929                                  ; IBMDOS.COM (1987) - Offset 4D82h
 22930                                  
 22931                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 22932                                  
 22933                                  ;----------------------------------------------------------------------------
 22934                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 22935                                  ;
 22936                                  ;	Dev_Open_SFT issues an open call to the device associated with
 22937                                  ;	the SFT.
 22938                                  ;
 22939                                  ;	ENTRY	(ES:DI) = SFT
 22940                                  ;	EXIT	none
 22941                                  ;	USES	all
 22942                                  ;----------------------------------------------------------------------------
 22943                                  
 22944                                  DEV_OPEN_SFT:
 22945 00004E78 E87DC7                  	call	save_world
 22946                                  	;mov	al,0Dh	
 22947 00004E7B B00D                    	MOV	AL,DEVOPN
 22948 00004E7D EB05                    	JMP	SHORT DO_OPCLS
 22949                                  
 22950                                  ;----------------------------------------------------------------------------
 22951                                  ; Procedure Name : DEV_CLOSE_SFT
 22952                                  ;
 22953                                  ; Inputs:
 22954                                  ;	ES:DI Points to SFT
 22955                                  ; Function:
 22956                                  ;	Issue a CLOSE call to the correct device
 22957                                  ; Outputs:
 22958                                  ;	None
 22959                                  ; ALL preserved
 22960                                  ;----------------------------------------------------------------------------
 22961                                  
 22962                                  DEV_CLOSE_SFT:
 22963 00004E7F E876C7                  	call	save_world
 22964                                  	;mov	al,0Eh	
 22965 00004E82 B00E                    	MOV	AL,DEVCLS
 22966                                  
 22967                                  	; Main entry for device open and close. AL contains the function 
 22968                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 22969                                  	; open/close to block devices. This allows networks to function but 
 22970                                  	; does NOT hang up with bogus change-line code.
 22971                                  
 22972                                  	;entry	DO_OPCLS
 22973                                  DO_OPCLS:
 22974                                  	; Is the SFT for the net?  If so, no action necessary.
 22975                                  
 22976                                  	; MSDOS 3.3
 22977                                  	;call	IsSFTNet
 22978                                  	;jnz	short OPCLS_DONE
 22979                                  
 22980                                  	; MSDOS 6.0
 22981                                  	;test	word [es:di+5],8000h
 22982 00004E84 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 22983 00004E8A 756A                    	JNZ	short OPCLS_DONE	; NOP on net SFTs
 22984 00004E8C 30E4                    	XOR	AH,AH			; Unit
 22985                                  	;test	word [es:di+5],80h
 22986 00004E8E 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 22987                                  	;les	di,[es:di+7]
 22988 00004E94 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 22989 00004E98 7513                    	JNZ	short GOT_DEV_ADDR
 22990                                  
 22991                                  	; We are about to call device open/close on a block driver. If no 
 22992                                  	; sharing then just short circuit to done.
 22993                                  	
 22994                                  ;;;;;	invoke	CheckShare
 22995                                  
 22996                                  	; MSDOS 3.3
 22997                                  	;call	CheckShare	; cmp byte [cs:fShare],0
 22998                                  	;jz	short OPCLS_DONE
 22999                                  
 23000                                  	; MSDOS 6.0
 23001                                  					; SS override
 23002 00004E9A 36803E[B102]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 23003 00004EA0 7654                    	JBE	short OPCLS_DONE	;AN010; yes
 23004                                  
 23005                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23006                                  	;mov	ah,[es:di+1]
 23007 00004EA2 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 23008 00004EA6 268A0D                  	mov	cl,[es:di]
 23009                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 23010                                  	;les	di,[es:di+12h]
 23011 00004EA9 26C47D12                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 23012                                  GOT_DEV_ADDR:				; ES:DI -> device
 23013                                  	;test	word [es:di+4],800h
 23014 00004EAD 26F745040008            	TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 23015 00004EB3 7441                    	JZ	short OPCLS_DONE	; Device can't
 23016 00004EB5 06                      	PUSH	ES
 23017 00004EB6 1F                      	POP	DS
 23018 00004EB7 89FE                    	MOV	SI,DI			; DS:SI -> device
 23019                                  OPCLS_RETRY:
 23020                                  	;Context ES
 23021 00004EB9 16                      	push	ss
 23022 00004EBA 07                      	pop	es
 23023                                  					; DEVCALL is in DOSDATA
 23024 00004EBB BF[0603]                	MOV	DI,DEVCALL
 23025                                  
 23026 00004EBE 89FB                    	MOV	BX,DI
 23027 00004EC0 50                      	PUSH	AX
 23028                                  	;mov	al,13
 23029 00004EC1 B00D                    	MOV	AL,DOPCLHL
 23030 00004EC3 AA                      	STOSB				; Length
 23031 00004EC4 58                      	POP	AX
 23032 00004EC5 86E0                    	XCHG	AH,AL
 23033 00004EC7 AA                      	STOSB				; Unit
 23034 00004EC8 86E0                    	XCHG	AH,AL
 23035 00004ECA AA                      	STOSB				; Command
 23036 00004ECB 26C7050000              	MOV	WORD [ES:DI],0		; Status
 23037 00004ED0 50                      	PUSH	AX			; Save Unit,Command
 23038                                  	;invoke	DEVIOCALL2
 23039 00004ED1 E82900                  	call	DEVIOCALL2
 23040                                  
 23041                                  	;mov	di,[es:bx+3]
 23042 00004ED4 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 23043                                  	;test	di,8000h
 23044                                  	;jz	short OPCLS_DONEP	
 23045 00004ED8 21FF                    	and	di,di
 23046 00004EDA 7919                    	jns	short OPCLS_DONEP	; No error
 23047                                  	;test	word [si+4],8000h
 23048                                  	; 22/11/2022 (BugFix)
 23049                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVTYP
 23050 00004EDC F744040080              	TEST	word [SI+SYSDEV.ATT],DEVTYP
 23051 00004EE1 7404                    	JZ	short BLKDEV
 23052 00004EE3 B486                    	MOV	AH,86H			; Read error in data, Char dev
 23053 00004EE5 EB04                    	JMP	SHORT HRDERR
 23054                                  
 23055                                  BLKDEV:
 23056 00004EE7 88C8                    	MOV	AL,CL			; Drive # in AL
 23057 00004EE9 B406                    	MOV	AH,6			; Read error in data, Blk dev
 23058                                  HRDERR:
 23059                                  	;invoke	CHARHARD
 23060 00004EEB E83F09                  	call	CHARHARD
 23061 00004EEE 3C01                    	CMP	AL,1
 23062 00004EF0 7503                    	JNZ	short OPCLS_DONEP	; IGNORE or FAIL
 23063                                  					;  Note that FAIL is essentually IGNORED
 23064 00004EF2 58                      	POP	AX			; Get back Unit, Command
 23065 00004EF3 EBC4                    	JMP	short OPCLS_RETRY
 23066                                  
 23067                                  OPCLS_DONEP:
 23068 00004EF5 58                      	POP	AX			; Clean stack
 23069                                  OPCLS_DONE:
 23070 00004EF6 E8ECC6                  	call	restore_world
 23071 00004EF9 C3                      	retn
 23072                                  
 23073                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 23074                                  ;----------------------------------------------------------------------------
 23075                                  ;**	DevIoCall  - Call Device
 23076                                  ;
 23077                                  ;	ENTRY	DS:SI Points to device SFT
 23078                                  ;		ES:BX Points to request data
 23079                                  ;	EXIT	DS:SI -> Device driver
 23080                                  ;	USES	DS:SI,AX
 23081                                  ;----------------------------------------------------------------------------
 23082                                  ;**	DevIoCall2 - Call Device
 23083                                  ;
 23084                                  ;	ENTRY	DS:SI Points to DPB
 23085                                  ;		ES:BX Points to request data
 23086                                  ;	EXIT	DS:SI -> Device driver
 23087                                  ;	USES	DS:SI,AX
 23088                                  ;----------------------------------------------------------------------------
 23089                                  
 23090                                  DEVIOCALL:
 23091                                  					; SS override for CALLSSEC, 
 23092                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 23093 00004EFA C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 23094                                  
 23095                                  	;entry	DEVIOCALL2
 23096                                  DEVIOCALL2:
 23097                                  	;EnterCrit critDevice
 23098 00004EFD E873D1                  	call	EcritDevice
 23099                                  
 23100                                  	; MSDOS 6.0
 23101                                  	;TEST	word [SI+SYSDEV.ATT],DevTyp ;AN000; >32mb   block device ?
 23102                                  	;JNZ	short chardev2		;AN000; >32mb   no
 23103                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb   read ?
 23104                                  	;JZ	short chkext		;AN000; >32mb   yes
 23105                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb   write ?
 23106                                  	;JZ	short chkex		;AN000; >32mb   yes
 23107                                  	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 23108                                  	;				;AN000; >32mb   write/verify ?
 23109                                  	;JNZ	short chardev2		;AN000; >32mb   no
 23110                                  ;chkext:
 23111                                  	;CALL	RW_SC			;AN000;LB. use secondary cache if there
 23112                                  	;JC	short dev_exit		;AN000;LB. done
 23113                                  	;
 23114                                  	;TEST	word [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb   extended driver?
 23115                                  	;JZ	short chksector		;AN000;>32mb   no
 23116                                  	;ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 23117                                  	;MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 23118                                  	;MOV	[SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 23119                                  	;MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 23120                                  	;MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 23121                                  	;MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 23122                                  	;JMP	short chardev2		;AN000; >32mb
 23123                                  ;chksector:				;AN000; >32mb
 23124                                  	;CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 23125                                  	;JZ	short chardev2		;AN000; >32mb   then fake error
 23126                                  	;MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+ERROR_I24_NOT_DOS_DISK 
 23127                                  	;				;AN000; >32mb
 23128                                  	;JMP	SHORT dev_exit		;AN000; >32mb
 23129                                  
 23130                                  ;chardev2:				;AN000;
 23131                                  
 23132                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 23133                                  	; preserved
 23134                                  
 23135                                  	;mov	ax,[si+6]
 23136 00004F00 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 23137 00004F03 36A3[2003]              	MOV	[SS:CALLDEVAD],AX
 23138 00004F07 368C1E[2203]            	MOV	[SS:CALLDEVAD+2],DS
 23139 00004F0C 36FF1E[2003]            	CALL	far [SS:CALLDEVAD]
 23140                                  	;mov	ax,[si+8]
 23141 00004F11 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 23142 00004F14 36A3[2003]              	MOV	[SS:CALLDEVAD],AX
 23143 00004F18 36FF1E[2003]            	CALL	far [SS:CALLDEVAD]
 23144                                  	; MSDOS 6.0
 23145                                  	;CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 23146                                  	;JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 23147                                  dev_exit:
 23148                                  	;LeaveCrit critDevice
 23149 00004F1D E85BD1                  	call	LcritDevice
 23150 00004F20 C3                      	retn
 23151                                  
 23152                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 23153                                  ;---------------------------------------------------------------------------
 23154                                  ;
 23155                                  ; Procedure Name : SETREAD, SETWRITE
 23156                                  ;
 23157                                  ; Inputs:
 23158                                  ;	DS:BX = Transfer Address
 23159                                  ;	CX = Record Count
 23160                                  ;	DX = Starting Record
 23161                                  ;	AH = Media Byte
 23162                                  ;	AL = Unit Code
 23163                                  ; Function:
 23164                                  ;	Set up the device call header at DEVCALL
 23165                                  ; Output:
 23166                                  ;	ES:BX Points to DEVCALL
 23167                                  ; No other registers effected
 23168                                  ;
 23169                                  ;---------------------------------------------------------------------------
 23170                                  
 23171                                  SETREAD:
 23172 00004F21 57                      	PUSH	DI
 23173 00004F22 51                      	PUSH	CX
 23174 00004F23 50                      	PUSH	AX
 23175 00004F24 B104                    	MOV	CL,DEVRD ; mov cl,4
 23176                                  SETCALLHEAD:
 23177 00004F26 B016                    	MOV	AL,DRDWRHL ; mov al,16h
 23178 00004F28 16                      	PUSH	SS
 23179 00004F29 07                      	POP	ES
 23180                                  					; DEVCALL is in DOSDATA
 23181 00004F2A BF[0603]                	MOV	DI,DEVCALL
 23182                                  
 23183 00004F2D AA                      	STOSB				; length
 23184 00004F2E 58                      	POP	AX
 23185 00004F2F AA                      	STOSB				; Unit
 23186 00004F30 50                      	PUSH	AX
 23187 00004F31 88C8                    	MOV	AL,CL
 23188 00004F33 AA                      	STOSB				; Command code
 23189 00004F34 31C0                    	XOR	AX,AX
 23190 00004F36 AB                      	STOSW				; Status
 23191 00004F37 83C708                  	ADD	DI,8			; Skip link fields
 23192 00004F3A 58                      	POP	AX
 23193 00004F3B 86E0                    	XCHG	AH,AL
 23194 00004F3D AA                      	STOSB				; Media byte
 23195 00004F3E 86C4                    	XCHG	AL,AH
 23196 00004F40 50                      	PUSH	AX
 23197 00004F41 89D8                    	MOV	AX,BX
 23198 00004F43 AB                      	STOSW
 23199 00004F44 8CD8                    	MOV	AX,DS
 23200 00004F46 AB                      	STOSW				; Transfer addr
 23201 00004F47 59                      	POP	CX			; Real AX
 23202 00004F48 58                      	POP	AX			; Real CX
 23203 00004F49 AB                      	STOSW				; Count
 23204 00004F4A 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 23205 00004F4B AB                      	STOSW				; Start
 23206 00004F4C 91                      	XCHG	AX,CX
 23207 00004F4D 87D1                    	XCHG	DX,CX
 23208 00004F4F 5F                      	POP	DI
 23209                                  					; DEVCALL is in DOSDATA
 23210 00004F50 BB[0603]                	MOV	BX,DEVCALL
 23211 00004F53 C3                      	retn
 23212                                  
 23213                                  	;entry	SETWRITE
 23214                                  SETWRITE:
 23215                                  
 23216                                  ; Inputs:
 23217                                  ;	DS:BX = Transfer Address
 23218                                  ;	CX = Record Count
 23219                                  ;	DX = Starting Record
 23220                                  ;	AH = Media Byte
 23221                                  ;	AL = Unit Code
 23222                                  ; Function:
 23223                                  ;	Set up the device call header at DEVCALL
 23224                                  ; Output:
 23225                                  ;	ES:BX Points to DEVCALL
 23226                                  ; No other registers effected
 23227                                  
 23228 00004F54 57                      	PUSH	DI
 23229 00004F55 51                      	PUSH	CX
 23230 00004F56 50                      	PUSH	AX
 23231 00004F57 B108                    	MOV	CL,DEVWRT ; mov cl,8
 23232 00004F59 36020E[AD02]            	ADD	CL,[SS:VERFLG]		; SS override
 23233 00004F5E EBC6                    	JMP	SHORT SETCALLHEAD
 23234                                  
 23235                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 23236                                  ;---------------------------------------------------------------------------
 23237                                  ;
 23238                                  ; Procedure Name : RW_SC
 23239                                  ;
 23240                                  ; Inputs:
 23241                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 23242                                  ;	 [SC_STATUS]= SC validity status
 23243                                  ;	 [SEQ_SECTOR]= last sector read
 23244                                  ; Function:
 23245                                  ;	Read from or write through secondary cache
 23246                                  ; Output:
 23247                                  ;	ES:BX Points to DEVCALL
 23248                                  ;	carry clear, I/O is not done
 23249                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 23250                                  ;	carry set, I/O is done
 23251                                  ;
 23252                                  ;----------------------------------------------------------------------------
 23253                                  
 23254                                  ;procedure   RW_SC,NEAR		;AN000;
 23255                                  ;
 23256                                  ;	; SS override for all variables used.
 23257                                  ;
 23258                                  ;	CMP	[SC_CACHE_COUNT],0	;AN000;LB. secondary cache exists?
 23259                                  ;	JZ	scexit4 		;AN000;LB. no, do nothing
 23260                                  ;	CMP	[CALLSCNT],1		;AN000;LB. sector count = 1 (buffer I/O)
 23261                                  ;	JNZ	scexit4 		;AN000;LB. no, do nothing
 23262                                  ;	PUSH	CX			    ;AN000;;LB.
 23263                                  ;	PUSH	DX			    ;AN000;;LB. yes
 23264                                  ;	PUSH	DS			    ;AN000;;LB. save registers
 23265                                  ;	PUSH	SI			    ;AN000;;LB.
 23266                                  ;	PUSH	ES			    ;AN000;;LB.
 23267                                  ;	PUSH	DI			    ;AN000;;LB.
 23268                                  ;	MOV	DX,WORD PTR [CALLSSEC]	    ;AN000;;LB.  starting sector
 23269                                  ;	CMP	BYTE PTR [DEVCALL.REQFUNC],DEVRD ;AN000;LB. read ?
 23270                                  ;	JZ	doread			    ;AN000;LB. yes
 23271                                  ;	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 23272                                  ;	JMP	scexit2 		    ;AN000;LB. back to normal
 23273                                  ;scexit4:				    ;AN000;
 23274                                  ;	CLC				    ;AN000;LB. I/O not done yet
 23275                                  ;	return				    ;AN000;LB.
 23276                                  ;doread: 				    ;AN000;
 23277                                  ;	CALL	SC2BUF			    ;AN000;LB. check if in SC
 23278                                  ;	JC	readSC			    ;AN000;LB.
 23279                                  ;	MOV	[DEVCALL.REQSTAT],STDON     ;AN000;LB. fake done and ok
 23280                                  ;	STC				    ;AN000;LB. set carry
 23281                                  ;	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 23282                                  ;readSC: 				    ;AN000;
 23283                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
 23284                                  ;	MOV	CX,WORD PTR [CALLSSEC]	    ;AN000;;LB. saved sequential sector
 23285                                  ;	SUB	CX,WORD PTR [SEQ_SECTOR]    ;AN000;;LB. number
 23286                                  ;	SBB	AX,WORD PTR [SEQ_SECTOR+2]  ;AN000;;LB.
 23287                                  ;	CMP	AX,0			    ;AN000;;LB. greater than 64K
 23288                                  ;	JNZ	saveseq2		    ;AN000;;LB. yes,save seq. sector #
 23289                                  ;chklow: 						
 23290                                  ;	CMP	CX,1			    ;AN000;;LB. <= 1
 23291                                  ;	JA	saveseq2		    ;AN000;;LB. no, not sequential
 23292                                  ;	MOV	[SC_STATUS],-1		    ;AN000;;LB. prsume all SC valid
 23293                                  ;	MOV	AX,[SC_CACHE_COUNT]	    ;AN000;;LB. yes, sequential
 23294                                  ;	MOV	[CALLSCNT],AX		    ;AN000;;LB. read continuous sectors
 23295                                  ;readsr:
 23296                                  ;	MOV	AX,WORD PTR [CALLXAD+2]     ;AN000;;LB. save buffer addr
 23297                                  ;	MOV	[TEMP_VAR2],AX		    ;AN000;;LB. in temp vars
 23298                                  ;	MOV	AX,WORD PTR [CALLXAD]	    ;AN000;;LB.
 23299                                  ;	MOV	[TEMP_VAR],AX		    ;AN000;;LB.
 23300                                  ;						
 23301                                  ;	MOV	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;LB. use SC cache addr as
 23302                                  ;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;LB. transfer addr
 23303                                  ;	MOV	AX,WORD PTR [SC_CACHE_PTR+2] ;AN000;LB.
 23304                                  ;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;LB.
 23305                                  ;	MOV	[SC_FLAG],1		    ;AN000;LB. flag it for later;
 23306                                  ;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
 23307                                  ;	MOV	[CURSC_DRIVE],AL	    ;AN000;;LB. set current drive
 23308                                  ;	MOV	AX,WORD PTR [CALLSSEC]	    ;AN000;;LB. current sector
 23309                                  ;	MOV	[CURSC_SECTOR],AX	    ;AN000;;LB. set current sector
 23310                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB.
 23311                                  ;	MOV	[CURSC_SECTOR+2],AX	    ;AN000;;LB.
 23312                                  ;saveseq2:				    ;AN000;
 23313                                  ;	CLC				    ;AN000;LB. clear carry
 23314                                  ;saveseq:				    ;AN000;	
 23315                                  ;	MOV	AX,[HIGH_SECTOR]	    ;AN000;LB. save current sector #
 23316                                  ;	MOV	WORD PTR [SEQ_SECTOR+2],AX  ;AN000;LB. for access mode ref.
 23317                                  ;	MOV	AX,[CALLSSEC]		    ;AN000;LB.	
 23318                                  ;	MOV	WORD PTR [SEQ_SECTOR],AX    ;AN000;LB.	
 23319                                  ;	JMP	short scexit 		    ;AN000;LB.	
 23320                                  ;						
 23321                                  ;scexit2:				    ;AN000;LB.
 23322                                  ;	CLC				    ;AN000;LB.	clear carry
 23323                                  ;scexit: 				    ;AN000;		
 23324                                  ;	POP	DI			    ;AN000;;LB.
 23325                                  ;	POP	ES			    ;AN000;;LB. restore registers
 23326                                  ;	POP	SI			    ;AN000;;LB.
 23327                                  ;	POP	DS			    ;AN000;;LB.
 23328                                  ;	POP	DX			    ;AN000;;LB.
 23329                                  ;	POP	CX			    ;AN000;;LB.
 23330                                  ;	return				    ;AN000;;LB.
 23331                                  ;							
 23332                                  ;EndProc RW_SC				    ;AN000;
 23333                                  
 23334                                  ;Break	<IN_SC -- check if in secondary cache>
 23335                                  ;--------------------------------------------------------------------------
 23336                                  ;
 23337                                  ; Procedure Name : IN_SC
 23338                                  ;
 23339                                  ; Inputs:  [SC_DRIVE]= requesting drive
 23340                                  ;	   [CURSC_DRIVE]= current SC drive
 23341                                  ;	   [CURSC_SECTOR] = starting scetor # of SC
 23342                                  ;	   [SC_CACHE_COUNT] = SC count
 23343                                  ;	   [HIGH_SECTOR]:DX= sector number
 23344                                  ; Function:
 23345                                  ;	Check if the sector is in secondary cache
 23346                                  ; Output:
 23347                                  ;	carry clear, in SC
 23348                                  ;	   CX= the index in the secondary cache
 23349                                  ;	carry set, not in SC
 23350                                  ;
 23351                                  ;---------------------------------------------------------------------------
 23352                                  
 23353                                  ;procedure   IN_SC,NEAR		    ;AN000;
 23354                                  ;
 23355                                  ;	; SS override for all variables used
 23356                                  ;
 23357                                  ;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
 23358                                  ;	CMP	AL,[CURSC_DRIVE]	    ;AN000;;LB. same as SC drive
 23359                                  ;	JNZ	outrange2		    ;AN000;;LB. no
 23360                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
 23361                                  ;	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 23362                                  ;	SUB	CX,WORD PTR [CURSC_SECTOR]    ;AN000;;LB. number
 23363                                  ;	SBB	AX,WORD PTR [CURSC_SECTOR+2]  ;AN000;;LB.
 23364                                  ;	CMP	AX,0			    ;AN000;;LB. greater than 64K
 23365                                  ;	JNZ	outrange2		    ;AN000;;LB. yes
 23366                                  ;	CMP	CX,[SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 23367                                  ;	JAE	outrange2		    ;AN000;;LB. yes
 23368                                  ;	CLC				    ;AN000;;LB. clear carry
 23369                                  ;	JMP	short inexit		    ;AN000;;LB. in SC
 23370                                  ;outrange2:				    ;AN000;;LB. set carry
 23371                                  ;	STC				    ;AN000;;LB.
 23372                                  ;inexit: 				    ;AN000;;LB.
 23373                                  ;	return				    ;AN000;;LB.
 23374                                  ;
 23375                                  ;EndProc IN_SC				    ;AN000;
 23376                                  
 23377                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 23378                                  ;---------------------------------------------------------------------------
 23379                                  ;
 23380                                  ; Procedure Name : Invalidate_Sc
 23381                                  ;
 23382                                  ; Inputs:  [SC_DRIVE]= requesting drive
 23383                                  ;	   [CURSC_DRIVE]= current SC drive
 23384                                  ;	   [CURSC_SECTOR] = starting scetor # of SC
 23385                                  ;	   [SC_CACHE_COUNT] = SC count
 23386                                  ;	   [SC_STAUS] = SC status word
 23387                                  ;	   [HIGH_SECTOR]:DX= sector number
 23388                                  ;
 23389                                  ; Function:
 23390                                  ;	invalidate secondary cache if in there
 23391                                  ; Output:
 23392                                  ;	[SC_STATUS] is updated
 23393                                  ;---------------------------------------------------------------------------
 23394                                  
 23395                                  ;procedure   INVALIDATE_SC,NEAR	    ;AN000;
 23396                                  ;
 23397                                  ;	; SS override for all variables used
 23398                                  ;
 23399                                  ;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 23400                                  ;	JC	outrange		    ;AN000;;LB. no
 23401                                  ;	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 23402                                  ;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 23403                                  ;	NOT	AX			    ;AN000;;LB.
 23404                                  ;	AND	[SC_STATUS],AX		    ;AN000;;LB. save the status
 23405                                  ;outrange:				    ;AN000;;LB.
 23406                                  ;	return				    ;AN000;;LB.
 23407                                  ;
 23408                                  ;EndProc INVALIDATE_SC			    ;AN000;
 23409                                  
 23410                                  
 23411                                  ;Break	<VIRREAD- virtually read data into buffer>
 23412                                  ;--------------------------------------------------------------------------
 23413                                  ;
 23414                                  ; Procedure Name : SC_FLAG
 23415                                  ;
 23416                                  ; Inputs:  SC_FLAG = 0 , no sectors were read into SC
 23417                                  ;		     1, continous sectors were read into SC
 23418                                  ; Function:
 23419                                  ;	   Move data from SC to buffer
 23420                                  ; Output:
 23421                                  ;	 carry clear, data is moved to buffer
 23422                                  ;	 carry set, bad sector or exceeds maximum sector
 23423                                  ;	   SC_FLAG =0
 23424                                  ;	   CALLSCNT=1
 23425                                  ;	   SC_STATUS= -1 if succeeded
 23426                                  ;     
 23427                                  ;		       0 if failed
 23428                                  ;--------------------------------------------------------------------------
 23429                                  
 23430                                  ;procedure   VIRREAD,NEAR	    ;AN000;
 23431                                  ;
 23432                                  ;	; SS override for all variables used
 23433                                  ;
 23434                                  ;	CMP	[SC_FLAG],0		    ;AN000;;LB.  from SC fill
 23435                                  ;	JZ	sc2end			    ;AN000;;LB.  no
 23436                                  ;	MOV	AX,[TEMP_VAR2]		    ;AN000;;LB. restore buffer addr
 23437                                  ;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;;LB.
 23438                                  ;	MOV	AX,[TEMP_VAR]		    ;AN000;;LB.
 23439                                  ;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;;LB.
 23440                                  ;	MOV	[SC_FLAG],0		    ;AN000;;LB.  reset sc_flag
 23441                                  ;	MOV	[CALLSCNT],1		    ;AN000;;LB.  one sector transferred
 23442                                  ;
 23443                                  ;	TESTB	[DEVCALL.REQSTAT],STERR     ;AN000;;LB.  error?
 23444                                  ;	JNZ	scerror 		    ;AN000;;LB. yes
 23445                                  ;	PUSH	DS			    ;AN000;;LB.
 23446                                  ;	PUSH	SI			    ;AN000;;LB.
 23447                                  ;	PUSH	ES			    ;AN000;;LB.
 23448                                  ;	PUSH	DI			    ;AN000;;LB.
 23449                                  ;	PUSH	DX			    ;AN000;;LB.
 23450                                  ;	PUSH	CX			    ;AN000;;LB.
 23451                                  ;	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 23452                                  ;	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buffer
 23453                                  ;	POP	CX			    ;AN000;;LB.
 23454                                  ;	POP	DX			    ;AN000;;LB.
 23455                                  ;	POP	DI			    ;AN000;;LB.
 23456                                  ;	POP	ES			    ;AN000;;LB.
 23457                                  ;	POP	SI			    ;AN000;;LB.
 23458                                  ;	POP	DS			    ;AN000;;LB.
 23459                                  ;	JMP	SHORT sc2end		    ;AN000;;LB. return
 23460                                  ;
 23461                                  ;scerror:				    ;AN000;
 23462                                  ;	MOV	[CALLSCNT],1		    ;AN000;;LB. reset sector count to 1
 23463                                  ;	MOV	[SC_STATUS],0		    ;AN000;;LB. invalidate all SC sectors
 23464                                  ;	MOV	[CURSC_DRIVE],-1	    ;AN000;;LB. invalidate drive
 23465                                  ;	STC				    ;AN000;;LB. carry set
 23466                                  ;	return				    ;AN000;;LB.
 23467                                  ;
 23468                                  ;sc2end: 				    ;AN000;
 23469                                  ;	CLC				    ;AN000;;LB. carry clear
 23470                                  ;	return				    ;AN000;;LB.
 23471                                  ;
 23472                                  ;EndProc VIRREAD 			    ;AN000;
 23473                                  
 23474                                  ;Break	<SC2BUF- move data from SC to buffer>
 23475                                  ;----------------------------------------------------------------------------
 23476                                  ;
 23477                                  ; Procedure Name : SC2BUF
 23478                                  ;
 23479                                  ; Inputs:  [SC_STATUS] = SC validity status
 23480                                  ;	   [SC_SECTOR_SIZE] = request sector size
 23481                                  ;	   [SC_CACHE_PTR] = pointer to SC
 23482                                  ; Function:
 23483                                  ;	   Move data from SC to buffer
 23484                                  ; Output:
 23485                                  ;	   carry clear, in SC  and data is moved
 23486                                  ;	   carry set, not in SC and data is not moved
 23487                                  ;---------------------------------------------------------------------------
 23488                                  
 23489                                  ;procedure   SC2BUF,NEAR 	    ;AN000;
 23490                                  ;
 23491                                  ;	; SS override for all variables used
 23492                                  ;
 23493                                  ;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 23494                                  ;	JC	noSC			    ;AN000;;LB. no
 23495                                  ;	MOV	AX,1			    ;AN000;;LB. check if valid sector
 23496                                  ;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 23497                                  ;	TEST	[SC_STATUS],AX		    ;AN000;;LB.
 23498                                  ;	JZ	noSC			    ;AN000;;LB. invalid
 23499                                  ;entry SC2BUF2				    ;AN000;
 23500                                  ;	MOV	AX,CX			    ;AN000;;LB. times index with
 23501                                  ;	MUL	[SC_SECTOR_SIZE]	    ;AN000;;LB. sector size
 23502                                  ;	ADD	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;;LB. add SC starting addr
 23503                                  ;	ADC	DX,WORD PTR [SC_CACHE_PTR+2];AN000;;LB.
 23504                                  ;	MOV	DS,DX			    ;AN000;    ;LB. DS:SI-> SC sector addr
 23505                                  ;	MOV	SI,AX			    ;AN000;    ;LB.
 23506                                  ;	MOV	ES,WORD PTR [CALLXAD+2]     ;AN000;    ;LB. ES:DI-> buffer addr
 23507                                  ;	MOV	DI,WORD PTR [CALLXAD]	    ;AN000;    ;LB.
 23508                                  ;	MOV	CX,[SC_SECTOR_SIZE]	    ;AN000;    ;LB. count= sector size
 23509                                  ;	SHR	CX,1			    ;AN000;    ;LB. may use DWORD move for 386
 23510                                  ;entry MOVWORDS				    ;AN000;
 23511                                  ;	CMP	[DDMOVE],0		    ;AN000;    ;LB. 386 ?
 23512                                  ;	JZ	nodd			    ;AN000;    ;LB. no
 23513                                  ;	SHR	CX,1			    ;AN000;    ;LB. words/2
 23514                                  ;	DB	66H			    ;AN000;    ;LB. use double word move
 23515                                  ;nodd:
 23516                                  ;	REP	MOVSW			    ;AN000;    ;LB. move to buffer
 23517                                  ;	CLC				    ;AN000;    ;LB. clear carry
 23518                                  ;	return				    ;AN000;    ;LB. exit
 23519                                  ;noSC:					    ;AN000;
 23520                                  ;	STC				    ;AN000;    ;LB. set carry
 23521                                  ;sexit:					    ;AN000;
 23522                                  ;	return				    ;AN000;    ;LB.
 23523                                  ;
 23524                                  ;EndProc SC2BUF
 23525                                  
 23526                                  
 23527                                  ;============================================================================
 23528                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 23529                                  ;============================================================================
 23530                                  ; 29/07/2018 - Retro DOS v3.0
 23531                                  
 23532                                  ;	TITLE	MKNODE - Node maker
 23533                                  ;	NAME	MKNODE
 23534                                  
 23535                                  ;**	MKNODE.ASM
 23536                                  ;
 23537                                  ;	Low level routines for making a new local file system node
 23538                                  ;	and filling in an SFT from a directory entry
 23539                                  ;
 23540                                  ;	BUILDDIR
 23541                                  ;	SETDOTENT
 23542                                  ;	MakeNode
 23543                                  ;	NEWENTRY
 23544                                  ;	FREEENT
 23545                                  ;	NEWDIR
 23546                                  ;	DOOPEN
 23547                                  ;	RENAME_MAKE
 23548                                  ;	CHECK_VIRT_OPEN
 23549                                  ;
 23550                                  ;	Revision history:
 23551                                  ;
 23552                                  ;	 AN000	version 4.0  Jan. 1988
 23553                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 23554                                  
 23555                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 23556                                  ;----------------------------------------------------------------------------
 23557                                  ;
 23558                                  ; Procedure Name : BUILDDIR,NEWDIR
 23559                                  ;
 23560                                  ; Inputs:
 23561                                  ;       ES:BP Points to DPB
 23562                                  ;       [THISSFT] Set if using NEWDIR entry point
 23563                                  ;               (used by ALLOCATE)
 23564                                  ;       [LASTENT] current last valid entry number in directory if no free
 23565                                  ;               entries
 23566                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 23567                                  ; Function:
 23568                                  ;       Grow directory if no free entries and not root
 23569                                  ; Outputs:
 23570                                  ;       CARRY SET IF FAILURE
 23571                                  ;       ELSE
 23572                                  ;          AX entry number of new entry
 23573                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 23574                                  ;               AX = first entry of new dir
 23575                                  ;       GETENT should be called to set [LASTENT]
 23576                                  ;
 23577                                  ;----------------------------------------------------------------------------
 23578                                  
 23579                                  BUILDDIR:
 23580                                  	; 29/07/2018 - Retro DOS v3.0
 23581                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 23582                                  
 23583 00004F60 A1[6A05]                        MOV     AX,[ENTFREE]
 23584 00004F63 83F8FF                          CMP     AX,-1
 23585 00004F66 7402                            JZ	short CHECK_IF_ROOT
 23586 00004F68 F8                              CLC
 23587 00004F69 C3                              retn
 23588                                  
 23589                                  CHECK_IF_ROOT:
 23590 00004F6A 833E[5805]00                    CMP     word [DIRSTART],0
 23591 00004F6F 7502                            JNZ	short NEWDIR
 23592 00004F71 F9                              STC
 23593                                  builddir_retn:
 23594 00004F72 C3                              retn				; Can't grow root
 23595                                  
 23596                                  	;entry   NEWDIR
 23597                                  NEWDIR:        
 23598 00004F73 8B1E[5805]              	MOV     BX,[DIRSTART]
 23599 00004F77 09DB                            OR      BX,BX
 23600 00004F79 7405                            JZ	short NULLDIR
 23601 00004F7B E89A05                  	call	GETEOF
 23602 00004F7E 72F2                            jc	short builddir_retn	; Screw up
 23603                                  NULLDIR:
 23604 00004F80 B90100                          MOV     CX,1
 23605 00004F83 E8BF04                  	call	ALLOCATE
 23606 00004F86 72EA                            jc	short  builddir_retn
 23607 00004F88 8B16[5805]                      MOV     DX,[DIRSTART]
 23608 00004F8C 09D2                            OR      DX,DX
 23609 00004F8E 750D                            JNZ	short ADDINGDIR
 23610 00004F90 E84CF8                  	call	SETDIRSRCH
 23611 00004F93 72DD                            jc	short  builddir_retn
 23612 00004F95 C706[F402]FFFF                  MOV     word [LASTENT],-1
 23613 00004F9B EB2B                            JMP     SHORT GOTDIRREC
 23614                                  ADDINGDIR:
 23615 00004F9D 53                              PUSH    BX
 23616 00004F9E 8B1E[5405]                      MOV     BX,[CLUSNUM]
 23617 00004FA2 E8940A                          call	IsEOF
 23618 00004FA5 5B                              POP     BX
 23619 00004FA6 7219                            JB	short NOTFIRSTGROW
 23620                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 23621 00004FA8 891E[5405]                      MOV     [CLUSNUM],BX
 23622 00004FAC 51                              PUSH    CX
 23623 00004FAD 50                              PUSH    AX
 23624 00004FAE 55                              PUSH    BP
 23625 00004FAF B401                            MOV     AH,1			; CLUSNUM update
 23626                                  	;mov	dl,[es:bp+0]
 23627 00004FB1 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 23628                                          ;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 23629 00004FB5 8B0E[5805]                      MOV     CX,[DIRSTART]		; first cluster #
 23630 00004FB9 89DD                            MOV     BP,BX 			; CLUSNUM
 23631 00004FBB E84DE4                  	call	FastOpen_Update
 23632 00004FBE 5D                              POP     BP
 23633 00004FBF 58                              POP     AX
 23634 00004FC0 59                              POP     CX
 23635                                  
 23636                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 23637                                  NOTFIRSTGROW:
 23638 00004FC1 89DA                            MOV     DX,BX
 23639 00004FC3 30DB                            XOR     BL,BL
 23640 00004FC5 E86C04                  	call	FIGREC
 23641                                  GOTDIRREC:
 23642                                  	;mov	cl,[es:bp+4]
 23643 00004FC8 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 23644 00004FCC FEC1                            INC     CL
 23645 00004FCE 30ED                            XOR     CH,CH
 23646                                  ZERODIR:
 23647 00004FD0 51                              PUSH    CX
 23648                                  	;mov	byte [ALLOWED],18h
 23649 00004FD1 C606[F702]18                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 23650 00004FD6 B0FF                            MOV     AL,0FFH
 23651 00004FD8 E8AD0E                          call	GETBUFFR
 23652 00004FDB 7302                            JNC	short GET_SSIZE
 23653 00004FDD 59                              POP     CX
 23654 00004FDE C3                              retn
 23655                                  
 23656                                  GET_SSIZE:
 23657                                  	;mov	cx,[es:bp+2]
 23658 00004FDF 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 23659 00004FE3 06                              PUSH    ES
 23660 00004FE4 C43E[7405]                      LES     DI,[CURBUF]
 23661                                  	;or	byte [es:di+5],4
 23662 00004FE8 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 23663 00004FED 57                              PUSH    DI
 23664                                  	;add	di,16
 23665 00004FEE 83C710                          ADD     DI,BUFINSIZ
 23666 00004FF1 31C0                            XOR     AX,AX
 23667 00004FF3 D1E9                            SHR     CX,1
 23668 00004FF5 F3AB                            REP     STOSW
 23669 00004FF7 7301                            JNC	short EVENZ
 23670 00004FF9 AA                              STOSB
 23671                                  EVENZ:
 23672 00004FFA 5F                              POP     DI
 23673                                  
 23674                                  	; MSDOS 6.0
 23675                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 23676                                  	;				;LB. if already dirty		  ;AN000;
 23677                                          ;JNZ	short _yesdirty_	;LB.  don't increment dirty count ;AN000;
 23678                                          ;call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 23679                                          
 23680                                  	;or	byte [es:di+5],40h
 23681 00004FFB 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 23682                                  ;_yesdirty_:
 23683 00005000 07                              POP	ES
 23684 00005001 59                              POP	CX
 23685                                  
 23686                                  	; MSDOS 6.0
 23687                                  	;add	dx, 1
 23688                                  	;adc	word [HIGH_SECTOR],0
 23689                                  
 23690 00005002 42                      	INC	DX
 23691 00005003 E2CB                            LOOP    ZERODIR
 23692                                  
 23693 00005005 A1[F402]                        MOV     AX,[LASTENT]
 23694 00005008 40                              INC     AX
 23695 00005009 F8                              CLC
 23696 0000500A C3                              retn
 23697                                  
 23698                                  ;--------------------------------------------------------------------------
 23699                                  ;
 23700                                  ; Procedure Name : SETDOTENT
 23701                                  ;
 23702                                  ; set up a . or .. directory entry for a directory.
 23703                                  ;
 23704                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 23705                                  ;               AX contains ". " or ".."
 23706                                  ;               DX contains first cluster of entry
 23707                                  ;
 23708                                  ;----------------------------------------------------------------------------
 23709                                  
 23710                                  SETDOTENT:
 23711                                  ;	Fill in name field
 23712 0000500B AB                              STOSW
 23713 0000500C B90400                          MOV     CX,4
 23714 0000500F B82020                          MOV     AX,"  " ; 2020h
 23715 00005012 F3AB                            REP     STOSW
 23716 00005014 AA                              STOSB
 23717                                  
 23718                                  ;	Set up attribute
 23719                                  	;mov	al, 10h
 23720 00005015 B010                            MOV     AL,attr_directory
 23721 00005017 AA                              STOSB
 23722                                  
 23723                                  ;	Initialize time and date of creation
 23724 00005018 83C70A                          ADD     DI,10
 23725 0000501B 8B36[3605]                      MOV     SI,[THISSFT]
 23726                                  	;mov	ax,[si+0Dh]
 23727 0000501F 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 23728 00005022 AB                              STOSW
 23729                                  	;mov	ax,[si+0Fh]
 23730 00005023 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 23731 00005026 AB                      	STOSW
 23732                                  
 23733                                  ;	Set up first cluster field
 23734 00005027 89D0                            MOV     AX,DX
 23735 00005029 AB                              STOSW
 23736                                  
 23737                                  ;	0 file size
 23738 0000502A 31C0                            XOR     AX,AX
 23739 0000502C AB                              STOSW
 23740 0000502D AB                              STOSW
 23741 0000502E C3                              retn
 23742                                  
 23743                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 23744                                  ;---------------------------------------------------------------------------
 23745                                  ;
 23746                                  ; Procedure Name : MakeNode
 23747                                  ;
 23748                                  ; Inputs:
 23749                                  ;       AL - attribute to create
 23750                                  ;       AH = 0 if it is ok to truncate a file already by this name
 23751                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 23752                                  ;               (AH ignored on dirs and devices)
 23753                                  ;
 23754                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 23755                                  ;               a name already existant is ALWAYS an error in these cases.
 23756                                  ;
 23757                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 23758                                  ;               terminated)
 23759                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 23760                                  ;               ( = -1 if current dir not involved, else
 23761                                  ;                Points to first char after last "/" of current dir part)
 23762                                  ;       [THISCDS] Points to CDS being used
 23763                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 23764                                  ; Function:
 23765                                  ;       Make a new node
 23766                                  ; Outputs:
 23767                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 23768                                  ;       CARRY SET IF ERROR
 23769                                  ;          AX = 1 A node by this name exists and is a directory
 23770                                  ;          AX = 2 A new node could not be created
 23771                                  ;          AX = 3 A node by this name exists and is a disk file
 23772                                  ;               (AH was NZ on input)
 23773                                  ;          AX = 4 Bad Path
 23774                                  ;               SI return from GetPath maintained
 23775                                  ;          AX = 5 Attribute mismatch
 23776                                  ;          AX = 6 Sharing Violation
 23777                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 23778                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 23779                                  ;       ELSE
 23780                                  ;          AX = 0       Disk Node
 23781                                  ;          AX = 3       Device Node (error in some cases)
 23782                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 23783                                  ;               containing new node.
 23784                                  ;          [CURBUF+2]:BX Points to entry
 23785                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 23786                                  ;          [THISSFT] is filled in
 23787                                  ;               sf_mode = unchanged.
 23788                                  ;          Attribute byte in entry is input AL
 23789                                  ; DS preserved, others destroyed
 23790                                  ;
 23791                                  ;-------------------------------------------------------------------------
 23792                                  
 23793                                  MakeNode:
 23794                                  	;mov	word [CREATING],0E5FFh
 23795 0000502F C706[1805]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 23796 00005035 50                              PUSH    AX              ; Save AH value
 23797 00005036 C606[F802]00            	MOV	byte [NoSetDir],0
 23798 0000503B A2[0805]                	MOV	[SATTRIB],AL
 23799 0000503E E8F9F7                  	call	GetPathNoSet
 23800 00005041 88CA                            MOV     DL,CL           ; Save CL info
 23801 00005043 89C1                            MOV     CX,AX           ; Device ID to CH
 23802 00005045 58                              POP     AX              ; Get back AH
 23803 00005046 7316                            JNC	short make_exists ; File existed
 23804 00005048 7505                            JNZ	short make_err_4 ; Path bad
 23805 0000504A 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 23806 0000504D 7406                            JZ	short make_type	; Name simply not found, and no metas
 23807                                  make_err_4:
 23808 0000504F B004                            MOV     AL,4            ; case 1 bad path
 23809                                  make_err_ret:
 23810 00005051 30E4                            XOR     AH,AH
 23811 00005053 F9                              STC
 23812                                  make_retn:
 23813 00005054 C3                              retn
 23814                                  
 23815                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 23816                                  RENAME_MAKE:
 23817                                  make_type:
 23818                                  ;Extended Open hooks
 23819                                  	; MSDOS 6.0
 23820                                  	;TESTB	EXTOPEN_ON,ext_open_on	;FT. from extended open		;AN000;
 23821                                  	;JZ	make_type2		;FT. no				;AN000;
 23822                                  	;OR	EXTOPEN_ON,ext_file_not_exists ;FT. set for extended open ;AN000;
 23823                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 23824                                  	;JNZ    make_type2		;FT. no				;AN000;
 23825                                  	;STC				;FT. set carry			;AN000;
 23826                                  	;MOV    AX,7			;FT. file not found		;AN000;
 23827                                  	;return				;FT.				;AN000;
 23828                                  ;	Extended Open hooks
 23829                                  
 23830                                  make_type2:
 23831 00005055 C43E[3605]                      LES     DI,[THISSFT]
 23832 00005059 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 23833 0000505B F9                              STC                     ; Not found
 23834 0000505C EB5A                            JMP     short make_new
 23835                                  
 23836                                  ; The node exists.  It may be either a device, directory or file:
 23837                                  ;   Zero set => directory
 23838                                  ;   High bit of CH on => device
 23839                                  ;   else => file
 23840                                  make_exists:
 23841 0000505E 7448                            JZ	short make_exists_dir
 23842 00005060 B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 23843                                  	;test	byte [ATTRIB],18h
 23844 00005062 F606[0605]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 23845 00005067 753B                            JNZ	short make_err_ret_5
 23846                                  				; Cannot already exist as Disk or Device Node
 23847                                                                  ;       if making DIR or Volume ID
 23848 00005069 08ED                            OR      CH,CH
 23849 0000506B 781A                            JS	short make_share ; No further checks on attributes if device
 23850 0000506D 08E4                            OR      AH,AH
 23851 0000506F 75E0                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 23852 00005071 51                              PUSH    CX              ; Save device ID
 23853 00005072 8E06[7605]                      MOV     ES,[CURBUF+2]
 23854                                  	;mov	ch,[es:bx+0Bh]
 23855 00005076 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 23856                                  	;test	ch,1
 23857 0000507A F6C501                  	test	CH,attr_read_only
 23858 0000507D 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 23859 0000507F E850FA                  	call	MatchAttributes
 23860 00005082 59                              POP     CX              ; Devid back in CH
 23861 00005083 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 23862 00005085 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 23863                                  make_share:
 23864 00005087 30E4                            XOR     AH,AH
 23865 00005089 50                              PUSH    AX              ; Save Disk or Device node
 23866 0000508A 51                              PUSH    CX              ; Save Device ID
 23867 0000508B 88EC                            MOV     AH,CH           ; Device ID to AH
 23868 0000508D E83301                          CALL    DOOPEN          ; Fill in SFT for share check
 23869 00005090 C43E[3605]                      LES     DI,[THISSFT]
 23870 00005094 56                      	push	si
 23871 00005095 53                      	push	bx		; Save CURBUF pointers
 23872 00005096 E8BF22                  	call	ShareEnter
 23873 00005099 7350                            jnc	short MakeEndShare
 23874                                  
 23875                                  ; User failed request.
 23876 0000509B 5B                      	pop	bx
 23877 0000509C 5E                      	pop	si
 23878 0000509D 59                      	pop	cx
 23879 0000509E 58                      	pop	ax
 23880                                  
 23881                                  Make_Share_ret:
 23882 0000509F B006                            MOV     AL,6
 23883 000050A1 EBAE                            JMP	short make_err_ret
 23884                                  
 23885                                  make_err_ret_5P:
 23886 000050A3 59                              POP     CX              ; Get back device ID
 23887                                  make_err_ret_5:
 23888 000050A4 B005                            MOV     AL,5            ; Attribute mismatch
 23889 000050A6 EBA9                            JMP     make_err_ret
 23890                                  
 23891                                  make_exists_dir:
 23892 000050A8 B001                            MOV     AL,1            ; exists as directory, always an error
 23893 000050AA EBA5                            JMP     make_err_ret
 23894                                  
 23895                                  make_save:
 23896 000050AC 50                              PUSH    AX              ; Save whether Disk or File
 23897 000050AD 89C8                            MOV     AX,CX           ; Device ID to AH
 23898 000050AF E86A00                          CALL    NEWENTRY
 23899 000050B2 58                              POP     AX              ; 0 if Disk, 3 if File
 23900 000050B3 739F                            jnc	short make_retn
 23901 000050B5 B002                            MOV     AL,2            ; create failed case 2
 23902                                  make_save_retn:
 23903 000050B7 C3                              retn
 23904                                  
 23905                                  make_new:
 23906 000050B8 E8F1FF                          call    make_save
 23907 000050BB 72FA                            jc	short make_save_retn	; case 2 fail
 23908 000050BD F606[0605]10            	test	BYTE [ATTRIB],attr_directory
 23909 000050C2 75F3                            jnz	short make_save_retn	; Don't "open" directories, so don't
 23910                                                                  ;   tell the sharer about them
 23911 000050C4 50                      	push	ax
 23912 000050C5 53                      	push	bx
 23913 000050C6 56                      	push	si		
 23914 000050C7 E88E22                          call	ShareEnter
 23915 000050CA 5E                      	pop	si
 23916 000050CB 5B                      	pop	bx
 23917 000050CC 58                      	pop	ax
 23918 000050CD 73E8                    	jnc	short make_save_retn
 23919                                  ;
 23920                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 23921                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 23922                                  ; possible: delete the newly created directory entry and return share_error.
 23923                                  ;
 23924 000050CF 50                              PUSH    AX
 23925 000050D0 C43E[7405]                      LES     DI,[CURBUF]
 23926                                  	;mov	byte [es:bx],0E5h
 23927 000050D4 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 23928                                  	
 23929                                  	; MSDOS 6.0
 23930                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 23931                                  	;				;LB. if already dirty		  ;AN000;
 23932                                          ;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 23933                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 23934                                  	;or	byte [es:di+5],40h
 23935 000050D8 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 23936                                  ;yesdirty3:
 23937 000050DD C42E[2405]                      LES     BP,[THISDPB]
 23938 000050E1 268A4600                        mov	al,[ES:BP]
 23939                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 23940 000050E5 E8480E                          call	FLUSHBUF		; write out buffer.
 23941 000050E8 58                              POP     AX
 23942 000050E9 EBB4                            jmp	short Make_Share_ret
 23943                                  ;
 23944                                  ; We have found an existing file. We have also entered it into the share set.
 23945                                  ; At this point we need to call newentry to correctly address the problem of
 23946                                  ; getting rid of old data (create an existing file) or creating a new
 23947                                  ; directory entry (create a new file). Unfortunately, this operation may
 23948                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 23949                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 23950                                  ; the share set now, do the operation and then reassert the share access.
 23951                                  ;
 23952                                  ; We are allowed to do this! There is no window! After all, we are in
 23953                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 23954                                  ;
 23955                                  MakeEndShare:
 23956 000050EB C43E[3605]                      LES     DI,[THISSFT]		; grab SFT
 23957 000050EF 31C0                            XOR     AX,AX
 23958 000050F1 E86FCF                  	call	EcritSFT
 23959 000050F4 268705                  	xchg	AX,[ES:DI]
 23960                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 23961 000050F7 50                      	push	ax
 23962 000050F8 57                      	push	di
 23963 000050F9 06                      	push	es
 23964 000050FA 9C                              PUSHF
 23965 000050FB E85522                          call	ShareEnd                ; remove sharing
 23966 000050FE 9D                              POPF
 23967 000050FF 07                      	pop	es
 23968 00005100 5F                      	pop	di
 23969 00005101 268F05                          pop	word [ES:DI]	
 23970                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 23971 00005104 E864CF                  	call	LcritSFT
 23972 00005107 5B                      	pop	bx
 23973 00005108 5E                      	pop	si
 23974 00005109 59                      	pop	cx
 23975 0000510A 58                      	pop	ax
 23976 0000510B E89EFF                          CALL    make_save
 23977                                  
 23978                                  ; If the user failed, we do not reenter into the sharing set.
 23979                                  
 23980 0000510E 72A7                            jc	short make_save_retn	; bye if error
 23981 00005110 50                      	push	ax
 23982 00005111 53                      	push	bx
 23983 00005112 56                      	push	si
 23984 00005113 9C                              PUSHF
 23985 00005114 E84122                          call	ShareEnter
 23986 00005117 9D                              POPF
 23987 00005118 5E                      	pop	si
 23988 00005119 5B                      	pop	bx
 23989 0000511A 58                      	pop	ax
 23990                                  
 23991                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 23992                                  
 23993                                  makeendshare_retn:
 23994 0000511B C3                              retn
 23995                                  
 23996                                  ;---------------------------------------------------------------------------
 23997                                  ;
 23998                                  ; Procedure Name : NEWENTRY
 23999                                  ;
 24000                                  ; Inputs:
 24001                                  ;       [THISSFT] set
 24002                                  ;       [THISDPB] set
 24003                                  ;       [LASTENT] current last valid entry number in directory if no free
 24004                                  ;               entries
 24005                                  ;       [VOLID] set if a volume ID was found during search
 24006                                  ;	Attrib Contains attributes for new file
 24007                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 24008                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 24009                                  ;               NC means file existed (device)
 24010                                  ;               C  means file did not exist
 24011                                  ;       AH = Device ID byte
 24012                                  ;       If FILE
 24013                                  ;           [CURBUF+2]:BX points to start of directory entry
 24014                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 24015                                  ;       If device
 24016                                  ;           DS:BX points to start of "fake" directory entry
 24017                                  ;           DS:SI points to dir_first of "fake" directory entry
 24018                                  ;               (has DWORD pointer to device header)
 24019                                  ; Function:
 24020                                  ;       Make a new directory entry
 24021                                  ;       If an old one existed it is truncated first
 24022                                  ; Outputs:
 24023                                  ;       Carry set if error
 24024                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 24025                                  ;               vol ID, user FAILed to I 24
 24026                                  ;       else
 24027                                  ;               outputs of DOOPEN
 24028                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 24029                                  ;
 24030                                  ;----------------------------------------------------------------------------
 24031                                  
 24032                                  NEWENTRY:
 24033 0000511C C42E[2405]                      LES     BP,[THISDPB]
 24034 00005120 7316                            JNC	short EXISTENT	
 24035 00005122 803E[F602]00                    CMP     byte [FAILERR],0
 24036 00005127 F9                              STC
 24037 00005128 75F1                            jnz	short makeendshare_retn	; User FAILed, node might exist
 24038 0000512A E833FE                          CALL    BUILDDIR        ; Try to build dir
 24039 0000512D 72EC                            jc	short makeendshare_retn	; Failed
 24040 0000512F E87FF6                          call	GETENT          ; Point at that free entry
 24041 00005132 72E7                            jc	short makeendshare_retn	; Failed
 24042 00005134 EB0E                            JMP     SHORT FREESPOT
 24043                                  
 24044                                  ERRRET3:
 24045 00005136 F9                              STC
 24046                                  newentry_retn:
 24047 00005137 C3                              retn
 24048                                  
 24049                                  EXISTENT:
 24050 00005138 08E4                            OR      AH,AH           ; Check if file is I/O device
 24051 0000513A 7903                            JNS	short NOT_DEV1
 24052 0000513C E98400                          JMP     DOOPEN          ; If so, proceed with open
 24053                                  
 24054                                  NOT_DEV1:
 24055 0000513F E81401                          call	FREEENT		; Free cluster chain
 24056 00005142 72F3                            jc	short newentry_retn ; Failed
 24057                                  FREESPOT:
 24058                                  	;test	byte [ATTRIB],8
 24059 00005144 F606[0605]08            	test	BYTE [ATTRIB],attr_volume_id
 24060 00005149 7407                            JZ	short NOTVOLID
 24061 0000514B 803E[1605]00                    CMP     BYTE [VOLID],0
 24062 00005150 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 24063                                  NOTVOLID:
 24064 00005152 8E06[7605]                      MOV     ES,[CURBUF+2]
 24065 00005156 89DF                            MOV     DI,BX
 24066                                  
 24067 00005158 BE[E604]                        MOV     SI,NAME1
 24068                                  
 24069 0000515B B90500                          MOV     CX,5
 24070 0000515E F3A5                            REP     MOVSW
 24071 00005160 A4                              MOVSB                   ; Move name into dir entry
 24072 00005161 A0[0605]                	MOV	AL,[ATTRIB]
 24073 00005164 AA                      	STOSB                   ; Attributes
 24074                                  
 24075                                  ;; File Tagging for Create DOS 4.00
 24076 00005165 B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 24077                                  ;; File Tagging for Create DOS 4.00
 24078                                  
 24079 00005167 31C0                            XOR     AX,AX
 24080 00005169 F3AB                            REP     STOSW           ; Zero pad
 24081 0000516B E848C7                          call	DATE16
 24082 0000516E 92                              XCHG    AX,DX
 24083 0000516F AB                              STOSW                   ; dir_time
 24084 00005170 92                              XCHG    AX,DX
 24085 00005171 AB                              STOSW                   ; dir_date
 24086 00005172 31C0                            XOR     AX,AX
 24087 00005174 57                              PUSH    DI              ; Correct SI input value
 24088                                  				; 	(recomputed for new buffer)
 24089 00005175 AB                              STOSW                   ; Zero dir_first and size
 24090 00005176 AB                              STOSW
 24091 00005177 AB                              STOSW
 24092                                  updnxt:
 24093 00005178 8B36[7405]              	MOV	SI,[CURBUF]
 24094                                  
 24095                                  	; MSDOS 6.0
 24096                                  	;TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 24097                                  	;			;LB. if already dirty		  ;AN000;
 24098                                          ;JNZ	short yesdirty4	;LB.  don't increment dirty count ;AN000;
 24099                                          ;call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 24100                                          
 24101                                  	;or	byte [es:si+5],40h
 24102 0000517C 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 24103                                  ;yesdirty4:
 24104 00005181 C42E[2405]                      LES     BP,[THISDPB]
 24105 00005185 268A4600                	MOV	AL,[ES:BP]	; mov al,[es:bp+0] 
 24106                                          ;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 24107 00005189 50                              PUSH    AX
 24108 0000518A 53                              PUSH    BX
 24109                                  ; If we have a file, we need to increment the open ref. count so that
 24110                                  ; we have some protection against invalid media changes if an Int 24
 24111                                  ; error occurs.
 24112                                  ; Do nothing for a device.
 24113 0000518B 06                      	push	es
 24114 0000518C 57                      	push	di
 24115 0000518D C43E[3605]                      LES     DI,[THISSFT]
 24116                                  	;test	word [es:di+5],80h
 24117 00005191 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 24118 00005197 751A                            jnz	short GotADevice
 24119 00005199 1E                      	push	ds
 24120 0000519A 53                      	push	bx
 24121 0000519B C51E[2405]                      LDS     BX,[THISDPB]
 24122                                  	;mov	[es:di+7],bx
 24123 0000519F 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 24124 000051A3 8CDB                            MOV     BX,DS
 24125                                  	;mov	[es:di+9],bx
 24126 000051A5 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 24127 000051A9 5B                      	pop	bx
 24128 000051AA 1F                      	pop	ds ; need to use DS for segment later on
 24129 000051AB E8CAFC                  	call	DEV_OPEN_SFT    ; increment ref. count
 24130 000051AE C606[080A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 24131                                  GotADevice:
 24132 000051B3 5F                      	pop	di
 24133 000051B4 07                      	pop	es
 24134                                  
 24135 000051B5 E8780D                          call	FLUSHBUF
 24136 000051B8 E8DA00                          Call    CHECK_VIRT_OPEN ; decrement ref. count                          ;AN000;
 24137 000051BB 5B                              POP     BX
 24138 000051BC 58                              POP     AX
 24139 000051BD 5E                              POP     SI              ; Get SI input back
 24140 000051BE 88C4                            MOV     AH,AL           ; Get I/O driver number back
 24141 000051C0 7301                            jnc	short DOOPEN    ; Failed
 24142 000051C2 C3                      	retn
 24143                                  
 24144                                  ;NOTE FALL THROUGH
 24145                                  
 24146                                  ; Inputs:
 24147                                  ;       [THISDPB] points to DPB if file
 24148                                  ;       [THISSFT] points to SFT being used
 24149                                  ;       AH = Device ID byte
 24150                                  ;       If FILE
 24151                                  ;           [CURBUF+2]:BX points to start of directory entry
 24152                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 24153                                  ;       If device
 24154                                  ;           DS:BX points to start of "fake" directory entry
 24155                                  ;           DS:SI points to dir_first of "fake" directory entry
 24156                                  ;               (has DWORD pointer to device header)
 24157                                  ; Function:
 24158                                  ;       Fill in SFT from dir entry
 24159                                  ; Outputs:
 24160                                  ;       CARRY CLEAR
 24161                                  ;       sf_ref_count and sf_mode fields not altered
 24162                                  ;       sf_flags high byte = 0
 24163                                  ;       sf_flags low byte = AH except
 24164                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 24165                                  ;       sf_attr sf_date sf_time sf_name set from entry
 24166                                  ;       sf_position = 0
 24167                                  ;       If device
 24168                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 24169                                  ;           sf_size = 0
 24170                                  ;       If file
 24171                                  ;           sf_firclus sf_size set from entry
 24172                                  ;           sf_devptr = [THISDPB]
 24173                                  ;           sf_cluspos = 0
 24174                                  ;           sf_lstclus = sf_firclus
 24175                                  ;           sf_dirsec sf_dirpos set
 24176                                  ; DS,SI,BX preserved, others destroyed
 24177                                  
 24178                                  	;entry	DOOPEN
 24179                                  DOOPEN:
 24180                                  ;	Generate and store attribute
 24181                                  
 24182 000051C3 88E6                            MOV     DH,AH           ; AH to different place
 24183 000051C5 C43E[3605]                      LES     DI,[THISSFT]
 24184                                  	;add	di,4
 24185 000051C9 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 24186 000051CC 30C0                            XOR     AL,AL           ; Assume it's a device, devices have an
 24187                                                                  ;   attribute of 0 (for R/O testing etc).
 24188 000051CE 08F6                            OR      DH,DH           ; See if our assumption good.
 24189 000051D0 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 24190 000051D2 8E1E[7605]                      MOV     DS,[CURBUF+2]
 24191                                  	;mov	al,[BX+0Bh]
 24192 000051D6 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 24193                                  				; If file, get attrib from dir entry
 24194                                  DEV_SFT1:
 24195 000051D9 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 24196                                  
 24197                                  ;	Generate and store flags word
 24198                                  
 24199 000051DA 31C0                            XOR     AX,AX
 24200 000051DC 88F0                            MOV     AL,DH
 24201                                  	;or	al,40h
 24202 000051DE 0C40                            OR      AL,devid_file_clean
 24203 000051E0 AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 24204                                  
 24205                                  ;	Generate and store device pointer
 24206                                  
 24207 000051E1 1E                              PUSH    DS
 24208                                  	;lds	ax,[bx+1Ah]
 24209 000051E2 C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 24210 000051E5 08F6                            OR      DH,DH
 24211 000051E7 7805                            JS	short DEV_SFT2
 24212                                  
 24213                                  ;hkn; SS override
 24214 000051E9 36C506[2405]                    LDS     AX,[SS:THISDPB]	; Was file
 24215                                  DEV_SFT2:
 24216 000051EE AB                              STOSW 			; store offset
 24217 000051EF 8CD8                            MOV     AX,DS
 24218 000051F1 1F                              POP     DS
 24219 000051F2 AB                      	STOSW			; store segment
 24220                                  				; ES:DI -> sf_firclus
 24221                                  
 24222                                  ;	Generate pointer to, generate and store first cluster 
 24223                                  ;	(irrelevant for devices)
 24224                                  
 24225 000051F3 56                              PUSH    SI              ; Save pointer to dir_first
 24226 000051F4 A5                              MOVSW                   ; dir_first -> sf_firclus
 24227                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 24228                                  
 24229                                  ;	Copy time/date of last modification
 24230                                  
 24231                                  	;sub	si,6
 24232 000051F5 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 24233                                  				; DS:SI->dir_time
 24234 000051F8 A5                              MOVSW                   ; dir_time -> sf_time
 24235                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 24236 000051F9 A5                              MOVSW                   ; dir_date -> sf_date
 24237                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 24238                                  
 24239                                  ;	Generate and store file size (0 for devices)
 24240                                  
 24241 000051FA AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 24242 000051FB AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 24243 000051FC 89C1                            MOV     CX,AX           ; dir_size_l in CX
 24244 000051FE AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 24245 000051FF 08F6                            OR      DH,DH
 24246 00005201 7904                            JNS	short FILE_SFT1
 24247 00005203 31C0                            XOR     AX,AX
 24248 00005205 89C1                            MOV     CX,AX           ; Devices are open ended
 24249                                  FILE_SFT1:
 24250 00005207 91                              XCHG    AX,CX
 24251 00005208 AB                              STOSW                   ; Low word of sf_size
 24252 00005209 91                              XCHG    AX,CX
 24253 0000520A AB                              STOSW                   ; High word of sf_size
 24254                                                                  ; ES:DI -> sf_position
 24255                                  ; Initialize position to 0
 24256                                  
 24257 0000520B 31C0                            XOR     AX,AX
 24258 0000520D AB                              STOSW
 24259 0000520E AB                              STOSW                   ; sf_position
 24260                                                                  ; ES:DI -> sf_cluspos
 24261                                  
 24262                                  ; Generate cluster optimizations for files
 24263                                  
 24264 0000520F 08F6                            OR      DH,DH
 24265 00005211 7834                            JS	short DEV_SFT3
 24266 00005213 AB                              STOSW                   ; sf_cluspos
 24267                                  	;mov	ax,[bx+1Ah]
 24268 00005214 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 24269                                  	; MSDOS 3.3
 24270 00005217 AB                      	STOSW                   ; sf_lstclus
 24271                                  	; MSDOS 6.0
 24272                                          ;PUSH	DI              ;AN004; save dirsec offset
 24273                                          ;SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 24274                                          ;MOV	[ES:DI.sf_lstclus],AX	;AN004; save it
 24275                                          ;POP	DI              ;AN004; restore dirsec offset
 24276                                  
 24277                                  ; DOS 3.3  FastOpen  6/13/86
 24278                                  
 24279 00005218 1E                      	PUSH	DS
 24280                                  
 24281                                  ;hkn; SS is DOSDATA
 24282 00005219 16                      	push	ss
 24283 0000521A 1F                      	pop	ds
 24284                                  	;test	byte [FastOpenFlg],4
 24285 0000521B F606[6E0F]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 24286 00005220 740D                    	JZ	short Not_FastOpen
 24287                                  
 24288                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 24289 00005222 BE[490F]                        MOV     SI,FastOpen_Ext_Info
 24290                                  
 24291 00005225 8B4401                          MOV     AX,[SI+FEI.dirsec]
 24292 00005228 AB                              STOSW                   ; sf_dirsec
 24293                                  	; MSDOS 6.0
 24294                                          ;MOV	AX,[SI+FEI.dirsec+2]
 24295                                  				;;; changed for >32mb
 24296                                          ;STOSW                   ; sf_dirsec
 24297                                  	; 19/08//2018
 24298 00005229 8A04                    	mov	al,[SI]
 24299                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 24300 0000522B AA                              STOSB                   ; sf_dirpos
 24301 0000522C 1F                              POP	DS
 24302 0000522D EB16                            JMP     short Next_Name
 24303                                  
 24304                                  ; DOS 3.3  FastOpen  6/13/86
 24305                                  
 24306                                  Not_FastOpen:
 24307 0000522F 1F                              POP     DS		; normal path
 24308                                  
 24309                                  ;hkn; SS override
 24310 00005230 368B36[7405]                    MOV     SI,[SS:CURBUF]	; DS:SI->buffer header
 24311                                  
 24312 00005235 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 24313 00005238 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 24314                                          ; MSDOS 6.0
 24315                                  	;MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 24316                                          ;STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 24317                                          
 24318 00005239 89D8                    	MOV     AX,BX
 24319                                  	;add	si,16
 24320 0000523B 83C610                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 24321 0000523E 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 24322                                          ;mov	cl,32
 24323 00005240 B120                    	MOV     CL,dir_entry.size
 24324 00005242 F6F1                            DIV     CL
 24325 00005244 AA                              STOSB                   ; sf_dirpos
 24326                                  
 24327                                  Next_Name:
 24328 00005245 EB03                            JMP     SHORT FILE_SFT2
 24329                                  
 24330                                  DEV_SFT3:
 24331                                  	;add	di,7
 24332 00005247 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 24333                                  FILE_SFT2:
 24334                                  ;
 24335                                  ; Copy in the object's name
 24336                                  ;
 24337 0000524A 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 24338 0000524C B90B00                          MOV     CX,11
 24339 0000524F F3A4                            REP     MOVSB           ; sf_name
 24340 00005251 5E                              POP     SI              ; recover DS:SI -> dir_first
 24341                                  
 24342                                  ;hkn; SS is DOSDATA
 24343 00005252 16                              push	ss
 24344 00005253 1F                      	pop	ds
 24345 00005254 F8                              CLC
 24346 00005255 C3                              retn
 24347                                  
 24348                                  ;---------------------------------------------------------------------------
 24349                                  ;
 24350                                  ; Procedure Name : FREEENT
 24351                                  ;
 24352                                  ; Inputs:
 24353                                  ;       ES:BP -> DPB
 24354                                  ;       [CURBUF] Set
 24355                                  ;       [CURBUF+2]:BX points to directory entry
 24356                                  ;       [CURBUF+2]:SI points to above dir_first
 24357                                  ; Function:
 24358                                  ;       Free the cluster chain for the entry if present
 24359                                  ; Outputs:
 24360                                  ;       Carry set if error (currently user FAILed to I 24)
 24361                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 24362                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 24363                                  ;---------------------------------------------------------------------------
 24364                                  
 24365                                  FREEENT:
 24366 00005256 1E                              PUSH    DS
 24367 00005257 C53E[7405]                      LDS     DI,[CURBUF]
 24368 0000525B 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 24369                                  	; 19/05/2019
 24370                                  	; MSDOS 6.0
 24371                                  	;MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 24372                                  ;hkn; SS override
 24373                                          ;MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 24374 0000525D 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 24375 00005260 1F                              POP     DS
 24376 00005261 83F902                  	CMP	CX,2
 24377 00005264 722D                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 24378                                  	;cmp	cx,[es:bp+0Dh]
 24379 00005266 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 24380 0000526A 7727                            JA	short RET1	; Treat like zero length file (firclus mucked)
 24381 0000526C 29FB                            SUB     BX,DI
 24382 0000526E 53                              PUSH    BX              ; Save offset
 24383                                  	;PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 24384 0000526F 52                              PUSH    DX              ; Save sector number
 24385 00005270 89CB                            MOV     BX,CX
 24386 00005272 E87702                          call	RELEASE         ; Free any data allocated
 24387 00005275 5A                              POP     DX
 24388                                          ;POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 24389 00005276 7302                            JNC	short GET_BUF_BACK
 24390 00005278 5B                              POP     BX
 24391                                  freeent_retn:
 24392 00005279 C3                              retn			; Screw up
 24393                                  
 24394                                  GET_BUF_BACK:
 24395                                  	;mov	byte [ALLOWED],18h
 24396 0000527A C606[F702]18                    MOV     byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 24397 0000527F 30C0                            XOR     AL,AL
 24398 00005281 E8040C                  	call	GETBUFFR        ; Get sector back
 24399 00005284 5B                              POP     BX              ; Get offset back
 24400 00005285 72F2                            jc	short freeent_retn
 24401 00005287 E8AAEE                  	call	SET_BUF_AS_DIR
 24402 0000528A 031E[7405]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 24403 0000528E 89DE                            MOV     SI,BX
 24404                                  	;add	si,1Ah
 24405 00005290 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 24406                                  RET1:
 24407 00005293 F8                              CLC
 24408 00005294 C3                              retn
 24409                                  
 24410                                  ;---------------------------------------------------------------------------
 24411                                  ;
 24412                                  ; Procedure Name : CHECK_VIRT_OPEN
 24413                                  ;
 24414                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 24415                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 24416                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 24417                                  ; flag [VIRTUAL_OPEN].
 24418                                  ; No registers affected (including flags).
 24419                                  ; On input, [THISSFT] points to current SFT.
 24420                                  ;
 24421                                  ;---------------------------------------------------------------------------
 24422                                  
 24423                                  CHECK_VIRT_OPEN:
 24424 00005295 50                      	        PUSH    AX
 24425 00005296 9F                              lahf                    ; preserve flags
 24426 00005297 803E[080A]00                    CMP     byte [VIRTUAL_OPEN],0
 24427 0000529C 7410                            JZ	short ALL_CLOSED
 24428 0000529E C606[080A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 24429 000052A3 06                      	push	es
 24430 000052A4 57                      	push	di
 24431 000052A5 C43E[3605]                      LES     DI,[THISSFT]
 24432 000052A9 E8D3FB                          call	DEV_CLOSE_SFT
 24433 000052AC 5F                      	pop	di
 24434 000052AD 07                      	pop	es
 24435                                  
 24436                                  ALL_CLOSED:
 24437 000052AE 9E                              sahf                    ; restore flags
 24438 000052AF 58                              POP     AX
 24439 000052B0 C3                              retn
 24440                                  
 24441                                  ;============================================================================
 24442                                  ; ROM.ASM, MSDOS 6.0, 1991
 24443                                  ;============================================================================
 24444                                  ; 29/07/2018 - Retro DOS v3.0
 24445                                  
 24446                                  ;	TITLE	ROM - Miscellaneous routines
 24447                                  ;	NAME	ROM
 24448                                  
 24449                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 24450                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 24451                                  ;
 24452                                  ;	SKPCLP
 24453                                  ;	FNDCLUS
 24454                                  ;	BUFSEC
 24455                                  ;	BUFRD
 24456                                  ;	BUFWRT
 24457                                  ;	NEXTSEC
 24458                                  ;	OPTIMIZE
 24459                                  ;	FIGREC
 24460                                  ;	ALLOCATE
 24461                                  ;	RESTFATBYT
 24462                                  ;	RELEASE
 24463                                  ;	RELBLKS
 24464                                  ;	GETEOF
 24465                                  ;
 24466                                  ;	Modification history:
 24467                                  ;
 24468                                  ;		Created: ARR 30 March 1983
 24469                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 24470                                  
 24471                                  ;Break   <FNDCLUS -- Skip over allocation units>
 24472                                  ;--------------------------------------------------------------------------
 24473                                  ;
 24474                                  ; Procedure Name : FNDCLUS
 24475                                  ;
 24476                                  ; Inputs:
 24477                                  ;       CX = No. of clusters to skip
 24478                                  ;       ES:BP = Base of drive parameters
 24479                                  ;       [THISSFT] point to SFT
 24480                                  ; Outputs:
 24481                                  ;       BX = Last cluster skipped to
 24482                                  ;       CX = No. of clusters remaining (0 unless EOF)
 24483                                  ;       DX = Position of last cluster
 24484                                  ;       Carry set if error (currently user FAILed to I 24)
 24485                                  ; DI destroyed. No other registers affected.
 24486                                  ;--------------------------------------------------------------------------
 24487                                  
 24488                                  FNDCLUS:
 24489 000052B1 06                      	PUSH	ES
 24490 000052B2 C43E[3605]                      LES     DI,[THISSFT]		; setup addressability to SFT
 24491                                  	;mov	bx,[es:di+1Bh]
 24492 000052B6 268B5D1B                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 24493                                  	;mov	dx,[es:di+19h]
 24494 000052BA 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 24495 000052BE 09DB                    	OR	BX,BX
 24496 000052C0 7424                    	JZ	short NOCLUS
 24497                                  
 24498 000052C2 29D1                            SUB     CX,DX
 24499 000052C4 7308                            JNB	short FINDIT
 24500                                  
 24501 000052C6 01D1                            ADD     CX,DX
 24502 000052C8 31D2                            XOR     DX,DX
 24503                                  	;mov	bx,[es:di+0Bh]
 24504 000052CA 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 24505                                  FINDIT:
 24506 000052CE 07                              POP	ES
 24507 000052CF E313                    	JCXZ	RET9
 24508                                  
 24509                                  	;entry	SKPCLP
 24510                                  SKPCLP:
 24511 000052D1 E87C07                  	call	UNPACK
 24512 000052D4 7214                            jc	short fndclus_retn	; retc
 24513                                  	
 24514                                  	; 09/09/2018
 24515                                  
 24516                                  	; MSDOS 6.0
 24517                                  	;xchg	bx,di
 24518                                  	;call	IsEOF
 24519                                  	;pop	bx
 24520                                  	;xchg	bx,di
 24521                                  	;jae	short RET9
 24522                                  
 24523                                  	; MSDOS 3.3
 24524 000052D6 53                      	push	bx
 24525 000052D7 89FB                    	mov	bx,di
 24526 000052D9 E85D07                  	call	IsEOF
 24527 000052DC 5B                      	pop	bx	
 24528 000052DD 7305                    	jae	short RET9
 24529                                  
 24530 000052DF 87DF                            XCHG    BX,DI
 24531 000052E1 42                              INC     DX
 24532 000052E2 E2ED                    	LOOP	SKPCLP			; RMFS
 24533                                  RET9:	
 24534 000052E4 F8                      	CLC
 24535 000052E5 C3                              retn
 24536                                  NOCLUS:
 24537 000052E6 07                              POP	ES
 24538 000052E7 41                              INC	CX
 24539 000052E8 4A                              DEC	DX
 24540 000052E9 F8                              CLC
 24541                                  
 24542                                  fndclus_retn:
 24543 000052EA C3                              retn
 24544                                  
 24545                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 24546                                  ;--------------------------------------------------------------------------
 24547                                  ;
 24548                                  ; Procedure Name : BUFSEC
 24549                                  ;
 24550                                  ; Inputs:
 24551                                  ;       AH = priority of buffer
 24552                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 24553                                  ;       ES:BP = Base of drive parameters
 24554                                  ;       [CLUSNUM] = Physical cluster number
 24555                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 24556                                  ;       [BYTCNT1] = Size of transfer
 24557                                  ; Function:
 24558                                  ;       Insure specified sector is in buffer, flushing buffer before
 24559                                  ;       read if necessary.
 24560                                  ; Outputs:
 24561                                  ;       ES:DI = Pointer to buffer
 24562                                  ;       SI = Pointer to transfer address
 24563                                  ;       CX = Number of bytes
 24564                                  ;       [NEXTADD] updated
 24565                                  ;       [TRANS] set to indicate a transfer will occur
 24566                                  ;       Carry set if error (user FAILed to I 24)
 24567                                  ;--------------------------------------------------------------------------
 24568                                  
 24569                                  BUFSEC:
 24570 000052EB 8B16[5405]                      MOV     DX,[CLUSNUM]
 24571 000052EF 8A1E[0E05]                      MOV     BL,[SECCLUSPOS]
 24572                                  	;mov	byte [ALLOWED],38h
 24573 000052F3 C606[F702]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 24574 000052F8 E83901                          CALL    FIGREC
 24575 000052FB E88A0B                  	call	GETBUFFR
 24576 000052FE 72EA                            jc	short fndclus_retn
 24577                                  
 24578 00005300 C606[0F05]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 24579 00005305 8B36[5005]                      MOV     SI,[NEXTADD]
 24580 00005309 89F7                            MOV     DI,SI
 24581 0000530B 8B0E[6405]                      MOV     CX,[BYTCNT1]
 24582 0000530F 01CF                            ADD     DI,CX
 24583 00005311 893E[5005]                      MOV     [NEXTADD],DI
 24584 00005315 C43E[7405]                      LES     DI,[CURBUF]
 24585                                  	;or	byte [es:di+5],8
 24586 00005319 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 24587                                  	;lea	di,[di+16]
 24588 0000531E 8D7D10                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 24589 00005321 033E[5E05]                      ADD     DI,[BYTSECPOS]
 24590 00005325 F8                              CLC
 24591 00005326 C3                              retn
 24592                                  
 24593                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 24594                                  
 24595                                  ;---------------------------------------------------------------------------
 24596                                  ;
 24597                                  ; Procedure Name : BUFRD
 24598                                  ;
 24599                                  ; Do a partial sector read via one of the system buffers
 24600                                  ; ES:BP Points to DPB
 24601                                  ; Carry set if error (currently user FAILed to I 24)
 24602                                  ;
 24603                                  ; DS - set to DOSDATA
 24604                                  ;
 24605                                  ;----------------------------------------------------------------------------
 24606                                  
 24607                                  BUFRD:
 24608 00005327 06                              PUSH	ES
 24609 00005328 31C0                            xor	ax, ax			; pre-read sector
 24610 0000532A E8BEFF                          CALL    BUFSEC
 24611 0000532D 7303                            JNC	short BUF_OK
 24612                                  
 24613                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 24614 0000532F 07                              POP	ES
 24615 00005330 EB29                            JMP     SHORT RBUFPLACED
 24616                                  
 24617                                  BUF_OK:
 24618 00005332 8CC3                            MOV     BX,ES
 24619 00005334 8E06[DC02]                      MOV     ES,[DMAADD+2]
 24620 00005338 8EDB                            MOV     DS,BX
 24621 0000533A 87FE                    	XCHG    DI,SI
 24622 0000533C D1E9                            SHR     CX,1
 24623                                  ;M039
 24624                                  	; MSDOS 3.3
 24625 0000533E 7301                    	JNC	short EVENRD
 24626 00005340 A4                      	MOVSB
 24627                                  EVENRD:
 24628 00005341 F3A5                    	REP     MOVSW
 24629                                  
 24630                                  ;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
 24631                                  ;       DS:SI-> Source within Buffer.
 24632                                  ;       ES:DI-> Destination within Transfer memory block.
 24633                                  
 24634                                  	; MSDOS 6.0
 24635                                  ;	rep	movsw			;Copy Buffer to Transfer memory.
 24636                                  ;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 24637                                  ;	rep	movsb                   ;Copy last byte.
 24638                                  ;M039
 24639                                  
 24640 00005343 07                              POP	ES
 24641                                  ;hkn; SS override
 24642 00005344 36C53E[7405]                    LDS     DI,[SS:CURBUF]
 24643                                  	;lea	bx,[di+16]
 24644 00005349 8D5D10                  	LEA     BX,[DI+BUFINSIZ]
 24645 0000534C 29DE                            SUB     SI,BX                   ; Position in buffer
 24646 0000534E E88C0A                          call	PLACEBUF
 24647                                  	;cmp	si,[es:bp+2]
 24648 00005351 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 24649 00005355 7203                            JB	short RBUFPLACEDC	; No, leave buf where it is
 24650                                  
 24651                                  ;M039
 24652                                  	; MSDOS 3.3
 24653 00005357 E8E50A                  	call	PLACEHEAD               ; Make it prime candidate for chucking
 24654                                                                          ;  even though it is MRU.
 24655                                          ; MSDOS 6.0
 24656                                  	;MOV	[BufferQueue],DI	; Make it prime candidate for
 24657                                  ;M039					; chucking even though it is MRU.
 24658                                  
 24659                                  RBUFPLACEDC:
 24660 0000535A F8                              CLC
 24661                                  RBUFPLACED:
 24662 0000535B 16                      	push	ss
 24663 0000535C 1F                      	pop	ds
 24664 0000535D C3                              retn
 24665                                  
 24666                                  ;----------------------------------------------------------------------------
 24667                                  ;
 24668                                  ; Procedure : BUFWRT
 24669                                  ;
 24670                                  ; Do a partial sector write via one of the system buffers
 24671                                  ; ES:BP Points to DPB
 24672                                  ; Carry set if error (currently user FAILed to I 24)
 24673                                  ;
 24674                                  ; DS - set to DOSDATA
 24675                                  ;
 24676                                  ;----------------------------------------------------------------------------
 24677                                  
 24678                                  BUFWRT:
 24679 0000535E A1[5A05]                        MOV     AX,[SECPOS]
 24680                                          ; MSDOS 6.0
 24681                                  	;ADD	AX,1            	; Set for next sector
 24682                                          ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 24683                                          ;ADC	[SECPOS+2],0		;F.C. >32mb	;AN000;
 24684                                          ;MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 24685                                          ;CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 24686                                          ;MOV	AL,1			;F.C. >32mb	;AN000;
 24687                                          ;JA	short NOREAD		;F.C. >32mb	;AN000;
 24688                                          ;JB	short doread		;F.C. >32mb	;AN000;
 24689                                          ;MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 24690                                  	; MSDOS 3.3
 24691 00005361 40                      	INC	AX
 24692 00005362 A3[5A05]                	MOV	[SECPOS],AX ; 09/09/2018
 24693                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24694 00005365 3B06[5C05]                      CMP     AX,[VALSEC]		; Has sector been written before?
 24695 00005369 B001                            MOV     AL,1
 24696 0000536B 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 24697                                  ;doread:
 24698 0000536D 30C0                            XOR     AL,AL
 24699                                  NOREAD:
 24700 0000536F 06                              PUSH	ES
 24701 00005370 E878FF                          CALL    BUFSEC
 24702 00005373 72BA                    	JC	short BUF_IO_FAIL
 24703 00005375 8E1E[DC02]                      MOV     DS,[DMAADD+2]
 24704 00005379 D1E9                            SHR     CX,1
 24705                                  
 24706                                  ;M039
 24707                                  	; MSDOS 3.3
 24708 0000537B 7301                    	JNC     short EVENWRT ; 09/09/2018
 24709 0000537D A4                      	MOVSB
 24710                                  EVENWRT:
 24711 0000537E F3A5                    	REP     MOVSW
 24712                                  
 24713                                  ;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
 24714                                  ;       DS:SI-> Source within Transfer memory block.
 24715                                  ;       ES:DI-> Destination within Buffer.
 24716                                  
 24717                                  	; MSDOS 6.0
 24718                                  	;rep	movsw			;Copy Transfer memory to Buffer.
 24719                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 24720                                  	;rep	movsb                   ;Copy last byte.
 24721                                  ;M039
 24722 00005380 07                              POP	ES
 24723                                  
 24724                                  ;hkn; SS override
 24725 00005381 36C51E[7405]                    LDS     BX,[SS:CURBUF]
 24726                                  
 24727                                  	; MSDOS 6.0
 24728                                          ;TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 24729                                  	;				;LB. if already dirty		  ;AN000;
 24730                                          ;JNZ	short yesdirty5		;LB.  don't increment dirty count ;AN000;
 24731                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 24732                                  	
 24733                                  	;or	byte [bx+5],40h
 24734 00005386 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 24735                                  ;yesdirty5:
 24736                                  	;lea	si,[bx+16]
 24737 0000538A 8D7710                          LEA     SI,[BX+BUFINSIZ]
 24738 0000538D 29F7                            SUB     DI,SI                   ; Position in buffer
 24739                                  ;M039
 24740                                  	; MSDOS 3.3
 24741 0000538F 89FE                    	MOV     SI,DI
 24742 00005391 89DF                    	MOV     DI,BX
 24743 00005393 E8470A                  	call	PLACEBUF
 24744                                  	;cmp	si,[es:bp+2]
 24745 00005396 263B7602                	CMP     SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 24746 0000539A 7203                    	JB	short WBUFPLACED	; No, leave buf where it is
 24747 0000539C E8A00A                  	call	PLACEHEAD               ; Make it prime candidate for chucking
 24748                                                                          ;  even though it is MRU.
 24749                                  	; MSDOS 6.0
 24750                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 24751                                          ;JB	short WBUFPLACED	; No, leave buf where it is
 24752                                          ;MOV	[BufferQueue],BX	; Make it prime candidate for
 24753                                  					; chucking even though it is MRU.
 24754                                  ;M039
 24755                                  
 24756                                  WBUFPLACED:
 24757 0000539F F8                              CLC
 24758 000053A0 16                      	push	ss
 24759 000053A1 1F                      	pop	ds
 24760 000053A2 C3                              retn
 24761                                  
 24762                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 24763                                  ;---------------------------------------------------------------------------
 24764                                  ;
 24765                                  ; Procedure Name : NEXTSEC
 24766                                  ;
 24767                                  ; Compute the next sector to read or write
 24768                                  ; ES:BP Points to DPB
 24769                                  ;
 24770                                  ;---------------------------------------------------------------------------
 24771                                  
 24772                                  NEXTSEC:
 24773 000053A3 F606[0F05]FF            	test	byte [TRANS],0FFh ; -1 
 24774 000053A8 7426                            JZ	short CLRET
 24775                                  
 24776 000053AA A0[0E05]                        MOV     AL,[SECCLUSPOS]
 24777 000053AD FEC0                            INC     AL
 24778                                  	;cmp	al,[es:bp+4]
 24779 000053AF 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 24780 000053B3 7618                            JBE	short SAVPOS
 24781                                  
 24782 000053B5 8B1E[5405]                      MOV     BX,[CLUSNUM]
 24783 000053B9 E87D06                          call	IsEOF
 24784 000053BC 7314                            JAE	short NONEXT
 24785                                  
 24786 000053BE E88F06                          call	UNPACK
 24787 000053C1 720F                            JC	short NONEXT
 24788                                  clusgot:
 24789 000053C3 893E[5405]                      MOV     [CLUSNUM],DI
 24790 000053C7 FF06[5205]                      INC     word [LASTPOS]
 24791 000053CB B000                            MOV     AL,0
 24792                                  SAVPOS:
 24793 000053CD A2[0E05]                        MOV     [SECCLUSPOS],AL
 24794                                  CLRET:
 24795 000053D0 F8                              CLC
 24796 000053D1 C3                              retn
 24797                                  NONEXT:
 24798 000053D2 F9                              STC
 24799 000053D3 C3                              retn
 24800                                  
 24801                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 24802                                  ;----------------------------------------------------------------------------
 24803                                  ;
 24804                                  ; Procedure Name : OPTIMIZE
 24805                                  ;
 24806                                  ; Inputs:
 24807                                  ;       BX = Physical cluster
 24808                                  ;       CX = No. of records
 24809                                  ;       DL = sector within cluster
 24810                                  ;       ES:BP = Base of drives parameters
 24811                                  ;       [NEXTADD] = transfer address
 24812                                  ; Outputs:
 24813                                  ;       AX = No. of records remaining
 24814                                  ;       BX = Transfer address
 24815                                  ;       CX = No. or records to be transferred
 24816                                  ;       DX = Physical sector address            (LOW)
 24817                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 24818                                  ;       DI = Next cluster
 24819                                  ;       [CLUSNUM] = Last cluster accessed
 24820                                  ;       [NEXTADD] updated
 24821                                  ;       Carry set if error (currently user FAILed to I 24)
 24822                                  ; ES:BP unchanged. Note that segment of transfer not set.
 24823                                  ;
 24824                                  ;---------------------------------------------------------------------------
 24825                                  
 24826                                  OPTIMIZE:
 24827 000053D4 52                      	PUSH    DX
 24828 000053D5 53                              PUSH    BX
 24829                                  	;mov	al,[es:bp+4]
 24830 000053D6 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 24831 000053DA FEC0                            INC     AL              ; Number of sectors per cluster
 24832 000053DC 88C4                            MOV     AH,AL
 24833 000053DE 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 24834 000053E0 89CA                            MOV     DX,CX
 24835 000053E2 B90000                          MOV     CX,0
 24836                                  OPTCLUS:
 24837                                  ; AL has number of sectors available in current cluster
 24838                                  ; AH has number of sectors available in next cluster
 24839                                  ; BX has current physical cluster
 24840                                  ; CX has number of sequential sectors found so far
 24841                                  ; DX has number of sectors left to transfer
 24842                                  ; ES:BP Points to DPB
 24843                                  ; ES:SI has FAT pointer
 24844                                  
 24845                                  do_norm3:
 24846 000053E5 E86806                          call	UNPACK
 24847 000053E8 7237                            JC	short OP_ERR
 24848                                  clusgot2:
 24849 000053EA 00C1                    	ADD	CL,AL
 24850 000053EC 80D500                          ADC     CH,0
 24851 000053EF 39D1                            CMP     CX,DX
 24852 000053F1 7333                            JAE	short BLKDON
 24853 000053F3 88E0                            MOV     AL,AH
 24854 000053F5 43                              INC     BX
 24855 000053F6 39DF                            CMP     DI,BX
 24856 000053F8 74EB                            JZ	short OPTCLUS
 24857 000053FA 4B                              DEC     BX
 24858                                  FINCLUS:
 24859 000053FB 891E[5405]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 24860 000053FF 29CA                            SUB     DX,CX           ; Number of sectors still needed
 24861 00005401 52                              PUSH    DX
 24862 00005402 89C8                            MOV     AX,CX
 24863                                  	;mul	word[ES:BP+2]
 24864 00005404 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 24865                                  				; Number of sectors times sector size
 24866 00005408 8B36[5005]                      MOV     SI,[NEXTADD]
 24867 0000540C 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 24868 0000540E A3[5005]                        MOV     [NEXTADD],AX
 24869 00005411 58                              POP     AX              ; Number of sectors still needed
 24870 00005412 5A                              POP     DX              ; Starting cluster
 24871 00005413 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 24872 00005415 011E[5205]                      ADD     [LASTPOS],BX
 24873 00005419 5B                              POP     BX              ; BL = sector postion within cluster
 24874 0000541A E81700                  	call	FIGREC
 24875 0000541D 89F3                            MOV     BX,SI
 24876 0000541F F8                      	CLC
 24877 00005420 C3                              retn
 24878                                  
 24879                                  OP_ERR:
 24880 00005421 83C404                          ADD     SP,4
 24881 00005424 F9                      	STC
 24882 00005425 C3                              retn
 24883                                  
 24884                                  BLKDON:
 24885 00005426 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 24886 00005428 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 24887 0000542A FECC                            DEC     AH              ; Adjust to mean position within cluster
 24888 0000542C 8826[0E05]                      MOV     [SECCLUSPOS],AH
 24889 00005430 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 24890 00005432 EBC7                            JMP     SHORT FINCLUS
 24891                                  
 24892                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 24893                                  ;---------------------------------------------------------------------------
 24894                                  ;
 24895                                  ; Procedure Name : FIGREC
 24896                                  ;
 24897                                  ; Inputs:
 24898                                  ;       DX = Physical cluster number
 24899                                  ;       BL = Sector position within cluster
 24900                                  ;       ES:BP = Base of drive parameters
 24901                                  ; Outputs:
 24902                                  ;       DX = physical sector number           (LOW)
 24903                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 24904                                  ; No other registers affected.
 24905                                  ;
 24906                                  ;---------------------------------------------------------------------------
 24907                                  
 24908                                  FIGREC:
 24909 00005434 51                              PUSH    CX
 24910                                  	;mov	cl,[es:bp+5]
 24911 00005435 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 24912 00005439 4A                              DEC     DX
 24913 0000543A 4A                              DEC     DX
 24914                                  
 24915                                  ;hkn; SS override HIGH_SECTOR
 24916                                  	; MSDOS 6.0
 24917                                  	;MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 24918                                  	;OR	CL,CL				;F.C. >32mb
 24919                                  	;JZ	short noshift			;F.C. >32mb
 24920                                  	;XOR	CH,CH 				;F.C. >32mb
 24921                                  ;rotleft:					;F.C. >32mb
 24922                                  	;CLC					;F.C. >32mb
 24923                                  	;RCL	DX,1				;F.C. >32mb
 24924                                  	;RCL	word [HIGH_SECTOR],1		;F.C. >32mb
 24925                                  	;LOOP	rotleft				;F.C. >32mb
 24926                                  ;noshift:
 24927                                  
 24928                                  	; MSDOS 3.3
 24929 0000543B D3E2                    	SHL     DX,CL
 24930                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24931 0000543D 08DA                            OR      DL,BL
 24932                                  	;add	dx,[es:bp+0Bh]
 24933 0000543F 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 24934                                  	; MSDOS 6.0
 24935                                          ;ADC	word [HIGH_SECTOR],0		;F.C. >32mb
 24936                                  	; MSDOS 3.3 (& MSDOS 6.0)        
 24937 00005443 59                      	POP     CX
 24938                                  figrec_retn:
 24939 00005444 C3                              retn
 24940                                  
 24941                                  ; 30/07/2018 - Retro DOS v3.0
 24942                                  ; IBMDOS.COM (MSDOS3.3, 1987) - Offset 
 24943                                  
 24944                                  ;Break   <ALLOCATE -- Assign disk space>
 24945                                  ;---------------------------------------------------------------------------
 24946                                  ;
 24947                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 24948                                  ;
 24949                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 24950                                  ;   FAT-chained onto the end of the existing file.
 24951                                  ;
 24952                                  ;   The DPB contains the cluster # of the last free cluster allocated
 24953                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 24954                                  ;   numbered clusters, looking for the necessary free blocks.
 24955                                  ;
 24956                                  ;   Once again, fancy terminology gets in the way of corrct coding. When
 24957                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 24958                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 24959                                  ;
 24960                                  ;       If we get to the end of the disk without satisfaction:
 24961                                  ;
 24962                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 24963                                  ;               return (insufficient_disk_space)
 24964                                  ;           ELSE
 24965                                  ;               dpb_next_free = 2; start scan over from the beginning.
 24966                                  ;
 24967                                  ;   Note that there is no multitasking interlock. There is no race when
 24968                                  ;   examining the entrys in an in-core FAT block since there will be no
 24969                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 24970                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 24971                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 24972                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 24973                                  ;   satisfied. We can't allow another activation to think this cluster is
 24974                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 24975                                  ;   allocated.
 24976                                  ;
 24977                                  ;   Note that when we run out of space this algorithem will scan from
 24978                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 24979                                  ;   redundantly scanning the later part of the disk. This only happens when
 24980                                  ;   we run out of space, so sue me.
 24981                                  ;
 24982                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 24983                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 24984                                  ;                                                                          ;
 24985                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 24986                                  ;   explanation:
 24987                                  ;
 24988                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 24989                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 24990                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 24991                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 24992                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 24993                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 24994                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 24995                                  ;   the
 24996                                  ;           LOOP   findfre         ; alloc more if needed
 24997                                  ;   instruction when the first cluster is allocated to the nul file. The
 24998                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 24999                                  ;
 25000                                  ;   This method is obviously useless (because it is non-reentrant) for
 25001                                  ;   multitasking, and will have to be changed. Storing the required value on
 25002                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 25003                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 25004                                  ;   problems with INT 24 well.
 25005                                  ;
 25006                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 25007                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 25008                                  ;                                                                          ;
 25009                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 25010                                  ;               CX = No. of clusters to allocate
 25011                                  ;               ES:BP = Base of drive parameters
 25012                                  ;               [THISSFT] = Points to SFT
 25013                                  ;
 25014                                  ;       EXIT    'C' set if insufficient space
 25015                                  ;                 [FAILERR] can be tested to see the reason for failure
 25016                                  ;                 CX = max. no. of clusters that could be added to file
 25017                                  ;               'C' clear if space allocated
 25018                                  ;                 BX = First cluster allocated
 25019                                  ;                 FAT is fully updated
 25020                                  ;                 sf_FIRCLUS field of SFT set if file was null
 25021                                  ;
 25022                                  ;       USES    ALL but SI, BP
 25023                                  
 25024                                  ;callmagic  proc near
 25025                                  ;       push    ds                             ;push segment of routine 
 25026                                  ;       push    Offset MagicPatch              ;push offset for routine
 25027                                  ;       retf                                   ;simulate jmp far
 25028                                  ;                                              ;far return address is on
 25029                                  ;                                              ;stack, so far return from
 25030                                  ;                                              ;call will return this routine
 25031                                  ;callmagic  endp
 25032                                  
 25033                                  ALLOCATE:
 25034                                  	; 10/09/2018
 25035                                  ;BEGIN MAGICDRV MODIFICATIONS
 25036                                  ;
 25037                                  ;7/5/92 scottq
 25038                                  ;
 25039                                  ;This is the disk compression patch location which allows
 25040                                  ;the disk compression software to fail allocations if the
 25041                                  ;FAT would allows allocation, but the free space for compressed
 25042                                  ;data would not.
 25043                                  ;        
 25044                                  ;;;	call    far ptr MAGICPATCH
 25045                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 25046                                  ;;; but we do know the segment and offset of the routine
 25047                                  ;;; so simulate a far call to dosdata:magicpatch
 25048                                  ;;; note dosassume above, so DS -> dosdata
 25049                                  
 25050                                  	; MSDOS 6.0
 25051                                          ;clc				;clear carry so we fall through
 25052                                  	;				;if no patch is present
 25053                                  	;push	cs			;push segment for far return
 25054                                          ;call	callmagic		;this is a near call
 25055                                          ;jnc	short Regular_Allocate_Path
 25056                                  	;jmp	Disk_Full_Return
 25057                                  
 25058                                  	; MSDOS 6.0
 25059                                          ;clc				;clear carry so we fall through
 25060                                  	;				;if no patch is present
 25061                                  	;push	cs			;push segment for far return
 25062                                          ;call	callmagic		;this is a near call
 25063                                          ;jnc	short Regular_Allocate_Path
 25064                                  	;jmp	Disk_Full_Return ; 10/09/2018 !
 25065                                  
 25066                                  ;Regular_Allocate_Path:
 25067                                  ;END MAGICDRV MODIFICATIONS
 25068                                  
 25069 00005445 53                              PUSH    BX                      ; save (bx)
 25070 00005446 31DB                            XOR     BX,BX
 25071 00005448 E80506                  	call	UNPACK
 25072 0000544B 893E[2E05]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 25073 0000544F 5B                              POP     BX
 25074 00005450 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 25075                                  
 25076 00005452 51                              PUSH    CX
 25077 00005453 53                              PUSH    BX
 25078                                  
 25079 00005454 89DA                            MOV     DX,BX
 25080                                  	;mov	bx,[es:bp+1Ch]
 25081 00005456 268B5E1C                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 25082 0000545A 83FB02                          cmp     bx,2
 25083 0000545D 7709                            ja	short FINDFRE
 25084                                  
 25085                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 25086                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 25087                                  
 25088                                  ads1:
 25089                                  	;mov	word [es:bp+1Ch],2
 25090 0000545F 26C7461C0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 25091 00005465 BB0100                          mov     bx,1                    ; Counter next instruction so first
 25092                                                                          ;       cluster examined is 2
 25093                                  
 25094                                  ;   Scanning both forwards and backwards for a free cluster
 25095                                  ;
 25096                                  ;       (BX) = forwards scan pointer
 25097                                  ;       (CX) = clusters remaining to be allocated
 25098                                  ;       (DX) = current last cluster in file
 25099                                  ;       (TOS) = last cluster of file
 25100                                  
 25101                                  FINDFRE:
 25102 00005468 43                              INC     BX
 25103                                  	;cmp	bx,[es:bp+0Dh]
 25104 00005469 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 25105 0000546D 7757                    	ja	short ads7	; at end of disk
 25106 0000546F E8DE05                          call	UNPACK          ; check out this cluster
 25107 00005472 722F                            jc	short ads4	; FAT error             [INTERR?]
 25108 00005474 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 25109                                  
 25110                                  ;   Have found a free cluster. Chain it to the file
 25111                                  ;
 25112                                  ;       (BX) = found free cluster #
 25113                                  ;       (DX) = current last cluster in file
 25114                                  
 25115                                  	;mov	[es:bp+1Ch],bx
 25116 00005476 26895E1C                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 25117 0000547A 92                              xchg    ax,dx           ; save (dx) in ax
 25118 0000547B BA0100                          mov     dx,1            ; mark this free guy as "1"
 25119 0000547E E81806                  	call	PACK            ; set special "temporary" mark
 25120 00005481 7220                            jc	short ads4	; FAT error             [INTERR?]
 25121                                  	;cmp	word [es:bp+1Eh],-1
 25122 00005483 26837E1EFF                      CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 25123 00005488 7404                            JZ	short NO_ALLOC	; No
 25124                                  	;dec	word [es:bp+1Eh]
 25125 0000548A 26FF4E1E                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 25126                                  NO_ALLOC:
 25127 0000548E 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 25128 0000548F 87DA                            XCHG    BX,DX
 25129 00005491 89D0                            MOV     AX,DX
 25130 00005493 E80306                  	call	PACK            ; link free cluster onto file
 25131                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 25132                                                                  ;    cluster 0 with FIRCLUS value.
 25133 00005496 720B                            jc	short ads4	; FAT error [INTERR?]
 25134 00005498 93                              xchg    BX,AX           ; (BX) = last one we looked at
 25135 00005499 89DA                            mov     dx,bx           ; (dx) = current end of file
 25136 0000549B E2CB                            LOOP    FINDFRE         ; alloc more if needed
 25137                                  
 25138                                  ;   We've successfully extended the file. Clean up and exit
 25139                                  ;
 25140                                  ;       (BX) = last cluster in file
 25141                                  
 25142 0000549D BAFFFF                          MOV     DX,0FFFFH
 25143 000054A0 E8F605                  	call	PACK            ; mark last cluster EOF
 25144                                  
 25145                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 25146                                  ;   2 whole bytes.  Hope its worth it...
 25147                                  ;
 25148                                  ;       'C' set iff error
 25149                                  ;       calling (BX) and (CX) pushed on stack
 25150                                  
 25151                                  ads4:   
 25152 000054A3 5B                      	POP     BX
 25153 000054A4 59                              POP     CX              ; Don't need this stuff since we're successful
 25154 000054A5 729D                            jc	short figrec_retn
 25155 000054A7 E8A605                          call	UNPACK          ; Get first cluster allocated for return
 25156                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 25157 000054AA 7298                            jc	short figrec_retn
 25158 000054AC E82D00                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 25159 000054AF 7293                            jc	short figrec_retn
 25160 000054B1 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 25161 000054B3 09FF                            OR      DI,DI           ; clear 'C'
 25162 000054B5 758D                    	jnz	short figrec_retn ; we were extending an existing file
 25163                                  
 25164                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 25165                                  ;   info
 25166                                  dofastk:
 25167 000054B7 06                              PUSH	ES
 25168 000054B8 C43E[3605]                      LES     DI,[THISSFT]
 25169                                  	;mov	[es:di+0Bh],bx
 25170 000054BC 26895D0B                        MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 25171                                  	;mov	[es:di+1Bh],bx
 25172 000054C0 26895D1B                        MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 25173 000054C4 07                              POP	ES
 25174 000054C5 C3                              retn
 25175                                  
 25176                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 25177                                  ;   of the disk...
 25178                                  
 25179                                  ads7:   
 25180 000054C6 26837E1C02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 25181 000054CB 7592                    	jnz	short ads1	; start scan from front of disk
 25182                                  
 25183                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 25184                                  ;   the space back to the free list and tell the caller how much he could have
 25185                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 25186                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 25187                                  ;
 25188                                  ;       (CX) = clusters remaining to be allocated
 25189                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 25190                                  ;       (TOS+1) = # of clusters wanted to allocate
 25191                                  
 25192 000054CD 5B                              POP     BX              ; (BX) = last cluster of file
 25193 000054CE BAFFFF                          MOV     DX,0FFFFH
 25194 000054D1 E81A00                  	call	RELBLKS         ; give back any clusters just alloced
 25195 000054D4 58                              POP     AX              ; No. of clusters requested
 25196                                                                  ; Don't "retc". We are setting Carry anyway,
 25197                                                                  ;   Alloc failed, so proceed with return CX
 25198                                                                  ;   setup.
 25199 000054D5 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 25200 000054D7 E80200                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 25201                                                                  ;   Alloc failed.
 25202                                  Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 25203                                          ; MSDOS 6.0
 25204                                  	;MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 25205 000054DA F9                              STC
 25206 000054DB C3                              retn
 25207                                  
 25208                                  ;-----------------------------------------------------------------------
 25209                                  ;
 25210                                  ; Procedure Name : RESTFATBYT
 25211                                  ;
 25212                                  ; SEE ALLOCATE CAVEAT
 25213                                  ;       Carry set if error (currently user FAILed to I 24)
 25214                                  ;-----------------------------------------------------------------------
 25215                                  
 25216                                  RESTFATBYT:
 25217 000054DC 53                              PUSH    BX
 25218 000054DD 52                              PUSH    DX
 25219 000054DE 57                              PUSH    DI
 25220 000054DF 31DB                            XOR     BX,BX
 25221 000054E1 8B16[2E05]                      MOV     DX,[FATBYT]
 25222 000054E5 E8B105                  	call	PACK
 25223 000054E8 5F                              POP     DI
 25224 000054E9 5A                              POP     DX
 25225 000054EA 5B                              POP     BX
 25226                                  RELEASE_flush:
 25227 000054EB C3                      	retn
 25228                                  
 25229                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 25230                                  ;---------------------------------------------------------------------------
 25231                                  ;
 25232                                  ; Procedure Name : RELEASE
 25233                                  ;
 25234                                  ; Inputs:
 25235                                  ;       BX = Cluster in file
 25236                                  ;       ES:BP = Base of drive parameters
 25237                                  ; Function:
 25238                                  ;       Frees cluster chain starting with [BX]
 25239                                  ;       Carry set if error (currently user FAILed to I 24)
 25240                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 25241                                  ;
 25242                                  ;-----------------------------------------------------------------------------
 25243                                  
 25244                                  RELEASE:
 25245 000054EC 31D2                            XOR     DX,DX
 25246                                  
 25247                                  	;entry	RELBLKS
 25248                                  RELBLKS:
 25249                                  
 25250                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 25251                                  ;   and free the rest in the chain.
 25252                                  
 25253 000054EE E85F05                  	call	UNPACK
 25254 000054F1 72F8                    	jc	short RELEASE_flush
 25255 000054F3 74F6                    	jz	short RELEASE_flush
 25256 000054F5 89F8                            MOV     AX,DI
 25257 000054F7 52                              PUSH    DX
 25258 000054F8 E89E05                  	call	PACK
 25259 000054FB 5A                              POP     DX
 25260 000054FC 72ED                    	jc	short RELEASE_flush
 25261 000054FE 09D2                            OR      DX,DX
 25262 00005500 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 25263                                  	;cmp	word [es:bp+1Eh],-1
 25264 00005502 26837E1EFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 25265 00005507 7404                            JZ	short NO_DEALLOC	; No
 25266 00005509 26FF461E                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 25267                                  NO_DEALLOC:
 25268 0000550D 89C3                            MOV     BX,AX
 25269 0000550F 48                              dec     ax              ; check for "1"
 25270 00005510 74D9                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 25271 00005512 E82405                  	call	IsEOF
 25272 00005515 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 25273                                  
 25274                                  ;RELEASE_flush:
 25275                                  	; MSDOS 6.0
 25276                                  	;mov	al,[es:bp]
 25277                                  	;;MOV	AL,[ES:BP+DPB.DRIVE]
 25278                                  	;push	si		; FLUSHBUF may trash these and we guarantee
 25279                                  	;push	cx		;  them to be preserved.
 25280                                  	;push	es
 25281                                  	;push	bp
 25282                                  	;call	FLUSHBUF	; commit buffers for this drive
 25283                                  	;pop	bp
 25284                                  	;pop	es
 25285                                  	;pop	cx
 25286                                  	;pop	si
 25287                                  RET12:
 25288 00005517 C3                      	retn
 25289                                  
 25290                                  ;Break	<GETEOF -- Find the end of a file>
 25291                                  ;------------------------------------------------------------------------
 25292                                  ;
 25293                                  ; Procedure Name : GETEOF
 25294                                  ;
 25295                                  ; Inputs:
 25296                                  ;       ES:BP Points to DPB
 25297                                  ;       BX = Cluster in a file
 25298                                  ;       DS = CS
 25299                                  ; Outputs:
 25300                                  ;       BX = Last cluster in the file
 25301                                  ;       Carry set if error (currently user FAILed to I 24)
 25302                                  ; DI destroyed. No other registers affected.
 25303                                  ;
 25304                                  ;--------------------------------------------------------------------------
 25305                                  
 25306                                  GETEOF:
 25307 00005518 E83505                  	call	UNPACK
 25308 0000551B 72FA                            jc	short RET12
 25309 0000551D 53                              PUSH    BX
 25310 0000551E 89FB                            MOV     BX,DI
 25311 00005520 E81605                  	call	IsEOF
 25312 00005523 5B                              POP     BX
 25313 00005524 73F1                            JAE     short RET12
 25314 00005526 89FB                            MOV     BX,DI
 25315 00005528 EBEE                            JMP     short GETEOF
 25316                                  
 25317                                  ;============================================================================
 25318                                  ; FCB.ASM, MSDOS 6.0, 1991
 25319                                  ;============================================================================
 25320                                  ; 30/07/2018 - Retro DOS v3.0
 25321                                  
 25322                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 25323                                  ;	NAME	FCB
 25324                                  
 25325                                  ;**	FCB.ASM -  Low level routines for parsing names into FCBs and analyzing
 25326                                  ;		   filename characters
 25327                                  ;
 25328                                  ;	MakeFcb
 25329                                  ;	NameTrans
 25330                                  ;	PATHCHRCMP
 25331                                  ;	GetLet
 25332                                  ;	UCase
 25333                                  ;	GetLet3
 25334                                  ;	GetCharType
 25335                                  ;	TESTKANJ
 25336                                  ;	NORMSCAN
 25337                                  ;	DELIM
 25338                                  ;
 25339                                  ;	Revision history:
 25340                                  ;
 25341                                  ;		A000  version 4.00  Jan. 1988
 25342                                  ;	
 25343                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 25344                                  
 25345                                  TableLook	EQU -1
 25346                                  
 25347                                  SCANSEPARATOR	EQU	1
 25348                                  DRVBIT		EQU	2
 25349                                  NAMBIT		EQU	4
 25350                                  EXTBIT		EQU	8
 25351                                  
 25352                                  ;
 25353                                  ;----------------------------------------------------------------------------
 25354                                  ;
 25355                                  ; Procedure : MakeFcb
 25356                                  ;
 25357                                  ;----------------------------------------------------------------------------
 25358                                  ;
 25359                                  
 25360                                  MAKEFCB:
 25361                                  ;hkn; SS override
 25362 0000552A 36C606[FA02]00          	MOV	BYTE [SS:SpaceFlag],0
 25363 00005530 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 25364                                  	;test	al,2
 25365 00005532 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 25366 00005534 7504                    	JNZ	short DEFDRV
 25367 00005536 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 25368                                  DEFDRV:
 25369 0000553A 47                      	INC	DI
 25370 0000553B B90800                  	MOV	CX,8
 25371                                  	;test	al,4
 25372 0000553E A804                    	test	AL,NAMBIT	; Use current name fields as default?
 25373 00005540 93                      	XCHG	AX,BX		; Save bits in BX
 25374 00005541 B020                    	MOV	AL," "
 25375 00005543 7404                    	JZ	short FILLB	; If not, go fill with blanks
 25376 00005545 01CF                    	ADD	DI,CX
 25377 00005547 31C9                    	XOR	CX,CX		; Don't fill any
 25378                                  FILLB:
 25379 00005549 F3AA                    	REP	STOSB
 25380 0000554B B103                    	MOV	CL,3
 25381 0000554D F6C308                  	test	BL,EXTBIT	; Use current extension as default
 25382 00005550 7404                    	JZ	short FILLB2
 25383 00005552 01CF                    	ADD	DI,CX
 25384 00005554 31C9                    	XOR	CX,CX
 25385                                  FILLB2:
 25386 00005556 F3AA                    	REP	STOSB
 25387 00005558 91                      	XCHG	AX,CX		; Put zero in AX
 25388 00005559 AB                      	STOSW
 25389 0000555A AB                      	STOSW			; Initialize two words after to zero
 25390 0000555B 83EF10                  	SUB	DI,16		; Point back at start
 25391                                  	;test	bl,1
 25392 0000555E F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 25393 00005561 7409                    	JZ	short SKPSPC
 25394 00005563 E87300                  	CALL	SCANB		; Peel off blanks and tabs
 25395 00005566 E8CA00                  	CALL	DELIM		; Is it a one-time-only delimiter?
 25396 00005569 7504                    	JNZ	short NOSCAN
 25397 0000556B 46                      	INC	SI		; Skip over the delimiter
 25398                                  SKPSPC:
 25399 0000556C E86A00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 25400                                  NOSCAN:
 25401 0000556F E89C00                  	CALL	GETLET
 25402 00005572 7616                    	JBE	short NODRV	; Quit if termination character
 25403 00005574 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 25404 00005577 7511                    	JNZ	short NODRV
 25405 00005579 46                      	INC	SI		; Skip over colon
 25406 0000557A 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 25407 0000557C 7607                    	JBE	short BADDRV	; Drive letter out of range
 25408                                  
 25409 0000557E 50                      	PUSH	AX
 25410 0000557F E8DB13                  	call	GetVisDrv
 25411 00005582 58                      	POP	AX
 25412 00005583 7302                    	JNC	short HAVDRV
 25413                                  
 25414                                  	; MSDOS 6.0
 25415                                  ;hkn; SS override
 25416                                  	;CMP	byte [SS:DrvErr],error_not_DOS_disk
 25417                                  	;				; if not FAT drive ;AN000;
 25418                                  	;JZ	short HAVDRV		; assume ok	   ;AN000;
 25419                                  BADDRV:
 25420 00005585 B2FF                    	MOV	DL,-1
 25421                                  HAVDRV:
 25422 00005587 AA                      	STOSB			; Put drive specifier in first byte
 25423 00005588 46                      	INC	SI
 25424 00005589 4F                      	DEC	DI		; Counteract next two instructions
 25425                                  NODRV:
 25426 0000558A 4E                      	DEC	SI		; Back up
 25427 0000558B 47                      	INC	DI		; Skip drive byte
 25428                                  
 25429                                  	;entry	NORMSCAN
 25430                                  NORMSCAN:
 25431 0000558C B90800                  	MOV	CX,8
 25432 0000558F E81300                  	CALL	GETWORD 	; Get 8-letter file name
 25433 00005592 803C2E                  	CMP	BYTE [SI],"."
 25434 00005595 7507                    	JNZ	short NODOT
 25435 00005597 46                      	INC	SI		; Skip over dot if present
 25436                                  
 25437                                  	; MSDOS6.0
 25438                                  ;hkn; SS override
 25439                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2	;AN000;
 25440                                  	;JZ	short VOLOK				;AN000;
 25441                                  	;MOVSB			; 2nd byte of DBCS	;AN000;
 25442                                  	;MOV	CX,2					;AN000;
 25443                                  	;JMP	SHORT contvol				;AN000;
 25444                                  ;VOLOK:
 25445 00005598 B90300                  	MOV	CX,3		; Get 3-letter extension
 25446                                  contvol:
 25447 0000559B E80D00                  	CALL	MUSTGETWORD
 25448                                  NODOT:
 25449 0000559E 88D0                    	MOV	AL,DL
 25450                                  
 25451                                  	; MSDOS 6.0
 25452                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 25453                                  
 25454 000055A0 C3                      	retn
 25455                                  
 25456                                  NONAM:
 25457 000055A1 01CF                    	ADD	DI,CX
 25458 000055A3 4E                      	DEC	SI
 25459 000055A4 C3                      	retn
 25460                                  
 25461                                  GETWORD:
 25462 000055A5 E86600                  	CALL	GETLET		
 25463 000055A8 76F7                    	JBE	short NONAM	; Exit if invalid character
 25464 000055AA 4E                      	DEC	SI
 25465                                  
 25466                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 25467                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 25468                                  
 25469                                  MUSTGETWORD:
 25470 000055AB E86000                  	CALL	GETLET
 25471                                  
 25472                                  ;	If spaceFlag is set then we allow spaces in a pathname
 25473                                  
 25474                                  ;IF NOT TABLELOOK
 25475 000055AE 7223                    	JB	short FILLNAM
 25476                                  ;ENDIF
 25477 000055B0 750C                    	JNZ	short MustCheckCX
 25478                                  
 25479                                  ;hkn; SS override
 25480 000055B2 36F606[FA02]FF          	test	BYTE [SS:SpaceFlag],0FFh
 25481 000055B8 7419                    	JZ	short FILLNAM
 25482 000055BA 3C20                    	CMP	AL," "
 25483 000055BC 7515                    	JNZ	short FILLNAM
 25484                                  
 25485                                  MustCheckCX:
 25486 000055BE E3EB                    	JCXZ	MUSTGETWORD
 25487 000055C0 49                      	DEC	CX
 25488 000055C1 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 25489 000055C3 7504                    	JNZ	short NOSTAR
 25490 000055C5 B03F                    	MOV	AL,"?"
 25491 000055C7 F3AA                    	REP	STOSB
 25492                                  NOSTAR:
 25493 000055C9 AA                      	STOSB
 25494 000055CA 3C3F                    	CMP	AL,"?"
 25495 000055CC 75DD                    	JNZ	short MUSTGETWORD
 25496 000055CE 80CA01                  	OR	DL,1		; Flag ambiguous file name
 25497 000055D1 EBD8                    	JMP	short MUSTGETWORD
 25498                                  FILLNAM:
 25499 000055D3 B020                    	MOV	AL," "
 25500 000055D5 F3AA                    	REP	STOSB
 25501 000055D7 4E                      	DEC	SI
 25502 000055D8 C3                      	retn
 25503                                  
 25504                                  SCANB:
 25505 000055D9 AC                      	LODSB
 25506 000055DA E86200                  	CALL	SPCHK
 25507 000055DD 74FA                    	JZ	short SCANB
 25508 000055DF 4E                      	DEC	SI
 25509                                  scanb_retn:
 25510 000055E0 C3                      	retn
 25511                                  
 25512                                  ;----------------------------------------------------------------------------
 25513                                  ;
 25514                                  ; Procedure Name : NameTrans
 25515                                  ;
 25516                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 25517                                  ; allow spaces in pathnames
 25518                                  ;
 25519                                  ;   Inputs:	DS:SI points to start of path element
 25520                                  ;   Outputs:	Name1 has unpacked name, uppercased
 25521                                  ;		ES = DOSGroup
 25522                                  ;		DS:SI advanced after name
 25523                                  ;   Registers modified: DI,AX,DX,CX
 25524                                  ;
 25525                                  ;----------------------------------------------------------------------------
 25526                                  
 25527                                  NameTrans:
 25528                                  ;hkn; SS override
 25529 000055E1 36C606[FA02]01          	MOV	BYTE [SS:SpaceFlag],1
 25530 000055E7 16                      	push	ss
 25531 000055E8 07                      	pop	es
 25532                                  
 25533                                  ;hkn; NAME1 is in DOSDATA
 25534 000055E9 BF[E604]                	MOV	DI,NAME1
 25535 000055EC 57                      	PUSH	DI
 25536 000055ED B82020                  	MOV	AX,'  '
 25537 000055F0 B90500                  	MOV	CX,5
 25538 000055F3 AA                      	STOSB
 25539 000055F4 F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 25540 000055F6 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 25541 000055F8 88C2                    	MOV	DL,AL
 25542 000055FA AA                      	STOSB
 25543 000055FB 5F                      	POP	DI
 25544                                  
 25545 000055FC E88DFF                  	CALL	NORMSCAN
 25546                                  
 25547                                  ;hkn; SS override for NAME1
 25548 000055FF 36803E[E604]E5          	CMP	byte [SS:NAME1],0E5H
 25549 00005605 75D9                    	jnz	short scanb_retn
 25550 00005607 36C606[E604]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 25551 0000560D C3                      	retn
 25552                                  
 25553                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 25554                                  
 25555                                  ;----------------------------------------------------------------------------
 25556                                  ;
 25557                                  ; Procedure Names : GetLet, UCase, GetLet3
 25558                                  ;
 25559                                  ; These routines take a character, convert it to upper case, and check
 25560                                  ; for delimiters.  Three different entry points:
 25561                                  ;	GetLet -  DS:[SI] = character to convert
 25562                                  ;	UCase  -  AL = character to convert
 25563                                  ;	GetLet3 - AL = character
 25564                                  ;		  [BX] = translation table to use
 25565                                  ;
 25566                                  ;	Exit (in all cases) : AL = upper case character
 25567                                  ;			      CY set if char is control char other than TAB
 25568                                  ;			      ZF set if char is a delimiter
 25569                                  ;	Uses : AX, flags
 25570                                  ;
 25571                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 25572                                  ; inline version.  Return with carry set is only possible in the inline
 25573                                  ; version.  The table lookup version is the one in use.
 25574                                  ;
 25575                                  ;----------------------------------------------------------------------------
 25576                                  
 25577                                  
 25578                                  ; This entry point has character at [SI]
 25579                                  
 25580                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 25581                                  GETLET:	
 25582 0000560E AC                      	LODSB
 25583                                  
 25584                                  ; This entry point has character in AL
 25585                                  
 25586                                  	;entry	UCase
 25587                                  UCase:	
 25588                                  	; 09/08/2018
 25589                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 25590                                  _UCase:
 25591 0000560F 53                      	PUSH	BX
 25592 00005610 BB[0A11]                	MOV	BX,FILE_UCASE_TAB+2
 25593                                  
 25594                                  ; Convert the character in AL to upper case
 25595                                  
 25596                                  gl_0:
 25597 00005613 3C61                    	CMP	AL,"a"
 25598 00005615 720E                    	JB	short gl_2	; Already upper case, go check type
 25599 00005617 3C7A                    	CMP	AL,"z"
 25600 00005619 7702                    	JA	short gl_1
 25601 0000561B 2C20                    	SUB	AL,20H		; Convert to upper case
 25602                                  
 25603                                  ; Map European character to upper case
 25604                                  
 25605                                  gl_1:
 25606 0000561D 3C80                    	CMP	AL,80H
 25607 0000561F 7204                    	JB	short gl_2	; Not EuroChar, go check type
 25608 00005621 2C80                    	SUB	AL,80H		; translate to upper case with this index
 25609                                  
 25610                                  	; M048 - Start 
 25611                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 25612                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 25613                                  	; preserve it.
 25614                                  	;
 25615                                  
 25616                                  	;push	ds
 25617                                  	;push	cs
 25618                                  	;pop	ds
 25619                                  
 25620                                  	; 09/08/2018
 25621                                  	;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 25622 00005623 2ED7                    	CS	XLAT
 25623                                  
 25624                                  	;pop	ds
 25625                                  
 25626                                  	; M048 - End
 25627                                  
 25628                                  ; Now check the type
 25629                                  
 25630                                  ;If TableLook
 25631                                  
 25632                                  gl_2:
 25633 00005625 50                      	PUSH	AX
 25634                                  	
 25635                                  	; MSDOS 6.0
 25636                                  	;CALL	GetCharType	; returns type flags in AL
 25637                                  	
 25638                                  	; MSDOS 3.3
 25639 00005626 BB[1613]                	mov	bx,CharType
 25640                                  	; 09/08/2018
 25641                                  	;xlat	byte [cs:bx]
 25642 00005629 2ED7                    	cs	xlat	
 25643                                  
 25644                                  	;test	al,1	
 25645 0000562B A801                    	TEST	AL,FCHK 	; test for normal character
 25646 0000562D 58                      	POP	AX
 25647 0000562E 5B                      	POP	BX
 25648 0000562F C3                      	RETN
 25649                                  
 25650                                  ; This entry has character in AL and lookup table in BX
 25651                                  
 25652                                  	; MSDOS 6.0
 25653                                  ;	;entry GetLet3
 25654                                  GETLET3: ; 10/08/2018
 25655 00005630 53                      	PUSH	BX
 25656 00005631 EBE0                    	JMP	short gl_0
 25657                                  
 25658                                  ;ELSE
 25659                                  ;
 25660                                  ;gl_2:
 25661                                  ;	POP	BX
 25662                                  ;	CMP	AL,"."
 25663                                  ;	retz
 25664                                  ;	CMP	AL,'"'
 25665                                  ;	retz
 25666                                  ;	CALL	PATHCHRCMP
 25667                                  ;	retz
 25668                                  ;	CMP	AL,"["
 25669                                  ;	retz
 25670                                  ;	CMP	AL,"]"
 25671                                  ;	retz
 25672                                  ;ENDIF
 25673                                  
 25674                                  ;---------------------------------------------------------------------
 25675                                  ;
 25676                                  ; DELIM - check if character is a delimiter
 25677                                  ;	Entry : AX = character to check
 25678                                  ;	Exit  : ZF set if character is not a delimiter
 25679                                  ;	Uses  : Flags
 25680                                  ;
 25681                                  ;--------------------------------------------------------------------
 25682                                  
 25683                                  	;entry	DELIM
 25684                                  DELIM:
 25685                                  ;IF TableLook
 25686 00005633 50                      	PUSH	AX
 25687                                  
 25688                                  	; MSDOS 6.0
 25689                                  	;CALL	GetCharType
 25690                                  	
 25691                                  	; MSDOS 3.3
 25692 00005634 53                      	push	bx
 25693 00005635 BB[1613]                	mov	bx,CharType
 25694                                  	;09/08/2018
 25695                                  	;xlat	byte [cs:bx]
 25696 00005638 2ED7                    	cs	xlat
 25697 0000563A 5B                      	pop	bx
 25698                                  
 25699                                  	;test	al,2
 25700 0000563B A802                    	TEST	AL,FDELIM
 25701 0000563D 58                      	POP	AX
 25702 0000563E C3                      	RETN
 25703                                  ;ELSE
 25704                                  ;	CMP	AL,":"
 25705                                  ;	retz
 25706                                  ;
 25707                                  ;	CMP	AL,"<"
 25708                                  ;	retz
 25709                                  ;	CMP	AL,"|"
 25710                                  ;	retz
 25711                                  ;	CMP	AL,">"
 25712                                  ;	retz
 25713                                  ;
 25714                                  ;	CMP	AL,"+"
 25715                                  ;	retz
 25716                                  ;	CMP	AL,"="
 25717                                  ;	retz
 25718                                  ;	CMP	AL,";"
 25719                                  ;	retz
 25720                                  ;	CMP	AL,","
 25721                                  ;	retz
 25722                                  ;ENDIF
 25723                                  
 25724                                  ;-------------------------------------------------------------------------
 25725                                  ;
 25726                                  ;  SPCHK - checks to see if a character is a space or equivalent
 25727                                  ;	Entry : AL = character to check
 25728                                  ;	Exit  : ZF set if character is a space
 25729                                  ;	Uses  : flags
 25730                                  ;
 25731                                  ;-------------------------------------------------------------------------
 25732                                  
 25733                                  	;entry SPCHK
 25734                                  SPCHK:
 25735                                  ;IF TableLook
 25736 0000563F 50                      	PUSH	AX
 25737                                  
 25738                                  	; MSDOS 6.0
 25739                                  	;CALL	GetCharType
 25740                                  	
 25741                                  	; MSDOS 3.3
 25742 00005640 53                      	push	bx
 25743 00005641 BB[1613]                	mov	bx,CharType
 25744                                  	; 09/08/2018
 25745                                  	;xlat	byte [cs:bx]
 25746 00005644 2ED7                    	cs	xlat
 25747 00005646 5B                      	pop	bx
 25748                                  
 25749                                  	;test	al,4
 25750 00005647 A804                    	TEST	AL,FSPCHK
 25751 00005649 58                      	POP	AX
 25752 0000564A C3                      	RETN
 25753                                  ;ELSE
 25754                                  ;	CMP	AL,9		; Filter out tabs too
 25755                                  ;	retz
 25756                                  ;; WARNING! " " MUST be the last compare
 25757                                  ;	CMP	AL," "
 25758                                  ;	return
 25759                                  ;ENDIF
 25760                                  
 25761                                  ; MSDOS 6.0
 25762                                  ;-------------------------------------------------------------------------
 25763                                  ;
 25764                                  ;  GetCharType - return flag bits indicating character type
 25765                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 25766                                  ;	defined above at label CharType.
 25767                                  ;
 25768                                  ;	Entry : AL = character to return type flags for
 25769                                  ;	Exit  : AL = type flags
 25770                                  ;	Uses  : AL, flags
 25771                                  ;
 25772                                  ;-------------------------------------------------------------------------
 25773                                  ;
 25774                                  ;GetCharType:
 25775                                  ;	cmp	al,CharType_last	; beyond end of table?
 25776                                  ;	jae	short gct_90		; return standard value
 25777                                  ;
 25778                                  ;	push	bx
 25779                                  ;	mov	bx,CharType		; load lookup table
 25780                                  ;	shr	al,1			; adjust for half-byte table entry size
 25781                                  ;	;xlat	cs:[bx] 		; get flags
 25782                                  ;	cs	xlat	
 25783                                  ;	pop	bx
 25784                                  ;
 25785                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 25786                                  ; we have to shift the flags down to the low nibble
 25787                                  ;
 25788                                  ;	jnc	short gct_80		; carry clear, no shift needed
 25789                                  ;
 25790                                  ;	shr	al,1			; we want high nibble, shift it down
 25791                                  ;	shr	al,1
 25792                                  ;	shr	al,1
 25793                                  ;	shr	al,1
 25794                                  ;
 25795                                  ;gct_80:
 25796                                  ;	and	al,0Fh			; clear the unused nibble
 25797                                  ;	retn
 25798                                  ;
 25799                                  ;gct_90:
 25800                                  ;	mov	al,0Fh			; set all flags
 25801                                  ;	retn
 25802                                  
 25803                                  ;----------------------------------------------------------------------------
 25804                                  ;
 25805                                  ; Procedure : PATHCHRCMP
 25806                                  ;
 25807                                  ;----------------------------------------------------------------------------
 25808                                  
 25809                                  PATHCHRCMP:
 25810 0000564B 3C2F                    	CMP	AL,'/'
 25811 0000564D 7606                    	JBE	short PathRet
 25812 0000564F 3C5C                    	CMP	AL,'\'
 25813 00005651 C3                      	retn
 25814                                  GotFor:
 25815 00005652 B05C                    	MOV	AL,'\'
 25816 00005654 C3                      	retn
 25817                                  PathRet:
 25818 00005655 74FB                    	JZ	short GotFor
 25819 00005657 C3                      	retn
 25820                                  
 25821                                  
 25822                                  ;============================================================================
 25823                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 25824                                  ;============================================================================
 25825                                  ; 30/07/2018 - Retro DOS v3.0
 25826                                  
 25827                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 25828                                  
 25829                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 25830                                  
 25831                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 25832                                  ;	NAME	IBMCTRLC
 25833                                  
 25834                                  ;**	Low level routines for detecting special characters on CON input,
 25835                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 25836                                  ;	process termination code, and the INT 0 divide overflow handler.
 25837                                  ;
 25838                                  ;	FATAL
 25839                                  ;	FATAL1
 25840                                  ;	reset_environment
 25841                                  ;	DSKSTATCHK
 25842                                  ;	SPOOLINT
 25843                                  ;	STATCHK
 25844                                  ;	CNTCHAND
 25845                                  ;	DIVOV
 25846                                  ;	CHARHARD
 25847                                  ;	HardErr
 25848                                  ;
 25849                                  ;	Revision history:
 25850                                  ;
 25851                                  ;	    AN000	version 4.0   Jan 1988
 25852                                  ;	    A002	PTM    -- dir >lpt3 hangs
 25853                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 25854                                  ;
 25855                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 25856                                  ;	      flags register. In order to return to user normally DOS used to
 25857                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 25858                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 25859                                  ;
 25860                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 25861                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 25862                                  ;	      charhard.
 25863                                  
 25864                                  
 25865                                  	; MSDOS 6.0
 25866                                  ;		public	LowInt23Addr		
 25867                                  ;LowInt23Addr	LABEL	DWORD
 25868                                  ;	DW	offset DOSDATA:LowInt23, 0
 25869                                  ;
 25870                                  ;		public	LowInt24Addr
 25871                                  ;LowInt24Addr	LABEL	DWORD
 25872                                  ;	DW	offset DOSDATA:LowInt24, 0
 25873                                  ;
 25874                                  ;		public	LowInt28Addr
 25875                                  ;LowInt28Addr	LABEL	DWORD
 25876                                  ;	DW	offset DOSDATA:LowInt28, 0
 25877                                  
 25878                                  ;Break	<Checks for ^C in CON I/O>
 25879                                  
 25880                                  ;---------------------------------------------------------------------------
 25881                                  ;
 25882                                  ; Procedure Name : DSKSTATCHK
 25883                                  ;
 25884                                  ; Check for ^C if only one level in
 25885                                  ;
 25886                                  ;---------------------------------------------------------------------------
 25887                                  
 25888                                          ;procedure   DSKSTATCHK,NEAR ; Check for ^C if only one level in
 25889                                  
 25890                                  DSKSTATCHK:        
 25891                                  	;CMP	BYTE [INDOS],1
 25892 00005658 36803E[CF02]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 25893                                  	;retnz			; Do NOTHING
 25894 0000565E 7535                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 25895                                  
 25896 00005660 51                      	PUSH    CX
 25897 00005661 06                              PUSH    ES
 25898 00005662 53                              PUSH    BX
 25899 00005663 1E                              PUSH    DS
 25900 00005664 56                              PUSH    SI
 25901                                          
 25902                                  	;PUSH	CS
 25903                                          ;POP	ES
 25904                                          ;PUSH	CS
 25905                                          ;POP	DS
 25906                                  
 25907 00005665 8CD3                    	MOV	BX, SS		; SS is DOSDATA. ES:BX must be set up
 25908 00005667 8EC3                    	MOV	ES, BX		; for deviocall2
 25909 00005669 8EDB                    	MOV	DS, BX
 25910                                  
 25911                                  	; 09/09/2018
 25912 0000566B C606[3C03]05                    MOV     BYTE [DSKSTCOM],DEVRDND
 25913 00005670 C606[3A03]0E                    MOV     BYTE [DSKSTCALL],DRDNDHL
 25914 00005675 C706[3D03]0000          	mov	word [DSKSTST],0
 25915                                  
 25916 0000567B BB[3A03]                        MOV     BX,DSKSTCALL
 25917 0000567E C536[3200]                      LDS     SI,[BCON]
 25918 00005682 E878F8                          CALL	DEVIOCALL2
 25919                                   	; 15/03/2018
 25920                                  	;test	word [ss:DSKSTST],200h
 25921 00005685 36F706[3D03]0002                TEST    WORD [SS:DSKSTST],STBUI
 25922                                  	;JNZ	SHORT ZRET		; No characters available
 25923                                  	; 30/07/2018
 25924 0000568C 7408                    	jz	short _GotCh
 25925                                  ;ZRET:
 25926 0000568E 30C0                            XOR     AL,AL                   ; Set zero
 25927                                  RET36:
 25928 00005690 5E                              POP     SI
 25929 00005691 1F                              POP     DS
 25930 00005692 5B                              POP     BX
 25931 00005693 07                              POP     ES
 25932 00005694 59                              POP     CX
 25933                                  _RET37:
 25934 00005695 C3                              RETN
 25935                                  
 25936                                  _GotCh:
 25937 00005696 36A0[4703]                      MOV     AL,[SS:DSKCHRET]	; SS override
 25938                                  
 25939 0000569A 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 25940 0000569C 75F2                            JNZ     SHORT RET36
 25941 0000569E 36C606[3C03]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 25942 000056A4 36C606[3A03]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 25943 000056AA 36880E[4703]                    MOV     [SS:DSKCHRET],CL
 25944                                  	; 09/09/2018
 25945 000056AF 36C706[3D03]0000        	MOV	word [SS:DSKSTST],0
 25946 000056B6 36C706[4C03]0100        	MOV	word [SS:DSKSTCNT],1
 25947 000056BD E83DF8                  	CALL	DEVIOCALL2              ; Eat the ^C
 25948 000056C0 5E                              POP     SI
 25949 000056C1 1F                              POP     DS
 25950 000056C2 5B                              POP     BX                      ; Clean stack
 25951 000056C3 07                              POP     ES
 25952 000056C4 59                              POP     CX
 25953 000056C5 E9BF00                          JMP	CNTCHAND ; 10/08/2018
 25954                                  
 25955                                  NOSTOP:
 25956                                  	; MSDOS 6.0
 25957                                  	;CMP	AL,"P"-"@"
 25958                                  	;JNZ	short check_next
 25959                                  				    	; SS override
 25960                                  	;CMP	BYTE [SS:Scan_Flag],0	; ALT_Q ?
 25961                                  	;JZ	short INCHKJ		; no
 25962                                  	;retn
 25963                                  ;check_next:
 25964                                  	;;IF	NOT TOGLPRN
 25965                                  	;CMP	AL,"N"-"@"
 25966                                  	;JZ	short INCHKJ
 25967                                  	;;ENDIF
 25968                                  
 25969                                  	;CMP	AL,"C"-"@"
 25970                                  	;JZ	short INCHKJ
 25971                                  ;check_end:
 25972                                  	;retn
 25973                                  
 25974                                  	; MSDOS 3.3
 25975 000056C8 3C10                            CMP     AL,"P"-"@"  ; cmp al,16	
 25976 000056CA 7405                            JZ	short INCHKJ
 25977                                  
 25978                                  	; 15/04/2018
 25979                                          ;;IF	NOT TOGLPRN
 25980                                          ;CMP	AL,"N"-"@"
 25981                                          ;JZ	SHORT INCHKJ
 25982                                          ;;ENDIF
 25983                                  
 25984 000056CC 3C03                            CMP     AL,"C"-"@"  ; cmp al,3	
 25985 000056CE 7401                            JZ	short INCHKJ
 25986 000056D0 C3                      	RETN
 25987                                  
 25988                                  	; 08/09/2018
 25989                                  INCHKJ:	; 10/08/2018
 25990 000056D1 E98F00                  	JMP	INCHK
 25991                                  
 25992                                  ;----------------------------------------------------------------------------
 25993                                  ;
 25994                                  ; Procedure Name : SpoolInt
 25995                                  ;
 25996                                  ; SpoolInt - signal processes that the DOS is truly idle.  We are allowed to
 25997                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 25998                                  ; the middle of an INT 24.
 25999                                  ;
 26000                                  ;----------------------------------------------------------------------------
 26001                                  
 26002                                  SPOOLINT:
 26003 000056D4 9C                              PUSHF
 26004                                  	; 15/03/2018
 26005 000056D5 36803E[0403]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 26006 000056DB 7414                            JZ      SHORT POPFRET
 26007 000056DD 36803E[CE02]00                  CMP     BYTE [SS:ERRORMODE],0
 26008 000056E3 750C                            JNZ     SHORT POPFRET		;No spool ints in error mode
 26009                                  
 26010                                  	; 30/07/2018
 26011                                  
 26012                                  	; Note that we are going to allow an external program to issue system 
 26013                                  	; calls at this time.  We MUST preserve IdleInt across this.
 26014                                  
 26015                                  
 26016 000056E5 36FF36[0403]            	PUSH	WORD [SS:IDLEINT]
 26017                                   
 26018                                  	; MSDOS 6.0
 26019                                  	;cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 26020                                  	;jne	short do_low_int28	; Y: the int must be done from low mem
 26021                                  	;INT	int_spooler		; N: Execute user int 28 handler
 26022                                  	;jmp	short spool_ret_addr
 26023                                  
 26024                                  ;do_low_int28:
 26025                                  	;call	far [SS:LowInt28Addr]
 26026                                  
 26027                                  ;spool_ret_addr:
 26028                                  
 26029 000056EA CD28                            INT     int_spooler		; INT 28h
 26030                                  
 26031 000056EC 368F06[0403]            	POP	WORD [SS:IDLEINT]
 26032                                  
 26033                                  POPFRET:
 26034 000056F1 9D                              POPF
 26035                                  _RET18:  
 26036 000056F2 C3                      	RETN
 26037                                  
 26038                                  ;----------------------------------------------------------------------------
 26039                                  ;
 26040                                  ; Procedure Name : STATCHK
 26041                                  ;
 26042                                  ;----------------------------------------------------------------------------
 26043                                  
 26044                                  STATCHK:
 26045 000056F3 E862FF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 26046                                                                          ; input redirection
 26047 000056F6 53                              PUSH    BX
 26048 000056F7 31DB                            XOR     BX,BX
 26049 000056F9 E8BAE9                          CALL	GET_IO_SFT
 26050 000056FC 5B                              POP     BX
 26051 000056FD 72F3                            JC      SHORT _RET18
 26052 000056FF B401                            MOV     AH,1
 26053 00005701 E84CF6                          CALL	IOFUNC
 26054 00005704 74CE                            JZ      SHORT SPOOLINT
 26055 00005706 3C13                            CMP     AL,'S'-'@'
 26056 00005708 75BE                            JNZ     SHORT NOSTOP
 26057                                  
 26058                                  	; MSDOS 6.0			; SS override
 26059                                  	;CMP	BYTE [SS:Scan_Flag],0	; AN000; ALT_R ?
 26060                                  	;JNZ	short check_end		; AN000; yes
 26061                                  
 26062 0000570A 30E4                            XOR     AH,AH
 26063 0000570C E841F6                          CALL	IOFUNC                  ; Eat Cntrl-S
 26064 0000570F EB4B                            JMP     SHORT PAUSOSTRT
 26065                                  
 26066                                  PRINTOFF:
 26067                                  PRINTON:
 26068 00005711 36F616[AC02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 26069                                  
 26070                                  	; 30/07/2018 - Retro DOS v3.0
 26071 00005716 53                      	PUSH	BX
 26072 00005717 BB0400                  	MOV	BX,4
 26073 0000571A E899E9                  	call	GET_IO_SFT
 26074 0000571D 5B                      	POP	BX
 26075 0000571E 72D2                    	jc	short _RET18
 26076 00005720 06                      	PUSH	ES
 26077 00005721 57                      	PUSH	DI
 26078 00005722 1E                      	PUSH	DS
 26079 00005723 07                      	POP	ES
 26080 00005724 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 26081                                  	;test	word [es:di+5],800h
 26082 00005726 26F745050008            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 26083 0000572C 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 26084                                  
 26085                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 26086                                  					; See if allowed
 26087 0000572E 50                      	push	ax
 26088 0000572F B82611                  	mov	ax, 1126h
 26089 00005732 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 26090                                  			; Return: CF set on error, AX = error code
 26091                                  			; STACK unchanged
 26092 00005734 58                      	pop	ax
 26093                                  
 26094 00005735 730F                    	JNC	short NORM_PR 		; Echo is OK
 26095                                  
 26096                                  					; SS override
 26097 00005737 36C606[AC02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 26098                                  
 26099                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 26100                                  
 26101 0000573D 50                      	push    ax
 26102 0000573E B82411                  	mov     ax, 1124h
 26103 00005741 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 26104                                  			; ES:DI -> SFT, SS = DOS CS
 26105 00005743 58                      	pop     ax
 26106                                  
 26107 00005744 EB10                    	JMP	SHORT RETP6
 26108                                  
 26109                                  NORM_PR:
 26110 00005746 36803E[AC02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 26111 0000574C 7505                    	JNZ	short PRNOPN
 26112 0000574E E82EF7                  	call	DEV_CLOSE_SFT
 26113 00005751 EB03                    	JMP	SHORT RETP6
 26114                                  
 26115                                  PRNOPN:
 26116 00005753 E822F7                  	call	DEV_OPEN_SFT
 26117                                  RETP6:
 26118 00005756 5F                      	POP	DI
 26119 00005757 07                      	POP	ES
 26120                                  
 26121                                  STATCHK_RETN:
 26122 00005758 C3                              RETN
 26123                                  
 26124                                  PAUSOLP:
 26125 00005759 E878FF                          CALL    SPOOLINT
 26126                                  PAUSOSTRT:
 26127 0000575C B401                            MOV     AH,1
 26128 0000575E E8EFF5                          CALL	IOFUNC
 26129 00005761 74F6                            JZ      SHORT PAUSOLP
 26130                                  INCHK:
 26131 00005763 53                              PUSH    BX
 26132 00005764 31DB                            XOR     BX,BX
 26133 00005766 E84DE9                          CALL	GET_IO_SFT
 26134 00005769 5B                              POP     BX
 26135 0000576A 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 26136 0000576C 30E4                            XOR     AH,AH
 26137 0000576E E8DFF5                          CALL	IOFUNC
 26138                                  	; 30/07/2018
 26139                                  	; MSDOS 3.3
 26140 00005771 3C10                            CMP     AL,'P'-'@' ;cmp al,16
 26141 00005773 750E                            JNZ	SHORT NOPRINT
 26142                                  
 26143 00005775 36803E[8B0F]00          	cmp	byte [SS:SCAN_FLAG],0
 26144 0000577B 7494                    	JZ	SHORT PRINTON	
 26145 0000577D 36C606[8B0F]00          	mov	byte [ss:SCAN_FLAG],0
 26146                                  
 26147                                  	; MSDOS 6.0
 26148                                  	;CMP	AL,"P"-"@"
 26149                                  	;;;;;  7/14/86	ALT_Q key fix
 26150                                  	;JZ	short PRINTON		; no! must be CTRL_P
 26151                                  
 26152                                  NOPRINT:	
 26153                                  	;IF	NOT TOGLPRN
 26154                                  	;CMP	AL,"N"-"@"
 26155                                  	;JZ	short PRINTOFF
 26156                                  	;ENDIF
 26157 00005783 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 26158                                  	;retnz
 26159 00005785 75D1                    	jnz	short STATCHK_RETN
 26160                                  
 26161                                  ;	!! NOTE: FALL THROUGH !!
 26162                                  
 26163                                  ;---------------------------------------------------------------------------
 26164                                  ;
 26165                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 26166                                  ;
 26167                                  ; "^C" and CR/LF is printed.  Then the user registers are restored and the
 26168                                  ; user CTRL-C handler is executed.  At this point the top of the stack has 1)
 26169                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 26170                                  ; processing to continue; 2) the original interrupt return address to the code
 26171                                  ; that performed the function call in the first place.	If the user CTRL-C
 26172                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 26173                                  ; (not IRET) with carry CLEAR.	If carry is SET then an terminate system call
 26174                                  ; is simulated.
 26175                                  ;
 26176                                  ;---------------------------------------------------------------------------
 26177                                  
 26178                                  CNTCHAND:
 26179                                  	; MSDOS 6.0			; SS override
 26180                                  					; AN002; from RAWOUT
 26181                                  	;TEST	word [SS:Dos34_Flag],CTRL_BREAK_FLAG  
 26182                                  	;JNZ	short around_deadlock 	; AN002;
 26183                                  
 26184 00005787 B003                            MOV     AL,3			; Display "^C"
 26185 00005789 E889CC                          CALL	BUFOUT
 26186 0000578C E829CB                          CALL	CRLF
 26187                                  ;around_deadlock:
 26188 0000578F 16                              PUSH    SS
 26189 00005790 1F                              POP     DS
 26190 00005791 803E[0303]00                    CMP     BYTE [CONSWAP],0
 26191 00005796 7403                            JZ      SHORT NOSWAP
 26192 00005798 E847E6                          CALL	SWAPBACK
 26193                                  NOSWAP:
 26194 0000579B FA                      	CLI				; Prepare to play with stack
 26195 0000579C 8E16[2005]              	MOV	SS,[USER_SS]		; User stack now restored
 26196 000057A0 8B26[1E05]              	MOV	SP,[USER_SP]
 26197 000057A4 E83EBE                          CALL	restore_world       ; User registers now restored
 26198                                  
 26199                                  	; 30/07/2018 - Retro DOS v3.0 
 26200                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 26201                                          ; 14/03/2018 - Retro DOS v2.0
 26202 000057A7 2EC606[CF02]00          	MOV     BYTE [CS:INDOS],0	
 26203 000057AD 2EC606[CE02]00                  MOV     BYTE [CS:ERRORMODE],0
 26204 000057B3 2E8926[E002]                    MOV     [CS:ConC_Spsave],SP
 26205 000057B8 F8                      	clc	;30/07/2018
 26206 000057B9 CD23                            INT     int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 26207                                  	;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 26208                                  			; Return: return via RETF 2 with CF set
 26209                                  			; DOS will abort program with errorlevel 0
 26210                                  			; else
 26211                                  			; interrupted DOS call continues
 26212                                  
 26213                                  	; 30/07/2018 
 26214                                  
 26215                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 26216                                  
 26217                                  ; The user has returned to us.	The circumstances we allow are:
 26218                                  ;
 26219                                  ;   IRET	We retry the operation by redispatching the system call
 26220                                  ;   CLC/RETF	POP the stack and retry
 26221                                  ;   ... 	Exit the current process with ^C exit
 26222                                  ;
 26223                                  ; User's may RETURN to us and leave interrupts on. 
 26224                                  ; Turn 'em off just to be sure
 26225                                  
 26226 000057BB FA                      	CLI
 26227                                  
 26228 000057BC 2EA3[E602]              	MOV	[CS:USER_IN_AX],ax	; save the AX
 26229 000057C0 9C                      	PUSHF				; and the flags (maybe new call)
 26230 000057C1 58                      	POP	AX
 26231                                  
 26232                                  ; See if the input stack is identical to the output stack
 26233                                  
 26234 000057C2 2E3B26[E002]                    CMP	SP,[CS:ConC_Spsave]
 26235 000057C7 7507                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 26236                                  
 26237                                  ; Repeat the operation by redispatching the system call.
 26238                                  
 26239                                  ctrlc_repeat:
 26240 000057C9 2EA1[E602]                      MOV     AX,[CS:USER_IN_AX]
 26241                                  	;transfer COMMAND           ; Repeat command otherwise
 26242                                  COMMANDJ:
 26243 000057CD E9DABC                  	JMP	COMMAND
 26244                                  
 26245                                  ; The current SP is NOT the same as the input SP. Presume that he 
 26246                                  ; RETF'd leaving some flags on the stack and examine the input
 26247                                  
 26248                                  ctrlc_try_new:
 26249 000057D0 83C402                  	ADD	SP,2			; pop those flags
 26250                                  	;test	ax,1
 26251 000057D3 A90100                  	TEST	AX,f_Carry		; did he return with carry?
 26252 000057D6 74F1                    	JZ	short ctrlc_repeat	; no carry set, just retry
 26253                                  
 26254                                  	; Well...  time to abort the user.  
 26255                                  	; Signal a ^C exit and use the EXIT system call..
 26256                                  
 26257                                  ctrlc_abort:
 26258                                          ;MOV	AX,(EXIT SHL 8) + 0
 26259 000057D8 B8004C                          MOV	AX, (EXIT*256) + 0  ; 4C00h
 26260 000057DB 2EC606[F902]FF          	mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 26261                                          ;transfer COMMAND	    ; give up by faking $EXIT
 26262                                  	;JMP	SHORT COMMANDJ
 26263 000057E1 E9C6BC                  	JMP	COMMAND
 26264                                  
 26265                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 26266                                  ;----------------------------------------------------------------------------
 26267                                  ;
 26268                                  ; Procedure Name : DIVOV
 26269                                  ;
 26270                                  ; Default handler for division overflow trap
 26271                                  ;
 26272                                  ;----------------------------------------------------------------------------
 26273                                  
 26274                                  DIVOV: 
 26275                                  	; 30/07/2018
 26276                                  	; 07/07/2018 - Retro DOS v3.0
 26277 000057E4 BE[BC12]                	mov	si,DIVMES
 26278 000057E7 2E8B1E[CF12]            	mov	bx,[cs:DivMesLen]
 26279 000057EC 8CC8                    	mov     ax,cs
 26280 000057EE 8ED0                    	mov	ss,ax
 26281 000057F0 BC[0607]                	mov     sp,AUXSTACK
 26282 000057F3 E80200                  	call	RealDivOv
 26283                                  	;call	_outmes ; MSDOS 6.0
 26284 000057F6 EBE0                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 26285                                  
 26286                                  ; 30/07/2018
 26287                                  
 26288                                  ; MSDOS 6.0
 26289                                  ;---------------------------------------------------------------------------
 26290                                  ;
 26291                                  ; Procedure Name : OutMes
 26292                                  ;
 26293                                  ;
 26294                                  ; OutMes: perform message output
 26295                                  ; Inputs:   SS:SI points to message
 26296                                  ;	    BX has message length
 26297                                  ; Outputs:  message to BCON
 26298                                  ;
 26299                                  ;Actually, cs:si points to the message now. The segment address is filled in
 26300                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 26301                                  ;NB. This procedure is called only from DIVOV. -SR
 26302                                  ;
 26303                                  ;---------------------------------------------------------------------------
 26304                                  
 26305                                  ;MSDOS 3.3
 26306                                  ;---------------------------------------------------------------------------
 26307                                  ; RealDivOv: perform actual divide overflow stuff.
 26308                                  ; Inputs:   none
 26309                                  ; Outputs:  message to BCON
 26310                                  ;---------------------------------------------------------------------------
 26311                                  
 26312                                  	; 30/07/2018
 26313                                  	; MSDOS 6.0
 26314                                  ;_OUTMES:
 26315                                  	;MSDOS 3.3
 26316                                  RealDivOv:
 26317                                  	 
 26318                                  	; 07/07/2018 - Retro DOS v3.0
 26319                                          ;Context ES
 26320                                          ;push	ss ; 30/07/2018
 26321 000057F8 0E                      	PUSH	CS			; get ES addressability
 26322 000057F9 07                      	POP	ES
 26323                                          ;Context DS
 26324                                  	;push	ss ; 30/07/2018
 26325 000057FA 0E                      	PUSH	CS			; get DS addressability
 26326 000057FB 1F                      	POP	DS
 26327 000057FC C606[3C03]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 26328 00005801 C606[3A03]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 26329 00005806 C706[3D03]0000                  MOV     WORD [DSKSTST],0
 26330                                  	; BX = [DivMesLen] = 19
 26331 0000580C 891E[4C03]                      MOV     [DSKSTCNT],BX
 26332 00005810 BB[3A03]                        MOV     BX,DSKSTCALL
 26333                                          ;MOV     [DSKCHRET+1],SI	; transfer address (need an EQU)
 26334                                  	; 08/09/2018
 26335 00005813 8936[4803]              	mov	[DEVIOBUF_PTR],si
 26336                                  	; MSDOS 6.0
 26337                                  					; CS is used for string, fill in 
 26338                                  					; segment address 
 26339                                  	;MOV	[DskChRet+3],CS
 26340                                  
 26341 00005817 C536[3200]                      LDS     SI,[BCON]
 26342 0000581B E8DFF6                          CALL	DEVIOCALL2
 26343                                  	; 14/03/2018
 26344                                          ;MOV     WORD [CS:DSKCHRET+1],DEVIOBUF
 26345                                  	; 08/09/2018
 26346 0000581E 2EC706[4803][5E03]      	mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 26347 00005825 2EC706[4C03]0100                MOV     WORD [CS:DSKSTCNT],1
 26348 0000582C C3                              RETN
 26349                                  
 26350                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 26351                                  ;---------------------------------------------------------------------------
 26352                                  ;
 26353                                  ; Procedure Name : CHARHARD
 26354                                  ;
 26355                                  ;
 26356                                  ; Character device error handler
 26357                                  ; Same function as HARDERR
 26358                                  ;
 26359                                  ;---------------------------------------------------------------------------
 26360                                  
 26361                                  CHARHARD:
 26362                                  	; 30/07/2018
 26363                                  	; 08/07/2018 - Retro DOS v3.0
 26364                                  
 26365                                  	; MSDOS 6.0
 26366                                  ;		   			; M024 - start
 26367                                  ;	cmp	byte ptr [ERRORMODE], 0	; Q: are we in the middle of int 24
 26368                                  ;	jne	@f			; Y: allow fail
 26369                                  ;
 26370                                  ;	OR	AH, Allowed_RETRY	; assume ctrl p
 26371                                  ;
 26372                                  ;	test	byte ptr [PFLAG], -1	; Q: has ctrl p been pressed
 26373                                  ;	jnz	ctrlp			; Y: 
 26374                                  ;@@:					; M024 - end
 26375                                  
 26376                                  ; Character device error handler
 26377                                  ; Same function as HARDERR
 26378                                  
 26379                                  	;or	ah,38h
 26380 0000582D 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 26381                                  ;ctrlp:			; SS override for Allowed and EXITHOLD
 26382 00005830 368826[F702]            	mov	[SS:ALLOWED],ah
 26383                                  
 26384                                  	; 15/03/2018
 26385 00005835 368C06[1C05]                    MOV     [SS:EXITHOLD+2],ES
 26386 0000583A 36892E[1A05]                    MOV     [SS:EXITHOLD],BP
 26387 0000583F 56                              PUSH    SI
 26388                                  	;and	di,0FFh
 26389 00005840 81E7FF00                        AND     DI,STECODE
 26390 00005844 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 26391 00005846 E86400                          CALL    FATALC
 26392 00005849 5E                              POP     SI
 26393                                  	;return
 26394 0000584A C3                              RETN
 26395                                  
 26396                                  ;---------------------------------------------------------------------------
 26397                                  ;
 26398                                  ; Procedure Name : HardErr
 26399                                  ;
 26400                                  ; Hard disk error handler. Entry conditions:
 26401                                  ;	DS:BX = Original disk transfer address
 26402                                  ;	DX = Original logical sector number
 26403                                  ;	CX = Number of sectors to go (first one gave the error)
 26404                                  ;	AX = Hardware error code
 26405                                  ;	DI = Original sector transfer count	
 26406                                  ;	ES:BP = Base of drive parameters
 26407                                  ;	[READOP] = 0 for read, 1 for write
 26408                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 26409                                  ; Output:
 26410                                  ;	[FAILERR] will be set if user responded FAIL
 26411                                  ;
 26412                                  ;--------------------------------------------------------------------------
 26413                                  
 26414                                  HARDERR:
 26415                                  	; 30/07/2018
 26416                                  	; 08/07/2018 - Retro DOS v3.0
 26417 0000584B 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 26418                                          ;and	di,0FFh
 26419 0000584C 81E7FF00                	AND     DI,STECODE              ; And off status bits
 26420                                          ;CMP	DI,WRECODE		; Write Protect Error?
 26421                                  	;cmp	di,0
 26422 00005850 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 26423 00005853 750A                            JNZ     short NOSETWRPERR
 26424 00005855 50                              PUSH    AX
 26425                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 26426                                          ;MOV	AL,[ES:BP+0]
 26427 00005856 268A4600                	mov	al,[ES:BP]
 26428                                          	; 15/03/2018
 26429 0000585A 36A2[D002]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 26430 0000585E 58                              POP     AX
 26431                                  NOSETWRPERR:
 26432 0000585F 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 26433 00005861 01C2                            ADD     DX,AX                   ; First sector number to retry
 26434 00005863 52                              PUSH    DX
 26435                                  	; 08/07/2018
 26436                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 26437 00005864 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 26438 00005868 5A                              POP     DX
 26439 00005869 01C3                            ADD     BX,AX                   ; First address for retry
 26440 0000586B 30E4                            XOR     AH,AH                   ; Flag disk section in error
 26441                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 26442 0000586D 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 26443 00005871 721A                            JB      SHORT ERRINT
 26444 00005873 FEC4                            INC     AH                      ; Flag for FAT
 26445                                          ;CMP	DX,[ES:BP+10H] 		; In FAT?
 26446 00005875 263B5610                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]   
 26447 00005879 7308                    	JAE	short TESTDIR 		; No
 26448                                  		 ; Err in FAT must force recomp of freespace
 26449                                  	;mov	word[ES:BP+1Eh],-1
 26450 0000587B 26C7461EFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 26451 00005881 EB0A                    	JMP	SHORT ERRINT
 26452                                  TESTDIR:
 26453 00005883 FEC4                            INC     AH
 26454                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 26455 00005885 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 26456 00005889 7202                            JB      SHORT ERRINT
 26457 0000588B FEC4                            INC     AH                      ; Must be in data area
 26458                                  ERRINT:
 26459 0000588D D0E4                            SHL     AH,1                    ; Make room for read/write bit
 26460 0000588F 360A26[1005]                    OR      AH,[SS:READOP] ; 15/03/2018
 26461                                  
 26462                                  	; 15/08/2018
 26463                                  					; SS override for allowed and EXITHOLD
 26464 00005894 360A26[F702]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 26465                                  
 26466                                          ;entry   FATAL
 26467                                  FATAL:
 26468                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 26469                                          ;MOV	AL,[ES:BP+0]		; Get drive number
 26470 00005899 268A4600                	MOV	AL,[ES:BP]        
 26471                                  
 26472                                  	;entry   FATAL1
 26473                                  FATAL1:  
 26474                                  	; 15/03/2018      
 26475 0000589D 368C06[1C05]            	MOV     [SS:EXITHOLD+2],ES
 26476 000058A2 36892E[1A05]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 26477                                  	;LES	SI,[ES:BP+12H]
 26478 000058A7 26C47612                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 26479 000058AB 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 26480                                  
 26481                                  	; DI has the INT-24-style extended error. We now map the error code 
 26482                                  	; for this into the normalized get extended error set by using the 
 26483                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 26484                                  	; the device returned codes and leave all others beyond the look up 
 26485                                  	; table alone.
 26486                                  
 26487                                  	; 08/07/2018 - Retro DOS v3.0
 26488                                  FATALC:
 26489 000058AD E86701                  	call	SET_I24_EXTENDED_ERROR
 26490                                  	;cmp	di,0Ch
 26491 000058B0 83FF0C                  	CMP	DI,error_I24_gen_failure
 26492 000058B3 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 26493 000058B5 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 26494                                  					;  Only come via GetExtendedError
 26495                                  ;**
 26496                                  ;
 26497                                  ; Entry point used by REDIRector on Network I 24 errors.
 26498                                  ;
 26499                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 26500                                  ;
 26501                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 26502                                  ;     EXITHOLD set for restore of ES:BP.
 26503                                  ;
 26504                                  	;entry	NET_I24_ENTRY
 26505                                  NET_I24_ENTRY:
 26506                                  GOT_RIGHT_CODE:
 26507 000058B8 36803E[CE02]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 26508 000058BE 7404                            JZ	SHORT NoSetFail
 26509 000058C0 B003                    	MOV	AL,3
 26510 000058C2 EB51                    	JMP	short FailRet
 26511                                  NoSetFail:
 26512 000058C4 368926[2205]                    MOV     [SS:CONTSTK],SP		; SS override
 26513 000058C9 16                              PUSH	SS
 26514 000058CA 07                              POP	ES
 26515                                      
 26516                                  	; Wango!!! We may need to free some user state info... In 
 26517                                  	; particular, we may have locked down a JFN for a user and he may 
 26518                                  	; NEVER return to us. Thus,we need to free it here and then 
 26519                                  	; reallocate it when we come back.
 26520                                  
 26521 000058CB 36833E[4205]FF          	CMP	word [SS:SFN],-1
 26522 000058D1 740C                    	JZ	short _NoFree
 26523 000058D3 1E                      	push	ds
 26524 000058D4 56                      	push	si
 26525 000058D5 36C536[4605]            	LDS	SI,[SS:PJFN]
 26526 000058DA C604FF                  	MOV	BYTE [SI],0FFH
 26527 000058DD 5E                      	pop	si
 26528 000058DE 1F                      	pop	ds
 26529                                  
 26530                                  _NoFree:
 26531 000058DF FA                      	CLI
 26532                                  					; Prepare to play with stack
 26533 000058E0 36FE06[CE02]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 26534 000058E5 36FE0E[CF02]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 26535 000058EA 368E16[2005]                    MOV     SS,[SS:USER_SS]
 26536 000058EF 268B26[1E05]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 26537                                  	;int	24h	
 26538 000058F4 CD24                            INT     int_fatal_abort         ; Fatal error interrupt vector, must preserve ES
 26539 000058F6 268926[1E05]                    MOV     [ES:USER_SP],SP         ; restore our stack
 26540 000058FB 268C16[2005]                    MOV     [ES:USER_SS],SS
 26541 00005900 8CC5                            MOV     BP,ES
 26542 00005902 8ED5                            MOV     SS,BP
 26543 00005904 368B26[2205]                    MOV     SP,[SS:CONTSTK]
 26544 00005909 36FE06[CF02]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 26545 0000590E 36C606[CE02]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 26546 00005914 FB                              STI
 26547                                  FailRet:
 26548 00005915 36C42E[1A05]                    LES     BP,[SS:EXITHOLD]
 26549                                  	
 26550                                  	; 08/07/2018
 26551                                  
 26552                                  	; Triage the user's reply.
 26553                                  
 26554 0000591A 3C01                    	CMP	AL,1
 26555 0000591C 7235                    	JB	short CheckIgnore	; 0 => ignore
 26556 0000591E 743D                    	JZ	short CheckRetry	; 1 => retry
 26557 00005920 3C03                    	CMP	AL,3			; 3 => fail
 26558 00005922 7543                    	JNZ	short DoAbort 		; 2, invalid => abort
 26559                                  
 26560                                  	; The reply was fail.  See if we are allowed to fail.
 26561                                  
 26562                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 26563                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 26564                                  	;test	byte [ss:ALLOWED],8
 26565 00005924 36F606[F702]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 26566 0000592A 743B                    	jz	short DoAbort	; No, do abort
 26567                                  DoFail:
 26568 0000592C B003                    	MOV	AL,3		; just in case...
 26569                                  				; AN000;EO. I24 error disabled
 26570                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 26571                                  	;test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 26572                                  	;jnz	short Cleanup 		; AN000;EO. no
 26573                                  	
 26574 0000592E 36FE06[F602]            	inc	byte [SS:FAILERR]	; Tell everybody
 26575                                  
 26576                                  CleanUp:
 26577 00005933 36C606[D002]FF          	MOV	byte [SS:WPERR],-1
 26578 00005939 36833E[4205]FF          	CMP	word [SS:SFN],-1
 26579                                  	;jnz	short CleanUp2
 26580                                  	;retn
 26581 0000593F 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 26582                                  ;CleanUp2:
 26583 00005941 1E                      	push	ds
 26584 00005942 56                      	push	si
 26585 00005943 50                      	push	ax
 26586 00005944 36A1[4205]              	MOV	AX,[ss:SFN]
 26587 00005948 36C536[4605]            	LDS	SI,[ss:PJFN]
 26588 0000594D 8804                    	MOV	[SI],AL
 26589 0000594F 58                      	pop	ax
 26590 00005950 5E                      	pop	si
 26591 00005951 1F                      	pop	ds
 26592                                  Cleanup_retn:
 26593 00005952 C3                      	retn
 26594                                  
 26595                                  	; The reply was IGNORE. See if we are allowed to ignore.
 26596                                  
 26597                                  CheckIgnore:
 26598                                  	;test	byte [ss:ALLOWED],20h
 26599 00005953 36F606[F702]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 26600 00005959 74D1                    	jz	short DoFail			 ; No, do fail
 26601 0000595B EBD6                    	jmp	short CleanUp
 26602                                  
 26603                                  	; The reply was RETRY. See if we are allowed to retry.
 26604                                  
 26605                                  CheckRetry:
 26606                                  	;test	byte [ss:ALLOWED],10h
 26607 0000595D 36F606[F702]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 26608 00005963 74C7                    	jz	short DoFail			; No, do fail
 26609 00005965 EBCC                    	JMP	short CleanUp
 26610                                  
 26611                                  	; The reply was ABORT.
 26612                                  
 26613                                  DoAbort:
 26614 00005967 16                      	push	ss
 26615 00005968 1F                      	pop	ds
 26616                                  
 26617 00005969 803E[0303]00            	CMP	byte [CONSWAP],0
 26618 0000596E 7403                    	JZ	short NOSWAP2
 26619 00005970 E86FE4                  	call	SWAPBACK
 26620                                  NOSWAP2:
 26621                                  	; See if we are to truly abort. If we are in the process of aborting, 
 26622                                  	; turn this abort into a fail.
 26623                                  
 26624                                  	;test	byte [fAborting],0FFh
 26625                                  	;jnz	short DoFail
 26626                                  
 26627 00005973 803E[0503]00            	cmp	byte [fAborting],0
 26628 00005978 75B2                    	JNZ	short DoFail
 26629                                  
 26630                                  	; Set return code
 26631                                  
 26632 0000597A C606[1705]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR
 26633 0000597F 30C0                    	XOR	AL,AL
 26634                                  
 26635                                  	; we are truly aborting the process. Go restore information from 
 26636                                  	; the PDB as necessary.
 26637                                  
 26638 00005981 E93B0B                  	jmp	exit_inner
 26639                                  
 26640                                  ;**
 26641                                  ;
 26642                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 26643                                  ; different, then an old-style return is performed. If they are the same,
 26644                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 26645                                  ; the source of the terminate addresses.
 26646                                  ;
 26647                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 26648                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 26649                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 26650                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 26651                                  ; flag that will indicate that if any abort code is seen, we just continue the
 26652                                  ; operation. In essence, we dis-allow the abort response.
 26653                                  ;
 26654                                  ; output:   none.
 26655                                  ;
 26656                                  	;entry	reset_environment
 26657                                  	
 26658                                  reset_environment:
 26659                                  	; 30/07/2018 - Retro DOS v3.0
 26660                                  	; IBMDOS.COM (MSDOS3.3) - Offset 588Ah 
 26661                                  
 26662                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 26663                                  
 26664 00005984 1E                      	PUSH	DS			; save PDB of process
 26665                                  
 26666                                  	; There are no critical sections in force. Although we may enter 
 26667                                  	; here with critical sections locked down, they are no longer 
 26668                                  	; relevant. We may safely free all allocated resources.
 26669                                  
 26670 00005985 B482                    	MOV	AH,82h
 26671                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 26672                                  	;int	2Ah 	
 26673 00005987 CD2A                    	INT	int_IBM
 26674                                  
 26675                                  					; SS override
 26676 00005989 36C606[0503]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 26677                                  
 26678                                  					; DOS 4.00 doesn't need it
 26679                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 26680                                  					; Allow REDIR to clear some stuff
 26681                                  					; On process exit.
 26682 0000598F B82211                  	mov     ax, 1122h
 26683 00005992 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 26684                                  			; SS = DOS CS
 26685                                  	;mov	al,22h	
 26686 00005994 B022                    	MOV	AL,int_terminate
 26687 00005996 E8C5C2                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 26688                                  
 26689 00005999 59                      	POP	CX			; get ThisPDB
 26690 0000599A 06                      	push	es
 26691 0000599B 53                      	push	bx			; save return address
 26692                                  
 26693 0000599C 368B1E[DE02]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 26694 000059A1 8EDB                    	MOV	DS,BX
 26695 000059A3 A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 26696                                  
 26697                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 26698                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 26699                                  	; is not Exit_keep_process
 26700                                  	
 26701 000059A6 39D8                    	CMP	AX,BX
 26702 000059A8 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 26703 000059AA 39CB                    	CMP	BX,CX
 26704 000059AC 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 26705 000059AE 50                      	PUSH	AX			; save parent
 26706                                  
 26707                                  					; SS override
 26708                                  	;cmp	byte [SS:EXIT_TYPE],3
 26709 000059AF 36803E[1705]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 26710 000059B5 7406                    	JZ	short reset_to_parent 	; keeping this process
 26711                                  
 26712                                  	; We are truly removing a process. Free all allocation blocks 
 26713                                  	; belonging to this PDB
 26714                                  
 26715                                  	;invoke	arena_free_process
 26716 000059B7 E83C0B                  	call	arena_free_process
 26717                                  
 26718                                  	; Kill off remainder of this process. Close file handles and signal 
 26719                                  	; to relevant network folks that this process is dead. Remember that 
 26720                                  	; CurrentPDB is STILL the current process!
 26721                                  
 26722                                  	;invoke	DOS_ABORT
 26723 000059BA E890E0                  	call	DOS_ABORT
 26724                                  
 26725                                  reset_to_parent:
 26726                                  					; SS override
 26727 000059BD 368F06[DE02]            	POP	word [SS:CurrentPDB]	; set up process as parent
 26728                                  
 26729                                  reset_return:				; come here for normal return
 26730                                  	;Context DS			; DS is used to refer to DOSDATA  
 26731 000059C2 16                      	push	ss
 26732 000059C3 1F                      	pop	ds	
 26733                                  
 26734 000059C4 B0FF                    	MOV	AL,-1
 26735                                  
 26736                                  	; make sure that everything is clean In this case ignore any errors, 
 26737                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 26738                                  
 26739                                  	;EnterCrit critDisk
 26740 000059C6 E89AC6                  	call	EcritDisk
 26741                                  	;invoke	FLUSHBUF
 26742 000059C9 E86405                  	call	FLUSHBUF
 26743                                  	;LeaveCrit critDisk
 26744 000059CC E89CC6                  	call	LcritDisk
 26745                                  
 26746                                  	; Decrement open ref. count if we had done a virtual open earlier.
 26747                                  
 26748 000059CF E8C3F8                  	call	CHECK_VIRT_OPEN
 26749 000059D2 FA                      	CLI
 26750 000059D3 C606[CF02]00            	MOV	BYTE [INDOS],0		; Go to known state
 26751 000059D8 C606[D002]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 26752 000059DD C606[0503]00            	MOV	byte [fAborting],0	; let aborts occur
 26753 000059E2 8F06[1A05]              	POP	WORD [EXITHOLD]
 26754 000059E6 8F06[1C05]              	POP	WORD [EXITHOLD+2]
 26755                                  
 26756                                  	; Snake into multitasking... Get stack from CurrentPDB person
 26757                                  
 26758 000059EA 8E1E[DE02]              	MOV	DS,[CurrentPDB]
 26759 000059EE 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 26760 000059F2 8B262E00                	MOV	SP,[PDB.USER_STACK]
 26761                                  
 26762 000059F6 E8ECBB                  	call	restore_world
 26763                                  
 26764                                  	; MSDOS 6.0
 26765                                  	;push	ax			; set up ds, but save ds in TEMPSEG 
 26766                                  	;mov	ax, ds			; and not on stack.
 26767                                  	;getdseg <ds>			; ds -> dosdata
 26768                                  	;mov	TempSeg, ax
 26769                                  	;pop	ax
 26770                                  					; set up ds to DOSDATA
 26771 000059F9 2EA3[1E05]              	MOV	[CS:USER_SP],AX
 26772                                  
 26773 000059FD 58                      	POP	AX			; suck off CS:IP of interrupt...
 26774 000059FE 58                      	POP	AX
 26775 000059FF 58                      	POP	AX
 26776                                  
 26777                                  ; M011 : BEGIN
 26778                                  
 26779                                  	; MSDOS 3.3
 26780                                  ;	MOV	AX,0F202h	; STI
 26781                                  
 26782                                  	; MSDOS 6.0
 26783 00005A00 9F                      	LAHF
 26784 00005A01 86E0                    	XCHG	AH, AL
 26785 00005A03 2402                    	AND	AL, 02
 26786 00005A05 B4F2                    	MOV	AH, 0F2h
 26787                                  
 26788                                  ; M011 : END
 26789                                  
 26790                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26791 00005A07 50                      	PUSH	AX
 26792                                   
 26793 00005A08 2EFF36[1C05]            	PUSH	word [CS:EXITHOLD+2]
 26794 00005A0D 2EFF36[1A05]            	PUSH	word [CS:EXITHOLD]
 26795                                  
 26796 00005A12 2EA1[1E05]              	MOV	AX,[CS:USER_SP]
 26797                                  
 26798                                  	; MSDOS 6.0
 26799                                  	;mov	ds,TempSeg	; restore ds
 26800                                  
 26801 00005A16 CF                      	IRET			; Long return back to user terminate address
 26802                                  
 26803                                  ;---------------------------------------------------------------------------
 26804                                  ;
 26805                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 26806                                  ;
 26807                                  ; This routine handles extended error codes.
 26808                                  ; Input : DI = error code from device
 26809                                  ; Output: All EXTERR fields are set
 26810                                  ;
 26811                                  ;--------------------------------------------------------------------------
 26812                                  
 26813                                  SET_I24_EXTENDED_ERROR:
 26814 00005A17 50                      	PUSH	AX
 26815                                  					; ErrMap24End is in DOSDATA
 26816 00005A18 B8[030E]                	MOV	AX,ErrMap24End
 26817 00005A1B 2D[F30D]                	SUB	AX,ErrMap24
 26818                                  					; Change to dosdata to access 
 26819                                  					; ErrMap24 and EXTERR -SR
 26820                                  	; MSDOS 6.0
 26821                                  	;push	ds
 26822                                  	;getdseg <ds>			; ds ->dosdata
 26823                                  
 26824                                  	; AX is the index of the first unavailable error. Do not translate 
 26825                                  	; if greater or equal to AX.
 26826                                  
 26827 00005A1E 39C7                    	CMP	DI,AX
 26828 00005A20 89F8                    	MOV	AX,DI
 26829 00005A22 7307                    	JAE	short NoTrans
 26830                                  
 26831 00005A24 2E8A85[F30D]            	MOV	AL,[CS:DI+ErrMap24]
 26832 00005A29 30E4                    	XOR	AH,AH
 26833                                  NoTrans:
 26834 00005A2B 2EA3[D202]              	MOV	[CS:EXTERR],AX
 26835                                  	;pop	ds
 26836                                  	;assume	ds:nothing
 26837 00005A2F 58                      	POP	AX
 26838                                  
 26839                                  	; Now Extended error is set correctly. Translate it to get correct 
 26840                                  	; error locus class and recommended action.
 26841                                  
 26842 00005A30 56                      	PUSH	SI
 26843                                  					; ERR_TABLE_24 is in DOSCODE 
 26844 00005A31 BE[A30D]                	MOV	SI,ERR_TABLE_24
 26845 00005A34 E809BD                  	call	CAL_LK			; Set other extended error fields
 26846 00005A37 5E                      	POP	SI
 26847 00005A38 C3                      	retn
 26848                                  
 26849                                  ;============================================================================
 26850                                  ; FAT.ASM, MSDOS 6.0, 1991
 26851                                  ;============================================================================
 26852                                  ; 30/07/2018 - Retro DOS v3.0
 26853                                  
 26854                                  ;	TITLE	FAT - FAT maintenance routines
 26855                                  ;	NAME	FAT
 26856                                  
 26857                                  ;**	FAT.ASM
 26858                                  ;
 26859                                  ;	Low level local device routines for performing disk change sequence,
 26860                                  ;	setting cluster validity, and manipulating the FAT
 26861                                  ;
 26862                                  ;	IsEof
 26863                                  ;	UNPACK
 26864                                  ;	PACK
 26865                                  ;	MAPCLUSTER
 26866                                  ;	FATREAD_SFT
 26867                                  ;	FATREAD_CDS
 26868                                  ;	FAT_operation
 26869                                  ;
 26870                                  ;	Revision history:
 26871                                  ;
 26872                                  ;	  AN000  version Jan. 1988
 26873                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 26874                                  ;
 26875                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 26876                                  ;	       from CL0FATENTRY rather than disk.
 26877                                  ;
 26878                                  
 26879                                  ;Break <IsEOF - check the quantity in BX for EOF>
 26880                                  ;----------------------------------------------------------------------------
 26881                                  ;
 26882                                  ; Procedure Name : IsEOF
 26883                                  ;
 26884                                  ; IsEOF - check the fat value in BX for eof.
 26885                                  ;
 26886                                  ;   Inputs:	ES:BP point to DPB
 26887                                  ;		BX has fat value
 26888                                  ;   Outputs:	JAE eof
 26889                                  ;   Registers modified: none
 26890                                  ;
 26891                                  ;---------------------------------------------------------------------------
 26892                                  
 26893                                  IsEOF:
 26894                                  	;cmp	word [es:bp+0Dh],0FF6h
 26895 00005A39 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 26896 00005A3F 730B                    	JAE	short EOF16			; yes, check for eof there
 26897                                  
 26898                                  ;J.K. 8/27/86
 26899                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 26900                                  ;of any media that has "F0"(Other) as a MediaByte.
 26901                                  ;Hopely, this does not create any side effect for those who may use any value
 26902                                  ;other than "FF8-FFF" as an EOF for their own file.
 26903                                  
 26904 00005A41 81FBF00F                	cmp	bx,0FF0h
 26905 00005A45 7404                    	je	short IsEOF_other
 26906                                  
 26907 00005A47 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 26908                                  IsEOF_other:
 26909 00005A4B C3                      	retn
 26910                                  EOF16:
 26911 00005A4C 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 26912 00005A4F C3                      	retn
 26913                                  
 26914                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 26915                                  ;---------------------------------------------------------------------------
 26916                                  ;
 26917                                  ; Procedur Name : UNPACK
 26918                                  ;
 26919                                  ; Inputs:
 26920                                  ;	BX = Cluster number (may be full 16-bit quantity)
 26921                                  ;	ES:BP = Base of drive parameters
 26922                                  ; Outputs:
 26923                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 26924                                  ;	Zero set means DI=0 (free cluster)
 26925                                  ;	Carry set means error (currently user FAILed to I 24)
 26926                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 26927                                  ;
 26928                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 26929                                  ;
 26930                                  ;----------------------------------------------------------------------------
 26931                                  
 26932                                  UNPACK:
 26933                                  	; MSDOS 6.0			; M014 - Start
 26934                                  	;or	bx, bx			; Q: are we unpacking cluster 0
 26935                                  	;jnz	short up_cont		; N: proceed with normal unpack
 26936                                  	;mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 26937                                  	;or	di,di 			; return z if di=0
 26938                                  	;retn				; done
 26939                                  ;up_cont:				; M014 - End
 26940                                  	;cmp	bx,[es:bp+0Dh]
 26941 00005A50 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 26942 00005A54 7726                    	JA	short HURTFAT
 26943 00005A56 E8B900                  	CALL	MAPCLUSTER
 26944 00005A59 721E                    	jc	short _DoContext
 26945 00005A5B 8B3D                    	MOV	DI,[DI]
 26946 00005A5D 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 26947 00005A5F 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 26948 00005A63 81FEF60F                	CMP	SI,4096-10
 26949 00005A67 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 26950 00005A69 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 26951 00005A6B EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 26952                                  
 26953                                  High12:
 26954 00005A6D D1EF                    	SHR	DI,1
 26955 00005A6F D1EF                    	SHR	DI,1
 26956 00005A71 D1EF                    	SHR	DI,1
 26957 00005A73 D1EF                    	SHR	DI,1
 26958                                  Unpack12:
 26959 00005A75 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 26960                                  _DoContext:
 26961 00005A79 16                      	PUSH	SS
 26962 00005A7A 1F                      	POP	DS
 26963 00005A7B C3                      	retn
 26964                                  
 26965                                  HURTFAT:
 26966                                  	;mov	word [es:bp+1Eh],0FFFFh
 26967 00005A7C 26C7461EFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 26968 00005A82 50                      	PUSH	AX
 26969 00005A83 B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 26970                                  
 26971                                  ;hkn; SS override
 26972 00005A85 36C606[F702]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 26973                                  ;
 26974                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 26975                                  ;
 26976 00005A8B BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 26977 00005A8E E808FE                  	call	FATAL
 26978 00005A91 3C03                    	CMP	AL,3
 26979 00005A93 F8                      	CLC
 26980 00005A94 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 26981 00005A96 F9                      	STC				; User said FAIL
 26982                                  OKU_RET:
 26983 00005A97 58                      	POP	AX
 26984                                  hurtfat_retn:
 26985 00005A98 C3                      	retn
 26986                                  
 26987                                  ;Break	<PACK -- PACK FAT ENTRIES>
 26988                                  ;----------------------------------------------------------------------------
 26989                                  ;
 26990                                  ; Procedure Name : PACK
 26991                                  ;
 26992                                  ; Inputs:
 26993                                  ;	BX = Cluster number
 26994                                  ;	DX = Data
 26995                                  ;	ES:BP = Pointer to drive DPB
 26996                                  ; Outputs:
 26997                                  ;	The data is stored in the FAT at the given cluster.
 26998                                  ;	SI,DX,DI all destroyed
 26999                                  ;	Carry set means error (currently user FAILed to I 24)
 27000                                  ;	No other registers affected
 27001                                  ;
 27002                                  ; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
 27003                                  ;
 27004                                  ;---------------------------------------------------------------------------
 27005                                  
 27006                                  PACK:
 27007                                  	; MSDOS 6.0			; M014 - start
 27008                                  	;or	bx, bx			; Q: are we packing cluster 0
 27009                                  	;jnz	short p_cont		; N: proceed with normal pack
 27010                                  	;mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 27011                                  	;retn				; done
 27012                                  ;p_cont:				; M014 - end
 27013 00005A99 E87600                  	CALL	MAPCLUSTER
 27014 00005A9C 72DB                    	JC	short _DoContext
 27015 00005A9E 8B35                    	MOV	SI,[DI]
 27016 00005AA0 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 27017 00005AA2 51                      	PUSH	CX			; move data to upper 12 bits
 27018 00005AA3 B104                    	MOV	CL,4
 27019 00005AA5 D3E2                    	SHL	DX,CL
 27020 00005AA7 59                      	POP	CX
 27021 00005AA8 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 27022 00005AAB EB14                    	JMP	SHORT PACKIN
 27023                                  ALIGNED:
 27024                                  	;cmp	word [es:bp+0Dh],0FF6h
 27025 00005AAD 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 27026 00005AB3 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 27027 00005AB5 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 27028 00005AB9 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 27029 00005ABD EB02                    	JMP	SHORT PACKIN		; MZ go store
 27030                                  Pack16:
 27031 00005ABF 31F6                    	XOR	SI,SI			; MZ no original data
 27032                                  PACKIN:
 27033 00005AC1 09D6                    	OR	SI,DX
 27034 00005AC3 8935                    	MOV	[DI],SI
 27035                                  
 27036                                  ;hkn; SS override
 27037 00005AC5 36C536[7405]            	LDS	SI,[SS:CURBUF]
 27038                                  	; MSDOS 6.0
 27039                                  	;TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 27040                                  					;LB. if already dirty		  ;AN000;
 27041                                  	;JNZ	short yesdirty6		;LB.  don't increment dirty count ;AN000;
 27042                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 27043                                  	
 27044                                  	;or	byte [si+5],40h
 27045 00005ACA 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 27046                                  ;yesdirty6:				;LB.				  ;AN000;
 27047                                  ;hkn; SS override
 27048 00005ACE 36803E[1305]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 27049                                  ;hkn; SS is DOSDATA
 27050 00005AD4 16                      	push	ss
 27051 00005AD5 1F                      	pop	ds
 27052 00005AD6 74C0                    	jz	short hurtfat_retn	; Carry clear
 27053 00005AD8 50                      	PUSH	AX
 27054 00005AD9 53                      	PUSH	BX
 27055 00005ADA 51                      	PUSH	CX
 27056 00005ADB A1[2805]                	MOV	AX,[CLUSSAVE]
 27057 00005ADE 8E1E[7605]              	MOV	DS,[CURBUF+2]
 27058 00005AE2 83C610                  	ADD	SI,BUFINSIZ  ; add si,16
 27059 00005AE5 8824                    	MOV	[SI],AH
 27060                                  ;hkn; SS is DOSDATA
 27061                                  	;Context DS
 27062 00005AE7 16                      	push	ss
 27063 00005AE8 1F                      	pop	ds	
 27064 00005AE9 50                      	PUSH	AX
 27065                                  	; MSDOS 6.0
 27066                                  	;MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 27067                                  	;MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 27068                                  
 27069 00005AEA 8B16[2A05]              	MOV	DX,[CLUSSEC]
 27070 00005AEE BE0100                  	MOV	SI,1
 27071 00005AF1 30C0                    	XOR	AL,AL
 27072 00005AF3 E89403                  	call	GETBUFFRB
 27073 00005AF6 58                      	POP	AX
 27074 00005AF7 7213                    	JC	short POPP_RET
 27075 00005AF9 C53E[7405]              	LDS	DI,[CURBUF]
 27076                                  	; MSDOS 6.0
 27077                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 27078                                  	;				;LB. if already dirty		  ;AN000;
 27079                                  	;JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 27080                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 27081                                  	
 27082                                  	;or	byte [di+5],40h
 27083 00005AFD 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 27084                                  yesdirty7:
 27085 00005B01 83C710                  	ADD	DI,BUFINSIZ ; add di,16
 27086 00005B04 4F                      	DEC	DI
 27087                                  	;add	di,[es:bp+2]
 27088 00005B05 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 27089 00005B09 8805                    	MOV	[DI],AL
 27090 00005B0B F8                      	CLC
 27091                                  POPP_RET:
 27092 00005B0C 16                      	PUSH	SS
 27093 00005B0D 1F                      	POP	DS
 27094 00005B0E 59                      	POP	CX
 27095 00005B0F 5B                      	POP	BX
 27096 00005B10 58                      	POP	AX
 27097 00005B11 C3                      	retn
 27098                                  
 27099                                  ; 31/07/2018 - Retro DOS v3.0
 27100                                  
 27101                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 27102                                  ;---------------------------------------------------------------------------
 27103                                  ;
 27104                                  ; Procedure Name : MAPCLUSTER
 27105                                  ;
 27106                                  ; Inputs:
 27107                                  ;	ES:BP Points to DPB
 27108                                  ;	BX Is cluster number
 27109                                  ; Function:
 27110                                  ;	Get a pointer to the cluster
 27111                                  ; Outputs:
 27112                                  ;	DS:DI Points to contents of FAT for given cluster
 27113                                  ;	DS:SI Points to start of buffer
 27114                                  ;	Zero Not set if cluster data is in high 12 bits of word
 27115                                  ;	Zero set if cluster data is in low 12 or 16 bits
 27116                                  ;	Carry set if failed.
 27117                                  ; SI is destroyed.
 27118                                  ;
 27119                                  ;---------------------------------------------------------------------------
 27120                                  
 27121                                  MAPCLUSTER:
 27122                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 27123 00005B12 C606[1305]00            	MOV	BYTE [CLUSSPLIT],0
 27124                                  	;SAVE	<AX,BX,CX,DX>
 27125 00005B17 50                      	push	ax
 27126 00005B18 53                      	push	bx
 27127 00005B19 51                      	push	cx
 27128 00005B1A 52                      	push	dx
 27129 00005B1B 89D8                    	MOV	AX,BX			; AX = BX
 27130 00005B1D 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 27131 00005B23 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 27132 00005B25 D1E8                    	SHR	AX,1			; AX = BX/2
 27133                                  Map16:	
 27134                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 27135                                  	;XOR	DI,DI			; >32mb fat ;AN000;
 27136                                  	
 27137 00005B27 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 27138                                  	;ADC	DI,DI			; >32mb fat ;DI is zero before op;AN000;
 27139 00005B29 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 27140                                  
 27141                                  ;IF FastDiv
 27142                                  ;
 27143                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 27144                                  ; case and apply a really fast algorithm to get the desired results
 27145                                  ;
 27146                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 27147                                  ; Fast method takes 39+20*4=119
 27148                                  ;
 27149                                  ; This saves a bunch.
 27150                                  ;
 27151 00005B2D 81F90002                	CMP	CX,512			; 4	Is this 512 byte sector?
 27152 00005B31 750E                    	jne	short _DoDiv		; 4     for no jump
 27153 00005B33 89C2                    	MOV	DX,AX			; 2	get set for remainder
 27154 00005B35 81E2FF01                	AND	DX,512-1		; 4	Form remainder
 27155 00005B39 88E0                    	MOV	AL,AH			; 2     Quotient in formation in AL
 27156                                  	; MDOS 6.0
 27157                                  	;shr	di,1			; 2
 27158                                  	;rcr	al,1			; 2
 27159                                  	; MDOS 3.3
 27160 00005B3B D0E8                    	shr	al,1	
 27161                                  	; MDOS 3.3 (& MSDOS 6.0)
 27162 00005B3D 30E4                    	xor	ah,ah			; 3
 27163 00005B3F EB04                    	jmp	short DivDone		; 16
 27164                                  _DoDiv:
 27165                                  ;ENDIF
 27166                                  	; MSDOS 6.0
 27167                                  	;mov	dx,di			; 2
 27168                                  	; MSDOS 3.3
 27169 00005B41 31D2                    	xor	dx,dx
 27170                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 27171 00005B43 F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 27172                                  ;IF FastDiv
 27173                                  DivDone:
 27174                                  ;ENDIF
 27175 00005B45 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 27176 00005B49 49                      	DEC	CX			; CX is sector size - 1
 27177                                  	;SAVE	<AX,DX,CX>
 27178 00005B4A 50                      	push	ax
 27179 00005B4B 52                      	push	dx
 27180 00005B4C 51                      	push	cx
 27181 00005B4D 89C2                    	MOV	DX,AX
 27182                                  	; MSDOS 6.0
 27183                                  	;MOV	word [HIGH_SECTOR],0 	;F.C. >32mb  low sector #
 27184 00005B4F 30C0                    	XOR	AL,AL
 27185 00005B51 BE0100                  	MOV	SI,1
 27186                                  	;invoke	GETBUFFRB
 27187 00005B54 E83303                  	call	GETBUFFRB
 27188                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 27189 00005B57 59                      	pop	cx
 27190 00005B58 58                      	pop	ax
 27191 00005B59 5A                      	pop	dx
 27192 00005B5A 724B                    	JC	short MAP_POP
 27193 00005B5C C536[7405]              	LDS	SI,[CURBUF]
 27194 00005B60 8D7C10                  	LEA	DI,[SI+BUFINSIZ]  ; [si+16]
 27195 00005B63 01C7                    	ADD	DI,AX
 27196 00005B65 39C8                    	CMP	AX,CX
 27197 00005B67 752B                    	JNZ	short MAPRET
 27198 00005B69 8A05                    	MOV	AL,[DI]
 27199                                  	;Context DS		 	;hkn; SS is DOSDATA
 27200 00005B6B 16                      	push	ss
 27201 00005B6C 1F                      	pop	ds	
 27202 00005B6D FE06[1305]              	INC	BYTE [CLUSSPLIT]
 27203 00005B71 A2[2805]                	MOV	[CLUSSAVE],AL
 27204 00005B74 8916[2A05]              	MOV	[CLUSSEC],DX
 27205                                  	; MSDOS 6.0
 27206                                  	;MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb		;AN000;
 27207 00005B78 42                      	INC	DX
 27208                                  	;MOV	word [HIGH_SECTOR],0	;F.C. >32mb FAT sector <32mb ;AN000;
 27209 00005B79 30C0                    	XOR	AL,AL
 27210 00005B7B BE0100                  	MOV	SI,1
 27211                                  	;invoke	GETBUFFRB
 27212 00005B7E E80903                  	call	GETBUFFRB
 27213 00005B81 7224                    	JC	short MAP_POP
 27214 00005B83 C536[7405]              	LDS	SI,[CURBUF]
 27215 00005B87 8D7C10                  	LEA	DI,[SI+BUFINSIZ]
 27216 00005B8A 8A05                    	MOV	AL,[DI]
 27217                                  	;Context DS			;hkn; SS is DOSDATA
 27218 00005B8C 16                      	push	ss
 27219 00005B8D 1F                      	pop	ds
 27220 00005B8E A2[2905]                	MOV	[CLUSSAVE+1],AL
 27221                                  
 27222                                  ;hkn; CLUSSAVE is in DOSDATA
 27223 00005B91 BF[2805]                	MOV	DI,CLUSSAVE
 27224                                  MAPRET:
 27225                                  	;RESTORE <DX,CX,BX>
 27226 00005B94 5A                      	pop	dx
 27227 00005B95 59                      	pop	cx
 27228 00005B96 5B                      	pop	bx
 27229 00005B97 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 27230 00005B99 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 27231 00005B9F 7302                    	JAE	short MapSet		; MZ no, set flags
 27232 00005BA1 89D8                    	MOV	AX,BX
 27233                                  MapSet:
 27234 00005BA3 A801                    	TEST	AL,1			; set zero flag if not on boundary
 27235                                  	;RESTORE <AX>
 27236 00005BA5 58                      	pop	ax
 27237 00005BA6 C3                      	retn
 27238                                  
 27239                                  MAP_POP:
 27240                                  	;RESTORE <DX,CX,BX,AX>
 27241 00005BA7 5A                      	pop	dx
 27242 00005BA8 59                      	pop	cx
 27243 00005BA9 5B                      	pop	bx
 27244 00005BAA 58                      	pop	ax
 27245 00005BAB C3                      	retn
 27246                                  
 27247                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 27248                                  ;----------------------------------------------------------------------------
 27249                                  ;
 27250                                  ; Procedure Name : FATREAD_SFT
 27251                                  ;
 27252                                  ; Inputs:
 27253                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 27254                                  ;		giving a NET SFT will produce system crashing results).
 27255                                  ;	DS DOSDATA
 27256                                  ; Function:
 27257                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 27258                                  ;	if disk changed.
 27259                                  ;	In other respects, same as FATREAD_CDS.
 27260                                  ;	(note ES:DI destroyed!)
 27261                                  ; Outputs:
 27262                                  ;	Carry set if error (currently user FAILed to I 24)
 27263                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 27264                                  ;	as far as invalidating curdir_ID is concerned.
 27265                                  ;	Since getting a true disk changed on this call is a screw up
 27266                                  ;	anyway, that's the way it goes.
 27267                                  ;
 27268                                  ;---------------------------------------------------------------------------
 27269                                  
 27270                                  FATREAD_SFT:
 27271 00005BAC 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 27272                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 27273 00005BB0 268A4600                	mov	AL,[ES:BP]
 27274 00005BB4 A2[1105]                	MOV	[THISDRV],AL
 27275 00005BB7 E83ABB                  	call	GOTDPB			;Set THISDPB
 27276 00005BBA E87A00                  	CALL	FAT_GOT_DPB
 27277                                  fatread_sft_retn:
 27278 00005BBD C3                      	retn
 27279                                  
 27280                                  ;----------------------------------------------------------------------------
 27281                                  ;
 27282                                  ; Procedure Name : FATREAD_CDS
 27283                                  ;
 27284                                  ; Inputs:
 27285                                  ;	DS:DOSDATA
 27286                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 27287                                  ;		giving a NET or NUL CDS will produce system crashing results).
 27288                                  ; Function:
 27289                                  ;	If disk may have been changed, media is determined and buffers are
 27290                                  ;	flagged invalid. If not, no action is taken.
 27291                                  ; Outputs:
 27292                                  ;	ES:BP = Drive parameter block
 27293                                  ;	THISDPB = ES:BP
 27294                                  ;	THISDRV set
 27295                                  ;	Carry set if error (currently user FAILed to I 24)
 27296                                  ; DS preserved , all other registers destroyed
 27297                                  ;
 27298                                  ;---------------------------------------------------------------------------
 27299                                  
 27300                                  FATREAD_CDS:
 27301 00005BBE 06                      	PUSH	ES
 27302 00005BBF 57                      	PUSH	DI
 27303                                  	;les	bp,[es:di+45h]
 27304 00005BC0 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 27305                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 27306 00005BC4 268A4600                	mov	AL,[ES:BP]
 27307 00005BC8 A2[1105]                	MOV	[THISDRV],AL
 27308 00005BCB E826BB                  	call	GOTDPB			;Set THISDPB
 27309 00005BCE E86600                  	CALL	FAT_GOT_DPB
 27310 00005BD1 5F                      	POP	DI			;Get back CDS pointer
 27311 00005BD2 07                      	POP	ES
 27312 00005BD3 72E8                    	jc	short fatread_sft_retn
 27313 00005BD5 7539                    	JNZ	short NO_CHANGE		;Media NOT changed
 27314                                  
 27315                                  ;	Media changed. We now need to find all CDS structures which use this
 27316                                  ;	DPB and invalidate their ID pointers.
 27317                                  
 27318                                  MED_CHANGE:
 27319 00005BD7 31C0                    	XOR	AX,AX
 27320 00005BD9 48                      	DEC	AX			; AX = -1
 27321 00005BDA 1E                      	PUSH	DS
 27322 00005BDB 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 27323 00005BDF 30ED                    	XOR	CH,CH			; CX is number of structures
 27324                                  	;lds	si,[es:di+45h]
 27325 00005BE1 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 27326                                  
 27327                                  ;hkn; SS override
 27328                                  
 27329                                  ;	Find all CDSs with this DevPtr
 27330                                  ;
 27331                                  ;	(ax) = -1
 27332                                  ;	(ds:si) = DevPtr
 27333                                  
 27334 00005BE5 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 27335                                  frcd20: 
 27336                                  	;test	word [es:di+43h],8000h
 27337 00005BEA 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 27338 00005BF0 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 27339                                  
 27340                                  	; MSDOS 3.3
 27341                                  	;push	es
 27342                                  	;push	di
 27343                                  	;les	di,[es:di+45h]
 27344                                  	;;les	di,[ES:DI+curdir.devptr]
 27345                                  	;call	POINTCOMP
 27346                                  	;pop	di
 27347                                  	;pop	es
 27348                                  	;jnz	short frcd25
 27349                                  
 27350                                  	; MSDOS 6.0
 27351 00005BF2 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 27352 00005BF6 7512                    	jne	short frcd25		; no match
 27353 00005BF8 8CDB                    	mov	bx,ds
 27354 00005BFA 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 27355 00005BFE 750A                    	jne	short frcd25		; CDS not for this drive
 27356                                  
 27357                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27358                                  	;test	[es:di+49h],ax
 27359 00005C00 26854549                	test	[ES:DI+curdir.ID],AX
 27360 00005C04 7404                    	JZ	short frcd25		; If root (0), leave root
 27361                                  	;mov	[es:di+49h],ax
 27362 00005C06 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 27363                                  frcd25:	
 27364                                  	;add	di,81
 27365 00005C0A 83C751                  	ADD	DI,curdir.size		; Point to next CDS
 27366 00005C0D E2DB                    	LOOP	frcd20
 27367 00005C0F 1F                      	POP	DS
 27368                                  NO_CHANGE:
 27369 00005C10 C42E[2405]              	LES	BP,[THISDPB]
 27370 00005C14 F8                      	CLC
 27371 00005C15 C3                      	retn
 27372                                  
 27373                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 27374                                  ;----------------------------------------------------------------------------
 27375                                  ;
 27376                                  ; Procedure Name : FAT_operation
 27377                                  ;
 27378                                  ;----------------------------------------------------------------------------
 27379                                  FAT_operation:
 27380                                  	; 31/07/2018 - Retro DOS v3.0
 27381                                  FATERR:
 27382                                  	;mov	word [es:bp+1Eh],-1
 27383 00005C16 26C7461EFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 27384                                  					; Err in FAT must force recomp of freespace
 27385                                  	;and	di,0FFh
 27386 00005C1C 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 27387                                  	;mov	byte [ALLOWED],18h
 27388 00005C20 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 27389                                  	;mov	ah,1Ah
 27390 00005C25 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 27391 00005C27 A0[1105]                	MOV	AL,[THISDRV]		; Tell which drive
 27392 00005C2A E870FC                  	call	FATAL1
 27393 00005C2D C42E[2405]              	LES	BP,[THISDPB]
 27394 00005C31 3C03                    	CMP	AL,3
 27395 00005C33 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 27396 00005C35 F9                      	STC				; User said FAIL
 27397 00005C36 C3                      	retn
 27398                                  
 27399                                  FAT_GOT_DPB:
 27400                                  	;Context DS			;hkn; SS is DOSDATA
 27401 00005C37 16                      	push	ss			
 27402 00005C38 1F                      	pop	ds
 27403                                  	;mov	al,0Fh
 27404 00005C39 B00F                    	MOV	AL,DMEDHL
 27405                                  	;mov	al,[es:bp+1]
 27406 00005C3B 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 27407 00005C3F A3[0603]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 27408 00005C42 C606[0803]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 27409 00005C47 C706[0903]0000          	MOV	word [DEVCALL_REQSTAT],0
 27410                                  	;mov	al,[es:bp+16h]
 27411 00005C4D 268A4616                	MOV	AL,[ES:BP+DPB.MEDIA]
 27412 00005C51 A2[1303]                	MOV	[CALLMED],AL
 27413 00005C54 06                      	PUSH	ES
 27414 00005C55 1E                      	PUSH	DS
 27415                                  
 27416                                  ;hkn; DEVCALL is in DOSDATA
 27417 00005C56 BB[0603]                	MOV	BX,DEVCALL
 27418                                  	;lds	si,[es:bp+12h]
 27419 00005C59 26C57612                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 27420 00005C5D 07                      	POP	ES			; ES:BX Points to call header
 27421 00005C5E E89CF2                  	call	DEVIOCALL2
 27422                                  	;Context DS		 	;hkn; SS is DOSDATA
 27423 00005C61 16                      	push	ss
 27424 00005C62 1F                      	pop	ds
 27425 00005C63 07                      	POP	ES			; Restore ES:BP
 27426 00005C64 8B3E[0903]              	MOV	DI,[DEVCALL_REQSTAT]
 27427                                  	;test	di,8000h
 27428                                  	;jnz	short FATERR
 27429 00005C68 09FF                    	or	di,di
 27430 00005C6A 78AA                    	js	short FATERR		; have error
 27431 00005C6C 30E4                    	XOR	AH,AH
 27432                                  	;xchg	ah,[es:bp+17h]
 27433 00005C6E 26866617                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 27434 00005C72 A0[1105]                	MOV	AL,[THISDRV]		; Use physical unit number
 27435                                  ; See if we had changed volume id by creating one on the diskette
 27436 00005C75 3806[070A]              	cmp	[VOLCHNG_FLAG],AL
 27437 00005C79 7508                    	jnz	short CHECK_BYT
 27438 00005C7B C606[070A]FF            	mov	byte [VOLCHNG_FLAG],-1
 27439 00005C80 E98800                  	jmp	GOGETBPB		; Need to get device driver to read in
 27440                                  					; new volume label.
 27441                                  CHECK_BYT:
 27442 00005C83 0A26[1403]              	OR	AH,[CALLRBYT]
 27443                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 27444                                  	;JMP	short NEWDSK
 27445 00005C87 785D                    	js	short NEWDSK
 27446                                  
 27447                                  CHECK_ZR:
 27448 00005C89 743D                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 27449 00005C8B F8                      	CLC
 27450 00005C8C C3                      	retn				; If Media not changed (NZ)
 27451                                  
 27452                                  DISK_CHNG_ERR:
 27453 00005C8D 06                      	PUSH	ES
 27454 00005C8E 55                      	PUSH	BP
 27455                                  	;les	bp,[es:bp+12h]
 27456 00005C8F 26C46E12                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 27457                                  	;test	word [es:bp+4],800h
 27458 00005C93 26F746040008            	TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 27459 00005C99 5D                      	POP	BP
 27460 00005C9A 07                      	POP	ES
 27461 00005C9B 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 27462 00005C9D 1E                      	PUSH	DS			; Save buffer pointer for ignore
 27463 00005C9E 57                      	PUSH	DI
 27464 00005C9F 16                      	push	ss			;hkn; SS is DOSDATA
 27465 00005CA0 1F                      	pop	ds
 27466                                  	;mov	byte [ALLOWED],18h
 27467 00005CA1 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 27468 00005CA6 06                      	PUSH	ES
 27469 00005CA7 C43E[1503]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 27470 00005CAB 8C06[D802]              	MOV	[EXTERRPT+2],ES
 27471 00005CAF 07                      	POP	ES
 27472 00005CB0 893E[D602]              	MOV	[EXTERRPT],DI
 27473                                  	;mov	ax,0Fh
 27474 00005CB4 B80F00                  	MOV	AX,error_I24_wrong_disk
 27475 00005CB7 C606[1005]01            	MOV	byte [READOP],1		; Write
 27476                                  	;invoke	HARDERR
 27477 00005CBC E88CFB                  	call	HARDERR
 27478 00005CBF 5F                      	POP	DI			; Get back buffer for ignore
 27479 00005CC0 1F                      	POP	DS
 27480 00005CC1 3C03                    	CMP	AL,3
 27481                                  FAIL_OPJ2:
 27482 00005CC3 7416                    	JZ	short FAIL_OP
 27483 00005CC5 E96FFF                  	JMP	FAT_GOT_DPB		; Retry
 27484                                  
 27485                                  CHKBUFFDIRT:
 27486                                  	; MSDOS 6.0
 27487                                  	;cmp	word [DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 27488                                  	;je	short NEWDSK			; no, skip the check
 27489                                  	;call	GetCurHead			; get pointer to first buffer
 27490                                  
 27491                                  	; MSDOS 3.3
 27492 00005CC8 C53E[3800]              	lds	di,[BUFFHEAD]
 27493                                  nbuffer:
 27494                                  	;cmp	al,[di+4]
 27495 00005CCC 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 27496 00005CCF 750E                    	jne	short lfnxt			; no, go for next buffer
 27497                                  	;test   byte [di+5],40h
 27498 00005CD1 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
 27499 00005CD5 7408                    	jz	short lfnxt			; no, go for next buffer
 27500                                  	;Context DS
 27501 00005CD7 16                      	push	ss
 27502 00005CD8 1F                      	pop	ds
 27503 00005CD9 F8                      	clc
 27504 00005CDA C3                      	retn
 27505                                  
 27506                                  FAIL_OP:					; This label & code is here
 27507                                  	;Context DS				;  for reachability
 27508 00005CDB 16                      	push	ss
 27509 00005CDC 1F                      	pop	ds
 27510 00005CDD F9                      	STC
 27511 00005CDE C3                      	retn
 27512                                  
 27513                                  lfnxt:
 27514                                  	; 15/08/2018
 27515                                  	;mov	di,[di]
 27516                                  	;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 27517                                  	;
 27518 00005CDF C53D                    	lds	di,[di]
 27519                                  	;
 27520                                  	; MSDOS 6.0
 27521                                  	;cmp	[FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 27522                                  	;jne	short nbuffer			; no, check this guy also
 27523                                  	; MSDOS 3.3
 27524 00005CE1 83FFFF                  	cmp	di,-1
 27525 00005CE4 75E6                    	jne	short nbuffer
 27526                                  
 27527                                  ; If no dirty buffers, assume Media changed
 27528                                  NEWDSK:
 27529                                  	;mov	word [es:bp+1Eh],0FFFFh
 27530 00005CE6 26C7461EFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 27531                                  	; MSDOS 6.0				;  recompute
 27532                                  	;call	GetCurHead
 27533                                  	; MSDOS 3.3
 27534 00005CEC E8B500                  	call	SETVISIT
 27535                                  nxbuffer:
 27536                                  	; MSDOS 3.3
 27537 00005CEF 804D0520                	or 	byte [di+5],20h
 27538                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27539                                  	;cmp	[di+4],al
 27540 00005CF3 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 27541 00005CF6 750E                    	jne	short lfnxt2
 27542                                  	;test	byte [di+5],40h
 27543 00005CF8 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 27544 00005CFC 758F                    	jnz	short DISK_CHNG_ERR
 27545                                  	;mov	word [di+4],20FFh
 27546 00005CFE C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 27547 00005D03 E8CB00                  	call	SCANPLACE
 27548                                  	; MSDOS 6.0
 27549                                  	;jmp	short skpbuff
 27550                                  ;lfnxt2:
 27551                                  	;;mov	di,[di+BUFFINFO.buf_next]
 27552                                  	;mov	di,[di]
 27553                                  ;skpbuff:
 27554                                  	;cmp	di,[FIRST_BUFF_ADDR]					;hkn;
 27555                                  	;jne	short nxbuffer
 27556                                  
 27557                                  	;CMP	word [SC_CACHE_COUNT],0	;LB.  look ahead buffers ?	;AN001;
 27558                                  	;JZ	short GOGETBPB		;LB.  no			;AN001;
 27559                                  	;CMP	AL,[CURSC_DRIVE]	;LB.  same as changed drive	;AN001;
 27560                                  	;JNZ	short GOGETBPB		;LB.  no			;AN001;
 27561                                  	;MOV	byte [CURSC_DRIVE],-1	;LB.  invalidate look ahead buffers ;AN000;
 27562                                  lfnxt2:
 27563                                  	; MSDOS 3.3
 27564 00005D06 E8B400                  	call	SKIPVISIT
 27565 00005D09 75E4                    	jnz	short nxbuffer
 27566                                  GOGETBPB:
 27567                                  	;lds	di,[es:bp+12h]
 27568 00005D0B 26C57E12                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 27569                                  	;test	word [di+4],2000h
 27570 00005D0F F745040020              	TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 27571 00005D14 7510                    	JNZ	short GETFREEBUF
 27572                                  	;context DS	    		;hkn; SS is DOSDATA
 27573 00005D16 16                      	push	ss
 27574 00005D17 1F                      	pop	ds
 27575 00005D18 BB0200                  	MOV	BX,2
 27576 00005D1B E832FD                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 27577                                  FAIL_OPJ:
 27578 00005D1E 72BB                    	JC	short FAIL_OP
 27579 00005D20 C53E[7405]              	LDS	DI,[CURBUF]
 27580 00005D24 EB0E                    	JMP	SHORT GOTGETBUF
 27581                                  
 27582                                  GETFREEBUF:
 27583 00005D26 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 27584 00005D27 55                      	PUSH	BP
 27585                                  	; MSDOS 3.3
 27586 00005D28 36C53E[3800]            	LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 27587                                  	; MSDOS 6.0
 27588                                  	;XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 27589                                  ;hkn; SS override
 27590                                  	;MOV	[SS:HIGH_SECTOR],DX	;LB.  buffer addr	  ;AN000;
 27591                                  	;call	GETCURHEAD		;LB.			  ;AN000;
 27592                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27593 00005D2D E84F02                  	call	BUFWRITE
 27594 00005D30 5D                      	POP	BP
 27595 00005D31 07                      	POP	ES
 27596                                  	;JC	short FAIL_OPJ
 27597 00005D32 72A7                    	jc	short FAIL_OP
 27598                                  GOTGETBUF:
 27599                                  	;add	di,16
 27600 00005D34 83C710                  	ADD	DI,BUFINSIZ
 27601                                  
 27602                                  ;hkn; SS override
 27603 00005D37 368C1E[1603]            	MOV	[SS:CALLXAD+2],DS
 27604                                  	;Context DS			;hkn; SS is DOSDATA
 27605 00005D3C 16                      	push	ss
 27606 00005D3D 1F                      	pop	ds
 27607 00005D3E 893E[1403]              	MOV	[CALLXAD],DI
 27608                                  	;mov	al,16h
 27609 00005D42 B016                    	MOV	AL,DBPBHL
 27610                                  	;mov	ah,[es:bp+1]
 27611 00005D44 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 27612 00005D48 A3[0603]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 27613 00005D4B C606[0803]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 27614 00005D50 C706[0903]0000          	MOV	word [DEVCALL_REQSTAT],0
 27615                                  	;mov	al,[es:bp+16h]
 27616 00005D56 268A4616                	MOV	AL,[ES:BP+DPB.MEDIA]
 27617 00005D5A A2[1303]                	MOV	[CALLMED],AL
 27618 00005D5D 06                      	PUSH	ES
 27619 00005D5E 1E                      	PUSH	DS
 27620                                  	;push	word [es:bp+14h]
 27621 00005D5F 26FF7614                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 27622                                  	;push	word [es:bp+12h]
 27623 00005D63 26FF7612                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 27624                                  
 27625                                  ;hkn; DEVCALL is in DOSDATA
 27626 00005D67 BB[0603]                	MOV	BX,DEVCALL
 27627 00005D6A 5E                      	POP	SI
 27628 00005D6B 1F                      	POP	DS			; DS:SI Points to device header
 27629 00005D6C 07                      	POP	ES			; ES:BX Points to call header
 27630                                  	;invoke	DEVIOCALL2
 27631 00005D6D E88DF1                  	call	DEVIOCALL2
 27632 00005D70 07                      	POP	ES			; Restore ES:BP
 27633                                  	;Context DS
 27634 00005D71 16                      	push	ss		 	;hkn; SS is DOSDATA
 27635 00005D72 1F                      	pop	ds
 27636 00005D73 8B3E[0903]              	MOV	DI,[DEVCALL_REQSTAT]
 27637                                  	; MSDOS 3.3
 27638                                  	;test	di,8000h
 27639                                  	;jnz	short FATERRJ
 27640                                  	; MSDOS 6.0
 27641 00005D77 09FF                    	or	di,di
 27642 00005D79 7826                    	js	short FATERRJ 		; have error
 27643                                  	;;mov	al,[es:bp+16h]
 27644 00005D7B 268A4616                	MOV	AL,[ES:BP+DPB.MEDIA]
 27645 00005D7F C536[1803]              	LDS	SI,[CALLBPB]
 27646                                  	;mov	word [es:bp+1Ch],0
 27647 00005D83 26C7461C0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 27648                                  	;invoke	$SETDPB
 27649 00005D89 E8F4BF                  	call	_$SETDPB
 27650                                  
 27651                                  ;hkn; SS override
 27652 00005D8C 36C53E[1403]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 27653                                  	;mov	al,[es:bp+8]
 27654 00005D91 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 27655                                  
 27656                                  	; MSDOS 6.0
 27657                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL ;>32mb		  ;AN000;
 27658                                  	;MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb			  ;AC000;
 27659                                  	;MOV	[DI.buf_wrtcntinc-BUFINSIZ],AX ;>32mb Correct buffer info ;AC000;
 27660                                  
 27661                                  	; MSDOS 3.3
 27662                                  	;mov	ah,[es:bp+0Fh]
 27663 00005D95 268A660F                	MOV	AH,[ES:BP+DPB.FAT_SIZE]
 27664                                  	;mov	[DI-8],ax
 27665 00005D99 8945F8                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 27666                                  
 27667                                  	;Context DS			;hkn; SS is DOSDATA
 27668 00005D9C 16                      	push	ss
 27669 00005D9D 1F                      	pop	ds
 27670 00005D9E 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 27671 00005DA0 C3                      	retn
 27672                                  
 27673                                  FATERRJ: 
 27674 00005DA1 E972FE                  	JMP	FATERR
 27675                                  
 27676                                  
 27677                                  ;============================================================================
 27678                                  ; STDBUF.ASM
 27679                                  ;============================================================================
 27680                                  ; Retro DOS v2.0 - 12/03/2018
 27681                                  
 27682                                  ;
 27683                                  ; Standard buffer management for MSDOS
 27684                                  ;
 27685                                  
 27686                                  ;.xlist
 27687                                  ;.xcref
 27688                                  ;INCLUDE STDSW.ASM
 27689                                  ;.cref
 27690                                  ;.list
 27691                                  
 27692                                  ;TITLE	STDBUF - MSDOS buffer management
 27693                                  ;NAME	STDBUF
 27694                                  
 27695                                  ;INCLUDE BUF.ASM
 27696                                  
 27697                                  ;============================================================================
 27698                                  ; BUF.ASM
 27699                                  ;============================================================================
 27700                                  ; 31/07/2018 - Retro DOS v3.0
 27701                                  ; Retro DOS v2.0 - 12/03/2018
 27702                                  
 27703                                  ;
 27704                                  ; buffer management for MSDOS
 27705                                  ;
 27706                                  
 27707                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 27708                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 27709                                  
 27710                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 27711                                  
 27712                                  SETVISIT:
 27713                                  	; 31/07/2018 - Retro DOS v3.0
 27714                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 27715                                  ; Inputs:
 27716                                  ;       None
 27717                                  ; Function:
 27718                                  ;       Set up a scan of I/O buffers
 27719                                  ; Outputs:
 27720                                  ;       All visit flags = 0
 27721                                  ;               NOTE: This pre-scan is needed because a hard disk error
 27722                                  ;                     may cause a scan to stop in the middle leaving some
 27723                                  ;                     visit flags set, and some not set.
 27724                                  ;       DS:DI Points to [BUFFHEAD]
 27725                                  ; No other registers altered
 27726                                  
 27727 00005DA4 36C53E[3800]                    LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 27728 00005DA9 50                      	PUSH    AX
 27729                                          ;;XOR	AX,AX	  ;; MSDOS 2.11
 27730                                  	;mov	al,0DFh
 27731 00005DAA B0DF                    	mov	al,~buf_visit
 27732                                  SETLOOP:
 27733                                          ;;MOV	[DI+7],AL ;; MSDOS 2.11
 27734                                  	;and	[DI+5],al
 27735 00005DAC 204505                  	AND	[DI+BUFFINFO.buf_flags],AL
 27736 00005DAF C53D                            LDS     DI,[DI]
 27737 00005DB1 83FFFF                          CMP     DI,-1
 27738 00005DB4 75F6                            JNZ     SHORT SETLOOP
 27739 00005DB6 58                              POP     AX ; 09/09/2018
 27740 00005DB7 36C53E[3800]            	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 27741                                  SVISIT_RETN:
 27742 00005DBC C3                              RETN
 27743                                  
 27744                                  SKIPVISIT:
 27745                                  	; 31/07/2018 - Retro DOS v3.0
 27746                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 27747                                  
 27748                                  ; Inputs:
 27749                                  ;       DS:DI Points to a buffer
 27750                                  ; Function:
 27751                                  ;       Skip visited buffers
 27752                                  ; Outputs:
 27753                                  ;       DS:DI Points to next unvisited buffer
 27754                                  ;       Zero is set if skip to LAST buffer
 27755                                  ; No other registers altered
 27756                                  
 27757 00005DBD 83FFFF                          CMP     DI,-1
 27758                                          ;retz
 27759 00005DC0 74FA                            JZ	SHORT SVISIT_RETN
 27760                                  
 27761                                  	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 27762                                          ;;;retnz
 27763                                          ;;JNZ	SHORT SVISIT_RETN
 27764                                  
 27765                                  	;test	byte [di+5],20h
 27766 00005DC2 F6450520                	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 27767 00005DC6 7505                    	JNZ	short SKIPLOOP
 27768                                  	
 27769 00005DC8 50                      	push	ax
 27770 00005DC9 0C01                    	or	al,1
 27771 00005DCB 58                      	pop	ax
 27772 00005DCC C3                      	retn	
 27773                                  
 27774                                  SKIPLOOP:
 27775 00005DCD C53D                    	LDS     DI,[DI]
 27776 00005DCF EBEC                            JMP     SHORT SKIPVISIT
 27777                                  
 27778                                  ;============================================================================
 27779                                  ; BUF.ASM, MSDOS 6.0, 1991
 27780                                  ;============================================================================
 27781                                  ; 31/07/2018 - Retro DOS v3.0
 27782                                  
 27783                                  ;	TITLE	BUF - MSDOS buffer management
 27784                                  ;	NAME	BUF
 27785                                  
 27786                                  ;**	BUF.ASM - Low level routines for buffer cache management
 27787                                  ;
 27788                                  ;	GETCURHEAD
 27789                                  ;	ScanPlace
 27790                                  ;	PLACEBUF
 27791                                  ;	PLACEHEAD
 27792                                  ;	PointComp
 27793                                  ;	GETBUFFR
 27794                                  ;	GETBUFFRB
 27795                                  ;	FlushBuf
 27796                                  ;	BufWrite
 27797                                  ;	SET_RQ_SC_PARMS
 27798                                  ;
 27799                                  ;	Revision history:
 27800                                  ;
 27801                                  ;		AN000  version 4.00  Jan. 1988
 27802                                  ;		A004   PTM 3765 -- Disk reset failed
 27803                                  ;		M039 DB 10/17/90 - Disk write optimization
 27804                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 27805                                  
 27806                                  ;Break	<GETCURHEAD -- Get current buffer header>
 27807                                  ;----------------------------------------------------------------------------
 27808                                  ; Procedure Name : GetCurHead
 27809                                  ; Inputs:
 27810                                  ;	 No Inputs
 27811                                  ; Function:
 27812                                  ;	Returns the pointer to the first buffer in Queue
 27813                                  ;	and updates FIRST_BUFF_ADDR
 27814                                  ;       and invalidates LASTBUFFER (recency pointer)
 27815                                  ; Outputs:
 27816                                  ;	DS:DI = pointer to the first buffer in Queue
 27817                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 27818                                  ;       LASTBUFFER = -1
 27819                                  ; No other registers altered
 27820                                  ;----------------------------------------------------------------------------
 27821                                  
 27822                                  ;procedure   GETCURHEAD,NEAR
 27823                                  ;
 27824                                  ;	lds	di, BufferQueue		; Pointer to the first buffer;smr;SS Override
 27825                                  ;	mov	word ptr [LastBuffer],-1; invalidate last buffer;smr;SS Override
 27826                                  ;	mov	[FIRST_BUFF_ADDR],di	;save first buffer addr;smr;SS Override
 27827                                  ;	ret
 27828                                  ;
 27829                                  ;EndProc GETCURHEAD
 27830                                  
 27831                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 27832                                  ;----------------------------------------------------------------------------
 27833                                  ; Procedure Name : ScanPlace
 27834                                  ; Inputs:
 27835                                  ;	Same as PLACEBUF
 27836                                  ; Function:
 27837                                  ;	Save scan location and call PLACEBUF
 27838                                  ; Outputs:
 27839                                  ;	DS:DI Points to saved scan location
 27840                                  ; All registers, except DS:DI, preserved.
 27841                                  ;----------------------------------------------------------------------------
 27842                                  ;M039: Rewritten to preserve registers.
 27843                                  
 27844                                  SCANPLACE:
 27845                                  	; 31/07/2018 - Retro DOS v3.0
 27846                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 27847 00005DD1 06                      	push	es
 27848 00005DD2 C435                    	les	si,[di]
 27849                                  	;les	si,[DI+BUFFINFO.buf_link]
 27850 00005DD4 E80600                  	call	PLACEBUF
 27851 00005DD7 06                      	push	es
 27852 00005DD8 1F                      	pop	ds
 27853 00005DD9 89F7                    	mov	di,si
 27854 00005DDB 07                      	pop	es
 27855                                  scanplace_retn:
 27856 00005DDC C3                      	retn	
 27857                                  	
 27858                                  	; MSDOS 6.0
 27859                                  ;ScanPlace:
 27860                                  	;push	[di].buf_next		;Save scan location
 27861                                  	;call	PLACEBUF
 27862                                  	;pop	di
 27863                                  	;retn
 27864                                  
 27865                                  ;----------------------------------------------------------------------------
 27866                                  ; Procedure Name : PlaceBuf
 27867                                  ; Input:
 27868                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 27869                                  ; Function:
 27870                                  ;	Remove buffer from queue and re-insert it in proper place.
 27871                                  ; NO registers altered
 27872                                  ;----------------------------------------------------------------------------
 27873                                  
 27874                                  ;procedure   PLACEBUF,NEAR
 27875                                  
 27876                                  ;PLACEBUF:
 27877                                  	; 31/07/2018 - Retro DOS v3.0
 27878                                  
 27879                                  	; MSDOS 6.0
 27880                                  	;push	AX			;Save only regs we modify	;AN000;
 27881                                  	;push	BX							;AN000;
 27882                                  	;push	SI							;AN000;
 27883                                  	;mov	ax, [di].BUF_NEXT
 27884                                  	;mov	bx, word ptr[BufferQueue]	; bx = offset of head of list;smr;SS Override
 27885                                  	;
 27886                                  	;cmp	ax,bx				;Buf = last?		;AN000;
 27887                                  	;je	nret				;Yes, special case	;AN000;
 27888                                  	;cmp	di,bx				;Buf = first?		;AN000;
 27889                                  	;jne	not_first 			;Yes, special case	;AN000;
 27890                                  	;mov	word ptr [BufferQueue],ax	;smr;SS Override
 27891                                  	;jmp	short nret 			;Continue with repositioning;AN000;
 27892                                  ;not_first:
 27893                                  	;mov	SI,[DI].BUF_PREV		;No, SI = prior Buf	;AN000;
 27894                                  	;mov	[SI].BUF_NEXT,AX		; ax has di->buf_next	;AN000;
 27895                                  	;xchg	si, ax
 27896                                  	;mov	[SI].BUF_PREV,AX		;			;AN000;
 27897                                  	;
 27898                                  	;mov	SI,[BX].BUF_PREV		;SI-> last buffer	;AN000;
 27899                                  	;mov	[SI].BUF_NEXT,DI		;Add Buf to end of list ;AN000;
 27900                                  	;mov	[BX].BUF_PREV,DI					;AN000;
 27901                                  	;mov	[DI].BUF_PREV,SI		;Update link in Buf too	;AN000;
 27902                                  	;mov	[DI].BUF_NEXT,BX					;AN000;
 27903                                  ;nret:									;AN000;
 27904                                  	;pop	SI							;AN000;
 27905                                  	;pop	BX							;AN000;
 27906                                  	;pop	AX							;AN000;
 27907                                  	;								;AN000;
 27908                                  	;cmp	[di.buf_ID],-1			; Buffer FREE?		;AN000;
 27909                                          ;jne	pbx                             ; M039: -no, jump.
 27910                                  	;mov	WORD PTR [BufferQueue],di	; M039: -yes, make it LRU.
 27911                                  ;pbx:	
 27912                                  ;	ret								;AN000;
 27913                                  
 27914                                  	; 31/07/2018 - Retro DOS v3.0
 27915                                  
 27916                                  	; MSDOS 3.3
 27917                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 27918                                  
 27919                                  PLACEBUF:
 27920                                  	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 27921                                  	
 27922 00005DDD E818B8                          CALL	save_world
 27923 00005DE0 C40D                            LES     CX,[DI]
 27924 00005DE2 83F9FF                          CMP     CX,-1           	; Buf is LAST?
 27925 00005DE5 744B                            JZ      SHORT NRET		; Buffer already last
 27926 00005DE7 8CC5                            MOV     BP,ES           	; Pointsave = Buf.nextbuf
 27927 00005DE9 1E                              PUSH    DS
 27928 00005DEA 07                              POP     ES              	; Buf is ES:DI
 27929                                  	; 15/03/2018
 27930 00005DEB 36C536[3800]                    LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 27931 00005DF0 E88600                          CALL    POINTCOMP       	; Buf == HEAD?
 27932 00005DF3 750C                            JNZ     SHORT BUFLOOP
 27933 00005DF5 36890E[3800]                    MOV     [SS:BUFFHEAD],CX
 27934 00005DFA 36892E[3A00]                    MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 27935 00005DFF EB14                            JMP     SHORT LOOKEND
 27936                                  
 27937                                  BUFLOOP:
 27938                                  	; 31/07/2018
 27939 00005E01 8CD8                    	mov	ax,ds
 27940 00005E03 89F3                    	mov	bx,si
 27941                                  	;lds	si,[SI+BUFFINFO.buf_link]
 27942 00005E05 C534                            LDS     SI,[SI]
 27943 00005E07 E86F00                          CALL    POINTCOMP
 27944 00005E0A 75F5                            jnz	short BUFLOOP
 27945                                  	;
 27946 00005E0C 8ED8                    	mov	ds,ax
 27947 00005E0E 89DE                    	mov	si,bx
 27948 00005E10 890C                    	mov	[SI],cx
 27949                                  	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 27950 00005E12 896C02                  	mov	[SI+2],bp
 27951                                  	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 27952                                  LOOKEND:
 27953 00005E15 8CD8                    	mov	ax,ds
 27954 00005E17 89F3                    	mov	bx,si
 27955 00005E19 C534                            LDS     SI,[SI]
 27956 00005E1B 83FEFF                          CMP     SI,-1
 27957 00005E1E 75F5                            jnz     short LOOKEND
 27958                                  
 27959                                  GOTHEEND:
 27960 00005E20 8ED8                            mov	ds,ax
 27961 00005E22 893F                    	mov	[BX],di
 27962 00005E24 8C4702                          MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 27963 00005E27 26C705FFFF                      MOV     WORD [ES:DI],-1
 27964                                  	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 27965 00005E2C 26C74502FFFF                    MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 27966                                  	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 27967                                  NRET:
 27968 00005E32 E8B0B7                          CALL	restore_world
 27969                                  	
 27970                                  	;cmp	byte [di+4],-1
 27971 00005E35 807D04FF                	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 27972 00005E39 75A1                    	jnz     short scanplace_retn
 27973 00005E3B E80100                  	call    PLACEHEAD
 27974 00005E3E C3                      	retn
 27975                                  
 27976                                  ;EndProc PLACEBUF
 27977                                  
 27978                                  ;M039 - Removed PLACEHEAD.
 27979                                  ;----------------------------------------------------------------------------
 27980                                  ; places buffer at head
 27981                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 27982                                  ;	ONE IN THE LIST!!!!!!!
 27983                                  ; BUGBUG ---- this routine can be removed because it has only
 27984                                  ; BUGBUG ---- one instruction. This routine is called from
 27985                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 27986                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 27987                                  ; BUGBUG ---- But kept as it is for modularity
 27988                                  ;----------------------------------------------------------------------------
 27989                                  ;procedure   PLACEHEAD,NEAR
 27990                                  ;	mov	word ptr [BufferQueue], di
 27991                                  ;	ret
 27992                                  ;EndProc PLACEHEAD
 27993                                  ;M039
 27994                                  
 27995                                  ;----------------------------------------------------------------------------
 27996                                  ; Procedure Name : PLACEHEAD
 27997                                  ;
 27998                                  ; SAME AS PLACEBUF except places buffer at head
 27999                                  ;----------------------------------------------------------------------------
 28000                                  
 28001                                  	; MSDOS 3.3 (Retro DOS v3.0)
 28002                                  	; 05/09/2018
 28003                                  	; MSDOS 2.11 (Retro DOS v2.0)
 28004                                  PLACEHEAD:
 28005                                  	; 31/07/2018 - Retro DOS v3.0
 28006                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 28007                                  
 28008 00005E3F E8B6B7                          CALL	save_world
 28009 00005E42 1E                              PUSH	DS
 28010 00005E43 07                              POP	ES
 28011                                  	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 28012 00005E44 36C536[3800]                    LDS     SI,[SS:BUFFHEAD]
 28013                                  	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 28014 00005E49 E82D00                  	CALL    POINTCOMP
 28015 00005E4C 7427                            JZ      SHORT GOTHEEND2
 28016 00005E4E 268935                  	MOV	[ES:DI],SI
 28017                                  	;mov	[ES:DI+BUFFINFO.buf_link],si
 28018 00005E51 268C5D02                        MOV	[ES:DI+2],DS
 28019                                  	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 28020 00005E55 36893E[3800]                    MOV	[SS:BUFFHEAD],DI
 28021 00005E5A 368C06[3A00]                    MOV	[SS:BUFFHEAD+2],ES
 28022                                  LOOKEND2:
 28023 00005E5F 8CD8                            mov	ax,ds
 28024 00005E61 89F3                    	mov	bx,si
 28025                                  	;lds	si,[SI+BUFFINFO.buf_link]
 28026 00005E63 C534                            LDS     SI,[SI]
 28027 00005E65 E81100                          CALL    POINTCOMP
 28028 00005E68 75F5                            JNZ	SHORT LOOKEND2 ; 05/09/2018
 28029 00005E6A 8ED8                            mov	ds,ax
 28030 00005E6C C707FFFF                	mov	word [bx],-1
 28031                                  	;mov	word [BX+BUFFINFO.buf_link],-1
 28032 00005E70 C74702FFFF              	mov	word [bx+2],-1
 28033                                  	;mov	word [BX+BUFFINFO.buf_link+2],-1
 28034                                  GOTHEEND2:
 28035 00005E75 E86DB7                         	call	restore_world
 28036                                  placehead_retn:
 28037 00005E78 C3                      	retn
 28038                                  
 28039                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 28040                                  ;----------------------------------------------------------------------------
 28041                                  ;
 28042                                  ; Procedure Name : PointComp
 28043                                  ; Inputs:
 28044                                  ;         DS:SI & ES:DI
 28045                                  ; Function:
 28046                                  ;          Checks for ((SI==DI) && (ES==DS))
 28047                                  ;	   Assumes that pointers are normalized for the
 28048                                  ;	   same segment
 28049                                  ;
 28050                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 28051                                  ; DO NOT USE FOR < or >
 28052                                  ; No Registers altered
 28053                                  ;
 28054                                  ;----------------------------------------------------------------------------
 28055                                  
 28056                                  POINTCOMP:
 28057                                  	; 31/07/2018 - Retro DOS v3.0
 28058                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 28059 00005E79 39FE                    	CMP	SI,DI
 28060                                  	;jnz	short _ret_label	; return if nz
 28061 00005E7B 75FB                    	jnz	short placehead_retn 
 28062 00005E7D 51                      	PUSH	CX
 28063 00005E7E 52                      	PUSH	DX
 28064 00005E7F 8CD9                    	MOV	CX,DS
 28065 00005E81 8CC2                    	MOV	DX,ES
 28066 00005E83 39D1                    	CMP	CX,DX
 28067 00005E85 5A                      	POP	DX
 28068 00005E86 59                      	POP	CX
 28069                                  ;_ret_label:
 28070 00005E87 C3                      	retn
 28071                                  
 28072                                  
 28073                                  ; 01/08/2018 - Retro DOS v3.0
 28074                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 28075                                  
 28076                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 28077                                  
 28078                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 28079                                  ;----------------------------------------------------------------------------
 28080                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 28081                                  ;	It gets the specified local sector into one of the I/O buffers
 28082                                  ;	and shuffles the queue
 28083                                  ; 
 28084                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 28085                                  ;		       ELSE no pre-read
 28086                                  ;		(DX) = Desired physical sector number	      (LOW)
 28087                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 28088                                  ;		(ES:BP) = Pointer to drive parameters
 28089                                  ;		ALLOWED set in case of INT 24
 28090                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 28091                                  ;		'C' clear if OK
 28092                                  ;		CURBUF Points to the Buffer for the sector
 28093                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 28094                                  ;	USES	AX, BX, CX, SI, DI, Flags
 28095                                  ;----------------------------------------------------------------------------
 28096                                  
 28097                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 28098                                  ;----------------------------------------------------------------------------
 28099                                  ;	GetBuffr reads a sector from the FAT file system's FAT table.
 28100                                  ;	It gets the specified sector into one of the I/O buffers
 28101                                  ;	and shuffles the queue. We need a special entry point so that
 28102                                  ;	we can read the alternate FAT sector if the first read fails, also
 28103                                  ;	so we can mark the buffer as a FAT sector.
 28104                                  ; 
 28105                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 28106                                  ;		       ELSE no pre-read
 28107                                  ;		(DX) = Desired physical sector number	      (LOW)
 28108                                  ;		(SI) != 0
 28109                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 28110                                  ;		(ES:BP) = Pointer to drive parameters
 28111                                  ;		ALLOWED set in case of INT 24
 28112                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 28113                                  ;		'C' clear if OK
 28114                                  ;		CUR ddBUF Points to the Buffer for the sector
 28115                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 28116                                  ;	USES	AX, BX, CX, SI, DI, Flags
 28117                                  ;----------------------------------------------------------------------------
 28118                                  
 28119                                  GETBUFFR:
 28120 00005E88 31F6                    	XOR	SI,SI
 28121                                  
 28122                                  ;	This entry point is called for FAT buffering with SI != 0
 28123                                  
 28124                                  GETBUFFRB:
 28125 00005E8A A3[2C05]                	MOV	[PREREAD],AX			; save pre-read flag
 28126 00005E8D 268A4600                	mov	al,[ES:BP]
 28127                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 28128 00005E91 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 28129                                  	; MSDOS 6.0
 28130                                  ;hkn; SS override
 28131                                  	;MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb		;AN000;
 28132                                  
 28133                                  ;	See if this is the buffer that was most recently returned.
 28134                                  ;	A big performance win if it is.
 28135                                  
 28136 00005E95 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 28137 00005E98 740A                    	je	short getb5			; No
 28138                                  	;cmp	dx,[di+6]
 28139 00005E9A 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 28140 00005E9D 7505                    	JNZ	short getb5			; Wrong sector
 28141                                  	
 28142                                  	; MSDOS 6.0
 28143                                  	;CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb		;AN000;
 28144                                  	;JNZ	short getb5			; F.C. >32mb		;AN000;
 28145                                  	
 28146                                  	;cmp	al,[di+4]
 28147 00005E9F 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 28148 00005EA2 7474                    	JZ	getb35				; Just asked for same buffer
 28149                                  
 28150                                  ;	It's not the buffer most recently returned.  See if it's in the
 28151                                  ;	cache.
 28152                                  ;
 28153                                  ;	(cx:dx) = sector #
 28154                                  ;	(al) = drive #
 28155                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 28156                                  ;	??? list may be incomplete ???
 28157                                  
 28158                                  getb5:	
 28159                                  	; MSDOS 6.0
 28160                                  	;CALL	GETCURHEAD			; get Q Head
 28161                                  	; MSDOS 3.3
 28162 00005EA4 36C53E[3800]            	lds	di,[SS:BUFFHEAD]
 28163                                  getb10:	
 28164                                  	;cmp	dx,[di+6]
 28165 00005EA9 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 28166 00005EAC 7505                    	jne	short getb12			; wrong sector lo
 28167                                  	
 28168                                  	; MSDOS 6.0
 28169                                  	;CMP	CX,[DI+BUFFINFO.buf_sector+2]
 28170                                  	;jne	short getb12			; wrong sector hi
 28171                                  	
 28172                                  	;cmp	al,[di+4]
 28173 00005EAE 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 28174 00005EB1 7450                    	je	short getb25 ; 05/09/2018	; Found the requested sector
 28175                                  getb12:	
 28176                                  	; MSDOS 6.0
 28177                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 28178                                  	;cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 28179                                  	;jne	short getb10			; no, continue looking
 28180                                  
 28181                                  	; MSDOS 3.3
 28182                                  	;mov	di,[DI]
 28183                                  	;mov	di,[DI+BUFFINFO.buf_link]
 28184                                  	;
 28185                                  	; 15/08/2018
 28186 00005EB3 C53D                    	lds	di,[di]
 28187                                  	;
 28188 00005EB5 83FFFF                  	cmp	di,-1 ; 0FFFFh
 28189 00005EB8 75EF                    	jne	short getb10
 28190 00005EBA 36C53E[3800]            	lds	di,[SS:BUFFHEAD]		
 28191                                  
 28192                                  ;	The requested sector is not available in the buffers. DS:DI now points
 28193                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 28194                                  ;	new sector into it.
 28195                                  ;
 28196                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 28197                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 28198                                  ;	him, we should take LRU. And the above lookup shouldn't be
 28199                                  ;	down a chain, but should be hashed.
 28200                                  ;
 28201                                  ;	(DS:DI) = first buffer in the queue
 28202                                  ;	(CX:DX) = sector # we want
 28203                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 28204                                  
 28205                                  ;hkn; SS override
 28206                                  	;PUSH	cx
 28207 00005EBF 56                      	push	si
 28208 00005EC0 52                      	push	dx
 28209 00005EC1 55                      	push	bp
 28210 00005EC2 06                      	push	es
 28211 00005EC3 E8B900                  	CALL	BUFWRITE			; Write out the dirty buffer
 28212 00005EC6 07                      	pop	es
 28213 00005EC7 5D                      	pop	bp
 28214 00005EC8 5A                      	pop	dx
 28215 00005EC9 5E                      	pop	si
 28216                                  	;POP	word [SS:HIGH_SECTOR]
 28217 00005ECA 7261                    	jc	short getbx			; if got hard error
 28218                                  
 28219                                  	; MSDOS 6.0
 28220                                  	;CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 28221                                  
 28222                                  ;	We're ready to read in the buffer, if need be. If the caller
 28223                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 28224                                  
 28225 00005ECC 30E4                    	XOR	AH,AH				; initial flags
 28226                                  ;hkn; SS override
 28227                                  	;test	byte [ss:PREREAD],0FFh
 28228                                  	;jnz	short getb20
 28229 00005ECE 363826[2C05]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 28230 00005ED3 751E                    	JNZ	short getb20			; no, we're done
 28231 00005ED5 8D5D10                  	LEA	BX,[DI+BUFINSIZ] ; [DI+16]	; (ds:bx) = data address
 28232 00005ED8 B90100                  	MOV	CX,1
 28233 00005EDB 56                      	push	si
 28234 00005EDC 57                      	push	di
 28235 00005EDD 52                      	push	dx
 28236                                  	; MSDOS 6.0
 28237                                  	;push	es
 28238                                  ; Note:  As far as I can tell, all disk reads into buffers go through
 28239                                  ;	 this point.  -mrw 10/88
 28240                                  	;cmp	BuffInHMA, 0		; is buffers in HMA?
 28241                                  	;jz	@f
 28242                                  	;push	ds
 28243                                  	;push	bx
 28244                                  	;lds	bx, dword ptr LoMemBuff	; Then let's read it into scratch buff
 28245                                  ;@@:
 28246                                  ;M039: Eliminated redundant HMA code.
 28247                                  
 28248                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28249 00005EDE 09F6                    	OR	SI,SI			; FAT sector ?
 28250 00005EE0 7407                    	JZ	short getb15		
 28251                                  
 28252 00005EE2 E85CE2                  	call	FATSECRD
 28253                                  	;mov	ah,2
 28254 00005EE5 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 28255                                  
 28256 00005EE7 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 28257                                  
 28258                                  getb15:
 28259 00005EE9 E87CE2                  	call	DREAD			; Buffer is marked free if read barfs
 28260 00005EEC B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 28261                                  getb17:	
 28262                                  	; MSDOS 6.0							  ;I001
 28263                                  	;pushf								  ;I001
 28264                                  	;cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 28265                                  	;jz	short not_in_hma	; no				  ;I001
 28266                                  	;mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 28267                                  	;shr	cx,1							  ;I001
 28268                                  	;popf				; Retreive possible CY from DREAD ;I001
 28269                                  	;mov	si,bx							  ;I001
 28270                                  	;pop	di							  ;I001
 28271                                  	;pop	es							  ;I001
 28272                                  	;cld								  ;I001
 28273                                  	;pushf				; Preserve possible CY from DREAD ;I001
 28274                                  	;rep	movsw			; move the contents of scratch buf;I001
 28275                                  	;push	es							  ;I001
 28276                                  	;pop	ds							  ;I001
 28277                                  ;not_in_hma:								  ;I001
 28278                                  	;popf							 	  ;I001
 28279                                  	;pop	es
 28280                                  	;
 28281 00005EEE 5A                      	pop	dx
 28282 00005EEF 5F                      	pop	di
 28283 00005EF0 5E                      	pop	si
 28284 00005EF1 723A                    	JC	short getbx
 28285                                  
 28286                                  ;	The buffer has the data setup in it (if we were to read)
 28287                                  ;	Setup the various buffer fields
 28288                                  ;
 28289                                  ;	(ds:di) = buffer address
 28290                                  ;	(es:bp) = DPB address
 28291                                  ;	(HIGH_SECTOR:DX) = sector #
 28292                                  ;	(ah) = BUF_FLAGS value
 28293                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 28294                                  
 28295                                  ;hkn; SS override
 28296                                  getb20:	; MSDOS 6.0
 28297                                  	;MOV	CX,[SS:HIGH_SECTOR]
 28298                                  	;MOV	WORD [DI+BUFFINFO.buf_sector+2],CX
 28299                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 28300                                   	;mov	[di+6],dx
 28301 00005EF3 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 28302                                  	;mov	[di+0Ah],bp
 28303 00005EF6 896D0A                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 28304                                  	;mov	[di+0Ch], es
 28305 00005EF9 8C450C                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 28306 00005EFC 268A4600                	mov	al,[es:bp]
 28307                                  	;mov	al,[es:bp+0]
 28308                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 28309                                  	;mov	[di+4],ax
 28310 00005F00 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 28311                                  getb25:	
 28312                                  	; MSDOS 6.0
 28313                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 28314                                  	;XOR	AX,AX
 28315                                  
 28316                                  	; MSDOS 3.3
 28317 00005F03 B80100                  	mov     ax,1
 28318                                  
 28319 00005F06 09F6                    	OR	SI,SI				; FAT sector ?
 28320 00005F08 7408                    	JZ	short getb30
 28321                                  
 28322                                  	;mov	al,[es:bp+8]
 28323 00005F0A 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 28324                                  	; MSDOS 6.0
 28325                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 28326                                  	;MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 28327                                  						;  sectors
 28328                                  	; MSDOS 3.3
 28329                                  	;mov	ah,[es:bp+0Fh]
 28330 00005F0E 268A660F                	MOV	AH,[ES:BP+DPB.FAT_SIZE]
 28331                                  
 28332                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 28333                                  ;		is set
 28334                                  
 28335                                  getb30:	
 28336                                  	; MSDOS 6.0
 28337                                  	;MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 28338                                  
 28339                                  	; MSDOS 3.3
 28340                                  	;mov	[di+8],ax ; 15/08/2018	
 28341 00005F12 894508                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 28342                                  
 28343 00005F15 E8C5FE                  	CALL	PLACEBUF
 28344                                  
 28345                                  ;hkn; SS override for next 4
 28346                                  getb35: 
 28347 00005F18 368C1E[7605]            	MOV	[SS:CURBUF+2],DS
 28348 00005F1D 368C1E[2000]            	MOV	[SS:LastBuffer+2],DS
 28349 00005F22 36893E[7405]            	MOV	[SS:CURBUF],DI
 28350 00005F27 36893E[1E00]            	MOV	[SS:LastBuffer],DI
 28351 00005F2C F8                      	CLC
 28352                                  
 28353                                  ;	Return with 'C' set appropriately
 28354                                  ;
 28355                                  ;	(dx) = caller's original value
 28356                                  
 28357                                  getbx:	
 28358 00005F2D 16                      	push	ss
 28359 00005F2E 1F                      	pop	ds
 28360 00005F2F C3                      	retn
 28361                                  
 28362                                  
 28363                                  
 28364                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 28365                                  ;----------------------------------------------------------------------------
 28366                                  ; Input:
 28367                                  ;	DS = DOSGROUP
 28368                                  ;	AL = Physical unit number local buffers only
 28369                                  ;	   = -1 for all units and all remote buffers
 28370                                  ; Function:
 28371                                  ;	Write out all dirty buffers for unit, and flag them as clean
 28372                                  ;	Carry set if error (user FAILed to I 24)
 28373                                  ;	    Flush operation completed.
 28374                                  ; DS Preserved, all others destroyed (ES too)
 28375                                  ;----------------------------------------------------------------------------
 28376                                  
 28377                                  FLUSHBUF:
 28378                                  	; MSDOS 6.0
 28379                                  	;call	GetCurHead
 28380                                  	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 28381                                  	;jnz	short scan_buf_queue
 28382                                  	;cmp	word [DirtyBufferCount], 0			;hkn;
 28383                                  	;je	short end_scan
 28384                                  	
 28385                                  	; MSDOS 3.3
 28386                                  	;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 28387 00005F30 C53E[3800]              	lds	di,[BUFFHEAD]
 28388                                  scan_buf_queue:
 28389 00005F34 E81F00                  	call	CHECKFLUSH
 28390                                  	;push	ax  ; MSDOS 3.3
 28391                                  	; MSDOS 6.0
 28392 00005F37 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 28393 00005F3A 363826[D002]            	cmp	[SS:WPERR],ah					;hkn;
 28394                                  	;je	short free_the_buf
 28395                                  	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 28396                                  	;jz	short dont_free_the_buf
 28397                                  	; MSDOS 3.3
 28398                                  	;mov	al,[di+4]
 28399                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 28400                                  	;cmp	[SS:WPERR],al					;hkn;
 28401                                  	; 15/08/2018
 28402 00005F3F 7505                    	jne	short dont_free_the_buf	
 28403                                  free_the_buf:
 28404                                  	; MSDOS 6.0 (& MSDOS 3.3)
 28405 00005F41 C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 28406                                  dont_free_the_buf:
 28407                                  	;pop	ax  ; MSDOS 3.3 	   	
 28408                                  	
 28409                                  	; MSDOS 6.0
 28410                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 28411                                  	;cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 28412                                  	;jne	short scan_buf_queue
 28413                                  
 28414                                  	; MSDOS 3.3
 28415                                  	;mov	di,[DI]
 28416                                  	;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 28417                                  	;
 28418                                  	; 15/08/2018
 28419 00005F46 C53D                    	lds	di,[di]
 28420                                  	;
 28421 00005F48 83FFFF                  	cmp	di,-1 ; 0FFFFh
 28422 00005F4B 75E7                    	jnz	short scan_buf_queue 
 28423                                  
 28424                                  end_scan:
 28425 00005F4D 16                      	push	ss
 28426 00005F4E 1F                      	pop	ds
 28427                                  	; 01/08/2018 - Retro DOS v3.0
 28428                                  	;cmp	byte [FAILERR],0
 28429                                  	;jne	short bad_flush
 28430                                  	;retn
 28431                                  ;bad_flush:
 28432                                  	;stc
 28433                                  	;retn
 28434                                  	; 01/08/2018 - Retro DOS v3.0
 28435 00005F4F 803E[F602]01            	cmp	byte [FAILERR],1
 28436 00005F54 F5                      	cmc
 28437                                  flushbuf_retn:
 28438 00005F55 C3                      	retn
 28439                                  
 28440                                  ;----------------------------------------------------------------------------
 28441                                  ;
 28442                                  ; Procedure Name : CHECKFLUSH
 28443                                  ;
 28444                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 28445                                  ;	   DS:DI - pointer to buffer
 28446                                  ;
 28447                                  ; Function : Write out a buffer if it is dirty
 28448                                  ;
 28449                                  ; Carry set if problem (currently user FAILed to I 24)
 28450                                  ;
 28451                                  ;----------------------------------------------------------------------------
 28452                                  
 28453                                  CHECKFLUSH:
 28454                                  	; MSDOS 6.0
 28455 00005F56 B4FF                    	mov	ah, -1 ; 01/08/2018 Retro DOS v3.0
 28456                                  	;cmp	[di+4],ah
 28457 00005F58 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 28458 00005F5B 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 28459 00005F5D 38C4                    	CMP	AH,AL			; 
 28460 00005F5F 7406                    	JZ	short DOBUFFER		; do this buffer
 28461                                  	;cmp	al,[di+4]
 28462 00005F61 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 28463 00005F64 F8                      	CLC
 28464 00005F65 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 28465                                  DOBUFFER:
 28466                                  	;test	byte [di+5],40h
 28467 00005F67 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 28468 00005F6B 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 28469 00005F6D 50                      	PUSH	AX
 28470                                  	;push	word [di+4]
 28471 00005F6E FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 28472 00005F71 E80B00                  	CALL	BUFWRITE
 28473 00005F74 58                      	POP	AX
 28474 00005F75 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 28475                                  	;and	ah,0BFh
 28476 00005F77 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 28477                                  	;mov	[di+4],ax
 28478 00005F7A 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 28479                                  LEAVE_BUF:
 28480 00005F7D 58                      	POP	AX			; Search info
 28481                                  checkflush_retn:
 28482 00005F7E C3                      	retn
 28483                                  
 28484                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 28485                                  ;----------------------------------------------------------------------------
 28486                                  ;
 28487                                  ;	BufWrite writes a buffer to the disk, iff it's dirty.
 28488                                  ;
 28489                                  ;	ENTRY	DS:DI Points to the buffer
 28490                                  ;
 28491                                  ;	EXIT	Buffer marked free
 28492                                  ;		Carry set if error (currently user FAILed to I 24)
 28493                                  ;
 28494                                  ;	USES	All buf DS:DI
 28495                                  ;		HIGH_SECTOR
 28496                                  ;----------------------------------------------------------------------------
 28497                                  
 28498                                  BUFWRITE:
 28499                                  	; 10/09/2018
 28500                                  	; 01/08/2018 - Retro DOS v3.0
 28501                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 28502 00005F7F B8FF00                  	MOV	AX,00FFH
 28503                                  	;xchg	ax,[di+4]
 28504 00005F82 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 28505 00005F85 3CFF                    	CMP	AL,0FFH
 28506 00005F87 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 28507                                  	;test	ah,40h
 28508 00005F89 F6C440                  	test	AH,buf_dirty
 28509 00005F8C 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 28510                                  	; MSDOS 6.0
 28511                                  	;call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 28512                                  
 28513                                  ;hkn; SS override
 28514 00005F8E 363A06[D002]            	CMP	AL,[SS:WPERR]
 28515 00005F93 74E9                    	jz      short checkflush_retn	; If in WP error zap buffer
 28516                                  
 28517                                  ;hkn; SS override
 28518                                  	; MSDOS 6.0
 28519                                  	;MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 28520                                  	
 28521                                  	;les	bp,[di+10]
 28522 00005F95 C46D0A                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 28523                                  	;lea	bx,[di+16]
 28524 00005F98 8D5D10                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 28525                                  	;mov	dx,[di+6]
 28526 00005F9B 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 28527                                  	; MSDOS 6.0
 28528                                  	;MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 28529                                  
 28530                                  ;hkn; SS override
 28531                                  	;MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 28532                                  	;MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 28533                                  	; MSDOS 3.3
 28534                                  	; mov	cx,[DI+8]
 28535 00005F9E 8B4D08                  	mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 28536 00005FA1 88E8                    	MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 28537 00005FA3 30ED                    	XOR	CH,CH
 28538                                  	;mov	ah,ch ; MSDOS 3.3
 28539                                  
 28540                                  ;hkn; SS override for ALLOWED
 28541                                  	;mov	byte [SS:ALLOWED],18h
 28542 00005FA5 36C606[F702]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 28543                                  	;test	byte [di+5],8
 28544                                  	;test	ah,8
 28545 00005FAB F6C408                  	test	AH,buf_isDATA
 28546 00005FAE 7406                    	JZ	short NO_IGNORE
 28547                                  	;or	byte [SS:ALLOWED],20h
 28548 00005FB0 36800E[F702]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 28549                                  NO_IGNORE:
 28550 00005FB6 30E4                    	xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 28551                                  	; MSDOS 6.0
 28552                                  	;MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 28553                                  
 28554 00005FB8 57                      	PUSH	DI		; Save buffer pointer
 28555 00005FB9 31FF                    	XOR	DI,DI		; Indicate failure
 28556                                  
 28557                                  	;push	ds
 28558                                  	;push	bx
 28559                                  WRTAGAIN:
 28560 00005FBB 57                      	push	di
 28561 00005FBC 51                      	push	cx
 28562 00005FBD 50                      	push	ax
 28563 00005FBE B90100                  	MOV	CX,1
 28564 00005FC1 53                      	push	bx
 28565 00005FC2 52                      	push	dx
 28566 00005FC3 1E                      	push	ds
 28567                                  
 28568                                  ; Note:  As far as I can tell, all disk reads into buffers go through this point.  -mrw 10/88
 28569                                  
 28570                                  	; MSDOS 6.0
 28571                                  	;cmp	byte [BuffInHMA], 0
 28572                                  	;jz	short NBUFFINHMA
 28573                                  	;push	cx
 28574                                  	;push	es
 28575                                  	;mov	si,bx
 28576                                  	;mov	cx,[es:bp+DPB.SECTOR_SIZE]
 28577                                  	;shr	cx,1
 28578                                  	;les	di,[LoMemBuff]
 28579                                  	;mov	bx,di
 28580                                  	;cld
 28581                                  	;rep	movsw
 28582                                  	;push	es
 28583                                  	;pop	ds
 28584                                  	;pop	es
 28585                                  	;pop	cx
 28586                                  ;NBUFFINHMA:
 28587 00005FC4 E800E2                  	call	DWRITE		; Write out the dirty buffer
 28588 00005FC7 1F                      	pop	ds
 28589 00005FC8 5A                      	pop	dx
 28590 00005FC9 5B                      	pop	bx
 28591 00005FCA 58                      	pop	ax
 28592 00005FCB 59                      	pop	cx
 28593 00005FCC 5F                      	pop	di
 28594 00005FCD 7201                    	JC	short NOSET
 28595 00005FCF 47                      	INC	DI		; If at least ONE write succeedes, the operation
 28596                                  NOSET:				;	succeedes.
 28597 00005FD0 01C2                    	ADD	DX,AX
 28598 00005FD2 E2E7                    	LOOP	WRTAGAIN
 28599                                  	;pop	bx
 28600                                  	;pop	ds
 28601 00005FD4 09FF                    	OR	DI,DI		; Clears carry
 28602 00005FD6 7501                    	JNZ	short BWROK	; At least one write worked
 28603 00005FD8 F9                      	STC			; DI never got INCed, all writes failed.
 28604                                  BWROK:	
 28605 00005FD9 5F                      	POP	DI
 28606 00005FDA C3                      	retn
 28607                                  
 28608                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 28609                                  ;----------------------------------------------------------------------------
 28610                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 28611                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 28612                                  ;	SC_DRIVE even if SC is disabled to save the testing
 28613                                  ;	code and time
 28614                                  ;
 28615                                  ;	ENTRY	ES:BP = drive parameter block
 28616                                  ;
 28617                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 28618                                  ;		[SC_DRIVE]= drive #
 28619                                  ;
 28620                                  ;	USES	Flags
 28621                                  ;----------------------------------------------------------------------------
 28622                                  
 28623                                  ;procedure   SET_RQ_SC_PARMS,NEAR
 28624                                  ;
 28625                                  ;;hkn; SS override for all variables used in this procedure.
 28626                                  ;
 28627                                  ;	SAVE	<ax>
 28628                                  ;
 28629                                  ;	MOV	ax,ES:[BP].DPB_SECTOR_SIZE	; save sector size
 28630                                  ;	MOV	SC_SECTOR_SIZE,ax
 28631                                  ;
 28632                                  ;	MOV	al,ES:[BP].DPB_DRIVE		; save drive #
 28633                                  ;	MOV	SC_DRIVE,al
 28634                                  ;
 28635                                  ;	RESTORE <ax>
 28636                                  ;
 28637                                  ;srspx:	return
 28638                                  ;
 28639                                  ;EndProc SET_RQ_SC_PARMS 			;LB. return
 28640                                  
 28641                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 28642                                  ;----------------------------------------------------------------------------
 28643                                  ; Input:
 28644                                  ;	none
 28645                                  ; Function:
 28646                                  ;	increment dirty buffers count
 28647                                  ; Output:
 28648                                  ;	dirty buffers count is incremented
 28649                                  ;
 28650                                  ; All registers preserved
 28651                                  ;----------------------------------------------------------------------------
 28652                                  
 28653                                  ;procedure   INC_DIRTY_COUNT,NEAR
 28654                                  ;
 28655                                  ;; BUGBUG  ---- remove this routine
 28656                                  ;; BUGBUG ---- only one instruction is needed   (speed win, space loose)
 28657                                  ;	inc	[DirtyBufferCount]			;hkn;
 28658                                  ;	ret
 28659                                  ;EndProc INC_DIRTY_COUNT
 28660                                  
 28661                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 28662                                  ;----------------------------------------------------------------------------
 28663                                  ; Input:
 28664                                  ;	none
 28665                                  ; Function:
 28666                                  ;	decrement dirty buffers count
 28667                                  ; Output:
 28668                                  ;	dirty buffers count is decremented
 28669                                  ;
 28670                                  ; All registers preserved
 28671                                  ;----------------------------------------------------------------------------
 28672                                  
 28673                                  ;procedure   DEC_DIRTY_COUNT,NEAR
 28674                                  ;	cmp	[DirtyBufferCount], 0	;hkn;
 28675                                  ;	jz	ddcx			; BUGBUG - shouldn't it be an
 28676                                  ;	dec	[DirtyBufferCount]	; error condition to underflow here? ;hkn;
 28677                                  ;ddcx:	ret
 28678                                  ;
 28679                                  ;EndProc DEC_DIRTY_COUNT
 28680                                  
 28681                                  ;============================================================================
 28682                                  ; MSPROC.ASM, MSDOS 6.0, 1991
 28683                                  ;============================================================================
 28684                                  ; 02/08/2018 - Retro DOS v3.0
 28685                                  
 28686                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 28687                                  
 28688                                  ; Pseudo EXEC system call for DOS
 28689                                  
 28690                                  ;	TITLE	MSPROC - process maintenance
 28691                                  ;	NAME	MSPROC
 28692                                  
 28693                                  ; =========================================================================
 28694                                  ;**	Process related system calls and low level routines for DOS 2.X.
 28695                                  ;	I/O specs are defined in DISPATCH.
 28696                                  ;
 28697                                  ;	$WAIT
 28698                                  ;	$EXEC
 28699                                  ;	$Keep_process
 28700                                  ;	Stay_resident
 28701                                  ;	$EXIT
 28702                                  ;	$ABORT
 28703                                  ;	abort_inner
 28704                                  ;
 28705                                  ;	Modification history:
 28706                                  ;
 28707                                  ;		Created: ARR 30 March 1983
 28708                                  ;		AN000	version 4.0 jan. 1988
 28709                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 28710                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 28711                                  ;
 28712                                  ;		M000	added support for loading programs into UMBs 7/9/90
 28713                                  ;
 28714                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 28715                                  ;		       dossym.inc. 7/30/90
 28716                                  ;		M005 - Support for EXE programs with out STACK segment and 
 28717                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 28718                                  ;		       stack is provided at the end of the program. Note that
 28719                                  ;		       only SP is changed.
 28720                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 28721                                  ;
 28722                                  ;		M028 - 4b04 implementation
 28723                                  ;
 28724                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 28725                                  ;			in memory block >= 64K, sp = 0. If memory block
 28726                                  ;			obtained is <64K, point sp at the end of the memory
 28727                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 28728                                  ;			added for a stack segment which may be needed if it
 28729                                  ;			is loaded in low memory situations.
 28730                                  ;
 28731                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 28732                                  ;
 28733                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 28734                                  ;			a bad environment if it reached 32767 bytes. Changed
 28735                                  ;			to allow 32768 bytes of environment.
 28736                                  ;
 28737                                  ;		M047 - Release the allocated UMB when we failed to load a 
 28738                                  ;		       COM file high. Also ensure that if the biggest block
 28739                                  ;		       into which we load the com file is less than 64K then
 28740                                  ;		       we provide atleast 256 bytes of stack to the user.
 28741                                  ;
 28742                                  ;		M050 - Made Lie table search CASE insensitive
 28743                                  ;
 28744                                  ;		M060 - Removed special version table from the kernal and
 28745                                  ;                      put it in a device drive which puts the address
 28746                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 28747                                  ;		       as a DWORD.
 28748                                  ;
 28749                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 28750                                  ;		       entry do not try to load low if there is no space in
 28751                                  ;		       UMBs.
 28752                                  ;
 28753                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 28754                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 28755                                  ;		       change return address to LeaveDos if AL=5.
 28756                                  ;
 28757                                  ;               20-Jul-1992 bens    Added ifdef RESTRICTED_BUILD code that
 28758                                  ;                      controls building a version of MSDOS.SYS that only
 28759                                  ;                      runs programs from a fixed list (defined in the
 28760                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 28761                                  ;                      for details.  This feature is used to build a
 28762                                  ;                      "special" version of DOS that can be handed out to
 28763                                  ;                      OEM/ISV customers as part of a "service" disk.
 28764                                  ;
 28765                                  ; =========================================================================
 28766                                  
 28767                                  ;SAVEXIT 	EQU	10
 28768                                  
 28769                                  ;BREAK	<$WAIT - return previous process error code>
 28770                                  ; =========================================================================
 28771                                  ;	$WAIT - Return previous process error code.
 28772                                  ;
 28773                                  ;	Assembler usage:
 28774                                  ;
 28775                                  ;	    MOV     AH, WaitProcess
 28776                                  ;	    INT     int_command
 28777                                  ;
 28778                                  ;	ENTRY	none
 28779                                  ;	EXIT	(ax) = exit code
 28780                                  ;	USES	all
 28781                                  ; =========================================================================
 28782                                  
 28783                                  _$WAIT:
 28784                                  	; 02/08/2018 - Retro DOS v3.0
 28785                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 28786                                  
 28787 00005FDB 31C0                    	xor	AX,AX
 28788 00005FDD 368706[E202]            	xchg	AX,[ss:exit_code]
 28789 00005FE2 E918B7                  	jmp	SYS_RET_OK
 28790                                  
 28791                                  ; =========================================================================
 28792                                  ;BREAK <$exec - load/go a program>
 28793                                  ;	EXEC.ASM - EXEC System Call
 28794                                  ;
 28795                                  ;
 28796                                  ; Assembler usage:
 28797                                  ;	    lds     DX, Name
 28798                                  ;	    les     BX, Blk
 28799                                  ;	    mov     AH, Exec
 28800                                  ;	    mov     AL, FUNC
 28801                                  ;	    int     INT_COMMAND
 28802                                  ;
 28803                                  ;	AL  Function
 28804                                  ;	--  --------
 28805                                  ;	 0  Load and execute the program.
 28806                                  ;	 1  Load, create  the  program	header	but  do  not
 28807                                  ;	    begin execution.
 28808                                  ;	 3  Load overlay. No header created.
 28809                                  ;
 28810                                  ;	    AL = 0 -> load/execute program
 28811                                  ;
 28812                                  ;	    +---------------------------+
 28813                                  ;	    | WORD segment address of	|
 28814                                  ;	    | environment.		|
 28815                                  ;	    +---------------------------+
 28816                                  ;	    | DWORD pointer to ASCIZ	|
 28817                                  ;	    | command line at 80h	|
 28818                                  ;	    +---------------------------+
 28819                                  ;	    | DWORD pointer to default	|
 28820                                  ;	    | FCB to be passed at 5Ch	|
 28821                                  ;	    +---------------------------+
 28822                                  ;	    | DWORD pointer to default	|
 28823                                  ;	    | FCB to be passed at 6Ch	|
 28824                                  ;	    +---------------------------+
 28825                                  ;
 28826                                  ;	    AL = 1 -> load program
 28827                                  ;
 28828                                  ;	    +---------------------------+
 28829                                  ;	    | WORD segment address of	|
 28830                                  ;	    | environment.		|
 28831                                  ;	    +---------------------------+
 28832                                  ;	    | DWORD pointer to ASCIZ	|
 28833                                  ;	    | command line at 80h	|
 28834                                  ;	    +---------------------------+
 28835                                  ;	    | DWORD pointer to default	|
 28836                                  ;	    | FCB to be passed at 5Ch	|
 28837                                  ;	    +---------------------------+
 28838                                  ;	    | DWORD pointer to default	|
 28839                                  ;	    | FCB to be passed at 6Ch	|
 28840                                  ;	    +---------------------------+
 28841                                  ;	    | DWORD returned value of	|
 28842                                  ;	    | CS:IP			|
 28843                                  ;	    +---------------------------+
 28844                                  ;	    | DWORD returned value of	|
 28845                                  ;	    | SS:IP			|
 28846                                  ;	    +---------------------------+
 28847                                  ;
 28848                                  ;	    AL = 3 -> load overlay
 28849                                  ;
 28850                                  ;	    +---------------------------+
 28851                                  ;	    | WORD segment address where|
 28852                                  ;	    | file will be loaded.	|
 28853                                  ;	    +---------------------------+
 28854                                  ;	    | WORD relocation factor to |
 28855                                  ;	    | be applied to the image.	|
 28856                                  ;	    +---------------------------+
 28857                                  ;
 28858                                  ; Returns:
 28859                                  ;	    AX = error_invalid_function
 28860                                  ;	       = error_bad_format
 28861                                  ;	       = error_bad_environment
 28862                                  ;	       = error_not_enough_memory
 28863                                  ;	       = error_file_not_found
 28864                                  ; =========================================================================
 28865                                  ;
 28866                                  ;   Revision history:
 28867                                  ;
 28868                                  ;	 A000	version 4.00  Jan. 1988
 28869                                  ;
 28870                                  ; =========================================================================
 28871                                  
 28872                                  Exec_Internal_Buffer		EQU	OPENBUF
 28873                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 28874                                  
 28875                                  ; =========================================================================
 28876                                  
 28877                                  ;IF1		; warning message on buffers
 28878                                  ;%out	Please make sure that the following are contiguous and of the
 28879                                  ;%out	following sizes:
 28880                                  ;%out
 28881                                  ;%out	OpenBuf     128
 28882                                  ;%out	RenBuf	    128
 28883                                  ;%out	SearchBuf    53
 28884                                  ;%out	DummyCDS    curdirLen
 28885                                  ;ENDIF
 28886                                  
 28887                                  ; =========================================================================
 28888                                  
 28889                                  ; =========================================================================
 28890                                  ;
 28891                                  ; =========================================================================
 28892                                  
 28893                                  _$EXEC:
 28894                                  	; 02/08/2018 - Retro DOS v3.0
 28895                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 28896                                  
 28897                                  EXEC001S:
 28898                                  
 28899                                  	;LocalVar    Exec_Blk		,DWORD
 28900                                  	;LocalVar    Exec_Func		,BYTE
 28901                                  	;LocalVar    Exec_Load_High	,BYTE
 28902                                  	;LocalVar    Exec_FH		,WORD
 28903                                  	;LocalVar    Exec_Rel_Fac	,WORD
 28904                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 28905                                  	;LocalVar    Exec_Environ	,WORD
 28906                                  	;LocalVar    Exec_Size		,WORD
 28907                                  	;LocalVar    Exec_Load_Block	,WORD
 28908                                  	;LocalVar    Exec_DMA		,WORD
 28909                                  	;LocalVar    ExecNameLen 	,WORD
 28910                                  	;LocalVar    ExecName		,DWORD
 28911                                  	;
 28912                                  	;LocalVar    Exec_DMA_Save	,WORD
 28913                                  	;LocalVar    Exec_NoStack	,BYTE
 28914                                  
 28915                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28916                                  	;%define	Exec_Blk	dword [bp-4]
 28917                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 28918                                  	%define		Exec_BlkL	word [bp-4]	
 28919                                  	%define		Exec_BlkH	word [bp-2]
 28920                                  	%define		Exec_Func	byte [bp-5]
 28921                                  	%define		Exec_Load_High	byte [bp-6]
 28922                                  	%define		Exec_FH		word [bp-8]
 28923                                  	%define		Exec_Rel_Fac	word [bp-10]
 28924                                  	%define		Exec_Res_Len_Para word [bp-12]
 28925                                  	%define		Exec_Environ	word [bp-14]
 28926                                  	%define		Exec_Size	word [bp-16]
 28927                                  	%define		Exec_Load_Block	word [bp-18]
 28928                                  	%define		Exec_DMA	word [bp-20]
 28929                                  	%define		ExecNameLen	word [bp-22]
 28930                                  	;%define	ExecName	dword [bp-26]
 28931                                  	%define		ExecName	[bp-26] ; 09/08/2018
 28932                                  	%define		ExecNameL	word [bp-26]	
 28933                                  	%define		ExecNameH	word [bp-24]
 28934                                  	; MSDOS 6.0
 28935                                  	%define		Exec_DMA_Save	word [bp-28]
 28936                                  	%define		Exec_NoStack	byte [bp-29]
 28937                                  	
 28938                                  	; ==================================================================
 28939                                  	; validate function
 28940                                  	; ==================================================================
 28941                                  		      	
 28942                                  	;
 28943                                  	; M068 - Start
 28944                                  	;
 28945                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 28946                                  	; possibility that the count may not be decremented all the way to
 28947                                  	; 0. A typical case is if the program for which we intended to keep 
 28948                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 28949                                  	; calls), exits pre-maturely due to error conditions.
 28950                                  	;
 28951                                  
 28952                                  	; MSDOS 6.0
 28953                                  	;mov	byte [SS:A20OFF_COUNT], 0
 28954                                  
 28955                                  	;
 28956                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 28957                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 28958                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 28959                                  	;
 28960                                  	
 28961                                  	;cmp	al, 5			; Q: is this ExecReady call
 28962                                  	;jne	@f			; N: continue
 28963                                  					; Y: change ret addr. to LeaveDos.
 28964                                  	;pop	cx			; Note CX is not input to ExecReady
 28965                                  	;mov	cx, offset DOSCODE:LeaveDos
 28966                                  	;push	cx
 28967                                  ;@@:
 28968                                  	;
 28969                                  	; M068 - End
 28970                                  	;
 28971                                  
 28972                                  	;Enter
 28973                                  
 28974 00005FE5 55                      	push	bp
 28975 00005FE6 89E5                    	mov	bp,sp
 28976 00005FE8 83EC1E                  	sub	sp,30 ; MSDOS 6.0
 28977                                  	;sub	sp,26 ; MSDOS 3.3
 28978                                  
 28979                                  	; MSDOS 6.0
 28980                                  	;cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 28981                                  					; M030
 28982                                  	;jna	short Exec_Check_2
 28983                                  
 28984                                  	; MSDOS 3.3
 28985 00005FEB 3C03                    	cmp	AL,3
 28986 00005FED 760E                    	jna	short Exec_Check_2
 28987                                  
 28988                                  Exec_Bad_Fun:
 28989 00005FEF 36C606[D102]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk 
 28990                                  					; Extended Error Locus	;smr;SS Override
 28991                                  	;mov	al,1
 28992 00005FF5 B001                    	mov	al,error_invalid_function
 28993                                  
 28994                                  Exec_Ret_Err:
 28995                                  	;Leave
 28996 00005FF7 89EC                    	mov	sp,bp
 28997 00005FF9 5D                      	pop	bp
 28998                                  	;transfer SYS_RET_ERR
 28999 00005FFA E909B7                  	jmp	SYS_RET_ERR
 29000                                  
 29001                                  	; MSDOS 6.0
 29002                                  ;ExecReadyJ:
 29003                                  	;call	ExecReady		; M028
 29004                                  	;jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 29005                                  
 29006                                  Exec_Check_2:
 29007 00005FFD 3C02                    	cmp	AL,2			
 29008 00005FFF 74EE                    	jz	short Exec_Bad_Fun
 29009                                  
 29010                                  	; MSDOS 6.0
 29011                                  	;cmp	al,4			; 2 & 4 are not allowed
 29012                                  	;je	short Exec_Bad_Fun
 29013                                  	;
 29014                                  	;cmp	al,5			; M028 ; M030
 29015                                  	;je	short ExecReadyJ		; M028
 29016                                  
 29017                                  	;mov	[bp-4],bx
 29018 00006001 895EFC                  	mov	Exec_BlkL,BX		; stash args
 29019                                  	;mov	[bp-2],es
 29020 00006004 8C46FE                  	mov	Exec_BlkH,ES
 29021                                  	;mov	[bp-5],al
 29022 00006007 8846FB                  	mov	Exec_Func,AL
 29023                                  	;mov	byte [bp-6],0
 29024 0000600A C646FA00                	mov	Exec_Load_High,0
 29025                                  
 29026                                  	;mov	[bp-26],dx
 29027 0000600E 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 29028                                  	;mov	[bp-24],ds
 29029 00006011 8C5EE8                  	mov	ExecNameH,DS
 29030 00006014 89D6                    	mov	SI,DX			; move pointer to convenient place
 29031                                  	;invoke	DStrLen
 29032 00006016 E856BF                  	call	DStrLen
 29033                                  	;mov	[bp-22],cx
 29034 00006019 894EEA                  	mov	ExecNameLen,CX		; save length
 29035                                  
 29036                                  	; MSDOS 6.0
 29037                                  	;mov	al, [AllocMethod]	; M063: save alloc method in 
 29038                                  	;mov	[AllocMsave], al	; M063: AllocMsave
 29039                                  
 29040 0000601C 30C0                    	xor	AL,AL			; open for reading
 29041 0000601E 55                      	push	BP
 29042                                  
 29043                                  	; MSDOS 6.0
 29044                                  	;or	byte [DOS_FLAG], EXECOPEN ; this flag is set to indicate to 
 29045                                  					; the redir that this open call is
 29046                                  					; due to an exec.
 29047                                  
 29048                                  	;invoke	$OPEN			; is the file there?
 29049 0000601F E81510                  	call	_$OPEN
 29050                                  
 29051                                  	; MSDOS 6.0
 29052                                  	;pushf
 29053                                  	;and	byte [DOS_FLAG],~EXECOPEN; reset flag
 29054                                  	;popf
 29055                                  
 29056 00006022 5D                      	pop	BP
 29057                                  	;MSDOS 3.3
 29058 00006023 72D2                    	jc	short Exec_Ret_Err
 29059                                  
 29060                                  	;mov	[bp-8],ax
 29061 00006025 8946F8                  	mov	Exec_FH,AX
 29062 00006028 89C3                    	mov	BX,AX
 29063 0000602A 30C0                    	xor	AL,AL
 29064                                  	;invoke	$Ioctl
 29065 0000602C E880CF                  	call	_$IOCTL
 29066 0000602F 7207                    	jc	short Exec_BombJ
 29067                                  
 29068                                  	;test	dl,80h
 29069 00006031 F6C280                  	test	DL,devid_ISDEV
 29070 00006034 740A                    	jz	short Exec_Check_Environ
 29071                                  
 29072                                  	;mov	al,2
 29073 00006036 B002                    	mov	AL,error_file_not_found
 29074                                  Exec_BombJ:
 29075 00006038 E9CC00                  	jmp	Exec_Bomb
 29076                                  
 29077                                  BadEnv:
 29078                                  	;mov	al,0Ah
 29079 0000603B B00A                    	mov	AL,error_bad_environment
 29080 0000603D E9C700                  	jmp	Exec_Bomb
 29081                                  
 29082                                  Exec_Check_Environ:
 29083                                  	;mov	word [bp-18],0
 29084 00006040 C746EE0000              	mov	Exec_Load_Block,0
 29085                                  	;mov	word [bp-14],0
 29086 00006045 C746F20000              	mov	Exec_Environ,0
 29087                                  					; overlays... no environment
 29088                                  	;test	byte [bp-5],2
 29089 0000604A F646FB02                	test	Exec_Func,exec_func_overlay
 29090 0000604E 7554                    	jnz	short Exec_Read_Header
 29091                                  
 29092                                  	;lds	si,[bp-4]
 29093 00006050 C576FC                  	lds	SI,Exec_Blk		; get block
 29094 00006053 8B04                    	mov	ax,[SI]
 29095                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 29096 00006055 09C0                    	or	AX,AX
 29097 00006057 750C                    	jnz	short Exec_Scan_Env
 29098                                  
 29099 00006059 368E1E[DE02]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 29100                                  	;mov	ax,[44]
 29101 0000605E A12C00                  	mov	AX,[PDB.ENVIRON]
 29102                                  
 29103                                  ; MSDOS 6.0
 29104                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 29105                                  ;
 29106                                  ; Exec_environ is being correctly initialized after the environment has been
 29107                                  ; allocated and copied form the parent's env. It must not be initialized here.
 29108                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 29109                                  ; parent's environment.
 29110                                  ;	mov	Exec_Environ,AX
 29111                                  ;
 29112                                  ;----------------------------------------------------------------------------
 29113                                  
 29114                                  	;mov	[bp-14],ax
 29115                                  	;mov	Exec_Environ,ax
 29116                                  
 29117 00006061 09C0                    	or	AX,AX
 29118 00006063 743F                    	jz	short Exec_Read_Header
 29119                                  
 29120                                  Exec_Scan_Env:
 29121 00006065 8EC0                    	mov	ES,AX
 29122 00006067 31FF                    	xor	DI,DI
 29123                                  	;mov	cx,7FFFh ; MSDOS 3.3
 29124 00006069 B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 29125 0000606C 30C0                    	xor	AL,AL
 29126                                  
 29127                                  Exec_Get_Environ_Len:
 29128 0000606E F2AE                    	repnz	scasb			; find that nul byte
 29129 00006070 75C9                    	jnz	short BadEnv
 29130                                  
 29131 00006072 49                      	dec	CX			; Dec CX for the next nul byte test
 29132 00006073 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 29133                                  
 29134 00006075 AE                      	scasb				; is there another nul byte?
 29135 00006076 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 29136                                  
 29137 00006078 57                      	push	DI
 29138                                  	;lea	bx,[DI+11h]
 29139 00006079 8D5D11                  	lea	BX,[DI+0Fh+2]
 29140                                  	;add	bx,[bp-22]
 29141 0000607C 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 29142                                  					; remember argv[0] length
 29143                                  					; round up and remember argc
 29144 0000607F B104                    	mov	CL,4
 29145 00006081 D3EB                    	shr	BX,CL			; number of paragraphs needed
 29146 00006083 06                      	push	ES
 29147                                  	;invoke	$Alloc			; can we get the space?
 29148 00006084 E8CA04                  	call	_$ALLOC
 29149 00006087 1F                      	pop	DS
 29150 00006088 59                      	pop	CX
 29151 00006089 7302                    	jnc	short Exec_Save_Environ
 29152                                  
 29153 0000608B EB74                    	jmp	SHORT Exec_No_Mem	; nope... cry and sob
 29154                                  
 29155                                  Exec_Save_Environ:
 29156 0000608D 8EC0                    	mov	ES,AX
 29157                                  	;mov	[bp-14],ax
 29158 0000608F 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 29159 00006092 31F6                    	xor	SI,SI
 29160 00006094 89F7                    	mov	DI,SI
 29161 00006096 F3A4                    	rep	movsb			; copy the environment
 29162 00006098 B80100                  	mov	AX,1
 29163 0000609B AB                      	stosw
 29164                                  	;lds	si,[bp-26]
 29165 0000609C C576E6                  	lds	SI,ExecName
 29166                                  	;mov	cx,[bp-22]
 29167 0000609F 8B4EEA                  	mov	CX,ExecNameLen
 29168 000060A2 F3A4                    	rep	movsb
 29169                                  
 29170                                  Exec_Read_Header:
 29171                                  	; We read in the program header into the above data area and
 29172                                  	; determine where in this memory the image will be located.
 29173                                  
 29174                                  	;Context DS
 29175 000060A4 16                      	push	ss
 29176 000060A5 1F                      	pop	ds
 29177                                  	;mov	cx,26
 29178 000060A6 B91A00                  	mov	CX,Exec_Header_Len	; header size
 29179 000060A9 BA[1E14]                	mov	DX,exec_signature
 29180 000060AC 06                      	push	ES
 29181 000060AD 1E                      	push	DS
 29182 000060AE E87803                  	call	ExecRead
 29183 000060B1 1F                      	pop	DS
 29184 000060B2 07                      	pop	ES
 29185 000060B3 7250                    	jc	short Exec_Bad_File
 29186                                  
 29187 000060B5 09C0                    	or	AX,AX
 29188 000060B7 744C                    	jz	short Exec_Bad_File
 29189                                  	;cmp	ax,26
 29190 000060B9 83F81A                  	cmp	AX,Exec_Header_Len	; did we read the right number?
 29191 000060BC 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 29192                                  
 29193 000060BE F706[2A14]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 29194 000060C4 7504                    	jnz	short Exec_Check_Sig
 29195                                  
 29196                                  	;mov	byte [bp-6],0FFh
 29197 000060C6 C646FAFF                	mov	Exec_Load_High,-1
 29198                                  
 29199                                  Exec_Check_Sig:
 29200 000060CA A1[1E14]                	mov	AX,[exec_signature]	; rms;NSS
 29201                                  	;cmp	ax,5A4Dh ; 'MZ'
 29202 000060CD 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 29203 000060D0 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 29204                                  
 29205                                  	;cmp	ax,4D5Ah ; 'ZM'
 29206 000060D2 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 29207 000060D5 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 29208                                  
 29209                                  Exec_Com_Filej:
 29210 000060D7 E9A201                  	jmp	Exec_Com_File
 29211                                  
 29212                                  	; We have the program header... determine memory requirements
 29213                                  
 29214                                  Exec_Save_Start:
 29215 000060DA A1[2214]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 29216 000060DD B105                    	mov	CL,5			; convert to paragraphs
 29217 000060DF D3E0                    	shl	AX,CL
 29218 000060E1 2B06[2614]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs;rms;NSS
 29219                                  	;mov	[bp-12],ax
 29220 000060E5 8946F4                  	mov	Exec_Res_Len_Para,AX
 29221                                  
 29222                                  		; Do we need to allocate memory?
 29223                                  		; Yes if function is not load-overlay
 29224                                  
 29225                                  	;test	byte [bp-5],2
 29226 000060E8 F646FB02                	test	Exec_Func,exec_func_overlay
 29227 000060EC 742C                    	jz	short Exec_Allocate	; allocation of space
 29228                                  
 29229                                  		; get load address from block
 29230                                  
 29231                                  	;les	di,[bp-4]
 29232 000060EE C47EFC                  	les	DI,Exec_Blk
 29233 000060F1 268B05                  	mov	ax,[es:di]
 29234                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 29235                                  	;mov	[bp-20],ax
 29236 000060F4 8946EC                  	mov	Exec_DMA,AX
 29237 000060F7 268B4502                	mov	AX,[ES:DI+EXEC3.reloc_fac]
 29238                                  	;mov	[bp-10],ax
 29239 000060FB 8946F6                  	mov	Exec_Rel_Fac,AX
 29240                                  	; 10/08/2018
 29241 000060FE E9AB00                  	jmp	Exec_Find_Res		; M000
 29242                                  
 29243                                  Exec_No_Mem:
 29244                                  	;mov	al,8
 29245 00006101 B008                    	mov	AL,error_not_enough_memory
 29246 00006103 EB02                    	jmp	short Exec_Bomb
 29247                                  
 29248                                  Exec_Bad_File:
 29249                                  	;mov	al,0Bh
 29250 00006105 B00B                    	mov	AL,error_bad_format
 29251                                  
 29252                                  Exec_Bomb:
 29253                                  	;mov	bx,[bp-8]
 29254 00006107 8B5EF8                  	mov	BX,Exec_FH
 29255 0000610A E82B03                  	call	Exec_Dealloc
 29256                                  	;LeaveCrit CritMem
 29257 0000610D E85BBF                  	call	LcritMem
 29258                                  	;save	<AX,BP>
 29259 00006110 50                      	push	ax
 29260 00006111 55                      	push	bp
 29261                                  	;invoke	$CLOSE
 29262 00006112 E8B10C                  	call	_$CLOSE
 29263                                  	;restore <BP,AX>
 29264 00006115 5D                      	pop	bp
 29265 00006116 58                      	pop	ax
 29266 00006117 E9DDFE                  	jmp	Exec_Ret_Err
 29267                                  
 29268                                  Exec_Chk_Mem: 
 29269                                  	; MSDOS 6.0    			; M063 - Start
 29270                                  	;mov	al,[AllocMethod]	; save current alloc method in ax
 29271                                  	;mov	bl,[AllocMsave]
 29272                                  	;mov	[AllocMethod], bl	; restore original allocmethod
 29273                                  	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
 29274                                  	;jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 29275                                  	;				; N: continue
 29276                                  	;
 29277                                  	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 29278                                  	;jz	short Exec_No_Mem	; N: no memory 
 29279                                  	;mov	ax,[save_AX]		; Y: restore ax and
 29280                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 29281                                  	;				; M063 - End
 29282                                  
 29283                                  Exec_Allocate:
 29284                                  	; 09/09/2018
 29285                                  
 29286                                  	; M005 - START
 29287                                  	; If there is no STACK segment for this exe file and if this
 29288                                  	; not an overlay and the resident size is less than 64K - 
 29289                                  	; 256 bytes we shall add 256bytes bytes to the programs 
 29290                                  	; resident memory requirement and set Exec_SP to this value.
 29291                                  
 29292                                  	; MSDOS 6.0
 29293 0000611A C646E300                	mov	Exec_NoStack,0
 29294 0000611E 833E[2C14]00            	cmp	word [exec_SS],0	; Q: is there a stack seg
 29295 00006123 7512                    	jne	short ea1		; Y: continue normal processing
 29296 00006125 833E[2E14]00            	cmp	word [exec_SP],0	; Q: is there a stack ptr
 29297 0000612A 750B                    	jne	short ea1		; Y: continue normal processing
 29298                                  
 29299 0000612C FE46E3                  	inc	Exec_NoStack
 29300 0000612F 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 29301 00006132 7303                    	jae	short ea1		; Y: don't set Exec_SP
 29302                                  
 29303 00006134 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 29304                                  ea1:
 29305                                  	; M005 - END
 29306                                  
 29307                                  	; MSDOS 6.0			; M000 - start
 29308                                  	;test	byte [AllocMethod],HIGH_FIRST
 29309                                  	;				; Q: is the alloc strat high_first
 29310                                  	;jz	short Exec_Norm_Alloc	; N: normal allocate
 29311                                  	;				; Y: set high_only bit
 29312                                  	;or	byte [AllocMethod],HIGH_ONLY
 29313                                  	;				; M000 - end
 29314                                  
 29315                                  ;Exec_Norm_Alloc:
 29316                                  	;mov	[save_ax],ax		; M000: save ax for possible 2nd  
 29317                                  					; M000: attempt at allocating memory
 29318                                  	;;push	ax			; M000
 29319                                  
 29320                                  	; MSDOS 3.3
 29321 00006137 50                      	push	ax	
 29322                                  
 29323 00006138 BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 29324 0000613B 1E                      	push	DS
 29325                                  	;invoke	$Alloc			; should have carry set and BX has max
 29326 0000613C E81204                  	call	_$ALLOC
 29327 0000613F 1F                      	pop	DS
 29328                                  
 29329                                  	; MSDOS 6.0
 29330                                  	;mov	ax,[save_ax]		; M000
 29331                                  	;;pop	AX			; M000
 29332                                  
 29333                                  	; MSDOS 3.3
 29334 00006140 58                      	pop	ax
 29335                                  
 29336 00006141 83C010                  	add	AX,10h			; room for header
 29337 00006144 83FB11                  	cmp	BX,11h			; enough room for a header
 29338                                  	; MSDOS 6.0
 29339                                  	;jb	short Exec_Chk_Mem	; M000
 29340                                  	; MSDOS 3.3	
 29341 00006147 72B8                    	jb	short Exec_No_Mem
 29342                                  
 29343 00006149 39D8                    	cmp	AX,BX			; is there enough for bare image?
 29344                                  	; MSDOS 6.0
 29345                                  	;ja	short Exec_Chk_Mem	; M000
 29346                                  	; MSDOS 3.3
 29347 0000614B 77B4                    	ja	short Exec_No_Mem
 29348                                  
 29349                                  	;test	byte [bp-6],0FFh
 29350 0000614D F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 29351 00006151 7518                    	jnz	short Exec_BX_Max	; use max
 29352                                  
 29353                                  	; 09/09/2018
 29354                                  
 29355 00006153 0306[2814]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 29356                                  	; MSDOS 6.0
 29357                                  	;jc	short Exec_Chk_Mem		; M000
 29358                                  	; MSDOS 3.3
 29359 00006157 72A8                    	jc	short Exec_No_Mem
 29360                                  
 29361 00006159 39D8                    	cmp	AX,BX			; enough space?
 29362                                  	; MSDOS 6.0
 29363                                  	;ja	short Exec_Chk_Mem	; M000: nope...	
 29364                                  	; MSDOS 3.3
 29365 0000615B 77A4                    	ja	short Exec_No_Mem
 29366                                  
 29367 0000615D 2B06[2814]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 29368 00006161 0306[2A14]              	add	AX,[exec_max_BSS] 	; go for the MAX
 29369 00006165 7204                    	jc	short Exec_BX_Max
 29370                                  
 29371 00006167 39D8                    	cmp	AX,BX
 29372 00006169 7602                    	jbe	short Exec_Got_Block
 29373                                  
 29374                                  Exec_BX_Max:
 29375 0000616B 89D8                    	mov	AX,BX
 29376                                  
 29377                                  Exec_Got_Block:
 29378                                  	; 03/08/2018 - Retro DOS v3.0
 29379                                  
 29380 0000616D 1E                      	push	DS
 29381 0000616E 89C3                    	mov	BX,AX
 29382                                  	;mov	[bp-16],bx
 29383 00006170 895EF0                  	mov	Exec_Size,BX
 29384                                  	;invoke	$Alloc			; get the space
 29385 00006173 E8DB03                  	call	_$ALLOC
 29386 00006176 1F                      	pop	DS
 29387                                  	; MSDOS 6.0
 29388                                  	;jc	short Exec_Chk_Mem	; M000
 29389                                  	; MSDOS 3.3
 29390 00006177 7288                    	jc	short Exec_No_Mem
 29391                                  
 29392                                  	; MSDOS 6.0
 29393                                  	;mov	cl,[AllocMsave]		; M063: 
 29394                                  	;mov	[AllocMethod],cl	; M063: restore allocmethod
 29395                                  
 29396                                  ;M029; Begin changes
 29397                                  ; This code does special handling for programs with no stack segment. If so,
 29398                                  ;check if the current block is larger than 64K. If so, we do not modify
 29399                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 29400                                  ;case Exec_SS is not changed.
 29401                                  ;
 29402                                  	; MSDOS 6.0
 29403 00006179 807EE300                	cmp	Exec_NoStack,0
 29404                                  	;je	@f
 29405 0000617D 7412                    	je	short ea2
 29406                                  
 29407 0000617F 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 29408                                  	;jae	@f			; Y: Exec_SP = 0
 29409 00006183 730C                    	jae	short ea2
 29410                                  ;
 29411                                  ;Make Exec_SP point at the top of the memory block
 29412                                  ;
 29413 00006185 B104                    	mov	cl,4
 29414 00006187 D3E3                    	shl	bx,cl			; get byte offset
 29415 00006189 81EB0001                	sub	bx,100h			; take care of PSP
 29416 0000618D 891E[2E14]              	mov	[exec_SP],bx		; Exec_SP = top of block
 29417                                  ea2:
 29418                                  ;@@:
 29419                                  ;
 29420                                  ;M029; end changes
 29421                                  ;
 29422                                  	;mov	[bp-18],ax
 29423 00006191 8946EE                  	mov	Exec_Load_Block,AX
 29424 00006194 83C010                  	add	AX,10h
 29425                                  	;test	byte [bp-6],0FFh
 29426 00006197 F646FAFF                	test	Exec_Load_High,-1
 29427 0000619B 7409                    	jz	short Exec_Use_AX	; use ax for load info
 29428                                  
 29429                                  	;add	ax,[bp-16]
 29430 0000619D 0346F0                  	add	AX,Exec_Size		; go to end
 29431                                  	;sub	ax,[bp-12]
 29432 000061A0 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 29433 000061A3 83E810                  	sub	AX,10h			; drop off pdb
 29434                                  
 29435                                  Exec_Use_AX:
 29436                                  	;mov	[bp-10],ax
 29437 000061A6 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 29438                                  	;mov	[bp-20],ax
 29439 000061A9 8946EC                  	mov	Exec_DMA,AX		; beginning of dma
 29440                                  
 29441                                  	; Determine the location in the file of the beginning of
 29442                                  	; the resident
 29443                                  
 29444                                  Exec_Find_Res:
 29445                                  	; MSDOS 6.0
 29446                                  	;mov	dx,[bp-20]
 29447 000061AC 8B56EC                  	mov	DX,Exec_DMA
 29448                                  	;mov	[bp-28],dx
 29449 000061AF 8956E4                  	mov	Exec_DMA_Save,DX
 29450                                  
 29451                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29452 000061B2 8B16[2614]              	mov	DX,[exec_par_dir]
 29453 000061B6 52                      	push	DX
 29454 000061B7 B104                    	mov	CL,4
 29455 000061B9 D3E2                    	shl	DX,CL			; low word of location
 29456 000061BB 58                      	pop	AX
 29457 000061BC B10C                    	mov	CL,12
 29458 000061BE D3E8                    	shr	AX,CL			; high word of location
 29459 000061C0 89C1                    	mov	CX,AX			; CX <- high
 29460                                  
 29461                                  		; Read in the resident image (first, seek to it)
 29462                                  	;mov	bx,[bp-8]
 29463 000061C2 8B5EF8                  	mov	BX,Exec_FH
 29464 000061C5 1E                      	push	DS
 29465 000061C6 30C0                    	xor	AL,AL
 29466                                  	;invoke	$Lseek			; Seek to resident
 29467 000061C8 E86D0D                  	call	_$LSEEK
 29468 000061CB 1F                      	pop	DS
 29469 000061CC 7303                    	jnc	short Exec_Big_Read
 29470                                  
 29471 000061CE E936FF                  	jmp	Exec_Bomb
 29472                                  
 29473                                  Exec_Big_Read:				; Read resident into memory
 29474                                  	;mov	bx,[bp-12]
 29475 000061D1 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 29476 000061D4 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 29477 000061D8 7203                    	jb	short Exec_Read_OK
 29478                                  
 29479 000061DA BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 29480                                  
 29481                                  Exec_Read_OK:
 29482                                  	;sub	[bp-12],bx
 29483 000061DD 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 29484 000061E0 53                      	push	BX
 29485 000061E1 B104                    	mov	CL,4
 29486 000061E3 D3E3                    	shl	BX,CL			; Get count in bytes from paras
 29487 000061E5 89D9                    	mov	CX,BX			; Count in correct register
 29488 000061E7 1E                      	push	DS
 29489                                  	;mov	ds,[bp-20]
 29490 000061E8 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 29491                                  
 29492 000061EB 31D2                    	xor	DX,DX
 29493 000061ED 51                      	push	CX			; Save our count
 29494 000061EE E83802                  	call	ExecRead
 29495 000061F1 59                      	pop	CX			; Get old count to verify
 29496 000061F2 1F                      	pop	DS
 29497 000061F3 7248                    	jc	short Exec_Bad_FileJ
 29498                                  
 29499 000061F5 39C1                    	cmp	CX,AX			; Did we read enough?
 29500 000061F7 5B                      	pop	BX			; Get paragraph count back
 29501 000061F8 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 29502                                  
 29503                                  	; The read did not match the request. If we are off by 512
 29504                                  	; bytes or more then the header lied and we have an error.
 29505                                  
 29506 000061FA 29C1                    	sub	CX,AX
 29507 000061FC 81F90002                	cmp	CX,512
 29508 00006200 733B                    	jae	short Exec_Bad_FileJ
 29509                                  
 29510                                  	; We've read in CX bytes... bump DTA location
 29511                                  
 29512                                  ExecCheckEnd:
 29513                                  	;add	[bp-20],bx
 29514 00006202 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 29515                                  	;test	word [bp-12],0FFFFh
 29516 00006205 F746F4FFFF              	test	Exec_Res_Len_Para,-1
 29517 0000620A 75C5                    	jnz	short Exec_Big_Read
 29518                                  
 29519                                  	; The image has now been read in. We must perform relocation
 29520                                  	; to the current location.
 29521                                  
 29522                                  exec_do_reloc:
 29523                                  	;mov	cx,[bp-10]
 29524 0000620C 8B4EF6                  	mov	CX,Exec_Rel_Fac
 29525 0000620F A1[2C14]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 29526 00006212 01C8                    	add	AX,CX			; and relocate him
 29527 00006214 A3[1814]                	mov	[exec_init_SS],AX 	; rms;NSS
 29528                                  
 29529 00006217 A1[2E14]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 29530 0000621A A3[1614]                	mov	[exec_init_SP],AX 	; rms;NSS
 29531                                  
 29532 0000621D C406[3214]              	les	AX,[exec_IP]		; rms;NSS
 29533 00006221 A3[1A14]                	mov	[exec_init_IP],AX 	; rms;NSS
 29534 00006224 8CC0                    	mov	AX,ES			; rms;NSS
 29535 00006226 01C8                    	add	AX,CX			; relocated...
 29536 00006228 A3[1C14]                	mov	[exec_init_CS],AX 	; rms;NSS
 29537                                  
 29538 0000622B 31C9                    	xor	CX,CX
 29539 0000622D 8B16[3614]              	mov	DX,[exec_rle_table]	; rms;NSS
 29540                                  	;mov	bx,[bp-8]
 29541 00006231 8B5EF8                  	mov	BX,Exec_FH
 29542 00006234 1E                      	push	DS
 29543 00006235 31C0                    	xor	AX,AX
 29544                                  	;invoke	$Lseek
 29545 00006237 E8FE0C                  	call	_$LSEEK
 29546 0000623A 1F                      	pop	DS
 29547 0000623B 7303                    	jnc	short exec_get_entries
 29548                                  
 29549                                  Exec_Bad_FileJ:
 29550 0000623D E9C5FE                  	jmp	Exec_Bad_File
 29551                                  
 29552                                  exec_get_entries:
 29553 00006240 8B16[2414]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 29554                                  
 29555                                  exec_read_reloc:
 29556 00006244 52                      	push	DX
 29557                                  	;mov	dx,OPENBUF
 29558 00006245 BA[6003]                	mov	DX,Exec_Internal_Buffer
 29559                                  	;mov	cx,388
 29560 00006248 B98401                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (390>>2)<<2
 29561 0000624B 1E                      	push	DS
 29562 0000624C E8DA01                  	call	ExecRead
 29563 0000624F 07                      	pop	ES
 29564 00006250 5A                      	pop	DX
 29565 00006251 72EA                    	jc	short Exec_Bad_FileJ
 29566                                  
 29567                                  	;mov	cx,97
 29568 00006253 B96100                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (390>>2)
 29569                                  					; Pointer to byte location in header
 29570                                  	;mov	di,OPENBUF
 29571 00006256 BF[6003]                	mov	DI,Exec_Internal_Buffer
 29572                                  	;mov	si,[bp-10]
 29573 00006259 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 29574                                  
 29575                                  exec_reloc_one:
 29576 0000625C 09D2                    	or	DX,DX			; Any more entries?
 29577 0000625E 7416                    	jz	short Exec_Set_PDBJ
 29578                                  
 29579                                  exec_get_addr:
 29580 00006260 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 29581 00006263 8CD8                    	mov	AX,DS			; Relocate address of item
 29582                                  
 29583                                  	; MSDOS 6.0
 29584                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 29585                                  	;add	ax,[bp-28]
 29586 00006265 0346E4                  	add	AX,Exec_DMA_Save
 29587                                  
 29588 00006268 8ED8                    	mov	DS,AX
 29589 0000626A 0137                    	add	[BX],SI
 29590 0000626C 83C704                  	add	DI,4
 29591 0000626F 4A                      	dec	DX
 29592 00006270 E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 29593                                  
 29594                                  	; We've exhausted a single buffer's worth. Read in the next
 29595                                  	; piece of the relocation table.
 29596                                  
 29597 00006272 06                      	push	ES
 29598 00006273 1F                      	pop	DS
 29599 00006274 EBCE                    	jmp	short exec_read_reloc
 29600                                  
 29601                                  Exec_Set_PDBJ:
 29602                                  
 29603                                  	; MSDOS 6.0
 29604                                  	;
 29605                                  	; We now determine if this is a buggy exe packed file and if 
 29606                                  	; so we patch in the right code. Note that fixexepatch will
 29607                                  	; point to a ret if dos loads low. The load segment as 
 29608                                  	; determined above will be in exec_dma_save
 29609                                  	;
 29610                                  	;push	es
 29611                                  	;push	ax			; M030
 29612                                  	;push	cx			; M030
 29613                                  	;mov	es,Exec_DMA_Save
 29614                                  	;mov	ax,[exec_init_CS]	; M030
 29615                                  	;mov	cx,[exec_init_IP]	; M030
 29616                                  	;call	word [fixexepatch]
 29617                                  	;call	word [Rational386PatchPtr]
 29618                                  	;pop	cx			; M030
 29619                                  	;pop	ax			; M030
 29620                                  	;pop	es
 29621                                  
 29622 00006276 E99D00                  	jmp	Exec_Set_PDB
 29623                                  
 29624                                  Exec_No_Memj:
 29625 00006279 E985FE                  	jmp	Exec_No_Mem
 29626                                  
 29627                                  	; we have a .COM file.	First, determine if we are merely
 29628                                  	; loading an overlay.
 29629                                  
 29630                                  Exec_Com_File:
 29631                                  	;test	byte [bp-5],2
 29632 0000627C F646FB02                	test	Exec_Func,exec_func_overlay
 29633 00006280 740C                    	jz	short Exec_Alloc_Com_File
 29634                                  	;lds	si,[bp-4]
 29635 00006282 C576FC                  	lds	SI,Exec_Blk		; get arg block
 29636 00006285 AD                      	lodsw				; get load address
 29637                                  	;mov	[bp-20],ax
 29638 00006286 8946EC                  	mov	Exec_DMA,AX
 29639 00006289 B8FFFF                  	mov	AX,0FFFFh
 29640 0000628C EB34                    	jmp	SHORT Exec_Read_Block	; read it all!
 29641                                  
 29642                                  Exec_Chk_Com_Mem:			
 29643                                  	; MSDOS 6.0	     		; M063 - Start
 29644                                  	;mov	al,[AllocMethod]	; save current alloc method in ax
 29645                                  	;mov	bl,[AllocMsave]
 29646                                  	;mov	[AllocMethod],bl	; restore original allocmethod
 29647                                  	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
 29648                                  	;jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 29649                                  	;				; N: continue
 29650                                  	;
 29651                                  	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 29652                                  	;jz	short Exec_No_Memj	; N: no memory 
 29653                                  	;
 29654                                  	;mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 29655                                  	;xor	bx,bx			; M047: bx => free arena
 29656                                  	;call	ChangeOwner		; M047: free this block
 29657                                  	;
 29658                                  	;jmp	short Exec_Norm_Com_Alloc
 29659                                  	;				; M063 - End
 29660                                  	
 29661                                  	; We must allocate the max possible size block (ick!)
 29662                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 29663                                  	; size of block.
 29664                                  
 29665                                  Exec_Alloc_Com_File:
 29666                                  
 29667                                  	; MSDOS 6.0			; M000 -start
 29668                                  	;test	byte [AllocMethod],HIGH_FIRST
 29669                                  	;				; Q: is the alloc strat high_first
 29670                                  	;jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 29671                                  	;				; Y: set high_only bit
 29672                                  	;or	byte [AllocMethod],HIGH_ONLY
 29673                                  	;				; M000 - end
 29674                                  ;Exec_Norm_Com_Alloc:			; M000
 29675                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29676 0000628E BBFFFF                  	mov	BX,0FFFFh
 29677                                  	;invoke	$Alloc			; largest piece available as error
 29678 00006291 E8BD02                  	call	_$ALLOC
 29679 00006294 09DB                    	or	BX,BX
 29680                                  	; MSDOS 6.0
 29681                                  	;jz	short Exec_Chk_Com_Mem	; M000
 29682                                  	; MSDOS 3.3
 29683 00006296 74E1                    	jz	short Exec_No_Memj
 29684                                  
 29685                                  	;mov	[bp-16],bx
 29686 00006298 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 29687 0000629B 53                      	push	BX
 29688                                  	;invoke	$ALLOC			; largest piece available as error
 29689 0000629C E8B202                  	call	_$ALLOC
 29690 0000629F 5B                      	pop	BX			; get size of block...
 29691                                  	;mov	[bp-18],ax
 29692 000062A0 8946EE                  	mov	Exec_Load_Block,AX
 29693 000062A3 83C010                  	add	AX,10h			; increment for header
 29694                                  	;mov	[bp-20],ax
 29695 000062A6 8946EC                  	mov	Exec_DMA,AX
 29696 000062A9 31C0                    	xor	AX,AX			; presume 64K read...
 29697 000062AB 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 29698 000062AF 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 29699                                  
 29700 000062B1 89D8                    	mov	AX,BX			; convert size to bytes
 29701 000062B3 B104                    	mov	CL,4
 29702 000062B5 D3E0                    	shl	AX,CL
 29703                                  	; MSDOS 6.0
 29704 000062B7 3D0002                          cmp     AX,200h                 ; enough memory for PSP and stack?
 29705                                  ;	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 29706                                  ;	;jbe	short Exec_No_Memj	; M000: jump if not
 29707                                  	; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 29708                                  	;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 29709 000062BA 76BD                    	jbe	short Exec_No_Memj	; M000: jump if not
 29710                                  
 29711                                  					; M047: size of the block is < 64K
 29712 000062BC 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 29713                                  
 29714                                  Exec_Read_Com:
 29715                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29716 000062BF 2D0001                  	sub	AX,100h 		; remember size of psp
 29717                                  
 29718                                  Exec_Read_Block:
 29719 000062C2 50                      	push	AX			; save number to read
 29720                                  	;mov	bx,[bp-8]
 29721 000062C3 8B5EF8                  	mov	BX,Exec_FH		; of com file
 29722 000062C6 31C9                    	xor	CX,CX			; but seek to 0:0
 29723 000062C8 89CA                    	mov	DX,CX
 29724 000062CA 31C0                    	xor	AX,AX			; seek relative to beginning
 29725                                  	;invoke	$Lseek			; back to beginning of file
 29726 000062CC E8690C                  	call	_$LSEEK
 29727 000062CF 59                      	pop	CX			; number to read
 29728                                  	;mov	ds,[bp-20]
 29729 000062D0 8E5EEC                  	mov	DS,Exec_DMA
 29730 000062D3 31D2                    	xor	DX,DX
 29731 000062D5 51                      	push	CX
 29732 000062D6 E85001                  	call	ExecRead
 29733 000062D9 5E                      	pop	SI			; get number of bytes to read
 29734 000062DA 7303                    	jnc	short OkRead
 29735                                  
 29736 000062DC E926FE                  	jmp	Exec_Bad_File
 29737                                  
 29738                                  	; 10/09/2018
 29739                                  OkRead:
 29740 000062DF 39F0                    	cmp	AX,SI			; did we read them all?
 29741                                  	; MSDOS 6.0
 29742                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 29743                                  	; MSDOS 3.3
 29744 000062E1 7496                    	jz	short Exec_No_Memj	; M00: exactly the wrong number...
 29745                                  	
 29746                                  	; MSDOS 6.0
 29747                                  	;mov	bl,[AllocMsave]		; M063
 29748                                  	;mov	[AllocMethod],bl	; M063: restore allocmethod
 29749                                  
 29750                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29751                                  	;test	byte [bp-5],2
 29752 000062E3 F646FB02                	test	Exec_Func,exec_func_overlay
 29753 000062E7 752D                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 29754                                  
 29755                                  	;mov	ax,[bp-20]
 29756 000062E9 8B46EC                  	mov	AX,Exec_DMA
 29757 000062EC 83E810                  	sub	AX,10h
 29758 000062EF 36A3[1C14]              	mov	[SS:exec_init_CS],AX
 29759 000062F3 36C706[1A14]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 29760                                  
 29761                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 29762                                  	; of 0 on stack.
 29763                                  
 29764 000062FA 81C6FE00                	add	SI,0FEh 		; make room for stack
 29765                                  
 29766                                  	; MSDOS 6.0
 29767 000062FE 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 29768 00006301 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 29769 00006303 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 29770                                  
 29771                                  Exec_St_Ok:
 29772                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29773 00006307 368936[1614]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 29774 0000630C 36A3[1814]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 29775 00006310 8ED8                    	mov	DS,AX
 29776 00006312 C7040000                	mov	WORD [SI],0		; 0 for return
 29777                                  
 29778                                  	; MSDOS 6.0
 29779                                  	;
 29780                                  	; M068
 29781                                  	;
 29782                                  	; We now determine if this is a Copy Protected App. If so the 
 29783                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 29784                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 29785                                  
 29786                                  	;call	word ptr [ChkCopyProt]	
 29787                                  
 29788                                  Exec_Set_PDB:
 29789                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29790                                  	;mov	bx,[bp-8]
 29791 00006316 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 29792 00006319 E81C01                  	call	Exec_Dealloc
 29793 0000631C 55                      	push	BP
 29794                                  	;invoke	$Close			; release the jfn
 29795 0000631D E8A60A                  	call	_$CLOSE
 29796 00006320 5D                      	pop	BP
 29797 00006321 E81F01                  	call	Exec_Alloc
 29798                                  	;test	byte [bp-5],2
 29799 00006324 F646FB02                	test	Exec_Func,exec_func_overlay
 29800 00006328 7406                    	jz	short Exec_Build_Header
 29801                                  
 29802                                  	; MSDOS 6.0
 29803                                  	;call	Scan_Execname
 29804                                  	;call	Scan_Special_Entries
 29805                                  	;
 29806                                  ;SR;
 29807                                  ;The current lie strategy uses the PSP to store the lie version. However,
 29808                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 29809                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 29810                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 29811                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 29812                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 29813                                  ;issues the version check, it gets the lie version until the next overlay
 29814                                  ;call is issued.
 29815                                  ;
 29816                                  	;cmp	DriverLoad,0		;was Sysinit processing done?
 29817                                  	;je	norm_ovl		;yes, no special handling
 29818                                  	;push	si
 29819                                  	;push	es
 29820                                  	;les	si,BiosDataPtr		;get ptr to BIOS data block
 29821                                  	;cmp	byte ptr es:[si],0		;in Sysinit?
 29822                                  	;je	sysinit_done		;no, Sysinit is finished
 29823                                  	;
 29824                                  	;mov	es,CurrentPDB		;es = current PSP (Sysinit PSP)
 29825                                  	;push	Special_Version
 29826                                  	;pop	es:PDB_Version		;store lie version in Sysinit PSP
 29827                                  		;;; PDB.VERSION
 29828                                  	;jmp	short setver_done
 29829                                  ;sysinit_done:
 29830                                  	;mov	DriverLoad,0		;Sysinit done,special handling off
 29831                                  ;setver_done:
 29832                                  	;pop	es
 29833                                  	;pop	si
 29834                                  ;norm_ovl:
 29835                                  
 29836                                  	;leave
 29837 0000632A 89EC                    	mov	sp,bp		
 29838 0000632C 5D                      	pop	bp
 29839                                  
 29840                                  	;transfer SYS_RET_OK		; overlay load -> done
 29841 0000632D E9CDB3                  	jmp	SYS_RET_OK
 29842                                  
 29843                                  Exec_Build_Header:
 29844                                  	;mov	dx,[bp-18]
 29845 00006330 8B56EE                  	mov	DX,Exec_Load_Block
 29846                                  					; assign the space to the process
 29847                                  	;mov	si,1
 29848 00006333 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 29849                                  	;mov	ax,[bp-14]
 29850 00006336 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 29851 00006339 09C0                    	or	AX,AX
 29852 0000633B 7405                    	jz	short No_Owner		; no environment
 29853                                  
 29854 0000633D 48                      	dec	AX			; point to header
 29855 0000633E 8ED8                    	mov	DS,AX
 29856 00006340 8914                    	mov	[SI],DX 		; assign ownership
 29857                                  
 29858                                  No_Owner:
 29859                                  	;mov	ax,[bp-18]
 29860 00006342 8B46EE                  	mov	AX,Exec_Load_Block	; get load block pointer
 29861 00006345 48                      	dec	AX
 29862 00006346 8ED8                    	mov	DS,AX			; point to header
 29863 00006348 8914                    	mov	[SI],DX 		; assign ownership
 29864                                  
 29865                                  	; MSDOS 6.0
 29866                                  	;push	DS			;AN000;MS. make ES=DS
 29867                                  	;pop	ES			;AN000;MS.
 29868                                  	;mov	DI,Arena_Name		;AN000;MS. ES:DI points to destination
 29869                                  	;call	Scan_Execname		;AN007;MS. parse execname
 29870                                  	;				;	   ds:si->name, cx=name length
 29871                                  	;push	CX			;AN007;;MS. save for fake version
 29872                                  	;push	SI			;AN007;;MS. save for fake version
 29873                                  	;
 29874                                  ;MoveName:				;AN000;
 29875                                  	;lodsb				;AN000;;MS. get char
 29876                                  	;cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 29877                                  	;jz	Mem_Done		;AN000;;MS. no, move to header
 29878                                  	;				;AN000;
 29879                                  	;stosb				;AN000;;MS. move char
 29880                                  	;				; MSKK bug fix - limit length copied
 29881                                  	;cmp	di,16			; end of memory arena block?
 29882                                  	;jae	mem_done		; jump if so
 29883                                  	;
 29884                                  	;loop	movename		;AN000;;MS. continue
 29885                                  ;Mem_Done:				;AN000;
 29886                                  	;xor	AL,AL			;AN000;;MS. make ASCIIZ
 29887                                  	;cmp	DI,SIZE ARENA		;AN000;MS. if not all filled
 29888                                  	;jae	Fill8			;AN000;MS.
 29889                                  	;
 29890                                  	;stosb				;AN000;MS.
 29891                                  	;
 29892                                  ;Fill8:					;AN000;
 29893                                  	;pop	SI			;AN007;MS. ds:si -> file name
 29894                                  	;pop	CX			;AN007;MS.
 29895                                  	;
 29896                                  	;call	Scan_Special_Entries	;AN007;MS.
 29897                                  
 29898                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29899 0000634A 52                      	push	DX
 29900                                  	;mov	si,[bp-16]
 29901 0000634B 8B76F0                  	mov	SI,Exec_Size
 29902 0000634E 01D6                    	add	SI,DX
 29903                                  	;Invoke	$Dup_PDB		; ES is now PDB
 29904 00006350 E8D7BA                  	call	_$DUP_PDB
 29905 00006353 5A                      	pop	DX
 29906                                  
 29907                                  	;push	word [bp-14]
 29908 00006354 FF76F2                  	push	Exec_Environ
 29909                                  	;pop	WORD [ES:2Ch]
 29910 00006357 268F062C00              	pop	word [ES:PDB.ENVIRON]
 29911                                  
 29912                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 29913                                  					; version number in PSP
 29914                                   	;push	word [Special_Version]	; Set the DOS version number to
 29915                                  	;pop	word [ES:PDB_Version]	; to be used for this application
 29916                                  		; PDB.VERSION
 29917                                  
 29918                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 29919                                  	;lds	si,[bp-4]
 29920 0000635C C576FC                  	lds	SI,Exec_Blk		; get the block
 29921 0000635F 1E                      	push	DS			; save its location
 29922 00006360 56                      	push	SI
 29923                                  	;lds	si, [si+6]
 29924 00006361 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 29925                                  
 29926                                  	; DS points to user space 5C FCB
 29927                                  
 29928 00006364 B90C00                  	mov	CX,12			; copy drive, name and ext
 29929 00006367 51                      	push	CX
 29930 00006368 BF5C00                  	mov	DI,5Ch
 29931 0000636B 8A1C                    	mov	BL,[SI]
 29932 0000636D F3A4                    	rep	movsb
 29933                                  
 29934                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 29935                                  
 29936 0000636F 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 29937 00006371 AB                      	stosw
 29938 00006372 AB                      	stosw
 29939                                  
 29940                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 29941                                  
 29942 00006373 59                      	pop	CX
 29943 00006374 5E                      	pop	SI			; get block
 29944 00006375 1F                      	pop	DS
 29945 00006376 1E                      	push	DS			; save (again)
 29946 00006377 56                      	push	SI
 29947                                  	;lds	si,[si+0Ah]
 29948 00006378 C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 29949                                  
 29950                                  	; DS points to user space 6C FCB
 29951                                  
 29952 0000637B 8A3C                    	mov	BH,[SI] 		; do same as above
 29953 0000637D F3A4                    	rep	movsb
 29954 0000637F AB                      	stosw
 29955 00006380 AB                      	stosw
 29956 00006381 5E                      	pop	SI			; get block (last time)
 29957 00006382 1F                      	pop	DS
 29958                                  	;ld	si,[si+2]
 29959 00006383 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 29960                                  
 29961                                  	; DS points to user space 80 command line
 29962                                  
 29963 00006386 80C980                  	or	CL,80h
 29964 00006389 89CF                    	mov	DI,CX
 29965 0000638B F3A4                    	rep	movsb			; Wham!
 29966                                  
 29967                                  	; Process BX into default AX (validity of drive specs on args).
 29968                                  	; We no longer care about DS:SI.
 29969                                  
 29970 0000638D FEC9                    	dec	CL			; get 0FFh in CL
 29971 0000638F 88F8                    	mov	AL,BH
 29972 00006391 30FF                    	xor	BH,BH
 29973                                  	;invoke	GetVisDrv
 29974 00006393 E8C705                  	call	GetVisDrv
 29975 00006396 7302                    	jnc	short Exec_BL
 29976                                  
 29977 00006398 88CF                    	mov	BH,CL
 29978                                  
 29979                                  Exec_BL:
 29980 0000639A 88D8                    	mov	AL,BL
 29981 0000639C 30DB                    	xor	BL,BL
 29982                                  	;invoke	GetVisDrv
 29983 0000639E E8BC05                  	call	GetVisDrv
 29984 000063A1 7302                    	jnc	short Exec_Set_Return
 29985                                  
 29986 000063A3 88CB                    	mov	BL,CL
 29987                                  
 29988                                  Exec_Set_Return:
 29989                                  	;invoke	Get_User_Stack			; get his return address
 29990 000063A5 E863B2                  	call	Get_User_Stack
 29991                                  
 29992                                  	;push	word [si+14h]
 29993 000063A8 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 29994                                  	;push	word [si+12h]
 29995 000063AB FF7412                  	push	word [SI+user_env.user_IP]
 29996                                  	;push	word [si+14h]
 29997 000063AE FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 29998                                  	;push	word [si+12h]
 29999 000063B1 FF7412                  	push	word [SI+user_env.user_IP]
 30000                                  	;pop	word [ES:0Ah]
 30001 000063B4 268F060A00              	pop	WORD [ES:PDB.EXIT]
 30002                                  	;pop	word [ES:0Ch]
 30003 000063B9 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 30004                                  
 30005 000063BE 31C0                    	xor	AX,AX
 30006 000063C0 8ED8                    	mov	DS,AX
 30007                                  					; save them where we can get them
 30008                                  					; later when the child exits.
 30009                                  	;pop	word [88h]
 30010 000063C2 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 30011                                  	;pop	word [90h]
 30012 000063C6 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 30013                                  
 30014 000063CA 36C706[DA02]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 30015 000063D1 368E1E[DE02]            	mov	DS,[SS:CurrentPDB]	; SS Override
 30016 000063D6 368C1E[DC02]            	mov	[SS:DMAADD+2],DS	; SS Override
 30017                                  
 30018                                  	;test	byte [bp-5],1
 30019 000063DB F646FB01                	test	Exec_Func,exec_func_no_execute
 30020 000063DF 7427                    	jz	short exec_go
 30021                                  
 30022 000063E1 36C536[1614]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 30023                                  	;les	di,[bp-4]
 30024 000063E6 C47EFC                  	les	DI,Exec_Blk		; and block for return
 30025                                  	;mov	[es:di+10h],ds
 30026 000063E9 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 30027                                  
 30028 000063ED 4E                      	dec	SI			; 'push' default AX
 30029 000063EE 4E                      	dec	SI
 30030 000063EF 891C                    	mov	[SI],BX 		; save default AX reg
 30031                                  	;mov	[es:di+0Eh], si
 30032 000063F1 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 30033                                  
 30034 000063F5 36C506[1A14]            	lds	AX,[SS:exec_init_IP]	; SS Override
 30035                                  	;mov	[es:di+14h],ds
 30036 000063FA 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 30037                                  	;mov	[es:di+12h],ax
 30038 000063FE 26894512                	mov	[ES:DI+EXEC1.IP],AX
 30039                                  	
 30040                                  	;leave
 30041 00006402 89EC                    	mov	sp,bp
 30042 00006404 5D                      	pop	bp	
 30043                                  
 30044                                  	;transfer SYS_RET_OK
 30045 00006405 E9F5B2                  	jmp	SYS_RET_OK
 30046                                  
 30047                                  exec_go:
 30048 00006408 36C536[1A14]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 30049 0000640D 36C43E[1614]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 30050 00006412 8CC0                    	mov	AX,ES
 30051                                  
 30052                                  	; MSDOS 6.0
 30053                                  	;cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 30054                                  	;je	short Xfer_To_User	; N: transfer control to user
 30055                                  
 30056                                  	;push	ds			; Y: control must go to low mem stub
 30057                                  	;	
 30058                                  	;push	cs			;    where we disable a20 and Xfer 
 30059                                  	;pop	ds			;    control to user 
 30060                                  	;
 30061                                  	;or	byte [DOS_FLAG],EXECA20OFF ; M068:
 30062                                  	;				; M004: Set bit to signal int 21
 30063                                  	;				; ah = 25 & ah= 49. See dossym.inc 
 30064                                  	;				; under TAG M003 & M009 for 
 30065                                  	;				; explanation
 30066                                  	;mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 30067                                  	;				; M068: going to be turned OFF.
 30068                                  	;
 30069                                  	;mov	ax,ds			; ax = segment of low mem stub
 30070                                  	;pop	ds
 30071                                  	;
 30072                                  	;push	ax			; ret far into the low mem stub
 30073                                  	;mov	ax,Disa20_Xfer
 30074                                  	;push	ax
 30075                                  	;mov	AX,ES			; restore ax
 30076                                  	;retf
 30077                                  
 30078                                  Xfer_To_User:
 30079                                  	; DS:SI points to entry point
 30080                                  	; AX:DI points to initial stack
 30081                                  	; DX has PDB pointer
 30082                                  	; BX has initial AX value
 30083                                  
 30084 00006414 FA                      	cli
 30085                                  	; 15/08/2018
 30086 00006415 36C606[CF02]00          	mov	BYTE [SS:INDOS],0	; SS Override
 30087                                  
 30088 0000641B 8ED0                    	mov	SS,AX			; set up user's stack
 30089 0000641D 89FC                    	mov	SP,DI			; and SP
 30090 0000641F FB                      	sti
 30091                                  
 30092 00006420 1E                      	push	DS			; fake long call to entry
 30093 00006421 56                      	push	SI
 30094 00006422 8EC2                    	mov	ES,DX			; set up proper seg registers
 30095 00006424 8EDA                    	mov	DS,DX
 30096 00006426 89D8                    	mov	AX,BX			; set up proper AX
 30097                                  
 30098 00006428 CB                      	retf
 30099                                  
 30100                                  ; 04/08/2018 - Retro DOS v3.0
 30101                                  
 30102                                  ;----------------------------------------------------------------------------
 30103                                  ;
 30104                                  ;----------------------------------------------------------------------------
 30105                                  
 30106                                  ExecRead:
 30107 00006429 E80C00                  	CALL	Exec_Dealloc
 30108                                  	;mov	bx,[bp-8]
 30109 0000642C 8B5EF8                  	MOV	bx,Exec_FH
 30110 0000642F 55                      	PUSH	BP
 30111 00006430 E8AB0A                  	call	_$READ
 30112 00006433 5D                      	POP	BP
 30113 00006434 E80C00                  	CALL	Exec_Alloc
 30114 00006437 C3                      	retn
 30115                                  
 30116                                  ;----------------------------------------------------------------------------
 30117                                  ;
 30118                                  ;----------------------------------------------------------------------------
 30119                                  
 30120                                  Exec_Dealloc:
 30121 00006438 53                      	push	BX
 30122                                  	;mov	bx,0
 30123 00006439 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 30124 0000643B E825BC                  	call	EcritMem
 30125 0000643E E81000                  	call	ChangeOwners
 30126 00006441 5B                      	pop	BX
 30127 00006442 C3                      	retn
 30128                                  
 30129                                  ;----------------------------------------------------------------------------
 30130                                  ;
 30131                                  ;----------------------------------------------------------------------------
 30132                                  
 30133                                  Exec_Alloc:
 30134 00006443 53                      	push	BX
 30135                                  	;mov	bx,[SS:CurrentPDB]	; SS Override
 30136 00006444 2E8B1E[DE02]            	mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 30137 00006449 E80500                  	call	ChangeOwners
 30138 0000644C E81CBC                  	call	LcritMem
 30139 0000644F 5B                      	pop	BX
 30140 00006450 C3                      	retn
 30141                                  
 30142                                  ;----------------------------------------------------------------------------
 30143                                  ;
 30144                                  ;----------------------------------------------------------------------------
 30145                                  
 30146                                  ChangeOwners:
 30147 00006451 9C                      	pushf
 30148 00006452 50                      	push	AX
 30149                                  	;mov	ax,[bp-14]
 30150 00006453 8B46F2                  	mov	AX,Exec_Environ
 30151 00006456 E80900                  	call	ChangeOwner
 30152                                  	;mov	ax,[bp-18]
 30153 00006459 8B46EE                  	mov	AX,Exec_Load_Block
 30154 0000645C E80300                  	call	ChangeOwner
 30155 0000645F 58                      	pop	AX
 30156 00006460 9D                      	popf
 30157                                  chgown_retn:
 30158 00006461 C3                      	retn
 30159                                  
 30160                                  ;----------------------------------------------------------------------------
 30161                                  ;
 30162                                  ;----------------------------------------------------------------------------
 30163                                  
 30164                                  ChangeOwner:
 30165 00006462 09C0                    	or	AX,AX			; is area allocated?
 30166 00006464 74FB                    	jz	short chgown_retn	; no, do nothing
 30167 00006466 48                      	dec	AX
 30168 00006467 1E                      	push	DS
 30169 00006468 8ED8                    	mov	DS,AX
 30170 0000646A 891E0100                	mov	[ARENA.OWNER],BX
 30171 0000646E 1F                      	pop	DS
 30172 0000646F C3                      	retn
 30173                                  
 30174                                  
 30175                                  ; MSDOS 6.0
 30176                                  ;----------------------------------------------------------------------------
 30177                                  ;
 30178                                  ;----------------------------------------------------------------------------
 30179                                  
 30180                                  ;Procedure	Scan_Execname,near
 30181                                  ;	ASSUME	SS:DosData
 30182                                  ;
 30183                                  ;	lds	SI,ExecName		; DS:SI points to name
 30184                                  ;Entry	Scan_Execname1			; M028
 30185                                  ;Save_Begin:				;
 30186                                  ;	mov	CX,SI			; CX= starting addr
 30187                                  ;Scan0:					;
 30188                                  ;	lodsb				; get char
 30189                                  ;
 30190                                  ;	cmp	AL,':'			; is ':' , may be A:name
 30191                                  ;	jz	save_begin		; yes, save si
 30192                                  ;	cmp	AL,'\'                  ; is '\', may be A:\name
 30193                                  ;	jz	save_begin		; yes, save si
 30194                                  ;	cmp	AL,0			; is end of name
 30195                                  ;	jnz	scan0			; no, continue scanning
 30196                                  ;	sub	SI,CX			; get name's length
 30197                                  ;	xchg	SI,CX			; cx= length, si= starting addr
 30198                                  ;
 30199                                  ;	return
 30200                                  ;
 30201                                  ;EndProc Scan_Execname
 30202                                  
 30203                                  ; MSDOS 6.0
 30204                                  ;----------------------------------------------------------------------------
 30205                                  ;
 30206                                  ;----------------------------------------------------------------------------
 30207                                  
 30208                                  ;Procedure    Scan_Special_Entries,near
 30209                                  ;	assume	SS:DOSDATA
 30210                                  ;
 30211                                  ;	dec	CX			; cx= name length
 30212                                  ;;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 30213                                  ;					;reset to current version
 30214                                  ;	mov    [Special_Version],(Minor_Version SHL 8) + Major_Version
 30215                                  ;;***	call	Reset_Version
 30216                                  ;
 30217                                  ;;M060	push	SS
 30218                                  ;;M060	pop	ES
 30219                                  ;
 30220                                  ;	les	DI,SS:UU_IFS_DOS_CALL	;M060; ES:DI --> Table in SETVER.SYS
 30221                                  ;	mov	AX,ES			;M060; First do a NULL ptr check to
 30222                                  ;	or	AX,DI			;M060; be sure the table exists
 30223                                  ;	jz	End_List		;M060; If ZR then no table
 30224                                  ;
 30225                                  ;GetEntries:
 30226                                  ;	mov	AL,ES:[DI]		; end of list
 30227                                  ;	or	AL,AL
 30228                                  ;	jz	End_List		; yes
 30229                                  ;
 30230                                  ;	mov	[Temp_Var2],DI		; save di
 30231                                  ;	cmp	AL,CL			; same length ?
 30232                                  ;	jnz	SkipOne 		; no
 30233                                  ;
 30234                                  ;	inc	DI			; es:di -> special name
 30235                                  ;	push	CX			; save length and name addr
 30236                                  ;	push	SI
 30237                                  ;
 30238                                  ;;
 30239                                  ;; M050 - BEGIN
 30240                                  ;;
 30241                                  ;	push	ax			; save len
 30242                                  ;sse_next_char:
 30243                                  ;	lodsb
 30244                                  ;	call	UCase
 30245                                  ;	scasb
 30246                                  ;	jne	Not_Matched
 30247                                  ;	loop	sse_next_char
 30248                                  ;	
 30249                                  ;;
 30250                                  ;;	repz	cmpsb			; same name ?
 30251                                  ;;
 30252                                  ;;	jnz	Not_Matched		; no
 30253                                  ;;
 30254                                  ;	pop	ax			; take len off the stack
 30255                                  ;;
 30256                                  ;; M050 - END
 30257                                  ;;
 30258                                  ;	mov	AX,ES:[DI]		; get special version
 30259                                  ;	mov	[Special_Version],AX	; save it
 30260                                  ;
 30261                                  ;;***	mov	AL,ES:[DI+2]		; get fake count
 30262                                  ;;***	mov	[Fake_Count],AL 	; save it
 30263                                  ;
 30264                                  ;	pop	SI
 30265                                  ;	pop	CX
 30266                                  ;	jmp	SHORT end_list
 30267                                  ;
 30268                                  ;Not_Matched:
 30269                                  ;	pop	ax			; get len from stack ; M050
 30270                                  ;	pop	SI			; restore si,cx
 30271                                  ;	pop	CX
 30272                                  ;
 30273                                  ;SkipOne:
 30274                                  ;	mov	DI,[Temp_Var2]		; restore old di use SS Override
 30275                                  ;	xor	AH,AH			; position to next entry
 30276                                  ;	add	DI,AX
 30277                                  ;
 30278                                  ;	add	DI,3			; DI -> next entry length
 30279                                  ;;***	add	DI,4			; DI -> next entry length
 30280                                  ;
 30281                                  ;	jmp	Getentries
 30282                                  ;
 30283                                  ;End_List:
 30284                                  ;	return
 30285                                  ;
 30286                                  ;EndProc Scan_Special_Entries
 30287                                  
 30288                                  
 30289                                  ; 04/08/2018 - Retro DOS v3.0
 30290                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 30291                                  
 30292                                  ;----------------------------------------------------------------------------
 30293                                  ;SUBTTL Terminate and stay resident handler
 30294                                  ;
 30295                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 30296                                  ;	    truncate the current block.
 30297                                  ;
 30298                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 30299                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 30300                                  ;	    and restoring the vectors.
 30301                                  ;
 30302                                  ;----------------------------------------------------------------------------
 30303                                  
 30304                                  _$KEEP_PROCESS:
 30305 00006470 50                      	push	AX			; keep exit code around
 30306                                  	;mov	byte [SS:EXIT_TYPE],3
 30307 00006471 36C606[1705]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 30308 00006477 368E06[DE02]            	mov	ES,[SS:CurrentPDB]
 30309 0000647C 83FA06                  	cmp	DX,6h			; keep enough space around for system
 30310 0000647F 7303                    	jae	short Keep_Shrink	; info
 30311                                  
 30312 00006481 BA0600                  	mov	DX,6h
 30313                                  
 30314                                  Keep_Shrink:
 30315 00006484 89D3                    	mov	BX,DX
 30316 00006486 53                      	push	BX
 30317 00006487 06                      	push	ES
 30318 00006488 E8BF01                  	call	_$SETBLOCK		; ignore return codes.
 30319 0000648B 1F                      	pop	DS
 30320 0000648C 5B                      	pop	BX
 30321 0000648D 7207                    	jc	short Keep_Done		; failed on modification
 30322                                  
 30323 0000648F 8CD8                    	mov	AX,DS
 30324 00006491 01D8                    	add	AX,BX
 30325                                  	;mov	[2],ax
 30326 00006493 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 30327                                  
 30328                                  Keep_Done:
 30329 00006496 58                      	pop	AX
 30330 00006497 EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 30331                                  
 30332                                  ;----------------------------------------------------------------------------
 30333                                  ;
 30334                                  ;----------------------------------------------------------------------------
 30335                                  
 30336                                  STAY_RESIDENT:
 30337                                  	;mov	ax,3100h
 30338 00006499 B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 30339 0000649C 83C20F                  	add	DX,15
 30340 0000649F D1DA                    	rcr	DX,1
 30341 000064A1 B103                    	mov	CL,3
 30342 000064A3 D3EA                    	shr	DX,CL
 30343                                  
 30344 000064A5 E902B0                  	jmp	COMMAND
 30345                                  
 30346                                  ;----------------------------------------------------------------------------
 30347                                  ;SUBTTL $EXIT - return to parent process
 30348                                  ;   Assembler usage:
 30349                                  ;	    MOV     AL, code
 30350                                  ;	    MOV     AH, Exit
 30351                                  ;	    INT     int_command
 30352                                  ;   Error return:
 30353                                  ;	    None.
 30354                                  ;
 30355                                  ;----------------------------------------------------------------------------
 30356                                  
 30357                                  _$EXIT:
 30358                                  	; 04/08/2018 - Retro DOS v3.0
 30359                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 30360 000064A8 30E4                    	xor	AH,AH
 30361 000064AA 368626[F902]            	xchg	AH,[SS:DidCTRLC]
 30362 000064AF 08E4                    	or	AH,AH
 30363                                  	;mov	BYTE [SS:EXIT_TYPE],0
 30364 000064B1 36C606[1705]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 30365 000064B7 7406                    	jz	short exit_inner
 30366                                  	;mov	BYTE [SS:EXIT_TYPE],1
 30367 000064B9 36C606[1705]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 30368                                  
 30369                                  	;entry	Exit_inner
 30370                                  exit_inner:
 30371 000064BF E849B1                  	call	Get_User_Stack		;PBUGBUG
 30372                                  
 30373 000064C2 36FF36[DE02]            	push	word [ss:CurrentPDB]
 30374                                  	;pop	word [si+14h]
 30375 000064C7 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 30376 000064CA EB08                    	jmp	short abort_inner
 30377                                  
 30378                                  ;BREAK <$ABORT -- Terminate a process>
 30379                                  ;----------------------------------------------------------------------------
 30380                                  ; Inputs:
 30381                                  ;	user_CS:00 must point to valid program header block
 30382                                  ; Function:
 30383                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 30384                                  ;	to the terminate address
 30385                                  ; Returns:
 30386                                  ;	TO THE TERMINATE ADDRESS
 30387                                  ;----------------------------------------------------------------------------
 30388                                  
 30389                                  _$ABORT:
 30390 000064CC 30C0                    	xor	AL,AL
 30391                                  	;mov	byte [SS:EXIT_TYPE],0
 30392                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 30393 000064CE 36C606[1705]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 30394                                  
 30395                                  	; abort_inner must have AL set as the exit code! The exit type
 30396                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 30397                                  	; to be correct as the one that is terminating.
 30398                                  
 30399                                  abort_inner:
 30400 000064D4 368A26[1705]            	mov	AH,[SS:EXIT_TYPE]
 30401 000064D9 36A3[E202]              	mov	[SS:exit_code],AX
 30402 000064DD E82BB1                  	call	Get_User_Stack
 30403                                  
 30404                                  	;mov	ds,[si+14h]
 30405 000064E0 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 30406 000064E3 31C0                    	xor	AX,AX
 30407 000064E5 8EC0                    	mov	ES,AX
 30408                                  	;mov	si,10
 30409 000064E7 BE0A00                  	mov	SI,SAVEXIT
 30410                                  	;mov	di,88h
 30411 000064EA BF8800                  	mov	DI,addr_int_terminate
 30412 000064ED A5                      	movsw
 30413 000064EE A5                      	movsw
 30414 000064EF A5                      	movsw
 30415 000064F0 A5                      	movsw
 30416 000064F1 A5                      	movsw
 30417 000064F2 A5                      	movsw
 30418 000064F3 E98EF4                  	jmp	reset_environment
 30419                                  
 30420                                  ; MSDOS 6.0
 30421                                  ;----------------------------------------------------------------------------
 30422                                  ;
 30423                                  ; fixexepatch will point to this is DOS loads low. 
 30424                                  ;
 30425                                  ;----------------------------------------------------------------------------
 30426                                  
 30427                                  ;retexepatch	proc	near
 30428                                  ;	
 30429                                  ;	ret
 30430                                  ;
 30431                                  ;retexepatch 	endp
 30432                                  
 30433                                  
 30434                                  ;============================================================================
 30435                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 30436                                  ;============================================================================
 30437                                  ; 04/08/2018 - Retro DOS v3.0
 30438                                  
 30439                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 30440                                  
 30441                                  ;**
 30442                                  ;	Microsoft Confidential
 30443                                  ;	Copyright (C) Microsoft Corporation 1991
 30444                                  ;	All Rights Reserved.
 30445                                  ;
 30446                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 30447                                  ;	I/O specs are defined in DISPATCH.
 30448                                  ;
 30449                                  ;	$ALLOC
 30450                                  ;	$SETBLOCK
 30451                                  ;	$DEALLOC
 30452                                  ;	$AllocOper
 30453                                  ;	arena_free_process
 30454                                  ;	arena_next
 30455                                  ;	check_signature
 30456                                  ;	Coalesce
 30457                                  ;
 30458                                  ;	Modification history:
 30459                                  ;
 30460                                  ;	    Created: ARR 30 March 1983
 30461                                  ;
 30462                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 30463                                  ;		      M003 - added support for link/unlink UMBs from
 30464                                  ;			     DOS arena chain. 7/18/90
 30465                                  ;		      M009 - Added error returns invalid function and 
 30466                                  ;			     arena trashed in set link state call.
 30467                                  ;		      M010 - Release UMB arenas allocated to current PDB
 30468                                  ;			     if UMB_HEAD is initialized.
 30469                                  ;
 30470                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 30471                                  ;			     support. Please see under M009 in 
 30472                                  ;			     ..\inc\dossym.inc. 8/31/90.
 30473                                  ;
 30474                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 30475                                  ;			     sure that umb_head arena is valid and also make
 30476                                  ;			     sure that the previous arena is pointing to 
 30477                                  ;			     umb_head.
 30478                                  ;
 30479                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 30480                                  ;			     set allloc strategy.
 30481                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 30482                                  ;			     bx in AllocSetStrat.
 30483                                  ;
 30484                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 30485                                  ;			     a bit to indicate to dos dispatcher to turn
 30486                                  ;			     a20 off before iret. See M016.
 30487                                  ;
 30488                                  
 30489                                  ;	BREAK	<memory allocation utility routines>
 30490                                  
 30491                                  
 30492                                  ; 15/04/2018 - Retro DOS v2.0
 30493                                  ;----------------------------------------------------------------------------
 30494                                  ; xenix memory calls for MSDOS
 30495                                  ;
 30496                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 30497                                  ; arena_owner_system are all equal to zero and are contained in DI.
 30498                                  ;
 30499                                  ;INCLUDE DOSSEG.ASM
 30500                                  
 30501                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 30502                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 30503                                  
 30504                                  ;.xlist
 30505                                  ;.xcref
 30506                                  ;INCLUDE DOSSYM.ASM
 30507                                  ;INCLUDE DEVSYM.ASM
 30508                                  ;.cref
 30509                                  ;.list
 30510                                  
 30511                                  ;TITLE ALLOC.ASM - memory arena manager
 30512                                  ;NAME Alloc
 30513                                  
 30514                                  ;SUBTTL memory allocation utility routines
 30515                                  ;PAGE
 30516                                  ;
 30517                                  ; arena data
 30518                                  ;
 30519                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 30520                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 30521                                  ;       i_need  FirstArena,WORD         ; first free block found
 30522                                  ;       i_need  BestArena,WORD          ; best free block found
 30523                                  ;       i_need  LastArena,WORD          ; last free block found
 30524                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 30525                                  
 30526                                  ;**	Arena_Free_Process
 30527                                  ;----------------------------------------------------------------------------
 30528                                  ;	Free all arena blocks allocated to a prOcess
 30529                                  ;
 30530                                  ;	ENTRY	(bx) = PID of process
 30531                                  ;	EXIT	none
 30532                                  ;	USES	????? BUGBUG
 30533                                  ;----------------------------------------------------------------------------
 30534                                  
 30535                                  arena_free_process:
 30536                                  	; 04/08/2018 - Retro DOS v3.0
 30537 000064F6 36A1[2400]                      MOV	AX,[SS:arena_head]
 30538                                  arena_free_process_start:
 30539 000064FA BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 30540                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 30541 000064FD E81F00                          CALL    check_signature         ; ES <- AX, check for valid block
 30542                                  
 30543                                  arena_free_process_loop:
 30544                                          ;retc
 30545 00006500 722C                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 30546 00006502 06                      	PUSH    ES
 30547 00006503 1F                              POP     DS
 30548                                  	;cmp	[1],bx 
 30549 00006504 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 30550 00006508 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 30551                                  	; 20/05/2019
 30552                                  	;mov	[1],di
 30553 0000650A 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 30554                                  
 30555                                  arena_free_next:
 30556                                  	;cmp	byte [di],5Ah ;'Z'
 30557 0000650E 803D5A                          CMP     BYTE [DI],arena_signature_end
 30558                                                                          ; end of road, Jack?
 30559                                          ;retz				; never come back no more
 30560 00006511 741B                    	JZ	SHORT AFP_RETN  ;msdos 3.3 (& MSDOS 2.11)
 30561                                  	; MSDOS 6.0
 30562                                  	;jz	short arena_chk_umbs
 30563                                          
 30564 00006513 E80200                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 30565 00006516 EBE8                            JMP     SHORT arena_free_process_loop
 30566                                  
 30567                                  	; MSDOS 6.0
 30568                                  ;arena_chk_umbs:			; M010 - Start
 30569                                  	;mov	ax,[umb_head]		; ax = umb_head
 30570                                  	;cmp	ax,0FFFFh		; Q: is umb_head initialized
 30571                                  	;je	short ret_label		; N: we're done
 30572                                  	;
 30573                                  	;mov	di,ds			; di = last arena
 30574                                  	;cmp	di,ax			; Q: is last arena above umb_head
 30575                                  	;jae	short ret_label		; Y: we've scanned umbs also. done.
 30576                                  	;jmp	short arena_free_process_start
 30577                                  					; M010 - End
 30578                                  
 30579                                  ;AFP_RETN:
 30580                                  ;	RETN
 30581                                  
 30582                                  ;	BREAK	<Arena Helper Routines>
 30583                                  
 30584                                  ;**	Arena_Next - Find Next item in Arena
 30585                                  ;----------------------------------------------------------------------------
 30586                                  ;	ENTRY	DS - pointer to block head
 30587                                  ;		(di) = 0
 30588                                  ;	EXIT	AX,ES - pointers to next head
 30589                                  ;		'C' set iff arena damaged
 30590                                  ;----------------------------------------------------------------------------
 30591                                  
 30592                                  arena_next:
 30593 00006518 8CD8                            MOV     AX,DS                   ; AX <- current block
 30594 0000651A 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 30595 0000651E 40                              INC     AX                      ; remember that header!
 30596                                  ;
 30597                                  ;       fall into check_signature and return
 30598                                  ;
 30599                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 30600                                  ;       RET
 30601                                  
 30602                                  ;**	Check_Signature - Check Memory Block Signature
 30603                                  ;----------------------------------------------------------------------------
 30604                                  ;	ENTRY	(AX) = address of block header
 30605                                  ;		(di) = 0
 30606                                  ;	EXIT	 ES = AX
 30607                                  ;		'C' clear if signature good
 30608                                  ;		'C' set if signature bad
 30609                                  ;	USES	ES, Flags
 30610                                  ;----------------------------------------------------------------------------
 30611                                  
 30612                                  check_signature:        
 30613                                  
 30614 0000651F 8EC0                    	MOV     ES,AX                   ; ES <- AX
 30615                                  	;cmp	byte [es:di],4Dh ; 'M'
 30616 00006521 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 30617                                                                          ; IF next signature = not_end THEN
 30618 00006525 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 30619                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 30620 00006527 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 30621                                                                          ; IF next signature = end then
 30622 0000652B 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 30623 0000652D F9                              STC                             ; set error
 30624                                  ;ret_label: ; MSDOS 6.0
 30625                                  AFP_RETN:
 30626                                   	;  Retro DOS v.20 - 05/03/2018
 30627                                  check_signature_ok:
 30628                                  COALESCE_RETN:
 30629 0000652E C3                      	RETN
 30630                                  
 30631                                  ;**	Coalesce - Combine free blocks ahead with current block
 30632                                  ;----------------------------------------------------------------------------
 30633                                  ;	Coalesce adds the block following the argument to the argument block,
 30634                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 30635                                  ;	some callers (such as $setblock) use it to join a free block to it's
 30636                                  ;	preceeding allocated block.
 30637                                  ;
 30638                                  ;	ENTRY	(ds) = pointer to the head of a free block
 30639                                  ;		(di) = 0
 30640                                  ;	EXIT	'C' clear if OK
 30641                                  ;		  (ds) unchanged, this block updated
 30642                                  ;		  (ax) = address of next block, IFF not at end
 30643                                  ;		'C' set if arena trashed
 30644                                  ;	USES	(cx)
 30645                                  ;----------------------------------------------------------------------------
 30646                                          
 30647                                  Coalesce:
 30648                                  	;cmp	byte [di],5Ah ; 'Z'
 30649 0000652F 803D5A                  	CMP     BYTE [DI],arena_signature_end
 30650                                                                          ; IF current signature = END THEN
 30651                                          ;retz				;   GOTO ok
 30652 00006532 74FA                            jz	short COALESCE_RETN
 30653 00006534 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 30654                                          ;retc				; IF no error THEN GOTO check
 30655 00006537 72F5                    	jc	short COALESCE_RETN
 30656                                  
 30657                                  coalesce_check:
 30658                                  	;cmp	[es:1],di
 30659 00006539 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 30660                                          ;retnz				; IF next block isnt free THEN return
 30661 0000653E 75EE                            JNZ	SHORT COALESCE_RETN
 30662                                  	;mov	cx,[ES:3]
 30663 00006540 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 30664 00006545 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 30665                                          ;ADD	[3],CX
 30666 00006546 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 30667 0000654A 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 30668 0000654D 880D                            MOV     [DI],CL
 30669 0000654F EBDE                            JMP     SHORT Coalesce		; try again
 30670                                  
 30671                                  ; 04/08/2018 - Retro DOS v3.0
 30672                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 30673                                  
 30674                                  ;	BREAK  <$Alloc - allocate space in memory>
 30675                                  
 30676                                  ; MSDOS 6.0
 30677                                  ;----------------------------------------------------------------------------
 30678                                  ;**	$Alloc - Allocate Memory Space
 30679                                  ;
 30680                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 30681                                  ;	Alloc returns a pointer to a free block of memory that
 30682                                  ;	has the requested size in paragraphs.
 30683                                  ;
 30684                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 30685                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 30686                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 30687                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 30688                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 30689                                  ;
 30690                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 30691                                  ;	starts from arena_head.
 30692                                  ;
 30693                                  ;	Assembler usage:
 30694                                  ;           MOV     BX,size
 30695                                  ;           MOV     AH,Alloc
 30696                                  ;           INT     21h
 30697                                  ;
 30698                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 30699                                  ;	so that we start searching the arena at it's first non-trivial free
 30700                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 30701                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 30702                                  ;	doesn't have too many memory objects in it beyond the first free one.
 30703                                  ;	verify that this is true; if so, this can stay as is
 30704                                  ;
 30705                                  ;	ENTRY	(bx) = requested size, in bytes
 30706                                  ;		(DS) = (ES) = DOSGROUP
 30707                                  ;	EXIT	'C' clear if memory allocated
 30708                                  ;		  (ax:0) = address of requested memory
 30709                                  ;		'C' set if request failed
 30710                                  ;		  (AX) = error_not_enough_memory
 30711                                  ;		    (bx) = max size we could have allocated
 30712                                  ;		  (ax) = error_arena_trashed
 30713                                  ;	USES	All
 30714                                  ;----------------------------------------------------------------------------
 30715                                  
 30716                                  ; MSDOS 2.11 (& MSDOS 3.3)
 30717                                  ;----------------------------------------------------------------------------
 30718                                  ;SUBTTL $Alloc - allocate space in memory
 30719                                  ;
 30720                                  ;   Assembler usage:
 30721                                  ;           MOV     BX,size
 30722                                  ;           MOV     AH,Alloc
 30723                                  ;           INT     21h
 30724                                  ;         AX:0 is pointer to allocated memory
 30725                                  ;         BX is max size if not enough memory
 30726                                  ;
 30727                                  ;   Description:
 30728                                  ;           Alloc returns  a  pointer  to  a  free  block of
 30729                                  ;       memory that has the requested  size  in  paragraphs.
 30730                                  ;
 30731                                  ;   Error return:
 30732                                  ;           AX = error_not_enough_memory
 30733                                  ;              = error_arena_trashed
 30734                                  ;----------------------------------------------------------------------------
 30735                                  
 30736                                  _$ALLOC:
 30737                                  	; 04/08/2018 - Retro DOS v3.0
 30738                                  	;EnterCrit critMem
 30739 00006551 E80FBB                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 30740                                  
 30741                                  	; MSDOS 6.0
 30742                                  	;mov	ax,[arena_head]
 30743                                  	;mov	[start_arena],ax	; assume LOW_FIRST
 30744                                  	;			
 30745                                  	;test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 30746                                  	;				; Q: should we start scanning from 
 30747                                  	;				;    UMB's
 30748                                  	;jz	short norm_alloc	; N: scan from arena_head
 30749                                  	;	
 30750                                  	;;cmp	word [umb_head],-1	; Q: Has umb_head been initialized
 30751                                  	;;je	short norm_alloc	; N: scan from arena_head
 30752                                  	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
 30753                                  	;jz	short norm_alloc	; N: scan from arena_head
 30754                                  	;
 30755                                  	;mov	ax,[umb_head]
 30756                                  	;mov	[start_arena],ax	; start_arena = umb_head
 30757                                  	;
 30758                                  					; M000 - end
 30759                                  ;norm_alloc:
 30760 00006554 31C0                            XOR     AX,AX
 30761 00006556 89C7                            MOV     DI,AX
 30762                                  	; 15/03/2018
 30763 00006558 36A3[EC02]                      MOV     [SS:FirstArena],AX	; init the options
 30764 0000655C 36A3[EE02]                      MOV     [SS:BestArena],AX
 30765 00006560 36A3[F002]                      MOV     [SS:LastArena],AX
 30766 00006564 50                              PUSH    AX                      ; alloc_max <- 0
 30767                                  	; 04/08/2018
 30768                                  start_scan:
 30769                                  	; MSDOS 6.0
 30770                                  	;mov	ax,[SS:start_arena]	; M000: AX <- beginning of arena
 30771                                  	;
 30772 00006565 36A1[2400]              	MOV     AX,[SS:arena_head]	; AX <- beginning of arena
 30773 00006569 E8B3FF                  	CALL    check_signature         ; ES <- AX, carry set if error
 30774 0000656C 7212                            JC      SHORT alloc_err		; IF error THEN GOTO err
 30775                                  
 30776                                  alloc_scan:
 30777 0000656E 06                              PUSH    ES
 30778 0000656F 1F                              POP     DS                      ; DS <- ES
 30779 00006570 393E0100                        CMP     [ARENA.OWNER],DI
 30780 00006574 742A                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 30781                                  
 30782                                  alloc_next:
 30783                                  	; MSDOS 6.0			; M000 - start 
 30784                                  	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
 30785                                  	;jz	short norm_strat	; N: see if we reached last arena
 30786                                  	;
 30787                                  	;test	byte [AllocMethod],HIGH_FIRST
 30788                                  	;				; Q: is alloc strategy high_first
 30789                                  	;jz	short norm_strat	; N: see if we reached last arena
 30790                                  	;mov	ax,[start_arena]
 30791                                  	;cmp	ax,[arena_head]		; Q: did we start scan from 
 30792                                  					;    arena_head
 30793                                  	;jne	short norm_strat	; N: see if we reached last arena
 30794                                  	;mov	ax,ds			; ax = current block
 30795                                  	;cmp	ax,[umb_head]		; Q: check against umb_head 
 30796                                  	;jmp	short alloc_chk_end
 30797                                  
 30798                                  ;norm_strat:
 30799                                  	;cmp	byte [di],5Ah ; 'Z'
 30800 00006576 803D5A                          CMP     BYTE [DI],arena_signature_end
 30801                                                                          ; IF current block is last THEN
 30802 00006579 740E                            JZ      SHORT alloc_end		;   GOTO end
 30803 0000657B E89AFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 30804 0000657E 73EE                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 30805                                  
 30806                                  alloc_err:
 30807 00006580 58                              POP     AX
 30808                                  
 30809                                  alloc_trashed:
 30810                                  	;LeaveCrit critMem
 30811 00006581 E8E7BA                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0	
 30812                                          ;error	error_arena_trashed
 30813                                  	;mov	al,7
 30814 00006584 B007                    	MOV	AL,error_arena_trashed
 30815                                  alloc_errj:
 30816 00006586 E97DB1                  	JMP	SYS_RET_ERR
 30817                                  
 30818                                  alloc_end:
 30819 00006589 36833E[EC02]00                  CMP	WORD [SS:FirstArena],0	; 15/03/2018
 30820 0000658F 756B                    	JNZ     SHORT alloc_do_split
 30821                                  
 30822                                  	; MSDOS 6.0
 30823                                  	;mov	ax,[arena_head]
 30824                                  	;cmp	ax,[start_arena]	; Q: started scanning from arena_head
 30825                                  	;je	short alloc_fail	; Y: not enough memory
 30826                                  	;				; N:
 30827                                  	;				; Q: is the alloc strat HIGH_ONLY
 30828                                  	;test 	byte [AllocMethod],HIGH_ONLY
 30829                                  	;jnz	short alloc_fail	; Y: return size of largest UMB
 30830                                  	;
 30831                                  	;mov	[start_arena],ax	; N: start scanning from arena_head
 30832                                  	;jmp	short start_scan
 30833                                  	;				; M000 - end
 30834                                  
 30835                                  alloc_fail:
 30836                                          ;invoke Get_User_Stack
 30837 00006591 E877B0                          CALL	Get_User_Stack
 30838 00006594 5B                      	POP     BX
 30839                                          ;MOV	[SI].user_BX,BX
 30840                                  	;MOV	[SI+2],BX
 30841 00006595 895C02                  	mov	[SI+user_env.user_BX],bx
 30842                                  	;LeaveCrit critMem
 30843 00006598 E8D0BA                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 30844                                  	;error	error_not_enough_memory
 30845                                  	;mov	al,8
 30846 0000659B B008                    	MOV	AL,error_not_enough_memory
 30847                                  	;jmp	short alloc_errj
 30848 0000659D E966B1                  	JMP	SYS_RET_ERR
 30849                                  
 30850                                  alloc_free:
 30851 000065A0 E88CFF                          CALL    Coalesce		; add following free block to current
 30852 000065A3 72DB                            JC	SHORT alloc_err		; IF error THEN GOTO err
 30853 000065A5 8B0E0300                        MOV     CX,[ARENA.SIZE]
 30854 000065A9 5A                              POP     DX                      ; check for max found size
 30855 000065AA 39D1                            CMP     CX,DX
 30856 000065AC 7602                            JNA     SHORT alloc_test
 30857 000065AE 89CA                            MOV     DX,CX
 30858                                  
 30859                                  alloc_test:
 30860 000065B0 52                              PUSH    DX
 30861 000065B1 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 30862 000065B3 77C1                            JA      SHORT alloc_next	;   GOTO next
 30863                                  
 30864                                  	; 15/03/2018
 30865 000065B5 36833E[EC02]00                  CMP     WORD [SS:FirstArena],0
 30866 000065BB 7505                    	JNZ	SHORT alloc_best
 30867 000065BD 368C1E[EC02]                    MOV     [SS:FirstArena],DS	; save first one found	
 30868                                  alloc_best:
 30869 000065C2 36833E[EE02]00                  CMP     WORD [SS:BestArena],0
 30870 000065C8 740E                            JZ      SHORT alloc_make_best	; initial best
 30871 000065CA 06                              PUSH	ES
 30872 000065CB 368E06[EE02]                    MOV     ES,[SS:BestArena]
 30873 000065D0 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 30874 000065D5 07                              POP	ES
 30875 000065D6 7605                            JBE     SHORT alloc_last
 30876                                  alloc_make_best:
 30877 000065D8 368C1E[EE02]                    MOV     [SS:BestArena],DS	; assign best
 30878                                  alloc_last:
 30879 000065DD 368C1E[F002]                    MOV     [SS:LastArena],DS 	; assign last
 30880 000065E2 EB92                            JMP     SHORT alloc_next
 30881                                  ;
 30882                                  ; split the block high
 30883                                  ;
 30884                                  alloc_do_split_high:
 30885 000065E4 368E1E[F002]                    MOV     DS,[SS:LastArena]
 30886 000065E9 8B0E0300                        MOV     CX,[ARENA.SIZE]
 30887 000065ED 29D9                            SUB     CX,BX
 30888 000065EF 8CDA                            MOV     DX,DS
 30889 000065F1 7444                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 30890 000065F3 01CA                            ADD     DX,CX                   ; point to next block
 30891 000065F5 8EC2                            MOV     ES,DX                   ; no decrement!
 30892 000065F7 49                              DEC     CX
 30893 000065F8 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 30894 000065FA EB26                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 30895                                  ;
 30896                                  ; we have scanned memory and have found all appropriate blocks
 30897                                  ; check for the type of allocation desired; first and best are identical
 30898                                  ; last must be split high
 30899                                  ;
 30900                                  alloc_do_split:
 30901                                  	; 04/08/2018
 30902                                  	; MSDOS 6.0			; M000 - start
 30903                                  	;xor	cx,cx
 30904                                  	;mov	cl,[AllocMethod]
 30905                                  	;and	cx,STRAT_MASK		; mask off bit 7
 30906                                  	;cmp	cx,BEST_FIT		; Q; is the alloc strategy best_fit
 30907                                  
 30908                                  	; 15/03/2018
 30909                                          ;CMP     BYTE [SS:AllocMethod], 1
 30910                                  	; 04/08/2018
 30911 000065FC 36803E[B002]01          	CMP     BYTE [SS:AllocMethod],BEST_FIT
 30912 00006602 77E0                            JA      SHORT alloc_do_split_high
 30913 00006604 368E1E[EC02]                    MOV     DS,[SS:FirstArena]        
 30914 00006609 7205                    	JB      SHORT alloc_get_size
 30915 0000660B 368E1E[EE02]            	MOV     DS,[SS:BestArena]
 30916                                  
 30917                                  alloc_get_size:
 30918 00006610 8B0E0300                        MOV     CX,[ARENA.SIZE]
 30919 00006614 29D9                            SUB     CX,BX                   ; get room left over
 30920 00006616 8CD8                            MOV     AX,DS
 30921 00006618 89C2                            MOV     DX,AX                   ; save for owner setting
 30922 0000661A 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 30923 0000661C 01D8                            ADD     AX,BX
 30924 0000661E 40                              INC     AX                      ; remember the header
 30925 0000661F 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 30926 00006621 49                              DEC     CX                      ; CX <- size of split block
 30927                                  alloc_set_sizes:
 30928 00006622 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 30929 00006626 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 30930                                  	;mov	bl,4Dh ; 'M'
 30931 0000662B B34D                            MOV     BL,arena_signature_normal
 30932 0000662D 861D                            XCHG    BL,[DI]			; current signature <- 4D
 30933 0000662F 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 30934 00006632 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 30935                                  
 30936                                  alloc_set_owner:
 30937 00006637 8EDA                            MOV     DS,DX
 30938 00006639 36A1[DE02]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 30939 0000663D A30100                          MOV     [ARENA.OWNER],AX
 30940 00006640 8CD8                            MOV     AX,DS
 30941 00006642 40                              INC     AX
 30942 00006643 5B                              POP     BX
 30943                                  	;LeaveCrit critMem
 30944 00006644 E824BA                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 30945                                          ;transfer SYS_RET_OK
 30946 00006647 E9B3B0                  	JMP	SYS_RET_OK
 30947                                  
 30948                                  
 30949                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 30950                                  
 30951                                  ; MSDOS 6.0
 30952                                  ;----------------------------------------------------------------------------
 30953                                  ;**	$SETBLOCK - Change size of an Alocated Block
 30954                                  ;
 30955                                  ;	Setblock changes the size of an allocated block.  First, we coalesce
 30956                                  ;	any following free space onto this block; then we try to trim the
 30957                                  ;	block down to the size requested.
 30958                                  ;
 30959                                  ;	Note that if the guy wants to grow the block but that growth fails,
 30960                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 30961                                  ;	Thus the maximum-size-possible value that we return has already
 30962                                  ;	been allocated!  This is a bug, dare we fix it?  BUGBUG
 30963                                  ;
 30964                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 30965                                  ;		finish it's work.  FOr this reason we build the allocsf
 30966                                  ;		structure on the frame, to make us compatible with $ALLOCs
 30967                                  ;		code.
 30968                                  ;
 30969                                  ;	ENTRY	(es) = segment of old block
 30970                                  ;		(bx) = newsize
 30971                                  ;		(ah) = SETBLOCK
 30972                                  ;
 30973                                  ;	EXIT	'C' clear if OK
 30974                                  ;		'C' set if error
 30975                                  ;		  (ax) = error_invalid_block
 30976                                  ;		       = error_arena_trashed
 30977                                  ;		       = error_not_enough_memory
 30978                                  ;		       = error_invalid_function
 30979                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 30980                                  ;	USES	???? BUGBUG
 30981                                  ;----------------------------------------------------------------------------
 30982                                  
 30983                                  ; MSDOS 2.11 (& MSDOS 3.3)
 30984                                  ;----------------------------------------------------------------------------
 30985                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 30986                                  ;
 30987                                  ;   Assembler usage:
 30988                                  ;           MOV     ES,block
 30989                                  ;           MOV     BX,newsize
 30990                                  ;           MOV     AH,setblock
 30991                                  ;           INT     21h
 30992                                  ;         if setblock fails for growing, BX will have the maximum
 30993                                  ;         size possible
 30994                                  ;   Error return:
 30995                                  ;           AX = error_invalid_block
 30996                                  ;              = error_arena_trashed
 30997                                  ;              = error_not_enough_memory
 30998                                  ;              = error_invalid_function
 30999                                  ;----------------------------------------------------------------------------
 31000                                  
 31001                                  _$SETBLOCK:        
 31002                                  	; 04/08/2018 - Retro DOS v3.0
 31003                                  	;EnterCrit   critMem
 31004 0000664A E816BA                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 31005                                  
 31006 0000664D BF0000                  	MOV     DI,ARENA.SIGNATURE
 31007 00006650 8CC0                            MOV     AX,ES
 31008 00006652 48                              DEC     AX
 31009 00006653 E8C9FE                          CALL    check_signature
 31010 00006656 7303                            JNC     SHORT setblock_grab
 31011                                  
 31012                                  setblock_bad:
 31013 00006658 E926FF                          JMP     alloc_trashed
 31014                                  
 31015                                  setblock_grab:
 31016 0000665B 8ED8                            MOV     DS,AX
 31017 0000665D E8CFFE                          CALL    Coalesce
 31018 00006660 72F6                            JC      SHORT setblock_bad
 31019 00006662 8B0E0300                        MOV     CX,[ARENA.SIZE]
 31020 00006666 51                              PUSH    CX
 31021 00006667 39CB                            CMP     BX,CX
 31022 00006669 76A5                            JBE     SHORT alloc_get_size
 31023 0000666B E923FF                          JMP     alloc_fail
 31024                                  
 31025                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 31026                                  
 31027                                  ; MSDOS 6.0
 31028                                  ;----------------------------------------------------------------------------
 31029                                  ;**	$DEALLOC - Free Heap Memory
 31030                                  ;
 31031                                  ;	ENTRY	(es) = address of item
 31032                                  ;
 31033                                  ;	EXIT	'C' clear of OK
 31034                                  ;		'C' set if error
 31035                                  ;		  (AX) = error_invalid_block
 31036                                  ;	USES	???? BUGBUG
 31037                                  
 31038                                  ; MSDOS 2.11 (& MSDOS 3.3)
 31039                                  ;----------------------------------------------------------------------------
 31040                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 31041                                  ;
 31042                                  ;   Assembler usage:
 31043                                  ;           MOV     ES,block
 31044                                  ;           MOV     AH,dealloc
 31045                                  ;           INT     21h
 31046                                  ;
 31047                                  ;   Error return:
 31048                                  ;           AX = error_invalid_block
 31049                                  ;              = error_arena_trashed
 31050                                  ;---------------------------------------------------------------------------- 
 31051                                  
 31052                                  _$DEALLOC:    
 31053                                  	; 04/08/2018 - Retro DOS v3.0
 31054                                  	;EnterCrit   critMem
 31055 0000666E E8F2B9                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 31056                                  
 31057                                  	; MSDOS 6.0			; M016, M068 - Start
 31058                                  	;test	byte [DOS_FLAG],EXECA20OFF
 31059                                  					; Q: was the previous call an int 21
 31060                                  					;    exec call
 31061                                  	;jz	short deallocate	; N: continue
 31062                                  	;cmp	byte [A20OFF_COUNT], 0	; Q: is count 0
 31063                                  	;jne	short deallocate	; N: continue
 31064                                  	;mov	byte [A20OFF_COUNT], 1	; Y: set count to 1
 31065                                  ;deallocate:				; M016, M068 - End
 31066                                      
 31067 00006671 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 31068 00006674 8CC0                            MOV     AX,ES
 31069 00006676 48                              DEC     AX
 31070 00006677 E8A5FE                          CALL    check_signature
 31071 0000667A 720B                            JC      SHORT dealloc_err
 31072 0000667C 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 31073                                  	;LeaveCrit critMem
 31074 00006681 E8E7B9                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 31075                                          ;transfer SYS_RET_OK
 31076 00006684 E976B0                  	JMP	SYS_RET_OK
 31077                                  
 31078                                  dealloc_err:
 31079                                  	;LeaveCrit critMem
 31080 00006687 E8E1B9                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 31081                                          ;error	error_invalid_block
 31082                                  	;mov	al,9
 31083 0000668A B009                    	MOV	AL,error_invalid_block
 31084 0000668C E977B0                  	JMP	SYS_RET_ERR
 31085                                  
 31086                                  ;	BREAK $AllocOper - get/set allocation mechanism
 31087                                  
 31088                                  ; MSDOS 6.0
 31089                                  ;----------------------------------------------------------------------------
 31090                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 31091                                  ;
 31092                                  ;	Assembler usage:
 31093                                  ;           MOV     AH,AllocOper
 31094                                  ;           MOV     BX,method
 31095                                  ;           MOV     AL,func
 31096                                  ;           INT     21h
 31097                                  ;
 31098                                  ;	ENTRY	
 31099                                  ;		(al) = 0
 31100                                  ;		  Get allocation Strategy in (ax)
 31101                                  ;
 31102                                  ;		(al) = 1, (bx) = method = zw0000xy
 31103                                  ;		  Set allocation strategy.
 31104                                  ;		   w  = 1  => HIGH_ONLY
 31105                                  ;		   z  = 1  => HIGH_FIRST
 31106                                  ;		   xy = 00 => FIRST_FIT
 31107                                  ;		      = 01 => BEST_FIT
 31108                                  ;		      = 10 => LAST_FIT
 31109                                  ;
 31110                                  ;		(al) = 2
 31111                                  ;		  Get UMB link state in (al)
 31112                                  ;
 31113                                  ;		(al) = 3
 31114                                  ;		  Set UMB link state
 31115                                  ;		   (bx) = 0 => Unlink UMBs
 31116                                  ;		   (bx) = 1 => Link UMBs
 31117                                  ;
 31118                                  ;
 31119                                  ;	EXIT	'C' clear if OK
 31120                                  ;
 31121                                  ;		 if (al) = 0
 31122                                  ;		  (ax) = existing method
 31123                                  ;		 if (al) = 1
 31124                                  ;		  Sets allocation strategy
 31125                                  ;		 if (al) = 2
 31126                                  ;		  (al) = 0 => UMBs not linked
 31127                                  ;		  (al) = 1 => UMBs linked in
 31128                                  ;		 if (al) = 3
 31129                                  ;		  Links/Unlinks the UMBs into DOS chain
 31130                                  ;
 31131                                  ;		'C' set if error
 31132                                  ;		  AX = error_invalid_function
 31133                                  ;
 31134                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 31135                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 31136                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 31137                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 31138                                  ;		    arena' if an arena sig is damaged.
 31139                                  ;----------------------------------------------------------------------------
 31140                                  
 31141                                  ; MSDOS 2.11 (& MSDOS 3.3)
 31142                                  ;----------------------------------------------------------------------------
 31143                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 31144                                  ;
 31145                                  ;   Assembler usage:
 31146                                  ;           MOV     AH,AllocOper
 31147                                  ;           MOV     BX,method
 31148                                  ;           MOV     AL,func
 31149                                  ;           INT     21h
 31150                                  ;
 31151                                  ;   Error return:
 31152                                  ;           AX = error_invalid_function
 31153                                  ;----------------------------------------------------------------------------
 31154                                  
 31155                                  _$ALLOCOPER:
 31156                                  	; MSDOS 6.0
 31157                                  	;or	al, al
 31158                                  	;jz	short AllocGetStrat
 31159                                  	;cmp	al, 1
 31160                                  	;jz	short AllocSetStrat
 31161                                  	;cmp	al, 2
 31162                                  	;jz	short AllocGetLink
 31163                                  	;cmp	al, 3
 31164                                  	;jz	short AllocSetLink
 31165                                  
 31166                                  	; 15/04/2018
 31167 0000668F 3C01                    	CMP     AL,1
 31168 00006691 720D                            JB      SHORT AllocOperGet
 31169 00006693 7414                            JZ      SHORT AllocOperSet
 31170                                  
 31171                                  AllocOperError:
 31172                                  	; 04/08/2018 - Retro DOS v3.0
 31173                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 31174                                  	;mov	byte [ss:EXTERR_LOCUS],5
 31175 00006695 36C606[D102]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 31176                                  	;error	error_invalid_function
 31177                                  	;mov	al,1
 31178 0000669B B001                    	MOV	AL,error_invalid_function
 31179                                  AllocOperErrj:
 31180 0000669D E966B0                  	JMP	SYS_RET_ERR
 31181                                  
 31182                                  ;AllocArenaError:
 31183                                  	; MSDOS 6.0
 31184                                  	;MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 31185                                  	;				; M009: Extended Error Locus
 31186                                  	;;error   error_arena_trashed	; M009:
 31187                                  	;MOV	AL,error_arena_trashed
 31188                                  	;;JMP	SYS_RET_ERR
 31189                                  	;jmp	short AllocOperErrj
 31190                                  
 31191                                  ;AllocGetStrat: 
 31192                                  	; MSDOS 6.0
 31193                                  AllocOperGet:
 31194 000066A0 36A0[B002]                      MOV     AL,[SS:AllocMethod]
 31195 000066A4 30E4                            XOR     AH,AH
 31196                                          ;transfer SYS_RET_OK
 31197 000066A6 E954B0                  	JMP	SYS_RET_OK
 31198                                  
 31199                                  ;AllocSetStrat: 
 31200                                  	; MSDOS 6.0
 31201                                  	;push	bx			; M000 - start
 31202                                  	;and	bx,STRAT_MASK 		; M064: mask off bit 6 & 7
 31203                                  	;cmp	bx,2			; BX must be 0-2
 31204                                  	;pop	bx			; M000 - end
 31205                                  	;ja	short AllocOperError
 31206                                  
 31207                                  AllocOperSet:
 31208 000066A9 36881E[B002]                    MOV     [SS:AllocMethod],BL
 31209                                          ;transfer SYS_RET_OK
 31210 000066AE E94CB0                  	JMP	SYS_RET_OK
 31211                                  
 31212                                  ;AllocGetLink:
 31213                                  	; MSDOS 6.0
 31214                                  	;mov	al,[UmbFlag]		; return link state in al
 31215                                  	;and 	al,LINKSTATE		
 31216                                  	;;transfer SYS_RET_OK
 31217                                  	;jmp	SYS_RET_OK
 31218                                  
 31219                                  ;AllocSetLink:
 31220                                  	; MSDOS 6.0			; M009 - start
 31221                                  	;mov	cx,[umb_head]		; cx = umb_head
 31222                                  	;cmp	cx,0FFFFh		; Q: has umb_head been initialized
 31223                                  	;je	short AllocOperError	; N: error
 31224                                  	;				; Y: continue
 31225                                  	;				; M009 - end
 31226                                  	;cmp	bx,1			
 31227                                  	;jb	short UnlinkUmbs
 31228                                  	;jz	short LinkUmbs
 31229                                  	;
 31230                                  	;jmp	short AllocOperError
 31231                                  	;
 31232                                  ;UnlinkUmbs:
 31233                                  	;test	byte[UmbFlag],LINKSTATE	; Q: umbs unlinked?
 31234                                  	;jz	short unlinked		; Y: return 
 31235                                  	;
 31236                                  	;call	GetLastArena		; get arena before umb_head in DS
 31237                                  	;jc	short AllocArenaError	; M009: arena trashed
 31238                                  	;
 31239                                  	;				; make it last
 31240                                  	;mov	byte [0],arena_signature_end
 31241                                  	;
 31242                                  	;and	byte [UmbFlag],~LINKSTATE ; indicate unlink'd state in umbflag
 31243                                  	;
 31244                                  ;unlinked:
 31245                                  	;;transfer SYS_RET_OK
 31246                                  	;jmp	SYS_RET_OK
 31247                                  
 31248                                  ;LinkUmbs:
 31249                                  	;test	byte [UmbFlag],LINKSTATE ; Q: umbs linked?
 31250                                  	;jnz	short linked		; Y: return
 31251                                  	;
 31252                                  	;call	GetLastArena		; get arena before umb_head
 31253                                  	;jc	short AllocArenaError	; M009: arena trashed
 31254                                  	;
 31255                                  	;				; make it normal. M061: ds points to
 31256                                  	;				; arena before umb_head
 31257                                  	;mov	byte [0],arena_signature_normal
 31258                                  	;
 31259                                  	;or	byte [UmbFlag],LINKSTATE ; indicate link'd state in umbflag
 31260                                  ;linked:
 31261                                  	;;transfer SYS_RET_OK
 31262                                  	;jmp	SYS_RET_OK
 31263                                  
 31264                                  ; MSDOS 6.0
 31265                                  ;--------------------------------------------------------------------------
 31266                                  ; Procedure Name : GetLastArena		-  M003
 31267                                  ;
 31268                                  ; Inputs	 : cx = umb_head
 31269                                  ;
 31270                                  ;
 31271                                  ; Outputs	 : If UMBs are linked
 31272                                  ;			ES = umb_head
 31273                                  ;			DS = arena before umb_head
 31274                                  ;		   else
 31275                                  ;			DS = last arena
 31276                                  ;			ES = next arena. will be umb_head if NC.
 31277                                  ;
 31278                                  ;		   CY if error
 31279                                  ;
 31280                                  ; Uses		 : DS, ES, DI, BX
 31281                                  ;--------------------------------------------------------------------------
 31282                                  	
 31283                                  ;Procedure	GetLastArena, NEAR
 31284                                  ;
 31285                                  ;	push	ax			; save ax
 31286                                  ;
 31287                                  ;	mov	ax, [arena_head]
 31288                                  ;	mov	es, ax			; es = arena_head
 31289                                  ;	xor	di, di
 31290                                  ;
 31291                                  ;	cmp     byte ptr es:[di],arena_signature_end
 31292                                  ;					; Q: is this the last arena
 31293                                  ;	je	GLA_done		; Y: return last arena in ES		
 31294                                  ;					
 31295                                  ;
 31296                                  ;GLA_next:
 31297                                  ;	mov	ds, ax
 31298                                  ;	call	arena_next		; ax, es -> next arena
 31299                                  ;	jc	GLA_err
 31300                                  ;
 31301                                  ;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
 31302                                  ;	jnz	GLA_chkumb		; Y: terminating condition is 
 31303                                  ;					;    umb_head
 31304                                  ;					; N: terminating condition is 05Ah
 31305                                  ;
 31306                                  ;	cmp     byte ptr es:[di],arena_signature_end
 31307                                  ;					; Q: is this the last arena
 31308                                  ;	jmp	short @f
 31309                                  ;GLA_chkumb:
 31310                                  ;	cmp	ax, cx			; Q: is this umb_head
 31311                                  ;@@:
 31312                                  ;	jne	GLA_next		; N: get next arena
 31313                                  ;
 31314                                  ;GLA_done:
 31315                                  ;					; M061 - Start
 31316                                  ;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
 31317                                  ;	jnz	GLA_ret			; Y: we're done
 31318                                  ;					; N: let us confirm that the next 
 31319                                  ;					;    arena is umb_head
 31320                                  ;	mov	ds, ax
 31321                                  ;	call	arena_next		; ax, es -> next arena
 31322                                  ;	jc	GLA_err
 31323                                  ;	cmp	ax, cx			; Q: is this umb_head
 31324                                  ;	jne	GLA_err			; N: error
 31325                                  ;					; M061 - End
 31326                                  ;
 31327                                  ;GLA_ret:				
 31328                                  ;	clc
 31329                                  ;	pop	ax			; M061
 31330                                  ;	ret				; M061
 31331                                  ;
 31332                                  ;GLA_err:
 31333                                  ;	stc				; M061
 31334                                  ;	pop	ax
 31335                                  ;	ret
 31336                                  ;
 31337                                  ;EndProc GetLastArena
 31338                                  
 31339                                  ;============================================================================
 31340                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 31341                                  ;============================================================================
 31342                                  ; 04/08/2018 - Retro DOS v3.0
 31343                                  
 31344                                  ;	TITLE SRVCALL - Server DOS call
 31345                                  ;	NAME  SRVCALL
 31346                                  
 31347                                  ;**	SRVCALL.ASM - Server DOS call functions
 31348                                  ;
 31349                                  ;
 31350                                  ;	$ServerCall
 31351                                  ;
 31352                                  ;	Modification history:
 31353                                  ;
 31354                                  ;	    Created: ARR 08 August 1983
 31355                                  
 31356                                  ;AsmVars <Installed>
 31357                                  
 31358                                  ;include dpl.asm
 31359                                  
 31360                                  ;Installed = TRUE
 31361                                  
 31362                                  ;BREAK <ServerCall -- Server DOS call>
 31363                                  ;----------------------------------------------------------------------------
 31364                                  ;
 31365                                  ; Procedure Name : $ServerCall
 31366                                  ;
 31367                                  ; Inputs:
 31368                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 31369                                  ; Function:
 31370                                  ;	AL=0	Server DOS call
 31371                                  ;	AL=1	Commit All files
 31372                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 31373                                  ;	AL=3	Close all files for DPL_UID
 31374                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 31375                                  ;	AL=5	Get open file list entry
 31376                                  ;		    IN: BX File Index
 31377                                  ;			CX User Index
 31378                                  ;		    OUT:ES:DI -> Name
 31379                                  ;			BX = UID
 31380                                  ;		    CX = # locked blocks held by this UID
 31381                                  ;	AL=6	Get DOS data area
 31382                                  ;		    OUT: DS:SI -> Start
 31383                                  ;			CX size in bytes of swap if indos
 31384                                  ;			DX size in bytes of swap always
 31385                                  ;	AL=7	Get truncate flag
 31386                                  ;	AL=8	Set truncate flag
 31387                                  ;	AL=9	Close all spool files
 31388                                  ;	AL=10	SetExtendedError
 31389                                  ;
 31390                                  ;----------------------------------------------------------------------------
 31391                                  
 31392                                  _$ServerCall:
 31393                                  	; 05/08/2018 - Retro DOS v3.0
 31394                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 31395 000066B1 3C07                    	CMP	AL,7
 31396 000066B3 7204                    	JB	short SET_STUFF
 31397 000066B5 3C09                    	CMP	AL,9
 31398 000066B7 7612                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 31399                                  SET_STUFF:
 31400 000066B9 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 31401                                  	;mov	bx,[si+12h]
 31402 000066BB 8B5C12                  	MOV	BX,[SI+DPL.UID]
 31403                                  
 31404                                  	; MSDOS 6.0
 31405                                  ;SR;
 31406                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 31407                                  ; of USER_ID
 31408                                  ;
 31409                                  	;test	byte [SS:IsWin386],1
 31410                                  	;jnz	short skip_win386
 31411                                  
 31412                                  ;hkn; SS override for user_id and proc_id
 31413                                  	; 15/08/2018
 31414 000066BE 36891E[EA02]            	MOV	[SS:USER_ID],BX		; Set UID
 31415                                  
 31416                                  ;skip_win386:
 31417                                  
 31418 000066C3 8B5C14                  	MOV	BX,[SI+DPL.PID]
 31419 000066C6 36891E[E802]            	MOV	[SS:PROC_ID],BX		; Set process ID
 31420                                  NO_SET_ID:
 31421 000066CB 36FF36[3A14]            	PUSH	word [SS:SERVERLEAVE]	; push return address
 31422 000066D0 36FF36[3814]            	PUSH	word [SS:SERVERTAB]	; push table address
 31423 000066D5 50                      	PUSH	AX
 31424 000066D6 E8C1B8                  	call	TableDispatch
 31425                                  
 31426                                  ;hkn; SS override
 31427                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 31428 000066D9 36C606[D102]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 31429                                  	;error	error_invalid_function
 31430                                  	;mov	al,1
 31431 000066DF B001                    	MOV	AL,error_invalid_function
 31432                                  servercall_error:
 31433 000066E1 E922B0                  	JMP	SYS_RET_ERR
 31434                                  
 31435                                  SERVERRETURN:
 31436 000066E4 C3                      	retn
 31437                                  
 31438                                  ; Commit - iterate through the open file list and make sure that the
 31439                                  ; directory entries are correctly updated.
 31440                                  
 31441                                  COMMIT_ALL:
 31442 000066E5 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 31443 000066E7 16                      	push	ss
 31444 000066E8 1F                      	pop	ds
 31445 000066E9 E877B9                  	call	EcritSFT		; Gonna scan SFT cache, lock it down
 31446                                  CommitLoop:
 31447 000066EC 53                      	push	bx
 31448 000066ED E82501                  	call	SFFromSFN
 31449 000066F0 7223                    	JC	short CommitDone
 31450 000066F2 26833D00                	cmp	word [es:di],0
 31451                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 31452                                  					; if (ThisSFT->refcount != 0)
 31453 000066F6 7419                    	JZ	short CommitNext
 31454                                  	;cmp	word [es:di],0FFFFh ; -1
 31455 000066F8 26833DFF                	cmp	word [ES:DI],sf_busy
 31456                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 31457                                  					; BUSY SFTs have god knows what
 31458 000066FC 7413                    	JZ	short CommitNext	;   in them.
 31459 000066FE 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 31460 00006704 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 31461                                  					;	doesn't deadlock
 31462 00006706 893E[3605]              	MOV	[THISSFT],DI
 31463 0000670A 8C06[3805]              	MOV	[THISSFT+2],ES
 31464 0000670E E8AAD4                  	call	DOS_COMMIT		;	DOSCommit ();
 31465                                  CommitNext:
 31466 00006711 5B                      	pop	bx
 31467 00006712 43                      	INC	BX
 31468 00006713 EBD7                    	JMP	short CommitLoop
 31469                                  CommitDone:
 31470 00006715 E853B9                  	call	LcritSFT
 31471 00006718 5B                      	pop	bx
 31472 00006719 E9E1AF                  	jmp	SYS_RET_OK
 31473                                  
 31474                                  CLOSE_NAME:
 31475                                  
 31476                                  ;if installed
 31477                                  
 31478                                  ;hkn; SS override
 31479 0000671C 36FF1E[7000]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 31480                                  ;else
 31481                                  ;	Call	MFTcloN
 31482                                  ;endif
 31483                                  
 31484                                  CheckReturns:
 31485 00006721 7203                    	JC	short func_err
 31486 00006723 E9D7AF                  	jmp	SYS_RET_OK
 31487                                  func_err:
 31488                                  	;transfer SYS_RET_ERR
 31489                                  	;jmp	SYS_RET_ERR
 31490 00006726 EBB9                    	jmp	short servercall_error
 31491                                  
 31492                                  CLOSE_UID:
 31493                                  
 31494                                  ;if installed
 31495                                  ;hkn; SS override
 31496 00006728 36FF1E[6800]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 31497                                  ;else
 31498                                  ;	Call	MFTclU
 31499                                  ;endif
 31500 0000672D EBF2                    	JMP	short CheckReturns
 31501                                  
 31502                                  CLOSE_UID_PID:
 31503                                  
 31504                                  ;if installed
 31505                                  ;hkn; SS override
 31506 0000672F 36FF1E[6C00]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 31507                                  ;else
 31508                                  ;	Call	MFTCloseP
 31509                                  ;endif
 31510 00006734 EBEB                    	JMP	CheckReturns
 31511                                  
 31512                                  GET_LIST:
 31513                                  
 31514                                  ;if installed
 31515                                  ;hkn; SS override
 31516 00006736 36FF1E[8000]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 31517                                  ;else
 31518                                  ;	Call	MFT_get
 31519                                  ;endif
 31520 0000673B 72E9                    	JC	short func_err
 31521 0000673D E8CBAE                  	call	Get_User_Stack
 31522                                  	;mov	[si+2],bx
 31523 00006740 895C02                  	MOV	[SI+user_env.user_BX],BX
 31524                                  	;mov	[si+10],di
 31525 00006743 897C0A                  	MOV	[SI+user_env.user_DI],DI
 31526                                  	;mov	[si+16],es
 31527 00006746 8C4410                  	MOV	[SI+user_env.user_ES],ES
 31528                                  SetCXOK:
 31529                                  	;mov	[si+4],cx
 31530 00006749 894C04                  	MOV	[SI+user_env.user_CX],CX
 31531 0000674C E9AEAF                  	jmp	SYS_RET_OK
 31532                                  
 31533                                  SRV_CALL:
 31534 0000674F 58                      	POP	AX			; get rid of call to $srvcall
 31535 00006750 1E                      	push	ds
 31536 00006751 56                      	push	si
 31537 00006752 E8B6AE                  	call	Get_User_Stack
 31538 00006755 5F                      	pop	di
 31539 00006756 07                      	pop	es
 31540                                  ;
 31541                                  ; DS:SI point to stack
 31542                                  ; ES:DI point to DPL
 31543                                  ;
 31544 00006757 E81FB8                  	call	XCHGP
 31545                                  ;
 31546                                  ; DS:SI point to DPL
 31547                                  ; ES:DI point to stack
 31548                                  ;
 31549                                  ; We now copy the registers from DPL to save stack
 31550                                  ;
 31551 0000675A 56                      	push	si
 31552 0000675B B90600                  	MOV	CX,6
 31553 0000675E F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 31554 00006760 47                      	INC	DI
 31555 00006761 47                      	INC	DI			; Skip user_BP
 31556 00006762 A5                      	MOVSW				; DS
 31557 00006763 A5                      	MOVSW				; ES
 31558 00006764 5E                      	pop	si			; DS:SI -> DPL
 31559 00006765 8B04                    	mov	ax,[SI]
 31560                                  	;MOV	AX,[SI+DPL.AX]
 31561                                  	;mov	bx,[si+2]
 31562 00006767 8B5C02                  	MOV	BX,[SI+DPL.BX]
 31563                                  	;mov	cx,[si+4]
 31564 0000676A 8B4C04                  	MOV	CX,[SI+DPL.CX]
 31565                                  	;mov	dx,[si+6]
 31566 0000676D 8B5406                  	MOV	DX,[SI+DPL.DX]
 31567                                  	;mov	di,[si+10]
 31568 00006770 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 31569                                  	;mov	es,[si+14]
 31570 00006773 8E440E                  	MOV	ES,[SI+DPL.ES]
 31571                                  	;push	word [si+8]
 31572 00006776 FF7408                  	PUSH	word [SI+DPL.SI]
 31573                                  	;mov	ds,[si+12]
 31574 00006779 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 31575 0000677C 5E                      	POP	SI
 31576                                  
 31577                                  ;hkn; SS override for next 3
 31578 0000677D 368C1E[7E05]            	MOV	[SS:SAVEDS],DS
 31579 00006782 36891E[7C05]            	MOV	[SS:SAVEBX],BX
 31580 00006787 36C606[0D05]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 31581 0000678D E9B5AD                  	jmp	REDISP
 31582                                  
 31583                                  GET_DOS_DATA:
 31584 00006790 16                      	push	ss
 31585 00006791 07                      	pop	es
 31586 00006792 BF[CE02]                	MOV     DI,SWAP_START
 31587 00006795 B9[090A]                	MOV     CX,SWAP_END
 31588 00006798 BA[E602]                	MOV     DX,SWAP_ALWAYS
 31589 0000679B 29F9                    	SUB     CX,DI
 31590 0000679D 29FA                    	SUB     DX,DI
 31591 0000679F D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 31592 000067A1 83D100                  	ADC     CX,0                    ; div by 2 + round up
 31593 000067A4 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 31594 000067A6 E862AE                  	call	Get_User_Stack
 31595                                  	;mov	[si+14],es
 31596 000067A9 8C440E                  	MOV     [SI+user_env.user_DS],ES
 31597                                  	;mov	[si+8],di
 31598 000067AC 897C08                  	MOV     [SI+user_env.user_SI],DI
 31599                                  	;mov	[si+6],dx
 31600 000067AF 895406                  	MOV     [SI+user_env.user_DX],DX
 31601 000067B2 EB95                    	JMP	short SetCXOK
 31602                                  
 31603                                  SPOOL_OPER:
 31604                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 31605                                  
 31606 000067B4 50                      	push    ax
 31607 000067B5 B82511                  	mov     ax, 1125h
 31608 000067B8 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 31609                                  			; STACK: WORD subfunction
 31610                                  			; Return: CF set on error, AX = error code
 31611                                  			; STACK unchanged
 31612 000067BA 5B                      	pop	bx
 31613 000067BB 7203                    	JC	short func_err2
 31614 000067BD E93DAF                  	jmp	SYS_RET_OK
 31615                                  func_err2:
 31616 000067C0 E943AF                  	jmp	SYS_RET_ERR
 31617                                  
 31618                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 31619                                  ;--------------------------------------------------------------------------
 31620                                  ;
 31621                                  ; Procedure Name : $SetExtendedError
 31622                                  ;
 31623                                  ; $SetExtendedError takes extended error information and loads it up for the
 31624                                  ; next extended error call.  This is used by interrupt-level proccessors to
 31625                                  ; mask their actions.
 31626                                  ;
 31627                                  ;   Inputs: DS:SI points to DPL which contains all registers
 31628                                  ;   Outputs: none
 31629                                  ;
 31630                                  ;---------------------------------------------------------------------------
 31631                                  
 31632                                  _$SetExtendedError:
 31633                                  
 31634                                  ;hkn; SS override for all variables used
 31635                                  
 31636 000067C3 8B04                    	mov	ax,[si]
 31637                                  	;MOV	AX,[SI+DPL.AX]
 31638 000067C5 36A3[D202]              	MOV	[SS:EXTERR],AX
 31639                                  	;mov	ax,[si+10]
 31640 000067C9 8B440A                  	MOV	AX,[SI+DPL.DI]
 31641 000067CC 36A3[D602]              	MOV	[SS:EXTERRPT],AX
 31642                                  	;mov	ax,[si+14]
 31643 000067D0 8B440E                  	MOV	AX,[SI+DPL.ES]
 31644 000067D3 36A3[D802]              	MOV	[SS:EXTERRPT+2],AX
 31645                                  	;mov	ax,[si+2]
 31646 000067D7 8B4402                  	MOV	AX,[SI+DPL.BX]
 31647 000067DA 36A3[D402]              	MOV	[SS:EXTERR_ACTION],AX
 31648                                  	;mov	ax,[si+4]
 31649 000067DE 8B4404                  	MOV	AX,[SI+DPL.CX]
 31650 000067E1 368826[D102]            	MOV	[SS:EXTERR_LOCUS],AH
 31651 000067E6 C3                      	retn
 31652                                  
 31653                                  ;============================================================================
 31654                                  ; UTIL.ASM, MSDOS 6.0, 1991
 31655                                  ;============================================================================
 31656                                  ; 05/08/2018 - Retro DOS v3.0
 31657                                  
 31658                                  ;**	Handle related utilities for MSDOS 2.X.
 31659                                  ;
 31660                                  ;	pJFNFromHandle	written
 31661                                  ;	SFFromHandle	written
 31662                                  ;	SFFromSFN	written
 31663                                  ;	JFNFree 	written
 31664                                  ;	SFNFree 	written
 31665                                  ;
 31666                                  ;	Modification history:
 31667                                  ;
 31668                                  ;	    Created: MZ 1 April 1983
 31669                                  
 31670                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 31671                                  
 31672                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 31673                                  ;----------------------------------------------------------------------------
 31674                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 31675                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 31676                                  ;
 31677                                  ;	NOTE:
 31678                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 31679                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 31680                                  ;
 31681                                  ;	ENTRY	(bx) = handle
 31682                                  ;	EXIT	'C' clear if ok
 31683                                  ;		  (es:di) = address of JFN value
 31684                                  ;		'C' set if error
 31685                                  ;		  (ax) = error code
 31686                                  ;	USES	AX, DI, ES, Flags
 31687                                  ;----------------------------------------------------------------------------
 31688                                  
 31689                                  pJFNFromHandle:
 31690                                  
 31691 000067E7 2E8E06[DE02]            	MOV	ES,[cs:CurrentPDB]	; get user process data block
 31692                                  	;cmp	bx,[ES:32h]
 31693 000067EC 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 31694 000067F1 7204                    	JB	short pjfn10		; no, get offset
 31695                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 31696                                  	;mov	al,6
 31697 000067F3 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 31698                                  ReturnCarry:
 31699 000067F5 F9                      	STC                             ; signal error
 31700 000067F6 C3                      	retn				; go back
 31701                                  pjfn10: 
 31702                                  	;les	di,[es:34h]
 31703 000067F7 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 31704 000067FC 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 31705                                  	;clc
 31706                                  pJFNFromHandle_error:
 31707 000067FE C3                      	retn
 31708                                  
 31709                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 31710                                  ;----------------------------------------------------------------------------
 31711                                  ;
 31712                                  ; Procedure Name : SFFromHandle
 31713                                  ;
 31714                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 31715                                  ;
 31716                                  ;   Input:      BX has handle
 31717                                  ;   Output:     Carry Set
 31718                                  ;                   AX has error code
 31719                                  ;               Carry Reset
 31720                                  ;                   ES:DI has pointer to SF entry
 31721                                  ;   Registers modified: If error, AX,ES, else ES:DI
 31722                                  ; NOTE:
 31723                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 31724                                  ;       at DOSINIT time with SS NOT DOSGROUP
 31725                                  ;
 31726                                  ;----------------------------------------------------------------------------
 31727                                  
 31728                                  SFFromHandle:
 31729 000067FF E8E5FF                  	CALL    pJFNFromHandle          ; get jfn pointer
 31730                                  	;retc				; return if error
 31731 00006802 72FA                    	jc	short pJFNFromHandle_error
 31732 00006804 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 31733                                  	;JNZ	short GetSF		; nope, suck out SF
 31734                                  	;;mov	al,6
 31735                                  	;MOV	AL,error_invalid_handle ; appropriate error
 31736                                  	;jmp	short ReturnCarry	; signal it
 31737 00006808 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 31738                                  GetSF:
 31739 0000680A 53                      	push	bx			; save handle
 31740 0000680B 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 31741 0000680E 30FF                    	XOR     BH,BH                   ; ignore upper half
 31742 00006810 E80200                  	CALL    SFFromSFN               ; get real sf spot
 31743 00006813 5B                      	pop	bx			; restore
 31744 00006814 C3                      	retn                          ; say goodbye
 31745                                  
 31746                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 31747                                  
 31748                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 31749                                  ;----------------------------------------------------------------------------
 31750                                  ;	SFFromSfn uses an SFN to index an entry into the SF table.  This
 31751                                  ;	is more than just a simple index instruction because the SF table
 31752                                  ;	can be made up of multiple pieces chained together. We follow the
 31753                                  ;	chain to the right piece and then do the index operation.
 31754                                  ;
 31755                                  ;   NOTE:
 31756                                  ;	This routine is called from SFFromHandle which is called
 31757                                  ;       at DOSINIT time with SS NOT DOSGROUP
 31758                                  ;
 31759                                  ;	ENTRY	BX has SF index
 31760                                  ;	EXIT	'C' clear if OK
 31761                                  ;		  ES:DI points to SF entry
 31762                                  ;		'C' set if index too large
 31763                                  ;	USES	BX, DI, ES
 31764                                  ;----------------------------------------------------------------------------
 31765                                  
 31766                                  SFFromSFN:
 31767 00006815 2EC43E[2A00]            	LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 31768                                  sfsfn5:	
 31769                                  	;cmp	bx,[es:di+4]
 31770 0000681A 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 31771 0000681E 720E                    	JB	short sfsfn7		; yes, go grab it
 31772                                  	;sub	bx,[es:di+4]
 31773 00006820 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 31774 00006824 26C43D                  	les	di,[es:di] ; 14/08/2018
 31775                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 31776 00006827 83FFFF                  	CMP     DI,-1                   ; end of tables?
 31777 0000682A 75EE                    	JNZ	short sfsfn5		; no, try again
 31778 0000682C F9                      	STC
 31779 0000682D C3                      	retn				; return with error, not found
 31780                                  
 31781                                  sfsfn7:
 31782 0000682E 50                      	push	ax
 31783                                  	;mov	ax,53
 31784 0000682F B83500                  	MOV     AX,SF_ENTRY.size	; put it in a nice place
 31785 00006832 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 31786 00006834 01C7                    	ADD	DI,AX			; add base of SF block
 31787 00006836 58                      	pop	ax
 31788                                  	;add	di,6
 31789 00006837 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 31790 0000683A C3                      	retn				; return with 'C' clear
 31791                                  
 31792                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 31793                                  
 31794                                  ;**	JFNFree - Find a Free JFN Slot
 31795                                  ;----------------------------------------------------------------------------
 31796                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 31797                                  ;
 31798                                  ;	ENTRY	(ss) = DOSDATA
 31799                                  ;	EXIT	'C' clear if OK
 31800                                  ;		  (bx) = new handle
 31801                                  ;		  (es:di) = pointer to JFN slot
 31802                                  ;		'C' set if error
 31803                                  ;		  (al) = error code
 31804                                  ;	USES	bx, di, es, flags
 31805                                  ;----------------------------------------------------------------------------
 31806                                  
 31807                                  JFNFree:
 31808 0000683B 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 31809                                  jfnf1:	
 31810 0000683D E8A7FF                  	CALL	pJFNFromHandle		; get the appropriate handle
 31811 00006840 7209                    	JC	short jfnf5		; no more handles
 31812 00006842 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 31813 00006846 7405                    	je	short jfnfx		; yes, carry is clear
 31814 00006848 43                      	INC     BX                      ; no, next handle
 31815 00006849 EBF2                    	JMP	short jfnf1		; and try again
 31816                                  
 31817                                  ;	Error.	'C' set
 31818                                  jfnf5:	
 31819                                  	;mov	al,4
 31820 0000684B B004                    	MOV	AL,error_too_many_open_files
 31821                                  jfnfx:	
 31822 0000684D C3                      	retn				; bye
 31823                                  
 31824                                  ;	BREAK <SFNFree - Allocate a free SFN>
 31825                                  
 31826                                  ;**	SFNFree - Allocate a Free SFN/SFT
 31827                                  ;----------------------------------------------------------------------------
 31828                                  ;	SFNFree scans through the sf table looking for a free entry
 31829                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 31830                                  ;
 31831                                  ;	The problem is that we want to mark the SFT busy so that other threads
 31832                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 31833                                  ;	we can't just mark it busy because we may get blown out of our open
 31834                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 31835                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 31836                                  ;	an SFT with this value we look to see if it belongs to this user
 31837                                  ;	and process.  If it does belong to us then it must be an orphan
 31838                                  ;	and we reclaim it.
 31839                                  ;
 31840                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 31841                                  ;		over and over, but we could at least set a high water mark...
 31842                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 31843                                  ;		even though this is not a frequently called routine - jgl
 31844                                  ;
 31845                                  ;	ENTRY	(ss) = DOSDATA
 31846                                  ;	EXIT	'C' clear if no error
 31847                                  ;		  (bx) = SFN
 31848                                  ;		  (es:di) = pointer to SFT
 31849                                  ;		  es:[di].SFT_REF_COUNT = -1
 31850                                  ;		'C' set if error
 31851                                  ;		  (al) = error code
 31852                                  ;	USES	bx, di, es, Flags
 31853                                  ;----------------------------------------------------------------------------
 31854                                  
 31855                                  SFNFree:
 31856                                  	;12/08/2018
 31857                                  	;05/08/2018 - Retro DOS v3.0
 31858                                  	; MSDOS 6.0
 31859 0000684E 50                      	push	ax
 31860 0000684F 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 31861                                  sfnf5:	
 31862 00006851 53                      	push	bx
 31863 00006852 E8C0FF                  	call	SFFromSFN		; get the potential handle
 31864 00006855 5B                      	pop	bx
 31865 00006856 723A                    	jc	short sfnf95		; no more free SFNs
 31866 00006858 26833D00                	cmp	word [ES:DI],0
 31867                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 31868 0000685C 741D                    	je	short sfnf20			; yep, got one
 31869                                  	
 31870                                  	;cmp	word [es:di],0FFFFh ; -1
 31871 0000685E 26833DFF                	cmp	word [ES:DI],sf_busy
 31872                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 31873 00006862 7403                    	je	short sfnf10		; special busy mark
 31874                                  sfnf7:	
 31875 00006864 43                      	inc	bx			; try the next one
 31876 00006865 EBEA                    	jmp	short sfnf5
 31877                                  
 31878                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 31879                                  ;	it was abandoned during a earlier call and we can use it.
 31880                                  ;
 31881                                  ;	(bx)	= SFN
 31882                                  ;	(es:di) = pointer to SFT
 31883                                  ;	(TOS)	= caller's (ax)
 31884                                  
 31885                                  sfnf10:	
 31886 00006867 36A1[EA02]              	mov	ax,[SS:USER_ID]
 31887                                  	;cmp	[es:di+2Fh],ax
 31888 0000686B 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 31889 0000686F 75F3                    	jnz	short sfnf7		; not ours
 31890 00006871 36A1[E802]              	mov	ax,[SS:PROC_ID]
 31891                                  	;cmp	[es:di+31h],ax
 31892 00006875 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 31893 00006879 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 31894                                  
 31895                                  ;	We have an SFT to allocate
 31896                                  ;
 31897                                  ;	(bx)	= SFN
 31898                                  ;	(es:di) = pointer to SFT
 31899                                  ;	(TOS)	= caller's (ax)
 31900                                  
 31901                                  sfnf20:
 31902                                  	; cf = 0 ;; Retro DOS v3.0
 31903                                  
 31904                                  	;mov	word [es:di],0FFFFh
 31905 0000687B 26C705FFFF              	mov	word [ES:DI],sf_busy
 31906                                  					; make sure that this is allocated
 31907                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 31908                                  
 31909 00006880 36A1[EA02]              	mov	ax,[SS:USER_ID]
 31910                                  	;mov	[es:di+2Fh],ax
 31911 00006884 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 31912 00006888 36A1[E802]              	mov	ax,[SS:PROC_ID]
 31913                                  	;mov	[es:di+31h],ax
 31914 0000688C 26894531                	mov	[es:DI+SF_ENTRY.sf_PID],ax
 31915                                  sfnf21: ;; Retro DOS v3.0
 31916 00006890 58                      	pop	ax
 31917                                  	;clc
 31918 00006891 C3                      	retn				; return with no error
 31919                                  
 31920                                  ;**	Error - no more free SFNs
 31921                                  ;
 31922                                  ;	'C' set
 31923                                  ;	(TOS) = saved ax
 31924                                  
 31925                                  sfnf95: 
 31926 00006892 58                      	pop	ax
 31927                                  	;mov	al,4
 31928 00006893 B004                    	mov	al,error_too_many_open_files
 31929 00006895 C3                      	retn				; return with 'C' and error
 31930                                  
 31931                                  ;============================================================================
 31932                                  ; MACRO.ASM, MSDOS 6.0, 1991
 31933                                  ;============================================================================
 31934                                  ; Retro	DOS v3.0 - 11/07/2018
 31935                                  
 31936                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 31937                                  ;	NAME	MACRO
 31938                                  
 31939                                  ;	Microsoft Confidential
 31940                                  ;	Copyright (C) Microsoft Corporation 1991
 31941                                  ;	All Rights Reserved.
 31942                                  
 31943                                  ;**	MACRO.ASM
 31944                                  ;
 31945                                  ;	$AssignOper
 31946                                  ;	FIND_DPB
 31947                                  ;	InitCDS
 31948                                  ;	$UserOper
 31949                                  ;	GetVisDrv
 31950                                  ;	GetThisDrv
 31951                                  ;	GetCDSFromDrv
 31952                                  ;
 31953                                  ;   Revision history:
 31954                                  ;
 31955                                  ;	Created: MZ 4 April 1983
 31956                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 31957                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 31958                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 31959                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 31960                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 31961                                  ;				    aliasing.
 31962                                  ;
 31963                                  ;   MSDOS performs several types of name translation. First, we maintain for
 31964                                  ;   each valid drive letter the text of the current directory on that drive.
 31965                                  ;   For invalid drive letters, there is no current directory so we pretend to
 31966                                  ;   be at the root. A current directory is either the raw local directory
 31967                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 31968                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 31969                                  ;
 31970                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 31971                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 31972                                  ;   this and all * are expanded into ?'s.
 31973                                  ;
 31974                                  ;   The second part of name translation involves subtree aliasing. A list of
 31975                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 31976                                  ;   the previous 'canonicalization' are then examined to see if any of the
 31977                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 31978                                  ;   replaced with the other subtree in the pair.
 31979                                  ;
 31980                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 31981                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 31982                                  ;   The output of the previous translation is examined to see if any of the
 31983                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 31984                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 31985                                  ;   'mount' one device under another.
 31986                                  ;
 31987                                  ;   The final form of name translation involves the mapping of a user's
 31988                                  ;   logical drive number into the internal physical drive. This is
 31989                                  ;   accomplished by converting the drive number into letter:CON, performing
 31990                                  ;   the above translation and then converting the character back into a drive
 31991                                  ;   number.
 31992                                  ;
 31993                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 31994                                  ;   take a path and form the real text of the pathname with all . and ..
 31995                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 31996                                  ;   TransPath.
 31997                                  ;
 31998                                  ;	A000	version 4.00  Jan. 1988
 31999                                  
 32000                                  ;Installed = TRUE
 32001                                  
 32002                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 32003                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 32004                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 32005                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 32006                                  ;					; current drive)
 32007                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 32008                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 32009                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 32010                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 32011                                  ;	I_need	MYNAME,16		; machine name
 32012                                  ;	I_need	MYNUM,WORD		; machine number
 32013                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 32014                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 32015                                  ;	I_need	DrvErr,BYTE		; drive error
 32016                                  
 32017                                  ;BREAK <$AssignOper -- Set up a Macro>
 32018                                  ;----------------------------------------------------------------------------
 32019                                  ; Inputs:
 32020                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 32021                                  ;	AL = 01 set assign mode 		    (SetMode)
 32022                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 32023                                  ;	AL = 03 Define Macro (attch start)
 32024                                  ;	    BL = Macro type
 32025                                  ;	       = 0 alias
 32026                                  ;	       = 1 file/device
 32027                                  ;	       = 2 drive
 32028                                  ;	       = 3 Char device -> network
 32029                                  ;	       = 4 File device -> network
 32030                                  ;	    DS:SI -> ASCIZ source name
 32031                                  ;	    ES:DI -> ASCIZ destination name
 32032                                  ;	AL = 04 Cancel Macro
 32033                                  ;	    DS:SI -> ASCIZ source name
 32034                                  ;	AL = 05 Modified get attach list entry
 32035                                  ;	AL = 06 Get ifsfunc item
 32036                                  ;	AL = 07 set in_use of a drive's CDS
 32037                                  ;	     DL = drive number, 0=default  0=A,,
 32038                                  ;	AL = 08 reset in_use of a drive's CDS
 32039                                  ;	     DL = drive number, 0=A, 1=B,,,
 32040                                  ; Function:
 32041                                  ;	Do macro stuff
 32042                                  ; Returns:
 32043                                  ;	Std Xenix style error return
 32044                                  ;----------------------------------------------------------------------------
 32045                                  
 32046                                  _$AssignOper:
 32047                                  	; MSDOS 6.0
 32048                                  	;CMP	AL,7			      ; set in_use ?		;AN000;
 32049                                  	;JNZ	short chk08		      ; no			;AN000;
 32050                                  ;srinuse:								;AN000;
 32051                                  	;PUSH	AX			      ; save al 		;AN000;
 32052                                  	;MOV	AL,DL			      ; AL= drive id		;AN000;
 32053                                  	;CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 32054                                  	;POP	AX			      ; 			;AN000;
 32055                                  	;JC	short baddrv		      ; bad drive		;AN000;
 32056                                  	;CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 32057                                  	;JZ	short baddrv		      ;     no			;AN000;
 32058                                  	;CMP	AL,7			      ; set ?			;AN000;
 32059                                  	;JNZ	short resetdrv		      ; no			;AN000;
 32060                                  	;OR	word [SI+curdir.flags],curdir_inuse; set in_use		;AN000;
 32061                                  	;JMP	SHORT okdone		      ; 			;AN000;
 32062                                  ;resetdrv:								;AN000;
 32063                                  	;AND	word [SI+curdir_flags],~curdir_inuse ; reset in_use	;AN000;
 32064                                  	;JMP	SHORT okdone			; 			;AN000;
 32065                                  ;baddrv: 								;AN000;
 32066                                  	;MOV	AX,error_invalid_drive	      ; error			;AN000;
 32067                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 32068                                  ;chk08:									;AN000;
 32069                                  	;CMP	AL,8			      ; reset inuse ?		;AN000;
 32070                                  	;JZ	short srinuse 		      ; yes			;AN000;
 32071                                  
 32072                                  	;IF	NOT INSTALLED
 32073                                  	;transfer NET_ASSOPER
 32074                                  	;ELSE
 32075                                  
 32076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32077 00006896 50                      	PUSH	AX
 32078                                  	;mov	ax,111Eh
 32079                                  	;MOV	AX,(MultNET SHL 8) OR 30
 32080 00006897 B81E11                  	mov	ax,(MultNET*256)+30
 32081 0000689A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 32082                                  			; SS = DOS CS
 32083                                  			; STACK: WORD function to execute
 32084                                  			; Return: CF set on error, AX = error code
 32085                                  			; STACK unchanged
 32086 0000689C 5B                      	POP	BX			; Don't zap error code in AX
 32087 0000689D 7203                    	JC	short ASS_ERR
 32088                                  okdone:
 32089 0000689F E95BAE                  	jmp	SYS_RET_OK
 32090                                  
 32091                                  ASS_ERR:
 32092 000068A2 E961AE                  	jmp	SYS_RET_ERR
 32093                                  
 32094                                  	;ENDIF
 32095                                  
 32096                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 32097                                  ;----------------------------------------------------------------------------
 32098                                  ;**	FIND_DPB - Find a DPB from a Drive #
 32099                                  ;
 32100                                  ;	ENTRY	AL has drive number A = 0
 32101                                  ;	EXIT	'C' set
 32102                                  ;		    No DPB for this drive number
 32103                                  ;		'C' clear
 32104                                  ;		    DS:SI points to DPB for drive
 32105                                  ;	USES	SI, DS, Flags
 32106                                  ;----------------------------------------------------------------------------
 32107                                  
 32108                                  FIND_DPB:
 32109 000068A5 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 32110                                  fdpb5:	
 32111 000068AA 83FEFF                  	CMP	SI,-1
 32112 000068AD 7409                    	JZ	short fdpb10
 32113 000068AF 3A04                    	cmp	al,[si]
 32114                                  	;CMP	AL,[SI+DPB.DRIVE]
 32115 000068B1 7406                    	jz	short ret_label15	; Carry clear (retz)
 32116                                  	;lds	si,[si+18h]
 32117 000068B3 C57418                  	LDS	SI,[SI+DPB.NEXT_DPB]
 32118 000068B6 EBF2                    	JMP	short fdpb5
 32119                                  
 32120                                  fdpb10:	
 32121 000068B8 F9                      	STC
 32122                                  
 32123                                  ret_label15:
 32124 000068B9 C3                      	retn
 32125                                  
 32126                                  ;	Break <InitCDS - set up an empty CDS>
 32127                                  ;----------------------------------------------------------------------------
 32128                                  ;**	InitCDS - Setup an Empty CDS
 32129                                  ;
 32130                                  ;	ENTRY	ThisCDS points to CDS
 32131                                  ;		AL has uppercase drive letter
 32132                                  ;	EXIT	ThisCDS is now empty
 32133                                  ;		(ES:DI) = CDS
 32134                                  ;		'C' set if no DPB associated with drive
 32135                                  ;	USES	AH,ES,DI, Flags
 32136                                  ;----------------------------------------------------------------------------
 32137                                  
 32138                                  InitCDS:
 32139                                  	; 19/08/2018
 32140                                  	; 05/08/2018 - Retro DOS v3.0
 32141                                  	; MSDOS 6.0
 32142 000068BA 50                      	push	ax			; save (AL) for caller
 32143 000068BB 36C43E[3A05]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 32144                                  	;mov	word [es:di+67],0
 32145 000068C0 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 32146 000068C6 2C40                    	SUB	AL,"A"-1                ; A = 1
 32147 000068C8 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 32148 000068CD 7236                    	JC	short icdsx		; Drive does not map a physical drive
 32149 000068CF 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 32150 000068D0 50                      	PUSH	AX			; save drive number for later
 32151 000068D1 0441                    	add	al,"A"
 32152 000068D3 B43A                    	MOV	AH,':'
 32153 000068D5 268905                  	mov	[ES:DI],ax
 32154                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 32155                                  	;mov	ax,"\"
 32156                                  	;mov	[es:di+2],ax
 32157                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 32158 000068D8 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 32159                                  	;or	word [es:di+67],4000h
 32160                                  	;or	byte [es:di+68],40h
 32161 000068DE 26804D4440              	OR	byte [ES:DI+curdir.flags+1],curdir_inuse>>8
 32162 000068E3 29C0                    	sub	ax,ax
 32163                                  	;MOV	[es:di+73],ax ; 0
 32164 000068E5 26894549                	MOV	[ES:DI+curdir.ID],ax
 32165                                  	;mov	[es:di+75],ax ; 0
 32166 000068E9 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 32167 000068ED B002                    	mov	al,2
 32168                                  	;mov	[es:di+79],aX ; 2
 32169 000068EF 2689454F                	MOV	[ES:DI+curdir.end],ax
 32170 000068F3 58                      	POP	AX			; (al) = drive number
 32171 000068F4 1E                      	push	ds
 32172 000068F5 56                      	push	si
 32173 000068F6 E8ACFF                  	call	FIND_DPB
 32174 000068F9 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 32175                                  	;mov	[es:di+69],si
 32176 000068FB 26897545                	MOV	[ES:DI+curdir.devptr],SI
 32177                                  	;mov	[es:di+71],ds
 32178 000068FF 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 32179                                  icds5:	
 32180 00006903 5E                      	pop	si
 32181 00006904 1F                      	pop	ds
 32182                                  icdsx:	
 32183 00006905 58                      	pop	ax
 32184                                  RET45:
 32185 00006906 C3                      	retn
 32186                                  
 32187                                  ;Break <$UserOper - get/set current user ID (for net)>
 32188                                  ;----------------------------------------------------------------------------
 32189                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 32190                                  ;	maintain this string and do no verifications.
 32191                                  ;
 32192                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 32193                                  ;				      4-printer-set-flags,5-printer-get-flags)
 32194                                  ;		DS:DX is user string pointer (calls 1,2)
 32195                                  ;		ES:DI is user buffer (call 3)
 32196                                  ;		BX is assign index (calls 2,3,4,5)
 32197                                  ;		CX is user number (call 1)
 32198                                  ;		DX is flag word (call 4)
 32199                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 32200                                  ;			and user CX is set to the user number
 32201                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 32202                                  ;		If AL = 5 then DX is flag word
 32203                                  ;----------------------------------------------------------------------------
 32204                                  
 32205                                  _$UserOper:
 32206                                  	; 05/08/2018 - Retro DOS v3.0
 32207                                  	; MSDOS 6.0 (& MSDOS 3.3)
 32208 00006907 50                      	PUSH	AX
 32209 00006908 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 32210 0000690A 58                      	POP	AX
 32211 0000690B 7211                    	JB	short UserGet 		; return to user the string
 32212 0000690D 742E                    	JZ	short UserSet 		; set the current user
 32213 0000690F 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 32214 00006911 763D                    	JBE	short UserPrint		; yep
 32215                                  	;mov	byte [ss:EXTERR_LOCUS],1
 32216 00006913 36C606[D102]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 32217                                  					; Extended Error Locus
 32218                                  	;error	error_invalid_function	; not 0,1,2,3
 32219                                  	;mov	al,1
 32220 00006919 B001                    	MOV	AL,error_invalid_function
 32221                                  useroper_error:
 32222 0000691B E9E8AD                  	JMP	SYS_RET_ERR
 32223                                  
 32224                                  UserGet:
 32225                                  ; Transfer MYNAME to DS:DX
 32226                                  ; Set Return CX to MYNUM
 32227 0000691E 1E                      	PUSH	DS			; switch registers
 32228 0000691F 07                      	POP	ES
 32229 00006920 89D7                    	MOV	DI,DX			; destination
 32230 00006922 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 32231 00006927 E8E1AC                  	call	Get_User_Stack
 32232 0000692A 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 32233 0000692D 16                      	push	ss			; point to DOSDATA
 32234 0000692E 1F                      	pop	ds
 32235 0000692F BE[B302]                	MOV	SI,MYNAME		; point source to user string
 32236                                  UserMove:
 32237 00006932 B90F00                  	MOV	CX,15
 32238 00006935 F3A4                    	REP	MOVSB			; blam.
 32239 00006937 31C0                    	XOR	AX,AX			; 16th byte is 0
 32240 00006939 AA                      	STOSB
 32241                                  UserBye:
 32242 0000693A E9C0AD                  	jmp	SYS_RET_OK		; no errors here
 32243                                  
 32244                                  UserSet:
 32245                                  ; Transfer DS:DX to MYNAME
 32246                                  ; CX to MYNUM
 32247 0000693D 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 32248 00006942 89D6                    	MOV	SI,DX			; user space has source
 32249 00006944 16                      	push	ss
 32250 00006945 07                      	pop	es
 32251 00006946 BF[B302]                	MOV	DI,MYNAME		; point dest to user string
 32252 00006949 36FE06[B202]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 32253 0000694E EBE2                    	JMP	short UserMove
 32254                                  
 32255                                  UserPrint:
 32256                                  
 32257                                  ;IF NOT Installed
 32258                                  ;	transfer PRINTER_GETSET_STRING
 32259                                  ;ELSE
 32260 00006950 50                      	PUSH	AX
 32261                                  	;mov	ax,111Fh
 32262                                  	;MOV	AX,(MultNET SHL 8) OR 31
 32263 00006951 B81F11                  	mov	ax,(MultNET<<8)|31
 32264 00006954 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 32265                                  			; STACK: WORD function
 32266                                  			; Return: CF set on error, AX = error code
 32267                                  			; STACK unchanged
 32268 00006956 5A                      	POP	DX			; Clean stack
 32269 00006957 7302                    	JNC	short OKPA
 32270 00006959 EBC0                    	jmp	short useroper_error
 32271                                  OKPA:
 32272 0000695B EBDD                    	jmp	short UserBye
 32273                                  ;ENDIF
 32274                                  
 32275                                  
 32276                                  ;Break	<GetVisDrv - return visible drive>
 32277                                  ;----------------------------------------------------------------------------
 32278                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 32279                                  ;
 32280                                  ;   Inputs:	AL has drive identifier (0=default)
 32281                                  ;   Outputs:	Carry Set - invalid drive/macro
 32282                                  ;		Carry Clear - AL has physical drive (0=A)
 32283                                  ;		    ThisCDS points to CDS
 32284                                  ;   Registers modified: AL
 32285                                  ;----------------------------------------------------------------------------
 32286                                  
 32287                                  GetVisDrv:
 32288                                  	; 05/08/2018 - Retro DOS v3.0
 32289                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 32290 0000695D E81400                  	CALL	GETTHISDRV		; get inuse drive
 32291 00006960 72A4                    	jc	short RET45
 32292 00006962 1E                      	push	ds
 32293 00006963 56                      	push	si
 32294 00006964 36C536[3A05]            	LDS	SI,[SS:THISCDS]			;smr;SS Override
 32295                                  	;test	word [si+67],2000h
 32296 00006969 F744430020              	TEST	word [SI+curdir.flags],curdir_splice
 32297 0000696E 5E                      	pop	si
 32298 0000696F 1F                      	pop	ds
 32299 00006970 7494                    	jz	short RET45		; if not spliced, return OK
 32300                                  	; MSDOS 6.0
 32301                                  	;MOV	[SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 32302                                  	;
 32303 00006972 F9                      	STC				; signal error
 32304 00006973 C3                      	retn
 32305                                  
 32306                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 32307                                  ;----------------------------------------------------------------------------
 32308                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 32309                                  ;	macro pointer
 32310                                  ;
 32311                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 32312                                  ;   Outputs:
 32313                                  ;		Carry Set - invalid drive/macro
 32314                                  ;		Carry Clear - AL has physical drive (0=A)
 32315                                  ;		   ThisCDS points to macro
 32316                                  ;   Registers modified: AL
 32317                                  ;----------------------------------------------------------------------------
 32318                                  
 32319                                  GETTHISDRV:
 32320                                  	; 05/08/2018
 32321                                  	; 12/07/2018 - Retro DOS v3.0
 32322                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 32323                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32324 00006974 08C0                    	OR	AL,AL			; are we using default drive?
 32325 00006976 7506                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 32326 00006978 36A0[E402]              	MOV	AL,[SS:CURDRV]		; get the current drive
 32327                                  	;INC	ax			; Counteract next instruction
 32328                                  	; 04/09/2018
 32329 0000697C FEC0                    	inc	al
 32330                                  GTD10:	
 32331                                  	;DEC	ax			; 0 = A
 32332 0000697E FEC8                    	dec	al
 32333 00006980 1E                      	PUSH	DS			; save world
 32334 00006981 56                      	PUSH	SI
 32335                                  	;mov	byte [ss:EXTERR_LOCUS],2
 32336 00006982 36C606[D102]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 32337 00006988 36F606[0D05]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 32338 0000698E 7421                    	JZ	SHORT GTD20		; Logical
 32339 00006990 50                      	PUSH	AX
 32340 00006991 06                      	PUSH	ES
 32341 00006992 57                      	PUSH	DI
 32342 00006993 36C706[3A05][9504]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 32343 0000699A 368C0E[3C05]            	mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 32344                                  	;MOV	[SS:THISCDS+2],SS	;ThisCDS = &DummyCDS;smr;
 32345 0000699F 0441                    	ADD	AL,'A'
 32346 000069A1 E816FF                  	CALL	InitCDS			;	InitCDS(c);
 32347                                  	;test	word [es:di+67],4000h
 32348 000069A4 26F745430040            	TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 32349 000069AA 5F                      	POP	DI
 32350 000069AB 07                      	POP	ES
 32351 000069AC 58                      	POP	AX
 32352 000069AD 740E                    	JZ	SHORT GTD30		; Not a physical drive.
 32353 000069AF EB13                    	JMP	SHORT GTDX		; carry clear
 32354                                  GTD20:
 32355 000069B1 E81300                  	CALL	GetCDSFromDrv
 32356 000069B4 7207                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 32357                                  	;test	word [si+43h],4000h
 32358 000069B6 F744430040              	TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 32359 000069BB 7507                    	JNZ	SHORT GTDX		; carry clear
 32360                                  GTD30:	
 32361                                  	; 14/08/2018
 32362                                  	;MOV	AL,error_invalid_drive	; invalid FAT drive
 32363                                  	;MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 32364 000069BD 36C606[D102]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 32365 000069C3 F9                      	STC
 32366                                  GTDX:	
 32367 000069C4 5E                      	POP	SI			; restore world
 32368 000069C5 1F                      	POP	DS
 32369 000069C6 C3                      	RETN
 32370                                   
 32371                                  
 32372                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 32373                                  ;----------------------------------------------------------------------------
 32374                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 32375                                  ;	pointer, returning an error if the drive number is greater than the
 32376                                  ;	number of CDS's
 32377                                  ;
 32378                                  ;   Inputs:	AL is physical unit # A=0...
 32379                                  ;   Outputs:	Carry Set if Bad Drive
 32380                                  ;		Carry Clear
 32381                                  ;		    DS:SI -> CDS
 32382                                  ;		    [THISCDS] = DS:SI
 32383                                  ;   Registers modified: DS,SI
 32384                                  ;----------------------------------------------------------------------------
 32385                                  
 32386                                  GetCDSFromDrv:
 32387 000069C7 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 32388 000069CC 7202                    	JB	SHORT GetCDS		; yes, go get the macro
 32389 000069CE F9                      	STC				; signal error
 32390 000069CF C3                      	RETN				; bye
 32391                                  GetCDS:
 32392 000069D0 53                      	PUSH	BX
 32393 000069D1 50                      	PUSH	AX
 32394 000069D2 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 32395                                  	;mov	bl,81
 32396 000069D7 B351                    	MOV	BL,curdir.size		; size in convenient spot
 32397 000069D9 F6E3                    	MUL	BL			; get net offset
 32398 000069DB 01C6                    	ADD	SI,AX			; convert to true pointer
 32399 000069DD 368936[3A05]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 32400 000069E2 368C1E[3C05]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 32401 000069E7 58                      	POP	AX
 32402 000069E8 5B                      	POP	BX
 32403 000069E9 F8                      	CLC				; no error
 32404 000069EA C3                      	RETN				; bye!
 32405                                  
 32406                                  ;============================================================================
 32407                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 32408                                  ;============================================================================
 32409                                  ; Retro	DOS v3.0 - 12/07/2018
 32410                                  
 32411                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 32412                                  ;----------------------------------------------------------------------------
 32413                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 32414                                  ;       gritty substitution.
 32415                                  ;
 32416                                  ;   Inputs:     DS:DX - pointer to FCB
 32417                                  ;               ES:DI - point to destination
 32418                                  ;   Outputs:    Carry Set - invalid path in final map
 32419                                  ;               Carry Clear - FCB has been mapped into ES:DI
 32420                                  ;                   Sattrib is set from possibly extended FCB
 32421                                  ;                   ExtFCB set if extended FCB found
 32422                                  ;   Registers modified: most
 32423                                  ;----------------------------------------------------------------------------
 32424                                  
 32425                                  TransFCB:
 32426                                  	; 12/07/2018 - Retro DOS v3.0
 32427                                  	;LocalVar FCBTmp,16
 32428                                  	;ENTER
 32429 000069EB 55                      	push	bp
 32430 000069EC 89E5                    	mov	bp,sp
 32431                                  	;sub	sp,15	; MSDOS 3.3
 32432 000069EE 83EC10                  	sub	sp,16	; MSDOS 6.0
 32433 000069F1 16                      	push	ss
 32434 000069F2 07                      	pop	es
 32435 000069F3 06                      	push	es
 32436 000069F4 57                      	push	di
 32437                                  	;lea	di,[bp-15] ; MSDOS 3.3
 32438                                  	;LEA	DI,FCBTmp 
 32439 000069F5 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 32440 000069F8 36C606[0705]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 32441 000069FE 36C606[0805]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 32442 00006A04 E8B9BF                  	call	GetExtended             ; get FCB, extended or not
 32443 00006A07 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 32444 00006A09 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 32445 00006A0C 36A2[0805]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 32446 00006A10 36C606[0705]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 32447                                  GetDrive:
 32448 00006A16 AC                      	lodsb				; get drive byte
 32449 00006A17 E85AFF                  	call	GETTHISDRV
 32450 00006A1A 722C                    	jc	short BadPack
 32451 00006A1C E87C03                  	call	TextFromDrive           ; convert 0-based drive to text
 32452                                  ;
 32453                                  ; Scan the source to see if there are any illegal chars
 32454                                  ;
 32455 00006A1F BB[1613]                	mov	bx,CharType		; load lookup table
 32456 00006A22 B90B00                  	mov	cx,11
 32457 00006A25 56                      	push	si			; back over name, ext
 32458                                  FCBScan:
 32459 00006A26 AC                      	lodsb				; get a byte
 32460                                  	; 09/08/2018
 32461                                  	;xlat	byte [es:bx]
 32462 00006A27 26D7                    	es	xlat			; get flags
 32463                                  	;test	al,8	
 32464 00006A29 A808                    	test	al,FFCB
 32465 00006A2B 741B                    	jz	short BadPack
 32466                                  NextCh: 
 32467 00006A2D E2F7                    	loop	FCBScan
 32468 00006A2F 5E                      	pop	si
 32469 00006A30 89FB                    	mov	bx,di
 32470 00006A32 E8DDC3                  	call	PackName                ; crunch the path
 32471 00006A35 5F                      	pop	di			; get original destination
 32472 00006A36 07                      	pop	es
 32473 00006A37 16                      	push	ss			; get DS addressability
 32474 00006A38 1F                      	pop	ds
 32475                                  	;lea	si,[bp-15] ; MSDOS 3.3
 32476                                  	;LEA	SI,FCBTmp		; point at new pathname
 32477 00006A39 8D76F0                  	lea	si,[bp-16]
 32478 00006A3C 803F00                  	cmp	byte [bx],0
 32479 00006A3F 7407                    	jz	short BadPack
 32480 00006A41 55                      	push	bp
 32481 00006A42 E80E00                  	call	TransPathSet            ; convert the path
 32482 00006A45 5D                      	pop	bp
 32483 00006A46 7303                    	jnc	short FCBRet		; bye with transPath error code
 32484                                  BadPack:
 32485 00006A48 F9                      	STC
 32486                                  	;mov	al,3
 32487 00006A49 B003                    	MOV     AL,error_path_not_found
 32488                                  FCBRet: 
 32489                                  	;LEAVE
 32490 00006A4B 89EC                    	mov	sp,bp
 32491 00006A4D 5D                      	pop	bp
 32492                                  TransPath_retn:
 32493 00006A4E C3                      	retn
 32494                                  
 32495                                  ; 12/07/2018 - Retro DOS v3.0
 32496                                  
 32497                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 32498                                  ;----------------------------------------------------------------------------
 32499                                  ;
 32500                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 32501                                  ;       substitution, insertion of current directory and fixing . and ..
 32502                                  ;       entries. Perform splicing. Allow input string to match splice
 32503                                  ;       exactly.
 32504                                  ;
 32505                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 32506                                  ;       matches splice.
 32507                                  ;
 32508                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 32509                                  ;
 32510                                  ;   The following anomalous behaviour is required:
 32511                                  ;
 32512                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 32513                                  ;       Paths on devices are ignored. (truncate to 0-length)
 32514                                  ;       Raw net I/O sets ThisCDS => NULL.
 32515                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 32516                                  ;
 32517                                  ;   Other behaviour:
 32518                                  ;
 32519                                  ;       ThisCDS set up.
 32520                                  ;       FatRead done on local CDS.
 32521                                  ;       ValidateCDS done on local CDS.
 32522                                  ;
 32523                                  ;   Brief flowchart:
 32524                                  ;
 32525                                  ;       if fSharing then
 32526                                  ;           set up DummyCDS (ThisCDS)
 32527                                  ;           canonicalize (sets cMeta)
 32528                                  ;           splice
 32529                                  ;           fatRead
 32530                                  ;           return
 32531                                  ;       if \\ or d:\\ lead then
 32532                                  ;           set up null CDS (ThisCDS)
 32533                                  ;           canonicalize (sets cMeta)
 32534                                  ;           return
 32535                                  ;       if device then
 32536                                  ;           set up dummyCDS (ThisCDS)
 32537                                  ;           canonicalize (sets cMeta)
 32538                                  ;           return
 32539                                  ;       if file then
 32540                                  ;           getCDS (sets (ThisCDS) from name)
 32541                                  ;           validateCDS (may reset current dir)
 32542                                  ;           Copy current dir
 32543                                  ;           canonicalize (set cMeta)
 32544                                  ;           splice
 32545                                  ;           generate correct CDS (ThisCDS)
 32546                                  ;           if local then
 32547                                  ;               fatread
 32548                                  ;           return
 32549                                  ;
 32550                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 32551                                  ;               DI - point to buffer in DOSDATA
 32552                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 32553                                  ;                   syntax, etc. or user FAILed to I 24.
 32554                                  ;               WFP_Start - points to beginning of buffer
 32555                                  ;               Curr_Dir_End - points to end of current dir in path
 32556                                  ;               DS - DOSDATA
 32557                                  ;   Registers modified: most
 32558                                  ;
 32559                                  ;----------------------------------------------------------------------------
 32560                                  
 32561                                  TransPath:
 32562 00006A4F 30C0                    	XOR     AL,AL
 32563 00006A51 EB02                    	JMP     SHORT SetSplice
 32564                                  TransPathSet:
 32565 00006A53 B0FF                    	MOV     AL,-1
 32566                                  SetSplice:
 32567 00006A55 36A2[F802]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 32568 00006A59 B0FF                    	MOV     AL,-1
 32569                                  TransPathNoSet:
 32570 00006A5B 36A2[0C05]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 32571 00006A5F 36C606[1505]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 32572 00006A65 36893E[4A05]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 32573 00006A6A 36C706[4E05]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 32574 00006A71 16                      	push	ss
 32575 00006A72 07                      	pop	es
 32576                                  	;lea	bp,[di+134]
 32577 00006A73 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 32578                                  ;
 32579                                  ; if this is through the server dos call, fsharing is set. We set up a
 32580                                  ; dummy cds and let the operation go.
 32581                                  ;
 32582 00006A77 36F606[0D05]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 32583 00006A7D 7435                    	JZ	short CheckUNC		; skip to UNC check
 32584                                  ;
 32585                                  ; ES:DI point to buffer
 32586                                  ;
 32587 00006A7F E80203                  	CALL	DriveFromText           ; get drive and advance DS:SI
 32588 00006A82 E8EFFE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 32589 00006A85 722A                    	jc	short NoPath
 32590 00006A87 E81103                  	CALL	TextFromDrive		; drop in new
 32591 00006A8A 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 32592 00006A8D E83801                  	CALL	Canonicalize            ; copy and canonicalize
 32593 00006A90 72BC                    	jc	short TransPath_retn	; errors
 32594                                  ;
 32595                                  ; Perform splices for net guys.
 32596                                  ;
 32597 00006A92 16                      	push	ss
 32598 00006A93 1F                      	pop	ds
 32599 00006A94 8B36[4A05]              	MOV     SI,[WFP_START] 		; point to name
 32600 00006A98 F606[0C05]FF            	TEST	byte [FSPLICE],-1
 32601 00006A9D 7403                    	JZ	short NoServerSplice
 32602 00006A9F E83602                  	CALL    Splice
 32603                                  NoServerSplice:
 32604 00006AA2 16                      	push	ss
 32605 00006AA3 1F                      	pop	ds                      ; for FATREAD
 32606 00006AA4 C43E[3A05]              	LES     DI,[THISCDS]		; for fatread
 32607 00006AA8 E8B8B5                  	call	EcritDisk
 32608 00006AAB E810F1                  	call	FATREAD_CDS
 32609 00006AAE E8BAB5                  	call	LcritDisk
 32610                                  NoPath:
 32611                                  	;mov	al,3
 32612 00006AB1 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 32613 00006AB3 C3                      	retn				; any errors are in Carry flag
 32614                                  
 32615                                  ;
 32616                                  ; Let the network decide if the name is for a spooled device. It will map
 32617                                  ; the name if so.
 32618                                  ;
 32619                                  CheckUNC:
 32620 00006AB4 36C706[3A05]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 32621                                  	;CallInstall NetSpoolCheck,MultNET,35
 32622 00006ABB B82311                  	mov	ax,1123h
 32623 00006ABE CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 32624                                  			; DS:SI -> ASCIZ filename to canonicalize
 32625                                  			; ES:DI -> 128-byte buffer for qualified name
 32626                                  			; Return: CF set if not resolved
 32627 00006AC0 7329                    	JNC	short UNCDone
 32628                                  ;
 32629                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 32630                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 32631                                  ; input, then the name has been changed to the remote spooler by the above net
 32632                                  ; call. Also, there may be a drive in front of the \\.
 32633                                  ;
 32634                                  NO_CHECK:
 32635 00006AC2 E8BF02                  	CALL    DriveFromText		; eat drive letter
 32636 00006AC5 50                      	PUSH    AX                      ; save it
 32637 00006AC6 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 32638 00006AC8 E880EB                  	call    PATHCHRCMP              ; convert to normal form
 32639 00006ACB 86E0                    	XCHG    AH,AL                   ; swap for second byte
 32640 00006ACD E87BEB                  	call    PATHCHRCMP              ; convert to normal form
 32641 00006AD0 751F                    	JNZ	short CheckDevice	; not a path char
 32642 00006AD2 38C4                    	CMP     AH,AL                   ; are they same?
 32643 00006AD4 751B                    	JNZ	short CheckDevice	; nope
 32644                                  ;
 32645                                  ; We have a UNC request. We must copy the string up to the beginning of the
 32646                                  ; local machine root path
 32647                                  ;
 32648                                  
 32649 00006AD6 58                      	POP     AX
 32650 00006AD7 A5                      	MOVSW                           ; get the lead \\.
 32651                                  UNCCpy:
 32652 00006AD8 AC                      	LODSB                           ; get a byte
 32653 00006AD9 E833EB                   	call	UCase                   ;AN000;; convert the char
 32654 00006ADC 08C0                    	OR      AL,AL
 32655 00006ADE 740E                    	JZ	short UNCTerm		; end of string. All done.
 32656 00006AE0 E868EB                  	call    PATHCHRCMP              ; is it a path char?
 32657 00006AE3 89FB                    	MOV     BX,DI                   ; backup position
 32658 00006AE5 AA                      	STOSB
 32659 00006AE6 75F0                    	JNZ	short UNCCpy		; no, go copy
 32660 00006AE8 E8DD00                  	CALL    Canonicalize            ; wham (and set cMeta)
 32661                                  UNCDone:
 32662 00006AEB 16                      	push	ss
 32663 00006AEC 1F                      	pop	ds
 32664 00006AED C3                       	retn				; return error code
 32665                                  UNCTerm:
 32666 00006AEE AA                      	STOSB                           ;AN000;
 32667 00006AEF EBFA                    	JMP	short UNCDone		;AN000;
 32668                                  
 32669                                  CheckDevice:
 32670                                  ;
 32671                                  ; Check DS:SI for device. First eat any path stuff
 32672                                  ;
 32673 00006AF1 58                      	POP     AX                      ; retrieve drive info
 32674 00006AF2 803C00                  	CMP     BYTE [SI],0		; check for null file
 32675 00006AF5 7504                    	JNZ	short CheckPath
 32676                                  	;mov	al,2 
 32677 00006AF7 B002                    	MOV     AL,error_file_not_found ; bad file error
 32678 00006AF9 F9                      	STC                             ; signal error on null input
 32679 00006AFA C3                      	RETN				; bye!
 32680                                  CheckPath:
 32681 00006AFB 50                      	push	ax
 32682 00006AFC 55                      	push	bp			; save drive number
 32683                                  
 32684                                  	; MSDOS 6.0
 32685                                  ;;;BUGBUG BUG 10-26-1992 scottq
 32686                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 32687                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 32688                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 32689                                  ;;;end up having a 5D in the opcode's displacement field. The
 32690                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 32691                                  ;;;
 32692                                  ;;;What we do here is do a call to a function that is less than 5Dh
 32693                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 32694                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 32695                                  ;;;
 32696                                  ;;;More info:
 32697                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 32698                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 32699                                  ;;;
 32700 00006AFD E82000                  	call	no5Dshere
 32701                                  start5Dhack:
 32702                                  ;following is replaced with 5Dhack code--Invoke  CheckThisDevice         
 32703                                  backfrom5Dhack:
 32704 00006B00 5D                      	pop	bp
 32705 00006B01 58                      	pop	ax			; get drive letter back
 32706 00006B02 731F                    	JNC	short DoFile		; yes we have a file.
 32707                                  ;
 32708                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 32709                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 32710                                  ; call.
 32711                                  ;
 32712 00006B04 36C606[0D05]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 32713 00006B0A E867FE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 32714 00006B0D 36C606[0D05]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 32715                                  ;
 32716                                  ; Now that we have noted that we have a device, we put it into a form that
 32717                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 32718                                  ; string. We relax this to state that if the d:\ is present then the path
 32719                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 32720                                  ; a device.
 32721                                  ;
 32722 00006B13 E88502                  	CALL    TextFromDrive
 32723 00006B16 B02F                    	MOV     AL,'/'                  ; path sep.
 32724 00006B18 AA                      	STOSB
 32725 00006B19 E82DB4                  	call	StrCpy			; move remainder of string
 32726                                  
 32727 00006B1C F8                      	CLC                             ; everything OK.
 32728 00006B1D 16                      	push	ss
 32729 00006B1E 1F                      	pop	ds                      ; remainder of OK stuff
 32730                                  DoFile_retn:
 32731 00006B1F C3                      	retn
 32732                                  
 32733                                  no5Dshere:
 32734                                  	; 10/08/2018
 32735 00006B20 E9FEE0                  	jmp	CheckThisDevice		; snoop for device
 32736                                  
 32737                                  ;.erre (no5Dshere - start5Dhack - 5D)
 32738                                  
 32739                                  ;
 32740                                  ; We have a file. Get the raw CDS.
 32741                                  ;
 32742                                  
 32743                                  DoFile:
 32744                                  	; MSDOS 3.3 (& MSDOS 6.0)
 32745                                  
 32746 00006B23 E837FE                  	call	GetVisDrv               ; get proper CDS
 32747                                  	;mov	al,3 
 32748 00006B26 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 32749 00006B28 72F5                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 32750                                  ;
 32751                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 32752                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 32753                                  ; Use the one that we are going to use (ES:DI).
 32754                                  ;
 32755                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 32756 00006B2A 1E                      	push	ds
 32757 00006B2B 56                      	push	si
 32758 00006B2C 06                      	push	es
 32759 00006B2D 57                      	push	di
 32760 00006B2E E83CE0                  	call	ValidateCDS             ; poke CDS and make everything OK
 32761                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 32762 00006B31 5F                      	pop	di
 32763 00006B32 07                      	pop	es
 32764 00006B33 5E                      	pop	si
 32765 00006B34 1F                      	pop	ds
 32766                                  	;mov	al,3
 32767 00006B35 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 32768                                  	;retc				; someone failed an operation
 32769 00006B37 72E6                    	jc	short DoFile_retn
 32770                                  ;
 32771                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 32772                                  ; current directory. Copy it in.
 32773                                  ;
 32774 00006B39 1E                      	push	ds
 32775 00006B3A 56                      	push	si
 32776 00006B3B 36C536[3A05]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 32777 00006B40 89FB                    	MOV     BX,DI                   ; point to destination
 32778 00006B42 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 32779                                  ;       LEA     SI,[SI+curdir.text]	; point to text
 32780                                  	;lea	bp,[di+134]
 32781 00006B45 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 32782                                  					;AN000;
 32783 00006B49 E80CB4                  	call	FStrCpy                 ; copy string. ES:DI point to end
 32784 00006B4C 4F                      	DEC     DI                      ; point to NUL byte
 32785                                  
 32786                                  ;
 32787                                  ; Make sure that there is a path char at end.
 32788                                  ;
 32789 00006B4D B05C                    	MOV     AL,'\'
 32790 00006B4F 263845FF                	CMP     [ES:DI-1],AL
 32791 00006B53 7401                    	JZ	short GetOrig
 32792 00006B55 AA                      	STOSB
 32793                                  ;
 32794                                  ; Now get original string.
 32795                                  ;
 32796                                  GetOrig:
 32797 00006B56 4F                      	DEC     DI                      ; point to path char
 32798 00006B57 5E                      	pop	si
 32799 00006B58 1F                      	pop	ds
 32800                                  ;
 32801                                  ; BX points to the end of the root part of the CDS (at where a path char
 32802                                  ; should be). Now, we decide whether we use this root or extend it with the
 32803                                  ; current directory.  See if the input string begins with a leading ;
 32805 00006B59 E8D100                  	CALL    PathSep                 ; is DS:SI a path sep?
 32806 00006B5C 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 32807 00006B5E 08C0                    	OR      AL,AL                   ; end of string?
 32808 00006B60 7410                    	JZ	short DoCanon		; yes, skip.
 32809                                  ;
 32810                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 32811                                  ; to this root. Make sure that there is a path char there and advance the
 32812                                  ; source string over all leading \'s.
 32813                                  ;
 32814 00006B62 89DF                    	MOV     DI,BX                   ; back up to root point.
 32815                                  SkipPath:
 32816 00006B64 AC                      	LODSB
 32817 00006B65 E8E3EA                  	call    PATHCHRCMP
 32818 00006B68 74FA                    	JZ	short SkipPath
 32819 00006B6A 4E                      	DEC     SI
 32820 00006B6B 08C0                    	OR      AL,AL
 32821 00006B6D 7403                    	JZ	short DoCanon
 32822                                  ;
 32823                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 32824                                  ; for yucks.
 32825                                  ;
 32826                                  PathAssure:
 32827 00006B6F B05C                    	MOV     AL,'\'
 32828 00006B71 AA                      	STOSB
 32829                                  ;
 32830                                  ; ES:DI point to the correct spot for canonicalization to begin.
 32831                                  ; BP is the max extent to advance DI
 32832                                  ; BX is the backup limit for ..
 32833                                  ;
 32834                                  DoCanon:
 32835 00006B72 E85300                  	CALL    Canonicalize            ; wham.
 32836                                  	;retc				; badly formatted path.
 32837 00006B75 72A8                    	jc	short DoFile_retn
 32838                                  
 32839                                  ;
 32840                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 32841                                  ; to wfp_start and do string substitution. BP is still the max position in
 32842                                  ; buffer.
 32843                                  ;
 32844 00006B77 16                      	push	ss
 32845 00006B78 1F                      	pop	ds
 32846 00006B79 8B3E[4A05]              	MOV     DI,[WFP_START]		; DS:SI point to string
 32847 00006B7D C536[3A05]              	LDS     SI,[THISCDS]		; point to CDS
 32848                                  ;       LEA     SI,[SI+curdir.text]	; point to text
 32849 00006B81 E81F02                  	CALL    PathPref                ; is there a prefix?
 32850 00006B84 7514                    	JNZ	short DoSplice		; no, do splice
 32851                                  ;
 32852                                  ; We have a match. Check to see if we ended in a path char.
 32853                                  ;
 32854 00006B86 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 32855 00006B89 E8BFEA                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 32856 00006B8C 740C                    	JZ	short DoSplice		; yes, no current dir here.
 32857                                  Pathline:                               ; 2/13/KK
 32858 00006B8E 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 32859 00006B92 7406                    	JZ	short DoSplice
 32860 00006B94 47                      	INC     DI                      ; point to after current path char
 32861 00006B95 36893E[4E05]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 32862                                  ;
 32863                                  ; Splice the result.
 32864                                  ;
 32865                                  DoSplice:
 32866 00006B9A 16                      	push	ss
 32867 00006B9B 1F                      	pop	ds			; back to DOSDATA
 32868 00006B9C 8B36[4A05]              	MOV     SI,[WFP_START]		; point to beginning of string
 32869 00006BA0 31C9                    	XOR     CX,CX
 32870 00006BA2 F606[0C05]FF            	TEST	byte [FSPLICE],-1
 32871 00006BA7 7403                    	JZ	short SkipSplice
 32872 00006BA9 E82C01                  	CALL    Splice                  ; replaces in place.
 32873                                  SkipSplice:
 32874                                  ;
 32875                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 32876                                  ; device.
 32877                                  ;
 32878 00006BAC 16                      	push	ss
 32879 00006BAD 1F                      	pop	ds
 32880 00006BAE C43E[3A05]              	LES     DI,[THISCDS]		; point to correct drive
 32881                                  	;test	word [es:di+67],8000h
 32882 00006BB2 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 32883 00006BB8 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 32884 00006BBA E30B                    	JCXZ    Done
 32885 00006BBC E8A4B4                  	call	EcritDisk
 32886 00006BBF E8FCEF                  	call	FATREAD_CDS
 32887 00006BC2 E8A6B4                  	call	LcritDisk
 32888                                  	;mov	al, 3
 32889 00006BC5 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 32890                                  Done:   
 32891 00006BC7 C3                      	retn                         ; any errors in carry flag.
 32892                                  
 32893                                  ; 13/07/2018
 32894                                  
 32895                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 32896                                  ;----------------------------------------------------------------------------
 32897                                  ;   Canonicalize - copy path removing . and .. entries.
 32898                                  ;
 32899                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 32900                                  ;               ES:DI - point to buffer
 32901                                  ;               BX - backup limit (offset from ES) points to slash
 32902                                  ;               BP - end of buffer
 32903                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 32904                                  ;                   syntax, etc.
 32905                                  ;               Carry Clear -
 32906                                  ;                   DS:DI - advanced to end of string
 32907                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 32908                                  ;   Registers modified: AX CX DX (in addition to those above)
 32909                                  ;----------------------------------------------------------------------------
 32910                                  
 32911                                  Canonicalize:
 32912                                  ;
 32913                                  ; We copy all leading path separators.
 32914                                  ;
 32915 00006BC8 AC                      	LODSB                           ;   while (PathChr (*s))
 32916 00006BC9 E87FEA                  	call    PATHCHRCMP
 32917 00006BCC 7507                    	JNZ	short CanonDec
 32918 00006BCE 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 32919 00006BD0 7319                    	JAE	short CanonBad		;           goto error;
 32920 00006BD2 AA                      	STOSB
 32921 00006BD3 EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 32922                                  CanonDec:
 32923 00006BD5 4E                      	DEC     SI
 32924                                  ;
 32925                                  ; Main canonicalization loop.  We come here with DS:SI pointing to a textual
 32926                                  ; component (no leading path separators) and ES:DI being the destination
 32927                                  ; buffer.
 32928                                  ;
 32929                                  CanonLoop:
 32930                                  ;
 32931                                  ; If we are at the end of the source string, then we need to check to see that
 32932                                  ; a potential drive specifier is correctly terminated with a path sep char.
 32933                                  ; Otherwise, do nothing
 32934                                  ;
 32935 00006BD6 31C0                    	XOR     AX,AX
 32936 00006BD8 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 32937 00006BDA 751A                    	JNZ	short DoComponent
 32938 00006BDC 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 32939 00006BE1 7505                    	JNZ	short DoTerminate
 32940 00006BE3 B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 32941 00006BE5 AA                      	STOSB
 32942 00006BE6 88E0                    	MOV     AL,AH
 32943                                  DoTerminate:
 32944 00006BE8 AA                      	STOSB                           ;           *d++ = 0;
 32945 00006BE9 F8                      	CLC                             ;           return (0);
 32946 00006BEA C3                      	retn
 32947                                  
 32948                                  CanonBad:
 32949 00006BEB E8CE01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 32950                                  	;mov	al,3
 32951 00006BEE B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 32952 00006BF0 7402                    	JZ	short PathEnc		; path character encountered in string
 32953                                  	;mov	al,2
 32954 00006BF2 B002                    	MOV     AL,error_file_not_found ; Set bad file error
 32955                                  PathEnc:
 32956 00006BF4 F9                      	STC
 32957                                  CanonBad_retn:
 32958 00006BF5 C3                      	retn
 32959                                  ;
 32960                                  ; We have a textual component that we must copy.  We uppercase it and truncate
 32961                                  ; it to 8.3
 32962                                  ;
 32963                                  DoComponent:                            ;           }
 32964 00006BF6 E85100                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 32965 00006BF9 72FA                    	jc	short CanonBad_retn	;           return (-1);
 32966                                  ;
 32967                                  ; We special case the . and .. cases.  These will be backed up.
 32968                                  ;
 32969                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 32970 00006BFB 26833D2E                	CMP	WORD [ES:DI],002Eh
 32971 00006BFF 7408                    	JZ	short Skip1
 32972                                  	;CMP	WORD PTR ES:[DI],'..'
 32973 00006C01 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 32974 00006C06 750A                    	JNZ	short CanonNormal
 32975 00006C08 4F                      	DEC     DI                      ;           d--;
 32976                                  Skip1:  
 32977 00006C09 E82B00                  	CALL    SkipBack                ;           SkipBack ();
 32978                                  	;mov	al,3
 32979 00006C0C B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 32980 00006C0E 72E5                    	jc	short CanonBad_retn
 32981 00006C10 EB02                    	JMP     short CanonPath         ;           }
 32982                                  ;
 32983                                  ; We have a normal path.  Advance destination pointer over it.
 32984                                  ;
 32985                                  CanonNormal:                            ;       else
 32986 00006C12 01CF                    	ADD     DI,CX                   ;           d += ct;
 32987                                  ;
 32988                                  ; We have successfully copied a component.  We are now pointing at a path
 32989                                  ; sep char or are pointing at a nul or are pointing at something else.
 32990                                  ; If we point at something else, then we have an error.
 32991                                  ;
 32992                                  CanonPath:
 32993 00006C14 E81600                  	CALL    PathSep
 32994 00006C17 75D2                    	JNZ	short CanonBad		; something else...
 32995                                  ;
 32996                                  ; Copy the first path char we see.
 32997                                  ;
 32998 00006C19 AC                      	LODSB                           ; get the char
 32999 00006C1A E82EEA                  	call    PATHCHRCMP              ; is it path char?
 33000 00006C1D 75B6                    	JNZ	short CanonDec		; no, go test for nul
 33001 00006C1F 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 33002 00006C21 73C8                    	JAE	short CanonBad		; yep, error.
 33003 00006C23 AA                      	STOSB                           ; copy the one byte
 33004                                  ;
 33005                                  ; Skip all remaining path chars
 33006                                  ;
 33007                                  CanonPathLoop:
 33008 00006C24 AC                      	LODSB                           ; get next byte
 33009 00006C25 E823EA                  	call    PATHCHRCMP              ; path char again?
 33010 00006C28 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 33011 00006C2A 4E                      	DEC     SI                      ; back up
 33012 00006C2B EBA9                    	JMP	short  CanonLoop	; go copy component
 33013                                  
 33014                                  ;BREAK <PathSep - determine if char is a path separator>
 33015                                  ;----------------------------------------------------------------------------
 33016                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 33017                                  ;   Inputs:     DS:SI - point to a char
 33018                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 33019                                  ;               Zero set if AL is / \ or NUL
 33020                                  ;               Zero reset otherwise
 33021                                  ;   Registers modified: AL
 33022                                  ;----------------------------------------------------------------------------
 33023                                  
 33024                                  PathSep:
 33025 00006C2D 8A04                    	MOV     AL,[SI]                 ; get the character
 33026                                  PathSepGotCh:				; already have character
 33027 00006C2F 08C0                    	OR      AL,AL                   ; test for zero
 33028 00006C31 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 33029 00006C33 E815EA                  	call    PATHCHRCMP              ; check for path character
 33030 00006C36 C3                      	retn				; and return HIS determination
 33031                                  
 33032                                  ;BREAK <SkipBack - move backwards to a path separator>
 33033                                  ;----------------------------------------------------------------------------
 33034                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 33036                                  ;               BX has current directory back up limit (point to a / \)
 33037                                  ;   Outputs:    ES:DI backed up to point to a path char
 33038                                  ;               AL has char from output ES:DI (path sep if carry clear)
 33039                                  ;               Carry set if illegal backup
 33040                                  ;               Carry Clear if ok
 33041                                  ;   Registers modified: DI,AL
 33042                                  ;----------------------------------------------------------------------------
 33043                                  
 33044                                  SkipBack:
 33045 00006C37 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 33046 00006C39 720B                    	JB	short SkipBad		;       if (d < dlim)
 33047 00006C3B 4F                      	DEC     DI                      ;           goto err;
 33048 00006C3C 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 33049 00006C3F E809EA                  	call    PATHCHRCMP              ;           break;
 33050 00006C42 75F3                    	JNZ	short SkipBack		;       }
 33051 00006C44 F8                      	CLC                             ;   return (0);
 33052 00006C45 C3                      	retn				;
 33053                                  SkipBad:                                ;err:
 33054                                  	;mov	al,3
 33055 00006C46 B003                    	MOV     AL,error_path_not_found ; bad path error
 33056 00006C48 F9                      	STC                             ;   return (-1);
 33057 00006C49 C3                      	retn                          ;
 33058                                  
 33059                                  ;Break <CopyComponent - copy out a file path component>
 33060                                  ;----------------------------------------------------------------------------
 33061                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 33062                                  ;
 33063                                  ;   Inputs:     DS:SI - source path
 33064                                  ;               ES:DI - destination
 33065                                  ;               ES:BP - end of buffer
 33066                                  ;   Outputs:    Carry Set - too long
 33067                                  ;               Carry Clear - DS:SI moved past component
 33068                                  ;                   CX has length of destination
 33069                                  ;   Registers modified: AX,CX,DX
 33070                                  ;----------------------------------------------------------------------------
 33071                                  
 33072                                  CopyComponent:
 33073                                  
 33074                                  %define CopyBP	 [BP]		; word
 33075                                  %define CopyD	 [BP+2]		; dword
 33076                                  %define CopyDoff [BP+2]		; word
 33077                                  %define CopyS	 [BP+6]		; dword
 33078                                  %define CopySoff [BP+6]		; word
 33079                                  %define CopyTemp [BP+10]	; byte
 33080                                  
 33081 00006C4A 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 33082 00006C4D 1E                      	push	ds
 33083 00006C4E 56                      	push	si
 33084 00006C4F 06                      	push	es
 33085 00006C50 57                      	push	di
 33086 00006C51 55                      	push	bp
 33087 00006C52 89E5                    	MOV     BP,SP
 33088 00006C54 B42E                    	MOV     AH,'.'
 33089 00006C56 AC                      	LODSB
 33090 00006C57 AA                      	STOSB
 33091 00006C58 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 33092 00006C5A 7518                    	JNZ	short NormalComp
 33093 00006C5C E8CEFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 33094 00006C5F 740B                    	JZ	short NulTerm
 33095                                  TryTwoDot:
 33096 00006C61 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 33097 00006C62 AA                      	STOSB
 33098 00006C63 38E0                    	CMP     AL,AH
 33099 00006C65 7557                    	JNZ	short CopyBad
 33100 00006C67 E8C3FF                  	CALL    PathSep
 33101 00006C6A 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 33102                                  NulTerm:                                ;               return -1;
 33103 00006C6C 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 33104 00006C6E AA                      	STOSB
 33105 00006C6F 897606                  	MOV     CopySoff,SI
 33106 00006C72 EB47                    	JMP     SHORT _GoodRet		;       }
 33107                                  NormalComp:                             ;   else {
 33108 00006C74 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 33109 00006C77 E867E9                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 33110 00006C7A 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 33111 00006C7D 743F                    	JZ	short CopyBad		;           return (-1);
 33112 00006C7F 36F606[0D05]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 33113 00006C85 7510                    	JNZ	short DoPack
 33114 00006C87 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 33115 00006C8A 360016[1505]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 33116 00006C8F 7F2D                    	JG	short CopyBad		;               return (-1);
 33117 00006C91 7504                    	JNZ	short DoPack		;           else
 33118 00006C93 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 33119 00006C95 742F                    	JZ	short CopyBadPath	;               return (-1);
 33120                                  DoPack:                                 ;           }
 33121 00006C97 897606                  	MOV     CopySoff,SI ; [bp+6]
 33122 00006C9A 16                      	push	ss
 33123 00006C9B 1F                      	pop	ds
 33124 00006C9C BE[E604]                	MOV     SI,NAME1
 33125 00006C9F 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 33126 00006CA2 57                      	push	di
 33127 00006CA3 E86CC1                  	call	PackName                ;       PackName (Name1, temp);
 33128 00006CA6 5F                      	pop	di
 33129 00006CA7 E8B7B2                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 33130 00006CAA 49                      	DEC     CX
 33131 00006CAB 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 33132 00006CAE 3B4E00                  	CMP     CX,CopyBP   ; [bp+0]
 33133 00006CB1 730B                    	JAE	short CopyBad		;           return (-1);
 33134 00006CB3 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 33135 00006CB5 C47E02                  	LES     DI,CopyD    ; [bp+2]	
 33136 00006CB8 E89DB2                  	call	FStrCpy
 33137                                  _GoodRet:				;       }
 33138 00006CBB F8                      	CLC
 33139 00006CBC EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 33140                                  CopyBad:
 33141 00006CBE F9                      	STC
 33142 00006CBF E8FA00                  	CALL    ScanPathChar            ; check for path chars in rest of string
 33143                                  	;mov	al,2
 33144 00006CC2 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 33145 00006CC4 7503                    	JNZ	short CopyEnd
 33146                                  CopyBadPath:
 33147 00006CC6 F9                      	STC
 33148                                  	;mov	al,3
 33149 00006CC7 B003                    	MOV     AL,error_path_not_found ; Set bad path error
 33150                                  CopyEnd:
 33151 00006CC9 5D                      	pop	bp
 33152 00006CCA 5F                      	pop	di
 33153 00006CCB 07                      	pop	es
 33154 00006CCC 5E                      	pop	si
 33155 00006CCD 1F                      	pop	ds
 33156 00006CCE 9F                      	LAHF
 33157 00006CCF 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 33158 00006CD2 E88CB2                  	call	StrLen
 33159 00006CD5 49                      	DEC     CX
 33160 00006CD6 9E                      	SAHF
 33161 00006CD7 C3                      	retn
 33162                                  
 33163                                  ;Break <Splice - pseudo mount by string substitution>
 33164                                  ;----------------------------------------------------------------------------
 33165                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 33166                                  ;       ThisCDS to point to physical drive CDS.
 33167                                  ;   Inputs:     DS:SI point to string
 33168                                  ;               NoSetDir = TRUE => exact matches with splice fail
 33169                                  ;   Outputs:    DS:SI points to thisCDS
 33170                                  ;               ES:DI points to DPB
 33171                                  ;               String at DS:SI may be reduced in length by removing prefix
 33172                                  ;               and substituting drive letter.
 33173                                  ;               CX = 0 If no splice done
 33174                                  ;               CX <> 0 otherwise
 33175                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 33176                                  ;                   left alone
 33177                                  ;               ThisDPB points to proper DPB
 33178                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 33179                                  ;----------------------------------------------------------------------------
 33180                                  
 33181                                  Splice:
 33182 00006CD8 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 33183 00006CDE 746A                    	JZ	short AllDone
 33184 00006CE0 36FF36[3A05]            	push	word [SS:THISCDS]
 33185 00006CE5 36FF36[3C05]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 33186 00006CEA 1E                      	push	ds
 33187 00006CEB 56                      	push	si
 33188 00006CEC 5F                      	pop	di
 33189 00006CED 07                      	pop	es
 33190 00006CEE 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 33191                                  SpliceScan:
 33192 00006CF0 E8D4FC                  	call	GetCDSFromDrv
 33193 00006CF3 724B                    	JC	short SpliceDone
 33194 00006CF5 FEC0                    	INC     AL
 33195                                  	;test	word [si+67],2000h
 33196 00006CF7 F744430020              	TEST    word [SI+curdir.flags],curdir_splice
 33197 00006CFC 74F2                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 33198 00006CFE 57                      	push	di
 33199 00006CFF E8A100                  	CALL    PathPref                ;           if (!PathPref (s, d))
 33200 00006D02 7403                    	JZ	short SpliceFound	;
 33201                                  SpliceSkip:
 33202 00006D04 5F                      	pop	di
 33203 00006D05 EBE9                    	JMP	short SpliceScan	;               continue;
 33204                                  SpliceFound:
 33205 00006D07 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 33206 00006D0B 7508                    	JNZ	short SpliceDo
 33207 00006D0D 36F606[F802]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 33208 00006D13 75EF                    	JNZ	short SpliceSkip
 33209                                  SpliceDo:
 33210 00006D15 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 33211 00006D17 06                      	push	es
 33212 00006D18 1F                      	pop	ds
 33213 00006D19 5F                      	pop	di
 33214 00006D1A E88000                  	CALL    TextFromDrive1          ;               src = TextFromDrive1(src,i);
 33215 00006D1D 36A1[4E05]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 33216 00006D21 09C0                    	OR      AX,AX
 33217 00006D23 7808                    	JS	short NoPoke
 33218 00006D25 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 33219 00006D27 29F0                    	SUB     AX,SI
 33220 00006D29 36A3[4E05]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 33221                                  NoPoke:
 33222 00006D2D 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 33223 00006D30 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 33224 00006D32 B05C                    	MOV     AL,"\"
 33225 00006D34 AA                      	STOSB
 33226                                  SpliceCopy:                             ;               strcpy (src, p);
 33227 00006D35 E820B2                  	call	FStrCpy
 33228 00006D38 83C404                  	ADD     SP,4                    ; throw away saved stuff
 33229 00006D3B 80C901                  	OR      CL,1                    ; signal splice done.
 33230 00006D3E EB0C                    	JMP     SHORT DoSet             ;               return;
 33231                                  SpliceDone:                             ;               }
 33232 00006D40 368F06[3C05]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 33233 00006D45 368F06[3A05]            	pop	word [SS:THISCDS]			;smr;SS Override
 33234                                  AllDone:
 33235 00006D4A 31C9                    	XOR     CX,CX
 33236                                  DoSet:
 33237 00006D4C 36C536[3A05]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 33238                                  	;les	di,[si+69]
 33239 00006D51 C47C45                  	LES     DI,[SI+curdir.devptr]	
 33240 00006D54 36893E[2405]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 33241 00006D59 368C06[2605]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 33242                                  Splice_retn:
 33243 00006D5E C3                      	retn
 33244                                  
 33245                                  ;Break <$NameTrans - partially process a name>
 33246                                  ;----------------------------------------------------------------------------
 33247                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 33248                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 33249                                  ;   to Transpath playing games with devices, we need to insure that the output
 33250                                  ;   has drive letter and : in it.
 33251                                  ;
 33252                                  ;   Inputs:     DS:SI - source string for translation
 33253                                  ;               ES:DI - pointer to buffer
 33254                                  ;   Outputs:
 33255                                  ;       Carry Clear
 33256                                  ;               Buffer at ES:DI is filled in with data
 33257                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 33258                                  ;       Carry Set
 33259                                  ;               AX = error_path_not_found
 33260                                  ;   Registers modified: all
 33261                                  ;----------------------------------------------------------------------------
 33262                                  
 33263                                  _$NameTrans:
 33264 00006D5F 1E                      	push	ds
 33265 00006D60 56                      	push	si
 33266 00006D61 06                      	push	es
 33267 00006D62 57                      	push	di
 33268 00006D63 51                      	push	cx ; MSDOS 6.0
 33269                                  	
 33270                                  	; MSDOS 6.0	
 33271                                  ; M027 - Start
 33272                                  ;
 33273                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 33274                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 33275                                  ; device if the old call set the volume attribute bit. Note that devname in
 33276                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 33277                                  ; and restore CX.
 33278                                  ;
 33279 00006D64 B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 33280 00006D66 E81A05                  	call	SetAttrib
 33281                                  
 33282                                  ; M027 - End
 33283                                  
 33284                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33285 00006D69 BF[6003]                	MOV     DI,OPENBUF
 33286 00006D6C E8E0FC                  	CALL    TransPath               ; to translation (everything)
 33287 00006D6F 59                      	pop	cx ; MSDOS 6.0
 33288 00006D70 5F                      	pop     di
 33289 00006D71 07                      	pop	es
 33290 00006D72 5E                      	pop     si
 33291 00006D73 1F                      	pop     ds
 33292 00006D74 7303                    	JNC	short TransOK
 33293 00006D76 E98DA9                  	jmp	SYS_RET_ERR
 33294                                  TransOK:
 33295 00006D79 BE[6003]                	MOV     SI,OPENBUF
 33296 00006D7C 16                      	push	ss
 33297 00006D7D 1F                      	pop	ds
 33298                                  GotText:
 33299 00006D7E E8D7B1                  	call	FStrCpy
 33300 00006D81 E979A9                  	jmp	SYS_RET_OK
 33301                                  
 33302                                  ;Break   <DriveFromText - return drive number from a text string>
 33303                                  ;----------------------------------------------------------------------------
 33304                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 33305                                  ;   pointer.
 33306                                  ;
 33307                                  ;   Inputs:     DS:SI point to a text string
 33308                                  ;   Outputs:    AL has drive number
 33309                                  ;               DS:SI advanced
 33310                                  ;   Registers modified: AX,SI.
 33311                                  ;----------------------------------------------------------------------------
 33312                                  
 33313                                  DriveFromText:
 33314 00006D84 30C0                    	XOR     AL,AL                   ;       drive = 0;
 33315 00006D86 803C00                  	CMP     BYTE [SI],0		;       if (*s &&
 33316 00006D89 74D3                    	jz	short Splice_retn
 33317 00006D8B 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 33318 00006D8F 75CD                    	jnz	short Splice_retn
 33319 00006D91 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 33320 00006D92 0C20                    	OR      AL,20h
 33321                                  	;sub	al,60h
 33322 00006D94 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 33323 00006D96 75C6                    	jnz	short Splice_retn
 33324 00006D98 B0FF                    	MOV     AL,-1                   ; nuke AL...
 33325 00006D9A C3                      	retn				;           }
 33326                                  
 33327                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 33328                                  ;----------------------------------------------------------------------------
 33329                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 33330                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 33331                                  ;
 33332                                  ;   Inputs:     AL has 0-based drive number
 33333                                  ;   Outputs:    ES:DI advanced
 33334                                  ;   Registers modified: AX
 33335                                  ;----------------------------------------------------------------------------
 33336                                  
 33337                                  TextFromDrive:
 33338 00006D9B FEC0                    	INC     AL
 33339                                  TextFromDrive1:
 33340                                  	;add	al,40h
 33341 00006D9D 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 33342 00006D9F B43A                    	MOV     AH,":"                  ;   strcat (d, ":");
 33343 00006DA1 AB                      	STOSW
 33344                                  PathPref_retn:
 33345 00006DA2 C3                      	retn
 33346                                  
 33347                                  ;Break   <PathPref - see if one path is a prefix of another>
 33348                                  ;----------------------------------------------------------------------------
 33349                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 33350                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 33351                                  ;   prefix: A:\ and A:\FOO
 33352                                  ;
 33353                                  ;   Inputs:     DS:SI potential prefix
 33354                                  ;               ES:DI string
 33355                                  ;   Outputs:    Zero set => prefix found
 33356                                  ;                   DI/SI advanced past matching part
 33357                                  ;               Zero reset => no prefix, DS/SI garbage
 33358                                  ;   Registers modified: CX
 33359                                  ;----------------------------------------------------------------------------
 33360                                  
 33361                                  PathPref:
 33362 00006DA3 E8C9B1                  	call	DStrLen                 ; get length
 33363 00006DA6 49                      	DEC     CX                      ; do not include nul byte
 33364 00006DA7 F3A6                    	REPZ    CMPSB                   ; compare
 33365 00006DA9 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 33366 00006DAB 50                      	push	ax			; save char register
 33367 00006DAC 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 33368 00006DAF E899E8                  	call    PATHCHRCMP              ; is it a path char (Root!)
 33369 00006DB2 7406                    	JZ	short Prefix		; yes, match root (I hope)
 33370                                  NotSep:                                 ; 2/13/KK
 33371 00006DB4 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 33372 00006DB7 E875FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 33373                                  Prefix:
 33374 00006DBA 58                      	pop	ax			; get back original
 33375 00006DBB C3                      	retn
 33376                                  
 33377                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 33378                                  ;----------------------------------------------------------------------------
 33379                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 33380                                  ;     a path separator.
 33381                                  ;
 33382                                  ;     Input:    DS:SI target string (null terminated)
 33383                                  ;     Output:   Zero set => path separator encountered in string
 33384                                  ;               Zero clear => null encountered
 33385                                  ;     Registers modified: SI
 33386                                  ;----------------------------------------------------------------------------
 33387                                  
 33388                                  ScanPathChar:
 33389 00006DBC AC                      	LODSB                           ; fetch a character
 33390 00006DBD E86FFE                  	call    PathSepGotCh
 33391 00006DC0 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 33392 00006DC2 E886E8                  	call    PATHCHRCMP              ; path separator?
 33393 00006DC5 C3                      	retn
 33394                                  
 33395                                  ;============================================================================
 33396                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 33397                                  ;============================================================================
 33398                                  ; 13/07/2018 - Retro DOS v3.0
 33399                                  
 33400                                  ;	BREAK <$Close - return a handle to the system>
 33401                                  ;----------------------------------------------------------------------------
 33402                                  ;
 33403                                  ;**	$Close - Close a file Handle
 33404                                  ;
 33405                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 33406                                  ;		path
 33407                                  ;
 33408                                  ;	Assembler usage:
 33409                                  ;	    MOV     BX, handle
 33410                                  ;	    MOV     AH, Close
 33411                                  ;	    INT     int_command
 33412                                  ;
 33413                                  ;	ENTRY	(bx) = handle
 33414                                  ;	EXIT	<normal INT21 return convention>
 33415                                  ;	USES	all
 33416                                  ;
 33417                                  ;----------------------------------------------------------------------------
 33418                                  
 33419                                  _$CLOSE:
 33420                                  ;	Grab the SFT pointer from the JFN.
 33421                                  
 33422 00006DC6 E85902                  	call	CheckOwner		; get system file entry
 33423 00006DC9 722B                    	jc	short CloseError	; error return
 33424 00006DCB 16                      	push	ss
 33425 00006DCC 1F                      	pop	ds			; For DOS_CLOSE
 33426 00006DCD 893E[3605]              	MOV	[THISSFT],DI		; save offset of pointer
 33427 00006DD1 8C06[3805]              	MOV	[THISSFT+2],ES		; save segment value
 33428                                  
 33429                                  ; DS:SI point to JFN table entry.
 33430                                  ; ES:DI point to SFT
 33431                                  ;
 33432                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 33433                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 33434                                  ; If the file was not a net FCB, we free the JFN too.
 33435                                  
 33436                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 33437 00006DD5 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 33438 00006DD9 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 33439                                  	;mov	al,[ES:DI+2]
 33440 00006DDB 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 33441                                  	;and	al,0F0h
 33442 00006DDF 24F0                    	AND	AL,SHARING_MASK
 33443                                  	;cmp	al,70h
 33444 00006DE1 3C70                    	CMP	AL,SHARING_NET_FCB
 33445 00006DE3 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 33446                                  
 33447                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 33448                                  ; -1.
 33449                                  
 33450                                  FreeJFN:
 33451 00006DE5 E8FFF9                  	call	pJFNFromHandle		;   d = pJFN (handle);
 33452 00006DE8 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 33453                                  PostFree:
 33454                                  
 33455                                  ; ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_CLOSE!
 33456                                  
 33457 00006DEC E8CBCC                  	call	DOS_CLOSE
 33458                                  
 33459                                  ; DOS_Close may return an error.  If we see such an error, we report it but
 33460                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 33461                                  
 33462 00006DEF 7205                    	JC	short CloseError
 33463                                  	;mov	ah,3Eh
 33464 00006DF1 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 33465 00006DF3 E907A9                  	jmp	SYS_RET_OK
 33466                                  CloseError:
 33467 00006DF6 E90DA9                  	jmp	SYS_RET_ERR
 33468                                  
 33469                                  
 33470                                  ;	BREAK <$Commit - commit the file>
 33471                                  ;----------------------------------------------------------------------------
 33472                                  ;
 33473                                  ;**	$Commit - Commit a File
 33474                                  ;
 33475                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 33476                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 33477                                  ;	the directory entry, etc., so this commit is pretty useless. check
 33478                                  ;	and fix this!! jgl
 33479                                  ;
 33480                                  ;	Assembler usage:
 33481                                  ;	    MOV     BX, handle
 33482                                  ;	    MOV     AH, Commit
 33483                                  ;	    INT     int_command
 33484                                  ;
 33485                                  ;	ENTRY	(bx) = handle
 33486                                  ;	EXIT	none
 33487                                  ;	USES	all
 33488                                  ;;----------------------------------------------------------------------------
 33489                                  
 33490                                  _$COMMIT:
 33491                                  ;	Grab the SFT pointer from the JFN.
 33492                                  
 33493 00006DF9 E82602                  	call	CheckOwner		; get system file entry
 33494 00006DFC 7214                    	JC	short CommitError	; error return
 33495 00006DFE 16                      	push	ss
 33496 00006DFF 1F                      	pop	ds			; For DOS_COMMIT
 33497 00006E00 893E[3605]              	MOV	[THISSFT],DI		; save offset of pointer
 33498 00006E04 8C06[3805]              	MOV	[THISSFT+2],ES		; save segment value
 33499                                  
 33500                                  ;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
 33501                                  ;
 33502                                  ;	ES:DI point to SFT
 33503                                  
 33504 00006E08 E8B0CD                  	call	DOS_COMMIT
 33505 00006E0B 7205                    	JC	short CommitError
 33506                                  	;mov	ah,68h
 33507 00006E0D B468                    	MOV	AH,COMMIT		;
 33508 00006E0F E9EBA8                  	jmp	SYS_RET_OK
 33509                                  CommitError:
 33510 00006E12 E9F1A8                  	jmp	SYS_RET_ERR
 33511                                  
 33512                                  ;	BREAK <$ExtHandle - extend handle count>
 33513                                  
 33514                                  ;**	$ExtHandle - Extend Handle Count
 33515                                  ;----------------------------------------------------------------------------
 33516                                  ;	Assembler usage:
 33517                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 33518                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 33519                                  ;	    INT     int_command 		 busy )
 33520                                  ;
 33521                                  ;	ENTRY	(bx) = new number of handles
 33522                                  ;	EXIT	'C' clear if OK
 33523                                  ;		'C' set iff err
 33524                                  ;		  (ax) = error code
 33525                                  ;			 AX = error_not_enough_memory
 33526                                  ;			      error_too_many_open_files
 33527                                  ;	USES	all
 33528                                  ;----------------------------------------------------------------------------
 33529                                  
 33530                                  _$ExtHandle:
 33531 00006E15 31ED                    	XOR	BP,BP			; 0: enlarge  1: shrink  2:psp
 33532                                  	;cmp	bx,20
 33533 00006E17 83FB14                  	CMP	BX,FILPERPROC
 33534 00006E1A 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 33535 00006E1C BB1400                  	MOV	BX,FILPERPROC
 33536                                  exth2:	
 33537 00006E1F 368E06[DE02]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 33538                                  	;mov	cx,[ES:32h]
 33539 00006E24 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 33540 00006E29 39CB                    	CMP	BX,CX			; the requested == current
 33541 00006E2B 7452                    	JE	short ok_done 		; yes and exit
 33542 00006E2D 7722                    	JA	short larger		; go allocate new table
 33543                                  
 33544                                  ;	We're going to shrink the # of handles available
 33545                                  
 33546 00006E2F BD0100                  	MOV	BP,1			; shrink
 33547                                  	;mov	ds,[ES:36h]
 33548 00006E32 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 33549 00006E37 89DE                    	MOV	SI,BX			;
 33550 00006E39 29D9                    	SUB	CX,BX			; get difference
 33551                                  
 33552                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 33553                                  chck_handles:
 33554 00006E3B 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 33555 00006E3E 7542                    	JNZ	short too_many_files	; status
 33556 00006E40 46                      	INC	SI
 33557 00006E41 E2F8                    	LOOP	chck_handles
 33558 00006E43 83FB14                  	CMP	BX,FILPERPROC		; = 20
 33559 00006E46 7709                    	JA	short larger		; no
 33560                                  
 33561 00006E48 BD0200                  	MOV	BP,2			; psp
 33562                                  	;mov	di,24
 33563 00006E4B BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 33564 00006E4E 53                      	PUSH	BX
 33565 00006E4F EB1F                    	JMP	short movhandl
 33566                                  
 33567                                  larger:
 33568 00006E51 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 33569 00006E54 0F848100                	JZ	invalid_func ; 10/08/2018
 33570 00006E58 F8                      	CLC
 33571 00006E59 53                      	PUSH	BX			; save requested number
 33572 00006E5A 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 33573 00006E5D B104                    	MOV	CL,4
 33574                                  	;ror	bx,cl			; MSDOS 3.3
 33575 00006E5F D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 33576 00006E61 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 33577                                  
 33578 00006E65 55                      	PUSH	BP
 33579 00006E66 E8E8F6                  	call	_$ALLOC			; allocate memory
 33580 00006E69 5D                      	POP	BP
 33581 00006E6A 7267                    	JC	short no_memory		; not enough meory
 33582                                  
 33583 00006E6C 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 33584 00006E6E 31FF                    	XOR	DI,DI
 33585                                  movhandl:
 33586 00006E70 368E1E[DE02]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 33587                                  
 33588 00006E75 F7C50300                	test	BP,3			; enlarge ?
 33589 00006E79 740C                    	JZ	short enlarge 		; yes
 33590 00006E7B 59                      	POP	CX			; cx = the amount you shrink
 33591 00006E7C 51                      	PUSH	CX
 33592 00006E7D EB0C                    	JMP	short copy_hand
 33593                                  
 33594                                  ;	Done.  'C' clear
 33595                                  
 33596                                  ok_done:
 33597 00006E7F E97BA8                  	jmp	SYS_RET_OK
 33598                                  
 33599                                  too_many_files:
 33600                                  	;mov	al,4
 33601 00006E82 B004                    	MOV	AL,error_too_many_open_files
 33602 00006E84 E97FA8                  	jmp	SYS_RET_ERR
 33603                                  
 33604                                  enlarge:
 33605                                  	;mov	cx,[32h]
 33606 00006E87 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 33607                                  copy_hand:
 33608 00006E8B 89CA                    	MOV	DX,CX
 33609                                  	;lds	si,[34h]
 33610 00006E8D C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 33611 00006E91 F3A4                    	REP	MOVSB			; copy information to new table
 33612 00006E93 59                      	POP	CX			; get new number of handles
 33613 00006E94 51                      	PUSH	CX			; save it again
 33614 00006E95 29D1                    	SUB	CX,DX			; get the difference
 33615 00006E97 B0FF                    	MOV	AL,-1			; set availability to handles
 33616 00006E99 F3AA                    	REP	STOSB
 33617 00006E9B 368E1E[DE02]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 33618                                  	;cmp	word [34h],0
 33619 00006EA0 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 33620 00006EA5 750D                    	JNZ	short update_info	; yes, go update PDB entries
 33621 00006EA7 55                      	PUSH	BP
 33622 00006EA8 1E                      	PUSH	DS			; save old table segment
 33623 00006EA9 06                      	PUSH	ES			; save new table segment
 33624 00006EAA 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 33625 00006EAE E8BDF7                  	call	_$DEALLOC		; deallocate old table meomory
 33626 00006EB1 07                      	POP	ES			; restore new table segment
 33627 00006EB2 1F                      	POP	DS			; restore old table segment
 33628 00006EB3 5D                      	POP	BP
 33629                                  
 33630                                  update_info:
 33631 00006EB4 F7C50200                	test	BP,2			; psp?
 33632 00006EB8 7408                    	JZ	short non_psp 		; no
 33633                                  	;mov	word [34h],18h ; 24
 33634 00006EBA C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 33635 00006EC0 EB06                    	JMP	short final
 33636                                  non_psp:
 33637                                  	;mov	word [34h],0
 33638 00006EC2 C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 33639                                  final:
 33640                                  	;mov	word [36h],es	
 33641 00006EC8 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 33642                                  	;pop	word [32h]
 33643 00006ECC 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 33644 00006ED0 E92AA8                  	jmp	SYS_RET_OK
 33645                                  
 33646                                  no_memory:
 33647 00006ED3 5B                      	POP	BX			; clean stack
 33648                                  	;mov	al,8
 33649 00006ED4 B008                    	MOV	AL,error_not_enough_memory
 33650 00006ED6 E92DA8                  	jmp	SYS_RET_ERR
 33651                                  invalid_func:
 33652                                  	;mov	al,1
 33653 00006ED9 B001                    	MOV	AL,error_invalid_function
 33654 00006EDB E928A8                  	jmp	SYS_RET_ERR
 33655                                  
 33656                                  
 33657                                  ;	BREAK <$READ - Read from a file handle>
 33658                                  ;----------------------------------------------------------------------------
 33659                                  ;
 33660                                  ;**	$Read - Read from a File Handle
 33661                                  ;
 33662                                  ;   Assembler usage:
 33663                                  ;
 33664                                  ;	LDS	DX, buf
 33665                                  ;	MOV	CX, count
 33666                                  ;	MOV	BX, handle
 33667                                  ;	MOV	AH, Read
 33668                                  ;	INT	int_command
 33669                                  ;	  AX has number of bytes read
 33670                                  ;
 33671                                  ;	ENTRY	(bx) = file handle
 33672                                  ;		(cx) = byte count
 33673                                  ;		(ds:dx) = buffer address
 33674                                  ;	EXIT	Through system call return so that to user:
 33675                                  ;		  'C' clear if OK
 33676                                  ;		    (ax) = bytes read
 33677                                  ;		  'C' set if error
 33678                                  ;		    (ax) = error code
 33679                                  ;
 33680                                  ;----------------------------------------------------------------------------
 33681                                  
 33682                                  _$READ:
 33683 00006EDE BE[FC3D]                	MOV	SI,DOS_READ
 33684                                  ReadDo:
 33685 00006EE1 E803F9                  	call	pJFNFromHandle
 33686 00006EE4 7208                    	JC	short ReadError
 33687 00006EE6 268A05                  	MOV	AL,[ES:DI]
 33688 00006EE9 E83601                  	call	CheckOwner		; get the handle
 33689 00006EEC 7303                    	JNC	short ReadSetup		; no errors do the operation
 33690                                  
 33691                                  ;	Have an error.	'C' set
 33692                                  
 33693                                  ReadError:
 33694 00006EEE E915A8                  	jmp	SYS_RET_ERR		; go to error traps
 33695                                  
 33696                                  ReadSetup:
 33697 00006EF1 36893E[3605]            	MOV	[SS:THISSFT],DI		; save offset of pointer;smr;SS Override
 33698 00006EF6 368C06[3805]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 33699                                  	;;; MSDOS 6.0 
 33700                                  ;; Extended Open
 33701                                  	;;;testb [ES:DI+SF_ENTRY.sf_mode],INT_24_ERROR  ;AN000;;EO. need i24
 33702                                  	;;;JZ	short needi24 		      ;AN000;;EO. yes
 33703                                  	;;;OR	byte [EXTOPEN_ON],EXT_OPEN_I24_OFF 
 33704                                  					;AN000;;EO. set it off;smr;SS Override
 33705                                  needi24:				;AN000;
 33706                                  ;; Extended Open
 33707 00006EFB 36FF36[DA02]            	push	word [SS:DMAADD]
 33708 00006F00 36FF36[DC02]            	push	word [SS:DMAADD+2]	;smr;SS Override
 33709                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 33710                                  	;;; MSDOS 6.0
 33711                                  	;;; CALL Align_Buffer		;AN000;MS. align user's buffer
 33712                                  	; MSDOS 3.3
 33713 00006F05 89D3                    	MOV	BX,DX			; copy offset
 33714 00006F07 51                      	push	cx			; don't stomp on count
 33715 00006F08 B104                    	MOV	CL,4			; bits to shift bytes->para
 33716 00006F0A D3EB                    	SHR	BX,CL			; get number of paragraphs
 33717 00006F0C 59                      	pop	cx			; get count back
 33718 00006F0D 8CD8                    	MOV	AX,DS			; get original segment
 33719 00006F0F 01D8                    	ADD	AX,BX			; get new segment
 33720 00006F11 8ED8                    	MOV	DS,AX			; in seg register
 33721 00006F13 83E20F                  	AND	DX,0Fh			; normalize offset
 33722 00006F16 368916[DA02]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 33723 00006F1B 368C1E[DC02]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 33724                                  						;smr;SS Override
 33725                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 33726 00006F20 16                      	push	ss			; go for DOS addressability
 33727 00006F21 1F                      	pop	ds
 33728 00006F22 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 33729 00006F24 8F06[DC02]              	pop	word [DMAADD+2]
 33730 00006F28 8F06[DA02]              	pop	word [DMAADD]
 33731                                  	;JNC	short READ_OK		;AN002;
 33732                                  	;JMP	ReadError		;AN002; if error, say bye bye
 33733 00006F2C 72C0                    	jc	short ReadError
 33734                                  READ_OK:
 33735 00006F2E 89C8                    	MOV	AX,CX			; get correct return in correct reg
 33736 00006F30 E9CAA7                  	jmp	SYS_RET_OK		; successful return
 33737                                  
 33738                                  
 33739                                  
 33740                                  ; 13/07/2018 - Retro DOS v3.0
 33741                                  
 33742                                  ;
 33743                                  ;   Input: DS:DX points to user's buffer addr
 33744                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 33745                                  ;   Output: [DMAADD] set
 33746                                  ;
 33747                                  
 33748                                  ;Align_Buffer:
 33749                                  ;	MOV	BX,DX			; copy offset
 33750                                  ;	push	cx			; don't stomp on count
 33751                                  ;	MOV	CL,4			; bits to shift bytes->para
 33752                                  ;	SHR	BX,CL			; get number of paragraphs
 33753                                  ;	pop	cx			; get count back
 33754                                  ;	MOV	AX,DS			; get original segment
 33755                                  ;	ADD	AX,BX			; get new segment
 33756                                  ;	MOV	DS,AX			; in seg register
 33757                                  ;	AND	DX,0Fh			; normalize offset
 33758                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 33759                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 33760                                  ;						;smr;SS Override
 33761                                  ;	retn
 33762                                  
 33763                                  ;BREAK <$WRITE - write to a file handle>
 33764                                  ;----------------------------------------------------------------------------
 33765                                  ;
 33766                                  ;   Assembler usage:
 33767                                  ;	    LDS     DX, buf
 33768                                  ;	    MOV     CX, count
 33769                                  ;	    MOV     BX, handle
 33770                                  ;	    MOV     AH, Write
 33771                                  ;	    INT     int_command
 33772                                  ;	  AX has number of bytes written
 33773                                  ;   Errors:
 33774                                  ;	    AX = write_invalid_handle
 33775                                  ;	       = write_access_denied
 33776                                  ;
 33777                                  ;   Returns in register AX
 33778                                  ;
 33779                                  ;----------------------------------------------------------------------------
 33780                                  
 33781                                  _$WRITE:
 33782 00006F33 BE[7D3F]                	MOV	SI,DOS_WRITE
 33783 00006F36 EBA9                    	JMP	short ReadDo
 33784                                  
 33785                                  ;BREAK <$LSEEK - move r/w pointer>
 33786                                  ;----------------------------------------------------------------------------
 33787                                  ;
 33788                                  ;   Assembler usage:
 33789                                  ;	    MOV     DX, offsetlow
 33790                                  ;	    MOV     CX, offsethigh
 33791                                  ;	    MOV     BX, handle
 33792                                  ;	    MOV     AL, method
 33793                                  ;	    MOV     AH, LSeek
 33794                                  ;	    INT     int_command
 33795                                  ;	  DX:AX has the new location of the pointer
 33796                                  ;   Error returns:
 33797                                  ;	    AX = error_invalid_handle
 33798                                  ;	       = error_invalid_function
 33799                                  ;   Returns in registers DX:AX
 33800                                  ;
 33801                                  ;----------------------------------------------------------------------------
 33802                                  
 33803                                  _$LSEEK:
 33804 00006F38 E8E700                  	call	CheckOwner		; get system file entry
 33805                                  LSeekError:
 33806                                  	;JNC	short CHKOWN_OK		;AN002;
 33807                                  	;JMP	short ReadError		;AN002; error return
 33808 00006F3B 72B1                    	jc	short ReadError ; 24/07/2019
 33809                                  CHKOWN_OK:				;AN002;
 33810 00006F3D 3C02                    	CMP	AL,2			; is the seek value correct?
 33811 00006F3F 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 33812                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 33813 00006F41 36C606[D102]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 33814                                  					;smr;SS Override
 33815                                  	;mov	al,1
 33816 00006F47 B001                    	mov	al, error_invalid_function ; invalid method
 33817 00006F49 EBA3                    	jmp	short ReadError
 33818                                  LSeekDisp:
 33819 00006F4B 3C01                    	CMP	AL,1			; best way to dispatch ; check middle
 33820 00006F4D 720A                    	JB	short LSeekStore	; just store CX:DX
 33821 00006F4F 771C                    	JA	short LSeekEOF		; seek from end of file
 33822                                  	;add	dx,[es:di+21]
 33823 00006F51 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 33824                                  	;adc	cx,[es:di+23]
 33825 00006F55 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 33826                                  LSeekStore:
 33827 00006F59 89C8                    	MOV	AX,CX			; AX:DX
 33828 00006F5B 92                      	XCHG	AX,DX			; DX:AX is the correct value
 33829                                  LSeekSetpos:
 33830                                  	;mov	[es:di+21],ax
 33831 00006F5C 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 33832                                  	;mov	[es:di+23],dx
 33833 00006F60 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 33834 00006F64 E8A4A6                  	call	Get_User_Stack
 33835                                  	;mov	[si+6],dx
 33836 00006F67 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 33837                                  	;jmp	SYS_RET_OK		; successful return
 33838                                  	; 26/07/2019
 33839 00006F6A E993A7                  	jmp	SYS_RET_OK_clc
 33840                                  
 33841                                  LSeekEOF:
 33842                                  	;test	word [es:di+5],8000h
 33843 00006F6D 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 33844 00006F73 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 33845                                  LOCAL_LSeek:
 33846                                  	;add	dx,[es:di+17]
 33847 00006F75 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 33848                                  	;adc	cx,[es:di+19]
 33849 00006F79 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 33850 00006F7D EBDA                    	JMP	short LSeekStore	; go and set the position
 33851                                  
 33852                                  Check_LSeek_Mode:
 33853                                  	;test	word [es:di+2],8000h
 33854 00006F7F 26F745020080            	test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 33855 00006F85 75EE                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 33856                                  	;mov	ax,[es:di+2]
 33857 00006F87 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 33858                                  	;and	ax, 0F0h
 33859 00006F8B 25F000                  	AND	AX,SHARING_MASK
 33860                                  	;cmp	ax,40h
 33861 00006F8E 83F840                  	CMP	AX,SHARING_DENY_NONE
 33862 00006F91 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 33863                                  	;cmp	ax,30h
 33864 00006F93 83F830                  	CMP	AX,SHARING_DENY_READ
 33865 00006F96 75DD                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 33866                                  NET_LSEEK:
 33867                                  ;	JMP	short LOCAL_LSeek
 33868                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 33869                                  	;CallInstall Net_Lseek,MultNET,33
 33870                                  	;JNC	short LSeekSetPos
 33871                                  
 33872 00006F98 B82111                  	mov     ax, 1121h
 33873 00006F9B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 33874                                  			; CX:DX = offset (in bytes) from end
 33875                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 33876                                  			; SS = DOS CS
 33877                                  			; Return: CF set on error
 33878                                  			; CF clear if successful, DX:AX = new file position
 33879 00006F9D 73BD                    	jnb     short LSeekSetpos
 33880 00006F9F E964A7                  	jmp	SYS_RET_ERR
 33881                                  
 33882                                  ;BREAK <FileTimes - modify write times on a handle>
 33883                                  ;----------------------------------------------------------------------------
 33884                                  ;
 33885                                  ;   Assembler usage:
 33886                                  ;	    MOV AH, FileTimes (57H)
 33887                                  ;	    MOV AL, func
 33888                                  ;	    MOV BX, handle
 33889                                  ;	; if AL = 1 then then next two are mandatory
 33890                                  ;	    MOV CX, time
 33891                                  ;	    MOV DX, date
 33892                                  ;	    INT 21h
 33893                                  ;	; if AL = 0 then CX/DX has the last write time/date
 33894                                  ;	; for the handle.
 33895                                  ;
 33896                                  ;	AL=02		 get extended attributes
 33897                                  ;	   BX=handle
 33898                                  ;	   CX=size of buffer (0, return max size )
 33899                                  ;	   DS:SI query list (si=-1, selects all EA)
 33900                                  ;	   ES:DI buffer to hold EA list
 33901                                  ;
 33902                                  ;	AL=03		 get EA name list
 33903                                  ;	   BX=handle
 33904                                  ;	   CX=size of buffer (0, return max size )
 33905                                  ;	   ES:DI buffer to hold name list
 33906                                  ;
 33907                                  ;	AL=04		 set extended attributes
 33908                                  ;	   BX=handle
 33909                                  ;	   ES:DI buffer of EA list
 33910                                  ;
 33911                                  ;
 33912                                  ;   Error returns:
 33913                                  ;	    AX = error_invalid_function
 33914                                  ;	       = error_invalid_handle
 33915                                  ;
 33916                                  ;----------------------------------------------------------------------------
 33917                                  
 33918                                  _$FILE_TIMES:
 33919                                  	; 13/07/2018 - Retro DOS v3.0
 33920                                  
 33921                                  	; MSDOS 3.3
 33922 00006FA2 3C02                    	cmp	al,2			; correct subfunction ?
 33923 00006FA4 720B                    	jb	short ft1
 33924                                  
 33925                                          ;mov	byte [ss:EXTERR_LOCUS], 1
 33926 00006FA6 36C606[D102]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 33927                                  						;SS Overr
 33928                                  	;mov	al,1
 33929 00006FAC B001                    	mov	al,error_invalid_function ; give bad return
 33930 00006FAE E955A7                  	jmp     SYS_RET_ERR
 33931                                  
 33932                                  	; MSDOS 6.0
 33933                                  	;cmp	al,2			; correct subfunction ?
 33934                                  	;jae	short inval_func
 33935                                  ft1:
 33936 00006FB1 E86E00                  	call	CheckOwner		; get sft
 33937 00006FB4 7285                    	jc	short LSeekError	; bad handle
 33938                                  
 33939 00006FB6 08C0                    	or	al,al			; get time/date ?
 33940 00006FB8 7515                    	jnz	short ft_set_time
 33941                                  
 33942                                  ;------ here we get the time & date from the sft for the user
 33943                                  
 33944 00006FBA FA                      	cli				; is this cli/sti reqd ? BUGBUG
 33945                                  	;mov	cx,[es:di+13]
 33946 00006FBB 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 33947                                  	;mov	dx,[es:di+15]
 33948 00006FBF 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 33949 00006FC3 FB                      	sti
 33950 00006FC4 E844A6                  	call	Get_User_Stack
 33951                                  	;mov	[si+4],cx
 33952 00006FC7 894C04                  	mov	[si+user_env.user_CX],cx
 33953                                  	;mov	[si+6],dx
 33954 00006FCA 895406                  	mov	[si+user_env.user_DX],dx
 33955 00006FCD EB20                    	jmp	short ok_ret
 33956                                  
 33957                                  ;------ here we set the time in sft
 33958                                  
 33959                                  ft_set_time:
 33960 00006FCF E891B0                  	call    EcritSFT
 33961                                  	;mov	[es:di+13],cx
 33962 00006FD2 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 33963                                  	;mov	[es:di+15],dx
 33964 00006FD6 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 33965                                  
 33966 00006FDA 31C0                    	xor	ax, ax
 33967 00006FDC 36FF1E[9400]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 33968                                  
 33969                                  ;------ set the flags in SFT entry
 33970                                  	;and	word [es:di+5],0FFBFh
 33971 00006FE1 26836505BF              	and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 33972                                  							; mark file as dirty
 33973                                  	;or	word [es:di+5],4000h
 33974 00006FE6 26814D050040            	or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 33975                                  							; ask close not to
 33976                                  							;   bother about date
 33977                                  							;   and time
 33978 00006FEC E87CB0                  	call	LcritSFT
 33979                                  ok_ret:
 33980 00006FEF E90BA7                  	jmp	SYS_RET_OK
 33981                                  
 33982                                  ;inval_func:
 33983                                  ;	mov	byte [ss:EXTERR_LOCUS], 1
 33984                                  ;	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 33985                                  ;						;SS Overr
 33986                                  ;	;mov	al,1
 33987                                  ;	mov	al,error_invalid_function ; give bad return
 33988                                  ;	jmp     SYS_RET_ERR
 33989                                  
 33990                                  ;BREAK <$DUP - duplicate a jfn>
 33991                                  ;----------------------------------------------------------------------------
 33992                                  ;
 33993                                  ;   Assembler usage:
 33994                                  ;	    MOV     BX, fh
 33995                                  ;	    MOV     AH, Dup
 33996                                  ;	    INT     int_command
 33997                                  ;	  AX has the returned handle
 33998                                  ;   Errors:
 33999                                  ;	    AX = dup_invalid_handle
 34000                                  ;	       = dup_too_many_open_files
 34001                                  ;
 34002                                  ;----------------------------------------------------------------------------
 34003                                  
 34004                                  _$DUP:
 34005 00006FF2 89D8                    	MOV	AX,BX			; save away old handle in AX
 34006 00006FF4 E844F8                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 34007                                  DupErrorCheck:
 34008 00006FF7 7218                    	JC	short DupErr		; nope, bye
 34009 00006FF9 06                      	push	es
 34010 00006FFA 57                      	push	di			; save away SFT
 34011 00006FFB 5E                      	pop	si			; into convenient place DS:SI
 34012 00006FFC 1F                      	pop	ds
 34013 00006FFD 93                      	XCHG	AX,BX			; get back old handle
 34014 00006FFE E82100                  	call	CheckOwner		; get sft in ES:DI
 34015 00007001 720E                    	JC	short DupErr		; errors go home
 34016 00007003 E8D2C6                  	call	DOS_Dup_Direct
 34017 00007006 E8DEF7                  	call	pJFNFromHandle		; get pointer
 34018 00007009 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 34019 0000700C 881C                    	MOV	[SI],BL			; stuff in new SFT
 34020 0000700E E9ECA6                  	jmp	SYS_RET_OK		; and go home
 34021                                  DupErr:
 34022 00007011 E9F2A6                  	jmp	SYS_RET_ERR
 34023                                  
 34024                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 34025                                  ;----------------------------------------------------------------------------
 34026                                  ;
 34027                                  ;   Assembler usage:
 34028                                  ;	    MOV     BX, fh
 34029                                  ;	    MOV     CX, newfh
 34030                                  ;	    MOV     AH, Dup2
 34031                                  ;	    INT     int_command
 34032                                  ;   Error returns:
 34033                                  ;	    AX = error_invalid_handle
 34034                                  ;
 34035                                  ;----------------------------------------------------------------------------
 34036                                  
 34037                                  _$DUP2:
 34038 00007014 53                      	push	bx
 34039 00007015 51                      	push	cx			; save source
 34040 00007016 89CB                    	MOV	BX,CX			; get one to close
 34041 00007018 E8ABFD                  	call	_$CLOSE			; close destination handle
 34042 0000701B 5B                      	pop	bx
 34043 0000701C 58                      	pop	ax			; old in AX, new in BX
 34044 0000701D E8C7F7                  	call	pJFNFromHandle		; get pointer
 34045 00007020 EBD5                    	JMP	short DupErrorCheck	; check error and do dup
 34046                                  
 34047                                  ;Break	<CheckOwner - verify ownership of handles from server>
 34048                                  ;----------------------------------------------------------------------------
 34049                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 34050                                  ;   process without the process knowing it (delete/rename of open files, for
 34051                                  ;   example), it is possible for the redirector to issue a call to a handle
 34052                                  ;   that it soes not rightfully own.  We check here to make sure that the
 34053                                  ;   issuing process is the owner of the SFT.  At the same time, we do a
 34054                                  ;   SFFromHandle to really make sure that the SFT is good.
 34055                                  ;
 34056                                  ;	ENTRY	BX has the handle
 34057                                  ;		User_ID is the current user
 34058                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 34059                                  ;		Carry Set => AX has error code
 34060                                  ;	USES	none
 34061                                  ;----------------------------------------------------------------------------
 34062                                  
 34063                                  CheckOwner:
 34064                                  	; 13/07/2018 - Retro DOS v3.0
 34065                                  
 34066 00007022 E8DAF7                  	call	SFFromHandle
 34067 00007025 720F                    	jc	short co_ret_label	; retc
 34068                                  
 34069 00007027 50                      	push	ax
 34070                                  
 34071                                  	; MSDOS 6.0
 34072                                  ;SR;
 34073                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 34074                                  ;SR; are shared across multiple VMs in win386.
 34075                                  ;SR;
 34076                                  	;test	byte [IsWin386],1
 34077                                  	;jz	short no_win386		;win386 is not present
 34078                                  	;xor	ax,ax			;set the zero flag
 34079                                  	;jmp	short skip_win386	
 34080                                  
 34081                                  ;no_win386:
 34082 00007028 36A1[EA02]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 34083                                  	;cmp	ax,[es:di+47]
 34084 0000702C 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 34085                                  
 34086                                  ;skip_win386:
 34087 00007030 58                      	pop	ax
 34088                                  	
 34089 00007031 7403                    	jz	short co_ret_label
 34090                                  	
 34091                                  	;mov	al,6
 34092 00007033 B006                    	mov	al,error_invalid_handle
 34093 00007035 F9                      	stc
 34094                                  
 34095                                  co_ret_label:
 34096 00007036 C3                      	retn
 34097                                  
 34098                                  ;============================================================================
 34099                                  ; FILE.ASM, MSDOS 6.0, 1991
 34100                                  ;============================================================================
 34101                                  ; 14/07/2018 - Retro DOS v3.0
 34102                                  
 34103                                  ; MSDOS 2.11
 34104                                  ;BREAK <$Open - open a file handle>
 34105                                  ;----------------------------------------------------------------------------
 34106                                  ;   Assembler usage:
 34107                                  ;           LDS     DX, Name
 34108                                  ;           MOV     AH, Open
 34109                                  ;           MOV     AL, access
 34110                                  ;           INT     int_command
 34111                                  ;
 34112                                  ;       ACCESS          Function
 34113                                  ;       ------          --------
 34114                                  ;       open_for_read   file is opened for reading
 34115                                  ;       open_for_write  file is opened for writing
 34116                                  ;       open_for_both   file is opened for both reading and writing.
 34117                                  ;
 34118                                  ;   Error returns:
 34119                                  ;           AX = error_invalid_access
 34120                                  ;              = error_file_not_found
 34121                                  ;              = error_access_denied
 34122                                  ;              = error_too_many_open_files
 34123                                  ;----------------------------------------------------------------------------
 34124                                  
 34125                                  ; MSDOS 6.0
 34126                                  ;	BREAK <$Open - open a file from a path string>
 34127                                  ;----------------------------------------------------------------------------
 34128                                  ;
 34129                                  ;**	$OPen - Open a File
 34130                                  ;
 34131                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 34132                                  ;	file and and returns a handle
 34133                                  ;
 34134                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 34135                                  ;		(AL) = open mode
 34136                                  ;	EXIT	'C' clear if OK
 34137                                  ;		  (ax) = file handle
 34138                                  ;		'C' set if error
 34139                                  ;		  (ax) = error code
 34140                                  ;	USES	all
 34141                                  ;
 34142                                  ;----------------------------------------------------------------------------
 34143                                  
 34144                                  _$OPEN:       
 34145 00007037 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 34146                                  _$Open2:
 34147                                  	;mov	ch,16h
 34148 00007039 B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 34149 0000703B E84502                  	call	SetAttrib
 34150 0000703E B9[7A37]                	mov	cx,DOS_OPEN
 34151                                  
 34152                                  	;xor	ah,ah  ; MSDOS 3.3
 34153                                  
 34154 00007041 50                      	push	ax
 34155                                  
 34156                                  ;*	General file open/create code. The $CREATE call and the various
 34157                                  ;	$OPEN calls all come here.
 34158                                  ;
 34159                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 34160                                  ;	path names, etc., and then dispatch to our individual handlers.
 34161                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 34162                                  ;
 34163                                  ;	(TOS) = create mode
 34164                                  ;	(CX) = address of routine to call to do actual function
 34165                                  ;	(DS:DX) = ASCIZ name
 34166                                  ;	SAttrib = Attribute mask
 34167                                  
 34168                                  ;	Get a free SFT and mark it "being allocated"
 34169                                  
 34170                                  AccessFile:
 34171 00007042 E81EB0                  	call	EcritSFT
 34172 00007045 E806F8                  	call	SFNFree			; get a free sfn
 34173 00007048 E820B0                  	call	LcritSFT
 34174 0000704B 7214                    	jc	short OpenFailJ		; oops, no free sft's
 34175 0000704D 36891E[4205]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 34176 00007052 36893E[3605]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 34177 00007057 368C06[3805]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 34178                                  
 34179                                  ;	Find a free area in the user's JFN table.
 34180                                  
 34181 0000705C E8DCF7                  	call	JFNFree			; get a free jfn
 34182 0000705F 7303                    	jnc	short SaveJFN
 34183                                  OpenFailJ:
 34184 00007061 E98100                  	JMP	OpenFail		; there were free JFNs... try SFN
 34185                                  
 34186                                  SaveJFN:
 34187 00007064 36893E[4605]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 34188 00007069 368C06[4805]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 34189 0000706E 36891E[4405]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 34190                                  
 34191                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 34192                                  ;	reusing the same JFN.
 34193                                  
 34194 00007073 368B1E[4205]            	MOV	BX,[ss:SFN]					;smr;SS Override
 34195 00007078 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 34196 0000707B 89D6                    	MOV	SI,DX			; get name in appropriate place
 34197 0000707D BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 34198 00007080 51                      	push	cx			; save routine to call
 34199 00007081 E8CBF9                  	call	TransPath		; convert the path
 34200 00007084 5B                      	pop	bx			; (bx) = routine to call
 34201                                  
 34202 00007085 36C536[3605]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 34203 0000708A 720A                    	JC	short OpenCleanJ	; no error, go and open file
 34204 0000708C 36803E[1505]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 34205 00007092 7404                    	JZ	short SetSearch
 34206                                  	;mov	al,2
 34207 00007094 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 34208                                  OpenCleanJ:
 34209 00007096 EB3E                    	JMP	short OpenClean
 34210                                  
 34211                                  SetSearch:
 34212 00007098 58                      	pop	ax			; Mode (Open), Attributes (Create)
 34213                                  
 34214                                  ;	We need to get the new inheritance bits.
 34215                                  
 34216 00007099 31C9                    	xor	cx,cx
 34217                                  	; MSDOS 6.0
 34218                                  	;mov	[si+2],cx ; 0
 34219 0000709B 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 34220                                  	;mov    [si+51],cx ; 0
 34221 0000709E 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 34222                                  	;
 34223 000070A1 81FB[7A37]              	CMP	BX,DOS_OPEN
 34224 000070A5 7509                    	JNZ	short _DoOper
 34225                                  	;test   al,80h
 34226 000070A7 A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 34227 000070A9 7405                    	JZ	short _DoOper ; 10/08/2018
 34228 000070AB 247F                    	AND	AL,7Fh			; mask off inherit bit
 34229                                  	;mov	cx,1000h
 34230 000070AD B90010                  	MOV	CX,sf_no_inherit
 34231                                  _DoOper:
 34232                                  	;; MSDOS 3.3
 34233                                  	;;mov	word [si+2], 0
 34234                                  	;;mov	word [si+33h], 0
 34235                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 34236                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 34237                                  
 34238                                  	; MSDOS 6.0
 34239                                  ;**	Check if this is an extended open. If so you must set the
 34240                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 34241                                  ;	Set_EXT_mode in creat.asm
 34242                                  
 34243                                  	; MSDOS 6.0
 34244                                  	;;SAVE	<di, es>                ;M022 conditional removed here
 34245                                  	;push	di
 34246                                  	;push	es
 34247                                  	;push	ds
 34248                                  	;pop	es
 34249                                  	;push	si
 34250                                  	;pop	di			; (es:di) = SFT address
 34251                                  	;call	Set_EXT_mode
 34252                                  	;;RESTORE <es, di>
 34253                                  	;pop	es
 34254                                  	;pop	di
 34255                                  
 34256                                  	;Context DS
 34257 000070B0 16                      	push	ss
 34258 000070B1 1F                      	pop	ds	
 34259                                  
 34260 000070B2 51                      	push	cx
 34261 000070B3 FFD3                    	CALL	BX			; blam!
 34262 000070B5 59                      	pop	cx
 34263 000070B6 C536[3605]              	LDS	SI,[THISSFT]
 34264                                  	;JC	short OpenE2		;AN000;FT. chek extended open hooks first
 34265 000070BA 721B                    	jc	short OpenE ; MSDOS 3.3
 34266                                  
 34267                                  ;	The SFT was successfully opened. Remove busy mark.
 34268                                  
 34269                                  OpenOK:
 34270                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 34271 000070BC C7040100                	mov	word [SI],1
 34272                                  	;or	[SI+5],cx
 34273 000070C0 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 34274                                  
 34275                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 34276                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 34277                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 34278                                  ;
 34279                                  ; Since this is only relevant on sharer systems, we stick this code into the
 34280                                  ; sharer.
 34281                                  
 34282 000070C3 36A1[4405]              	MOV	AX,[ss:JFN]				;smr;SS Override
 34283 000070C7 36FF1E[8C00]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 34284                                  
 34285 000070CC 36C706[4205]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 34286 000070D3 E927A6                  	jmp	SYS_RET_OK		; bye with no errors
 34287                                  
 34288                                  	; MSDOS 6.0
 34289                                  ;Extended Open hooks check
 34290                                  ;OpenE2:					;AN000;;EO.
 34291                                  ;	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 34292                                  ;	JNZ	short OpenE		;AN000;;EO. no.
 34293                                  ;	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 34294                                  
 34295                                  ;	Extended Open hooks check
 34296                                  ;
 34297                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 34298                                  
 34299                                  OpenClean:
 34300 000070D6 5B                      	pop	bx			; clean off stack
 34301                                  OpenE:
 34302                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 34303 000070D7 C7040000                	mov	word [SI],0
 34304 000070DB 36C536[4605]            	LDS	SI,[ss:PJFN]				;smr;SS Override
 34305 000070E0 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 34306 000070E3 EB02                    	JMP	SHORT OpenCritLeave
 34307                                  
 34308                                  OpenFail:
 34309 000070E5 FB                      	STI
 34310 000070E6 59                      	pop	cx			; Clean stack
 34311                                  OpenCritLeave:
 34312 000070E7 36C706[4205]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 34313                                  
 34314                                  	; MSDOS 6.0
 34315                                  ;; File Tagging DOS 4.00
 34316                                  ;	CMP	[SS:EXTERR],error_Code_Page_Mismatched 
 34317                                  ;				;AN000;;FT. code page mismatch;smr;SS Override
 34318                                  ;	JNZ	short NORERR	  	;AN000;;FT. no
 34319                                  ;	jmp	From_GetSet		;AN000;;FT. yes
 34320                                  ;NORERR: 				;AN000;
 34321                                  ;; File Tagging DOS 4.00
 34322                                  
 34323 000070EE E915A6                  	jmp	SYS_RET_ERR		; no free, return error
 34324                                  
 34325                                  ; MSDOS 2.11
 34326                                  ;BREAK <$CREAT - creat a new file and open him for input>
 34327                                  ;----------------------------------------------------------------------------
 34328                                  ;   Assembler usage:
 34329                                  ;           LDS     DX, name
 34330                                  ;           MOV     AH, Creat
 34331                                  ;           MOV     CX, access
 34332                                  ;           INT     21h
 34333                                  ;       ; AX now has the handle
 34334                                  ;
 34335                                  ;   Error returns:
 34336                                  ;           AX = error_access_denied
 34337                                  ;              = error_path_not_found
 34338                                  ;              = error_too_many_open_files
 34339                                  ;----------------------------------------------------------------------------
 34340                                  
 34341                                  ; MSDOS 6.0
 34342                                  ;	BREAK <$Creat - create a brand-new file>
 34343                                  ;----------------------------------------------------------------------------
 34344                                  ;
 34345                                  ;**	$Creat - Create a File
 34346                                  ;
 34347                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 34348                                  ;	initial attributes contained in CX
 34349                                  ;
 34350                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 34351                                  ;		(CX) = initial attributes
 34352                                  ;	EXIT	'C' set if error
 34353                                  ;		  (ax) = error code
 34354                                  ;		'C' clear if OK
 34355                                  ;		  (ax) = file handle
 34356                                  ;	USES	all
 34357                                  ;
 34358                                  ;----------------------------------------------------------------------------
 34359                                  
 34360                                  _$CREAT:
 34361 000070F1 51                      	push	cx			; Save attributes on stack
 34362 000070F2 B9[E436]                	mov	CX,DOS_CREATE		; routine to call
 34363                                  AccessSet:
 34364                                  	;mov	byte [ss:SATTRIB],6
 34365 000070F5 36C606[0805]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 34366                                  	; 10/08/2018
 34367 000070FB E944FF                  	JMP	AccessFile		; use good ol' open
 34368                                  
 34369                                  
 34370                                  ; MSDOS 6.0 (MSDOS 3.3)
 34371                                  ;	BREAK <$CHMOD - change file attributes>
 34372                                  ;----------------------------------------------------------------------------
 34373                                  ;
 34374                                  ;**	$CHMOD - Change File Attributes
 34375                                  ;
 34376                                  ;   Assembler usage:
 34377                                  ;	    LDS     DX, name
 34378                                  ;	    MOV     CX, attributes
 34379                                  ;	    MOV     AL,func (0=get, 1=set)
 34380                                  ;	    INT     21h
 34381                                  ;   Error returns:
 34382                                  ;	    AX = error_path_not_found
 34383                                  ;	    AX = error_access_denied
 34384                                  ;
 34385                                  ;----------------------------------------------------------------------------
 34386                                  
 34387                                  _$CHMOD:
 34388                                  	; 05/08/2018 - Retro DOS v3.0
 34389                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 34390 000070FE BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 34391 00007101 50                      	push	ax
 34392 00007102 51                      	push	cx			; save function and attributes
 34393 00007103 89D6                    	MOV	SI,DX			; get things in appropriate places
 34394 00007105 E84BF9                  	call	TransPathSet		; get correct path
 34395 00007108 59                      	pop	cx
 34396 00007109 58                      	pop	ax			; and get function and attrs back
 34397 0000710A 7235                    	JC	short ChModErr		; errors get mapped to path not found
 34398 0000710C 16                      	push	ss			; set up for later possible calls
 34399 0000710D 1F                      	pop	ds
 34400 0000710E 803E[1505]FF            	CMP	byte [CMETA],-1
 34401 00007113 752C                    	JNZ	short ChModErr
 34402                                  	;mov	byte [SATTRIB],16h
 34403 00007115 C606[0805]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 34404 0000711A 2C01                    	SUB	AL,1			; fast way to discriminate
 34405 0000711C 720B                    	JB	short ChModGet		; 0 -> go get value
 34406 0000711E 7417                    	JZ	short ChModSet		; 1 -> go set value
 34407                                  	;mov	byte [EXTERR_LOCUS],1
 34408 00007120 C606[D102]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 34409                                  	;mov	al,1
 34410 00007125 B001                    	mov	al,error_invalid_function ; bad value
 34411                                  	;jmp	SYS_RET_ERR
 34412 00007127 EB1A                    	jmp	short ChModE	
 34413                                  ChModGet:
 34414 00007129 E8BFC4                  	call	GET_FILE_INFO		; suck out the ol' info
 34415 0000712C 7215                    	JC	short ChModE		; error codes are already set for ret
 34416 0000712E E8DAA4                  	call	Get_User_Stack		; point to user saved vaiables
 34417                                  	;mov	[SI+4],ax
 34418 00007131 894404                  	MOV	[SI+user_env.user_CX],AX  ; return the attributes
 34419                                  	;jmp	SYS_RET_OK		; say sayonara
 34420                                  	; 26/07/2019
 34421 00007134 E9C9A5                  	jmp	SYS_RET_OK_clc
 34422                                  ChModSet:
 34423 00007137 89C8                    	MOV	AX,CX			; get attrs in position
 34424 00007139 E810C5                  	call	SET_FILE_ATTRIBUTE	; go set
 34425 0000713C 7205                    	JC	short ChModE		; errors are set
 34426 0000713E E9BCA5                  	jmp	SYS_RET_OK
 34427                                  ChModErr:
 34428                                  	;mov	al, 3
 34429 00007141 B003                    	mov	al,error_path_not_found
 34430                                  ChModE:
 34431 00007143 E9C0A5                  	jmp	SYS_RET_ERR
 34432                                  
 34433                                  ;	BREAK <$UNLINK - delete a file entry>
 34434                                  ;----------------------------------------------------------------------------
 34435                                  ;
 34436                                  ;**	$UNLINK - Delete a File
 34437                                  ;
 34438                                  ;
 34439                                  ;	Assembler usage:
 34440                                  ;	    LDS     DX, name
 34441                                  ;	    IF VIA SERVER DOS CALL
 34442                                  ;	     MOV     CX,SEARCH_ATTRIB
 34443                                  ;	    MOV     AH, Unlink
 34444                                  ;	    INT     21h
 34445                                  ;
 34446                                  ;	ENTRY	(ds:dx) = path name
 34447                                  ;		(cx) = search_attribute, if via server_dos
 34448                                  ;	EXIT	'C' clear if no error
 34449                                  ;		'C' set if error
 34450                                  ;		  (ax) = error code
 34451                                  ;			= error_file_not_found
 34452                                  ;			= error_access_denied
 34453                                  ;
 34454                                  ;----------------------------------------------------------------------------
 34455                                  
 34456                                  _$UNLINK:
 34457 00007146 51                      	push	cx			; Save possible CX input parm
 34458 00007147 89D6                    	MOV	SI,DX			; Point at input string
 34459 00007149 BF[6003]                	MOV	DI,OPENBUF		; temp spot for path
 34460 0000714C E804F9                  	call	TransPathSet		; go get normalized path
 34461 0000714F 59                      	pop	cx
 34462 00007150 72EF                    	JC	short ChModErr		; badly formed path
 34463 00007152 36803E[1505]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 34464 00007158 750F                    	JNZ	short NotFound
 34465 0000715A 16                      	push	ss
 34466 0000715B 1F                      	pop	ds
 34467                                  	;mov	ch,6
 34468 0000715C B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 34469 0000715E E82201                  	call	SetAttrib
 34470 00007161 E804C1                  	call	DOS_DELETE		; remove that file
 34471 00007164 7205                    	JC	short UnlinkE 		; error is there
 34472 00007166 E994A5                  	jmp	SYS_RET_OK		; okey doksy
 34473                                  NotFound:
 34474                                  	;mov	al, 3
 34475 00007169 B003                    	MOV	AL,error_path_not_found
 34476                                  UnlinkE:
 34477 0000716B E998A5                  	jmp	SYS_RET_ERR		; bye
 34478                                  
 34479                                  ;BREAK <$RENAME - move directory entries around>
 34480                                  ;----------------------------------------------------------------------------
 34481                                  ;
 34482                                  ;   Assembler usage:
 34483                                  ;	    LDS     DX, source
 34484                                  ;	    LES     DI, dest
 34485                                  ;	    IF VIA SERVER DOS CALL
 34486                                  ;	     MOV     CX,SEARCH_ATTRIB
 34487                                  ;	    MOV     AH, Rename
 34488                                  ;	    INT     21h
 34489                                  ;
 34490                                  ;   Error returns:
 34491                                  ;	    AX = error_file_not_found
 34492                                  ;	       = error_not_same_device
 34493                                  ;	       = error_access_denied
 34494                                  ;
 34495                                  ;----------------------------------------------------------------------------
 34496                                  
 34497                                  _$RENAME:
 34498                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34499 0000716E 51                      	push	cx
 34500 0000716F 1E                      	push	ds
 34501 00007170 52                      	push	dx			; save source and possible CX arg
 34502 00007171 06                      	PUSH	ES
 34503 00007172 1F                      	POP	DS			; move dest to source
 34504 00007173 89FE                    	MOV	SI,DI			; save for offsets
 34505 00007175 BF[E003]                	MOV	DI,RENBUF
 34506 00007178 E8D8F8                  	call	TransPathSet		; munge the paths
 34507 0000717B 36FF36[4A05]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 34508 00007180 368F06[4C05]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 34509 00007185 5E                      	pop	si
 34510 00007186 1F                      	pop	ds
 34511 00007187 59                      	pop	cx			; get back source and possible CX arg
 34512                                  epjc2:	
 34513 00007188 72B7                    	JC	short ChModErr		; get old error
 34514 0000718A 36803E[1505]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 34515 00007190 75D7                    	JNZ	short NotFound
 34516 00007192 51                      	push	cx			; Save possible CX arg
 34517 00007193 BF[6003]                	MOV	DI,OPENBUF		; appropriate buffer
 34518 00007196 E8BAF8                  	call	TransPathSet		; wham
 34519 00007199 59                      	pop	cx
 34520 0000719A 72EC                    	JC	short epjc2
 34521 0000719C 16                      	push	ss
 34522 0000719D 1F                      	pop	ds
 34523 0000719E 803E[1505]FF            	CMP	byte [CMETA],-1
 34524 000071A3 72C4                    	JB	short NotFound
 34525                                  
 34526                                  	; MSDOS 6.0
 34527 000071A5 FF36[3A05]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 34528 000071A9 FF36[3C05]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 34529 000071AD BF[6003]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 34530 000071B0 16                      	PUSH	SS			   ;AN000;;MS.
 34531 000071B1 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 34532 000071B2 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 34533                                  rnloop: 				   ;AN000;
 34534 000071B4 E810F8                  	call	GetCDSFromDrv		   ;AN000;;MS.
 34535 000071B7 7211                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 34536 000071B9 E86FAD                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 34537 000071BC 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 34538 000071BE FEC0                    	INC	AL			   ;AN000;;MS.	next
 34539 000071C0 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 34540                                  rnerr:					   ;AN000;
 34541 000071C2 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 34542                                  	;error	error_current_directory    ;AN000;;MS.
 34543 000071C5 B010                    	mov	al,error_current_directory 
 34544 000071C7 E93CA5                  	jmp	SYS_RET_ERR
 34545                                  dorn:					   ;AN000;
 34546 000071CA 368F06[3C05]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 34547 000071CF 368F06[3A05]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 34548                                  
 34549 000071D4 16                      	push	ss
 34550 000071D5 1F                      	pop	ds
 34551                                  
 34552                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34553                                  	;mov	ch,16h
 34554 000071D6 B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 34555                                  					; rename appropriate files
 34556 000071D8 E8A800                  	call	SetAttrib
 34557 000071DB E835C2                  	call	DOS_RENAME		; do the deed
 34558 000071DE 728B                    	JC	short UnlinkE 		; errors
 34559                                  
 34560 000071E0 E91AA5                  	jmp	SYS_RET_OK
 34561                                  
 34562                                  
 34563                                  ; 14/07/2018 - Retro DOS v3.0
 34564                                  ; MSDOS 3.3 (& MSDOS 6.0)
 34565                                  
 34566                                  ;Break <$CreateNewFile - Create a new directory entry>
 34567                                  ;----------------------------------------------------------------------------
 34568                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 34569                                  ;	was no previous directory entry, and fail if a directory entry with
 34570                                  ;	the same name existed previously.
 34571                                  ;
 34572                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 34573                                  ;		CX contains default file attributes
 34574                                  ;   Outputs:	Carry Clear:
 34575                                  ;		    AX has file handle opened for read/write
 34576                                  ;		Carry Set:
 34577                                  ;		    AX has error code
 34578                                  ;   Registers modified: All
 34579                                  ;----------------------------------------------------------------------------
 34580                                  
 34581                                  _$CreateNewFile:
 34582 000071E3 51                      	push	cx			; Save attributes on stack
 34583 000071E4 B9[7537]                	MOV	CX,DOS_Create_New	; routine to call
 34584 000071E7 E90BFF                  	JMP	AccessSet		; use good ol' open
 34585                                  
 34586                                  ;**	BinToAscii - convert a number to a string.
 34587                                  ;----------------------------------------------------------------------------
 34588                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 34589                                  ;	This routine is used to generate temp file names so we don't spend
 34590                                  ;	the time and code needed for a true hex number, we just use
 34591                                  ;	A thorugh O.
 34592                                  ;
 34593                                  ;	ENTRY	(ax) = value
 34594                                  ;		(es:di) = destination
 34595                                  ;	EXIT	(es:di) updated by 4
 34596                                  ;	USES	cx, di, flags
 34597                                  ;----------------------------------------------------------------------------
 34598                                  
 34599                                  ; MSDOS 3.3
 34600                                  ;BinToAscii:
 34601                                  ;	mov     cx,4
 34602                                  ;bta5:
 34603                                  ;	push    cx
 34604                                  ;	mov     cl,4
 34605                                  ;	rol     ax,cl
 34606                                  ;	push    ax
 34607                                  ;	and     al,0Fh
 34608                                  ;	add     al,'0'
 34609                                  ;	cmp     al,'9'
 34610                                  ;	jbe     short bta6
 34611                                  ;	add     al,7
 34612                                  ;bta6: 
 34613                                  ;	stosb
 34614                                  ;	pop     ax
 34615                                  ;	pop     cx
 34616                                  ;	loop    bta5
 34617                                  ;	retn
 34618                                  
 34619                                  ; MSDOS 6.0
 34620                                  BinToAscii:
 34621 000071EA B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 34622                                  bta5:	
 34623 000071ED D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 34624 000071EF 50                      	push	ax			; preserve remainder of digits
 34625 000071F0 240F                    	AND	AL,0Fh			; grab low nibble
 34626 000071F2 0441                    	ADD	AL,'A'			; turn into ascii
 34627 000071F4 AA                      	STOSB				; drop in the character
 34628 000071F5 58                      	pop	ax			; (ax) = shifted number
 34629 000071F6 FECD                    	dec	ch
 34630 000071F8 75F3                    	jnz	short bta5		; process 4 digits
 34631 000071FA C3                      	retn
 34632                                  
 34633                                  ;Break	<$CreateTempFile - create a unique name>
 34634                                  ;----------------------------------------------------------------------------
 34635                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 34636                                  ;	Method used is to get the current time, convert to a name and attempt
 34637                                  ;	a create new.  Repeat until create new succeeds.
 34638                                  ;
 34639                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 34640                                  ;		CX  contains default attributes
 34641                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 34642                                  ;		AX has handle
 34643                                  ;   Registers modified: all
 34644                                  ;----------------------------------------------------------------------------
 34645                                  
 34646                                  _$CreateTempFile:
 34647                                  	;Enter
 34648 000071FB 55                      	push	bp
 34649 000071FC 89E5                    	mov	bp,sp
 34650                                  
 34651                                  	;LocalVar    EndPtr,DWORD
 34652                                  	;LocalVar    FilPtr,DWORD
 34653                                  	;LocalVar    Attr,WORD
 34654                                  
 34655 000071FE 83EC0A                  	sub	sp,10
 34656                                  
 34657                                  	;test	cx,0FFD8h
 34658 00007201 F7C1D8FF                	test	CX,~attr_changeable
 34659 00007205 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 34660                                  ;
 34661                                  ; We need this "hook" here to detect these cases (like user sets one both of
 34662                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 34663                                  ; below.  The code loops on error_access_denied, but if one of the non
 34664                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 34665                                  ; infinite because CreateNewFile will fail with access_denied always.  Thus we
 34666                                  ; need to detect these cases before getting to the loop.
 34667                                  ;
 34668                                  	;mov	ax, 5
 34669 00007207 B80500                  	MOV	AX,error_access_denied
 34670 0000720A EB6B                    	JMP	SHORT SETTMPERR
 34671                                  
 34672                                  OKatts:
 34673                                  	;MOV	attr,CX 		; save attribute
 34674 0000720C 894EF6                  	mov     [bp-10],cx
 34675                                  	;MOV	FilPtrL,DX		; pointer to file
 34676 0000720F 8956F8                  	mov	[bp-8],dx
 34677                                  	;MOV	FilPtrH,DS
 34678 00007212 8C5EFA                  	mov	[bp-6],ds
 34679                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 34680 00007215 8C5EFE                  	mov	[bp-2],ds
 34681 00007218 1E                      	PUSH	DS
 34682 00007219 07                      	POP	ES			; destination for nul search
 34683 0000721A 89D7                    	MOV	DI,DX
 34684 0000721C 89F9                    	MOV	CX,DI
 34685 0000721E F7D9                    	NEG	CX			; number of bytes remaining in segment
 34686                                  	; MSDOS 6.0
 34687 00007220 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 34688 00007222 7501                    	JNZ	short okok		;AN000;MS. no
 34689                                  	;MOV	CX,-1			;AN000;MS.
 34690 00007224 49                      	dec	cx  ; mov cx,-1
 34691                                  	;
 34692                                  okok:					;AN000;
 34693 00007225 31C0                    	XOR	AX,AX			;AN000;
 34694 00007227 F2AE                    	REPNZ	SCASB			;AN000;
 34695                                  					;AN000;
 34696 00007229 4F                      	DEC	DI			; point back to the null
 34697 0000722A 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 34698 0000722E E81AE4                  	call	PATHCHRCMP		; Is it a path separator?
 34699 00007231 7403                    	JZ	short SETENDPTR		; Yes
 34700                                  STOREPTH:
 34701 00007233 B05C                    	MOV	AL,'\'
 34702 00007235 AA                      	STOSB				; Add a path separator (and INC DI)
 34703                                  SETENDPTR:
 34704                                  	;MOV	EndPtrL,DI		; pointer to the tail
 34705 00007236 8856FC                  	mov	[bp-4],dl
 34706                                  CreateLoop:
 34707 00007239 16                      	push	ss			; let ReadTime see variables
 34708 0000723A 1F                      	pop	ds
 34709 0000723B 55                      	push	bp
 34710 0000723C E89EA6                  	call	READTIME		; go get time
 34711 0000723F 5D                      	pop	bp
 34712                                  ;
 34713                                  ; Time is in CX:DX.  Go drop it into the string.
 34714                                  ;
 34715                                  	;les	di,EndPtr		; point to the string
 34716 00007240 C47EFC                  	les	di,[BP-4]
 34717 00007243 89C8                    	mov	ax,cx
 34718 00007245 E8A2FF                  	call	BinToAscii		; store upper word
 34719 00007248 89D0                    	mov	ax,dx
 34720 0000724A E89DFF                  	call	BinToAscii		; store lower word
 34721 0000724D 30C0                    	xor	al,al
 34722 0000724F AA                      	STOSB				; nul terminate
 34723                                  	;LDS	DX,FilPtr		; get name
 34724 00007250 C556F8                  	lds	dx,[bp-8]
 34725                                  	;MOV	CX,Attr 		; get attr
 34726 00007253 8B4EF6                  	mov	cx,[bp-10]
 34727 00007256 55                      	push	bp
 34728 00007257 E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 34729 0000725A 5D                      	pop	bp
 34730 0000725B 731B                    	JNC	short CreateDone	; failed, go try again
 34731                                  ;
 34732                                  ; The operation failed and the error has been mapped in AX.  Grab the extended
 34733                                  ; error and figure out what to do.
 34734                                  ;
 34735                                  	;; MSDOS 3.3			; M049 - start
 34736                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 34737                                  ;;	cmp	al,error_file_exists
 34738                                  ;;	jz	short CreateLoop	; file existed => try with new name
 34739                                  ;;	cmp	al,error_access_denied
 34740                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 34741                                  
 34742                                  	; MSDOS 6.0
 34743                                  	;cmp	al,50h
 34744 0000725D 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 34745 0000725F 74D8                    	JZ	short CreateLoop	; Y: try again
 34746                                  	;cmp	al,5
 34747 00007261 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 34748 00007263 7512                    	JNZ	short SETTMPERR		; N: Error out
 34749                                  					; Y: Check to see if we got this due
 34750                                  					;    to the network drive. Note that
 34751                                  					;    the redir will set the exterr
 34752                                  					;    to error_cannot_make if this is 
 34753                                  					;    so. 
 34754 00007265 36803E[D202]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 34755                                  					; See if it's REALLY an att mismatch
 34756 0000726B 740A                    	je	short SETTMPERR		; no, network error, stop
 34757                                  ;M070
 34758                                  ; If the user failed on an I24, we do not want to try again
 34759                                  ;
 34760 0000726D 36803E[D202]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 34761 00007273 7402                    	je	short SETTMPERR		;yes, do not try again ;M070
 34762                                  
 34763 00007275 EBC2                    	jmp	short CreateLoop	;attr mismatch, try again ;M070
 34764                                  
 34765                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 34766                                  					; M049 - end
 34767                                  SETTMPERR:
 34768 00007277 F9                      	STC
 34769                                  CreateDone:
 34770                                  	;Leave
 34771 00007278 89EC                    	mov	sp,bp
 34772 0000727A 5D                      	pop	bp
 34773 0000727B 7203                    	JC	short CreateFail
 34774 0000727D E97DA4                  	jmp	SYS_RET_OK		; success!
 34775                                  CreateFail:
 34776 00007280 E983A4                  	jmp	SYS_RET_ERR
 34777                                  
 34778                                  ;
 34779                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 34780                                  ;   (CH) or to the value in CL if the current system call is through
 34781                                  ;   serverdoscall.
 34782                                  ;
 34783                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 34784                                  ;		fSharing == TRUE => set sattrib to CL
 34785                                  ;   Outputs:	none
 34786                                  ;   Registers changed:	CX
 34787                                  
 34788                                  SetAttrib:
 34789 00007283 36F606[0D05]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 34790 00007289 7502                    	jnz	short Set
 34791 0000728B 88E9                    	mov	cl,ch
 34792                                  Set:
 34793 0000728D 36880E[0805]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 34794 00007292 C3                      	retn
 34795                                  
 34796                                  ; 14/07/2018 - Retro DOS v3.0
 34797                                  ; MSDOS 6.0
 34798                                  
 34799                                  ;Break	<Extended_Open- Extended open the file>
 34800                                  ;----------------------------------------------------------------------------
 34801                                  ; Input: AL= 0 reserved  AH=6CH
 34802                                  ;	 BX= mode
 34803                                  ;	 CL= create attribute  CH=search attribute (from server)
 34804                                  ;	 DX= flag
 34805                                  ;	 DS:SI = file name
 34806                                  ;	 ES:DI = parm list
 34807                                  ;			   DD  SET EA list (-1) null
 34808                                  ;			   DW  n  parameters
 34809                                  ;			   DB  type (TTTTTTLL)
 34810                                  ;			   DW  IOMODE
 34811                                  ; Function: Extended Open
 34812                                  ; Output: carry clear
 34813                                  ;		     AX= handle
 34814                                  ;		     CX=1 file opened
 34815                                  ;			2 file created/opened
 34816                                  ;			3 file replaced/opened
 34817                                  ;	  carry set: AX has error code
 34818                                  ;----------------------------------------------------------------------------
 34819                                  
 34820                                  ;_$Extended_Open:			  ;AN000;
 34821                                  ;	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 34822                                  ;	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 34823                                  ;	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 34824                                  ;	TEST	DX,reserved_bits_mask	  ;AN000;EO. reserved bits 0  ?
 34825                                  ;	JNZ	short ext_inval2	  ;AN000;EO. no
 34826                                  ;	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 34827                                  ;	CMP	DL,0			  ;AN000;EO. all fail ?
 34828                                  ;	JZ	short ext_inval2	  ;AN000;EO. yes, error
 34829                                  ;	AND	DL,exists_mask		  ;AN000;EO. get exists action byte
 34830                                  ;	CMP	DL,2			  ;AN000;EO, > 02
 34831                                  ;	JA	short ext_inval2	  ;AN000;EO. yes ,error
 34832                                  ;	AND	AH,not_exists_mask	  ;AN000;EO. get no exists action byte
 34833                                  ;	CMP	AH,10H			  ;AN000;EO. > 10
 34834                                  ;	JA	short ext_inval2	  ;AN000;EO. yes error
 34835                                  ;
 34836                                  ;	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 34837                                  ;	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 34838                                  ;	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 34839                                  ;	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 34840                                  ;	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 34841                                  ;	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 34842                                  ;	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 34843                                  ;	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 34844                                  ;	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 34845                                  ;	MOV	AX,BX			  ;AN000;EO. ax= mode
 34846                                  ;	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 34847                                  ;ext_inval2:				  ;AN000;;EO.
 34848                                  ;	mov	al,error_invalid_function ;AN000;EO.. invalid function
 34849                                  ;	jmp	SYS_RET_ERR
 34850                                  ;error_return:				  ;AN000;EO.
 34851                                  ;	retn				  ;AN000;EO.. return with error
 34852                                  ;goopen2:				  ;AN000;
 34853                                  ;	TEST	BX,int_24_error 	  ;AN000;EO.. disable INT 24 error ?
 34854                                  ;	JZ	short goopen		  ;AN000;EO.. no
 34855                                  ;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 34856                                  ;goopen:					  ;AN000;
 34857                                  ;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 34858                                  ;	AND	word [SS:EXTOPEN_FLAG],0FFH  ;AN000;EO.create new ?;smr;SS Override
 34859                                  ;	CMP	word [SS:EXTOPEN_FLAG],ext_exists_fail + ext_nexists_create ;AN000;FT.;smr;SS Override
 34860                                  ;	JNZ	short chknext 		  ;AN000;;EO. no
 34861                                  ;	call	_$CreateNewFile		  ;AN000;;EO. yes
 34862                                  ;	JC	short error_return	  ;AN000;;EO. error
 34863                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 34864                                  ;	JZ	short ok_return2	  ;AN000;;EO. yes
 34865                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. creted/opened;smr;SS Override
 34866                                  ;	JMP	short setXAttr		  ;AN000;;EO. set XAs
 34867                                  ;ok_return2:
 34868                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 34869                                  ;chknext:
 34870                                  ;	TEST	word [SS:EXTOPEN_FLAG],ext_exists_open ;AN000;;EO. exists open;smr;SS Override
 34871                                  ;	JNZ	short exist_open	  ;AN000;;EO. yes
 34872                                  ;	call	_$CREAT			  ;AN000;;EO. must be replace open
 34873                                  ;	JC	short error_return	  ;AN000;;EO. return with error
 34874                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 34875                                  ;	JZ	short ok_return2	  ;AN000;;EO. yes
 34876                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. prsume create/open;smr;SS Override
 34877                                  ;	TEST	byte [SS:EXTOPEN_ON],ext_file_not_exists ;AN000;;EO. file not exists ?;smr;SS Override
 34878                                  ;	JNZ	short setXAttr		  ;AN000;;EO. no
 34879                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_replaced_opened ;AN000;;EO. replaced/opened;smr;SS Override
 34880                                  ;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 34881                                  ;error_return2:
 34882                                  ;	STC 				  ; Set Carry again to flag error ;AN001;
 34883                                  ;	retn				  ;AN000;;EO. return with error
 34884                                  ;					  ;AN000;
 34885                                  ;exist_open:				  ;AN000;
 34886                                  ;	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 34887                                  ;	jz	short noserver		  ;AN000;;EO. no
 34888                                  ;	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 34889                                  ;noserver:
 34890                                  ;	call	_$Open2			  ;AN000;;EO. do open
 34891                                  ;	JNC	short ext_ok		  ;AN000;;EO.
 34892                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 34893                                  ;	JZ	short error_return2	  ;AN000;;EO. return with error
 34894                                  ;local_extopen:
 34895                                  ;	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 34896                                  ;	JNZ	short error_return2	  ;AN000;;EO. no,
 34897                                  ;	TEST	word [SS:EXTOPEN_FLAG],ext_nexists_create;AN000;;EO. want to fail;smr;SS Override
 34898                                  ;	JNZ	short do_creat		  ;AN000;;EO. yes
 34899                                  ;	JMP	short extexit 		  ;AN000;;EO. yes
 34900                                  ;do_creat:
 34901                                  ;	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 34902                                  ;	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 34903                                  ;	MOV	DX,SI			  ;AN000;;EO.
 34904                                  ;	call	_$CREAT			  ;AN000;;EO. do create
 34905                                  ;	JC	short extexit 		  ;AN000;;EO. error
 34906                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened 
 34907                                  ;					  ;AN000;;EO. is created/opened;smr;SS Override
 34908                                  ;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 34909                                  ;
 34910                                  ;ext_ok:
 34911                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 34912                                  ;	JZ	short ok_return		  ;AN000;;EO. yes
 34913                                  ;	MOV	[SS:EXTOPEN_FLAG],action_opened ;AN000;;EO.  opened;smr;SS Override
 34914                                  ;setXAttr:
 34915                                  ;	call	Get_User_Stack		  ;AN000;;EO.
 34916                                  ;	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 34917                                  ;	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 34918                                  ;	POP	AX			  ;AN000;;EO.
 34919                                  ;	MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 34920                                  ;
 34921                                  ;ok_return:				  ;AN000;
 34922                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 34923                                  ;
 34924                                  ;extexit2:				  ;AN000; ERROR RECOVERY
 34925                                  ;	POP	BX			  ;AN000;EO. close the handle
 34926                                  ;	PUSH	AX			  ;AN000;EO. save error code from set XA
 34927                                  ;	CMP	word [SS:EXTOPEN_FLAG],action_created_opened 
 34928                                  ;					  ;AN000;EO. from create;smr;SS Override
 34929                                  ;	JNZ	short justopen		  ;AN000;EO.
 34930                                  ;	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 34931                                  ;	LDS	DX,[SI]			  ;AN000;EO.
 34932                                  ;	call	_$UNLINK 		  ;AN000;EO. delete the file
 34933                                  ;	JMP	SHORT reserror		  ;AN000;EO.
 34934                                  ;
 34935                                  ;justopen:				  ;AN000;
 34936                                  ;	call	$CLOSE			  ;AN000;EO. pretend never happend
 34937                                  ;reserror:				  ;AN000;
 34938                                  ;	POP	AX			  ;AN000;EO. restore error code from set XA
 34939                                  ;	JMP	SHORT extexit		  ;AN000;EO.
 34940                                  ;
 34941                                  ;ext_file_unfound:			  ;AN000;
 34942                                  ;	MOV	AX,error_file_not_found   ;AN000;EO.
 34943                                  ;	JMP	SHORT extexit		  ;AN000;EO.
 34944                                  ;ext_inval:				  ;AN000;
 34945                                  ;	MOV	AX,error_invalid_function ;AN000;EO.
 34946                                  ;extexit:
 34947                                  ;	jmp	SYS_RET_ERR		  ;AN000;EO.
 34948                                  
 34949                                  ;============================================================================
 34950                                  ; LOCK.ASM, MSDOS 6.0, 1991
 34951                                  ;============================================================================
 34952                                  ; 14/07/2018 - Retro DOS v3.0
 34953                                  
 34954                                  ;BREAK <$LockOper - Lock Calls>
 34955                                  
 34956                                  ;
 34957                                  ;   Assembler usage:
 34958                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 34959                                  ;	    MOV     CX, OffsetHigh
 34960                                  ;	    MOV     DX, OffsetLow
 34961                                  ;	    MOV     SI, LengthHigh
 34962                                  ;	    MOV     DI, LengthLow
 34963                                  ;	    MOV     AH, LockOper
 34964                                  ;	    MOV     AL, Request
 34965                                  ;	    INT     21h
 34966                                  ;
 34967                                  ;   Error returns:
 34968                                  ;	    AX = error_invalid_handle
 34969                                  ;	       = error_invalid_function
 34970                                  ;	       = error_lock_violation
 34971                                  ;
 34972                                  ;   Assembler usage:
 34973                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 34974                                  ;
 34975                                  ;				    0? lock all
 34976                                  ;				    8? lock write
 34977                                  ;				    ?2 lock multiple
 34978                                  ;				    ?3 unlock multiple
 34979                                  ;				    ?4 lock/read
 34980                                  ;				    ?5 write/unlock
 34981                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 34982                                  ;	    MOV     BX, Handle
 34983                                  ;	    MOV     CX, count or size
 34984                                  ;	    LDS     DX, buffer
 34985                                  ;	    INT     21h
 34986                                  ;
 34987                                  ;   Error returns:
 34988                                  ;	    AX = error_invalid_handle
 34989                                  ;	       = error_invalid_function
 34990                                  ;	       = error_lock_violation
 34991                                  
 34992                                  _$LockOper:
 34993 00007293 3C01                    	CMP	AL,1
 34994 00007295 770C                    	JA	short lock_bad_func
 34995                                  
 34996 00007297 57                      	PUSH	DI			       ; Save LengthLow
 34997 00007298 E864F5                  	call	SFFromHandle		       ; ES:DI -> SFT
 34998 0000729B 7311                    	JNC	short lock_do 		       ; have valid handle
 34999 0000729D 5F                      	POP	DI			       ; Clean stack
 35000                                  	;mov	al,6
 35001 0000729E B006                    	mov	al,error_invalid_handle
 35002 000072A0 E963A4                  	jmp	SYS_RET_ERR
 35003                                  
 35004                                  lock_bad_func:
 35005                                  	;mov	byte [ss:EXTERR_LOCUS],1
 35006 000072A3 36C606[D102]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 35007                                  	;mov	al,1
 35008 000072A9 B001                    	mov	al,error_invalid_function
 35009 000072AB E958A4                  	jmp	SYS_RET_ERR
 35010                                  
 35011                                  	; MSDOS 6.0 
 35012                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 35013                                  ; Dead code deleted, MD, 23 Mar 90
 35014                                  
 35015                                  lock_do:
 35016                                  	; MSDOS 3.3
 35017 000072AE 08C0                    	or	al,al
 35018 000072B0 58                      	pop	ax
 35019 000072B1 741E                    	jz	short DOS_Lock
 35020                                  DOS_Unlock:
 35021                                   	;test	word [es:di+5],8000h
 35022 000072B3 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 35023 000072B9 7409                    	JZ	short LOCAL_UNLOCK
 35024 000072BB 50                      	push    ax
 35025 000072BC B80B11                  	mov     ax,110Bh
 35026 000072BF CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 35027                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 35028                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 35029                                  			; SFT DPB field -> DPB of drive containing file
 35030                                  			; Return: CF set error
 35031 000072C1 5B                      	pop     bx
 35032 000072C2 EB05                    	jmp     short ValChk
 35033                                  
 35034                                  LOCAL_UNLOCK:
 35035 000072C4 36FF1E[7800]            	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 35036                                  ValChk:
 35037 000072C9 7303                    	JNC	short Lock_OK
 35038                                  lockerror:
 35039 000072CB E938A4                  	jmp	SYS_RET_ERR
 35040                                  Lock_OK:
 35041                                  	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 35042 000072CE E92CA4                  	jmp	SYS_RET_OK
 35043                                  DOS_Lock:
 35044                                  	;test	word [es:di+5],8000h
 35045 000072D1 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 35046 000072D7 7407                    	JZ	short LOCAL_LOCK
 35047                                  	;CallInstall NET_XLock,MultNET,10
 35048 000072D9 B80A11                  	mov     ax, 110Ah
 35049 000072DC CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 35050                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 35051                                  			; STACK: WORD low word of size, ES:DI -> SFT
 35052                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 35053                                  			; Return: CF set error
 35054 000072DE EBE9                    	JMP	short ValChk
 35055                                  
 35056                                  LOCAL_LOCK:
 35057 000072E0 36FF1E[7400]            	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 35058 000072E5 EBE2                    	JMP	short ValChk
 35059                                  
 35060                                  ;lock_do:
 35061                                  ;	; MSDOS 6.0
 35062                                  ;	MOV	BX,AX				; save AX
 35063                                  ;	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 35064                                  ;	MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 35065                                  ;	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 35066                                  ;	POP	CX				; get low length
 35067                                  ;	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 35068                                  ;	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 35069                                  ;	MOV	CX,1				; one range
 35070                                  ;
 35071                                  ;;	PUSH	CS				;
 35072                                  ;;	POP	DS				; DS:DX points to
 35073                                  ;
 35074                                  ;	push	ss
 35075                                  ;	pop	ds
 35076                                  ;
 35077                                  ;	MOV	DX,BP				;   Lock_Buffer
 35078                                  ;	TEST	AL,Unlock_all			; function 1
 35079                                  ;	JNZ	short DOS_Unlock		; yes
 35080                                  ;	JMP	short DOS_Lock			; function 0
 35081                                  ;
 35082                                  ;DOS_Unlock:
 35083                                  ;	;test	word [es:di+5],8000h
 35084                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 35085                                  ;	JZ	short LOCAL_UNLOCK
 35086                                  ;	;CallInstall Net_Xlock,MultNET,10
 35087                                  ;	mov     ax, 110Bh
 35088                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 35089                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 35090                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 35091                                  ;			; SFT DPB field -> DPB of drive containing file
 35092                                  ;			; Return: CF set error
 35093                                  ;
 35094                                  ;	JMP	SHORT ValChk
 35095                                  ;LOCAL_UNLOCK:
 35096                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 35097                                  ;ValChk:
 35098                                  ;	JNC	short Lock_OK
 35099                                  ;lockerror:
 35100                                  ;	jmp	SYS_RET_ERR
 35101                                  ;Lock_OK:
 35102                                  ;	MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 35103                                  ;	jmp	SYS_RET_OK
 35104                                  ;DOS_Lock:
 35105                                  ;	;test	word [es:di+5],8000h
 35106                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 35107                                  ;	JZ	short LOCAL_LOCK
 35108                                  ;	;CallInstall NET_XLock,MultNET,10
 35109                                  ;	mov     ax,110Ah
 35110                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 35111                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 35112                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 35113                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 35114                                  ;			; Return: CF set error
 35115                                  ;	JMP	short ValChk
 35116                                  ;
 35117                                  ;LOCAL_LOCK:
 35118                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 35119                                  ;	JMP	short ValChk
 35120                                  
 35121                                  ; 14/07/2018 - Retro DOS v3.0
 35122                                  ; LOC_CHECK
 35123                                  ;MSDOS6.0 (& MSDOS3.3)
 35124                                  
 35125                                  ; Inputs:
 35126                                  ;	Outputs of SETUP
 35127                                  ;	[USER_ID] Set
 35128                                  ;	[PROC_ID] Set
 35129                                  ; Function:
 35130                                  ;	Check for lock violations on local I/O
 35131                                  ;	Retries are attempted with sleeps in between
 35132                                  ; Outputs:
 35133                                  ;    Carry clear
 35134                                  ;	Operation is OK
 35135                                  ;    Carry set
 35136                                  ;	A lock violation detected
 35137                                  ; Outputs of SETUP preserved
 35138                                  
 35139                                  LOCK_CHECK:
 35140 000072E7 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 35141                                  LockRetry:
 35142                                  	; 26/07/2019
 35143 000072EB 53                      	push	bx		; save regs
 35144                                  	;push	ax ; MSDOS 6.0
 35145                                  	; MSDOS 3.3 (& msdos 6.0)
 35146 000072EC FF1E[7C00]              	Call	far [JShare+(8*4)] ; 8 = chk_block
 35147                                  	;pop	ax ; MSDOS 6.0
 35148 000072F0 5B                      	pop	bx		; restrore regs
 35149 000072F1 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 35150                                  LockN:
 35151 000072F3 E88AAC                  	call	Idle		; wait a while
 35152 000072F6 4B                      	DEC	BX		; remember a retry
 35153 000072F7 75F2                    	JNZ	short LockRetry	; more retries left...
 35154 000072F9 F9                      	STC
 35155                                  lc_ret_label:
 35156 000072FA C3                      	retn
 35157                                  
 35158                                  ; 14/07/2018 - Retro DOS v3.0
 35159                                  ; LOCK_VIOLATION
 35160                                  ;MSDOS6.0 (& MSDOS3.3)
 35161                                  
 35162                                  ; Inputs:
 35163                                  ;	[THISDPB] set
 35164                                  ;	[READOP] indicates whether error on read or write
 35165                                  ; Function:
 35166                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 35167                                  ; Outputs:
 35168                                  ;	Carry set if user says FAIL, causes error_lock_violation
 35169                                  ;	Carry clear if user wants a retry
 35170                                  ;
 35171                                  ; DS, ES, DI, CX preserved, others destroyed
 35172                                  
 35173                                  LOCK_VIOLATION:
 35174 000072FB 1E                      	PUSH	DS
 35175 000072FC 06                      	PUSH	ES
 35176 000072FD 57                      	PUSH	DI
 35177 000072FE 51                      	PUSH	CX
 35178                                  	;mov	ax,21h
 35179 000072FF B82100                  	MOV	AX,error_lock_violation
 35180                                  	;mov	byte [ALLOWED],18h
 35181 00007302 C606[F702]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 35182 00007307 C42E[2405]              	LES	BP,[THISDPB]
 35183 0000730B BF0100                  	MOV	DI,1		; Fake some registers
 35184 0000730E 89F9                    	MOV	CX,DI
 35185                                  	;mov	dx,[es:bp+11]
 35186 00007310 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 35187 00007314 E834E5                  	call	HARDERR
 35188 00007317 59                      	POP	CX
 35189 00007318 5F                      	POP	DI
 35190 00007319 07                      	POP	ES
 35191 0000731A 1F                      	POP	DS
 35192 0000731B 3C01                    	CMP	AL,1
 35193 0000731D 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 35194 0000731F F9                      	STC
 35195 00007320 C3                      	retn
 35196                                  
 35197                                  ; 14/07/2018 - Retro DOS v3.0
 35198                                  
 35199                                  ;	do a retz to return error
 35200                                  
 35201                                  CheckShare:
 35202                                  	; MSDOS 6.0
 35203                                  	;push	ds			;smr;
 35204                                  	;;getdseg <ds>			; ds -> dosdata
 35205                                  	;push	cs
 35206                                  	;pop	ds
 35207                                  	;CMP	byte [fShare],0
 35208                                  	;pop	ds			;smr;
 35209                                  	;retn
 35210                                  	
 35211                                  	; MSDOS 3.3
 35212 00007321 2E803E[B102]00          	cmp	byte [cs:fShare],0
 35213 00007327 C3                      	retn
 35214                                  
 35215                                  ;============================================================================
 35216                                  ; SHARE.ASM, MSDOS 6.0, 1991
 35217                                  ;============================================================================
 35218                                  ; 14/07/2018 - Retro DOS v3.0
 35219                                  
 35220                                  ; SHARE_CHECK
 35221                                  
 35222                                  ; Inputs:
 35223                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 35224                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 35225                                  ;       [WFP_START] has full path of name
 35226                                  ;       [USER_ID] Set
 35227                                  ;       [PROC_ID] Set
 35228                                  ; Function:
 35229                                  ;       Check for sharing violations on local file/device access
 35230                                  ; Outputs:
 35231                                  ;    Carry clear
 35232                                  ;       Sharing approved
 35233                                  ;    Carry set
 35234                                  ;       A sharing violation detected
 35235                                  ;           AX is error code
 35236                                  ; USES    ALL but DS
 35237                                  
 35238                                  SHARE_CHECK:
 35239                                  	; 26/07/2019
 35240 00007328 FF1E[6000]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 35241                                  shchk_retn:
 35242 0000732C C3                      	retn
 35243                                  
 35244                                  ; SHARE_VIOLATION
 35245                                  
 35246                                  ; Inputs:
 35247                                  ;       [THISDPB] Set
 35248                                  ;       AX has error code
 35249                                  ; Function:
 35250                                  ;       Handle Sharing errors
 35251                                  ; Outputs:
 35252                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 35253                                  ;       Carry clear if user wants a retry
 35254                                  ;
 35255                                  ; DS, ES, DI preserved, others destroyed
 35256                                  
 35257                                  SHARE_VIOLATION:
 35258 0000732D 1E                      	PUSH    DS
 35259 0000732E 06                      	PUSH	ES
 35260 0000732F 57                      	PUSH    DI
 35261 00007330 C606[1005]00            	MOV     byte [READOP],0		; All share errors are reading
 35262                                  	;mov	byte [ALLOWED],18h
 35263 00007335 C606[F702]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 35264 0000733A C42E[2405]              	LES     BP,[THISDPB]
 35265 0000733E BF0100                  	MOV     DI,1			; Fake some registers
 35266 00007341 89F9                    	MOV     CX,DI
 35267                                  	;mov	dx,[es:bp+16]
 35268 00007343 268B5610                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 35269 00007347 E801E5                  	call	HARDERR
 35270 0000734A 5F                      	POP     DI
 35271 0000734B 07                      	POP	ES
 35272 0000734C 1F                      	POP     DS
 35273 0000734D 3C01                    	CMP     AL,1
 35274 0000734F 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 35275 00007351 F9                      	STC
 35276 00007352 C3                      	retn
 35277                                  
 35278                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID.  This does
 35279                                  ;       NOT perform a close, it merely asserts that the sharing information
 35280                                  ;       for the SFT/UID/PID may be safely released.
 35281                                  ;
 35282                                  ;   Inputs:     ES:DI points to an SFT
 35283                                  ;   Outputs:    None
 35284                                  ;   Registers modified: all except DS,ES,DI
 35285                                  
 35286                                  ShareEnd:
 35287                                  	; 26/07/2019
 35288 00007353 FF1E[6400]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 35289 00007357 C3                      	retn
 35290                                  
 35291                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 35292                                  
 35293                                  ;
 35294                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set.  If
 35295                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 35296                                  ;
 35297                                  ;   Inputs:     ThisSFT points to the SFT
 35298                                  ;               WFP_Start points to the WFP
 35299                                  ;   Outputs:    Carry clear => successful entry
 35300                                  ;               Carry set => failed system call
 35301                                  ;   Registers modified: all
 35302                                  
 35303                                  ShareEnter:
 35304 00007358 51                      	push	cx
 35305                                  retry:
 35306 00007359 8B0E[1A00]              	mov     cx,[RetryCount]
 35307                                  attempt:
 35308 0000735D C43E[3605]              	les     di,[THISSFT]		; grab sft
 35309 00007361 31C0                    	XOR     AX,AX
 35310                                   	;mov	[es:di+51],ax
 35311 00007363 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 35312 00007367 51                      	push	cx
 35313 00007368 E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 35314 0000736B 59                      	pop	cx
 35315 0000736C 730A                    	jnc	short done		; success, let the user see this
 35316 0000736E E80FAC                  	call	Idle                    ; wait a while
 35317 00007371 E2EA                    	loop    attempt                 ; go back for another attempt
 35318 00007373 E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 35319 00007376 73E1                    	jnc	short retry		; user said to retry, go do it
 35320                                  done:
 35321 00007378 59                      	pop	cx
 35322 00007379 C3                      	retn
 35323                                  
 35324                                  ;----------------------------------------------------------------------------
 35325                                  
 35326                                  ;align 2 ; 05/09/2018 (Error!)
 35327                                  
 35328 0000737A 90<rep 6h>              align 16 ; 08/09/2018 (OK.)
 35329                                  
 35330                                  ; 06/08/2018 - Retro DOS v3.0
 35331                                  
 35332                                  ;============================================================================
 35333                                  ; MSINIT.ASM
 35334                                  ;============================================================================
 35335                                  ;
 35336                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 35337                                  ;
 35338                                  	; 15/07/2018 - RetroDOS v3.0
 35339                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 35340                                  
 35341                                  SYSBUF:
 35342                                  IRETT:
 35343 00007380 CF                      	iret
 35344                                  
 35345                                  	; 07/07/2018 - Retro DOS v3.0
 35346                                  	; Retro DOS v2.0 - 03/03/2018
 35347                                  DOSINIT:
 35348                                  	; Far call from SYSINIT
 35349                                  	; DX = Memory size in paragraphs
 35350                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 35351                                  	;	  (Retro DOS v2.0, 16/03/2018)
 35352 00007381 FA                              CLI
 35353 00007382 FC                              CLD
 35354 00007383 2E8916[F202]                    MOV     [CS:ENDMEM],DX
 35355 00007388 2E8926[6804]                    MOV     [CS:INITSP],SP
 35356 0000738D 2E8C16[6A04]                    MOV     [CS:INITSS],SS
 35357 00007392 8CC8                            MOV     AX,CS
 35358 00007394 8ED0                            MOV     SS,AX
 35359 00007396 BC[9476]                        MOV     SP,INITSTACK
 35360                                  	; 08/08/2018
 35361 00007399 368C1E[4A00]            	MOV     [SS:NULDEV+2],DS
 35362 0000739E 368936[4800]                    MOV     [SS:NULDEV],SI	; DS:SI Points to CONSOLE Device
 35363                                  	; 15/07/2018
 35364                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 35365                                  	; (Set INT 2Ah handler address to an 'IRET')
 35366 000073A3 1E                      	push    ds
 35367 000073A4 31C0                    	xor     ax,ax
 35368 000073A6 8ED8                    	mov     ds,ax
 35369 000073A8 B8[8073]                	mov     ax,IRETT
 35370 000073AB A3A800                  	mov     [2Ah*4],ax ; 00A8h
 35371 000073AE 8CC8                    	mov     ax,cs
 35372 000073B0 A3AA00                  	mov     [(2Ah*4)+2],ax ; 00AAh
 35373 000073B3 1F                      	pop     ds
 35374                                  	;
 35375 000073B4 E82C02                          CALL    CHARINIT	; initialize console driver
 35376                                  
 35377 000073B7 56                              PUSH	SI		; save pointer to header	
 35378 000073B8 0E                      	PUSH	CS
 35379 000073B9 07                              POP	ES
 35380                                          ; 07/07/2018
 35381 000073BA BF[9E00]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 35382 000073BD B80300                          MOV     AX,3
 35383 000073C0 AB                              STOSW           	; Refcount
 35384 000073C1 FEC8                            DEC     AL
 35385 000073C3 AB                              STOSW           	; Access rd/wr, compatibility
 35386 000073C4 30C0                            XOR     AL,AL
 35387 000073C6 AA                              STOSB           	; attribute
 35388                                  	;mov	al,0C3h
 35389 000073C7 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 35390 000073C9 AB                      	STOSw			; flags
 35391 000073CA 89F0                            mov	ax,si
 35392 000073CC AB                              stosw			; device pointer in devptr	
 35393 000073CD 8CD8                            mov	ax,ds
 35394 000073CF AB                      	stosw
 35395 000073D0 31C0                    	xor	ax,ax	; 0
 35396 000073D2 AB                      	stosw			; firclus
 35397 000073D3 AB                      	stosw			; time
 35398 000073D4 AB                      	stosw			; date
 35399 000073D5 48                      	dec	ax	; -1
 35400 000073D6 AB                      	stosw			; size
 35401 000073D7 AB                      	stosw
 35402 000073D8 40                      	inc	ax	; 0
 35403 000073D9 AB                      	stosw			; position
 35404 000073DA AB                      	stosw
 35405                                  	;add	di,7
 35406 000073DB 83C707                  	add	di,SF_ENTRY.sf_name - SF_ENTRY.sf_cluspos
 35407                                  				; point at name
 35408                                  	;add	si,10
 35409 000073DE 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 35410                                  				; point to name
 35411 000073E1 B90400                  	mov	cx,4
 35412 000073E4 F3A5                    	rep	movsw		; name
 35413 000073E6 B103                    	mov	cl,3
 35414 000073E8 B020                    	mov	al," "
 35415 000073EA F3AA                    	rep	stosb		; extension
 35416 000073EC 5E                      	POP	SI		; get back pointer to header
 35417                                  
 35418                                  				; mark device as CON I/O
 35419                                  	; 15/07/2018
 35420                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 35421 000073ED 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 35422                                  	; 12/03/2018
 35423 000073F1 368936[3200]            	MOV     [SS:BCON],SI
 35424 000073F6 368C1E[3400]                    MOV     [SS:BCON+2],DS
 35425                                  
 35426                                  CHAR_INIT_LOOP:
 35427 000073FB C534                            LDS     SI,[SI]				; AUX device
 35428 000073FD E8E301                          CALL    CHARINIT
 35429                                         	;15/07/2018
 35430                                  	;test	byte [SI+4],8
 35431 00007400 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 35432 00007404 74F5                            JZ      SHORT CHAR_INIT_LOOP
 35433                                  	; 12/03/2018
 35434 00007406 368936[2E00]                    MOV     [SS:BCLOCK],SI
 35435 0000740B 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 35436 00007410 BD[9676]                        MOV     BP,MEMSTRT			; ES:BP points to DPB
 35437                                  PERDRV:
 35438                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 35439 00007413 C534                            LDS     SI,[SI]				; Next device
 35440 00007415 83FEFF                          CMP     SI,-1
 35441 00007418 7468                    	JZ      SHORT CONTINIT
 35442                                  
 35443 0000741A E8C601                          CALL    CHARINIT
 35444                                  
 35445                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 35446                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 35447                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 35448                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 35449                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 35450                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 35451                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 35452                                  
 35453                                          ; 15/07/2018
 35454                                  	;test	word [SI+4],8000h		; DEVTYP
 35455 0000741D F744040080                      TEST    word [SI+SYSDEV.ATT],DEVTYP
 35456 00007422 75EF                    	JNZ     SHORT PERDRV			; Skip any other character devs
 35457                                  
 35458 00007424 368A0E[1303]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 35459 00007429 30ED                    	XOR     CH,CH
 35460                                          ; 07/07/2018
 35461                                  	;MOV	[SI+10],CL		; Number of units in name field
 35462 0000742B 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 35463 0000742E 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 35464 00007433 30F6                    	XOR     DH,DH
 35465 00007435 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 35466 0000743A 1E                      	PUSH    DS
 35467 0000743B 56                              PUSH    SI
 35468 0000743C 36C51E[1803]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 35469                                  PERUNIT:
 35470 00007441 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 35471 00007443 43                              INC     BX
 35472 00007444 43                              INC     BX                      ; On to next BPB
 35473                                  	;07/07/2018
 35474                                          ;mov	[ES:BP+DPB.DRIVE],dl
 35475 00007445 26885600                	MOV     [ES:BP],DL
 35476                                  	;MOV	[ES:BP+1],DH
 35477 00007449 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 35478 0000744D 53                              PUSH    BX
 35479 0000744E 51                              PUSH    CX
 35480 0000744F 52                              PUSH    DX
 35481                                  
 35482                                          ;invoke	$SETDPB
 35483 00007450 E82DA9                          CALL	_$SETDPB
 35484                                  
 35485                                  	; 07/07/2018
 35486                                  	;MOV	AX,[ES:BP+2]
 35487 00007453 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 35488                                          ; 12/03/2018
 35489 00007457 363B06[3600]            	CMP	AX,[SS:MAXSEC]
 35490 0000745C 7604                    	JBE     SHORT NOTMAX
 35491 0000745E 36A3[3600]              	MOV	[SS:MAXSEC],AX
 35492                                  NOTMAX:
 35493 00007462 5A                              POP     DX
 35494 00007463 59                              POP     CX
 35495 00007464 5B                              POP     BX
 35496 00007465 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 35497 00007467 5E                              POP     SI
 35498 00007468 1F                              POP     DS
 35499                                  					; ds:si -> device header
 35500                                  					; store it in the corresponding dpb
 35501                                  	; 07/07/2018
 35502                                          ;MOV	[ES:BP+18],SI
 35503 00007469 26897612                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 35504                                          ;MOV	[ES:BP+20],DS
 35505 0000746D 268C5E14                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 35506                                  
 35507 00007471 1E                              PUSH    DS			; save pointer to device header
 35508 00007472 56                              PUSH    SI
 35509 00007473 FEC6                            INC     DH			; inc unit #
 35510 00007475 FEC2                            INC     DL			; inc drive #
 35511 00007477 8ED8                            MOV     DS,AX			; restore segment of BPB array
 35512                                          ;add	bp,32 ;15/07/2018
 35513 00007479 83C520                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 35514 0000747C E2C3                    	LOOP    PERUNIT			; process all units in each driver
 35515                                          
 35516 0000747E 5E                      	POP     SI			; restore pointer to device header
 35517 0000747F 1F                              POP     DS
 35518 00007480 EB91                    	JMP	SHORT PERDRV		; process all drivers in chain
 35519                                  
 35520                                  CONTINIT:
 35521 00007482 0E                              PUSH    CS
 35522 00007483 1F                              POP     DS
 35523                                  ; Calculate true address of buffers, FATs, free space
 35524 00007484 89EF                            MOV     DI,BP           ; First byte after current DPBs
 35525 00007486 8B2E[3600]                      MOV     BP,[MAXSEC]
 35526 0000748A B8[8073]                        MOV     AX,SYSBUF	; = IRETT (15/07/2018)
 35527                                          ; 07/07/2018
 35528                                  	;MOV	[BUFFSTRT],AX
 35529 0000748D 01E8                            ADD     AX,BP           ; One I/O buffer
 35530 0000748F 83C010                          ADD     AX,BUFINSIZ ; = 16
 35531 00007492 A3[2600]                        MOV     [DPBHEAD],AX	; True start of DPBs
 35532 00007495 89C2                            MOV     DX,AX
 35533 00007497 81EA[8073]                      SUB     DX,SYSBUF	; = IRETT (15/07/2018)
 35534 0000749B 89D5                            MOV     BP,DX
 35535 0000749D 01FD                            ADD     BP,DI           ; Allocate buffer space
 35536                                  	;sub	bp,918 ; = ADJFAC for current DOSINIT (07/07/2018)
 35537 0000749F 81ED1603                        SUB     BP,ADJFAC       ; True address of free memory
 35538 000074A3 55                              PUSH    BP ; ###		
 35539 000074A4 BF[9676]                        MOV     DI,MEMSTRT	; Current start of DPBs
 35540                                  	;add	di,24
 35541 000074A7 83C718                          ADD     DI,DPB.NEXT_DPB	; Point at dpb.next_dpb field
 35542 000074AA 8A0E[4600]                      MOV     CL,[NUMIO]
 35543 000074AE 30ED                            XOR     CH,CH
 35544                                  TRUEDPBAD:
 35545                                  	;add	ax,32
 35546 000074B0 83C020                          ADD     AX,DPBSIZ       ; Compute address of next DPB
 35547 000074B3 AB                              STOSW                   ; Set the link to next DPB
 35548 000074B4 83C71E                          ADD     DI,DPBSIZ-2     ; Point at next address
 35549 000074B7 E2F7                            LOOP    TRUEDPBAD
 35550 000074B9 83EF20                          SUB     DI,DPBSIZ       ; Point at last dpb.next_dpb field
 35551 000074BC B8FFFF                          MOV     AX,-1
 35552 000074BF AB                              STOSW                   ; End of list
 35553 000074C0 83C50F                          ADD     BP,15           ; True start of free space (round up to segment)
 35554                                  	; 15/07/2018
 35555                                  	;MOV	CL,4
 35556                                          ;SHR	BP,CL           ; Number of segments for DOS resources
 35557 000074C3 D1DD                            rcr	bp,1
 35558 000074C5 B103                    	mov	cl,3
 35559 000074C7 D3ED                    	shr	bp,cl
 35560                                  	;
 35561 000074C9 8CCA                    	MOV     DX,CS
 35562 000074CB 01EA                            ADD     DX,BP           ; First free segment
 35563 000074CD BB0F00                  	MOV	BX,15 ; 0Fh
 35564 000074D0 8B0E[F202]              	MOV	CX,[ENDMEM]
 35565 000074D4 8CCD                            MOV     BP,CS
 35566                                  
 35567                                  ; BP has segment of DOS (whether to load high or run in place)
 35568                                  ; DX has program segment (whether after DOS or overlaying DOS)
 35569                                  ; CX has size of memory in paragraphs (reduced by DOS size if HIGHMEM)
 35570 000074D6 890E[F202]                      MOV	[ENDMEM],CX
 35571 000074DA 8EC5                            MOV     ES,BP
 35572 000074DC 268C06[4A03]                    MOV     [ES:DSKCHRET+3],ES ; mov [ES:DOSEG_INIT],es
 35573 000074E1 31C0                            XOR     AX,AX
 35574 000074E3 8ED8                            MOV     DS,AX
 35575 000074E5 8EC0                            MOV     ES,AX
 35576                                  	;mov	di,82h 
 35577 000074E7 BF8200                          MOV     DI,INTBASE+2
 35578                                  	; 15/07/2018
 35579 000074EA 89E8                            MOV     AX,BP
 35580                                  	; Set INT 0 (divide by zero) handler
 35581 000074EC C7060000[E457]          	mov     word [0],DIVOV
 35582 000074F2 A30200                  	mov     word [2],ax  ; = cs
 35583                                  	; Set INT 20h to INT 28h handler segments 
 35584 000074F5 B91100                  	mov	cx,17
 35585 000074F8 F3AB                    	rep	stosw
 35586                                  	; DI points to INT 29h vector, offset
 35587 000074FA 83C706                  	add	di,6 
 35588                                  	; DI points to INT 2Ah vector, segment
 35589                                  	;Set  INT 2Ah to INT 3Fh handler segments		
 35590 000074FD B92B00                  	mov	cx,43
 35591 00007500 F3AB                    	rep	stosw
 35592                                  	; DI points to INT 40h vector, segment
 35593 00007502 BF8000                  	mov	di,80h
 35594                                  	; Set INT 20h to INT 28h vectors to their default handler offsets
 35595 00007505 B8[9114]                	mov	ax,_IRET
 35596 00007508 B90900                  	mov	cx,9
 35597                                  iset1:
 35598 0000750B AB                      	stosw
 35599 0000750C 83C702                  	add	di,2
 35600 0000750F E2FA                    	loop	iset1
 35601 00007511 83C704                  	add	di,4
 35602                                  	; Set INT 2Ah to INT 3Fh vectors to their default handler offsets
 35603 00007514 B91600                  	mov	cx,22
 35604                                  iset2:
 35605 00007517 AB                      	stosw
 35606 00007518 83C702                  	add	di,2
 35607 0000751B E2FA                    	loop	iset2
 35608                                  	
 35609 0000751D 89E8                    	mov	ax,bp
 35610                                  	; Set	INT 2Fh handler offset to INT2F
 35611 0000751F C706BC00[BE17]          	mov	word [2Fh*4],INT2F  ; 00BCh
 35612                                  
 35613                                  	; set up entry point call at vectors 30-31h
 35614                                  
 35615 00007525 C606C000EA                      MOV     BYTE [ENTRYPOINT],mi_Long_JMP
 35616 0000752A C706C100[9214]                  MOV     WORD [ENTRYPOINT+1],CALL_ENTRY
 35617 00007530 A3C300                          MOV    [ENTRYPOINT+3],AX
 35618                                  
 35619                                  	; Set	INT 20h, 21h, 22h, 23h handler offsets
 35620 00007533 C7068000[8B14]                  MOV     WORD [addr_int_abort],QUIT
 35621 00007539 C7068400[AA14]                  MOV     WORD [addr_int_command],COMMAND
 35622 0000753F C70688000001                    MOV     WORD [addr_int_terminate],100H
 35623 00007545 89168A00                        MOV     [addr_int_terminate+2],DX
 35624                                  	; 15/07/2018 - Retro DOS v3.0
 35625 00007549 C7069400[7316]                  MOV     WORD [addr_int_disk_read],ABSDRD   ; INT 25h
 35626 0000754F C7069800[B616]                  MOV     WORD [addr_int_disk_write],ABSDWRT ; INT 26h
 35627 00007555 C7069C00[9964]                  MOV     WORD [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 35628                                  
 35629                                  	; 15/07/2018
 35630                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 35631 0000755B 0E                      	push	cs
 35632 0000755C 1F                      	pop	ds
 35633 0000755D 0E                      	push	cs
 35634 0000755E 07                      	pop	es
 35635                                  	; initialize the jump table for the sharer..
 35636                                  	;	(MSDOS 6.0, MSINIT.ASM, 1991, "patch_misc_segments")
 35637                                  	; MSDOS 3.3
 35638                                  	; (set JSharer jump table segments)
 35639 0000755F BF[5C00]                	mov	di,JShare
 35640 00007562 8CC8                    	mov	ax,cs
 35641 00007564 B90F00                  	mov	cx,15
 35642                                  iset3:
 35643 00007567 83C702                  	add	di,2
 35644 0000756A AB                      	stosw
 35645 0000756B E2FA                    	loop	iset3
 35646                                  
 35647                                  	; MSDOS 2.11, MSDOS 3.3
 35648 0000756D B8[5803]                        MOV     AX,INITBLOCK
 35649 00007570 83C00F                          ADD	AX,0Fh		; round to a paragraph
 35650 00007573 B104                            MOV     CL,4
 35651 00007575 D3E8                            SHR     AX,CL
 35652 00007577 8CDF                            MOV     DI,DS
 35653 00007579 01C7                            ADD     DI,AX
 35654 0000757B 47                              INC     DI
 35655 0000757C 893E[DE02]                      MOV     [CurrentPDB],DI
 35656 00007580 55                              PUSH    BP ; ##
 35657 00007581 52                              PUSH    DX ; #		; Save COMMAND address
 35658 00007582 A1[F202]                        MOV     AX,[ENDMEM]
 35659 00007585 89FA                            MOV     DX,DI
 35660                                  
 35661                                          ;invoke	SETMEM          ; Basic Header
 35662 00007587 E82BA9                  	CALL	SETMEM
 35663 0000758A 0E                              PUSH	CS
 35664 0000758B 1F                              POP	DS
 35665                                  	;mov	di,24
 35666 0000758C BF1800                          MOV     DI,PDB.JFN_TABLE
 35667 0000758F 31C0                            XOR     AX,AX
 35668 00007591 AB                              STOSW
 35669 00007592 AA                              STOSB                   ; 0,1 and 2 are CON device
 35670 00007593 B0FF                            MOV     AL,0FFH
 35671                                  	;mov	cx,17
 35672 00007595 B91100                          MOV     CX,FILPERPROC - 3 ; 17
 35673 00007598 F3AA                            REP     STOSB           ; Rest are unused
 35674 0000759A 0E                              PUSH	CS
 35675 0000759B 07                              POP	ES
 35676 0000759C 8C1E[2C00]                      MOV     [SFT_ADDR+2],DS	; Must be set to print messages
 35677                                  
 35678                                  	; 15/07/2018 - Retro DOS v3.0
 35679                                  	; MSDOS 3.3
 35680                                  	; (set country cdpg table segments)
 35681 000075A0 BE[FD0F]                	mov	si,COUNTRY_CDPG ; country_tab
 35682                                  	;mov	[es:si+79],es	; Ucase table segment
 35683                                  	;mov	[es:si+84],es	; File ucase table segment
 35684                                  	;mov	[es:si+89],es	; File char list segment
 35685                                  	;mov	[es:si+94],es	; Collate table segment
 35686                                  	;mov	[es:si+123],es	; Monocase routine segment
 35687 000075A3 8C444F                  	mov	[si+79],es
 35688 000075A6 8C4454                  	mov	[si+84],es
 35689 000075A9 8C4459                  	mov	[Si+89],es
 35690 000075AC 8C445E                  	mov	[si+94],es
 35691 000075AF 8C447B                  	mov	[si+123],es
 35692                                  	; (set SysInitTable -sysinitvars and country_cdpg- segments)
 35693 000075B2 BE[3B0F]                	mov     si,SysInitTable
 35694                                  	;;mov	[es:si+6], es
 35695                                  	;;mov	[es:si+2], es
 35696                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 35697                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 35698 000075B5 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 35699 000075B8 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 35700                                  
 35701                                  	; (set FastOpen table FastRet segment)
 35702 000075BB BE[430F]                	mov     si,FastTable
 35703                                  	;mov	[es:si+4],es
 35704                                  	;;mov	[es:si+8],es
 35705 000075BE 8C4404                  	mov     [si+4],es
 35706                                  	;mov	[si+8],es
 35707                                  	; IBMDOS.COM (Offset 7259h), IBM PC DOS 3.30
 35708 000075C1 C706[8F0F]7258          	mov	word [FETCHI_TAG],5872h ; ? ('Xr')
 35709                                  
 35710                                  	; 10/08/2018 - Retro DOS v3.0
 35711                                  
 35712                                  	; MSDOS 2.11 (Retro DOS v2.0), MSDOS 3.3
 35713                                  
 35714                                  ; After this points the char device functions for CON will work for
 35715                                  ; printing messages
 35716                                  
 35717                                  	;;IF	NOT IBM
 35718                                  	;;IF	NOT ALTVECT
 35719                                  	;MOV	SI,HEADER
 35720                                  	;;invoke OUTMES
 35721                                  	;CALL	OUTMES
 35722                                  	;;PUSH	CS		; Outmes stomps on segments
 35723                                  	;;POP	DS
 35724                                  	;;PUSH	CS
 35725                                  	;;POP	ES
 35726                                  	;;ENDIF
 35727                                  	;;ENDIF
 35728                                  
 35729                                  ; Move the FATs into position
 35730 000075C7 5A                              POP     DX ; #			; Restore COMMAND address
 35731 000075C8 5D                              POP     BP ; ##
 35732 000075C9 59                              POP     CX ; ###		; True address of free memory
 35733 000075CA BE[9676]                        MOV     SI,MEMSTRT		; Place to move DPBs from
 35734 000075CD 8B3E[2600]                      MOV     DI,[DPBHEAD]		; Place to move DPBs to
 35735 000075D1 29F9                            SUB     CX,DI                   ; Total length of DPBs
 35736 000075D3 39F7                            CMP     DI,SI
 35737 000075D5 7607                            JBE     SHORT MOVJMP		; Are we moving to higher or 
 35738                                  					; lower memory?
 35739 000075D7 49                              DEC     CX                      ; Move backwards to higher memory
 35740 000075D8 01CF                            ADD     DI,CX
 35741 000075DA 01CE                            ADD     SI,CX
 35742 000075DC 41                              INC     CX
 35743 000075DD FD                              STD
 35744                                  MOVJMP:
 35745 000075DE 8EC5                            MOV     ES,BP
 35746 000075E0 E9898E                          JMP     MOVDPB
 35747                                  
 35748                                  CHARINIT:
 35749                                  	; 07/07/2018 - Retro DOS v3.0
 35750 000075E3 36C606[0603]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 35751 000075E9 36C606[0703]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 35752 000075EF 36C606[0803]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 35753 000075F5 36C706[0903]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 35754 000075FC 06                              PUSH	ES
 35755 000075FD 53                              PUSH	BX
 35756 000075FE 50                              PUSH	AX
 35757 000075FF BB[0603]                        MOV	BX,DEVCALL
 35758 00007602 0E                              PUSH	CS
 35759 00007603 07                              POP	ES
 35760 00007604 E8F6D8                          CALL	DEVIOCALL2	
 35761 00007607 58                      	POP	AX
 35762 00007608 5B                              POP	BX
 35763 00007609 07                              POP	ES
 35764 0000760A C3                              RETN
 35765                                  
 35766 0000760B 90                      align 2
 35767                                          ;;DB	80H DUP(?)
 35768                                  	;TIMES 	64 dw 0 ; 05/09/2018
 35769                                  	; 10/08/2018
 35770                                  	;times	128 dw 0
 35771                                  	; 12/08/2018
 35772                                  	;times	132 dW 0 ; ADJFAC = 918 ; 08/09/2018 (OK.)
 35773                                  	; 08/09/2018 
 35774 0000760C 00<rep 88h>             	times	136 db 0 ; ADJFAC = 790	; 08/09/2018 (OK.) 
 35775                                  
 35776                                  INITSTACK:	; INITSTACK LABEL BYTE
 35777 00007694 0000                    	DW	0 ; DW ?
 35778                                  
 35779                                  ;MEMSTRT LABEL	WORD
 35780                                  MEMSTRT EQU	$
 35781                                  
 35782                                  ADJFAC  EQU     MEMSTRT-SYSBUF
 35783                                  
 35784 00007696 00                      	db 0
 35785 00007697 00                      	db 0
 35786 00007698 00                      	db 0
 35787 00007699 00                      	db 0
 35788 0000769A 00                      	db 0
 35789 0000769B 00                      	db 0
 35790 0000769C 00                      	db 0
 35791 0000769D 00                      	db 0
 35792 0000769E 00                      	db 0
 35793 0000769F 00                      	db 0
 35794                                  PcDosVersion:
 35795 000076A0 1A4040402323232050-     	db 1Ah,'@@@### PC-DOS Version 3.30',0Dh,0Ah
 35795 000076A9 432D444F5320566572-
 35795 000076B2 73696F6E20332E3330-
 35795 000076BB 0D0A               
 35796 000076BD 1A00                    	db 1Ah,0
 35797                                  
 35798                                          ;do_ext
 35799                                  ;LAST	ENDS
