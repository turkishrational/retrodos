; ****************************************************************************
; MSDOS3.BIN (MSDOS 3.3 Kernel) - RETRO DOS v3.1 by ERDOGAN TAN
; ----------------------------------------------------------------------------
; Last Update: 16/01/2024 (BugFix) - (Previous: 16/12/2022)
; ----------------------------------------------------------------------------
; Beginning: 07/07/2019 (Retro DOS 3.0), 29/06/2019 (Retro DOS 3.1)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.14  
; ----------------------------------------------------------------------------
;	    ((nasm msdos3.asm -l msdos3.txt -o MSDOS3.BIN)) 	
; ----------------------------------------------------------------------------
; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
; ----------------------------------------------------------------------------
; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
; ****************************************************************************
; main file: 'retrodos3.s'
; incbin 'MSDOS3.BIN' ; (DOSGROUP CODE SEGMENT)
; ----------------------------------------------------------------------------
; 07/07/2018 - Erdogan Tan
; (Note: I have not got MSDOS 3.3 kernel source files; so, I need to continue
; by using disassembled MSDOS.SYS -v3.3- and MSDOS 6.0 kernel source files.)
; ----------------------------------------------------------------------------
; MSDOS 6.0 Kernel source files:
;	MSDATA.ASM, 
; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC)
;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
;
; MSDOS 2.0 Kernel source files:
; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
;	MSCODE.ASM
;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM

; ----------------------------------------
; 20/05/2019 - MSDOS3.S - Retro DOS v3.0
; 29/06/2019 - MSDOS3.ASM - Retro DOS v3.1
; ----------------------------------------

;============================================================================
; DOSLINK
;============================================================================
;msdos mscode dosmes misc getset dircall alloc dev dir +
;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
;stdio time xenix xenix2

;============================================================================
; This MSDOS source code is verified & modified by using IDA Pro Disassembler
; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
;============================================================================
;
; ###########################################################################
; #	This file is generated by The Interactive Disassembler (IDA)	    #
; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
; #			 Licensed to: Freeware version			    #
; ###########################################################################
;
; Input	MD5   :	EF2ADCA1CB3882118FD247DD4C672C81

; ---------------------------------------------------------------------------
; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS33.BIN
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 75CFh Loaded length: 75CFh
;============================================================================
; MSDOS33.BIN = IBMDOS.COM, 17/03/1987, 30159 bytes (IBM PC DOS 3.30 kernel)

;============================================================================
; MSDOS.ASM
;============================================================================

;TITLE   Standard MSDOS
;NAME    MSDOS_2

; Number of disk I/O buffers

;	INCLUDE STDSW.ASM
;       INCLUDE MSHEAD.ASM
;       INCLUDE MSDATA.ASM

;	END

;============================================================================
; STDSW.ASM
;============================================================================

TRUE    EQU     0FFFFH
FALSE   EQU     ~TRUE ; NOT TRUE

; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;MSVER   EQU     false
;IBM     EQU     true
;WANG    EQU     FALSE
;ALTVECT EQU     FALSE

; Set this switch to cause DOS to move itself to the end of memory
;HIGHMEM EQU     FALSE

;	IF      IBM
ESCCH   EQU     0			; character to begin escape seq.
CANCEL  EQU     27			;Cancel with escape
TOGLINS EQU     TRUE			;One key toggles insert mode
TOGLPRN EQU     TRUE			;One key toggles printer echo
ZEROEXT EQU     TRUE
;       ELSE
;       IF      WANG			;Are we assembling for WANG?
;ESCCH   EQU     1FH			;Yes. Use 1FH for escape character
;       ELSE
;ESCCH   EQU     1BH
;       ENDIF
;CANCEL  EQU     "X"-"@"		;Cancel with Ctrl-X
;TOGLINS EQU     WANG			;Separate keys for insert mode on
					;and off if not WANG
;TOGLPRN EQU     FALSE			;Separate keys for printer echo on
					;and off
;ZEROEXT EQU     TRUE
;        ENDIF

;============================================================================
; MSHEAD.ASM
;============================================================================

;--------------------------------------------------------------
; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
;--------------------------------------------------------------

; MS-DOS High-performance operating system for the 8086  version 1.28
;        by Microsoft MSDOS development group:
;           Tim Paterson (Ret.)
;           Aaron Reynolds
;           Nancy Panners (Parenting)
;           Mark Zbikowski
;           Chris Peters (BIOS) (ret.)

; ****************** Revision History *************************
;          >> EVERY change must noted below!! <<
;
; 0.34 12/29/80 General release, updating all past customers
; 0.42 02/25/81 32-byte directory entries added
; 0.56 03/23/81 Variable record and sector sizes
; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
; 0.74 04/15/81 Recognize I/O devices with file names
; 0.75 04/17/81 Improve and correct buffer handling
; 0.76 04/23/81 Correct directory size when not 2^N entries
; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
; 1.00 04/28/81 Renumber for general release
; 1.01 05/12/81 Fix bug in `STORE'
; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
;               RENAME fix, general cleanup
; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
;               of smaller improvements
; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
;               zero extent field in IBM version (back to 1.01!)
; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
;               is searched first when possible to minimize I/O
;      03/03/82 STORE routine optimized to tack on partial sector tail as
;               full sector write when file is growing
;      03/09/82 Multiple I/O buffers
;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
;               of directory (infinite loop possible otherwise), DSKRESET
;               must invalidate all buffers (disk and directory).
; 1.27 03/31/82 Installable device drivers
;                 Function call 47 - Get pointer to device table list
;                 Function call 48 - Assign CON AUX LIST
;      04/01/82 Spooler interrupt (INT 28) added.
; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
;               call entries.  Most CS relative references changed to SS
;               relative with an eye toward putting a portion of the DOS in
;               ROM.  DOS source also broken into header, data and code pieces
;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
;               return the current values.
;      04/15/82 INDOS flag implemented for interrupt processing along with
;               call to return flag location (call 29)
;      04/15/82 Volume ID attribute added
;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
;               avoid a CS relative reference.
;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
;      04/20/82 Added INT int_upooler into loop ^S wait
;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
;               call 49.
;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
;               address of DPB
;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
;               writting to console device via file I/O.  Added a console
;               output attribute to devices.
;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
;               as devices....  pipes, redirection now possible
;      04/30/82 Expanded GETLIST call to 2.0 standard
;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
;               (data segment) stashed in ES, INT int_fatal_abort routines must
;               preserve ES.  This mod so HARDERR can be ROMed.
; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
;               out back about 1.27 or so (oops).  ARR
; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
;               RMDIR Xenix calls
; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
;               Frees up lots of memory.
; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
;               system buffers
; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
;               changed to set file handle environment.
; 2.00 08/01/82 Number for IBM release
;      01/19/83 No environ bug in EXEC
;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
;      01/19/83 Performance bug fix in cooked write to NUL
;      01/27/83 Growcnt fixed for 32-bits
;      01/27/83 Find-first problem after create
; 2.01 02/17/83 International DOS
; 2.11 08/12/83 Dos split into several more modules for assembly on
;               an IBM PC
; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
; (MSHEAD.ASM, MSDOS6.0, 1991) - mshead.asm 1.1 85/04/10 -
; 2.10 03/09/83 Start of NETWORK support
;		New Buffer structure
;		New Sytem file table structure
;		FCB moved to internal representation
;		DOS re-organized
; 2.11 04/21/83 Continuation of 2.10, preliminary Network
;		device interface.
; 2.11 08/12/83 Dos split into several more modules for assembly on
;               an IBM PC
; 2.50 09/12/83 More network stuff
;
; *************************************************************

; ----------------------------------------------------------------------------
; EQUATES

; Interrupt Entry Points:

; INTBASE:      ABORT
; INTBASE+4:    COMMAND
; INTBASE+8:    BASE EXIT ADDRESS
; INTBASE+C:    CONTROL-C ABORT
; INTBASE+10H:  FATAL ERROR ABORT
; INTBASE+14H:  BIOS DISK READ
; INTBASE+18H:  BIOS DISK WRITE
; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
; INTBASE+20H:  SPOOLER INTERRUPT
; INTBASE+40H:  Long jump to CALL entry point

ENTRYPOINTSEG   EQU     0CH
MAXDIF          EQU     0FFFH
SAVEXIT         EQU     10
;08/07/2018 - Retro DOS v3.0
;WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)

       ; INCLUDE DOSSYM.ASM
       ; INCLUDE DEVSYM.ASM

; SUBTTL ^C, terminate/abort/exit and Hard error actions
; PAGE
; There are three kinds of context resets that can occur during normal DOS
; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
; be handles in a clean fashion that allows nested executions along with the
; ability to trap one's own errors.
;
; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
;           follows:
;
;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
;           Save it in static memory.
;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
;
;           The interrupt service routine must preserve all registers and
;           return carry set iff the operation is to be aborted (via abort
;           system call), otherwise, carry is reset and the operation is
;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
;           RESULTS.
;
;           To restore original ^C processing (done on terminate/abort/exit),
;           restore INT int_ctrl_c from the saved vector.
;
; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
;           also preserve registers and return one of three values in AL: 0 and
;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
;           himself is not to issue the abort, rather, the dos will do it for
;           him by simulating a normal abort/exit system call.  ANY DEVIATION
;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
;
; terminate/abort/exit -- The user may not, under any circumstances trap an
;           abort call.  This is reserved for knowledgeable system programs.
;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.

;SUBTTL SEGMENT DECLARATIONS

; The following are all of the segments used.  They are declared in the order
; that they should be placed in the executable

;
; segment ordering for MSDOS
;

;START           SEGMENT BYTE PUBLIC 'START'
;START           ENDS

;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
;CONSTANTS       ENDS

;DATA            SEGMENT WORD PUBLIC 'DATA'
;DATA            ENDS

;CODE            SEGMENT BYTE PUBLIC 'CODE'
;CODE            ENDS

;LAST            SEGMENT BYTE PUBLIC 'LAST'
;LAST            ENDS

;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST

; The following segment is defined such that the data/const classes appear
; before the code class for ROMification

;START		SEGMENT BYTE PUBLIC 'START'
;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
;		JMP     DOSINIT
;START		ENDS

;============================================================================
; DOSSYM.ASM
;============================================================================

;<Control character definitions>

c_DEL       EQU     7Fh         ;    ASCII rubout or delete previous char
c_BS        EQU     08h         ; ^H ASCII backspace
c_CR        EQU     0Dh         ; ^M ASCII carriage return
c_LF        EQU     0Ah         ; ^J ASCII linefeed
c_ETB       EQU     17h         ; ^W ASCII end of transmission
c_NAK       EQU     15h         ; ^U ASCII negative acknowledge
c_ETX       EQU     03h         ; ^C ASCII end of text
c_HT        EQU     09h         ; ^I ASCII tab

;============================================================================
; BPB.INC, MSDOS 3.3, 1987
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;

; BIOS PARAMETER BLOCK DEFINITION
; THIS STRUCTURE IS USED TO BUILD A FULL DPB

struc BPBLOCK
.SECSZ: resw 1		; Size in bytes of physical sector
.CLUS:  resb 1		; Sectors/Alloc unit
.RES:   resw 1		; Number of reserved sectors
.FTCNT: resb 1		; Number of FATs
.DRCNT: resw 1		; Number of directory entries
.SCCNT: resw 1		; Total number of sectors
.MEDIA: resb 1		; Media descriptor byte
.FTSEC:	resw 1		; Number of sectors taken up by one FAT
.size:
endstruc

; 09/07/2018 - Retro DOS v3.0
; (BPB.INC, MSDOS 6.0, 1991)

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure.  It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB.  DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it. 

struc A_BPB
.BPB_BYTESPERSECTOR:	resw	1
.BPB_SECTORSPERCLUSTER:	resb	1
.BPB_RESERVEDSECTORS:	resw	1
.BPB_NUMBEROFFATS:	resb	1
.BPB_ROOTENTRIES: 	resw	1
.BPB_TOTALSECTORS:	resw	1
.BPB_MEDIADESCRIPTOR:	resb	1
.BPB_SECTORSPERFAT:	resw	1
.BPB_SECTORSPERTRACK:	resw	1
.BPB_HEADS:		resw	1
.BPB_HIDDENSECTORS:	resw	1
			resw	1
.BPB_BIGTOTALSECTORS:	resw	1
			resw	1
			resb	6	; NOTE:  many times these
;					; 	 6 bytes are omitted
;					;	 when BPB manipulations
;					;	 are performed!
.size:
endstruc

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; BUFFER.INC, MSDOS 3.3, 1987
;============================================================================
; 09/07/2018 - Retro DOS v3.0

; <Disk I/O Buffer Header>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

; Field definition for I/O buffer information

struc BUFFINFO
.buf_link:	resd 1		; Pointer to next buffer in list
.buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
				; SFT table index (bit 7 = 1)
				; = FFH if buffer free
.buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
				;	= 0 if Local device buffer
				; Bit 6 = 1 if buffer dirty
				; Bit 5 = Reserved
				; Bit 4 = Search bit (bit 7 = 1)
				; Bit 3 = 1 if buffer is DATA
				; Bit 2 = 1 if buffer is DIR
				; Bit 1 = 1 if buffer is FAT
				; Bit 0 = Reserved
.buf_sector:	resw 1		; Sector number of buffer (bit 7 = 0)
; The next two items are often refed as a word (bit 7 = 0)
.buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
.buf_wrtcntinc:	resb 1		; "   "     "   , # sectors between each write
.buf_DPB:	resd 1		; Pointer to drive parameters
.buf_fill:	resw 1		; How full buffer is (bit 7 = 1)
.size:
endstruc

%define buf_offset dword [buf_sector]
				;For bit 7 = 1, this is the byte
				;offset of the start of the buffer in
				;the file pointed to by buf_ID.  Thus
				;the buffer starts at location
				;buf_offset in the file and contains
				;buf_fill bytes.

BUFINSIZ        EQU     BUFFINFO.size

buf_Free	EQU	0FFh	; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	BUFINSIZ

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <User stack inside of system call>
; Location of user registers relative user stack pointer

struc	user_env   ; user_environ
.user_AX: resw 1
.user_BX: resw 1
.user_CX: resw 1
.user_DX: resw 1
.user_SI: resw 1
.user_DI: resw 1
.user_BP: resw 1
.user_DS: resw 1
.user_ES: resw 1
.user_IP: resw 1
.user_CS: resw 1
.user_F:  resw 1
.size:
endstruc

; 09/07/2018 - Retro DOS v3.0
; (VECTOR.INC, MSDOS 3.3, 1987)
; ----------------------------------------------------------------------------

; <interrupt definitions>

INTTAB          EQU     20H
INTBASE         EQU     4 * INTTAB
ENTRYPOINT      EQU     INTBASE+40H

;	IF      ALTVECT
;ALTTAB  EQU     0F0H
;ALTBASE EQU     4 * ALTTAB
;	ENDIF

;
; interrupt assignments
;
;	IF	NOT ALTVECT
int_abort	    EQU     INTTAB	; abort process
int_command	    EQU     int_abort+1 ; call MSDOS
int_terminate	    EQU     int_abort+2 ; int to terminate address
int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
int_fatal_abort     EQU     int_abort+4 ; hard disk error
int_disk_read	    EQU     int_abort+5 ; logical sector disk read
int_disk_write	    EQU     int_abort+6 ; logical sector disk write
int_keep_process    EQU     int_abort+7 ; terminate program and stay
					; resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
int_spooler	    EQU     int_abort+8 ; spooler call
int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
int_IBM 	    EQU     int_abort+10; critical section maintenance
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	ELSE
;int_abort	    EQU     INTTAB	; abort process
;int_command	    EQU     int_abort+1 ; call MSDOS
;int_terminate	    EQU     ALTTAB	; int to terminate address
;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;int_spooler	    EQU     int_terminate+3 ; spooler call
;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	ENDIF

addr_int_abort		EQU    4 * int_abort
addr_int_command	EQU    4 * int_command
addr_int_terminate	EQU    4 * int_terminate
addr_int_ctrl_c 	EQU    4 * int_ctrl_c
addr_int_fatal_abort	EQU    4 * int_fatal_abort
addr_int_disk_read	EQU    4 * int_disk_read
addr_int_disk_write	EQU    4 * int_disk_write
addr_int_keep_process	EQU    4 * int_keep_process
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
addr_int_spooler	EQU    4 * int_spooler
addr_int_fastcon	EQU    4 * int_fastcon
addr_int_IBM		EQU    4 * int_IBM
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;


; <Disk map>
;  MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;       |           | boot/reserved     |
;       |           +-------------------+
;       |           |  File allocation  |
;       v           |      table(s)     |
;                   |  (multiple copies |
;                   |     are kept)     |
;                   +-------------------+
;                   |     Directory     |
;                   +-------------------+
;                   |     File space    |
;                   +-------------------+
;                   |   Unaddressable   |
;                   |  (to end of disk) |
;                   +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

; BREAK <Directory entry>

;
;       +---------------------------+
;       |  (12 BYTE) filename/ext   |       0       0
;       +---------------------------+
;       |     (BYTE) attributes     |       11      B
;       +---------------------------+
;       |    (10 BYTE) reserved     |       12      C
;       +---------------------------+
;       | (WORD) time of last write |       22      16
;       +---------------------------+
;       | (WORD) date of last write |       24      18
;       +---------------------------+
;       |   (WORD) First cluster    |       26      1A
;       +---------------------------+
;       |     (DWORD) file size     |       28      1C
;       +---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;                           = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;
struc dir_entry
.dir_name:	resb 11			; file name
.dir_attr:	resb 1			; attribute bits
.dir_pad:	resb 10			; reserved for expansion
.dir_time:	resw 1			; time of last write
.dir_date:	resw 1			; date of last write
.dir_first:	resw 1			; first allocation unit of file
.dir_size_l:	resw 1			; low 16 bits of file size
.dir_size_h:	resw 1			; high 16 bits of file size
.size:
endstruc

attr_read_only      EQU      1h
attr_hidden         EQU      2h
attr_system         EQU      4h
attr_volume_id      EQU      8h
attr_directory      EQU     10h
attr_archive        EQU     20h
;09/07/2018 - Retro DOS v3.0
;(DIRENT.INC, MSDOS 3.3, 1987)
attr_device	    EQU     40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

attr_all            EQU     attr_hidden+attr_system+attr_directory
                                        ; OR of hard attributes for FINDENTRY

attr_ignore         EQU     attr_read_only+attr_archive
                                        ; ignore this(ese) attribute(s)
                                        ; during search first/next

attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
                                        ; changeable via CHMOD

; 09/08/2018 - Retro DOS v3.0
; (DIRENT.INC, MSDOS 6,0, 1991)
DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

; <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on the
; disk.  These entries are packed, two for every three bytes.  The contents of
; entry number N is found by 1) multiplying N by 1.5; 2) adding the result to
; the base address of the Allocation Table; 3) fetching the 16-bit word at this
; address; 4) If N was odd (so that N*1.5 was not an integer), shift the word
; right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry number zero
; is used as an end-of-file trap in the OS and is passed to the BIOS to help
; determine disk format.  Entry 1 is reserved for future use.  The first
; available allocation unit is assigned entry number two, and even though it is
; the first, is called cluster 2.  Entries greater than 0FF8H are end of file
; marks; entries of zero are unallocated.  Otherwise, the contents of a FAT
; entry is the number of the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would do
; because these clusters show as allocated, but are not part of any allocation
; chain and thus will never be allocated to a file.  A particular number is
; selected so that disk checking programs know what to do (ie.  a cluster with
; entry FF7H which is not in a chain is not an error).

;DIRSTRLEN       EQU     64	; Max length in bytes of directory strings

; 19/07/2018
; (DPB.INC, MSDOS 3.3, 1987)
; 07/07/2018 - Retro DOS v3.0
; (DPB.INC, MSDOS 6.0, 1991)
; ----------------------------------------------------------------------------
;**	DPB - Drive Parameter Block
;
;	BUGBUG - this isn't authorative - it's my probably incomplete and
;	possibly inaccurate deductions from code study... - jgl
;
;	The DPB is DOS's main structure for describing block devices.
;	It contains info about the "Drive" intermingled with info about
;	the FAT file system which is presumably on the drive.  I don't know
;	how those fields are used if it's not the FAT file system - BUGBUG
;
;	The DPBs are statically allocated and chained off of DPBHead.
;	Users scan this chain looking for a match on DPB_DRIVE.
;	The DPBs are built at init time from info in the SYSDEV structure.

struc	DPB
.DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
.UNIT:		resb 1		; Driver unit number of DPB
.SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
.CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
.CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
.FIRST_FAT:	resw 1		; Starting record of FATs
.FAT_COUNT:	resb 1		; Number of FATs for this drive
.ROOT_ENTRIES:	resw 1		; Number of directory entries
.FIRST_SECTOR:	resw 1		; First sector of first cluster
.MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
; MSDOS 3.3
.FAT_SIZE:	resb 1		; Number of records occupied by FAT
; MSDOS 6.0
;.FAT_SIZE:	resw 1		; Number of records occupied by FAT
.DIR_SECTOR:	resw 1		; Starting record of directory
.DRIVER_ADDR:	resd 1		; Pointer to driver
.MEDIA:		resb 1		; Media byte
.FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
				; check the first time this DPB is used
.NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
.NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
.FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
.size:
endstruc

DPBSIZ  EQU     DPB.size	; Size of the structure in bytes

DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; 12/07/2018 - Retro DOS v3.0 
; (DOSSYM.INC, MSDOS 6.0, 1991)

;**	Character Type Flags
;
;	These flags are used in a lookup table indexed by the character code.
;	They're used to quickly classify characters when parsing paths.
;	I think that these are only used to parse FCBs - jgl

FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
FDELIM	equ 2		; is a delimiter
FSPCHK	equ 4		; set if character is not a space or equivalent
FFCB	equ 8		; is valid in an FCB

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
devid_file_clean        EQU     40h     ; true if file and not written
devid_file_mask_drive   EQU     3Fh     ; mask for drive number

devid_device            EQU     80h     ; true if a device
devid_device_EOF        EQU     40h     ; true if end of file reached
devid_device_raw        EQU     20h     ; true if in raw mode
devid_device_special    EQU     10h     ; true if special device
devid_device_clock      EQU     08h     ; true if clock device
devid_device_null       EQU     04h     ; true if null device
devid_device_con_out    EQU     02h     ; true if console output
devid_device_con_in     EQU     01h     ; true if consle input

;
; structure of devid field as returned by IOCTL is:
;
;       BIT     7   6   5   4   3   2   1   0
;             |---|---|---|---|---|---|---|---|
;             | I | E | R | S | I | I | I | I |
;             | S | O | A | P | S | S | S | S |
;             | D | F | W | E | C | N | C | C |
;             | E |   |   | C | L | U | O | I |
;             | V |   |   | L | K | L | T | N |
;             |---|---|---|---|---|---|---|---|
;       ISDEV = 1 if this channel is a device
;             = 0 if this channel is a disk file
;
;       If ISDEV = 1
;
;             EOF = 0 if End Of File on input
;             RAW = 1 if this device is in Raw mode
;                 = 0 if this device is cooked
;             ISCLK = 1 if this device is the clock device
;             ISNUL = 1 if this device is the null device
;             ISCOT = 1 if this device is the console output
;             ISCIN = 1 if this device is the console input
;
;       If ISDEV = 0
;             EOF = 0 if channel has been written
;             Bits 0-5  are  the  block  device  number  for
;                 the channel (0 = A, 1 = B, ...)
;
devid_ISDEV     EQU     80h
devid_EOF       EQU     40h
devid_RAW       EQU     20h
devid_SPECIAL   EQU     10H
devid_ISCLK     EQU     08h
devid_ISNUL     EQU     04h
devid_ISCOT     EQU     02h
devid_ISCIN     EQU     01h

devid_block_dev EQU     1Fh             ; mask for block device number

; 08/07/2018 - Retro DOS v3.0
; (PDB.INC, MSDOS 6.0, 1991)
; ----------------------------------------------------------------------------
; BREAK <Process data block>
;
;**	Process data block (otherwise known as program header)
;

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever.  Reserved areas are probably safe
;	for use.

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
.ENVIRON:	resw 1		; seg addr of environment
.USER_STACK:	resd 1		; stack of self during system calls
.JFN_Length:	resw 1		; number of handles allowed
.JFN_Pointer:	resd 1		; pointer to JFN table
.Next_PDB:	resd 1		; pointer to nested PDB's
.InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
.Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
.Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
.Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
.PAD1:		resb 14 ; 0Eh
.CALL_SYSTEM:	resb 5		; portable method of system call
.PAD2:		resb 7		; reserved so FCB 1 can be used as
				;  an extended FCB
;endstruc 	; MSDOS 3.3
	  	; MSDOS 6.0
.FCB1:		resb 16 ; 10h	; default FCB 1
.FCB2:		resb 16 ; 10h	; default FCB 2
.PAD3:		resb 4		; not sure if this is used by PDB_FCB2
.TAIL:		resb 128	; command tail and default DTA
endstruc

; BREAK <EXEC and EXE file structures>
;
; EXEC arg block - load/go program
;

;
; The following get used as arguments to the EXEC system call.  They indicate
; whether or not the program is executed or whether or not a program header
; gets created.
;
exec_func_no_execute    EQU 1           ; no execute bit
exec_func_overlay       EQU 2           ; overlay bit

struc EXEC0
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.size:
endstruc

struc EXEC1
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.SP:		resw 1		; stack pointer of program
.SS:		resw 1		; stack seg register of program
.IP:		resw 1		; entry point IP
.CS:		resw 1		; entry point CS
.size:
endstruc

struc EXEC3
.load_addr:	resw 1		; seg address of load point
.reloc_fac:	resw 1		; relocation factor
endstruc

; 02/08/2018 (MSDOS 6.0, EXEC.INC, 1991)
;**	Exit codes (in upper byte) for terminating programs

EXIT_TERMINATE		EQU	0
EXIT_ABORT		EQU	0
EXIT_CTRL_C		EQU	1
EXIT_HARD_ERROR 	EQU	2
EXIT_KEEP_PROCESS	EQU	3

;
; EXE file header
;

struc EXE
.signature:   resw 1		; must contain 4D5A (yay zibo!)
.len_mod_512: resw 1		; low 9 bits of length
.pages:       resw 1		; number of 512b pages in file
.rle_count:   resw 1		; count of reloc entries
.par_dir:     resw 1		; number of paragraphs before image
.min_BSS:     resw 1		; minimum number of para of BSS
.max_BSS:     resw 1		; max number of para of BSS
.SS:          resw 1		; stack of image
.SP:          resw 1		; SP of image
.chksum:      resw 1		; checksum of file (ignored)
.IP:          resw 1		; IP of entry
.CS:          resw 1		; CS of entry
.rle_table:   resw 1		; byte offset of reloc table
.iov:         resw 1		; overlay number (0 for root)
.sym_tab:     resd 1		; offset of symbol table in file
.size:
endstruc

exe_valid_signature     EQU 5A4Dh
exe_valid_old_signature EQU 4D5Ah

struc symbol_entry
.value:	resd 1
.type:	resw 1
.len:	resb 1
.name:	resb 255
endstruc

; 07/07/2018 - Retro DOS v3.0
; MSDOS 6.0 (SF.INC, 1991)
; ----------------------------------------------------------------------------
;**	SF.INC - System File Table
;
;   AN000   version 4.00   Jan. 1988
;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
;   AN009   PTM 3839	 reorder SFT for MS WINDOWS

;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.

struc	SFT
.SFLink:	resd 1
.SFCount:	resw 1		; number of entries
.SFTable:	resw 1		; beginning of array of the following
.size:
endstruc

; 07/07/2018 - Retro DOS v3.0
; MSDOS 6.0 (SF.INC, 1991)
; ----------------------------------------------------------------------------
;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.

struc SF_ENTRY
.sf_ref_count:	resw 1		; number of processes sharing entry
				;   if FCB then ref count
.sf_mode:	resw 1		; mode of access or high bit on if FCB
.sf_attr:	resb 1		; attribute of file
.sf_flags:	resw 1		;Bits 8-15
				; Bit 15 = 1 if remote file
				;	 = 0 if local file or device
				; Bit 14 = 1 if date/time is not to be
				;   set from clock at CLOSE.  Set by
				;   FILETIMES and FCB_CLOSE.  Reset by
				;   other reseters of the dirty bit
				;   (WRITE)
				; Bit 13 = Pipe bit (reserved)
				;
				; Bits 0-7 (old FCB_devid bits)
				; If remote file or local file, bit
				; 6=0 if dirty Device ID number, bits
				; 0-5 if local file.
				; bit 7=0 for local file, bit 7
				;      =1 for local I/O device
				; If local I/O device, bit 6=0 if EOF (input)
				;		Bit 5=1 if Raw mode
				;		Bit 0=1 if console input device
				;		Bit 1=1 if console output device
				;		Bit 2=1 if null device
				;		Bit 3=1 if clock device
.sf_devptr:	resd	1	; Points to DPB if local file, points
				; to device header if local device,
				; points to net device header if
				; remote
.sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
.sf_time:	resw	1	; Time associated with file
.sf_date:	resw	1	; Date associated with file
.sf_size:	resd 	1	; Size associated with file
.sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs

; Starting here, the next 7 bytes may be used by the file system to store an
; ID

; 09/07/2018 - Retro DOS v3.0

; MSDOS 3.3 SF.INC, 1987
.sf_cluspos:	resw	1	; Position of last cluster accessed
.sf_lstclus	resw	1	; Last cluster accessed
.sf_dirsec:	resw	1	; Sector number of directory sector
				; for this file
.sf_dirpos:	resb	1	; Offset of this entry in the above

; MSDOS 6.0, SF.INC, 1991
;.sf_cluspos:	resw	1	; Position of last cluster accessed
;.sf_dirsec:	resd	1	; Sector number of directory sector
;				; for this file
;.sf_dirpos:	resb	1	; Offset of this entry in the above

; End of 7 bytes of file-system specific info.

.sf_name:	resb	11	; 11 character name that is in the
				; directory entry.  This is used by
				; close to detect file deleted and
				; disk changed errors.
; SHARING INFO
.sf_chain:	resd	1	; link to next SF
.sf_UID:	resw	1
.sf_PID:	resw	1
.sf_MFT:	resw	1

; MSDOS 6.0, SF.INC, 1991
;.sf_lstclus:	resw	1	;AN009; Last cluster accessed
;.sf_IFS_HDR:	resd	1

.size:
endstruc

; 20/07/2018
; MSDOS 3.3, SF.INC, 1987
%define sf_netid   SF_ENTRY.sf_cluspos    ; byte
%define sf_OpenAge SF_ENTRY.sf_position+2 ; word
%define sf_LRU	   SF_ENTRY.sf_position	  ; word
; MSDOS 6.0, SDF.INC, 1991
%define sf_fsda	     SF_ENTRRY.sf_cluspos ; byte ;DOS 4.00
%define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00

; 19/07/2018

; MSDOS 3.3, SF.INC, 1987

sf_default_number  EQU	5

; Note that we need to mark an SFT as being busy for OPEN/CREATE.  This is
; because an INT 24 may prevent us from 'freeing' it.  We mark this as such
; by placing a -1 in the ref_count field.

sf_busy EQU -1

; mode mask for FCB detection
sf_isFCB		EQU	1000000000000000B

; Flag word masks
sf_isnet		EQU	1000000000000000B
sf_close_nodate 	EQU	0100000000000000B
sf_pipe 		EQU	0010000000000000B
sf_no_inherit		EQU	0001000000000000B
sf_net_spool		EQU	0000100000000000B

; 19/04/2018
sf_entry_size equ SF_ENTRY.size ; 53

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; 09/07/2018 - Retro DOS v3.0
; (ARENA.INC, MSDOS 3.3, 1987)
; ----------------------------------------------------------------------------
;BREAK <Memory arena structure>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;
; arena item
;

struc ARENA
.SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
.OWNER:		resw 1		; owner of arena item
.SIZE:		resw 1		; size in paragraphs of item
endstruc

; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
; and arena_owner_system are all equal to zero and are contained in DI.
; Change them and change ALLOC.ASM.

arena_owner_system  EQU 0               ; free block indication

arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
arena_signature_end     EQU 5Ah         ; valid signature, last block in arena

; 04/08/2018 - Retro DOS v3.0
; (ARENA.INC, MSDOS 6.0, 1991)

FIRST_FIT	EQU	00000000B
BEST_FIT	EQU	00000001B
LAST_FIT	EQU	00000010B

; MSDOS 6.0
;LOW_FIRST	EQU	00000000B	; M001
;HIGH_FIRST	EQU	10000000B	; M001
;HIGH_ONLY	EQU	01000000B	; M001

;LINKSTATE	EQU	00000001B	; M002

;HF_MASK		EQU	~HIGH_FIRST	; M001
;HO_MASK		EQU	~HIGH_ONLY	; M001

;STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
						; M026: used to mask of bits
						; M026: 6 & 7 of AllocMethod

; 07/07/2018 - Retro DOS v3.0
; (MI.INC, MSDOS 6.0, 1991)
; ----------------------------------------------------------------------------
;BREAK <Machine instruction, flag definitions and character types>

mi_INT		EQU	0CDh
mi_Long_JMP	EQU	0EAh
mi_Long_CALL	EQU	09Ah
mi_Long_RET	EQU	0CBh
mi_Near_RET	EQU	0C3h

;			xxxxoditszxaxpxc
f_Overflow	EQU	0000100000000000B
f_Direction	EQU	0000010000000000B
f_Interrupt	EQU	0000001000000000B
f_Trace 	EQU	0000000100000000B
f_Sign		EQU	0000000010000000B
f_Zero		EQU	0000000001000000B
f_Aux		EQU	0000000000010000B
f_Parity	EQU	0000000000000100B
f_Carry 	EQU	0000000000000001B

; <Standard I/O assignments>

stdin       EQU     0
stdout      EQU     1
stderr      EQU     2
stdaux      EQU     3
stdprn      EQU     4

; <Xenix subfunction assignments>

open_for_read   EQU 0
open_for_write  EQU 1
open_for_both   EQU 2

; 13/07/2018 - Retro DOS v3.0
; (FILEMODE.INC, MSDOS 6.0, 1991)

access_mask	EQU 0Fh ; 09/08/2018

EXEC_OPEN	EQU 3		; access code of 3 indicates that open was 
				; made from exec
SHARING_MASK	    equ 0F0h
SHARING_COMPAT	    equ 000h
SHARING_DENY_BOTH   equ 010h
SHARING_DENY_WRITE  equ 020h
SHARING_DENY_READ   equ 030h
SHARING_DENY_NONE   equ 040h
SHARING_NET_FCB     equ 070h
SHARING_NO_INHERIT  equ 080h

; 09/07/2018 - Retro DOS v3.0
; (SYSCALL.INC, MSDOS 3.3, 1987)
; ----------------------------------------------------------------------------

; <system call definitions>

ABORT                           EQU 0   ;  0      0
STD_CON_INPUT                   EQU 1   ;  1      1
STD_CON_OUTPUT                  EQU 2   ;  2      2
STD_AUX_INPUT                   EQU 3   ;  3      3
STD_AUX_OUTPUT                  EQU 4   ;  4      4
STD_PRINTER_OUTPUT              EQU 5   ;  5      5
RAW_CON_IO                      EQU 6   ;  6      6
RAW_CON_INPUT                   EQU 7   ;  7      7
STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
STD_CON_STRING_INPUT            EQU 10  ; 10      A
STD_CON_INPUT_STATUS            EQU 11  ; 11      B
STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
DISK_RESET                      EQU 13  ; 13      D
SET_DEFAULT_DRIVE               EQU 14  ; 14      E
FCB_OPEN                        EQU 15  ; 15      F
FCB_CLOSE                       EQU 16  ; 16     10
DIR_SEARCH_FIRST                EQU 17  ; 17     11
DIR_SEARCH_NEXT                 EQU 18  ; 18     12
FCB_DELETE                      EQU 19  ; 19     13
FCB_SEQ_READ                    EQU 20  ; 20     14
FCB_SEQ_WRITE                   EQU 21  ; 21     15
FCB_CREATE                      EQU 22  ; 22     16
FCB_RENAME                      EQU 23  ; 23     17
GET_DEFAULT_DRIVE               EQU 25  ; 25     19
SET_DMA                         EQU 26  ; 26     1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DEFAULT_DPB                 EQU 31  ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_RANDOM_READ                 EQU 33  ; 33     21
FCB_RANDOM_WRITE                EQU 34  ; 34     22
GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
GET_FCB_POSITION                EQU 36  ; 36     24
SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
GET_DATE                        EQU 42  ; 42     2A
SET_DATE                        EQU 43  ; 43     2B
GET_TIME                        EQU 44  ; 44     2C
SET_TIME                        EQU 45  ; 45     2D
SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
; Extended functionality group
GET_DMA                         EQU 47  ; 47     2F
GET_VERSION                     EQU 48  ; 48     30
KEEP_PROCESS                    EQU 49  ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DPB                         EQU 50  ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
GET_INDOS_FLAG                  EQU 52  ; 52     34
GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
GET_DRIVE_FREESPACE             EQU 54  ; 54     36
CHAR_OPER                       EQU 55  ; 55     37
INTERNATIONAL                   EQU 56  ; 56     38
; XENIX CALLS
;   Directory Group
MKDIR                           EQU 57  ; 57     39
RMDIR                           EQU 58  ; 58     3A
CHDIR                           EQU 59  ; 59     3B
;   File Group
CREAT                           EQU 60  ; 60     3C
OPEN                            EQU 61  ; 61     3D
CLOSE                           EQU 62  ; 62     3E
READ                            EQU 63  ; 63     3F
WRITE                           EQU 64  ; 64     40
UNLINK                          EQU 65  ; 65     41
LSEEK                           EQU 66  ; 66     42
CHMOD                           EQU 67  ; 67     43
IOCTL                           EQU 68  ; 68     44
XDUP                            EQU 69  ; 69     45
XDUP2                           EQU 70  ; 70     46
CURRENT_DIR                     EQU 71  ; 71     47
;    Memory Group
ALLOC                           EQU 72  ; 72     48
DEALLOC                         EQU 73  ; 73     49
SETBLOCK                        EQU 74  ; 74     4A
;    Process Group
EXEC                            EQU 75  ; 75     4B
EXIT                            EQU 76  ; 76     4C
_WAIT				EQU 77  ; 77     4D
FIND_FIRST                      EQU 78  ; 78     4E
;   Special Group
FIND_NEXT                       EQU 79  ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
SET_CURRENT_PDB                 EQU 80  ; 80     50
GET_CURRENT_PDB                 EQU 81  ; 81     51
GET_IN_VARS                     EQU 82  ; 82     52
SETDPB                          EQU 83  ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
DUP_PDB                         EQU 85  ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
RENAME                          EQU 86  ; 86     56
FILE_TIMES                      EQU 87  ; 87     57
ALLOCOPER			EQU 88	; 88	 58
; Network extention system calls
GETEXTENDEDERROR		EQU 89	; 89	 59
CREATETEMPFILE			EQU 90	; 90	 5A
CREATENEWFILE			EQU 91	; 91	 5B
LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
USEROPER			EQU 94	; 94	 5E Get and Set
ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
XNAMETRANS			EQU 96	; 96	 60
PATHPARSE			EQU 97	; 97	 61
GETCURRENTPSP			EQU 98	; 98	 62
HONGEUL 			EQU 99	; 99	 63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SET_PRINTER_FLAG		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GETEXTCNTRY			EQU 101 ; 101	 65 
GETSETCDPG			EQU 102 ; 102	 66
EXTHANDLE			EQU 103 ; 103	 67
COMMIT				EQU 104 ; 104	 68

; 09/07/2018 - Retro DOS v3.0
; (MSDOS 6.0, SYSCALL.INC, 1987)

;GetSetMediaID			EQU 105 ; 105	 69
;IFS_IOCTL			EQU 107 ; 107	 6B
;ExtOpen 			EQU 108 ; 108	 6C

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;ROM_FIND_FIRST			EQU 109 ; 109    6D
;ROM_FIND_NEXT			EQU 110 ; 110    6E
;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

SET_OEM_HANDLER			EQU 248 ; 248    F8
;OEM_C1				EQU 249 ; 249    F9
;OEM_C2				EQU 250 ; 250    FA
;OEM_C3				EQU 251 ; 251    FB
;OEM_C4				EQU 252 ; 252    FC
;OEM_C5				EQU 253 ; 253    FD
;OEM_C6				EQU 254 ; 254    FE
;OEM_C7				EQU 255 ; 255    FF

;============================================================================
; VERSIONA.INC (MSDOS 3.3, 24/07/1987)
;============================================================================
; 08/07/2018 - Retro DOS 3.0

MAJOR_VERSION   EQU     3
MINOR_VERSION   EQU     30

;============================================================================
; DOSSYM_V211.ASM (-*-)
;============================================================================

;DOS_MAJOR_VERSION   EQU      2
;DOS_MINOR_VERSION   EQU     11

;============================================================================
; INTNAT.INC, MSDOS 3.3, 1987
;============================================================================
; 09/07/2018 - Retro DOS 3.0

;
; Current structure of the data returned by the international call
;

struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
.Date_tim_format:
		RESW 1		; 0-USA, 1-EUR, 2-JAP
.Currency_sym:
		RESB 5		; Currency Symbol 5 bytes
.Thous_sep:
		RESB 2		; Thousands separator 2 bytes
.Decimal_sep:
		RESB 2		; Decimal separator 2 bytes
.Date_sep:
		RESB 2		; Date separator 2 bytes
.Time_sep:
		RESB 2		; Time separator 2 bytes
.Bit_field:	
		RESB 1		; Bit values
                                   ;   Bit 0 = 0 if currency symbol first
                                   ;         = 1 if currency symbol last
                                   ;   Bit 1 = 0 if No space after currency symbol
                                   ;         = 1 if space after currency symbol
.Currency_cents:
		RESB 	1	; Number of places after currency dec point
.Time_24:
		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
.Map_call:
		RESW	1	; Address of case mapping call (DWORD)
                RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
.Data_sep:
		RESB	2	; Data list separator character
.size:		
endstruc

;
; Max size of the block returned by the INTERNATIONAL call
;
internat_block_max	EQU	32

;============================================================================
; SYSVAR.INC (MSDOS 6.0, 1991)
;============================================================================
; 08/07/2018 - Retro DOS v3.0

;SysInitVars STRUC
struc SYSI
.DPB:	    resd 1		; DPB chain
.SFT:	    resd 1		; SFT chain
.CLOCK:	    resd 1		; CLOCK device
.CON:	    resd 1		; CON device
.MAXSEC:    resw 1		; maximum sector size
.BUF:	    resd 1		; points to Hashinitvar
.CDS:	    resd 1		; CDS list
.FCB:	    resd 1		; FCB chain
.Keep:	    resw 1		; keep count
.NUMIO:	    resb 1		; Number of block devices
.NCDS:	    resb 1		; number of CDS's
.DEV:	    resd 1		; device list
; 09/07/2018
; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
; Following parameters are used with MDSOS 6.0 (Retro DOS v4.0)
.ATTR:	    resw 1		; null device attribute word
.STRAT:	    resw 1		; null device strategy entry point
.INTER:	    resw 1		; null device interrupt entry point
.NAME:	    resb 8		; null device name
.SPLICE:    resb 1		; TRUE -> splicees being done
.IBMDOS_SIZE: resw 1		; DOS size in paragraphs
.IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
.IFS:	    resd 1		; IFS header chain
.BUFFERS:   resw 2		; BUFFERS= values (m,n)
.BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
.DWMOVE:    resb 1		; 1 if 386 machine
.EXT_MEM:   resw 1		; Extended memory size in KB.
endstruc
;SysInitVars ENDS

;This is added for more information exchange between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86

;SysInitVars_Ext struc
struc SYSI_EXT
.SysInitVars:	resd 1		; Points to the above structure.
.Country_Tab:	resd 1		; DOS_Country_cdpg_info
endstruc
;SysInitVars_Ext ends

;============================================================================
; IOCTL.INC - MSDOS 6.0 - 1991
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;*** J.K.
;General Guide -
;Category Code:
; 0... .... DOS Defined
; 1... .... User defined
; .xxx xxxx Code

;Function Code:
; 0... .... Return error if unsupported
; 1... .... Ignore if unsupported
; .0.. .... Intercepted by DOS
; .1.. .... Passed to driver
; ..0. .... Sends data/commands to device
; ..1. .... Quries data/info from device
; ...x .... Subfunction
;
; Note that "Sends/queries" data bit is intended only to regularize the
; function set.  It plays no critical role; some functions may contain both
; command and query elements. The convention is that such commands are
; defined as "sends data".

;*****************************;*
; BLOCK DRIVERS 	      ;*
;*****************************;*

; IOCTL SUB-FUNCTIONS
; (MSDOS 3.3 + MSDOS 6.0)
IOCTL_GET_DEVICE_INFO	EQU	0
IOCTL_SET_DEVICE_INFO	EQU	1
IOCTL_READ_HANDLE	EQU	2
IOCTL_WRITE_HANDLE	EQU	3
IOCTL_READ_DRIVE	EQU	4
IOCTL_WRITE_DRIVE	EQU	5
IOCTL_GET_INPUT_STATUS	EQU	6
IOCTL_GET_OUTPUT_STATUS EQU	7
IOCTL_CHANGEABLE?	EQU	8
IOCTL_DeviceLocOrRem?	EQU	9
IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
IOCTL_SHARING_RETRY	EQU	0Bh   ;11
GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
GENERIC_IOCTL		EQU	0Dh   ;13
; (MSDOS 6.0 + MSDOS 3.3)
IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
; (MSDOS 6.0)
IOCTL_QUERY_HANDLE	EQU	10h   ;16
IOCTL_QUERY_BLOCK	EQU	11h   ;17

; GENERIC IOCTL CATEGORY CODES
IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
IOC_TC			EQU	2	; TERMINAL CONTROL
IOC_SC			EQU	3	; SCREEN CONTROL
IOC_KC			EQU	4	; KEYBOARD CONTROL
IOC_PC			EQU	5	; PRINTER CONTROL
IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO			EQU	8

; RAWIO SUB-FUNCTIONS
; (MSDOS 3.3 + MSDOS 6.0)
GET_DEVICE_PARAMETERS	EQU	60H
SET_DEVICE_PARAMETERS	EQU	40H
READ_TRACK		EQU	61H
WRITE_TRACK		EQU	41H
VERIFY_TRACK		EQU	62H
FORMAT_TRACK		EQU	42H
; (MSDOS 6.0)
GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00

; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
BUILD_DEVICE_BPB	EQU	000000001B

; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
INSTALL_FAKE_BPB	EQU	000000001B
ONLY_SET_TRACKLAYOUT	EQU	000000010B
TRACKLAYOUT_IS_GOOD	EQU	000000100B

; SPECIAL FUNCTION FOR FORMAT TRACK
; (MSDOS 3.3 + MSDOS 6.0)
STATUS_FOR_FORMAT	EQU	000000001B
; (MSDOS 6.0)
DO_FAST_FORMAT		EQU	000000010B ;AN001;

; CODES RETURNED FROM FORMAT STATUS CALL
FORMAT_NO_ROM_SUPPORT	EQU	000000001B
FORMAT_COMB_NOT_SUPPORTED EQU	000000010B

; DEVICETYPE VALUES
; (MSDOS 3.3 + MSDOS 6.0)
MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
DEV_5INCH		EQU	0
DEV_5INCH96TPI		EQU	1
DEV_3INCH720KB		EQU	2
DEV_8INCHSS		EQU	3
DEV_8INCHDS		EQU	4
DEV_HARDDISK		EQU	5
DEV_OTHER		EQU	7
; (MSDOS 6.0)
;DEV_3INCH1440KB	EQU	7
DEV_3INCH2880KB		EQU	9
; Retro DOS v2.0 - 26/03/2018
;;DEV_TAPE		EQU	6
;;DEV_ERIMO		EQU	8
;DEV_3INCH2880KB	EQU	9
DEV_3INCH1440KB		EQU	10

; (MSDOS 3.3)
;MAX_DEV_TYPE		EQU	7

; (MSDOS 6.0)
MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
					; CURRENTLY SUPPORT.

struc A_SECTORTABLE
.ST_SECTORNUMBER:	resw	1
.ST_SECTORSIZE:		resw	1
.size:
endstruc

;============================================================================
; DEVSYM.ASM
;============================================================================

;SUBTTL DEVICE TABLE AND SRH DEFINITION
;PAGE

; 07/07/2018 - Retro DOS v3.0
; (DEVSYM.INC, MSDOS 6.0, 1991)

;**	DevSym.inc - Device Symbols

; The device table list has the form:
struc	SYSDEV
.NEXT:		resd 1		;Pointer to next device header
.ATT:		resw 1		;Attributes of the device
.STRAT:		resw 1		;Strategy entry point
.INT:		resw 1		;Interrupt entry point
.NAME:		resb 8		;Name of device (only first byte used for block)
.size:
endstruc

;
; ATTRIBUTE BIT MASKS
;
; CHARACTER DEVICES:
;
; BIT 15 -> MUST BE 1
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED
;      7 -> UNUSED
;      6 -> UNUSED
;      5 -> UNUSED
;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
;      3 -> 1 IF DEVICE IS CLOCK DEVICE
;      2 -> 1 IF DEVICE IS NULL DEVICE
;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
;      0 -> 1 IF DEVICE IS CONSOLE INPUT
;
; BLOCK DEVICES:
;
; BIT 15 -> MUST BE 0
;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
;	    THE SAME PLACE.
;     12 -> UNUSED
;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
;     10 -> MUST BE 0
;      9 -> MUST BE 0
;      8 -> UNUSED
;      7 -> UNUSED
;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
;      5 -> UNUSED
;      4 -> UNUSED
;      3 -> UNUSED
;      2 -> UNUSED
;      1 -> UNUSED
;      0 -> UNUSED
;

;Attribute bit masks
DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.

; 09/07/2018 - Retro DOS
; (DEVSYM.INC, MSDOS 3.3, 1987) 

OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
				;  NOT.  CURRENTLY BLOCK ONLY.
DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
				;  OPEN,CLOSE AND REMOVABLE MEDIA
				;  ENTRY POINTS, 0 IF NOT

EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
				;  THIS BIT IS RESERVED FOR FUTURE USE
				;  TO EXTEND THE DEVICE HEADER BEYOND
				;  ITS CURRENT FORM.

; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
;    MACHINES (FORMAT,CHKDSK,RECOVER,..).

DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
				;DEVICE SUPPORTS SET/GET MAP OF
				;LOGICAL DRIVES, AND SUPPORTS
				;GENERIC IOCTL CALLS.
				;FOR CHARACTER DEVICES, THIS
				;DEVICE SUPPORTS GENERIC IOCTL.
				;THIS IS A DOS 3.2 DEVICE DRIVER.

ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
;ISIBM	EQU     0010H		;Bit 4 - This device is special
ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.

;Static Reguest Header
struc	SRHEAD
.REQLEN:	resb 1		;Length in bytes of request block
.REQUNIT:	resb 1		;Device unit number
.REQFUNC:	resb 1		;Type of request
.REQSTAT:	resw 1		;Status Word
        	resb 8		;Reserved for queue links
.size:
endstruc

;Status word masks
STERR   EQU     8000H           ;Bit 15 - Error
STBUI   EQU     0200H           ;Bit 9 - Buisy
STDON   EQU     0100H           ;Bit 8 - Done
STECODE EQU     00FFH           ;Error code
WRECODE EQU     0

;Function codes
DEVINIT EQU     0               ;Initialization
DINITHL EQU     26              ;Size of init header
DEVMDCH EQU     1               ;Media check
DMEDHL  EQU     15              ;Size of media check header
DEVBPB  EQU     2               ;Get BPB
DEVRDIOCTL EQU  3               ;IOCTL read
DBPBHL  EQU     22              ;Size of Get BPB header
DEVRD   EQU     4               ;Read
DRDWRHL EQU     22              ;Size of RD/WR header
DEVRDND EQU     5               ;Non destructive read no wait (character devs)
DRDNDHL EQU     14              ;Size of non destructive read header
DEVIST  EQU     6               ;Input status
DSTATHL EQU     13              ;Size of status header
DEVIFL  EQU     7               ;Input flush
DFLSHL  EQU     15              ;Size of flush header
DEVWRT  EQU     8               ;Write
DEVWRTV EQU     9               ;Write with verify
DEVOST  EQU     10              ;Output status
DEVOFL  EQU     11              ;Output flush
DEVWRIOCTL EQU  12              ;IOCTL write

; 09/07/2018 - Retro DOS v3.0
; (DEVSYM.INC, MSDOS 3.3, 1987) 

DEVOPN	EQU	13		;DEVICE OPEN
DEVCLS	EQU	14		;DEVICE CLOSE
DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
DEVRMD	EQU	15		;REMOVABLE MEDIA
; 07/08/2018 - Retro DOS v3.0
REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
GENIOCTL EQU	19

; THE NEXT THREE ARE USED IN DOS 4.0
;		     20
;		     21
;		     22
DEVGETOWN      EQU   23		;GET DEVICE OWNER
DEVSETOWN      EQU   24		;SET DEVICE OWNER
OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER

DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY

; GENERIC IOCTL REQUEST STRUCTURE
;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
;

struc IOCTL_REQ
.SRHEAD:	resb SRHEAD.size
				; GENERIC IOCTL ADDITION.
.MAJORFUNCTION: resb 1		;FUNCTION CODE
.MINORFUNCTION: resb 1		;FUNCTION CATEGORY
.REG_SI:	resw 1
.REG_DI:	resw 1
.GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
.size: ; 07/08/2018
endstruc

; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
GEN_IOCTL_WRT_TRK EQU	40H
GEN_IOCTL_RD_TRK  EQU	60H
GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS

;============================================================================
; ERROR.INC (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS v3.0 

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX. If an error occurred then
;    the carry bit will be set and the error code is in AX. If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action. The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
error_file_not_found		EQU	2
error_path_not_found		EQU	3
error_too_many_open_files	EQU	4
error_access_denied		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
error_not_enough_memory 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
error_bad_format		EQU	11
error_invalid_access		EQU	12
error_invalid_data		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
error_no_more_files		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

error_write_protect		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
error_gen_failure		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
error_FCB_unavailable		EQU	35
error_sharing_buffer_exceeded	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;

;	BREAK <Interrupt 24 error codes>

;**	Int24 Error Codes

error_I24_write_protect 	EQU	0
error_I24_bad_unit		EQU	1
error_I24_not_ready		EQU	2
error_I24_bad_command		EQU	3
error_I24_CRC			EQU	4
error_I24_bad_length		EQU	5
error_I24_Seek			EQU	6
error_I24_not_DOS_disk		EQU	7
error_I24_sector_not_found	EQU	8
error_I24_out_of_paper		EQU	9
error_I24_write_fault		EQU	0Ah
error_I24_read_fault		EQU	0Bh
error_I24_gen_failure		EQU	0Ch
; NOTE: Code 0DH is used by MT-DOS.
error_I24_wrong_disk		EQU	0Fh

;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
;
;	NOTE: ABORT is ALWAYS allowed

Allowed_FAIL			EQU	00001000B
Allowed_RETRY			EQU	00010000B
Allowed_IGNORE			EQU	00100000B

I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
I24_area			EQU	00000110B  ; 00 if DOS
						   ; 01 if FAT
						   ; 10 if root DIR
						   ; 11 if DATA
I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char

;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>

;**	The GetExtendedError call takes an error code and returns CLASS,
;	ACTION and LOCUS codes to help programs determine the proper action
;	to take for error codes that they don't explicitly understand.

;	Values for error CLASS

errCLASS_OutRes 	EQU	1	; Out of Resource
errCLASS_TempSit	EQU	2	; Temporary Situation
errCLASS_Auth		EQU	3	; Permission problem
errCLASS_Intrn		EQU	4	; Internal System Error
errCLASS_HrdFail	EQU	5	; Hardware Failure
errCLASS_SysFail	EQU	6	; System Failure
errCLASS_Apperr 	EQU	7	; Application Error
errCLASS_NotFnd 	EQU	8	; Not Found
errCLASS_BadFmt 	EQU	9	; Bad Format
errCLASS_Locked 	EQU	10	; Locked
errCLASS_Media		EQU	11	; Media Failure
errCLASS_Already	EQU	12	; Collision with Existing Item
errCLASS_Unk		EQU	13	; Unknown/other

;	Values for error ACTION

errACT_Retry		EQU	1	; Retry
errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
errACT_User		EQU	3	; Ask user to regive info
errACT_Abort		EQU	4	; abort with clean up
errACT_Panic		EQU	5	; abort immediately
errACT_Ignore		EQU	6	; ignore
errACT_IntRet		EQU	7	; Retry after User Intervention

;	Values for error LOCUS

errLOC_Unk		EQU	1	; No appropriate value
errLOC_Disk		EQU	2	; Random Access Mass Storage
errLOC_Net		EQU	3	; Network
errLOC_SerDev		EQU	4	; Serial Device
errLOC_Mem		EQU	5	; Memory

;============================================================================
; MULT.INC (MSDOS 3.3, 1987)
;============================================================================

;Break <Critical section and Multiplex channels>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
; Critical section definitions
;
; These below are subject to leave-all sections
critDisk    EQU     1			; Disk I/O critical section
critDevice  EQU     2			; Device I/O critical section
critShare   EQU     1			; Sharer I/O critical section
critMem     EQU     1			; memory maintenance critical section
critNet     EQU     5			; network critical section
critSFT     EQU     1			; sft table allocation
; These below are not subject to leave-all sections
critASSIGN  EQU     8			; Assign has munged a system call
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;
; The current set of defined multiplex channels is (* means documented):
;
;   Channel(h)	Issuer		Receiver    Function
;      00	server		PSPRINT     print job control
;     *01	print/apps	PRINT	    Queueing of files
;      02	BIOS		REDIR	    signal open/close of printers
;
;      05	command 	REDIR	    obtain text of net int 24 message
;     *06	server/assign	ASSIGN	    Install check
;
;      08	external driver IBMBIO	    interface to internal routines
;
;      10	sharer/server	Sharer	    install check
;      11	DOS/server	Redir	    install check/redirection funcs
;      12	sharer/redir	DOS	    dos functions and structure maint
;      13	MSNET		MSNET	    movement of NCBs
;      14	DOS		NLSFUNC     down load NLS country info,DOS 3.3
;      14	Apps		Popup	    DOS 4.XX popup screen functions
;	  ***> NOTE <***  Yes there are 2 users of 14h but since DOS 4.XX
;			  doesn't use NLSFUNC, there is no conflict
;      15	Apps		MSCDEX	    CD-ROM redirector interface
;      16	Winoldap (?)	WIN386	    Private Windows communication
;      17	Winoldap (?)	WIN386	    Win386 clipboard interface
;      18	Apps		MS-Manager  Toggle interface to manager
;      19,(13h) external driver IBMBIO	    Reset_Int_13, allows installation
;					    of alternative INT_13 drivers after
;					    boot_up
;      B0	GRAFTABL	GRAFTABL
;

MultSHARE   EQU     10h 		; sharer
    ;	1   MFT_enter
    ;	2   MFTClose
    ;	3   MFTclU
    ;	4   MFTCloseP
    ;	5   MFTCloN
    ;	6   set_block
    ;	7   clr_block
    ;	8   chk_block
    ;	9   MFT_get
    ;	10  ShSave
    ;	11  ShChk
    ;	12  ShCol
    ;	13  ShCloseFile

MultNET     EQU     11h 		; Network support
    ;	1   NET_RMDIR
    ;	2   NET_SEQ_RMDIR
    ;	3   NET_MKDIR
    ;	4   NET_SEQ_MKDIR
    ;	5   NET_CHDIR
    ;	6   NET_CLOSE
    ;	7   NET_COMMIT
    ;	8   NET_READ
    ;	9   NET_WRITE
    ;	10  NET_LOCK
    ;	11  NET_UNLOCK
    ;	12  NET_DISK_INFO
    ;	13  NET_SET_FILE_ATTRIBUTE
    ;	14  NET_SEQ_SET_FILE_ATTRIBUTE
    ;	15  NET_GET_FILE_INFO
    ;	16  NET_SEQ_GET_FILE_INFO
    ;	17  NET_RENAME
    ;	18  NET_SEQ_RENAME
    ;	19  NET_DELETE
    ;	20  NET_SEQ_DELETE
    ;	21  NET_OPEN
    ;	22  NET_SEQ_OPEN
    ;	23  NET_CREATE
    ;	24  NET_SEQ_CREATE
    ;	25  NET_SEQ_SEARCH_FIRST
    ;	26  NET_SEQ_SEARCH_NEXT
    ;	27  NET_SEARCH_FIRST
    ;	28  NET_SEARCH_NEXT
    ;	29  NET_ABORT
    ;	30  NET_ASSOPER
    ;	31  Printer_SET_STRING
    ;	32  NetFlushBuf
    ;	33  NetBufWrite
    ;	34  NetResetEnvironment
    ;	35  NetSpoolCheck
    ;	36  NetSpoolClose

MultDOS     EQU     12h 		; DOS call back
    ;	1   DOS_CLOSE
    ;	2   RECSET
    ;	3   Get DOSGROUP
    ;	4   PATHCHRCMP
    ;	5   OUT
    ;	6   NET_I24_ENTRY
    ;	7   PLACEBUF
    ;	8   FREE_SFT
    ;	9   BUFWRITE
    ;	10  SHARE_VIOLATION
    ;	11  SHARE_ERROR
    ;	12  SET_SFT_MODE
    ;	13  DATE16
    ;	14  SETVISIT
    ;	15  SCANPLACE
    ;	16  SKIPVISIT
    ;	17  StrCpy
    ;	18  StrLen
    ;	19  UCase
    ;	20  POINTCOMP
    ;	21  CHECKFLUSH
    ;	22  SFFromSFN
    ;	23  GetCDSFromDrv
    ;	24  Get_User_Stack
    ;	25  GetThisDrv
    ;	26  DriveFromText
    ;	27  SETYEAR
    ;	28  DSUM
    ;	29  DSLIDE
    ;	30  StrCmp
    ;	31  initcds
    ;	32  pjfnfromhandle
    ;	33  $NameTrans
    ;	34  CAL_LK
    ;	35  DEVNAME
    ;	36  Idle
    ;
NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
    ;	0   NLSInstall
    ;	1   ChgCodePage
    ;	2   GetExtInfo
    ;	3   SetCodePage
    ;	4   GetCntry
    ;
;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
;	  it calls Multdos 42 to set up an entry routine address
    ;	0   Install status  (reserved)
    ;	1   Lookup
    ;	2   Insert
    ;	3   Delete
    ;	4   Purge	    (reserved)

;============================================================================
; FIND.INC (MSDOS 3.3, 1987)
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;Break	<find first/next buffer>

struc find_buf
.drive:	    resb 1		; drive of search
.name:	    resb 11		; formatted name
.sattr:	    resb 1		; attribute of search
.LastEnt:   resw 1		; LastEnt
.DirStart:  resw 1		; DirStart
.attr:	    resb 1		; attribute found
.time:	    resw 1		; time
.date:	    resw 1		; date
.size_l:    resw 1		; low(size)
.size_h:    resw 1		; high(size)
.pname:	    resb 13		; packed name
.size:
endstruc

;============================================================================
; DOSCNTRY.INC (MSDOS 3.3, 1987)
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;Equates for COUNTRY INFORMATION.
SetCountryInfo	EQU	1	;country info
SetUcase	EQU	2	;uppercase table
SetLcase	EQU	3	;lowercase table (Reserved)
SetUcaseFile	EQU	4	;uppercase file spec table
SetFileList	EQU	5	;valid file character list
SetCollate	EQU	6	;collating sequence
SetDBCS 	EQU	7	;double byte character set
SetALL		EQU	-1	;all the entries


;DOS country and code page information table structure.
;Internally, IBMDOS gives a pointer to this table.
;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
;this structure.
struc  DOS_CCDPG	; DOS_country_cdpg_info
.ccInfo_reserved: 	resb 8	;reserved for internal use
.ccPath_CountrySys:	resb 64 ;path and filename for country info
.ccSysCodePage:		resw 1	;system code page id
.ccNumber_of_entries:	resw 1  ; (default value = 5)
.ccSetUcase:		resb 1  ; (default value = SetUcase)
.ccUcase_ptr:		resd 1	;pointer to Ucase table

.ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
.ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table

.ccSetFileList:		resb 1 	; (default value = SetFileList)
.ccFileChar_ptr:	resd 1	;pointer to File char list table

.ccSetCollate:		resb 1	; (default value = SetCollate)
.ccCollate_ptr:		resd 1	;pointer to collate table

.ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
.ccCountryInfoLen:	resw 1	;length of country info
.ccDosCountry:		resw 1	;system country code id
.ccDosCodePage:		resw 1	;system code page id
.ccDFormat:		resw 1	;date format
.ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
.cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
.ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
.ccDateSep:		resb 2	;2 byte of (date sep. + 0)
.ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
.ccCFormat:		resb 1	;currency format flags
.ccCSigDigits:		resb 1	;# of digits in currency
.ccTFormat:		resb 1	;time format
.ccMono_Ptr:		resd 1	;monocase routine entry point
.ccListSep:		resb 2	;data list separator
.ccReserved_area: 	resw 5	;reserved
.size:
endstruc

;Ucase table
struc CC_UCASE_TAB
.ccUcase_leng:		resw 1	; (default value = 128)
.ccUcase_data:		resb 128
endstruc

;File Ucase table
struc CC_FILE_UCASE_TAB
.ccFileucase_leng:	resw 1	; (default value = 128)
.ccFileucase_data:	resb 128
endstruc

;File char list
struc CC_FILE_CHAR_TAB
.ccFilechar_leng:	resw 1
.ccFilechar_data:	resb 46
endstruc

;collate table
struc CC_COLLATE_TAB
.ccCollate_leng:	resw 1	; (default value = 128)
.ccCollate_data:	resb 256
endstruc

OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) 

; 06/08/2018
; DOSCNTRY.INC (MSDOS 6.0, 1991)

;CAPITALIZATION equates
CAP_ONE_CHAR	equ	20H
CAP_STRING	equ	21H
CAP_ASCIIZ	equ	22H
CHECK_YES_NO	equ	23H
UPPER_TABLE	equ	80H

;NLS_YES	equ	59H  ; 'Y'
;NLS_yes2	equ	79H  ; 'y' 	
;NLS_NO		equ	4EH  ; 'N'	
;NLS_no2	equ	6EH  ; 'n'	

;============================================================================
; CURDIR.INC (MSDOS 3.3, 1987)
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;BREAK <Current directory list structure>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
; CDS items are used bu the internal routines to store cluster numbers and ;
; network identifiers for each logical name.  The ID field is used dually, ;
; both as net ID and for a cluster number for local devices.  In the case  ;
; of local devices, the cluster number will be -1 if there is a potential  ;
; of the disk being changed or if the path must be recracked.  The END	   ;
; field is the location of the end of the definition.  No .. is allowed    ;
; past this point							   ;

DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

struc curdir	; curdir_list
.text:		resb DIRSTRLEN		; text of assignment and curdir
.flags:		resw 1			; various flags
.devptr:	resd 1			; local pointer to DPB or net device
.ID:		resw 1			; cluster of current dir (net ID)
		resw 1
.user_word:	resw 1
.end:		resw 1			; end of assignment
.size:
endstruc

curdirLen	EQU curdir.size		; Needed for screwed up

%define curdir_netID curdir_ID  ; dword

;Flag word masks
curdir_isnet	EQU	1000000000000000B
curdir_inuse	EQU	0100000000000000B
curdir_splice	EQU	0010000000000000B
curdir_local	EQU	0001000000000000B
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;============================================================================
; CPMFCB.INC (MSDOS 3.3, 1987)
;============================================================================
; 09/07/2018 - Retro DOS v3.0

;BREAK <File Control Block definition>

;
; Field definition for FCBs
; The FCB has the following structure:
;
;	+---------------------------+
;	|   Drive indicator(byte)   |
;	+---------------------------+
;	|    Filename (8 chars)     |
;	+---------------------------+
;	|    Extension (3 chars)    |
;	+---------------------------+
;	|   Current Extent(word)    |
;	+---------------------------+
;	|    Record size (word)     |
;	+---------------------------+
;	|    File Size (2 words)    |
;	+---------------------------+
;	|	Date of write	    |
;	+---------------------------+
;	|	Time of write	    |
;	+---------------------------+
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
;	+---------------------------+
;	|   8 bytes reserved	    |
;	+---------------------------+
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	|    next record number     |
;	+---------------------------+
;	|   random record number    |
;	+---------------------------+
;

struc	SYS_FCB
.drive:	resb 1
.name:	resb 8
.ext:	resb 3
.EXTENT: resw 1
.RECSIZ: resw 1			; Size of record (user settable)
.FILSIZ: resw 1			; Size of file in bytes; used with the
				; following word
.DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
.FDATE:	resw 1			; Date of last writing
.FTIME:	resw 1			; Time of last writing
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
.reserved: resb 8		; RESERVED
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
.NR:	resb 1			; Next record
.RR:	resb 4			; Random record
endstruc

FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
				; NEXT
; 20/07/2018
%define fcb_sfn	SYS_FCB.reserved ; byte

; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
; all must point to the same byte.  Otherwise, the FCBRegen will fail.
; NOTE about this byte (fcb_nsl_drive)
;   The high two bits of this byte are used as follows to indicate the FCB type
;	00 means a local file or device with sharing loaded
;	10 means a remote (network) file
;	01 means a local file with no sharing loaded
;	11 means a local device with no sharing loaded

; 20/07/2018

;
; Network FCB
;

%define fcb_net_drive	SYS_FCB.reserved+1  ; byte
%define fcb_net_handle	SYS_FCB.reserved+2  ; word
%define fcb_netID	SYS_FCB.reserved+4  ; dword		

;
; No sharing local file FCB
;

%define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
%define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
%define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
%define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
%define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte

;
; No sharing local device FCB
;

%define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
%define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword

;
; Sharing local FCB
;

%define fcb_l_drive	SYS_FCB.reserved+1  ; byte
%define fcb_l_firclus	SYS_FCB.reserved+2  ; word
%define fcb_l_mfs	SYS_FCB.reserved+4  ; word
%define fcb_l_attr	SYS_FCB.reserved+6  ; byte

;
; Bogusness:  the four cases are:
;
;   local file	    00
;   local device    40
;   local sharing   C0
;   network	    80
;
; Since sharing and network collide, we cannot use a test instruction for
; deciding whether a network or a share check in involved
;
FCBDEVICE   EQU 040h
FCBNETWORK  EQU 080h
FCBSHARE    EQU 0C0h

; FCBSPECIAL must be able to mask off both net and share
FCBSPECIAL  EQU 080h
FCBMASK     EQU 0C0h

;============================================================================
; FASTOPEN.INC, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0

struc	FEI	; FASTOPEN_EXTENDED_INFO
.dirpos:	resb 1
;.dirsec:	resd 1 ; MSDOS 6.0
.dirsec:	resw 1 ; MSDOS 3.3
.clusnum:	resw 1
;.lastent:	resw 1	; for search first ; MSDOS 6.0
;.dirstart:	resw 1	; for search first ; MSDOS 6.0
.size:
endstruc

; 23/07/2018
;FASTOPEN NAME CACHING Subfunctions
FONC_Look_up	equ	1
FONC_insert	equ	2
FONC_delete	equ	3
FONC_update	equ	4
FONC_purge	equ	5	;reserved for the future use.
FONC_Rename	equ	6	;AN001

; 27/07/2018
;FastOpen Data Structure
struc fastopen_entry	;Fastopen Entry pointer in DOS
.entry_size:	resw 1	; = 4	; size of the following
.name_caching:	resd 1
; MSDOS 6.0
;.fatchain_caching: resd 1	;reserved for future use
.size:
endstruc

; 27/07/2018
;Equates used in DOS.
FastOpen_Set	       equ     00000001b
FastOpen_Reset	       equ     11111110b
Lookup_Success	       equ     00000010b
Lookup_Reset	       equ     11111101b
Special_Fill_Set       equ     00000100b
Special_Fill_Reset     equ     11111011b
No_Lookup	       equ     00001000b
Set_For_Search	       equ     00010000b	;DCR 167

; 09/08/2018 
; (FASTXXXX.INC, MSDOS 6.0, 1991)
; Fastxxx equates
FastOpen_ID	   equ	   1
FastSeek_ID	   equ	   2
Fast_yes	   equ	   10000000B	 ; fastxxx flag

;Structure definitions
;
struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
.Fast_Entry_Num: resw 1	 ; number of entries
.FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
endstruc

;============================================================================
; LOCK.INC, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

;**	LOCK.INC - Definitions for Record Locking

;**	LOCK functions

LOCK_ALL	    equ    0
UNLOCK_ALL	    equ    1
LOCK_MUL_RANGE	    equ    2
UNLOCK_MUL_RANGE    equ    3
LOCK_READ	    equ    4
WRITE_UNLOCK	    equ    5
LOCK_ADD	    equ    6

;**	Structure for Lock buffer

struc LockBuf
.Lock_position:	resd 1		; file position for LOCK
.Lock_length:	resd 1		; number of bytes to LOCK
endstruc

;============================================================================
; DPL.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0

; (SRVCALL.ASM)

struc DPL
.AX:	resw	1	; AX register
.BX:	resw	1	; BX register
.CX:	resw	1	; CX register
.DX:	resw	1	; DX register
.SI:	resw	1	; SI register
.DI:	resw	1	; DI register
.DS:	resw	1	; DS register
.ES:	resw	1	; ES register
.rsrvd: resw	1	; Reserved
.UID:	resw	1	; User (Machine) ID (0 = local macine)
.PID:	resw	1	; Process ID (0 = local user PID)
.size:
endstruc
 
;============================================================================
; MSDATA.ASM
;============================================================================
;============================================================================
; MS_DATA.ASM (MSDOS 6.0, 1991) (1)
;============================================================================
; 16/07/2018 - Retro DOS 3.0	

;Break <Uninitialized data overlayed by initialization code>

;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
; Init code overlaps with data area below

		; Offset 0358h in IBMDOS.COM (MSDOS 3.3)

;	I_am    TIMEBUF,6               ; Time read from clock device
;	I_am    DEVIOBUF,2              ; Buffer for I/O under file assignment

TIMEBUF		EQU 	DATASEGMENT	; Offset 0358h (in IBMDOS.COM 3.3)
DEVIOBUF	EQU	TIMEBUF+6
;
; The following areas are used as temp buffer in EXEC system call
;
;       I_am    OPENBUF,128             ; buffer for name operations
;       I_am    RenBuf,128              ; buffer for rename destination

OPENBUF		EQU	DEVIOBUF+2	; DATASEGMENT+8 
RENBUF		EQU	OPENBUF+128	; DATASEGMENT+136

; Buffer for search calls
;        I_am    SEARCHBUF,53		; internal search buffer
;        I_am    DummyCDS,curdirLen

SEARCHBUF	EQU	RENBUF+128	; DATASEGMENT+264
DUMMYCDS	EQU	SEARCHBUF+53	; DATASEGMENT+317 
						; Offset 495h in MSDOS 3.3
;
; End of contiguous buffer
;

; Temporary directory entry for use by many routines.  Device directory
; entries (bogus) are built here.
;
;        PUBLIC  DevFCB
;DEVFCB  LABEL   BYTE                    ; Uses NAME1, NAME2, combined
; WARNING.. do not alter position of NAME1 relative to DEVFCB
; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
; as well as it is the only guy who uses NAME2 and DESTSTART.

DEVFCB		EQU	DUMMYCDS+curdirLen ; DATASEGMENT+398

;	I_am    NAME1,12                ; File name buffer
;       I_am    NAME2,13                ;
;	I_am    DESTSTART,WORD          ;
;	DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)

NAME1		EQU	DEVFCB		; Offset 04E6h in IBMDOS.COM 3.3
NAME2		EQU	NAME1+12	; DATASEGMENT+410
DESTSTART	EQU	NAME2+13	; DATASEGMENT+423

;
; End Temporary directory entry.
;

;       I_am    ATTRIB,BYTE             ; storage for file attributes
;	I_am    EXTFCB,BYTE             ; TRUE => extended FCB in use

ATTRIB		EQU	DEVFCB + dir_entry.size ; Offset 0506h
	; Offset 0507h in IBMDOS.COM (MSDOS 3.3) 
EXTFCB		EQU	ATTRIB+1	; DATASEGMENT+431

;       I_am    SATTRIB,BYTE            ; Storage for search attributes
;       I_AM    open_access,BYTE        ; access of open system call
;       I_am    FoundDel,BYTE           ; true => file was deleted
;       I_am    Found_dev,BYTE          ; true => search found a device
;       I_am    fSplice,BYTE            ; true => do a splice in transpath
;       I_am    fSharing,BYTE           ; TRUE => no redirection
;       I_am    SECCLUSPOS,BYTE         ; Position of first sector within cluster
;       I_am    TRANS,BYTE              ;
;       I_am    READOP,BYTE             ;
;       I_am    THISDRV,BYTE            ;
;       I_am    CLUSFAC,BYTE            ;
;       I_am    CLUSSPLIT,BYTE          ;
;       I_am    INSMODE,BYTE            ; true => insert mode in buffered read
;       I_am    cMeta,BYTE              ; count of meta'ed components found
;       I_am    VOLID,BYTE              ;
;       I_am    exit_type,BYTE          ; type of exit...

SATTRIB		EQU	EXTFCB+1	; DATASEGMENT+432
OPEN_ACCESS	EQU	SATTRIB+1	; DATASEGMENT+433
FOUNDDEL	EQU	OPEN_ACCESS+1	; DATASEGMENT+434
FOUND_DEV	EQU	FOUNDDEL+1	; DATASEGMENT+435
FSPLICE		EQU	FOUND_DEV+1	; DATASEGMENT+436
FSHARING	EQU	FSPLICE+1	; DATASEGMENT+437
SECCLUSPOS	EQU	FSHARING+1	; DATASEGMENT+438
TRANS		EQU	SECCLUSPOS+1	; DATASEGMENT+439
READOP		EQU	TRANS+1		; DATASEGMENT+440	
THISDRV		EQU	READOP+1	; DATASEGMENT+441
CLUSFAC		EQU	THISDRV+1	; DATASEGMENT+442
CLUSSPLIT	EQU	CLUSFAC+1	; DATASEGMENT+443
INSMODE		EQU	CLUSSPLIT+1	; DATASEGMENT+444
CMETA		EQU	INSMODE+1	; DATASEGMENT+445
VOLID		EQU	CMETA+1		; DATASEGMENT+446
EXIT_TYPE	EQU	VOLID+1		; DATASEGMENT+447
        
;	EVEN

; WARNING - the following two items are accessed as a word

;	I_am    CREATING,BYTE           ; true => creating a file
;	I_am	DELALL,BYTE		; = 0 iff BUGBUG
;					; = DIRFREE iff BUGBUG
;	I_am    EXITHOLD,DWORD          ; Temp location for proc terminate
;	I_am    user_SP,WORD            ; User SP for system call
;	I_am    user_SS,WORD            ; User SS for system call
;	I_am    CONTSTK,WORD            ;
;	I_am    THISDPB,DWORD           ;
;	I_am    CLUSSAVE,WORD           ;
; MSDOS 3.3
;	I_am    CLUSSEC,WORD		;	
;; MSDOS 6.0
;;	I_am    CLUSSEC,DWORD           ;>32mb         ; AC0000

	; Offset 0518h in IBMDOS.COM (MSDOS 3.3) 

CREATING	EQU	EXIT_TYPE+1 	; DATASEGMENT+448
	; (End of 'MOVDPB' (in MSINIT) - Offset 0519h (just after 'retf'))
DELALL		EQU	CREATING+1	; DATASEGMENT+449
EXITHOLD	EQU	DELALL+1	; DATASEGMENT+450
USER_SP		EQU	EXITHOLD+4	; DATASEGMENT+454
USER_SS		EQU	USER_SP+2	; DATASEGMENT+456
CONTSTK		EQU	USER_SS+2	; DATASEGMENT+458	
THISDPB		EQU	CONTSTK+2	; DATASEGMENT+460
CLUSSAVE	EQU	THISDPB+4	; DATASEGMENT+464
CLUSSEC		EQU	CLUSSAVE+2	; Offset 052Ah ; DATASEGENT+466

;       I_am    PREREAD,WORD            ; 0 means preread; 1 means optional
;       I_am    FATBYT,WORD             ; Used by ALLOCATE
;       I_am    FATBYTE,WORD            ; Used by $SLEAZEFUNC
;       I_am    DEVPT,DWORD             ;
;       I_am    THISSFT,DWORD           ; Address of user SFT
;       I_am    THISCDS,DWORD           ; Address of current CDS
;       I_am    THISFCB,DWORD           ; Address of user FCB

; MSDOS 3.3
PREREAD		EQU	CLUSSEC+2	; OffseT 052Ch ; DATASEGMENT+468

; MSDOS 6.0
; PREREAD	EQU	CLUSSEC+4

FATBYT		EQU	PREREAD+2	; DATASEGMENT+470
FATBYTE		EQU	FATBYT+2	; Offset 0530h ; DATASEGMENT+472
DEVPT		EQU	FATBYTE+2	; DATASEGMENT+474	
THISSFT		EQU	DEVPT+4		; Offset 0536h ; DATASEGMENT+478
THISCDS		EQU	THISSFT+4	; DATASEGMENT+482	
THISFCB		EQU	THISCDS+4	; DATASEGMENT+486

; DATASEGMENT+490 :  ; *!!!*
	; Here is offset 0542h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 
;SFN		EQU	THISFCB+4	; DATASEGMENT + 0542h - 0358h

;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
;       I_am    WFP_START,WORD          ;
;       I_am    REN_WFP,WORD            ;
;       I_am    CURR_DIR_END,WORD       ;
;       I_am    NEXTADD,WORD            ;
;       I_am    LASTPOS,WORD            ;
;       I_am    CLUSNUM,WORD            ;
;       I_am    DIRSEC,DWORD            ;>32mb 		; AC0000
;       I_am    DIRSTART,WORD           ;
;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
;                                       ; sectors
;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
;       I_am    BYTPOS,4                ; Byte position in file of access
;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
;       I_am    SECCNT,WORD             ; No. of whole sectors
;       I_am    ENTFREE,WORD            ;
;       I_am    ENTLAST,WORD            ;
;       I_am    NXTCLUSNUM,WORD         ;
;       I_am    GROWCNT,DWORD           ;
;       I_am    CURBUF,DWORD            ;
;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
;       I_am    SAVEBX,WORD             ;
;       I_am    SAVEDS,WORD             ;
;       I_am    restore_tmp,WORD        ; return address for restore world
;       I_am    NSS,WORD
;       I_am    NSP,WORD	

;	....  [ MS_DATA.ASM (MSDOS 6.0, 1991) (2) ] ; $$$

;DOSDATA ENDS

;============================================================================
; MSHEAD.ASM
;============================================================================

[BITS 16]
[ORG 0]

START:
        JMP     DOSINIT

;============================================================================
; MSHEAD.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0

	; MSDOS 6.0
;	dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
;BioDataSeg:
;	dw	0070h		; Bios data segment fixed at 70h

	; MSDOS 3.3
	dw	0
	db	0 ; 12/08/2018
	db	"BUG "
	dw	0
	dw	0

;============================================================================
; MSCONST.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0	

	; MSDOS 3.3
MYNUM:			; Offset 000Eh
	dw	0	
FCBLRU: 
	dw	0
OpenLRU:
	dw	0
OEM_HANDLER: 		; Pointer to OEM handler code	
	dd	-1
LeaveAddr:
	;dd	LeaveDOS
	dw	LeaveDOS ; 12/08/2018
RetryCount:		; Share retries
	dw	3
RetryLoop:
	dw	1
LastBuffer:
	dd	-1	; Buffer queue recency pointer
CONTPOS:
	dw	0	; location in buffer of next read
arena_head:
	dw	0	; Segment # of first arena in memory

;; 16/07/2018
;;****************************************************************************
;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
;;****************************************************************************
;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
;;
;;	AH = 52h
;;
;;	on return:
;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
;;		Known "invars" fields follow (varies with DOS version):
;;
;;	Offset Size		 Description
;;
;;	 -12   word   sharing retry count (DOS 3.1-3.3)
;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
;;	  -4   word   pointer in DOS code segment of unread CON input;
;;		      0 indicates no unread input (DOS 3.x)
;;	  -2   word   segment of first Memory Control Block (MCB)
;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
;;	  04   dword  pointer to DOS System File Table (SFT)
;;	  08   dword  pointer to $CLOCK device driver
;;	  0C   dword  pointer to CON device driver
;;	  10   byte   number of logical drives in system
;;	  11   word   maximum bytes/block of any block device
;;	  13   dword  pointer to DOS cache buffer header
;;	  17 18bytes  NUL device header, first 4 bytes of device header
;;		      point to the next device in device chain
;;
;;****************************************************************************

; The following block of data is used by SYSINIT.  Do not change the order or
; size of this block


; The following block of data is used by SYSINIT. 
; Do not change the order or size of this block

;SYSINITVAR:
SYSINITVARS:
DPBHEAD:
	dd	0	; Pointer to head of DPB-FAT list
SFT_ADDR:
	dd	SFTABL	; Pointer to first SFT table
BCLOCK:
	dd	0	; The CLOCK device
BCON:
	dd	0	; Console device entry points
MAXSEC:
	dw	128	; Maximum allowed sector size
BUFFHEAD:
	dd	0	; Pointer to head of buffer queue
CDSADDR:
	dd	0	; Pointer to curdir structure table
SFTFCB:
	dd	0	; pointer to FCB cache table
KEEPCOUNT:
	dw	0	; count of FCB opens to keep
NUMIO:
	db	0	; Number of disk tables
CDSCOUNT:
	db	0	; Number of CDS structures in above
; A fake header for the NUL device
NULDEV:
	dd	0	; Link to rest of device list
	;dw	8004h
	dw	DEVTYP | ISNULL	; Null device attributes
	dw	SNULDEV	; Strategy entry point
	dw	INULDEV	; Interrupt entry point
	db	"NUL     " ; Name of null device
SPLICES:
	db	0	; TRUE => splices being done

	; MSDOS 6.0 
;Special_Entries:
;	dw	0	; address of special entries	;AN000;
;UU_IFS_DOS_CALL:
;	dd	0	; entry for IFS DOS service	;AN000;
;; 
;; UU_IFS_HEADER:
;; 	dd	0	; IFS header chain		;AN000;
;;
;ChkCopyProt:
;	dw	0	; M068
;A20OFF_PSP:
;	dw	0	; M068
;BUFFERS_PARM1:
;	dw	0	; value of BUFFERS= ,m 	;AN000;
;BUFFERS_PARM2:
;	dw	0	; value of BUFFERS= ,n 	;AN000
;BOOTDRIVE:
;	db	0	; the boot drive	;AN000;
;DDMOVE:
;	db	0 	; 1 if we need DWORD move ;AN000;
;EXT_MEM_SIZE:
;	dw	0	; extended memory size 	;AN000;

;HASHINITVAR: ; LABEL   WORD	; AN000;
;;
;; Replaced by next two declarations
;;
;;UU_BUF_HASH_PTR:
;;	dd	0	; buffer Hash table addr
;;UU_BUF_HASH_COUNT:
;;	dw	1	; number of Hash entries
;
;BufferQueue:
;	dd	0	; Head of the buffer Queue
;DirtyBufferCount:
;	dw	0	; Count of Dirty buffers in the Que
;			; BUGBUG ---- change to byte
;SC_CACHE_PTR:
;	dd	0	; secondary cache pointer
;SC_CACHE_COUNT:
;	dw	0 	; secondary cache count
;BuffInHMA:
;	db	0	; Flag to indicate that buffs are in HMA
;LoMemBuff:
;	dd	0	; Ptr to intermediate buffer
;			;  in Low mem when buffs are in HMA
;;
;; All variables which have UU_ as prefix can be reused for other
;; purposes and can be renamed. All these variables were used for
;; EMS support of Buffer Manager. Now they are useless for Buffer
;; manager ---- MOHANS
;;
;
;	I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
;UU_BUF_EMS_FIRST_PAGE:	
;	db	0,0,0	; holds the first page above 640K
;
;;	I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
;;					   ; above 640K
;;UU_BUF_EMS_NPA640:
;;	dw	0			
;
;CL0FATENTRY:
;	dw	-1	; M014:	Holds the data that
;			; is used in pack/unpack rts.
;			; in fat.asm if cluster 0 is specified.
;			; SR;
;IoStatFail:
;	db	0	; IoStatFail has been added to 
;			; record a fail on an I24 
;			; issued from IOFUNC on a status call. 
;
;;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
;;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
;;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
;;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
;;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
;;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
;
;;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
;						; state of the 	buffers page.
;						; This one byte is retained to 
;						; keep the size of this data 
;						; block the same.;
;ALLOCMSAVE:
;	db	0	; M063: temp var. used to 
;			; M063: save alloc method in
;			; M063: msproc.asm
;A20OFF_COUNT:
;	db	0	; M068: indiactes the # of 
;			; M068: int 21 calls for 
;			; M068: which A20 is off
;DOS_FLAG:
;	db	0	; see DOSSYM.INC for Bit 
;			; definitions
;UNPACK_OFFSET:
;	dw	0	; saves pointer to the start
;			; of unpack code in exepatch.
;			; asm.
;UMBFLAG:
;	db	0 	; M003: bit 0 indicates the 
;			; M003: link state of the UMBs
;			; M003: whether linked or not 
;			; M003: to the DOS arena chain
;SAVE_AX:
;	dw	0	; M000: temp varibale to store ax
;			; M000: in msproc.asm
;UMB_HEAD:
;	dw	-1	; M000: this is initialized to  
;			; M000: the first umb arena by 
;			; M000: BIOS sysinit.
;START_ARENA:
;	dw	1	; M000: this is the first arena 
;			; M000: from which DOS will 
;			; M000: start its scan for alloc.

; End of SYSINITVar block

; 16/07/2018
; MSDOS 3.3 (& MDOS 6.0)

;
; Sharer jump table
;

;PUBLIC	JShare
	;EVEN
align 2

JShare: ; LABEL	DWORD
		DW	BadCall,0
MFT_enter	DW	OKCall, 0  ; 1   MFT_enter
MFTClose	DW	OKCall, 0  ; 2   MFTClose
MFTclU		DW	BadCall,0  ; 3   MFTclU
MFTCloseP	DW	BadCall,0  ; 4   MFTCloseP
MFTCloN		DW	BadCall,0  ; 5   MFTCloN
set_block	DW	BadCall,0  ; 6   set_block
clr_block	DW	BadCall,0  ; 7   clr_block
chk_block	DW	OKCall, 0  ; 8   chk_block
MFT_get		DW	BadCall,0  ; 9   MFT_get
ShSave		DW	BadCall,0  ; 10  ShSave
ShChk		DW	BadCall,0  ; 11  ShChk
ShCol		DW	OKCall, 0  ; 12  ShCol
ShCloseFile	DW	BadCall,0  ; 13  ShCloseFile
ShSU		DW	BadCall,0  ; 14  ShSU

;============================================================================
; CONST2.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0	

;Break <Initialized data and data used at DOS initialization>

;
; We need to identify the parts of the data area that are relevant to tasks
; and those that are relevant to the system as a whole.  Under 3.0, the system
; data will be gathered with the system code.  The process data under 2.x will
; be available for swapping and under 3.0 it will be allocated per-process.
;
; The data that is system data will be identified by [SYSTEM] in the comments
; describing that data item.

;	AsmVars <Debug, Redirector, ShareF>

;DOSDATA SEGMENT WORD PUBLIC 'DATA'

;
; Table of routines for assignable devices
;
; MSDOS allows assignment if the following standard devices:
;   stdin  (usually CON input)
;   stdout (usually CON output)
;   auxin  (usually AUX input)
;   auxout (usually AUX output)
;   stdlpt (usually PRN output)
;
; SPECIAL NOTE:
;   Status of a file is a strange idea. We choose to handle it in this manner:
;   If we're not at end-of-file, then we always say that we have a character.
;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
;   manner we can support program written under the old DOS (they use ^Z as EOF
;   on devices) and programs written under the new DOS (they use the ZERO flag
;   as EOF).

; Default SFTs for boot up

		;PUBLIC	SFTABL

SFTABL:	   ; LABEL   DWORD		; file table
		DW -1			; link to next table
		DW -1			; link seg to next table
		DW sf_default_number	; Number of entries in table
		times (sf_default_number*sf_entry_size) db 0

; the next two variables relate to the position of the logical stdout/stdin
; cursor. They are only meaningful when stdin/stdout are assigned to the
; console.

		; Offset 01A7h in IBMDOS.COM (MSDOS 3.3)
CARPOS:		db 0			; cursor position in stdin
STARTPOS:	db 0			; position of cursor at beginning
INBUF:		times 128 db 0		; general device input buffer
CONBUF:		times 131 db 0		; The rest of INBUF and console buffer
		; Offset 02ACh in IBMDOS.COM (MSDOS 3.3)
PFLAG:		db 0			; printer echoing flag
VERFLG:		db 0			; Initialize with verify off
CHARCO:		db 00000011b		; Allows statchks every 4 chars...
switch_character:
chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
AllocMethod:	db 0			; how to alloc first(best)last
fShare:		db 0			; TRUE => sharing installed
DIFFNAM:	db 1			; Indicates when MYNAME has changed                                        ; of buffered input call
MYNAME:		times 16 db 20h		; My network name

;
; The following table is a list of addresses that the sharer patches to be
; PUSH AX to enable the critical sections
;
		; Offset 02C3h in IBMDOS.COM (MSDOS 3.3)

;PUBLIC	CritPatch

CritPatch:	; LABEL WORD

;IRP sect,<critDisk,critDevice>

;IF (NOT REDIRECTOR) AND (NOT SHAREF)
;
;SR; Change code patch address to a variable in data segment
;
;       dw OFFSET DOSDATA: redir_patch
;       dw OFFSET DOSDATA: redir_patch
;
;;hkn	Short_Addr  E&sect
;;hkn	Short_Addr  L&sect
;
;ELSE
;	DW	0
;	DW	0
;ENDIF
;ENDM
;	DW	0

	; 16/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3), offset 02C3h
 
	dw 	EcritDisk
	dw 	LcritDisk			
	dw	EcritDevice
	dw 	LcritDevice

	dw	0

;
; WARNING!!!  PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
; Also, IBM server 1.0 requires this also.
;
	;EVEN			; Force swap area to start on word boundry
align 2
	;PUBLIC	SWAP_START
SWAP_START:	; LABEL BYTE
ERRORMODE:	db 0		; Flag for INT 24 processing
INDOS:		db 0		; DOS status for interrupt processing
WPERR:		db -1		; Write protect error flag
EXTERR_LOCUS:	db 0		; Extended Error Locus
EXTERR:		dw 0		; Extended Error code

;WARNING Following two bytes Accessed as word in $GetExtendedError
EXTERR_ACTION:	db 0		; Extended Error Action
EXTERR_CLASS:	db 0		; Extended Error Class
; end warning
 
EXTERRPT:	dd 0		; Extended Error pointer

DMAADD:		dw 80H		; User's disk transfer address (disp/seg)
                dw 0	
CurrentPDB:	dw 0		; Current process identifier
ConC_Spsave:	dw 0		; saved SP before ^C
exit_code:	dw 0		; exit code of last proc.
CURDRV:		db 0		; Default drive (init A)
CNTCFLAG:	db 0		; ^C check in dispatch disabled
;				; F.C. 2/17/86
;CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
;CPSWSAVE:	db 0		; copy of above in case of ABORT
SWAP_ALWAYS:	; 05/08/2018
USER_IN_AX:	dw 0		; User INPUT AX value (used for
				;   extended error type stuff.
				;   NOTE: does not have Correct value on
				;   1-12, OEM, Get/Set CurrentPDB,
				;   GetExtendedError system calls)
PROC_ID:	dw 0		; PID for sharing (0 = local)
USER_ID:	dw 0		; Machine for sharing (0 = local)
FirstArena:	dw 0		; first free block found
BestArena:	dw 0		; best free block found
LastArena:	dw 0		; last free block found
ENDMEM:		dw 0		; End of memory used in DOSINIT
LASTENT:	dw 0		; Last entry for directory search
FAILERR:	db 0		; NZ if user did FAIL on I 24
ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
NoSetDir:	db 0		; true -> do not set directory
DidCTRLC:	db 0		; true -> we did a ^C exit
SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC

; Warning!  The following items are accessed as a WORD in TIME.ASM
	;EVEN
align 2
	; Offset 02FCh in IBMDOS.COM (MSDOS 3.3); 
DAY:		db 0		; Day of month
MONTH:		db 0		; Month of year
YEAR:		dw 0		; Year (with century)
DAYCNT:		dw -1		; Day count from beginning of year
WEEKDAY:	db 0		; Day of week
; end warning

CONSWAP:	db 0		; TRUE => console was swapped during device read
IDLEINT:	db 1		; TRUE => idle int is allowed
fAborting:	db 0		; TRUE => abort in progress

; Combination of all device call parameters
	;PUBLIC	DEVCALL 	;
;DEVCALL SRHEAD	<>		; basic header for disk packet
DEVCALL: ; 08/08/2018
DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
DEVCALL_REQUNIT: db 0		;Device unit number
DEVCALL_REQFUNC: db 0		;Type of request
DEVCALL_REQSTAT: dw 0		;Status Word
         times 8 db 0		;Reserved for queue links

	;PUBLIC	CALLUNIT
CALLUNIT: ; LABEL   BYTE	; unit number for disk
CALLFLSH: ; LABEL   WORD	;
CALLMED:	db 0		; media byte
CALLBR:	  ; LABEL   DWORD	;
	;PUBLIC	CALLXAD 	;
CALLXAD:  ; LABEL   DWORD	;
CALLRBYT:	db 0		;
	;PUBLIC	CALLVIDM	;
CALLVIDM: ; LABEL   DWORD	;
	times 3 db 0	;
	;PUBLIC CallBPB		;
CALLBPB:  ; LABEL   DWORD	;
CALLSCNT:			;
		dw 0		;
	;PUBLIC	CALLSSEC	;
CALLSSEC: ; LABEL   WORD	;
		dw 0		;
CALLVIDRW:	dd 0		;
;*MSDOS 6.0
;*CALLNEWSC:	dd 0		; starting sector for >32mb
CALLDEVAD:	dd 0		; stash for device entry point

; Same as above for I/O calls	;
				;
	;PUBLIC	IOCall		;
;IOCALL	SRHEAD	<>		;
IOCALL:	; 07/08/2018
IOCALL_REQLEN:	db 0		;Length in bytes of request block	
IOCALL_REQUNIT:	db 0		;Device unit number
IOCALL_REQFUNC: db 0		;Type of request
IOCALL_REQSTAT: dw 0		;Status Word
	times 8	db 0		;Reserved for queue links
IOFLSH:	  ; LABEL   WORD	;
        ;PUBLIC  IORCHR		;
IORCHR:	  ; LABEL   BYTE	;
IOMED:		db 0		;
IOXAD:		dd 0		;
IOSCNT:		dw 0		;	
IOSSEC:		dw 0		;

; Call struct for DSKSTATCHK	;
DSKSTCALL:	db DRDNDHL 	; = 14
		db 0
DSKSTCOM:	db DEVRDND	; = 5
DSKSTST:	dw 0		;
	times 8	db 0		;
DSKCHRET:	db 0		;

;hkn; short_addr has been changed to provide offset in DOSCODE.
;hkn; deviobuf is in DATA seg (DOSDATA)
;hkn   short_addr  DEVIOBUF	;
	
DEVIOBUF_PTR	dw DEVIOBUF
DOSSEG_INIT	dw 0		; DOS segment set at Init
DSKSTCNT:	dw 1		;
		dw 0		;

CreatePDB:	db 0		; flag for creating a process

;* MSDOS 6.0
;*	;PUBLIC	Lock_Buffer	;
;*Lock_Buffer: ; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
;*	    	dd 0		;MS. position
;*	 	dd 0		;MS. length

;hkn; the foll. was moved from dosmes.asm.

	;EVEN
align 2				; needed to maintain offsets

	; Offset 0352h in IBMDOS.COM (MSDOS 3.3)
	;PUBLIC  UserNum, OEMNum
USERNUM:
 		dw 0		; 24 bit user number
		db 0
;IF IBM
;IF IBMCOPYRIGHT
OEMNUM:		DB 0		; 8 bit OEM number
;ELSE
;OEMNUM:	DB 0FFh		; 8 bit OEM number
;ENDIF
;ELSE
;OEMNUM:	DB 0FFh
;ENDIF

; 17/07/2018
;----------------------------------------------------------------------------
; (MSDOS 3.3, DOSMES.INC, 1987)

; The next variable points to the country table for the current country
;	(the table returned by the AL=0 INTERNATIONAL call).

CurrentCounry:	dw USTABLE			


;DOSDATA ENDS

;----------------------------------------------------------------------------

; 16/07/2018 - Retro DOS v3.0

align 2

DATASEGMENT EQU $ ; 17/04/2018

;============================================================================
; MSINIT.ASM
;============================================================================
; 16/07/2018 - Retro DOS v3.0
;	      (MSINIT code order/reference: MSDOS 3.3, IBMDOS.COM, 1987)
	
; 15/04/2018 - Retro DOS v2.0 (DATA adaption for NASM)

; TITLE MSINIT.ASM -- MS-DOS INITIALIZATION CODE

;       ORG     0                       ; reset to beginning of data segment
; Init code below overlaps with data area

	
	; Offset 0358h in IBMDOS.COM (MSDOS 3.3)

;INITBLOCK DB    110H DUP(0)     ; Allow for segment round up
INITBLOCK:	TIMES 272 DB 0

	; Offset 0468h in IBMDOS.COM (MSDOS 3.3)

INITSP:		DW 0
INITSS:		DW 0
;BUFFSTRT:	DW 0

	; Offset 046Ch in IBMDOS.COM (MSDOS 3.3)	

;ASSUME  CS:DOSGROUP,DS:DOSGROUP,ES:DOSGROUP,SS:NOTHING
;
;        EXTRN   QUIT:NEAR,IRET:NEAR,ABSDRD:FAR,ABSDWRT:FAR
;        EXTRN   COMMAND:NEAR,CALL_ENTRY:NEAR
;        IF      NOT IBM
;        EXTRN   HEADER:BYTE
;        ENDIF

MOVDPB:
	; 08/07/2018 - Retro DOS v3.0
; This section of code is safe from being overwritten by block move
        ;MOV     SP,[CS:INITSP]
        ;MOV     SS,[CS:INITSS]
        ; 30/03/2018
	MOV     SP,[INITSP]
        MOV     SS,[INITSS]
	REP     MOVSB
        CLD
        ; 15/07/2018
	;MOV	[ES:DMAADD+2],DX
	MOV	[DMAADD+2],DX
        MOV     SI,[DPBHEAD]	; Address of first DPB
	;MOV	[ES:DPBHEAD+2],ES
        MOV	[DPBHEAD+2],ES
	;MOV	[ES:SFT_ADDR+2],ES
	MOV     [SFT_ADDR+2],ES
        MOV     CL,[NUMIO]	; Number of DPBs
        XOR     CH,CH
SETFINDPB:
        MOV     [ES:SI+1AH],ES
        MOV     BYTE [ES:SI+17H],-1  ; Never accessed before
        ADD     SI,DPBSIZ ; 32	; Point to next DPB
        LOOP    SETFINDPB
        SUB     SI,DPBSIZ ; sub si,32
        MOV     WORD [ES:SI+1AH],-1
        ; 15/07/2018 - Retro DOS v3.0
	;; MSDOS 2.11
        ;MOV	DI,[BUFFSTRT]		; Set up one default buffer
	;MOV	[ES:BUFFHEAD+2],ES
        ;MOV	[ES:BUFFHEAD],DI
	; MSDOS 3.3
	push	es ; *
	mov	di,SYSBUF+15 
	rcr	di,1
	shr	di,1
	shr	di,1
	shr	di,1
	mov	ax,es
	add	ax,di
	mov	es,ax
	xor	di,di
	mov     [BUFFHEAD+2],es
	mov     [BUFFHEAD],di
	;	
        MOV     WORD [ES:DI+4],00FFH
        MOV     WORD [ES:DI],-1
        MOV     WORD [ES:DI+2],-1
	pop	es; * ; 15/07/2018
        PUSH    ES
        INC     DX			; Leave enough room for the ARENA
	mov	si,[ENDMEM] ; 15/07/2018

	; 11/08/2018 - Retro DOS v3.0
        ;invoke _$DUP_PDB		; create jfns and set CurrentPDB
	CALL	_$DUP_PDB
        POP	ES
;
; set up memory arena
;SPECIAL NOTE FOR HIGHMEM VERSION
; At this point a process header has been built where the start of the 
; CONSTANTS segment as refed by CS is. From this point until the return 
; below be careful about references off of CS.
;
	; 13/04/2018 ; *
        ;PUSH	AX ; *
        ;MOV	AX,[CurrentPDB]
        MOV	AX,[CS:CurrentPDB] ; 15/03/2018
	MOV     [ES:CurrentPDB],AX	; Put it in the REAL location
        MOV     BYTE [ES:CreatePDB],0	; reset flag in REAL location
        DEC     AX
        MOV     [ES:arena_head],AX
        PUSH    DS
        MOV     DS,AX
        MOV     BYTE [ARENA.SIGNATURE],arena_signature_end
        MOV     WORD [ARENA.OWNER],arena_owner_system
        SUB     AX,[ES:ENDMEM]
        NEG     AX
        DEC     AX
        MOV     [ARENA.SIZE],AX
        POP     DS
        ;POP	AX ; *

        MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
	; 15/07/2018
        MOV     AX,3
        STOSW		; Adjust Refcount
	;MOV	DI,SYSINITVAR	; 16/03/2018 (Retro DOS v2.0)
	MOV     DI,SysInitTable ; 15/07/2018 (Retro DOS v3.0)
        RETF
	
	; 18/04/2018
FILL1	equ	$ - DATASEGMENT
; ---------------------------------------------------------------------------
; 16/07/2018 - Retro DOS v3.0
	times (490-FILL1) db 0	; *!!!*

;============================================================================
; MS_DATA.ASM (MSDOS 6.0, 1991)  (2)
;============================================================================
; 16/07/2018 - Retro DOS 3.0	

;  MS_DATA.ASM (MSDOS 6.0, 1991) (1) ... $$$
 
; (continues from 'SFN' ..) - from offset 0542h in IBMDOS.COM, 1987 -

; DATASEGMENT + 490

;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
;       I_am    WFP_START,WORD          ;
;       I_am    REN_WFP,WORD            ;
;       I_am    CURR_DIR_END,WORD       ;
;       I_am    NEXTADD,WORD            ;
;       I_am    LASTPOS,WORD            ;
;       I_am    CLUSNUM,WORD            ;
; MSDOS 3.3
;	I_am	DIRSEC,WORD
;; MSDOS 6.0
;;      I_am    DIRSEC,DWORD            ;>32mb		; AC0000
;       I_am    DIRSTART,WORD           ;
;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
;                                       ; sectors
;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
;       I_am    BYTPOS,4                ; Byte position in file of access
;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
;       I_am    SECCNT,WORD             ; No. of whole sectors

SFN:		dw -1
JFN:		dw 0
PJFN:		dd 0
WFP_START: 	dw 0
REN_WFP: 	dw 0
CURR_DIR_END: 	dw 0
NEXTADD: 	dw 0
LASTPOS: 	dw 0
CLUSNUM: 	dw 0
; MSDOS 3.3
DIRSEC: 	dw 0
; MSDOS 6.0
;DIRSEC:	dd 0
DIRSTART: 	dw 0
; MSDOS 3.3
SECPOS: 	dw 0
; MSDOS 6.0
;SECPOS: 	dd 0
; MSDOS 3.3
VALSEC: 	dw 0
; MSDOS 6.0
;VALSEC: 	dd 0
BYTSECPOS: 	dw 0
BYTPOS:		dd 0
BYTCNT1: 	dw 0
BYTCNT2: 	dw 0
SECCNT: 	dw 0

	; Offset 056Ah in IBMDOS.COM (MSDOS 3.3)
; DATASEGMENT + 530 (in Retro DOS v3.0)

;       I_am    ENTFREE,WORD            ;
;       I_am    ENTLAST,WORD            ;
;       I_am    NXTCLUSNUM,WORD         ;
;       I_am    GROWCNT,DWORD           ;
;       I_am    CURBUF,DWORD            ;
;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
;       I_am    SAVEBX,WORD             ;
;       I_am    SAVEDS,WORD             ;
;       I_am    restore_tmp,WORD        ; return address for restore world
;       I_am    NSS,WORD
;       I_am    NSP,WORD

ENTFREE:	dw 0
ENTLAST:	dw 0
NXTCLUSNUM:	dw 0
GROWCNT:	dd 0
CURBUF:		dd 0
CONSFT:		dd 0
SAVEBX:		dw 0
SAVEDS:		dw 0
RESTORE_TMP:	dw 0
NSS:		dw 0
NSP:		dw 0	 ; Offset 0584h in IBMDOS.COM (MSDOS 3.3)

; DATASEGMENT+558 :  ; *!!!*
	; Here is offset 0586h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 

; MSDOS 6.0
;       I_am    EXTOPEN_FLAG,WORD,<0>   ;FT. extended open input flag       ;AN000;
;       I_am    EXTOPEN_ON,BYTE,<0>     ;FT. extended open conditional flag ;AN000;
;       I_am    EXTOPEN_IO_MODE,WORD,<0>;FT. extended open io mode          ;AN000;
;       I_am    SAVE_DI,WORD            ;FT. extended open saved DI         ;AN000;
;       I_am    SAVE_ES,WORD            ;FT. extended open saved ES         ;AN000;
;       I_am    SAVE_DX,WORD            ;FT. extended open saved DX         ;AN000;
;       I_am    SAVE_CX,WORD            ;FT. extended open saved CX         ;AN000;
;       I_am    SAVE_BX,WORD            ;FT. extended open saved BX         ;AN000;
;       I_am    SAVE_SI,WORD            ;FT. extended open saved SI         ;AN000;
;       I_am    SAVE_DS,WORD            ;FT. extended open saved DS         ;AN000;

;	HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
;	we used to just pass 16 bits in a register.  Now High_SECTOR holds
;	the high 16, the low 16 are still in the register.
;
;       I_am    HIGH_SECTOR,WORD,<0>    ;>32mb higher sector #		    ;AN000;
;
;       ;I_am    UU_HIGH_SECTOR_TEMP,WORD,<0> ;M019: Unused
;       I_am    OffsetMagicPatch,WORD,<offset MagicPatch> ;scottq 8/6/92
;                                                         ;see dos\mpatch.asm
;
;       I_am    DISK_FULL,BYTE          ;>32mb indicating disk full when 1  ;AN000;
;       I_am    TEMP_VAR,WORD           ; temporary variable for everyone   ;AN000;
;       I_am    TEMP_VAR2,WORD          ; temporary variable 2 for everyone ;AN000;
;       I_am    DrvErr,BYTE             ; used to save drive error          ;AN000;
;       I_am    DOS34_FLAG,WORD,<0>     ; common flag for DOS 3.4           ;AN000;
;       I_am    NO_FILTER_PATH,DWORD    ; pointer to orignal path           ;AN000;
;       I_am    NO_FILTER_DPATH,DWORD   ; pointer to orignal path of destination;AN000;
;; M008
;       I_am   AbsRdWr_SS,WORD         ; INT 25/26 user stack segment
;       I_am   AbsRdWr_SP,WORD         ; INT 25/26 user stack offset
;       I_am   UU_Callback_flag,BYTE,<0>  ; Unused
;; M008
 
; make those pushes fast!!!
	;.EVEN
align 2

; MSDOS 3.3 ($ MSDOS 6.0)
StackSize equ 180h			; gross but effective

;;;StackSize = 300h			; This is a "trial" change IBM hasn't
;;;					; made up their minds about
 
;
; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
;
 
        ;PUBLIC  RENAMEDMA,AuxStack,DskStack,IOStack
RENAMEDMA:  ; LABEL   BYTE		; See DOS_RENAME
	;DB	StackSize DUP (?)       ;
	times	StackSize db 0

AUXSTACK:   ; LABEL   BYTE		;  Offset 0706h in IBMDOS.COM, 1987
 	;DB	StackSize DUP (?)       ;
	times	StackSize db 0
DSKSTACK:   ; LABEL   BYTE		;  Offset 0886h in IBMDOS.COM, 1987
 	;DB	StackSize DUP (?)       ;
	times	StackSize db 0
IOSTACK:    ; LABEL   BYTE		;  Offset 0A06h in IBMDOS.COM, 1987
 
; patch space for Boca folks.
; Say What????!!! This does NOT go into the swappable area!
; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
;       This allows the REDIRector to work on either IBM or MS-DOS.
 
;PUBLIC  IBMPATCH
;IBMPATCH label byte
;	I_am    PRINTER_FLAG,BYTE,<0>   ; status of PRINT utility
;	I_am    VOLCHNG_FLAG,BYTE,<0>   ; true if volume label created
;	I_am    VIRTUAL_OPEN,BYTE,<0>   ; non-zero if we opened a virtual file

IBMPATCH:
PRINTER_FLAG:	db 0
VOLCHNG_FLAG:	db 0
VIRTUAL_OPEN:	db 0

; MSDOS 6.0
;; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
;      I_am     FSeek_drive,BYTE        ;AN000; fastseek drive #
;      I_am     FSeek_firclus,WORD      ;AN000; fastseek first cluster #
;      I_am     FSeek_logclus,WORD      ;AN000; fastseek logical cluster #
;      I_am     FSeek_logsave,WORD      ;AN000; fastseek returned log clus #
;      I_am     UU_ACT_PAGE,WORD,<-1>   ;;;;;;; ;BL ; active EMS page ;AN000;
;      I_am     TEMP_DOSLOC,WORD,<-1>   ;stores the temporary location of dos
					;at SYSINIT time.
;SWAP_END LABEL   BYTE
;PUBLIC  SWAP_END

SWAP_END:
 
;; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
;;   BE USED. If the size of the swap data area is ODD, it will be rounded up
;;   to include this byte.
;       DB      ?

	db	0
 
;;hkn;	DB      (512+80+32-(SWAP_END-ibmpatch)) DUP (?)

;DOSDATA    ENDS

; 08/09/2018
	times 579 db 0

;12/08/2018 - Retro DOS v3.0
;15/07/2018
;============================================================================
; 	Retro DOS v3.0
;============================================================================
	db 	0
RETRODOSMSG:
	db	13,10
	;;;db	"Retro DOS v3.0 by Erdogan Tan [2018]"
	;;db	"Retro DOS v3.1 by Erdogan Tan [2019]" ; 29/06/2019
	;db	"Retro DOS v3.1 by Erdogan Tan [2019-2022]" ; 22/11/2022
	db	"Retro DOS v3.1 by Erdogan Tan [2019-2024]" ; 16/01/2024
	db	13,10,"$", 0 

;============================================================================
; MSTABLE.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0

	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
MSVERS:				; MS-DOS version in hex for $GET_VERSION
MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  

;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
;        I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
;        I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]

; DOSTAB.ASM (MSDOS 6.0, 1991)
; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
;
;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 

; Days in year

YRTAB:   
	DB	200,166			; Leap year
	DB	200,165
	DB	200,165
	DB	200,165

; Days of each month

MONTAB:        
	DB      31                      ; January
february:
	DB	28 			; February--reset each 
					; time year changes
        DB      31                      ; March
        DB      30                      ; April
        DB      31                      ; May
        DB      30                      ; June
        DB      31                      ; July
        DB      31                      ; August
        DB      30                      ; September
        DB      31                      ; October
        DB      30                      ; November
        DB      31                      ; December

;
; This is the error code mapping table for INT 21 errors.  This table defines
; those error codes which are "allowed" for each system call.  If the error
; code ABOUT to be returned is not "allowed" for the call, the correct action
; is to return the "real" error via Extended error, and one of the allowed
; errors on the actual call.
;
; The table is organized as follows:
;
;    Each entry in the table is of variable size, but the first
;       two bytes are always:
;
;       Call#,Cnt of bytes following this byte
;
; EXAMPLE:
;       Call 61 (OPEN)
;
;       DB      61,5,12,3,2,4,5
;
;       61 is the AH INT 21 call value for OPEN.
;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
;       Next five bytes are those error codes which are "allowed" on OPEN.
;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
;       this case 5).  The last value will be the one returned on the call if
;       the "real" error is not one of the allowed ones.
;
; There are a number of calls (for instance all of the FCB calls) for which
;   there is NO entry.  This means that NO error codes are returned on this
;   call, so set up an Extended error and leave the current error code alone.
;
; The table is terminated by a call value of 0FFh

;PUBLIC I21_MAP_E_TAB
	; 10/08/2018
I21_MAP_E_TAB:	; LABEL	BYTE
    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
    DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  RMDIR,4,error_current_directory,error_path_not_found
    DB          error_file_not_found,error_access_denied
    DB  CHDIR,2,error_file_not_found,error_path_not_found
    DB  CREAT,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files
    DB          error_access_denied
    ; MSDOS 6.0
    ;DB  OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
    ;DB          error_too_many_open_files
    ;DB          error_not_dos_disk,error_access_denied
    ; MSDOS 3.3
    DB  OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
    DB          error_too_many_open_files,error_access_denied
    DB  CLOSE,1,error_invalid_handle
    DB  READ,2,error_invalid_handle,error_access_denied
    DB  WRITE,2,error_invalid_handle,error_access_denied
    DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
    DB  LSEEK,2,error_invalid_handle,error_invalid_function
    DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
    DB          error_access_denied
    DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
    DB          error_invalid_handle,error_access_denied
    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
    ; MSDOS 6.0	
    ;DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
    ; MSDOS 3.3	
    DB  CURRENT_DIR,1,error_invalid_drive
    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
    DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
    DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
    DB          error_too_many_open_files,error_bad_format,error_bad_environment
    DB          error_not_enough_memory,error_access_denied
    DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
    DB  FIND_NEXT,1,error_no_more_files
    ; MSDOS 6.0
    ;DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
    ;DB          error_current_directory,error_access_denied
    ; MSDOS 3.3
    DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
    DB          error_access_denied
    ; MSDOS 6.0	
    ;DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
    ;DB             error_invalid_data,error_invalid_function
    ; MSDOS 3.03	
    DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
    DB  ALLOCOPER,1,error_invalid_function
    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
    DB          error_too_many_open_files,error_access_denied
    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
    DB          error_file_not_found,error_too_many_open_files,error_access_denied
    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
    DB          error_sharing_buffer_exceeded,error_lock_violation
    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
    DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
    DB              error_invalid_function
    ; MSDOS 6.0		
    ;DB	ExtOpen,10
    ;DB   error_path_not_found,error_file_not_found,error_invalid_access
    ;DB         error_too_many_open_files,error_file_exists,error_not_enough_memory
    ;DB         error_not_dos_disk,error_invalid_data
    ;DB             error_invalid_function,error_access_denied
    ;DB GetSetMediaID,4,error_invalid_drive,error_invalid_data
    ;DB         error_invalid_function,error_access_denied
    DB  0FFh

;============================================================================
; DOSTAB.ASM (MSDOS 6.0, 1991)
;============================================================================
; 16/07/2018 - Retro DOS 3.0

;**
;
; The following table defines CLASS ACTION and LOCUS info for the INT 21H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
;

;PUBLIC  ERR_TABLE_21
ERR_TABLE_21: ; LABEL   BYTE
    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,     0FFh
    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,     errLOC_Unk
    DB  error_access_denied,          errCLASS_Auth,      errACT_User,      0FFh
    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,     errLOC_Mem
    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,      errLOC_Unk
    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,     errLOC_Unk
    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
    DB  error_current_directory,      errCLASS_Auth,      errACT_User,      errLOC_Disk
    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,      errLOC_Disk
    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
    DB  error_file_exists,            errCLASS_Already,   errACT_User,      errLOC_Disk
    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,     0FFh
    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,      errLOC_Unk
    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,     errLOC_Disk
    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
    DB  error_already_assigned,       errCLASS_Already,   errACT_User,      errLOC_Net
    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,      errLOC_Unk
    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,     errLOC_Unk
    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
    ; MSDOS 6.0
    ;DB  error_handle_EOF,            errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
    ;DB  error_handle_Disk_Full,      errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
    ;DB  error_sys_comp_not_loaded,   errCLASS_Unk,       errACT_Abort,     errLOC_Disk ;AN001;
    DB  0FFh,                         0FFH,       	  0FFH,       	    0FFh

; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
;ERR_TABLE_21:	db 1,7,4,0FFh
;		db 2,8,3,2
;		db 3,8,3,2
;		db 4,1,4,1
;		db 5,3,3,0FFh
;		db 6,7,4,1
;		db 7,7,5,5
;		db 8,1,4,5
;		db 9,7,4,5
;		db 0Ah,7,4,5
;		db 0Bh,9,3,1
;		db 0Ch,7,4,1
;		db 0Dh,9,4,1
;		db 0Fh,8,3,2
;		db 10h,3,3,2
;		db 11h,0Dh,3,2
;		db 12h,8,3,2
;		db 50h,0Ch,3,2
;		db 20h,0Ah,2,2
;		db 21h,0Ah,2,2
;		db 54h,1,4,0FFh
;		db 56h,3,3,1
;		db 52h,1,4,2
;		db 32h,9,3,3
;		db 55h,0Ch,3,3
;		db 57h,9,3,1
;		db 53h,0Dh,4,1
;		db 24h,1,4,5
;		db 0FFh,0FFh,0FFh,0FFh

;
; The following table defines CLASS ACTION and LOCUS info for the INT 24H
; errors.  Each entry is 4 bytes long:
;
;       Err#,Class,Action,Locus
;
; A Locus value of 0FFh indicates a call specific value (ie.  should already
; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
; THE END.

;PUBLIC  ERR_TABLE_24
ERR_TABLE_24: ; LABEL   BYTE
    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,    errLOC_Disk
    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,    0FFh
    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,     errLOC_Disk
    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,     errLOC_Disk
    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,    errLOC_Disk
    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,     errLOC_Disk
    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,    errLOC_SerDev
    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,     0FFh
    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,     0FFh
    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,     0FFh
    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,    errLOC_Disk
    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,     0FFh


; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
;ERR_TABLE_24:	db 13h,0Bh,7,2
;		db 14h,4,5,1
;		db 15h,5,7,0FFh
;		db 16h,4,5,1
;		db 17h,0Bh,4,2
;		db 18h,4,5,1
;		db 19h,5,1,2
;		db 1Ah,0Bh,7,2
;		db 1Bh,0Bh,4,2
;		db 1Ch,2,7,4
;		db 1Dh,5,4,0FFh
;		db 1Eh,5,4,0FFh
;		db 1Fh,0Dh,4,0FFh
;		db 20h,0Ah,2,2
;		db 21h,0Ah,2,2
;		db 22h,0Bh,7,2
;		db 32h,9,3,3
;		db 23h,7,4,1
;		db 24h,1,4,5
;		db 0FFh,0Dh,5,0FFh

;
; We need to map old int 24 errors and device driver errors into the new set
; of errors.  The following table is indexed by the new errors
;

;Public  ErrMap24
ErrMap24: ; Label   BYTE
    DB  error_write_protect	; 0
    DB  error_bad_unit		; 1
    DB  error_not_ready		; 2
    DB  error_bad_command	; 3
    DB  error_CRC		; 4
    DB  error_bad_length	; 5
    DB  error_seek		; 6
    DB  error_not_DOS_disk	; 7
    DB  error_sector_not_found	; 8
    DB  error_out_of_paper	; 9
    DB  error_write_fault	; A
    DB  error_read_fault	; B
    DB  error_gen_failure	; C
    DB  error_gen_failure	; D  RESERVED
    DB  error_gen_failure	; E  RESERVED
    DB  error_wrong_disk	; F

;Public  ErrMap24End
ErrMap24End: ; LABEL   BYTE

; 16/07/2018 - Retro DOS v3.0
;_MAXCALL:	db 	36
;_MAXCOM:	db	104

; 08/09/2018
    db  36
    db  104

;============================================================================
; MSTABLE.ASM, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0

	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0

align 2

	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h

; Standard Functions
;DISPATCH    LABEL WORD
DISPATCH:
	; 16/07/2018 - Retro DOS v3.0
	; (MSDOS 3.3)

        short_addr  _$ABORT			    ;  0      0
        short_addr  _$STD_CON_INPUT		    ;  1      1
        short_addr  _$STD_CON_OUTPUT		    ;  2      2
        short_addr  _$STD_AUX_INPUT		    ;  3      3
        short_addr  _$STD_AUX_OUTPUT		    ;  4      4
        short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
        short_addr  _$RAW_CON_IO		    ;  6      6
        short_addr  _$RAW_CON_INPUT		    ;  7      7
        short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
        short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
        short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
        short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
        short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
        short_addr  _$DISK_RESET		    ; 13      D
        short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
        short_addr  _$FCB_OPEN			    ; 15      F
        short_addr  _$FCB_CLOSE			    ; 16     10
        short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
        short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
        short_addr  _$FCB_DELETE		    ; 19     13
        short_addr  _$FCB_SEQ_READ		    ; 20     14
        short_addr  _$FCB_SEQ_WRITE	            ; 21     15
        short_addr  _$FCB_CREATE		    ; 22     16
        short_addr  _$FCB_RENAME		    ; 23     17
	; 16/07/2018
        ;short_addr _CPMFUNC			    ; 24     18	
        short_addr  NO_OP			    ; 24     18
        short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
        short_addr  _$SET_DMA			    ; 26     1A

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SLEAZEFUNC		    ; 27     1B
        short_addr  _$SLEAZEFUNCDL		    ; 28     1C
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

        ;short_addr  _CPMFUNC			    ; 29     1D
        ;short_addr  _CPMFUNC			    ; 30     1E

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

	short_addr  NO_OP			    ; 29     1D
	short_addr  NO_OP			    ; 30     1E

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DEFAULT_DPB               ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        ;short_addr _CPMFUNC			    ; 32     20

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

	short_addr  NO_OP			    ; 32     20

        short_addr  _$FCB_RANDOM_READ               ; 33     21
        short_addr  _$FCB_RANDOM_WRITE              ; 34     22
        short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
        short_addr  _$GET_FCB_POSITION		    ; 36     24

;MAXCALL = ($-DISPATCH)/2 - 1
MAXCALL EQU ($-DISPATCH)/2 - 1

; Extended Functions
        short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
        short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
        short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
        short_addr  _$GET_DATE                      ; 42     2A
        short_addr  _$SET_DATE                      ; 43     2B
        short_addr  _$GET_TIME                      ; 44     2C
        short_addr  _$SET_TIME                      ; 45     2D
        short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E

; Extended functionality group
        short_addr  _$GET_DMA                       ; 47     2F
        short_addr  _$GET_VERSION                   ; 48     30
        short_addr  _$KEEP_PROCESS		    ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DPB			    ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
        short_addr  _$GET_INDOS_FLAG                ; 52     34
        short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
        short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
        short_addr  _$CHAR_OPER                     ; 55     37
        short_addr  _$INTERNATIONAL                 ; 56     38
; XENIX CALLS
;   Directory Group
        short_addr  _$MKDIR			    ; 57     39
        short_addr  _$RMDIR			    ; 58     3A
        short_addr  _$CHDIR			    ; 59     3B
;   File Group
        short_addr  _$CREAT			    ; 60     3C
        short_addr  _$OPEN			    ; 61     3D
        short_addr  _$CLOSE		 	    ; 62     3E
        short_addr  _$READ			    ; 63     3F
        short_addr  _$WRITE			    ; 64     40
        short_addr  _$UNLINK			    ; 65     41
        short_addr  _$LSEEK			    ; 66     42
        short_addr  _$CHMOD			    ; 67     43
        short_addr  _$IOCTL			    ; 68     44
        short_addr  _$DUP			    ; 69     45
        short_addr  _$DUP2			    ; 70     46
        short_addr  _$CURRENT_DIR		    ; 71     47
;   Memory Group
        short_addr  _$ALLOC			    ; 72     48
        short_addr  _$DEALLOC                       ; 73     49
        short_addr  _$SETBLOCK                      ; 74     4A
;   Process Group
        short_addr  _$EXEC			    ; 75     4B
        short_addr  _$EXIT			    ; 76     4C
        short_addr  _$WAIT			    ; 77     4D
        short_addr  _$FIND_FIRST		    ; 78     4E
;   Special Group
        short_addr  _$FIND_NEXT			    ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SET_CURRENT_PDB		    ; 80     50
        short_addr  _$GET_CURRENT_PDB               ; 81     51
        short_addr  _$GET_IN_VARS                   ; 82     52
        short_addr  _$SETDPB			    ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$DUP_PDB                       ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$RENAME			    ; 86     56
        short_addr  _$FILE_TIMES                    ; 87     57
        short_addr  _$ALLOCOPER                     ; 88     58

; 08/07/2018 - Retro DOS v3.0
; -------------------------------------------------------------------------;
; MSDOS 6.0 - MSTABLE.ASM, 1991

; Network extention system calls
        short_addr  _$GetExtendedError              ; 89     59
        short_addr  _$CreateTempFile                ; 90     5A
        short_addr  _$CreateNewFile                 ; 91     5B
        short_addr  _$LockOper                      ; 92     5C
        short_addr  _$ServerCall                    ; 93     5D
        short_addr  _$UserOper                      ; 94     5E
        short_addr  _$AssignOper                    ; 95     5F
        short_addr  _$NameTrans                     ; 96     60
	short_addr  NO_OP			    ; 97     61
        short_addr  _$GET_CURRENT_PDB		    ; 98     62
; the next call is reserved for hangool sys call
	; 16/07/2018
	;short_addr  _$ECS_Call			    ; 99     63
	short_addr  NO_OP			    ; 99     63
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SET_PRINTER_FLAG              ; 100    64
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$GetExtCntry                   ; 101    65
        short_addr  _$GetSetCdPg                    ; 102    66
        short_addr  _$ExtHandle                     ; 103    67
        short_addr  _$COMMIT                        ; 104    68

; 08/07/2018
; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)

;	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
;	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
;	short_addr  NO_OP                           ; 107    6B   
;						    ; IFS_IOCTL no longer 
;						    ; supported
;	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;MAXCOM  = ($-DISPATCH)/2 - 1

MAXCOM  EQU ($-DISPATCH)/2 - 1

; 08/07/2018 - Retro DOS v3.0
; MSDOS 6.0 - MSTABLE.ASM, 1991

;	If	Installed

align 2

;PUBLIC FOO

FOO:	; LABEL WORD
        short_addr  Leave2F

DTab:	DW  DOSTable

	;PUBLIC FOO,DTAB

	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
       
DOSTable:  ; LABEL  WORD
        DB      (DOSTableEnd-DOSTable-1)/2 ; db  46
        short_addr  DOSInstall          ;   0 install check
        short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
        short_addr  RECSET              ;   2   RECSET
        short_addr  DosGetGroup         ;   3   Get DOSGROUP
        short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
        short_addr  OUTT                ;   5   OUT
        short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
        short_addr  PLACEBUF            ;   7   PLACEBUF
        short_addr  FREE_SFT            ;   8   FREE_SFT
        short_addr  BUFWRITE            ;   9   BUFWRITE
        short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
        short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
        short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
        short_addr  DATE16              ;   13  DATE16
        short_addr  Idle		;   14      empty slot
        short_addr  SCANPLACE           ;   15  SCANPLACE
        short_addr  Idle		;   16      empty slot
        short_addr  StrCpy              ;   17  StrCpy
        short_addr  StrLen              ;   18  StrLen
        short_addr  UCase		;   19  UCase
        short_addr  POINTCOMP           ;   20  POINTCOMP
        short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
        short_addr  SFFromSFN           ;   22  SFFromSFN
        short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
        short_addr  Get_User_Stack      ;   24  Get_User_Stack
        short_addr  GETTHISDRV          ;   25  GetThisDrv
        short_addr  DriveFromText       ;   26  DriveFromText
        short_addr  SETYEAR             ;   27  SETYEAR
        short_addr  DSUM                ;   28  DSUM
        short_addr  DSLIDE              ;   29  DSLIDE
        short_addr  StrCmp              ;   30  StrCmp
        short_addr  InitCDS             ;   31  initcds
        short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
        short_addr  _$NameTrans		;   33  $NameTrans
        short_addr  CAL_LK              ;   34  CAL_LK
        short_addr  DEVNAME             ;   35  DEVNAME
        short_addr  Idle                ;   36  Idle
        short_addr  DStrLen             ;   37  DStrLen
        short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
        short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
        short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
        short_addr  _$READ		;   41  $READ         DOS 3.3
        short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
        short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
        short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
        short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
        
	; 10/08/2018
	;short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;

	short_addr  NO_OP		;   M006: 47  no longer supported
;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;

DOSTableEnd:  ; LABEL BYTE

	;ENDIF

;============================================================================
; DOSTAB.ASM, MSDOS 6.0, 1991
;============================================================================
; 16/07/2018 - Retro DOS v3.0

;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------

; SYS init extended table,   DOS 3.3   F.C. 5/29/86
;
	;PUBLIC	SysInitTable

SysInitTable:	; label  byte
	dw      SYSINITVARS			; pointer to sysinit var
        dw      0                             	; segment
        dw      COUNTRY_CDPG		   	; pointer to country tabl
        dw      0                            	; segment of pointer

; DOS 3.3 F.C. 6/12/86
; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
;
	;PUBLIC	FastOpenTable
	;PUBLIC	FastTable		; a better name
	;EXTRN	FastRet:FAR		; defined in misc2.asm

; MSDOS 6.0
;FastTable:     ;label  byte		; a better name
;FastOpenTable: ;label  byte
;	dw      2                       ; number of entries
;	dw      FastRet			; pointer to ret instr.
;	dw      0                       ; and will be modified by
;	dw      FastRet			; FASTxxx when loaded in
;	dw      0                       

;
; DOS 3.3 F.C. 6/12/86
;

;	PUBLIC	FastFlg                 ; flags
;FastFlg:	;label  byte		; don't change the foll: order
;FastOpenFlg:
;	db	0  ; I_am    FastOpenFlg,BYTE,<0>

; MSDOS 3.3
FastTable:
FastOpenTable:
	dw      4 
	dw      FastRet
	dw      0  ; (('FastRet' segment will be set to CS by DOSINIT))

	;PUBLIC	FastOpen_Ext_Info

; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
; and clusnum  which are filled by DOS 3.ncwhen calling FastOpen Insert
; or filled by FastOPen when calling FastOpen Lookup

FastOpen_Ext_Info: ;label  byte		;dirpos
	times	FEI.size db 0	; 5 (for MSDOS 3.3), 11 (for MSDOS 6.0)

; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
; when calling FastOpen Lookup

	;PUBLIC	Dir_Info_Buff

Dir_Info_Buff:	; label  byte
	times	dir_entry.size db 0 ; 32 ; segment of pointer

; MSDOS 3.3 (IBMDOS.COM, 1987)
FastFlg:
FastOpenFlg:
	db	0

	;I_am	Next_Element_Start,WORD	; save next element start offset
Next_Element_Start:
	dw	0

	; MSDOS 6.0
	;I_am    Del_ExtCluster,WORD     ; for dos_delete                       

; 17/07/2018

; The following is a stack and its pointer for interrupt 2F which is uesd
; by NLSFUNC.  There is no significant use of this stack, we are just trying
; not to destroy the INT 21 stack saved for the user.

	;PUBLIC	USER_SP_2F

USER_SP_2F:	; LABEL  WORD
	dw	FAKE_STACK_2F

	;PUBLIC	Packet_Temp
;Packet_Temp	label  word		; temporary packet used by readtime
	;PUBLIC  DOS_TEMP		; temporary word
;DOS_TEMP	label  word
FAKE_STACK_2F:
	;dw	14 dup (0)
	times	12 dw 0			; 12 register temporary storage

	;PUBLIC	Hash_Temp		; temporary word
;Hash_Temp	label  word              
	;dw	4 dup (0)		; temporary hash table during config.sys

	;PUBLIC  SCAN_FLAG             	; flag to indicate key ALT_Q
SCAN_FLAG:	; label  byte
	db	0

; MSDOS 3.3
DISK_FULL:
	db	0

	;PUBLIC  DATE_FLAG
DATE_FLAG:   	;label  word 		; flag to
	dw     0                	; to update the date

FETCHI_TAG:	;label  word		; OBSOLETE - no longer used
	dw     0			; formerly part of IBM's piracy protection

; MSDOS 6.0
;      PUBLIC	MSG_EXTERROR 		; for system message addr              
;MSG_EXTERROR	label  DWORD                                                     
;               dd     0                ; for extended error                   
;               dd     0                ; for parser                           
;              	dd     0                ; for critical errror                  
;              	dd     0                ; for IFS                              
;              	dd     0                ; for code reduction                   
;
;      PUBLIC  	SEQ_SECTOR              ; last sector read                     
;SEQ_SECTOR    	label  DWORD                                                     
;              	dd     -1                                                        
;
;;      I_am    ACT_PAGE,WORD,<-1>      ; active EMS page                       
;	I_am    SC_SECTOR_SIZE,WORD     ; sector size for SC                 
;       I_am    SC_DRIVE,BYTE           ; drive # for secondary cache        
;       I_am    CurSC_DRIVE,BYTE,<-1>   ; current SC drive                   
;       I_am    CurSC_SECTOR,DWORD      ; current SC starting sector         
;       I_am    SC_STATUS,WORD,<0>      ; SC status word                     
;       I_am    SC_FLAG,BYTE,<0>        ; SC flag                            
;       I_am    AbsDskErr,WORD,<0>	; Storage for Abs dsk read/write err
;
;	PUBLIC 	NO_NAME_ID                                                           
;NO_NAME_ID	label byte                                                           
;		db   'NO NAME    '	; null media id                      
;
;;hkn; moved from TABLE segment in kstrin.asm
;
;Public	KISTR001S,KISTR001E,LOOKSIZ	; 2/17/KK
;KISTR001S	label	byte		; 2/17/KK
;LOOKSIZ DB	0			; 0 if byte, NZ if word	2/17/KK
;KISTR001E	label	byte		; 2/17/KK
;
;; the nul device driver used to be part of the code.  However, since the 
;; header is in the data, and the entry points are only given as an offset,
;; the strategy and interrupt entry points must also be in the data now.
;;
;
;procedure   snuldev,far
;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
; 	or	es:[bx.reqstat],stdon	; set done bit
;entry inuldev
;	ret				; must not be a return!
;endproc snuldev
;

;============================================================================
; MSTABLE.ASM, MSDOS 6.0, 1991
;============================================================================
; 17/07/2018 - Retro DOS v3.0

; ----------------------------------------------------------------------------
; BREAK   <Copyright notice and version>
; ----------------------------------------------------------------------------

;CODSTRT EQU     $

; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
; (MSTABLE.ASM, MSDOS 6.0, 1991)

; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
;       module. The reason is so that the data alignments are the same in
;       IBM-DOS and MS-DOS up through header.

	;PUBLIC	HEADER

HEADER:	; LABEL	BYTE
        ;IF	DEBUG
        ;DB	13,10,"Debugging DOS version "
        ;DB	MAJOR_VERSION + "0"
        ;DB	"."
        ;DB	(MINOR_VERSION / 10) + "0"
        ;DB	(MINOR_VERSION MOD 10) + "0"
        ;ENDIF

        ;IF	NOT IBM
        DB	13,10,"MS-DOS version "
        DB	MAJOR_VERSION + "0"
        DB	"."
        DB	(MINOR_VERSION / 10) + "0"
        ;DB	(MINOR_VERSION MOD 10) + "0"
        DB	(MINOR_VERSION % 10) + "0"

        ;IF	HIGHMEM
        ;DB	"H"
        ;ENDIF

	DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
	;ENDIF

;IF DEBUG
;	DB	13,10,"$"
;ENDIF

;include copyrigh.inc

	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
	;DB	"Licensed Material - Property of Microsoft "
	;DB	"All rights reserved "

;============================================================================
; MCODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 17/07/2018 - Retro DOS v3.0

;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
;	NAME	IBMCODE

;BREAK <NullDev -- Driver for null device>

; ROMDOS note:
;	NUL device driver used to be here, but it was removed and placed in
;	DOSDATA, because the entry points have to be in the segment as the
;	header, which is also in DOSDATA.

;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>

;Public MSC001S,MSC001E
;MSC001S label byte
	;IF	IBM
; Codes returned by BIOS
ERRIN:
	DB	2			; NO RESPONSE
	DB	6			; SEEK FAILURE
	DB	12			; GENERAL ERROR
	DB	4			; BAD CRC
	DB	8			; SECTOR NOT FOUND
	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
ERROUT:
; DISK ERRORS RETURNED FROM INT 25 and 26
	DB	80H			; NO RESPONSE
	DB	40H			; Seek failure
	DB	2			; Address Mark not found
	DB	10H			; BAD CRC
	DB	4			; SECTOR NOT FOUND
	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK

NUMERR	EQU	$-ERROUT
	;ENDIF
;MSC001E label byte

;============================================================================
; DOSMES.INC (MSDOS 3.3, 1987)
;============================================================================
; 17/07/2018 - Retro DOS v3.0

;TABLE	SEGMENT BYTE PUBLIC 'TABLE'

; The international table(s). Used for DOS 3.x  (x < 3)
; This is simply a sequence of tables of the following form:
;
; Offset
;		BYTE  Size of this table excluding this byte and the next
;		WORD  Country code represented by this table
;			A sequence of n bytes, where n is the number specified
;			by the first byte above and is not > internat_block_max,
;			in the correct order for being returned by the
;			INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.	=0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;			Bit 2.	=1 imbedded at decimal point, & no spaces;
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.	=0 12 hour clock  =1 24 hour
;		WORD	Segment offset for address of case conversion routine
;		WORD	RESERVED. Filled in by DOS. Segment value for above routine
;		2 BYTE	Data list separator null terminated.
;		   NOTE: The segment part of the DWORD Map_call is set
;			by the INTERNATIONAL call. Do not try to initialize
;			it to anything meaningful.
;
; The list of tables is terminated by putting a byte of -1 after the last
;	table (a table with length -1).

	; PUBLIC  international_table

; Offset 0F95h in IBMDOS.COM (MSDOS 3.3), 1987

international_table:	; LABEL BYTE

	DB 	INTERNAT_BLOCK.size  ; = 24 ; Size in bytes of this table
	DW 	1		; Country code
USTABLE:
	dw	0		; 0-USA, 1-EUR, 2-JAP
	db	'$',0,0,0,0	; Currency Symbol 5 bytes
	db	',',0		; Thousands separator 2 bytes
	db	'.',0		; Decimal separator 2 bytes
	db	'-',0		; Date separator 2 bytes
	db	':',0		; Time separator 2 bytes
	db	0		; Bit values
                               	;   Bit 0 = 0 if currency symbol first
                               	;         = 1 if currency symbol last
                               	;   Bit 1 = 0 if No space after currency symbol
                               	;         = 1 if space after currency symbol
	db	2		; Number of places after currency dec point
	db	0		; if 24 hour time, 0 if 12 hour time
	dw	MAP_CASE	; Address of case mapping call (DWORD)
        dw	0		; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
	db	',',0		; Data list separator character

;	Tables for the IBM PC character set follow. The values
;	associated with some of the currency symbols may change with
;	other character sets. You may wish to add or delete country
;	entries. NOTE: It is not a mistake that the JAPANESE entry
;	has different currency symbols for the KANJI and
;	non-KANJI versions.
	
	DB	-1		; end of table

; The following table is used for DOS 3.3
;DOS country and code page information is defined here for DOS 3.3.
;The initial value for ccDosCountry is 1 (USA).
;The initial value for ccDosCodepage is 850.
;
;
	;PUBLIC  COUNTRY_CDPG,UCASE_TAB,FILE_UCASE_TAB
	;PUBLIC  FILE_CHAR_TAB

; country and code page infomation

COUNTRY_CDPG:	; label  byte
	db	0,0,0,0,0,0,0,0		; reserved words
	db	'\COUNTRY.SYS',0	; path name of country.sys
	times	51 db 0
	dw	437			; system code page id
	dw	5			; number of entries
	db	SetUcase		; Ucase type
	dw	UCASE_TAB		; pointer to upper case table
	dw	0			; segment of poiter
	db	SetUcaseFile		; Ucase file char type
	dw	FILE_UCASE_TAB		; pointer to file upper case table
	dw	0			; segment of poiter
	db	SetFileList		; valid file chars type
	dw	FILE_CHAR_TAB		; pointer to valid file char tab
	dw	0			; segment of poiter
	db	SetCollate		; collate type
	dw	COLLATE_TAB		; pointer to collate table
	dw	0			; segment of pointer
	db	SetCountryInfo		; country info type
	dw	NEW_COUNTRY_SIZE	; extended country info size
	dw	1			; USA country id
	dw	437			; USA system code page id
	dw	0			; date format
	db	'$',0,0,0,0		; currency symbol
	db	',',0			; thousand separator
	db	'.',0			; decimal separator
	db	'-',0			; date separator
	db	':',0			; time separator
	db	0			; currency format flag
	db	2			; # of disgit in currency
	db	0			; time format
	dw	MAP_CASE		;mono case routine entry point
	dw	0			; segment of entry point
	db	',',0			; data list separator
	dw	0,0,0,0,0		; reserved

; upper case table

UCASE_TAB: 	; label   byte
	dw	128
	db	128,154,069,065,142,065,143,128
	db	069,069,069,073,073,073,142,143
	db	144,146,146,079,153,079,085,085
	db	089,153,154,155,156,157,158,159
	db	065,073,079,085,165,165,166,167
	db	168,169,170,171,172,173,174,175
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,225,226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255

; file upper case table

FILE_UCASE_TAB: ; label  byte
	dw	128
	db	128,154,069,065,142,065,143,128
	db	069,069,069,073,073,073,142,143
	db	144,146,146,079,153,079,085,085
	db	089,153,154,155,156,157,158,159
	db	065,073,079,085,165,165,166,167
	db	168,169,170,171,172,173,174,175
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,225,226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255

; file char list

FILE_CHAR_TAB:	; label  byte
	dw	22				; length
	db	1,0,255 			; include all
	db	0,0,20h 			; exclude 0 - 20h
	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
	;db	24 dup (?)			; reserved
	times	24 db 0

; collate table

COLLATE_TAB:	; label   byte
	dw	256
	db	0,1,2,3,4,5,6,7
	db	8,9,10,11,12,13,14,15
	db	16,17,18,19,20,21,22,23
	db	24,25,26,27,28,29,30,31
	db	" ","!",'"',"#","$","%","&","'"
	db	"(",")","*","+",",","-",".","/"
	db	"0","1","2","3","4","5","6","7"
	db	"8","9",":",";","<","=",">","?"
	db	"@","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","[","\","]","^","_"
	db	"`","A","B","C","D","E","F","G"
	db	"H","I","J","K","L","M","N","O"
	db	"P","Q","R","S","T","U","V","W"
	db	"X","Y","Z","{","|","}","~",127
	db	"C","U","E","A","A","A","A","C"
	db	"E","E","E","I","I","I","A","A"
	db	"E","A","A","O","O","O","U","U"
	db	"Y","O","U","$","$","$","$","$"
	db	"A","I","O","U","N","N",166,167
	db	"?",169,170,171,172,"!",'"','"'
	db	176,177,178,179,180,181,182,183
	db	184,185,186,187,188,189,190,191
	db	192,193,194,195,196,197,198,199
	db	200,201,202,203,204,205,206,207
	db	208,209,210,211,212,213,214,215
	db	216,217,218,219,220,221,222,223
	db	224,"S"
	db	226,227,228,229,230,231
	db	232,233,234,235,236,237,238,239
	db	240,241,242,243,244,245,246,247
	db	248,249,250,251,252,253,254,255

;include divmes.inc

; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
	;PUBLIC	DIVMES

DIVMES:	DB	13,10,"Divide overflow",13,10

	;PUBLIC	DivMesLen
DivMesLen:
	DW	$-DIVMES	; Length of the above message in bytes

;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS

; The following two tables implement the current buffered input editing
; routines. The tables are pairwise associated in reverse order for ease
; in indexing. That is; The first entry in ESCTAB corresponds to the last
; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.

	;PUBLIC	CANCHAR
CANCHAR:
	DB	CANCEL	; 1Bh	;Cancel line character
	
	;PUBLIC	ESCCHAR
ESCCHAR:
	DB	ESCCH	; 0	;Lead-in character for escape sequences
	
	;IF	NOT Rainbow

ESCTAB:	; LABEL BYTE

	;IF	IBM
	DB	64		; Ctrl-Z - F6
	DB	77		; Copy one char - -->
	DB	59		; Copy one char - F1
	DB	83		; Skip one char - DEL
	DB	60		; Copy to char - F2
	DB	62		; Skip to char - F4
	DB	61		; Copy line - F3
	DB	61		; Kill line (no change to template ) - Not used
	DB	63		; Reedit line (new template) - F5
	DB	75		; Backspace - <--
	DB	82		; Enter insert mode - INS (toggle)
	DB	82		; Exit insert mode - INS (toggle)
	DB	65		; Escape character - F7
	DB	65		; End of table
	;ENDIF

ESCEND: ; LABEL BYTE

ESCTABLEN EQU ESCEND-ESCTAB

ESCFUNC: ; LABEL WORD
	
	short_addr  GETCH	; Ignore the escape sequence
	short_addr  TWOESC
	short_addr  EXITINS
	short_addr  ENTERINS
	short_addr  BACKSP
	short_addr  REEDIT
	short_addr  KILNEW
	short_addr  COPYLIN
	short_addr  SKIPSTR
	short_addr  COPYSTR
	short_addr  SKIPONE
	short_addr  COPYONE
	short_addr  COPYONE
	short_addr  CTRLZ

	;ENDIF

;TABLE	ENDS

; 17/07/2018
; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987

;CRTERRTAB: ; 19/07/2018	
;	db	0,5,52h,50h,3,5,20h

; 08/08/2018

CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
	DB	0			; none
	DB	error_access_denied	; MakeNode error 1
	DB	error_cannot_make	; MakeNode error 2
	DB	error_file_exists	; MakeNode error 3
	DB	error_path_not_found	; MakeNode error 4
	DB	error_access_denied	; MakeNode error 5
	DB	error_sharing_violation ; MakeNode error 6
	; MSDOS 6.0
	;DB	error_file_not_found	; MakeNode error 7

;============================================================================
; DEV.ASM (MSDOS 6.0, 1987)
;============================================================================
; 17/07/2018 - Retro DOS v3.0

; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987

;Public DEV001S, DEV001E 		; Pathgen labels
;DEV001s:
;		length of packets
LenTab:		DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
;LenTab:	db	22,14,22,13,15,14

;	       Error Function

CmdTab:
	DB	86h, DEVRD	; 0 input
	DB	86h, DEVRDND	; 1 input status
	DB	87h, DEVWRT	; 2 output
	DB	87h, DEVOST	; 3 output status
	DB	86h, DEVIFL	; 4 input flush
	DB	86H, DEVRDND	; 5 input status with system WAIT

; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987

;CmdTab:
;	db	86h, 4
;	db	86h, 5
;	db	87h, 8
;	db	87h, 10
;	db	86h, 7
;	db	86h, 5

;DEV001E:

;============================================================================
; FCB.ASM (MSDOS 6.0, 1987)
;============================================================================
; 17/07/2018 - Retro DOS v3.0

; Character type table for file name scanning
; Table provides a mapping of characters to validity bits.
; Four bits are provided for each character.  Values 7Dh and above
; have all bits set, so that part of the table is chopped off, and
; the translation routine is responsible for screening these values.
; The bit values are defined in DOSSYM.INC

;	      ; ^A and NUL
;CharType:
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^C and ^B
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^E and ^D
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^G and ^F
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; TAB and BS
;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^K and ^J
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^M and ^L
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^O and ^N
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^Q and ^P
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^S and ^R
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^U and ^T
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^W and ^V
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^Y and ^X
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ESC and ^Z
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^] and ^\
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ^_ and ^^
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; ! and SPACE
;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
;
;	      ; # and "
;	 db   LOW (NOT FFCB+FCHK)
;
;	      ; $ - )
;	 db   3 dup (0FFh)
;
;	      ; + and *
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
;
;	      ; - and '
;	 db   NOT (FFCB+FCHK+FDELIM)
;
;	      ; / and .
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
;
;	      ; 0 - 9
;	 db   5 dup (0FFh)
;
;	      ; ; and :
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
;
;	      ; = and <
;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
;
;	      ; ? and >
;	 db   NOT FFCB+FCHK+FDELIM
;
;	      ; A - Z
;	 db   13 dup (0FFh)
;
;	      ; \ and [
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
;
;	      ; ^ and ]
;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
;
;	      ; _ - {
;	 db   15 dup (0FFh)
;
;	      ; } and |
;	 db   NOT FFCB+FCHK+FDELIM

;CharType_last equ ($ - CharType) * 2	; This is the value of the last
;					; character in the table

; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987

CharType:
        db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh

; 02/08/2018 - Retro DOS v3.0
; DOSTAB.ASM - MSDOS 6.0 - 1991

; Offset 13CAh of IBMDOS.COM (MSDOS 3.3), 1987

exec_init_SP:	dw 0
exec_init_SS:	dw 0
exec_init_IP:	dw 0
exec_init_CS:	dw 0

exec_signature:	dw 0	; must contain 4D5A  (yay zibo!)
exec_len_mod_512: dw 0	; low 9 bits of length
exec_pages:	dw 0	; number of 512b pages in file
exec_rle_count:	dw 0	; count of reloc entries
exec_par_dir:	dw 0	; number of paragraphs before image
exec_min_BSS:	dw 0	; minimum number of para of BSS
exec_max_BSS:	dw 0	; max number of para of BSS
exec_SS:	dw 0	; stack of image
exec_SP:	dw 0	; SP of image
exec_chksum:	dw 0	; checksum  of file (ignored)
exec_IP:	dw 0	; IP of entry
exec_CS:	dw 0	; CS of entry
exec_rle_table:	dw 0	; byte offset of reloc table

Exec_Header_Len	EQU $-exec_signature

; 02/08/2018 - Retro DOS v3.0
; SRVCALL.ASM - MSDOS 6.0 - 1991
;** Server DOS call functions

SERVERTAB:      dw SERVER_DISP
SERVERLEAVE:	dw SERVERRETURN
SERVER_DISP:	db (SERVER_DISP_END-SERVER_DISP-1)/2
		dw SRV_CALL	; 0
		dw COMMIT_ALL	; 1
		dw CLOSE_NAME	; 2
		dw CLOSE_UID	; 3
		dw CLOSE_UID_PID ; 4
		dw GET_LIST	; 5
		dw GET_DOS_DATA	; 6
		dw SPOOL_OPER	; 7
		dw SPOOL_OPER	; 8
		dw SPOOL_OPER	; 9
		dw _$SetExtendedError ; 10
SERVER_DISP_END:

;============================================================================
; MSCODE.ASM
;============================================================================

; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
; 03/03/2018

;
; MSCODE.ASM -- MSDOS code
;

;INCLUDE DOSSEG.ASM
;INCLUDE STDSW.ASM

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;IFNDEF  KANJI
;KANJI   EQU     0       ; FALSE
;ENDIF

;IFNDEF  IBM
;IBM     EQU     0
;ENDIF

;IFNDEF  HIGHMEM
;HIGHMEM  EQU     0
;ENDIF

        ;i_need  USER_SP,WORD
        ;i_need  USER_SS,WORD
        ;i_need  SAVEDS,WORD
        ;i_need  SAVEBX,WORD
        ;i_need  INDOS,BYTE
        ;i_need  NSP,WORD
        ;i_need  NSS,WORD
        ;i_need  CURRENTPDB,WORD
        ;i_need  AUXSTACK,BYTE
        ;i_need  CONSWAP,BYTE
        ;i_need  IDLEINT,BYTE
        ;i_need  NOSETDIR,BYTE
        ;i_need  ERRORMODE,BYTE
        ;i_need  IOSTACK,BYTE
        ;i_need  WPERR,BYTE
        ;i_need  DSKSTACK,BYTE
        ;i_need  CNTCFLAG,BYTE
        ;i_need  LEAVEADDR,WORD
        ;i_need  NULLDEVPT,DWORD

        ;IF NOT IBM
        ;i_need  OEM_HANDLER,DWORD
        ;ENDIF

        ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR

;============================================================================
; MSDISP.ASM, MSDOS 6.0, 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0

; 18/07/2018

; The following two routines are dispatched to directly with ints disabled
; immediately after the int 21h entry.	no DIS state is set.

; ---------------------------------------------------------------------------
; $Set_current_PDB takes BX and sets it to be the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
       ;procedure   $SET_CURRENT_PDB,NEAR
_$SET_CURRENT_PDB:
        ;ASSUME	DS:NOTHING,SS:NOTHING
        MOV     [CS:CurrentPDB],BX ; 12/03/2018
	iret ; 08/07/2018 - Retro DOS v3.0
;$SET_CURRENT_PDB    ENDP

; ---------------------------------------------------------------------------
; $get_current_PDB returns in BX the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
        ;procedure $GET_CURRENT_PDB,NEAR
_$GET_CURRENT_PDB:
        ;ASSUME	DS:NOTHING,SS:NOTHING
	mov	BX,[CS:CurrentPDB] ; 11/07/2018
	iret ; 08/07/2018 - Retro DOS v3.0
;$GET_CURRENT_PDB    ENDP
; ---------------------------------------------------------------------------

; 11/07/2018 - Retro DOS v3.0

;BREAK <$Set_CTRL_C_Trapping -- En/Disable ^C check in dispatcher>

_$SET_CTRL_C_TRAPPING:

; Inputs:
;       AL = 0 read ^C status
;       AL = 1 Set ^C status, DL = 0/1 for ^C off/on
;	AL = 2 Set ^C status to contents of DL.	Output is old state.
;	     (MSDISP.ASM,MSDOS 6.0, 1991)
; Function:
;       Enable disable ^C checking in dispatcher
; Outputs:
;       If AL = 0 then DL = 0/1 for ^C off/on

	; 08/07/2018 - Retro DOS v3.0

        OR      AL,AL
        JNZ     SHORT CTRL_C_set

	; 11/07/2018
	mov	dl,[CS:CNTCFLAG]
	iret

CTRL_C_set:
	; 08/07/2018
	cmp	al,2
	ja	short bad_val
	je	short scct_3

	push    dx
	and     dl,1
	mov     [cs:CNTCFLAG],dl
	pop     dx
	iret

scct_3:
	and	dl,1
        xchg	dl,[CS:CNTCFLAG]
        iret

bad_val:
	MOV	AL,0FFH
	iret

; 11/07/2018

_$SET_PRINTER_FLAG:
	; 08/07/2018 - Retro DOS v3.0
	;mov 	[cs:IOSTACK],al
	mov	[cs:PRINTER_FLAG],al
	iret

; 08/07/2018 - Retro DOS v3.0
; (MSDISP.ASM, MSDOS 6.0, 1991)

; ----------------------------------------------------------------------------
; BREAK   <System call entry points and dispatcher>
; ----------------------------------------------------------------------------
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

        ;procedure   SYSTEM_CALL,NEAR
SYSTEM_CALL:
;entry	QUIT				; INT 20H entry point
QUIT:
	;MOV	AH,0
	xor	ah,ah ; 08/07/2018
	JMP     SHORT SAVREGS

; ---------------------------------------------------------------------------

;COMMAND:
;	;IF	NOT IBM
;       CMP	AH,SET_OEM_HANDLER
;       JB      SHORT NOTOEM
;	; 18/07/2018
;	je	_$SET_OEM_HANDLER	
;
;	; 20/04/2018
;       ;JMP	_$SET_OEM_HANDLER
;
;	; Retro DOS v2.0 - 20/04/2018
;	CMP	AX, 0FFFFh
;	;JNE	_$SET_OEM_HANDLER
;	; 18/07/2018
;	jne	DO_OEM_FUNC
;
;	PUSHA
;	MOV     SI,RETRODOSMSG
;       ;CALL	OUTMES
;wrdosmsg:
;	mov	ah, 0Eh
;	mov	bx, 7
;wrdosmsg_nxt:
;	cs	lodsb
;	cmp	al, '$'
;	je	short wrdosmsg_ok		
;	int	10h
;	jmp	short wrdosmsg_nxt
;wrdosmsg_ok:
;	POPA
;	JMP	SHORT BADCALL 
;	;
;NOTOEM:
;	;ENDIF
;
;       CMP     AH,MAXCOM
;       JBE     SHORT SAVREGS

	; The system call in AH is out of the range that we know how
	; to handle. We arbitrarily set the contents of AL to 0 and
	; IRET. Note that we CANNOT set the carry flag to indicate an
	; error as this may break some programs compatability.

BADCALL:
        ;MOV	AL,0
	xor	al,al ; 08/07/2018
;entry	IRET
_IRET:
        IRET

; ---------------------------------------------------------------------------

;entry	CALL_ENTRY                      ; System call entry point and dispatcher
CALL_ENTRY:
        POP     AX                      ; IP from the long call at 5
        POP     AX                      ; Segment from the long call at 5
        ;POP	WORD [USER_SP]		; IP from the CALL 5
        POP	WORD [CS:USER_SP] ; 12/03/2018
	PUSHF                           ; Start re-ordering the stack
        CLI
        PUSH    AX                      ; Save segment
        ;PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
        PUSH	WORD [CS:USER_SP] ; 12/03/2018
        CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
        JA      SHORT BADCALL
        MOV     AH,CL
	; 08/07/2018
	jmp	short SAVREGS 

COMMAND:
	; 08/07/2018 - Retro DOS v3.0

	;IF	NOT IBM
        CMP	AH,SET_OEM_HANDLER
        JB      SHORT NOTOEM
	; 18/07/2018
	je	_$SET_OEM_HANDLER	

	; 20/04/2018
        ;JMP	_$SET_OEM_HANDLER

	; Retro DOS v2.0 - 20/04/2018
	CMP	AX,0FFFFh
	;JNE	_$SET_OEM_HANDLER
	; 18/07/2018
	jne	DO_OEM_FUNC

	PUSHA
	MOV     SI,RETRODOSMSG
        ;CALL	OUTMES
wrdosmsg:
	mov	ah, 0Eh
	mov	bx, 7
wrdosmsg_nxt:
	cs	lodsb
	cmp	al, '$'
	je	short wrdosmsg_ok		
	int	10h
	jmp	short wrdosmsg_nxt
wrdosmsg_ok:
	POPA
	JMP	SHORT BADCALL 
	;

NOTOEM:
	;ENDIF

	cli	; 08/07/2018

_COMMAND: ; MSDOS 3.3 (IBM)

        CMP     AH,MAXCOM
	;JBE	SHORT SAVREGS
        JA	SHORT BADCALL ; 08/07/2018

SAVREGS:
	; 10/08/2018
	; 08/07/2018 - Retro DOS v3.0
	cmp	ah,33h
	jz	short _$SET_CTRL_C_TRAPPING
	jb	short SaveAllRegs
	cmp	ah,64h
	ja	short SaveAllRegs
	jz	short _$SET_PRINTER_FLAG
	cmp	ah,51h
	jz	_$GET_CURRENT_PDB
	cmp	ah,62h
	jz	_$GET_CURRENT_PDB
	cmp     ah,50h
	jz	_$SET_CURRENT_PDB
SaveAllRegs:
        CALL    save_world
        MOV	[CS:SAVEDS],DS	; 12/03/2018
        MOV	[CS:SAVEBX],BX	; 12/03/2018
        MOV     BX,CS
        MOV     DS,BX
;ASSUME  DS:DOSGROUP
        INC     BYTE [INDOS]		; Flag that we're in the DOS
	
	; 08/07/2018 - Retro DOS v3.0        
	xor     ax, ax
	mov     [USER_ID],ax
	mov     ax,[CurrentPDB]
	mov     [PROC_ID],ax

	MOV     AX,[USER_SP]
        MOV     [NSP],AX
        MOV     AX,[USER_SS]
        MOV     [NSS],AX
        POP     AX
        PUSH    AX
        MOV     [USER_SP],SP
        MOV     [USER_SS],SS
;
; save user stack in his area for later returns (possibly from EXEC)
; Here comes multitasking!!!
;
        MOV     DS,[CurrentPDB]
        MOV     [PDB.USER_STACK],SP
        MOV     [PDB.USER_STACK+2],SS
	; 18/07/2018
	mov	byte [CS:FSHARING], 0

        MOV     BX,CS                   ; no holes here.
        MOV     SS,BX
;ASSUME  SS:DOSGROUP

;entry	REDISP
REDISP:
        MOV     SP,AUXSTACK		; Enough stack for interrupts
        STI                             ; Stack OK now
	; 08/07/2018
        ;PUSH	CS
        ;POP	DS
	mov	bx,cs
	mov	ds,bx
        XOR     BH,BH
        MOV     [CONSWAP],BH
        MOV     BYTE [IDLEINT],1
        MOV     BYTE [NoSetDir],bh ; 0	; set directories on search
        mov	byte [FAILERR],bh ; 0	
	MOV     BL,AH
        SHL     BX,1
        CLD
        OR      AH,AH
        JZ      SHORT DSKROUT		; ABORT

        ;CMP	AH,12
        ;JBE	SHORT IOROUT		; Character I/O
        ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
        ;JZ	SHORT IOROUT
        ;CMP	AH,SET_CURRENT_PDB
        ;JNZ	SHORT DSKROUT

	; 10/08/2018
	cmp     ah,GETEXTENDEDERROR ; 59h
	jz      short DISPCALL
	cmp     ah,STD_CON_INPUT_FLUSH ; 0Ch
	ja      short DSKROUT

IOROUT:
        CMP     BYTE [ERRORMODE],0
        JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
        MOV     SP,IOSTACK
        JMP     SHORT DISPCALL

DSKROUT:
	; 08/07/2018 - Retro DOS v3.0
        mov     [USER_IN_AX],ax
	mov     byte [EXTERR_LOCUS],1	; errLOC_Unk  (Default)

        MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
        MOV     BYTE [WPERR],-1		; error mode, so good place to
                                        ; make sure flags are reset
	push    ax
	mov     ah, 82h
	int     2Ah 		; Microsoft Networks 
				; END DOS CRITICAL SECTIONS 0 THROUGH 7
	pop     ax
	mov     byte [IDLEINT],0

        MOV     SP,DSKSTACK
        TEST    BYTE [CNTCFLAG],-1
        JZ      SHORT DISPCALL
        PUSH    AX
        ;invoke	DSKSTATCHK
        CALL	DSKSTATCHK
	POP     AX
DISPCALL:
	; 08/07/2018 -Retro DOS v3.0
	;;;PUSH	WORD [LEAVEADDR] ; (***)
        ;;;PUSH	WORD [CS:BX+DISPATCH]
        ;;;;PUSH WORD [BX+DISPATCH]

	; 11/07/2018	
	;mov	bx,[CS:BX+DISPATCH]
 	mov	bx,[bx+DISPATCH] 

	;;;MOV	BX,[SAVEBX]
	xchg    bx,[SAVEBX]        

	MOV     DS,[SAVEDS]
;ASSUME	DS:NOTHING
        ;return
;;;	RETN	

	call	word [SS:SAVEBX]

;entry LEAVE
;;;_LEAVE:				; Exit from a system call
LeaveDOS: ; 18/07/2018 
;ASSUME	SS:NOTHING			; User routines may misbehave
	CLI
        ; 12/03/2018
	DEC     BYTE [CS:INDOS]
        MOV     SP,[CS:USER_SP]
        MOV     SS,[CS:USER_SS]
	MOV     BP,SP
	;MOV	[BP.user_AX],AL	
        ;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
        MOV     [BP],AL
	MOV     AX,[CS:NSP]
        MOV     [CS:USER_SP],AX
        MOV     AX,[CS:NSS]
        MOV     [CS:USER_SS],AX
	CALL    restore_world

        IRET

;SYSTEM_CALL ENDP

;
; restore_world restores all registers ('cept SS:SP, CS:IP, flags) from
; the stack prior to giving the user control
;

; 11/07/2018 - Retro DOS v3.0
        ;ASSUME  DS:NOTHING,ES:NOTHING
;;restore_tmp DW  ?
;restore_tmp: 
;	dw	0
        ;procedure restore_world,NEAR
restore_world:
        POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
        POP     AX              ; PUSH    ES
        POP     BX              ; PUSH    DS
        POP     CX              ; PUSH    BP
        POP     DX              ; PUSH    DI
        POP     SI              ; PUSH    SI
        POP     DI              ; PUSH    DX
        POP     BP              ; PUSH    CX
        POP     DS              ; PUSH    BX
        POP     ES              ; PUSH    AX
	; 07/07/2018 - Retro DOS v3.0
       	jmp	word [CS:RESTORE_TMP]

;restore_world	ENDP

;
; save_world saves complete registers on the stack
;
        ;procedure save_world,NEAR
save_world:
        POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
        PUSH    ES
        PUSH    DS
        PUSH    BP
        PUSH    DI
        PUSH    SI
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    AX
	; 07/07/2018 - Retro DOS v3.0
       	jmp	word [CS:RESTORE_TMP]

;save_world	ENDP

;
; get_user_stack returns the user's stack (and hence registers) in DS:SI
;
        ;procedure get_user_stack,NEAR
Get_User_Stack:
        ;LDS	SI,DWORD PTR [USER_SP]
        ;LDS	SI,[USER_SP]
        LDS	SI,[CS:USER_SP] ; 12/03/2018
	;return
	RETN

;get_user_stack  ENDP

; ---------------------------------------------------------------------------
;
; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
; Inputs:
;	User registers, User Stack, INTS disabled
;	If CALL F8, DS:DX is new handler address
; Function:
;	Process OEM INT 21 extensions
; Outputs:
;	Jumps to OEM_HANDLER if appropriate
;
; ---------------------------------------------------------------------------

;IF	NOT IBM

_$SET_OEM_HANDLER:
	; 18/07/2018

	;JNE	short DO_OEM_FUNC	; If above F8 try to jump to handler
	MOV     [CS:OEM_HANDLER],DX	; Set Handler
	MOV     [CS:OEM_HANDLER+2],DS
	IRET                            ; Quick return, Have altered no registers

DO_OEM_FUNC:
	CMP     WORD [CS:OEM_HANDLER],-1
	JNZ     short OEM_JMP
	JMP     BADCALL                 ; Handler not initialized

OEM_JMP:
	JMP     FAR [CS:OEM_HANDLER]

;       ENDIF

;============================================================================
; DOSTAB.ASM - MSDOS 6.0 - 1991
;============================================================================
; 11/07/2018 - Retro DOS v3.0

; the nul device driver used to be part of the code.  However, since the 
; header is in the data, and the entry points are only given as an offset,
; the strategy and interrupt entry points must also be in the data now.
;

;procedure	snuldev,far
SNULDEV:
;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
; Offset 1599h in IBMDOS.COM (MSDOS 3.3), 1987
	;or	word [ES:BX+3],0100h
 	OR	word [ES:BX+SRHEAD.REQSTAT],STDON ; set done bit
;entry inuldev
INULDEV:
	retf				; must not be a return!
;endproc snuldev

;============================================================================
; MSCODE.ASM - MSDOS 6.0 - 1991
;============================================================================
; 18/07/2018 - Retro DOS v3.0

;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>


;   AbsSetup - setup for abs disk functions
;----------------------------------------------------------------------------

AbsSetup:
	INC	byte [SS:INDOS]		; SS override
	STI
	CLD
	PUSH	DS
	push	ss
	pop	ds
	CALL	GETBP
	JC	short errdriv 		; PM. error drive ;AN000;
	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
errdriv:
	POP	DS
	jnc	short AbsSetup2
AbsSetup_retn:
	retn

AbsSetup2:
	; MSDOS 6.0
	;				; SS override
	;MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
	;CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
	jc	short AbsSetup_retn
	;call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	DS
	PUSH	SI
	PUSH	AX

	push	ss
	pop	ds
	
	MOV	SI,OPENBUF
	MOV	[SI],AL
	ADD	BYTE [SI],"A"
	MOV	WORD [SI+1],003AH ; ":",0
	MOV	AX,0300H
	CLC
	INT	int_IBM 		; Will set carry if shared
	POP	AX
	POP	SI
	POP	DS
	jnc	short AbsSetup_retn

	;mov	word [ss:EXTERR],32h
	MOV	word [ss:EXTERR],error_not_supported
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDRD
;
; Interrupt 25 handler.  Performs absolute disk read.
; Inputs:	AL - 0-based drive number
;		DS:BX point to destination buffer
;		CX number of logical sectors to read
;		DX starting  logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------
        ;procedure   ABSDRD,FAR
ABSDRD:
	; 15/07/2018
;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING
        CLI
        ;MOV	[USER_SS],SS
        ;MOV	[USER_SP],SP
	; 15/03/2018
        MOV	[CS:USER_SS],SS
        MOV	[CS:USER_SP],SP        
	PUSH    CS
        POP     SS
;ASSUME  SS:DOSGROUP
        MOV	SP,DSKSTACK

	;; MSDOS 2.11

        ;;;INC	BYTE [INDOS]
        ;;INC	BYTE [SS:INDOS]
	;;STI
        ;;CLD
        ;;PUSH	ES
        ;;PUSH	DS
        ;;PUSH	SS
        ;;POP	DS
;;;ASSUME DS:DOSGROUP
        ;;;invoke GETBP
	;;CALL	GETBP
        ;;POP	DS
;;;ASSUME DS:NOTHING

	; 15/07/2018 - Retro DOS v3.0
	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
        PUSH    ES
	call    AbsSetup
	;	
        JC      SHORT ILEAVE
        ;invoke	DSKREAD
	CALL	DSKREAD
TLEAVE:
        JZ      SHORT ILEAVE

	; 15/07/2018 - Retro DOS v3.0
        ;IF	IBM
; Translate the error code to ancient 1.1 codes
        PUSH    ES
        PUSH    CS
        POP     ES
        XOR     AH,AH			; Nul error code
	;mov	cx,6
        MOV     CX,NUMERR		; Number of possible error conditions
        MOV     DI,ERRIN		; Point to error conditions
        REPNE   SCASB
        JNZ     SHORT LEAVECODE		; Not found
	;mov	ah,[ES:DI+5]
        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
LEAVECODE:
        POP     ES
        ;ENDIF

        STC
ILEAVE:
        POP     ES
        CLI
        ;DEC	BYTE [INDOS]
        ;15/03/2018
	DEC	BYTE [SS:INDOS]
	; 15/08/2018
        ;MOV	SS,[CS:USER_SS]
	;MOV	SP,[CS:USER_SP]
	MOV     SP,[SS:USER_SP]
        MOV     SS,[SS:USER_SS]
;ASSUME  SS:NOTHING
        STI
        ;return
	RETF   ; ! FAR return !

;ABSDRD	ENDP

;---------------------------------------------------------------------------
;
; Procedure Name : ABSDWRT
;
; Interrupt 26 handler.  Performs absolute disk write.
; Inputs:	AL - 0-based drive number
;		DS:BX point to source buffer
;		CX number of logical sectors to write
;		DX starting  logical sector number (0-based)
; Outputs:	Original flags still on stack
;		Carry set
;		    AH error from BIOS
;		    AL same as low byte of DI from INT 24
;
;---------------------------------------------------------------------------
        ;procedure   ABSDWRT,FAR
ABSDWRT:
	; 15/07/2018
;ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

        CLI
	; 15/08/2018
	; 15/03/2018
	MOV	[CS:USER_SS],SS
        MOV	[CS:USER_SP],SP
        PUSH    CS
        POP     SS
;ASSUME	SS:DOSGROUP
        ;MOV	SP,OFFSET DOSGROUP:DSKSTACK
        MOV	SP,DSKSTACK

	;; MSDOS 2.11

        ;;;INC	BYTE [INDOS]
        ;;INC	BYTE [SS:INDOS]
	;;STI
        ;;CLD
        ;;PUSH	ES
        ;;PUSH	DS
        ;;PUSH	SS
        ;;POP	DS
;;;ASSUME DS:DOSGROUP
        ;;;invoke GETBP
	;;CALL	GETBP
        ;;POP	DS
;;;ASSUME DS:NOTHING

	; 15/07/2018 - Retro DOS v3.0
	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
        PUSH    ES
	call    AbsSetup
	;
        JC      SHORT ILEAVE
        ;invoke DSKWRITE
        CALL	DSKWRITE
	JMP     SHORT TLEAVE

;ABSDWRT ENDP

;----------------------------------------------------------------------------
;
; Procedure Name : GETBP
;
; Inputs:
;	AL = Logical unit number (A = 0)
; Function:
;	Find Drive Parameter Block
; Outputs:
;	ES:BP points to DPB
;	[THISDPB] = ES:BP
;	Carry set if unit number bad or unit is a NET device.
;		Later case sets extended error error_I24_not_supported
; No other registers altered
;
;----------------------------------------------------------------------------

GETBP:
	; 11/07/2018 - Retro DOS v3.0
	PUSH	AX
	ADD	AL, 1		; No increment; need carry flag
	JC	SHORT SKIPGET
	CALL	GETTHISDRV
	; MSDOS 6.0
	;JNC	SHORT SKIPGET		;PM. good drive		;AN000;
	;XOR	AH,AH			;DCR. ax= error code 	;AN000;
	;CMP	AX,error_not_dos_disk	;DCR. is unknown media ? ;AN000;
	;JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
	;STC				;DCR.			;AN000;
	;MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
	;MOV	WORD [AbsDskErr],201h
SKIPGET:
	POP	AX
	JC	SHORT GETBP_RETN
	LES	BP,[THISCDS]
	;TEST	WORD [ES:BP+43H],8000H
	TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
	JZ	SHORT GETBP_CDS
	MOV	WORD [EXTERR],error_not_supported  ; 32
	STC
GETBP_RETN:
	RETN

GETBP_CDS:
	;LES	BP,[ES:BP+45H]
	LES	BP,[ES:BP+curdir.devptr]

GOTDPB:
	; Load THISDPB from ES:BP
	MOV	[THISDPB],BP
	MOV	[THISDPB+2],ES
	RETN

;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>

;----------------------------------------------------------------------------
;
; Procedure Name : SYS_RETURN
;
; These are the general system call exit mechanisms. All internal system
; calls will transfer (jump) to one of these at the end. Their sole purpose
; is to set the user's flags and set his AX register for return.
;
;----------------------------------------------------------------------------

        ;procedure   SYS_RETURN,NEAR
SYS_RETURN:        
        ;entry	SYS_RET_OK
SYS_RET_OK:   
	; 18/07/2018
	; Offset 1666h in IBMDOS.COM (MSDOS 3.3), 1987
	; 23/07/2019 - Retro DOS v3.2
	;call	FETCHI_CHECK ; MSDOS 3.3 ! IBMDOS feature !  	
     
	call    Get_User_Stack
		; turn off user's carry flag
SYS_RET_OK_clc: ; 24/07/2019  
        ;and	word [SI+16h],0FFFEh 
       ;and	word [SI+user_env.user_F],~f_Carry
	; 24/07/2019
	and	byte [SI+user_env.user_F],~f_Carry ; 0FEh 
        JMP     SHORT DO_RET

        ;entry   SYS_RET_ERR
SYS_RET_ERR:        
	XOR     AH,AH 		; hack to allow for smaller error rets
	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
	CALL	ErrorMap

	;entry	From_GetSet
From_GetSet:
        call    Get_User_Stack
		 ; signal carry to user
	;or	word [SI+16h],1
	;OR	word [SI+user_env.user_F],f_Carry
	; 24/07/2019
	or	byte [SI+user_env.user_F],f_Carry
	STC			; also, signal internal error
DO_RET:
        ;MOV	[SI+user_env.user_AX], AX ; Really only sets AH
	MOV	[SI],AX
	RETN

	;entry	FCB_RET_OK
FCB_RET_OK:
	;entry	NO_OP		; obsolete system calls dispatch to here
NO_OP:
	XOR	AL,AL
	retn

	;entry	FCB_RET_ERR
FCB_RET_ERR:
	XOR	AH,AH
	mov	[ss:EXTERR],AX
	CALL	ErrorMap
	MOV	AL,-1
	retn

	;entry	ErrorMap
ErrorMap:
	PUSH	SI
				; ERR_TABLE_21 is now in DOSDATA
	MOV	SI,ERR_TABLE_21
				; SS override for FAILERR and EXTERR
	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
	JZ	short EXTENDED_NORMAL ; All is OK.
		 ; Ooops, this is the REAL reason
	;mov	word [SS:EXTERR],53h
	MOV	word [SS:EXTERR],error_FAIL_I24
EXTENDED_NORMAL:
	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
	POP	SI
	retn

	;EndProc SYS_RETURN

;---------------------------------------------------------------------------
;
; Procedure Name : CAL_LK
;
; Inputs:
;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
;		(DS NEED not be DOSDATA)
;	[EXTERR] is set with error
; Function:
;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
; Outputs:
;	[EXTERR_CLASS] set
;	[EXTERR_ACTION] set
;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
; Destroys SI, FLAGS
;
;---------------------------------------------------------------------------

	;procedure CAL_LK,NEAR
CAL_LK:
	PUSH	DS
	PUSH	AX
	PUSH	BX

;M048	Context DS		; DS:SI -> Table
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	;getdseg	<ds>	; M048: DS:SI -> Table

	; 18/07/2018
	push	ss
	pop	ds

	MOV	BX,[EXTERR]	; Get error in BL
TABLK1:
	LODSB

	CMP	AL,0FFH
	JZ	short GOT_VALS	; End of table
	CMP	AL,BL
	JZ	short GOT_VALS	; Got entry
	ADD	SI,3		; Next table entry
	; 15/08/2018
	JMP	short TABLK1

GOT_VALS:
	LODSW			; AL is CLASS, AH is ACTION

	CMP	AH,0FFH
	JZ	short NO_SET_ACT
	MOV	[EXTERR_ACTION],AH	; Set ACTION
NO_SET_ACT:
	CMP	AL,0FFH
	JZ	short NO_SET_CLS
	MOV	[EXTERR_CLASS],AL	; Set CLASS
NO_SET_CLS:
	LODSB			; Get LOCUS

	CMP	AL,0FFH
	JZ	short NO_SET_LOC
	MOV	[EXTERR_LOCUS],AL
NO_SET_LOC:
	POP	BX
	POP	AX
	POP	DS
	retn

	;EndProc CAL_LK

;---------------------------------------------------------------------------
;
; Procedure Name : ETAB_LK
;
; Inputs:
;	AX is error code
;	[USER_IN_AX] has AH value of system call involved
; Function:
;	Make sure error code is appropriate to this call.
; Outputs:
;	AX MAY be mapped error code
;	[EXTERR] = Input AX
; Destroys ONLY AX and FLAGS
;
;---------------------------------------------------------------------------

	;procedure ETAB_LK,NEAR

ETAB_LK: ; 10/08/2018
	PUSH	DS
	PUSH	SI
	PUSH	CX
	PUSH	BX

	;Context DS			; SS is DOSDATA

	push	ss
	pop	ds

	MOV	[EXTERR],AX		; Set EXTERR with "real" error

					; I21_MAP_E_TAB is now in DOSCODE
	MOV	SI,I21_MAP_E_TAB
	MOV	BH,AL			; Real code to BH
	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
TABLK2:
;;hkn;	LODSW
;	LODS	word ptr cs:[si] ; MSDOS 6.0
	
	; 18/07/2018
	lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h

	CMP	AL,0FFH 		; End of table?
	JZ	short NOT_IN_TABLE	; Yes
	CMP	AL,BL			; Found call?
	JZ	short GOT_CALL		; Yes
	XCHG	AH,AL			; Count to AL
	XOR	AH,AH			; Make word for add
	ADD	SI,AX			; Next table entry
	JMP	short TABLK2

NOT_IN_TABLE:
	MOV	AL,BH			; Restore original code
	JMP	SHORT NO_MAP

GOT_CALL:
	MOV	CL,AH
	XOR	CH,CH			; Count of valid err codes to CX
CHECK_CODE:
;;hkn;	LODSB
;	LODS	byte ptr cs:[si]

	; 18/07/2018
	lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h

	CMP	AL,BH			; Code OK?
	JZ	short NO_MAP		; Yes
	LOOP	CHECK_CODE
NO_MAP:
	XOR	AH,AH			; AX is now valid code
	POP	BX
	POP	CX
	POP	SI
	POP	DS
	retn

	;EndProc ETAB_LK

; 18/07/2018 - Retro DOS v3.0
;---------------------------------------------------------------------------
; BREAK <DOS 2F Handler and default NET 2F handler>

;IF installed
;---------------------------------------------------------------------------
;
; Procedure Name : SetBad
;
; SetBad sets up info for bad functions
;
;---------------------------------------------------------------------------

SetBad:
	;mov	ax,1
	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func

;	set up ds to point to DOSDATA

	; MSDOS 6.0
	;push	ds

	;getdseg <ds>
	;MOV	[EXTERR_LOCUS],errLOC_Unk	

	; MSDOS 3.3
	;mov	byte [cs:EXTERR_LOCUS],1
	MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk

	;pop	ds	  		;hkn; restore ds

	STC
	retn

;--------------------------------------------------------------------------
;
; Procedure Name : BadCall
;
; BadCall is the initial routine for bad function calls
;
;--------------------------------------------------------------------------

BadCall:
	call	SetBad
	retf

;--------------------------------------------------------------------------
;
; OKCall always sets carry to off.
;
;-----------------------------------------------------------------------

OKCall:
	CLC
	retf

;---------------------------------------------------------------------------
;
; Procedure Name : INT2F
;
; INT 2F handler works as follows:
;   PUSH    AX
;   MOV     AX,multiplex:function
;   INT     2F
;   POP     ...
; The handler itself needs to make the AX available for the various routines.
;
;----------------------------------------------------------------------------

;PUBLIC	Int2F
;INT2F	PROC	FAR

	; 18/07/2018 - Retro DOS v3.0

INT2F:
	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
INT2FNT:
	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	STI
	;cmp	ah,11h
	CMP	AH,MultNET
	JNZ	short INT2FSHR
TestInstall:
	OR	AL,AL
	JZ	short Leave2F
BadFunc:
	CALL	SetBad

	;entry	Leave2F
Leave2F:
	RETF	2			; long return + clear flags off stack

INT2FSHR:
	;cmp	ah,10h
	CMP	AH,MultSHARE		; is this a share request
	JZ	short TestInstall	; yes, check for installation
INT2FNLS:
	;cmp	ah,14h
	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
	JZ	short TestInstall	; yes check for installation
INT2FDOS:
	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING

	; 18/07/2018
	; MSDOS 6.0
	;CMP	AH,MultDOS
	;JNZ	check_win		;check if win386 broadcast
	;jmp	DispatchDOS

	; .... win386 .... 
	
	; 18/07/2018
	; MSDOS 3.3
	;cmp	ah,12h	
	CMP	AH,MultDOS
	jz	short DispatchDOS
	iret

;INT2F	ENDP
	
DispatchDOS:
	PUSH	word [CS:FOO]		; push return address
	PUSH	word [CS:DTab]		; push table address
	PUSH	AX			; push index
	PUSH	BP
	MOV	BP,SP
		; stack looks like:
		;   0	BP
		;   2	DISPATCH
		;   4	TABLE
		;   6	RETURN
		;   8	LONG-RETURN
		;   c	FLAGS
		;   e	AX
	
	MOV	AX,[BP+0Eh]		; get AX value
	POP	BP
	call	TableDispatch
	JMP	short BadFunc 		; return indicates invalid function

INT2F_etcetera:
	;entry	DosGetGroup
DosGetGroup:
	; MSDOS 6.0
;SR; Cannot use CS now
;
;	PUSH	CS
;	POP	DS

	;getdseg <ds>
	;retn

	; MSDOS 3.3
	push	cs
	pop	ds
	retn

	;entry	DOSInstall
DOSInstall:
	MOV	AL,0FFh
	retn

;ENDIF

;============================================================================
; DOSTAB.ASM (MSDOS 6.0, 1991)
;============================================================================
; 18/07/2018 - Retro DOS 3.0

;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
;     ENTRY: AL = Character to map
;     EXIT:  AL = The converted character
; Alters no registers except AL and flags.
; The routine should do nothing to chars below 80H.
;
; Example:

;Procedure   MAP_CASE,FAR

MAP_CASE:
	; Offset 176Ch in IBMDOS.COM (MSDOS 3.3), 1987
	
	CMP	AL,80H
	JAE	short Map1	;Map no chars below 80H ever
	RETF
Map1:
	SUB	AL,80H		;Turn into index value
	PUSH	DS
	PUSH	BX
	MOV	BX,UCASE_TAB+2
FINISH:
	PUSH	CS		;Move to DS
	POP	DS
	XLAT			; Get upper case character
	POP	BX
	POP	DS
L_RET:	
	RETF

;EndProc MAP_CASE

;============================================================================
; DOSMES.INC (MSDOS 6.0, 1991)
;============================================================================
; 18/07/2018 - Retro DOS v3.0

; DOSMES.ASM (MSDOS 2.11, 1983)

; OEMFunction key is expected to process a single function
;   key input from a device and dispatch to the proper
;   routines leaving all registers UNTOUCHED.
;
; Inputs:   CS, SS are DOSGROUP
; Outputs:  None. This function is expected to JMP to onw of
;           the following labels:
;
;           GetCh       - ignore the sequence
;           TwoEsc      - insert an ESCChar in the buffer
;           ExitIns     - toggle insert mode
;           EnterIns    - toggle insert mode
;           BackSp      - move backwards one space
;           ReEdit      - reedit the line with a new template
;           KilNew      - discard the current line and start from scratch
;           CopyLin     - copy the rest of the template into the line
;           SkipStr     - read the next character and skip to it in the template
;           CopyStr     - read next char and copy from template to line until char
;           SkipOne     - advance position in template one character
;           CopyOne     - copy next character in template into line
;           CtrlZ       - place a ^Z into the template
; Registers that are allowed to be modified by this function are:
;           AX, CX, BP

OEMFunctionKey:
	CALL	_$STD_CON_INPUT_NO_ECHO  ; Get the second byte of the sequence
	MOV     CL,ESCTABLEN ; 14	; length of table for scan
	PUSH    DI                      ; save DI (cannot change it!)
	MOV     DI,ESCTAB		; offset of second byte table
	REPNE   SCASB                   ; Look it up in the table
	POP     DI                      ; restore DI
	SHL     CX,1                    ; convert byte offset to word
	MOV     BP,CX                   ; move to indexable register
	;JMP	word [SS:BP+ESCFUNC]	; Go to the right routine
	JMP	word [BP+ESCFUNC]
	
;============================================================================
; TIME.ASM (MSDOS 6.0, 1991)
;============================================================================
; Retro DOS v3.0 - 18/07/2018

; SYSCALL.ASM (MSDOS 2.11, 1983)
;----------------------------------------------------------------------------
; Retro DOS v2.0 - 13/03/2018

;**	TIME.ASM - System Calls and low level routines for DATE and TIME

	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>

;**	$GET_DATE - Get Current Date
;
;	ENTRY	none
;	EXIT	(cx:dx) = current date
;	USES	all

_$GET_DATE:	;System call 42

        PUSH    SS
        POP     DS
        CALL	READTIME        ;Check for rollover to next day
        MOV     AX,[YEAR]

;	WARNING!!!! DAY and MONTH must be adjacently allocated!

        MOV     BX,[DAY]	; fetch both day and month
	CALL	Get_User_Stack	;Get pointer to user registers
        ;MOV    [SI+6],BX  	;DH=month, DL=day
	MOV	[SI+user_env.user_DX],BX
        ADD     AX,1980         ;Put bias back
        ;MOV    [SI+4],AX  	;CX=year
	MOV	[SI+user_env.user_CX],AX
        ;MOV	AL,[WEEKDAY]
        MOV	AL,[SS:WEEKDAY]	;hkn; SS override
	RETN

;**	$SET_DATE - Set Current Date
;
;	ENTRY	(cx:dx) = current date
;	EXIT	(al) = -1 iff bad date
;		(al) = 0 if ok
;	USES	all

_$SET_DATE:			;System call 43

        MOV     AL,-1           ;Be ready to flag error
        SUB     CX,1980         ;Fix bias in year
        JC      SHORT RET24	;Error if not big enough
        CMP     CX,119          ;Year must be less than 2100
        JA      SHORT RET24
        OR      DH,DH
        JZ      SHORT RET24
        OR      DL,DL
        JZ      SHORT RET24	;Error if either month or day is 0
        CMP     DH,12           ;Check against max. month
        JA      SHORT RET24
        PUSH    SS
        POP     DS
	CALL	DODATE
RET24:  
	RETN


;**	$GET_TIME - Get Current Time
;
;	ENTRY	none
;	EXIT	(cx:dx) = current time
;	USES	all

_$GET_TIME:			;System call 44

        PUSH    SS
        POP     DS
	CALL	READTIME
	CALL	Get_User_Stack           ;Get pointer to user registers
       ;MOV     [SI+6],DX
	MOV	[SI+user_env.user_DX],DX
       ;MOV     [SI+4],CX
	MOV	[SI+user_env.user_CX],CX
        XOR     AL,AL
RET26:  
	RETN

;**	$SET_TIME - Set Current Time
;
;	ENTRY	(cx:dx) = time
;	EXIT	(al) = 0 if 0k
;		(al) = -1 if invalid
;	USES	ALL

_$SET_TIME:			;System call 45

        MOV     AL,-1           ;Flag in case of error
        CMP     CH,24           ;Check hours
        JAE     SHORT RET26
        CMP     CL,60           ;Check minutes
        JAE     SHORT RET26
        CMP     DH,60           ;Check seconds
        JAE     SHORT RET26
        CMP     DL,100          ;Check 1/100's
        JAE     SHORT RET26
        PUSH    CX
        PUSH    DX
        PUSH    SS
        POP     DS
        MOV     BX,TIMEBUF
        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
        PUSH    BX
	CALL	SETREAD
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Get correct day count
        POP     DS
        POP     BX
	CALL	SETWRITE
        POP     WORD [TIMEBUF+4]
        POP     WORD [TIMEBUF+2]
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Set the time
        XOR     AL,AL
        RETN

; 11/07/2018 - Retro DOS v3.0
; Retro DOS v2.0 - 14/03/2018

FOURYEARS EQU 3*365 + 366  ; = 1461 

;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE

;
; Date16 returns the current date in AX, current time in DX
;   AX - YYYYYYYMMMMDDDDD  years months days
;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
;

DATE16:
	
;M048	Context DS
;
; Since this function can be called thru int 2f we shall not assume that SS
; is DOSDATA

	;getdseg	<ds>			; M048

	;PUSH	SS
	PUSH	CS
	POP	DS

        PUSH    CX
        PUSH    ES
        CALL    READTIME
        POP     ES
        SHL     CL,1            ;Minutes to left part of byte
        SHL     CL,1
        SHL     CX,1            ;Push hours and minutes to left end
        SHL     CX,1
        SHL     CX,1
        SHR     DH,1            ;Count every two seconds
        OR      CL,DH           ;Combine seconds with hours and minutes
        MOV     DX,CX

;	WARNING!  MONTH and YEAR must be adjacently allocated

        MOV     AX,[MONTH]	;Fetch month and year
        MOV     CL,4
        SHL     AL,CL		;Push month to left to make room for day
        SHL     AX,1
        POP     CX
        OR      AL,[DAY]
RET21:
        RETN

READTIME:
;Gets time in CX:DX. Figures new date if it has changed.
;Uses AX, CX, DX.

	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
        PUSH    SI
        PUSH    BX

        MOV     BX,TIMEBUF

        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
	CALL	SETREAD
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Get correct date and time
        POP     DS
        POP     BX
        POP     SI
        MOV     AX,[TIMEBUF]
        MOV     CX,[TIMEBUF+2]
        MOV     DX,[TIMEBUF+4]
        CMP     AX,[DAYCNT]     ;See if day count is the same
        ;JZ	SHORT RET22
	JZ	SHORT RET21 ; 18/07/2018
	;cmp	ax,43830
        CMP     AX,FOURYEARS*30 ;Number of days in 120 years
        JAE     SHORT RET22	;Ignore if too large
        MOV     [DAYCNT],AX
        PUSH    SI
        PUSH    CX
        PUSH    DX              ;Save time
        XOR     DX,DX
	;mov	cx,1461
        MOV     CX,FOURYEARS    ;Number of days in 4 years
        DIV     CX              ;Compute number of 4-year units
        SHL     AX,1
        SHL     AX,1
        SHL     AX,1            ;Multiply by 8 (no. of half-years)
        MOV     CX,AX           ;<240 implies AH=0

        MOV     SI,YRTAB        ;Table of days in each year

        CALL    DSLIDE          ;Find out which of four years we're in
        SHR     CX,1            ;Convert half-years to whole years
        JNC     SHORT SK	;Extra half-year?
        ADD     DX,200
SK:
        CALL    SETYEAR
        MOV     CL,1            ;At least at first month in year

        MOV     SI,MONTAB       ;Table of days in each month
        
	CALL    DSLIDE          ;Find out which month we're in
        MOV     [MONTH],CL
        INC     DX              ;Remainder is day of month (start with one)
        MOV     [DAY],DL
        CALL    WKDAY           ;Set day of week
        POP     DX
        POP     CX
        POP     SI
RET22:  
	RETN

DSLIDE:
        MOV     AH,0
DSLIDE1:
        LODSB			;Get count of days
        CMP     DX,AX           ;See if it will fit
        JB      SHORT RET23	;If not, done
        SUB     DX,AX
        INC     CX              ;Count one more month/year
        JMP     SHORT DSLIDE1

SETYEAR:
;Set year with value in CX. Adjust length of February for this year.

; NOTE: This can also be called thru int 2f. If this is called then it will
;       set DS to DOSDATA. Since the only guy calling this should be the DOS
;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
;	preserve DS as CHKYR is also called as a routine.


	; MSDOS 6.0 (18/07/2018) ; *

	;GETDSEG DS

	PUSH	CS  ; *
	POP	DS  ; *

	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987 

        MOV     [YEAR],CL
CHKYR:
        TEST    CL,3            ;Check for leap year
        MOV     AL,28
        JNZ     SHORT SAVFEB	;28 days if no leap year
        INC     AL              ;Add leap day
SAVFEB:
	;mov	[february],al
        MOV     [MONTAB+1],AL   ;Store for February
RET23:  
	RETN

DODATE:
        CALL    CHKYR           ;Set Feb. up for new year
        MOV     AL,DH

        MOV     BX,MONTAB-1

        XLAT                    ;Look up days in month
        CMP     AL,DL
        MOV     AL,-1           ;Restore error flag, just in case
        ;JB	SHORT RET25	;Error if too many days
        jb	short RET23 ; 18/07/2018
	CALL    SETYEAR
;
; WARNING!  DAY and MONTH must be adjacently allocated
;
        MOV     [DAY],DX	;Set both day and month
        SHR     CX,1
        SHR     CX,1
	;mov	ax,1461
        MOV     AX,FOURYEARS
        MOV     BX,DX
        MUL     CX
        MOV     CL,[YEAR]
        AND     CL,3

        MOV     SI,YRTAB

        MOV     DX,AX
        SHL     CX,1            ;Two entries per year, so double count
        CALL    DSUM            ;Add up the days in each year
        MOV     CL,BH           ;Month of year

        MOV     SI,MONTAB

        DEC     CX              ;Account for months starting with one
        CALL    DSUM            ;Add up days in each month
        MOV     CL,BL           ;Day of month
        DEC     CX              ;Account for days starting with one
        ADD     DX,CX           ;Add in to day total
        XCHG    AX,DX           ;Get day count in AX
        MOV     [DAYCNT],AX
        PUSH    SI
        PUSH    BX
        PUSH    AX

        MOV     BX,TIMEBUF

        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
        PUSH    BX
	CALL	SETREAD

        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2	;Get correct date and time
        POP     DS
        POP     BX
	CALL	SETWRITE
        POP     WORD [TIMEBUF]
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Set the date
        POP     DS
        POP     BX
        POP     SI
WKDAY:
        MOV     AX,[DAYCNT]
        XOR     DX,DX
        MOV     CX,7
        INC     AX
        INC     AX              ;First day was Tuesday
        DIV     CX              ;Compute day of week
        MOV     [WEEKDAY],DL
        XOR     AL,AL           ;Flag OK
RET25:
	RETN

;**	DSUM - Compute the sum of a string of bytes
;
;	ENTRY	(cx) = byte count
;		(ds:si) = byte address
;		(dx) = sum register, initialized by caller
;	EXIT	(dx) updated
;	USES	ax, cx, dx, si, flags

DSUM:
        MOV     AH,0
	;JCXZ	DSUM9
        JCXZ	RET25 ; 18/07/2018
DSUM1:
        LODSB
        ADD     DX,AX
        LOOP    DSUM1
DSUM9:
        RETN


;============================================================================
; GETSET.ASM
;============================================================================
; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
; Retro DOS v2.0 - 12/03/2018

;TITLE	GETSET - GETting and SETting MS-DOS system calls
;NAME	GETSET

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;USERNUM:
;	DW	0			; 24 bit user number
;       DB      0
;;	IF      IBM
;;OEMNUM: DB    0			; 8 bit OEM number
;;	ELSE
;OEMNUM: DB     0FFH			; 8 bit OEM number
;;	ENDIF

;MSVERS:		; MS-DOS version in hex for $GET_VERSION
;; 08/07/2018 - Retro DOS v3.0
;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  


;BREAK <$Get_Version -- Return MSDOS version number>

_$GET_VERSION:

; Inputs:
;       None
; Function:
;       Return MS-DOS version number
; Outputs:
;       OEM number in BH
;       User number in BL:CX (24 bits)
;       Version number as AL.AH in binary
;       NOTE: On pre 1.28 DOSs AL will be zero

; MSDOS 6.0
;		if input al = 00
;		  (bh) = OEM number			
;		else if input al = 01
;		  (bh) = version flags
;		 
;		       	 bits 0-2 = DOS internal revision
;		       	 bits 3-7 = DOS type flags
;		              bit 3    = DOS is in ROM
;		              bit 4    = DOS in in HMA
;		              bits 5-7 = reserved
;               M007 change - only bit 3 is now valid.  Other bits
;               are 0 when AL = 1

	
	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)

        PUSH    SS
        POP     DS
        MOV     BX,[USERNUM+2]
        MOV     CX,[USERNUM]
        MOV     AX,[MSVERS]
        call	Get_User_Stack
        ;MOV	[SI+2],BX
	mov	[SI+user_env.user_BX],BX
        ;MOV	[SI+4],CX
	mov	[SI+user_env.user_CX],CX
        ;MOV	[SI+user_env.user_AX],AX  ; Really only sets AH
        MOV	[SI],AX ; 31/03/2018
	RETN

; 18/07/2018 - Retro DOS v3.0

;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>

;**	$Get_Verify_On_Write - Get Status of Verify on write flag
;
;	ENTRY	none
;	EXIT	(al) = value of VERIFY flag
;	USES	all


_$GET_VERIFY_ON_WRITE:

;hkn; SS override
	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
	retn

;**	$Set_Verify_On_Write - Set Status of Verify on write flag
;
;	ENTRY	(al) = value of VERIFY flag
;	EXIT	none
;	USES	all

_$SET_VERIFY_ON_WRITE:

	AND	AL,1
;hkn; SS override
	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
RET27:	; 18/07/2018
	retn

; 19/07/2018 - Retro DOS v3.0

;BREAK <$International - return country-dependent information>

;----------------------------------------------------------------------------
;
; Procedure Name : $INTERNATIONAL
;
; Inputs:
;	MOV	AH,International
;	MOV	AL,country	(al = 0 => current country)
;      [MOV	BX,country]
;	LDS	DX,block
;	INT	21
; Function:
;	give users an idea of what country the application is running
; Outputs:
;	IF DX != -1 on input (get country)
;	  AL = 0 means return current country table.
;	  0<AL<0FFH means return country table for country AL
;	  AL = 0FF means return country table for country BX
;	  No Carry:
;	     Register BX will contain the 16-bit country code.
;	     Register AL will contain the low 8 bits of the country code.
;	     The block pointed to by DS:DX is filled in with the information
;	     for the particular country.
;		BYTE  Size of this table excluding this byte and the next
;		BYTE  Country code represented by this table
;			A sequence of n bytes, where n is the number specified
;			by the first byte above and is not > internat_block_max,
;			in the correct order for being returned by the
;			INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.	=0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.	=0 12 hour clock  =1 24 hour
;		DWORD	Call address of case conversion routine
;		2 BYTE	Data list separator null terminated.
;	  Carry:
;	     Register AX has the error code.
;	IF DX = -1 on input (set current country)
;	  AL = 0 is an error
;	  0<AL<0FFH means set current country to country AL
;	  AL = 0FF means set current country to country BX
;	  No Carry:
;	    Current country SET
;	    Register AL will contain the low 8 bits of the country code.
;	  Carry:
;	     Register AX has the error code.
;-----------------------------------------------------------------------------

;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3

_$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
	 
	CMP	AL,0FFH
	JZ	short BX_HAS_CODE	; -1 means country code is in BX
	MOV	BL,AL			; Put AL country code in BX
	XOR	BH,BH
BX_HAS_CODE:
	PUSH	DS
	POP	ES
	PUSH	DX
	POP	DI			; User buffer to ES:DI

;hkn; SS is DOSDATA
;	context DS

	push	ss
	pop	ds

	CMP	DI,-1
	JZ	short international_set
	OR	BX,BX
	JNZ	short international_find

;hkn; country_cdpg is in DOSDATA segment.
	MOV	SI,COUNTRY_CDPG

	JMP	SHORT international_copy

international_find:
	MOV	BP,0			 ; flag it for GetCntry only
	CALL	international_get
	JC	short errtn
	CMP	BX,0			 ; nlsfunc finished it ?
	JNZ	SHORT international_copy ; no, copy by myself
	MOV	BX,DX			 ; put country back
	JMP	SHORT international_ok3

international_get:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	MOV	SI,COUNTRY_CDPG

	; MSDOS 6.0
	;CMP	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
	;retz				 ; return if equal

	; MSDOS 3.3
	;cmp	bx,[SI+63h]
	CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
	jz	short RET27

	MOV	DX,BX
	XOR	BX,BX			; bx = 0, default code page
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory

	mov	ax,1400h
	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	
	CMP	AL,0FFH
	JNZ	short interr		; not in memory
	;cmp	bp,0
	or	bp,bp			; GetCntry ?
	JNZ	short stcdpg
	;CallInstall GetCntry,NLSFUNC,4	; get country info

	mov     ax,1404h
	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
			; BX = code page, DX = country code,
			; DS:SI -> internal code page structure
			; ES:DI -> user buffer
			; Return: AL = status

	JMP	short chkok
	
	;nop

stcdpg:
	;CallInstall SetCodePage,NLSFUNC,3  ; set country info

	mov     ax,1403h
	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
			; DS:SI -> internal code page structure
			; BX = code page, DX = country code
			; Return: AL = status
chkok:
	or	al,al			; success ?
	;retz				; yes
	jz	short RET27

setcarry:
	STC				; set carry
	retn
interr:
	MOV	AL,0FFH			; flag nlsfunc error
	JMP	short setcarry

international_copy:

;hkn; country_cdpg is in DOSDATA segment.
;hkn; use ss override to access COUNTRY_CDPG fields
	; MSDOS 6.0
	;MOV	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
	;MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccDFormat

	; MSDOS 3.3
	;mov	bx,[SI+63h]
	mov	BX,[SI+DOS_CCDPG.ccDosCountry]
	mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018

	;mov	cx,24
	MOV	CX,OLD_COUNTRY_SIZE

	; MSDOS 6.0
;hkn;	must set up DS to SS so that international info can be copied
	;push	ds
	;push	ss					; cs -> ss
	;pop	ds

	REP	MOVSB			;copy country info

	; MSDOS 6.0
;hkn;	restore ds
	;pop	ds

international_ok3:
	call	Get_User_Stack
;ASSUME	DS:NOTHING
	;MOV	[SI+2],BX
	MOV	[SI+user_env.user_BX],BX
international_ok:
	MOV	AX,BX			; Return country code in AX too.
	jmp	SYS_RET_OK

international_set:

;hkn; ASSUME	DS:DOSGROUP
;ASSUME	DS:DOSDATA

	MOV	BP,1			; flag it for SetCodePage only
	CALL	international_get
	JNC	short international_ok
errtn:
	CMP	AL,0FFH
	JZ	short errtn2
errtn1:
	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
errtn2:
	;error	error_invalid_function	; NLSFUNC not existent

	;mov	al,1
	mov	al,error_invalid_function 
	;jmp	short errtn1
errtn3:
	jmp	SYS_RET_ERR

;EndProc $INTERNATIONAL

; 19/07/2018

;BREAK <$GetExtCntry - return extended country-dependent information>

;---------------------------------------------------------------------------
;
; Procedure Name : $GetExtCntry
;
; Inputs:
;	if AL >= 20H
;	  AL= 20H    capitalize single char, DL= char
;	      21H    capitalize string, CX= string length
;	      22H    capitalize ASCIIZ string
;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
;	      80H bit 0 = use normal upper case table
;		      1 = use file upper case table
;	   DS:DX points to string
;
;	else
;
;	MOV	AH,GetExtCntry	 ; DOS 3.3
;	MOV	AL,INFO_ID	( info type,-1 selects all )
;	MOV	BX,CODE_PAGE	( -1 = active code page )
;	MOV	DX,COUNTRY_ID	( -1 = active country )
;	MOV	CX,SIZE 	( amount of data to return )
;	LES	DI,COUNTRY_INFO ( buffer for returned data )
;	INT	21
; Function:
;	give users extended country dependent information
;	or capitalize chars
; Outputs:
;	  No Carry:
;	     extended country info is succesfully returned
;	  Carry:
;	     Register AX has the error code.
;	     AX=0, NO	 for YES/NO CHECK
;		1, YES
;-------------------------------------------------------------------------------

;procedure   $GetExtCntry,NEAR	; DOS 3.3

	; MSDOS 6.0
_$GetExtCntry:
	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
	JB	short notcap
capcap: 				;
	TEST	AL,UPPER_TABLE	; 80h	; which upper case table
	JNZ	short fileupper		; file upper case

;hkn; UCASE_TAB in DOSDATA
	MOV	BX,UCASE_TAB+2		; get normal upper case

	JMP	SHORT capit

fileupper:
	; 16/01/2024 (MSDOS 3.3-6.22 MSDOS.SYS has a bug here)
	; (PCDOS 7.1 IBMDOS.COM - DOSCODE:4C57h)
	; ((Note: This must be a bugfix, because bit 7 of AX is 1 here!))
	; AL >= 80h
	and	al,7Fh

;hkn; FILE_UCASE_TAB in DOSDATA
	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
capit:					;
	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
	JNZ	short chkyes		; no
	MOV	AL,DL			; set up AL
	call	GETLET3 		; upper case it
	call	Get_User_Stack		; get user stack
	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
	JMP	SHORT nono		; done
chkyes: 				;
	CMP	AL,CHECK_YES_NO		; check YES or NO ?
	JNZ	short capstring		; no
	XOR	AX,AX			; presume NO
		      
;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
;hkn; included in yesno.asm in the DOSCODE segment.

	; 06/08/2018 - Retro DOS v3.0
	;CMP	DL,[cs:NLS_YES]		; is 'Y' ?
	cmp	DL,'Y'
	JZ	short yesyes		; yes
	;CMP	DL,[cs:NLS_yes2]	; is 'y' ?
	cmp	dl,'y'
	JZ	short yesyes		; yes
	cmp	dl,'N'
	;CMP	DL,[cs:NLS_NO]		; is  'N'?
	JZ	short nono		; no
	CMP	DL,'n'
	;CMP	DL,[cs:NLS_no2]		; is 'n' ?
	JZ	short nono		; no
;dbcs_char:				;
	INC	AX			; not YES or NO
yesyes: 				;
	INC	AX			; return 1
nono:					;
	jmp	SYS_RET_OK		; done
capstring:				;
	MOV	SI,DX			; si=dx
	CMP	AL,CAP_STRING		; cap string ?
	JNZ	short capascii		; no
	OR	CX,CX			; check count 0
	JZ	short nono		; yes finished
concap: 				;
	LODSB				; get char
	call	GETLET3 		; upper case it
	MOV	byte [SI-1],AL		; store back
next99: 				;
	LOOP	concap			; continue
	JMP	short nono		; done
capascii:				;
	CMP	AL,CAP_ASCIIZ		; cap ASCIIZ string ?
	JNZ	short capinval		; no
concap2:				;
	LODSB				; get char
	or	al,al			; end of string ?
	JZ	short nono		; yes
	call	GETLET3 		; upper case it
	MOV	[SI-1],AL		; store back
	JMP	short concap2 		; continue

	; MSDOS 3.3 ($ MSDOS 6.0)

; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
; _$GetExtCntry:

notcap:
	CMP	CX,5			; minimum size is 5
	jb	short sizeerror

GEC_CONT:
;hkn; SS is DOSDATA
	;context DS

	push	ss
	;pop	es  ; ! (Retro DOS v3.0 BUG) !
	pop	ds  ; 17/05/2019 - BugFix
	
;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,COUNTRY_CDPG

	CMP	DX,-1			; active country ?
	JNZ	short GETCDPG 		; no

;hkn; use DS override to accesss country_cdpg fields
	;mov	dx,[si+63h]
	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
					; get active country id;smr;use DS
GETCDPG:
	CMP	BX,-1			; active code page?
	JNZ	short CHKAGAIN		; no, check again

;hkn; use DS override to accesss country_cdpg fields
	;mov	bx,[si+65h]
	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
					; get active code page id;smr;Use DS
CHKAGAIN:
	;cmp	dx,[si+63h]
	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
					; same as active country id?;smr;use DS
	JNZ	short CHKNLS		; no
	;cmp	bx,[si+65h]
	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
					; same as active code pg id?;smr;use DS
	JNZ	short CHKNLS		; no
CHKTYPE:
	;mov	bx,[si+48h]
	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
					; bx = sys code page id;smr;use DS
;	CMP	AL,SetALL		; select all?
;	JNZ	short SELONE
;	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccNumber_of_entries
;SELONE:
	PUSH	CX			; save cx
	;mov	cx,[si+4Ah]
	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]	;smr;use DS
	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
NXTENTRY:
	CMP	AL,[SI] 		; compare info type;smr;use DS
	JZ	short FOUNDIT
	ADD	SI,5			; next entry
	LOOP	NXTENTRY
	POP	CX
capinval:
	;error	error_invalid_function	; info type not found
	;mov	al,1
	mov	al,error_invalid_function
	jmp	SYS_RET_ERR

FOUNDIT:
	MOVSB				; move info id byte
	POP	CX			; retsore char count
	;cmp	al,1
	CMP	AL,SetCountryInfo	; select country info type ?
	JZ	short setsize
	MOV	CX,4			; 4 bytes will be moved
	MOV	AX,5			; 5 bytes will be returned in CX
OK_RETN:
	REP	MOVSB			; copy info
	MOV	CX,AX			; CX = actual length returned
	MOV	AX,BX			; return sys code page in ax
GETDONE:
	call	Get_User_Stack		; return actual length to user's CX
	;mov	[si+4],cx 
	MOV	[SI+user_env.user_CX],CX
	; 26/07/2019
	;jmp	SYS_RET_OK
	jmp	SYS_RET_OK_clc
setsize:
	SUB	CX,3			; size after length field
	CMP	[SI],CX			; less than table size ;smr;use ds
	JAE	short setsize2		; no
	MOV	CX,[SI]			; truncate to table size ;smr;use ds
setsize2:
	MOV	[ES:DI],CX		; copy actual length to user's
	ADD	DI,2			; update index
	ADD	SI,2
	MOV	AX,CX
	ADD	AX,3			; AX has the actual length
	JMP	short OK_RETN 		; go move it
CHKNLS:
	XOR	AH,AH
	PUSH	AX			; save info type
	POP	BP			; bp = info type
	
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory

	mov     ax, 1400h
	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	
	CMP	AL,0FFH
	JZ	short NLSNXT		; in memory

sizeerror:
	;error	error_invalid_function
	;mov	al,1
	mov	al,error_invalid_function
	jmp	SYS_RET_ERR

NLSNXT: 
	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info

	mov     ax, 1402h
	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
			; BP = subfunction, BX = code page
			; DX = country code, DS:SI -> internal code page structure
			; ES:DI -> user buffer, CX = size of user buffer
			; Return: AL = status
			; 00h successful
			; else DOS error code

	CMP	AL,0			; success ?
	JNZ	short NLSERROR
	mov     ax,[si+48h]
	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]	
			; ax = sys code page id;smr;use ds;
			;BUGBUG;check whether DS is OK after the above calls
	JMP	short GETDONE
NLSERROR:
	jmp	SYS_RET_ERR		; return what is got from NLSFUNC

;EndProc $GetExtCntry

;BREAK <$GetSetCdPg - get or set global code page>

;**	$GetSetCdPg - Get or Set Global Code Page
;
;   System call format:
;
;	MOV	AH,GetSetCdPg	; DOS 3.3
;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
;	MOV	BX,CODE_PAGE	( set code page only)
;	INT	21
;
;	ENTRY	(al) = n
;		(bx) = code page
;	EXIT	'C' clear
;		  global code page is set	(set global code page)
;		  (BX) = active code page id	(get global code page)
;		  (DX) = system code page id	(get global code page)
;		'C' set
;		  (AX) = error code

;procedure  $GetSetCdPg,NEAR   ; DOS 3.3

_$GetSetCdPg:

;hkn; SS is DOSDATA
	;context DS

	push	ss
	pop	ds

;hkn; COUNTRY_CDPG is in DOSDATA
	MOV	SI,COUNTRY_CDPG

	CMP	AL,1		       ; get global code page
	JNZ	short setglpg 	       ; set global cod epage
	;mov	bx,[si+65h]
	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
					; get active code page id;smr;use ds
	;mov	dx,[si+48h]
	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
				  	; get sys code page id;smr;use ds
	call	Get_User_Stack
;ASSUME DS:NOTHING
	;mov	[si+2],bx
	MOV	[SI+user_env.user_BX],BX ; update returned bx
	;mov	[si+6],dx
	MOV	[SI+user_env.user_DX],DX ; update returned dx
OK_RETURN:
	;transfer SYS_RET_OK
	jmp	SYS_RET_OK

;hkn; ASSUME DS:DOSGROUP
;ASSUME	DS:DOSDATA

setglpg:
	CMP	AL,2
	JNZ	short nomem
;;;;;;; CMP	BX,[SI+DOS_CCDPG.ccDosCodePage] ; same as active code page
;;;;;;; JZ	short OK_RETURN		; yes
	;mov	dx,[si+63h]
	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
	mov     ax, 1400h
	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, not OK
			; FFh installed
	CMP	AL,0FFH
	JNZ	short nomem		; not in memory
	;CallInstall SetCodePage,NLSFUNC,1  ;set the code page
	mov     ax, 1401h
	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
			; DS:SI -> internal code page structure
			; BX = new code page, DX = country code???
			; Return: AL = status
			; 00h successful
			; else DOS error code
	;cmp	al,0
	or	al,al			   ; success ?
	JZ	short OK_RETURN		   ; yes
	CMP	AL,65			   ; set device code page failed
	JNZ	short seterr
	MOV	AX,65
	MOV	[EXTERR],AX
	;mov	byte [EXTERR_ACTION],6
	;mov	byte [EXTERR_CLASS],5
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_ACTION],errACT_Ignore
	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;transfer From_GetSet
	jmp	From_GetSet

seterr:
	;transfer SYS_RET_ERR
	jmp	SYS_RET_ERR

nomem:
	;error	error_invalid_function ; function not defined
	;mov	al,1
	mov	al,error_invalid_function
	jmp	short seterr

;EndProc $GetSetCdPg


;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>

;**	$Get_Drive_Freespace - Return amount of drive free space
;
;	$Get_Drive_Freespace returns the # of free allocation units on a
;		drive.
;
;	This call returns the same info in the same registers (except for the
;	FAT pointer) as the old FAT pointer calls
;
;	ENTRY	DL = Drive number
;	EXIT	AX = Sectors per allocation unit
;		   = -1 if bad drive specified
;		On User Stack
;		    BX = Number of free allocation units
;		    DX = Total Number of allocation units on disk
;		    CX = Sector size

;procedure   $GET_DRIVE_FREESPACE,NEAR

_$GET_DRIVE_FREESPACE:

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds

	MOV	AL,DL
	;invoke	GetThisDrv		; Get drive
	call	GETTHISDRV
SET_AX_RET:
	JC	short BADFDRV
	;invoke	DISK_INFO
	call	DISK_INFO
	XCHG	DX,BX
	JC	short SET_AX_RET	; User FAILed to I 24
	XOR	AH,AH			; Chuck Fat ID byte
DoSt:
	call	Get_User_Stack
;ASSUME	DS:NOTHING
	;mov	[si+6],dx
	;mov	[si+4],cx
	;mov	[si+2],bx
	MOV	[SI+user_env.user_DX],DX
	MOV	[SI+user_env.user_CX],CX
	MOV	[SI+user_env.user_BX],BX
	;MOV	[SI+user_env.user_AX],AX
	mov     [si],ax
	;return
	retn

BADFDRV:
	; MSDOS 3.3
	;mov	al,0Fh
	mov	al,error_invalid_drive	; Assume error

	;invoke	FCB_RET_ERR
	call	FCB_RET_ERR
	MOV	AX,-1
	JMP	short DoSt

;EndProc $GET_DRIVE_FREESPACE


;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>

;**	$Get_DMA - Get Disk Transfer Address
;
;	ENTRY	none
;	EXIT	ES:BX is current transfer address
;	USES	all

_$GET_DMA:
	MOV	BX,[SS:DMAADD]
	MOV	CX,[SS:DMAADD+2]
	call	Get_User_Stack
	;mov	[si+2],bx
	;mov	[si+10h],cx
	MOV	[SI+user_env.user_BX],BX
	MOV	[SI+user_env.user_ES],CX
	retn

;**	$Set_DMA - Set Disk Transfer Address
;
;	ENTRY	DS:DX is current transfer address
;	EXIT	none
;	USES	all

_$SET_DMA:
	MOV	[SS:DMAADD],DX
	MOV	[SS:DMAADD+2],DS
	retn

;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>

;**	$Get_Default_Drive - Get Current Default Drive
;
;	ENTRY	none
;	EXIT	(AL) = drive number
;	USES	all

_$GET_DEFAULT_DRIVE:
	MOV	AL,[SS:CURDRV]
	retn

;**	$Set_Default_Drive - Specify new Default Drive
;
;	ENTRY	(DL) = Drive number for new default drive
;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD

_$SET_DEFAULT_DRIVE:
	MOV	AL,DL
	INC	AL			; A=1, B=2...
	call	GetVisDrv		; see if visible drive
	JC	short SETRET		; errors do not set
	MOV	[SS:CURDRV],AL		; no, set

SETRET:
	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
	retn


;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>

;**	$Get_Interrupt_Vector - Get Interrupt Vector
;
;	$Get_Interrupt_Vector is the official way for user pgms to get the
;	contents of an interrupt vector.
;
;	ENTRY	(AL) = interrupt number
;	EXIT	(ES:BX) = current interrupt vector

_$GET_INTERRUPT_VECTOR:
	CALL	RECSET
	LES	BX,[ES:BX]
	call	Get_User_Stack
	;mov	[si+2],bx
	;mov	[si+10h],es
	MOV	[SI+user_env.user_BX],BX
	MOV	[SI+user_env.user_ES],ES
	retn

;**	$Set_Interrupt_Vector - Set Interrupt Vector
;
;	$Set_Interrupt_Vector is the official way for user pgms to set the
;	contents of an interrupt vector.
;
;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
;	for explanation.
;
;	ENTRY	(AL) = interrupt number
;		(ds:dx) = desired new vector value
;	EXIT	none
;	USES	all

_$SET_INTERRUPT_VECTOR:
	CALL	RECSET
	CLI				; Watch out!!!!! Folks sometimes use
	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
	MOV	[ES:BX+2],DS
	STI
					; M004, M068 - Start
	; MSDOS 6.0
	;test	byte [DOS_FLAG],EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	;jnz	short siv_1		; Y: go set count
	retn				; N: return

;siv_1:	
	;cmp	byte [A20OFF_COUNT],0	; Q: is count 0
	;jne	short siv_2		; N: done 
	;mov	byte [A20OFF_COUNT],1	; Y: set it to 1 to indicate to dos 
					; dispatcher to turn A20 Off before 
					; returning to user.
;siv_2:
	;retn				; M004, M068 - End
	
RECSET:
	XOR	BX,BX
	MOV	ES,BX
	MOV	BL,AL
	SHL	BX,1
	SHL	BX,1
	retn


;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>

;**	$Char_Oper - Manipulate Switch Character
;
;	This function was put in to facilitate XENIX path/switch compatibility
;
;	ENTRY	AL = function:
;		    0 - read switch char
;		    1 - set switch char (char in DL)
;		    2 - read device availability
;			Always returns available
;		    3 - set device availability
;			No longer supported (NOP)
;	EXIT	(al) = 0xff iff error
;		(al) != 0xff if ok
;		  (dl) = character/flag, iff "read switch char" subfunction
;	USES	AL, DL
;
;	NOTE	This already obsolete function has been deactivated in DOS 5.0
;		The character / is always returned for subfunction 0,
;		subfunction 2 always returns -1, all other subfunctions are ignored.

_$CHAR_OPER:
	; MSDOS 6.0
	;or	al,al				; get switch?
	;mov	dl,'/'				; assume yes
	;jz	short chop_1			; jump if yes
	;cmp	al,2				; check device availability?
	;mov	dl,-1				; assume yes
	;jz	short chop_1				; jump if yes
	;retn					; otherwise just quit

; subfunctions requiring return of value to user come here.  DL holds
; value to return

;chop_1:
	;call	Get_User_Stack
	;mov	[SI+user_env.user_DX],dx	; store value for user
	;retn

	; MSDOS 3.3
	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
	push    ss
	pop     ds
	cmp     al, 1
	jb      short chop_1
	jz      short chop_2
	cmp     al, 3
	jb      short chop_3
	jz      short chop_5
	mov     al, 0FFh
	retn
chop_1:
	mov     dl,[chSwitch]
	jmp     short chop_4
chop_2:
	mov     [chSwitch], dl
	retn
chop_3:
	mov     dl, 0FFh
chop_4:
	call    Get_User_Stack
	mov     [si+6],dx
chop_5:
	retn


;**	$GetExtendedError - Return Extended error code
;
;	This function reads up the extended error info from the static
;	variables where it was stored.
;
;	ENTRY	none
;	EXIT	AX = Extended error code (0 means no extended error)
;		BL = recommended action
;		BH = class of error
;		CH = locus of error
;		ES:DI = may be pointer
;	USES	ALL

_$GetExtendedError:
	push	ss
	pop	ds
	MOV	AX,[EXTERR]
	LES	DI,[EXTERRPT]
	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
	MOV	CH,[EXTERR_LOCUS]
	call	Get_User_Stack
	;mov	[si+0Ah],di
	MOV	[SI+user_env.user_DI],DI
	;mov	[si+10h],es
	MOV	[SI+user_env.user_ES],ES
	;mov	[si+2],bx
	MOV	[SI+user_env.user_BX],BX
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
	;jmp	SYS_RET_OK
	; 26/07/2019
	jmp	SYS_RET_OK_clc

;============================================================================
; PARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 19/07/2018 - Retro DOS v3.0

; System calls for parsing command lines
;
;   $PARSE_FILE_DESCRIPTOR
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;               EE PathParse 10 Sept 1983
;

;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
;---------------------------------------------------------------------------
; Inputs:
;       DS:SI Points to a command line
;       ES:DI Points to an empty FCB
;       Bit 0 of AL = 1 At most one leading separator scanned off
;                   = 0 Parse stops if separator encountered
;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
;                   = 0  "    "    "     "         "      "  - put 0 in FCB
;       Bit 2 of AL = 1 If filename field blank - leave FCB
;                   = 0  "       "      "       - put blanks in FCB
;       Bit 3 of AL = 1 If extension field blank - leave FCB
;                   = 0  "       "      "        - put blanks in FCB
; Function:
;       Parse command line into FCB
; Returns:
;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
;       DS:SI points to first character after filename
;---------------------------------------------------------------------------

_$PARSE_FILE_DESCRIPTOR:
	call	MAKEFCB
	PUSH    SI
	call	Get_User_Stack
	;pop	word [si+8]
	POP     word [SI+user_env.user_SI]
	retn

;============================================================================
; MISC.ASM, MSDOS 6.0, 1991
;============================================================================
; 19/07/2018 - Retro DOS v3.0

;ENTRYPOINTSEG	EQU	0CH
;MAXDIF		EQU	0FFFH
;SAVEXIT 	EQU	10
;WRAPOFFSET	EQU	0FEF0h

;
;----------------------------------------------------------------------------
;
;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
;
;	Return Stuff sort of like old get fat call
;
;	ENTRY	none
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
;
;	Identical to $SLEAZEFUNC except (dl) = drive
;
;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
;			GOD help anyone who tries to do ANYTHING except
;			READ this ONE byte.
;		DX = Total Number of allocation units on disk
;		CX = Sector size
;		AL = Sectors per allocation unit
;		   = -1 if bad drive specified
;	USES	all
;
;----------------------------------------------------------------------------
;

_$SLEAZEFUNC:
	MOV	DL,0

_$SLEAZEFUNCDL:
	push	ss
	pop	ds
	
	MOV	AL,DL
	call	GETTHISDRV		; Get CDS structure
SET_AL_RET:
	; MSDOS 3.3
	;mov	al, 0Fh
	MOV	AL,error_invalid_drive	; Assume error	;AC000;

	JC	short BADSLDRIVE

	call	DISK_INFO
	JC	short SET_AL_RET	; User FAILed to I 24
	MOV	[FATBYTE],AH

; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
; CALL AGAIN

	MOV	DI,FATBYTE
	XOR	AH,AH			; AL has sectors/cluster
	call	Get_User_Stack
	;mov	[si+4],cx
	;mov	[si+6],bx
	;mov	[si+2],di
	MOV	[SI+user_env.user_CX],CX
	MOV	[SI+user_env.user_DX],BX
	MOV	[SI+user_env.user_BX],DI
	
	;mov	[si+0Eh],cs
	;mov	[SI+user_env.user_DS],SS
	MOV     [SI+user_env.user_DS],CS ; stash correct pointer

	retn

BADSLDRIVE:
	jmp	FCB_RET_ERR

;
;----------------------------------------------------------------------------
;
;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
;
;	Returns location of DOS status for interrupt routines
;									   ;
;	ENTRY	none
;	EXIT	(es:bx) = flag location
;	USES	all
;
;----------------------------------------------------------------------------
;

_$GET_INDOS_FLAG:
        CALL	Get_User_Stack
        ;MOV	WORD [SI+2],INDOS
	MOV     word [SI+user_env.user_BX],INDOS
        ;MOV	[SI+10H],SS
	MOV	[SI+user_env.user_ES],SS
	RETN 

;
;----------------------------------------------------------------------------
;
;**	$Get_IN_Vars - Return Pointer to DOS Variables
;
;	Return a pointer to interesting DOS variables This call is version
;	dependent and is subject to change without notice in future versions.
;	Use at risk.
;
;	ENTRY	none
;	EXIT	(es:bx) = address of SYSINITVAR
;	uses	ALL
;
;----------------------------------------------------------------------------
;

_$GET_IN_VARS:
        CALL	Get_User_Stack
        ;MOV	WORD [SI+2],SYSINITVAR
	;MOV	word [SI+user_env.user_BX],SYSINITVAR
	MOV	word [SI+user_env.user_BX],SYSINITVARS
        ;MOV	[SI+10H],SS
	MOV	[SI+user_env.user_ES],SS
	RETN

;
;----------------------------------------------------------------------------
;
;**	$Get_Default_DPB - Return a pointer to the Default DPB
;
;	Return pointer to drive parameter table for default drive
;
;	ENTRY	none
;	EXIT	(ds:bx) = DPB address
;	USES	all
;
;**	$Get_DPB - Return a pointer to a specified DPB
;
;	Return pointer to a specified drive parameter table
;
;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
;	EXIT	(al) = 0 iff ok
;		  (ds:bx) = DPB address
;		(al) = -1 if bad drive
;	USES	all
;
;----------------------------------------------------------------------------
;

_$GET_DEFAULT_DPB:
	MOV	DL,0
_$GET_DPB:
	push	ss
	pop	ds

	MOV	AL,DL
	call	GETTHISDRV		; Get CDS structure
	JC	short ISNODRV 		; no valid drive
	LES	DI,[THISCDS]		; check for net CDS
	;test	word [es:di+43h],8000h
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
	call	EcritDisk
	call	FATREAD_CDS		; Force Media Check and return DPB
	call	LcritDisk
	JC	short ISNODRV 		; User FAILed to I 24, only error we
					;   have.
	call	Get_User_Stack
	;mov	[si+2],bp
	;mov	[si+0Eh],es
	MOV	[SI+user_env.user_BX],BP
	MOV	[SI+user_env.user_DS],ES
	XOR	AL,AL
	retn
ISNODRV:
	MOV	AL,-1
	retn

;
;----------------------------------------------------------------------------
;
;**	$Disk_Reset - Flush out Dirty Buffers
;
;	$DiskReset flushes and invalidates all buffers. BUGBUG - do
;		we really invalidate? SHould we? THis screws non-removable
;		caching. Maybe CHKDSK relies upon it, though....
;
;	ENTRY	none
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$DISK_RESET:
	push	ss
	pop	ds
	MOV	AL,-1
	call	EcritDisk
	; MSDOS 6.0
	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
	call	FLUSHBUF
	; MSDOS 6.0
	;AND	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
	;mov	word [SC_STATUS],0	; Throw out secondary cache M041
;
; We will "ignore" any errors on the flush, and go ahead and invalidate. This
; call doesn't return any errors and it is supposed to FORCE a known state, so
; let's do it.
;
; Invalidate 'last-buffer' used
;
	MOV	BX,-1
	MOV	[LastBuffer+2],BX
	MOV	[LastBuffer],BX

	; MSDOS 3.3 
	; IBMDOS.COM, Offset 1C66h
	;;;;
	lds     si,[BUFFHEAD]
	mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
				; .buf_flags, AH = 0, reset/clear
DRST_1:
	; 25/07/2019 - Retro DOS v3.2
	;;mov	[si+4],ax
	;mov	[si+BUFFINFO.buf_ID],ax
	;lds	si,[SI]
	;cmp	si,bx ; -1
	;je	short DRST_2

	;mov	[si+4],ax
	mov	[si+BUFFINFO.buf_ID],ax
	lds	si,[SI]
	cmp	si,bx
	jne	short DRST_1
	;;;;
DRST_2:
	call	LcritDisk

	; 20/05/2019
	;MOV	AX,-1
	;CallInstall NetFlushBuf,MultNET,32,AX,AX
	;mov	ax,0FFFFh

	mov     ax,1120h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
			; DS = DOS CS
			; Return: CF clear (successful)
	retn

	; 19/07/2018 - Retro DOS v3.0

;
;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
;
;----------------------------------------------------------------------------
;
;**	$SetDPB - Create a DPB
;
;	SetDPB Creates a valid DPB from a user-specified BPB
;
;	ENTRY	ES:BP Points to DPB
;		DS:SI Points to BPB
;	EXIT	DPB setup
;	USES	ALL but BP, DS, ES
;
;----------------------------------------------------------------------------
;

; MSDOS 6.0
word3:	dw	3			; M008 -- word value for divides

;procedure   $SETDPB,NEAR

_$SETDPB:
	MOV	DI,BP
	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
	LODSW
	STOSW				; dpb_sector_size
	; MSDOS 6.0
	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
	JNZ	short yesfat			     ; yes		;AN000;
	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
	JMP	short setend			     ; NO		;AN000;
yesfat: ; 10/08/2018
	MOV	DX,AX
	LODSB
	DEC	AL
	STOSB				; dpb_cluster_mask
	INC	AL
	XOR	AH,AH
LOG2LOOP:
	test	AL,1
	JNZ	short SAVLOG
	INC	AH
	SHR	AL,1
	JMP	SHORT LOG2LOOP
SAVLOG:
	MOV	AL,AH
	STOSB				; dpb_cluster_shift
	MOV	BL,AL
	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
	LODSB
	STOSB				; dpb_FAT_count Number of FATs
;	OR	AL,AL			; NONFAT ?				;AN000;
;	JZ	short setend		; yes, don't do anything                ;AN000;
	MOV	BH,AL
	LODSW
	STOSW				; dpb_root_entries Number of directory entries
	MOV	CL,5
	SHR	DX,CL			; Directory entries per sector
	DEC	AX
	ADD	AX,DX			; Cause Round Up
	MOV	CX,DX
	XOR	DX,DX
	DIV	CX
	MOV	CX,AX			; Number of directory sectors
	INC	DI
	INC	DI			; Skip dpb_first_sector
	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
	LODSB
	;mov	[es:bp+16h],al
	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
	LODSW				; Number of sectors in a FAT
	;;;
	;MSDOS 6.0
	;
	;STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
	;MOV	DL,BH			;AN000;;>32mb
	;XOR	DH,DH			;AN000;;>32mb
	;MUL	DX			;AC000;;>32mb Space occupied by all FATs
	
	;MSDOS 3.3
	;
	STOSB		; DPB.FAT_SIZE
	MUL	BH
	;;;
	;add	ax,[es:bp+6]
	ADD	AX,[ES:BP+DPB.FIRST_FAT]
	STOSW				; dpb_dir_sector
	ADD	AX,CX			; Add number of directory sectors
	;mov	[es:bp+0Bh],ax
	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
	
	; MSDOS 6.0
	MOV	CL,BL			;F.C. >32mb				;AN000;
	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
	;XOR	CH,CH			;F.C. >32mb				;AN000;
	;MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
	;MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
	;SUB	BX,AX			;AN000;;F.C. >32mb
	;SBB	DX,0			;AN000;;F.C. >32mb
	;OR	CX,CX			;AN000;;F.C. >32mb
	;JZ	short norot		;AN000;;F.C. >32mb
;rott:					;AN000;;F.C. >32mb
	;CLC				;AN000;;F.C. >32mb
	;RCR	DX,1			;AN000;;F.C. >32mb
	;RCR	BX,1			;AN000;;F.C. >32mb
	;LOOP	rott			;AN000;;F.C. >32mb
;norot:					;AN000;
	;MOV	AX,BX			;AN000;;F.C. >32mb
	;JMP	short setend		;AN000;;F.C. >32mb
normal_dpb:
	;sub	ax,[es:bp+0Dh]
	SUB	AX,[ES:BP+DSKSIZ]
	NEG	AX			; Sectors in data area
;;	MOV	CL,BL			; dpb_cluster_shift
	SHR	AX,CL			; Div by sectors/cluster
setend:

;	M008 - CAS
;
	INC	AX			; +2 (reserved), -1 (count -> max)
;
;	There has been a bug in our fatsize calculation for so long
;	  that we can't correct it now without causing some user to
;	  experience data loss. There are even cases where allowing
;	  the number of clusters to exceed the fats is the optimal
;	  case -- where adding 2 more fat sectors would make the
;	  data field smaller so that there's nothing to use the extra
;	  fat sectors for.
;
;	Note that this bug had very minor known symptoms. CHKDSK would
;	  still report that there was a cluster left when the disk was
;	  actually full. Very graceful failure for a corrupt system
;	  configuration. There may be worse cases that were never
;	  properly traced back to this bug. The problem cases only
;	  occurred when partition sizes were very near FAT sector
;	  rounding boundaries, which were rare cases.
;
;	Also, it's possible that some third-party partition program might
;	  create a partition that had a less-than-perfect FAT calculation
;	  scheme. In this hypothetical case, the number of allocation
;	  clusters which don't actually have FAT entries to represent
;	  them might be larger and might create a more catastrophic
;	  failure. So we'll provide the safeguard of limiting the
;	  max_cluster to the amount that will fit in the FATs.
;
;	ax = maximum legal cluster, ES:BP -> dpb

;	make sure the number of fat sectors is actually enough to
;	  hold that many clusters. otherwise, back the number of
;	  clusters down

	; 19/07/2018 - Retro DOS v3.0
	; MSDOS 6.0
	mov	bx,ax			; remember calculated # clusters
	;;mov	ax,[ES:BP+0Fh]
	;mov	ax,[ES:BP+DPB.FAT_SIZE]
	; 01/08/2018 (MSDOS 3.3)
	mov	al,[ES:BP+DPB.FAT_SIZE]
	xor	ah,ah 	
	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
	cmp	bx,4096-10		; test for 12 vs. 16 bit fat
	jb	short setend_fat12
	shr	dx,1
;cs3 7/2/92
	jnz	short setend_faterr	; some bonehead gave us more fatspace
;					; than enough for the maximum FAT,
;					; so go ahead and use the calculated
;					; number of clusters.
;cs3 7/2/92

	rcr	ax,1			; find number of entries
	cmp	ax,4096-10+1		; would this truncation move us
;					;  into 12-bit fatland?
	jb	short setend_faterr	; then go ahead and let the
;					;  inconsistency pass through
;					;  rather than lose data by
;					;  correcting the fat type
	jmp	short setend_fat16

setend_fat12:
	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
	adc	dx,dx
;cs3 7/2/92
	cmp	dx,3			; if our fatspace is WAY more than
	jnb	short setend_faterr	; we need, we may get an overflow
;					; here.  Check for it and use
;					; the calcuated size in this case.
;cs3 7/2/92
	div	word [cs:word3]

setend_fat16:
	dec	ax			; limit at 1
	cmp	ax,bx			; is fat big enough?
	jbe	short setend_fat	; use max value that'll fit

setend_faterr:
	mov	ax,bx			; use calculated value

setend_fat:

;	now ax = maximum legal cluster

;	end M008

	;mov	[es:bp+0Dh], ax
	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
	;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
	MOV	word [ES:BP+DPB.NEXT_FREE],0 
					; Init so first ALLOC starts at
					; begining of FAT
	;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.

	retn

;EndProc $SETDPB


;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>

;
;----------------------------------------------------------------------------
;
;**	$Dup_PDB
;
; Inputs:   DX is new segment address of process
;	    SI is end of new allocation block
;
;----------------------------------------------------------------------------
;

_$DUP_PDB:

;hkn;	CreatePDB would have a CS override. This is not valid.
;hkn;	Must set up ds in order to acess CreatePDB. Also SS is 
;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.

	MOV	byte [CS:CreatePDB],0FFH  ; indicate a new process
	MOV	DS, [CS:CurrentPDB]
	PUSH	SI
	JMP	SHORT CreateCopy

;
;----------------------------------------------------------------------------
;
; Inputs:
;	DX = Segment number of new base
; Function:
;	Set up program base and copy term and ^C from int area
; Returns:
;	None
; Called at DOS init
;
;----------------------------------------------------------------------------
;

_$CREATE_PROCESS_DATA_BLOCK:
			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
	CALL	Get_User_Stack
	;mov	ds,[si+14h]
	MOV	DS,[SI+user_env.user_CS]
	;push	word [2]
	PUSH	word [PDB.BLOCK_LEN]
CreateCopy:
	MOV	ES,DX

	XOR	SI,SI			; copy entire PDB
	MOV	DI,SI
	MOV	CX,80H
	REP	MOVSW

; DOS 3.3 7/9/86

	;mov	cx,20
	MOV	CX,FILPERPROC		; copy handles in case of
	;mov	di,18h
	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
	PUSH	DS
	;lds	si,[34h]
	LDS	SI,[PDB.JFN_Pointer]
	REP	MOVSB
	POP	DS

; DOS 3.3 7/9/86

	;test	byte [cs:CreatePDB],0FFh
	cmp	byte [CS:CreatePDB],0	; Shall we create a process?
	JZ	short Create_PDB_cont 	; nope, old style call
;
; Here we set up for a new process...
;

	PUSH    CS                      ; Called at DOSINIT time, NO SS
	POP     DS

	XOR	BX,BX			; dup all jfns
	;mov	cx,20
	MOV	CX,FILPERPROC		; only 20 of them

Create_dup_jfn:
	PUSH	ES			; save new PDB
	call	SFFromHandle		; get sf pointer
	MOV	AL,-1			; unassigned JFN
	JC	short CreateStash	; file was not really open
	;test	word [es:di+5],1000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
;
; We do not inherit network file handles.
;
	;mov	ah,[es:di+2]
	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
	;and	ah,0F0h
	AND	AH,SHARING_MASK
	;cmp	ah,70h
	CMP	AH,SHARING_NET_FCB
	jz	short CreateStash
;
; The handle we have found is duplicatable (and inheritable).  Perform
; duplication operation.
;
	MOV	[THISSFT],DI
	MOV	[THISSFT+2],ES
	call	DOS_DUP 		; signal duplication
;
; get the old sfn for copy
;
	call	pJFNFromHandle		; ES:DI is jfn
	MOV	AL,[ES:DI]		; get sfn
;
; Take AL (old sfn or -1) and stash it into the new position
;
CreateStash:
	POP	ES
	;mov	[es:bx+18h],al
	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
	INC	BX			; next jfn...
	LOOP	Create_dup_jfn

	MOV	BX,[CurrentPDB]		; get current process
	;mov	[es:bx+16h]
	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
	MOV	[CurrentPDB],ES
	MOV	DS,BX
;
; end of new process create
;
Create_PDB_cont:
	MOV     BYTE [CS:CreatePDB],0	; reset flag
	POP	AX

	;entry	SETMEM

;---------------------------------------------------------------------------
; Inputs:
;	AX = Size of memory in paragraphs
;	DX = Segment
; Function:
;	Completely prepares a program base at the
;	specified segment.
; Called at DOS init
; Outputs:
;	DS = DX
;	ES = DX
;	[0] has INT int_abort
;	[2] = First unavailable segment
;	[5] to [9] form a long call to the entry point
;	[10] to [13] have exit address (from int_terminate)
;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
;	[18] to [21] have fatal error address (from int_fatal_abort)
; DX,BP unchanged. All other registers destroyed.
;---------------------------------------------------------------------------

SETMEM:
	XOR	CX,CX
	MOV	DS,CX
	MOV	ES,DX
	;mov	si,88h
	MOV	SI,addr_int_terminate
	;mov	di,10
	MOV	DI,SAVEXIT
	MOV	CX,6
	REP	MOVSW
	MOV	[ES:2],AX
	SUB	AX,DX
	CMP	AX,MAXDIF ; 0FFFh
	JBE	short HAVDIF
	MOV	AX,MAXDIF
HAVDIF:
	SUB	AX,10H			; Allow for 100h byte "stack"
	MOV	BX,ENTRYPOINTSEG	;	in .COM files
	SUB	BX,AX
	MOV	CL,4
	SHL	AX,CL
	MOV	DS,DX

	; (MSDOS 6.0 note)
	;
	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
	; making this equvalnce valid for this particular case. If however
	; there is less than 64K remaining the address in BX:AX will not 
	; be the same as above. We will then stuff 0:c0 , the call 5 address
	; into the PSP.
	;
	; Therefore for the case where there is less than 64K remaining in 
	; the system old CPM Apps that look at PSP:6 to determine memory
	; requirements will not work. Call 5, however will continue to work
	; for all cases.
	;

	;mov	[6],ax
	;mov	[8],bx

	MOV	[PDB.CPM_CALL+1],AX
	MOV	[PDB.CPM_CALL+3],BX

	;cmp	ax,WRAPOFFSET		; Q: does the system have >= 64k of
	;				;    memory left
	;je	short addr_ok		; Y: the above calculated address is
	;				;    OK
	;				; N: 

	;MOV	WORD [PDB.CPM_CALL+1],0c0h
	;MOV	WORD [PDB.CPM_CALL+3],0

;addr_ok:

	;mov	word [0],20CDh
	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
	;mov	byte [5],9Ah
	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
	;mov	word [50h],21CDh
	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
	;mov	byte [52h],0CBh
	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
	;mov	word [34h],18h
	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
	;mov	word [36h],ds
	MOV	WORD [PDB.JFN_Pointer+2],DS
	;mov	word [32h],20
	MOV	WORD [PDB.JFN_Length],FILPERPROC
;
; The server runs several PDB's without creating them VIA EXEC.  We need to
; enumerate all PDB's at CPS time in order to find all references to a
; particular SFT.  We perform this by requiring that the server link together
; for us all sub-PDB's that he creates.  The requirement for us, now, is to
; initialize this pointer.
;
 	;mov	word [38h],-1
	MOV	word [PDB.Next_PDB],-1
	;mov	word [3Ah],-1
	MOV	word [PDB.Next_PDB+2],-1

			; Set the real version number in the PSP - 5.00
	;mov	[ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION

	retn

;============================================================================
; IBMDOS.COM (MSDOS 3.3 KERNEL), 1987 - Offset 1DE6h
;============================================================================
; 19/07/2018 - Retro DOS v3.0

FETCHI_CHECK:
	pushf
	cmp	word [cs:FETCHI_TAG], 5872h
	jz      short FETCHI_CHK_RETN
	call    DOSINIT
FETCHI_CHK_RETN:
	popf
	retn

;============================================================================
; MISC2.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
;		Strings of different lengths don't match.
;   Inputs:	DS:SI - pointer to source string  ES:DI - pointer to dest string
;   Outputs:	Z if strings same, NZ if different
;   Registers modified: NONE
;----------------------------------------------------------------------------

StrCmp:
	push	si
	push	di
	push	ax

Cmplp:
	LODSB
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert / to \
	MOV	AH,AL
	MOV	AL,[ES:DI]
	INC	DI
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert / to \
	CMP	AH,AL
	JNZ	short PopRet		; Strings dif
Tend:
	OR	AL,AL
	JNZ	short Cmplp		; More string
PopRet:
	pop	ax
	pop	di
	pop	si
	retn

;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
;----------------------------------------------------------------------------
;
;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI.  no modification of
;	characters.
;
;   Inputs:	DS:SI - pointer to source string
;		ES:DI - pointer to destination string
;   Outputs:	ES:DI point byte after nul byte at end of dest string
;		DS:SI point byte after nul byte at end of source string
;   Registers modified: SI,DI
;----------------------------------------------------------------------------

StrCpy:
	push	ax
CPYLoop:
	LODSB
	call	UCase			; convert to upper case
	call	PATHCHRCMP		; convert / to \ ;
	STOSB
Tend2:
	OR	AL,AL
	JNZ	short CPYLoop
	pop	ax
	retn

;----------------------------------------------------------------------------
; Procedure Name : FStrCpy
;----------------------------------------------------------------------------

FStrCpy:
	push	ax
FCPYLoop:
	LODSB
	STOSB
	OR	AL,AL
	JNZ	short FCPYLoop
	pop	ax
	retn

; 20/07/2018 - Retro DOS v3.0
;----------------------------------------------------------------------------
; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
;----------------------------------------------------------------------------
;
;UCase:	
;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
;	retn

;Break <StrLen - compute length of string ES:DI>
;----------------------------------------------------------------------------
;**	StrLen - Compute Length of String
;
;	StrLen computes the length of a string, including the trailing 00
;
;	ENTRY	(es:di) = address of string
;	EXIT	(cx) = size of string
;	USES	cx, flags
;----------------------------------------------------------------------------

StrLen:
	push	di
	push	ax
	;MOV	CX,-1
	mov	cx,65535
	XOR	AL,AL
	REPNE	SCASB
	NOT	CX
	pop	ax
	pop	di
	retn

;----------------------------------------------------------------------------
;**	DStrLen - Compute Length of String
;
;	ENTRY	(ds:si) = address of string
;	EXIT	(cx) = size of string, including trailing NUL
;	USES	cx, flags
;----------------------------------------------------------------------------

DStrLen:	; BUGBUG - this guy is a pig, who uses him?
	CALL	XCHGP
	CALL	StrLen
	CALL	XCHGP
	retn

;----------------------------------------------------------------------------
;**	XCHGP - Exchange Source and Destination Pointers
;
;	XCHGP exchanges (DS:SI) and (ES:DI)
;
;	ENTRY	none
;	EXIT	pairs exchanged
;	USES	SI, DI, DS, ES
;----------------------------------------------------------------------------

XCHGP:
	push	ds
	push	es
	pop	ds
	pop	es
	XCHG	SI,DI
xchgp_retn:
	retn

;Break	<Idle - wait for a specified amount of time>
;----------------------------------------------------------------------------
;
;   Idle - when retrying an operation due to a lock/sharing violation,
;   	   we spin until RetryLoop is exhausted.
;
;   Inputs:	RetryLoop is the number of times we spin
;   Outputs:	Wait
;   Registers modified: none
;----------------------------------------------------------------------------

Idle:
	;test	byte [SS:FSHARING],0FFh
	cmp	byte [SS:FSHARING],0	;hkn; SS override
	;retnz
	jnz	short xchgp_retn
	;SAVE	<CX>
	push	cx
	MOV	CX,[ss:RetryLoop]	;hkn; SS override
	JCXZ	Idle3
Idle1:	
	PUSH	CX
	XOR	CX,CX
Idle2:	
	LOOP	Idle2
	POP	CX
	LOOP	Idle1
Idle3:	
	;RESTORE <CX>
	pop	cx
	retn

;Break	<TableDispatch - dispatch to a table>
;----------------------------------------------------------------------------
;
;   TableDispatch - given a table and an index, jmp to the approptiate
;   routine.  Preserve all input registers to the routine.
;
;   Inputs:	Push	return address
;		Push	Table address
;		Push	index (byte)
;   Outputs:	appropriate routine gets jumped to.
;		return indicates invalid index
;   Registers modified: none.
;----------------------------------------------------------------------------

struc TFrame	 ; TableFrame
.OldBP:	 resw 1  ; 0
.OldRet: resw 1  ; 2
.Index:	 resb 1  ; 4
.Pad:	 resb 1  ; 5  
.Tab:	 resw 1  ; 6
.NewRet: resw 1  ; 8
endstruc

TableDispatch:
	PUSH	BP
	MOV	BP,SP
	PUSH	BX			; save BX
	;mov	bx,[bp+6]
	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
	MOV	BL,[CS:BX]		; maximum index
	;cmp	[bp+4],bl
	CMP	[BP+TFrame.Index],BL	; table error?
	JAE	short TableError	; yes
	;mov	bl,[bp+4]
	MOV	BL,[BP+TFrame.Index]	; get desired table index
	XOR	BH,BH			; convert to word
	SHL	BX,1			; convert to word pointer
	INC	BX			; point past first length byte
	; 17/08/2018
	;add	bx,[bp+6]
	ADD	BX,[BP+TFrame.Tab]	; get real offset
	MOV	BX,[CS:BX]		; get contents of table entry
	;mov	[bp+6],bx
	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
	POP	BX			; restore BX
	POP	BP			; restore BP
	ADD	SP,4			; clean off Index and our return addr
	retn				; do operation
TableError:
	POP	BX			; restore BX
	POP	BP			; restore BP
	RETN	6			; clean off Index, Table and RetAddr


;Break	<TestNet - determine if a CDS is for the network>
;----------------------------------------------------------------------------
;
;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
;	network CDS.  This will handle NULL cds also.
;
;   Inputs:	ThisCDS points to CDS or NULL
;   Outputs:	ES:DI = ThisCDS
;		carry Set => network
;		carry Clear => local
;   Registers modified: none.
;----------------------------------------------------------------------------

TestNet:
	LES	DI,[CS:THISCDS]
	CMP	DI,-1
	JZ	short CMCRet		; UNC? carry is clear
	;test	word [es:di+43h],8000h
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JNZ	short CMCRet		; jump has carry clear
	retn				; carry is clear
CMCRet: 
	CMC
	retn

;Break	<IsSFTNet - see if an sft is for the network>
;----------------------------------------------------------------------------
;
;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
;	network file.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	Zero set if not network sft
;		zero reset otherwise
;		Carry CLEAR!!!
;   Registers modified: none.
;----------------------------------------------------------------------------

IsSFTNet:
	;test	word [es:di+5],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	retn

;Break	<FastInit - Initialize FastTable entries >
;----------------------------------------------------------------------------
;   DOS 4.00   2/9/87
;   FastInit  - initialize the FASTXXX routine entry
;		  in the FastTable
;
;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
;		DS:SI = address of FASTXXX routine entry
;		   SI = -1 for query only
;   Outputs:	Carry flag clear, if success
;		Carry flag set,   if failure
;
;
;----------------------------------------------------------------------------

;Procedure FastInit,NEAR
;	ASSUME	CS:DOSCODE,SS:NOTHING
;FastInit:
	; MSDOS 6.0
	;hkn; set up es to dosdataseg.
	;push	es
	;getdseg <es>			; es -> dosdata

	;hkn; FastTable is in DOSDATA
	;MOV	DI,OFFSET DOSDATA:FastTable + 2 ;AN000;FO. points to fastxxx entry
	;DEC	BX				;AN000;FO.;; decrement index
	;MOV	DX,BX				;AN000;FO.;; save bx
	;SHL	BX,1				;AN000;FO.;; times 4 , each entry is DWORD
	;SHL	BX,1				;AN000;FO.
	;ADD	DI,BX				;AN000;FO. index to the entry
	;MOV	AX,WORD PTR ES:[DI+2]		;AN000;FO. get entry segment
;fcheck: 					;AN000;
	;MOV	CX,CS				;AN000;FO.;; get DOS segment
	;CMP	AX,CX				;AN000;FO.;; first time installed ?
	;JZ	short ok_install			;AN000;FO.;; yes
	;OR	AX,AX				;AN000;FO.;
	;JZ	short ok_install		;AN000;FO.;
	;STC					;AN000;FO.;; already installed !
	;JMP	SHORT FSret			;AN000;FO. set carry
;ok_install:					;AN000;
	;CMP	SI,-1				;AN000;FO.; Query only ?
	;JZ	short FSret			;AN000;FO.; yes
	;MOV	CX,DS				;AN000;FO.; get FASTXXX entry segment
	;MOV	WORD PTR ES:[DI+2],CX		;AN000;FO.; initialize routine entry
	;MOV	WORD PTR ES:[DI],SI		;AN000;FO.; initialize routine offset

;hkn; FastFlg moved to DOSDATA
	;MOV	DI,OFFSET DOSDATA:FastFlg	;AN000;FO.; get addr of FASTXXX flags
	;ADD	DI,DX				;AN000;FO.; index to a FASTXXX flag
	;OR	byte ptr ES:[DI],Fast_yes	;AN000;FO.; indicate installed
FSret:						;AN000;
	;pop	es
	;return					;AN000;FO.
;EndProc FastInit				;AN000;FO.

	; MSDOS 3.3
	; IBMDOS.COM (1987) - Offset 1EB3h
FastInit:
	mov	di,FastTable ; FastOpenTable
	mov	ax,[cs:di+4]		; Entry segment
	mov	bx,cs			; get DOS segment
	cmp	ax,bx			; first time installed ?	
	je	short ok_install	; yes
	stc				; set carry
	retn				; (cf=1 means) already installed !

ok_install:
	mov	bx,FastTable ; FastOpenTable
	mov	cx,ds
	; set address of FASTXXX (FASTOPEN) routine entry
	mov	[cs:bx+4],cx
	mov	[cs:bx+2],si
	retn

;Break	<FastRet - initial routine in FastOpenTable >
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   FastRet	- indicate FASTXXXX  not in memory
;
;   Inputs:	None
;   Outputs:	AX = -1 and carry flag set
;
;   Registers modified: none.
;----------------------------------------------------------------------------

FastRet:
	;mov	ax,-1
	;stc
	;retf
	STC
	sbb	ax,ax		; (ax) = -1, 'C' set
	RETF

;Break	<NLS_OPEN - do $open for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_OPEN	- call $OPEN for NLSFUNC
;
;   Inputs:	Same input as $OPEN except CL = mode
;   Outputs:	same output as $OPEN
;
;----------------------------------------------------------------------------

;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!

NLS_OPEN:
;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
;	MOV	BYTE [CPSWFLAG],0
;	PUSH	BX		 ; save current state

	MOV	AL,CL		 ; set up correct interface for $OPEN
	call	_$OPEN

 ;	POP	BX		 ; restore current state
 ;	MOV	[CPSWFLAG],BL
	RETN

;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   NLS_LSEEK	- call $LSEEK for NLSFUNC
;
;   Inputs:	BP = open mode
;   Outputs:	same output as $LSEEK
;
;----------------------------------------------------------------------------

NLS_LSEEK:
	;PUSH	word [SS:USER_SP] ; save user stack
	;PUSH	word [SS:USER_SS]
	PUSH	word [CS:USER_SP] ; save user stack
	PUSH	word [CS:USER_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP		; set up correct interface for $LSEEK
	call	_$LSEEK
	;POP	word [SS:USER_SS] ; restore user stack
	;POP	word [SS:USER_SP]
	POP	word [cs:USER_SS] ; restore user stack
	POP	word [cs:USER_SP]
	RETN

;Break	<Fake_User_Stack - save user stack>
;----------------------------------------------------------------------------
;   DOS 3.3   6/10/86
;   Fake_User_Stack - save user stack pointer
;
;----------------------------------------------------------------------------

Fake_User_Stack:
	;MOV	AX,[ss:USER_SP_2F] ; replace with INT 2F stack
	MOV	AX,[cs:USER_SP_2F]
	;MOV	[SS:USER_SP],AX
	MOV	[CS:USER_SP],AX
	MOV	AX,CS
	;mov	ax,ss
	;MOV	[SS:USER_SS],AX
	MOV	[CS:USER_SS],AX
	RETN

;Break	<GetDevList - get device header list pointer>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   GetDevList - get device header list pointer
;
;   Output: AX:BX points to the device header list
;----------------------------------------------------------------------------

GetDevList:
	MOV	SI,SysInitTable
	;LDS	SI,[CS:SI+SYSINITVARS]
	LDS	SI,[CS:SI]
	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
	MOV	AX,[SI+SYSI.DEV]
	MOV	BX,[SI+SYSI.DEV+2]
	RETN

;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_IOCTL	- call $IOCTL for NLSFUNC
;
;   Inputs:	BP = function code 0CH
;   Outputs:	same output as generic $IOCTL
;
;----------------------------------------------------------------------------

NLS_IOCTL:
	;PUSH	word [SS:USER_SP] ; save user stack
	;PUSH	word [SS:USER_SS]
	PUSH	word [CS:USER_SP] ; save user stack
	PUSH	word [CS:USER_SS]
	CALL	Fake_User_Stack
	MOV	AX,BP	     ; set up correct interface for $LSEEK
	call	_$IOCTL
	;POP	word [SS:USER_SS] ; restore user stack
	;POP	word [SS:USER_SP]
	POP	word [CS:USER_SS] ; restore user stack
	POP	word [CS:USER_SP]
	RETN

;Break	<NLS_GETEXT- get extended error for NLSFUNC>
;----------------------------------------------------------------------------
;   DOS 3.3   7/25/86
;   NLS_GETEXT	-
;
;   Inputs:	none
;   Outputs:	AX = extended error
;
;----------------------------------------------------------------------------

NLS_GETEXT:
	;MOV	AX,[SS:EXTERR]	 ; return extended error
	mov	AX,[CS:EXTERR]
	RETN

;============================================================================
; EcritDisk, LcritDisk, EcritDevice, LCritDevice
; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
;============================================================================
; 20/07/2018 - Retro DOS v3.0

	; MSDOS 3.3
	; 08/08/2018 - Retro DSOS v3.0
EcritMem:
EcritSFT:
	;
EcritDisk:
	;push	ax
	retn
	
	mov	ax,8001h
	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	pop	ax
	retn

	; MSDOS 3.3
	; 08/08/2018 - Retro DSOS v3.0
LcritMem:
LcritSFT:
	;
LcritDisk:
	;push	ax
	retn
	
	mov	ax,8101h
	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	pop	ax
	retn

EcritDevice:
	;push	ax
	retn
	
	mov	ax,8002h
	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	pop	ax
	retn

LcritDevice:
	;push	ax
	retn
	
	mov	ax,8102h
	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
			; AL = critical section number (00h-0Fh)
	pop	ax
	retn

;============================================================================
; CRIT.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

; (DOSMAC.INC, MSDOS 6.0, 1991)

; Some old versions of the 80286 have a bug in the chip.  The popf
; instruction will enable interrupts.  Therefore in a section of code with
; interrupts disabled and you need a popf instruction use the 'popff'
; macro instead.
;

;%macro POPFF 0
;	jmp	$+3
;	iret
;	push	cs
;	call	$-2
;%endmacro

;**	CRIT.ASM - Critical Section Routines
;
;	Critical section handlers
;
;	Modification history:
;
;	    Created: ARR 30 March 1983

;
;SR; This variable is set when the redir installs itself
;
	;I_need redir_patch,BYTE

; Break	<Critical section handlers>

;   Each handler must leave everything untouched; including flags!
;
;   Sleaze for time savings:  first instruction is a return.  This is patched
;   by the sharer to be a PUSH AX to complete the correct routines.

;Procedure  EcritDisk,NEAR
	;public  EcritMem
	;public  EcritSFT
;ECritMEM    LABEL   NEAR
;ECritSFT    LABEL   NEAR

;
;SR; Check if critical section is to be entered
;

;	pushf
;	cmp	ss:[redir_patch],0
;	jz	@f
;	popff
;
;       PUSH    AX
;	MOV     AX,8000h+critDisk
;	INT     int_ibm
;	POP     AX
;	return
;@@:
;	popff
;	ret
;EndProc EcritDisk

;Procedure   LcritDisk,NEAR
;	public  LcritMem
;	public  LcritSFT
;LCritMEM    LABEL   NEAR
;LCritSFT    LABEL   NEAR

;
;SR; Check if critical section is to be entered
;

;	pushf
;	cmp	ss:[redir_patch],0
;	jz	@f
;	popff

;       PUSH    AX
;	MOV     AX,8100h+critDisk
;	INT     int_ibm
;	POP     AX
;	return
;@@:
;	popff
;	ret

;EndProc LcritDisk

;Procedure   EcritDevice,NEAR
;
;SR; Check if critical section is to be entered
;

;	pushf
;	cmp	ss:[redir_patch],0
;	jz	@f
;	popff

;       PUSH    AX
;	MOV     AX,8000h+critDevice
;	INT     int_ibm
;	POP     AX
;	return
;@@:
;	popff
;	ret

;EndProc EcritDevice

;Procedure   LcritDevice,NEAR
;
;SR; Check if critical section is to be entered
;

;	pushf
;	cmp	ss:[redir_patch],0
;	jz	@f
;	popff

;       PUSH    AX
;	MOV     AX,8100h+critDevice
;	INT     int_ibm
;	POP     AX
;	return
;@@:
;	popff
;	ret

;EndProc LcritDevice


;============================================================================
; CPMIO.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

;============================================================================
; STDIO.ASM - (MSDOS 2.0)
;============================================================================

;
; Standard device IO for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;INCLUDE DOSSEG.ASM
;.cref
;.list

;TITLE   STDIO - device IO for MSDOS
;NAME    STDIO

;INCLUDE IO.ASM

; ---------------------------------------------------------------------------
;
; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
;			    to restore MSDOS 2.0 device IO source code 
;
;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
	
;============================================================================
; STDIO.ASM - (MSDOS 2.0)
;============================================================================

;
; Standard device IO for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;INCLUDE DOSSEG.ASM
;.cref
;.list

;TITLE   STDIO - device IO for MSDOS
;NAME    STDIO

;INCLUDE IO.ASM

; ---------------------------------------------------------------------------
;
; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
;			    to restore MSDOS 2.0 device IO source code 
;
;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
;
;============================================================================
; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
;============================================================================
; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018

; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 

;**	Standard device IO for MSDOS (first 12 function calls)
;
;	TITLE	IBMCPMIO - device IO for MSDOS
;	NAME	IBMCPMIO

;	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input_No_Echo
;	$Std_Con_String_Output
;	$Std_Con_String_Input
;	$RawConIO
;	$RawConInput
;	RAWOUT
;	RAWOUT2
;

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

; ---------------------------------------------------------------------------

;	TITLE	CPMIO2 - device IO for MSDOS
;	NAME	CPMIO2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input
;	$Std_Con_Output
;	OUTT
;	TAB
;	BUFOUT
;	$Std_Aux_Input
;	$Std_Aux_Output
;	$Std_Printer_Output
;	$Std_Con_Input_Status
;	$Std_Con_Input_Flush
;
;	Revision History:
;
;	  AN000	 version 4.00 - Jan. 1988

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

;DOSCODE SEGMENT
;	ASSUME	SS:DOSDATA,CS:DOSCODE


;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 

;
;----------------------------------------------------------------------------
;
; Procedure : $Std_Con_Input_No_Echo
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_NO_ECHO:   ;System call 8

; Inputs:
;	None
; Function:
;	Input character from console, no echo
; Returns:
;	AL = character

	push	ds
	push	si
INTEST:
	call	STATCHK
	jnz	short GET ; 08/09/2018
;*************************************************************************
;hkn; SS override
	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
	jnz	short no_sys_wait
	mov	ah,5			; get input status with system wait
	call	IOFUNC
no_sys_wait:
;**************************************************************************
	MOV	AH,84h
	INT	int_IBM	 ; int 2Ah

;;; 7/15/86  update the date in the idle loop
;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
;;;;		 to shorten loop in consideration of the PC Convertible

;hkn; SS override
	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
	PUSH	AX
	PUSH	BX			; following is tricky,
	PUSH	CX			; it may be called by critical handler
	PUSH	DX			; at that time, DEVCALL is used by
					; other's READ or WRITE
	PUSH	DS			; save DS = SFT's sgement

;hkn; READTIME must use ds = DOSDATA
;hkn;	PUSH	CS			; READTIME must use DS=CS

	;push	ss
	PUSH	CS
	POP	DS

	MOV	AX,0			; therefore, we save DEVCALL
	CALL	Save_Restore_Packet	; save DEVCALL packet
	;invoke	READTIME		; readtime
	call	READTIME
	MOV	AX,1
	CALL	Save_Restore_Packet	; restore DEVCALL packet
	;
	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
	push	bx
	mov	bx,DATE_FLAG
	add	bx,2  ; mov bx,FETCHI_FLAG
	cmp	word [cs:bx],5872h
	jz	short FETCHI_TAG_chk_ok
	call	DOSINIT
FETCHI_TAG_chk_ok:
	pop	bx
	;
	POP	DS			; restore DS
	POP	DX
	POP	CX
	POP	BX
	POP	AX
NoUpdate:

;hkn; SS override
	INC	word [SS:DATE_FLAG]

;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	JMP	short INTEST
GET:
	XOR	AH,AH
	call	IOFUNC
	POP	SI
	POP	DS
;;; 7/15/86

;hkn; SS override
	; MSDOS 6.0
	MOV	BYTE [SS:SCAN_FLAG],0
	;
	CMP	AL,0	    ; extended code ( AL )
	JNZ	short noscan

;hkn; SS override
	MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key

noscan:
	retn
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_OUTPUT - Console String Output
;
;
;	ENTRY	(DS:DX) Point to output string '$' terminated
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_STRING_OUTPUT:	;System call 9

	mov	si,dx
STRING_OUT1:	
	lodsb
	cmp	al,'$'
	jz	short noscan
NEXT_STR1:
	call	OUTT
	jmp	short STRING_OUT1

;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_INPUT - Input Line from Console
;
;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
;
;	ENTRY	(ds:dx) = input buffer
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------

_$STD_CON_STRING_INPUT:		;System call 10

	mov	ax,ss
	mov	es,ax
	mov	si,dx
	xor	ch,ch
	lodsw

;	(AL) = the buffer length
;	(AH) = the template length

        or	al,al
        jz	short noscan	;Buffer is 0 length!!?
	mov	bl,ah		;Init template counter
        mov	bh,ch		;Init template counter

;	(BL) = the number of bytes in the template

        cmp	al,bl
        jbe	short NOEDIT	;If length of buffer inconsistent with contents
        cmp	byte [bx+si],c_CR ; 0Dh
        jz	short EDITON	;If CR correctly placed EDIT is OK

; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;

NOEDIT:	
	mov	bl,ch		;Reset buffer
EDITON: 
	mov	dl,al
	dec	dx		;DL is # of bytes we can put in the buffer

;	Top level.  We begin to read a line in.

NEWLIN: 
	mov	al,[SS:CARPOS]
	mov	[SS:STARTPOS],al ;Remember position in raw buffer

	push	si
	mov	di,INBUF ;Build the new line here
	mov	byte [SS:INSMODE],ch ;Insert mode off
	mov	bh,ch		;No chars from template yet
	mov	dh,ch		;No chars to new line yet
	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
	cmp	al,c_LF		; 0Ah	;Linefeed 
	jnz	short GOTCH

;	This is the main loop of reading in a character and processing it.
;
;	(BH) = the index of the next byte in the template
;	(BL) = the length of the template
;	(DH) = the number of bytes in the buffer
;	(DL) = the length of the buffer

GETCH:
	call	_$STD_CON_INPUT_NO_ECHO
GOTCH:
;
; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
; input queue.
;
        cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
	jz	short GETCH

;	If the leading char is the function-key lead byte

        cmp	al,[SS:ESCCHAR]
        jz	short ESCAPE	;change reserved keyword DBM 5-7-87

;	Rubout and ^H are both destructive backspaces.

        cmp	al,c_DEL ; 7FH
        jz	short BACKSPJ
        cmp	al,c_BS  ; 8
        jz	short BACKSPJ

	; MSDOS 6.0
;;	^W deletes backward once and then backs up until a letter is before the
;;	cursor
;
;	CMP     AL,"W"-"@" ; 17h
;
;;	The removal of the comment characters before the jump statement will
;;	cause ^W to backup a word.
;
;;***	JZ	short WordDel
;	NOP
;	NOP
;	CMP     AL,"U"-"@" ; 15h
;
;;	The removal of the comment characters before the jump statement will
;;	cause ^U to clear a line.
;
;;***	JZ	short LineDel
;	NOP
;	NOP

;	CR terminates the line.

        cmp	al,c_CR ; 0Dh
        jz	short ENDLIN

;	LF goes to a new line and keeps on reading.

        cmp	al,c_LF ; 0Ah
	jz	short PHYCRLF

;	^X (or ESC) deletes the line and starts over

	; MSDOS 3.3
	;cmp	al,[ss:CANCHAR] ; 1Bh
	;jz	short KILNEW
	;MSDOS 6.0
	cmp	al,CANCEL ; 1Bh
	jz	short KILNEW

; Otherwise, we save the input character.

SAVCH:	
	cmp	dh,dl
	jnb	short BUFFUL		; buffer is full.
        stosb
	inc	dh                      ; increment count in buffer.
	call	BUFOUT			;Print control chars nicely

        cmp	byte [SS:INSMODE], 0
	jnz	short GETCH		; insertmode => don't advance template
        cmp	bh,bl
        jnb	short GETCH		; no more characters in template
        inc	si                      ; Skip to next char in template
        inc	bh                      ; remember position in template
        jmp	short GETCH

BACKSPJ: 
	jmp	short BACKSP

BUFFUL: 
	mov	al, 7			; Bell to signal full buffer
	call	OUTT
	jmp	short GETCH

ESCAPE: 
	;transfer OEMFunctionKey
	JMP	OEMFunctionKey

ENDLIN:
        stosb				; Put the CR in the buffer
	call	OUTT                    ; Echo it
        pop	di                      ; Get start of user buffer
        mov	[di-1], dh		; Tell user how many bytes
        inc	dh			; DH is length including CR

COPYNEW:
	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
	;mov	bp, es
	;mov	bx, ds
	;mov	es, bx
	;mov	ds, bp
	;mov	si, INBUF
	;mov	cl, dh
	;rep	movsb
	;retn

	; CPMIO.ASM (MSDOS 6.0)
	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
	;SAVE	<DS,ES>
	PUSH	DS
	PUSH	ES
	;RESTORE <DS,ES>		; XCHG ES,DS
	POP	DS
	POP	ES

;;hkn; INBUF is in DOSDATA
        MOV     SI,INBUF
        MOV     CL,DH                   ; set up count
        REP     MOVSB                   ; Copy final line to user buffer
OLDBAK_RETN:
        RETN

;	Output a CRLF to the user screen and do NOT store it into the buffer

PHYCRLF:
	CALL	CRLF
        JMP	short GETCH

	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)

	; Note: Following routines were not used in IBMDOS.COM
	;	-CRTL+W, CRTL+U is not activated-
	;	but they were in the kernel code!?)
;
; Delete the previous line
;
;LineDel:
;	OR      DH,DH
;	JZ	short GetCh
;	Call    BackSpace
;	JMP	short LineDel

;
; delete the previous word.
;
;WordDel:
;WordLoop:
;	Call    BackSpace               ; backspace the one spot
;	OR      DH,DH
;	JZ	short GetChJ
;	MOV     AL,[ES:DI-1]
;	cmp     al,'0'
;	jb	short GetChj
;	cmp     al,'9'
;	jbe	short WordLoop
;	OR      AL,20h
;	CMP     AL,'a'
;	JB	short GetChJ
;	CMP     AL,'z'
;	JBE	short WordLoop
;getchj: 
;	JMP	GetCh

; The user wants to throw away what he's typed in and wants to start over.
; We print the backslash and then go to the next line and tab to the correct
; spot to begin the buffered input.

KILNEW:
        mov	al,'\'
        call	OUTT            ;Print the CANCEL indicator
        pop	si		;Remember start of edit buffer
PUTNEW:
	call	CRLF            ;Go to next line on screen
	mov	al,[SS:STARTPOS]
	call	TAB             ;Tab over
        JMP     NEWLIN		;Start over again

;	Destructively back up one character position

BACKSP:
	; 09/09/2018
	Call    BackSpace
	JMP     GETCH

BackSpace:
	or	dh,dh
	jz	short OLDBAK	;No chars in line, do nothing to line
	call	BACKUP          ;Do the backup
	mov	al,[es:di]	;Get the deleted char
        cmp	al,20h	; ' '
	jnb	short OLDBAK	;Was a normal char
        cmp	al,c_HT ; 9
	jz	short BAKTAB	;Was a tab, fix up users display
;; 9/27/86 fix for ctrl-U backspace
	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
	JZ	short OLDBAK
       	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
	JZ	short OLDBAK
;; 9/27/86 fix for ctrl-U backspace
        call	BACKMES         ;Was a control char, zap the '^'
OLDBAK:
        cmp	byte [SS:INSMODE], 0
	jnz	short OLDBAK_RETN ;In insert mode, done
	or	bh,bh
        jz	short OLDBAK_RETN 
				;Not advanced in template, stay where we are
	dec	bh		;Go back in template
        dec	si
	retn

BAKTAB:
        push	di
        dec	di		;Back up one char
        std			;Go backward
        mov	cl,dh		;Number of chars currently in line
        mov	al,20h	; ' '
        push	bx
        mov	bl,7		;Max
        jcxz	FIGTAB		;At start, do nothing
FNDPOS:
        scasb			;Look back
	jbe	short CHKCNT
	cmp	byte [es:di+1],9
	jz	short HAVTAB	;Found a tab
	dec	bl		;Back one char if non tab control char
CHKCNT:
        loop	FNDPOS
FIGTAB:		
	sub	bl,[SS:STARTPOS]
HAVTAB:
	sub	bl,dh
	add	cl,bl
	and	cl,7		;CX has correct number to erase
	cld			;Back to normal
	pop	bx
	pop	di
	jz	short OLDBAK	;Nothing to erase
TABBAK:
	call	BACKMES
	loop	TABBAK		;Erase correct number of chars
	jmp	short OLDBAK

BACKUP:
        dec	dh             ;Back up in line
        dec	di
BACKMES:
        mov	al,c_BS ; 8	;Backspace
        call	OUTT
        mov	al,20h ; ' '	;Erase
        call	OUTT
        mov	al,c_BS ; 8	;Backspace
	jmp	OUTT		;Done

;User really wants an ESC character in his line
TWOESC:	
	mov	al,[SS:ESCCHAR]
	jmp	SAVCH

;Copy the rest of the template
COPYLIN:
        mov	cl,bl		;Total size of template
	sub	cl,bh		;Minus position in template, is number to move
        jmp	short COPYEACH

COPYSTR:
	call	FINDOLD         ;Find the char
	jmp	short COPYEACH  ;Copy up to it

;Copy one char from template to line
COPYONE:
        mov	cl,1
;Copy CX chars from template to line
COPYEACH:
        mov	byte [SS:INSMODE],0	;All copies turn off insert mode
	cmp	dh,dl
        jz	short GETCH2		;At end of line, can't do anything
        cmp	bh,bl
        jz	short GETCH2		;At end of template, can't do anything
        lodsb
        stosb
	call	BUFOUT
        inc	bh			;Ahead in template
        inc	dh			;Ahead in line
        loop	COPYEACH
GETCH2:
        jmp	GETCH

;Skip one char in template
SKIPONE:
	cmp	bh,bl
	jz	short GETCH2		;At end of template
	inc	bh			;Ahead in templat
	inc	si
	jmp	GETCH

SKIPSTR:
	call	FINDOLD                 ;Find out how far to go
        add	si,cx			;Go there
        add	bh,cl
        jmp	GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;       address is popped off and a jump to GETCH is taken.
;       Make sure nothing extra on stack when this routine
;       is called!!! (no PUSHes before calling it).
FINDOLD:
        call	_$STD_CON_INPUT_NO_ECHO
	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
	CMP     AL,[SS:ESCCHAR]	; did he type a function key?
;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
	;CMP	AL,[CS:ESCCHAR]
	JNZ     SHORT FINDSETUP		; no, set up for scan
        CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
        JMP     SHORT NOTFND		; go try again
FINDSETUP:
	mov	cl,bl
        sub	cl,bh		;CX is number of chars to end of template
	jz	short NOTFND	;At end of template
        dec	cx		;Cannot point past end, limit search
        jz	short NOTFND	 ;If only one char in template, forget it
	push	es
	push	ds
	pop	es
	push	di
	mov	di,si		;Template to ES:DI
	inc	di
	repne	scasb		;Look
	pop	di
	pop	es
	jnz	short NOTFND	;Didn't find the char
        not	cl		;Turn how far to go into how far we went
        add	cl,bl		;Add size of template
        sub	cl,bh		;Subtract current pos, result distance to skip
FINDOLD_RETN:
	retn

NOTFND:
        pop	bp              ;Chuck return address
        jmp	GETCH

REEDIT:
	mov	al,'@'		;Output re-edit character
	call	OUTT
	pop	di
	push	di
	push	es
	push	ds
	call	COPYNEW		;Copy current line into template
	pop	ds
	pop	es
	pop	si
	mov	bl,dh		;Size of line is new size template
	jmp	PUTNEW		;Start over again

EXITINS:
ENTERINS:
	not	byte [SS:INSMODE]
	jmp	GETCH

;Put a real live ^Z in the buffer (embedded)
CTRLZ:
	mov	al,"Z"-"@" ; 1Ah
        jmp	SAVCH

;Output a CRLF
CRLF:
	mov	al,c_CR ; 0Dh 
	call	OUTT
	mov	al,c_LF ; 0Ah
	jmp	OUTT

;
;----------------------------------------------------------------------------
;
;**	$RAW_CON_IO - Do Raw Console I/O
;
;	Input or output raw character from console, no echo
;
;	ENTRY	DL = -1 if input
;		   =  output character if output
;	EXIT	(AL) = input character if input
;	USES	all
;
;----------------------------------------------------------------------------
; 20/07/2018 - Retro DOS v3.0

_$RAW_CON_IO:			; System call 6

        MOV     AL,DL
        CMP     AL,-1
        JNZ     SHORT RAWOUT
        ;LES 	DI,[USER_SP]	; Get pointer to register save area
        LES     DI,[SS:USER_SP] ; 12/03/2018
	XOR     BX,BX
    	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
        ;JC	SHORT RET17
        jc	short FINDOLD_RETN
	MOV     AH,1
        CALL	IOFUNC
        JNZ     SHORT RESFLG
        CALL	SPOOLINT
        ;OR	BYTE [ES:DI+16H],40H
	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
        XOR     AL,AL
RET17:
        RETN

RESFLG:
	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
				; Reset user's zero flag
;RILP:
rci0:
     	CALL	SPOOLINT

;
;----------------------------------------------------------------------------
;
;**	$Raw_CON_INPUT - Raw Console Input
;
;	Input raw character from console, no echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

;rci0:	invoke	SPOOLINT

	;entry	$RAW_CON_INPUT

_$RAW_CON_INPUT:		; System call 7
	push	bx
        XOR     BX,BX
        ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
        pop	bx
	JC	SHORT RET17
        MOV     AH,1
        CALL	IOFUNC
	;JZ	SHORT RILP	; MSDOS 2.11
	;XOR     AH,AH
        ;CALL	IOFUNC
        ;RETN
	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
	MOV	AH,84h
	INT	int_IBM  ; int 2Ah
	JMP	short rci0
rci5:	
        XOR     AH,AH
        CALL	IOFUNC
        RETN

;
;       Output the character in AL to stdout
;
	;entry   RAWOUT

RAWOUT:
        PUSH    BX
        MOV     BX,1

        ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
        JC      SHORT RAWRET1
	;
	; MSDOS 2.11
        ;TEST	BYTE [SI+18H],080H	; output to file?
        ;JZ	SHORT RAWNORM		; if so, do normally
        ;PUSH	DS
        ;PUSH	SI
        ;LDS	SI,[SI+19H]		; output to special?
	;TEST	BYTE [SI+4],ISSPEC
	;POP	SI
	;
        
	; MSDOS 3.3 & MSDOS 6.0
	;mov	bx,[si+5]
	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 ;
 ; If we are a network handle OR if we are not a local device then go do the
 ; output the hard way.
 ;	
	;and	bx,8080h
	AND	BX,sf_isnet+devid_device
	;cmp	bx,80h
	CMP	BX,devid_device
	jnz     short RAWNORM
	push    ds
	;lds	bx,[si+7]
	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
	;test	byte [bx+4],10h
	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
	;

        POP     DS
        JZ      SHORT RAWNORM		; if not, do normally
        INT     int_fastcon   ; int 29h	; quickly output the char

        ;JMP     SHORT RAWRET
;RAWNORM:
;	CALL    RAWOUT3

RAWRET: 
	CLC
RAWRET1:
        POP     BX
RAWRET2:
	RETN

RAWNORM:
	CALL    RAWOUT3
	jmp	short RAWRET

;
;       Output the character in AL to handle in BX
;
;	entry   RAWOUT2

RAWOUT2:
	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
	;JC	SHORT RET18
	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
	JC	SHORT RAWRET2
RAWOUT3:
        PUSH    AX
        JMP     SHORT RAWOSTRT
ROLP:
        CALL	SPOOLINT

	; MSDOS 6.0
	;OR	word [DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
				;AN002; set control break
	;;invoke DSKSTATCHK
	;call	DSKSTATCHK	;AN002; check control break

RAWOSTRT:
        MOV     AH,3
        CALL    IOFUNC
        JZ      SHORT ROLP

	; MSDOS 6.0
;SR;
; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
;the user failed. We do not send a char if this happens. We however return 
;to the caller with carry clear because this DOS call does not return any
;status. 
;
	;inc	ax		;fail on I24 if ax = -1
	;POP	AX
	;jz	short nosend	;yes, do not send char
	;MOV	AH,2
	;call	IOFUNC
;nosend:
	;CLC			; Clear carry indicating successful
	;retn

	; MSDOS 3.3 & MSDOS 2.11
        POP     AX
        MOV     AH,2
        CALL    IOFUNC
        CLC                     ; Clear carry indicating successful
RET18:    
	RETN

;;10/08/2018
; 20/07/2018 - Retro DOS v3.0
; ---------------------------------------------------------------------------
; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
; ---------------------------------------------------------------------------

; This routine is called at DOS init

;;	;procedure OUTMES,NEAR ; String output for internal messages
;;OUTMES:
;;	;LODS	CS:BYTE PTR [SI]
;;	CS	LODSB
;;	CMP     AL,"$" ; 24h
;;	JZ	SHORT RET18
;;	CALL	OUTT
;;	JMP     SHORT OUTMES

; ---------------------------------------------------------------------------

; 20/07/2018 - Retro DOS v3.0

; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h

;
;----------------------------------------------------------------------------
;
; Inputs:
;	AX=0 save the DEVCALL request packet
;	  =1 restore the DEVCALL request packet
; Function:
;	save or restore the DEVCALL packet
; Returns:
;	none
;
;----------------------------------------------------------------------------
;

Save_Restore_Packet:
	PUSH	DS
	PUSH	ES
	PUSH	SI
	PUSH	DI

	; 09/09/2018
	mov	di,FAKE_STACK_2F 
	mov	si,DEVCALL
	;
	CMP	AX,0		; save packet
	;JZ	short save_packet
	je	short set_seg 

	; MSDOS 6.0
restore_packet:
;	MOV	SI,OFFSET DOSDATA:Packet_Temp	 ;sourec
;	MOV	DI,OFFSET DOSDATA:DEVCALL	 ;destination
	; MSDOS 3.3
	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
	;mov	di,DEVCALL  ; 09/09/2018
	;
	;JMP	short set_seg
	
	; 09/09/2018
	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F

	; MSDOS 6.0
save_packet:
;	MOV	DI,OFFSET DOSDATA:Packet_Temp	 ;destination
;	MOV	SI,OFFSET DOSDATA:DEVCALL	 ;source
	; 09/09/2018
	; MSDOS 3.3
	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
	;mov	si,DEVCALL ; 09/09/2018

set_seg:
	; MSDOS 6.0
	;MOV	AX,SS		; set DS,ES to DOSDATA
	; MSDOS 3.3
	mov	ax,cs
	;
	MOV	DS,AX
	MOV	ES,AX
	MOV	CX,11		; 11 words to move
	REP	MOVSW

	POP	DI
	POP	SI
	POP	ES
	POP	DS
	retn

;============================================================================
; CPMIO2.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT - System Call 1
;
;	Input character from console, echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT:	;System call 1
	
	CALL	_$STD_CON_INPUT_NO_ECHO
	PUSH	AX
	CALL	OUTT
	POP	AX
CON_INPUT_RETN:	
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_OUTPUT - System Call 2
;
;	Output character to console
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_OUTPUT:	;System call 2

	MOV	AL,DL

OUTT:
	CMP	AL,20H ; " "
	JB	SHORT CTRLOUT
	CMP	AL,c_DEL ; 7Fh
	JZ	SHORT OUTCH
OUTCHA:	
	;INC	BYTE PTR [CARPOS]
	INC	BYTE [SS:CARPOS]
OUTCH:
	PUSH	DS
	PUSH	SI
	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
	INC	BYTE [SS:CHARCO]	
	;AND	BYTE [SS:CHARCO],00111111B
	; 14/03/2018
	and	byte [SS:CHARCO],3  ; IBMDOS.COM, MSDOS 3.3, MSDOS 2.11
	JNZ	SHORT OUTSKIP
	PUSH	AX
	CALL	STATCHK
	POP	AX
OUTSKIP:
	CALL	RAWOUT				;output the character
	POP	SI
	POP	DS

	;TEST	BYTE PTR [PFLAG],-1
	;retz
	TEST	BYTE [SS:PFLAG],0FFh
	JZ	SHORT CON_INPUT_RETN

	PUSH	BX
	PUSH	DS
	PUSH	SI
	MOV	BX,1
	; 20/07/2018 - Retro DOS v3.0
	; MSDOS 3.3
	; MSDOS 6.0 (CPMIO2.ASM)
	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
					;hkn; to sft entry
	JC	SHORT TRIPOPJ
	;mov	bx,[si+5]
	MOV	BX,[SI+SF_ENTRY.sf_flags]
	;test	bx,8000h
	TEST	BX,sf_isnet	; 8000H		; output to NET?
	JNZ	short TRIPOPJ 			; if so, no echo
	;test	bx,80h
	TEST	BX,devid_device ; 80H		; output to file?
	JZ	SHORT TRIPOPJ 			; if so, no echo
	; 14/03/2018
	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
	;jc	short TRIPOPJ
	; MSDOS 2.11
	;test	byte [SI+18H], 80h
	;jz	short TRIPOPJ
	MOV	BX,4
	CALL	GET_IO_SFT
	JC	SHORT TRIPOPJ
	;test	word [si+5], 800h
	TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H 
						; StdPrn redirected?
	;JZ	SHORT LISSTRT2J			; No, OK to echo
	jz	LISSTRT2 ; 10/08/2018 
	;MOV	BYTE [PFLAG],0			
	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
	; MSDOS 2.11
	;mov	bx,4
	;jmp	short LISSTRT2
	
TRIPOPJ:
	; 20/07/2018
	JMP	TRIPOP

;LISSTRT2J:
;	JMP	LISSTRT2

CTRLOUT:
	CMP	AL,c_CR ; 0Dh
	JZ	SHORT ZERPOS
	CMP	AL,c_BS ; 8
	JZ	SHORT BACKPOS
	CMP	AL,c_HT ; 9
	JNZ	SHORT OUTCH
	;MOV	AL,[CARPOS]
	MOV	AL,[SS:CARPOS]
	OR	AL,0F8H
	NEG	AL

TAB:
	PUSH	CX
	MOV	CL,AL
	MOV	CH,0
	JCXZ	POPTAB
TABLP:
	MOV	AL," "
	CALL	OUTT
	LOOP	TABLP
POPTAB:
	POP	CX
	RETN

ZERPOS:
	;MOV	BYTE PTR [CARPOS],0
	MOV	BYTE [SS:CARPOS],0
	; 10/08/2018
	JMP	OUTCH
OUTJ:	
	JMP	OUTT

BACKPOS:
	;DEC	BYTE PTR [CARPOS]
	DEC	BYTE [SS:CARPOS]
	JMP	OUTCH

BUFOUT:
	CMP	AL," "
	JAE	SHORT OUTJ		;Normal char
	CMP	AL,9
	JZ	SHORT OUTJ		;OUT knows how to expand tabs
	;DOS 3.3  7/14/86
	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
	JZ	short CTRLU
	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
	JZ	short CTRLU
NOT_CTRLU:
	;DOS 3.3  7/14/86
	PUSH	AX
	MOV	AL,"^"
	CALL	OUTT		;Print '^' before control chars
	POP	AX
	OR	AL,40H		;Turn it into Upper case mate
CTRLU:
	CALL	OUTT
BUFOUT_RETN:
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_INPUT - System Call 3
;
;	$STD_AUX_INPUT returns a character from Aux Input
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_AUX_INPUT:	;System call 3

	CALL	STATCHK
	MOV	BX,3
	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
	;retc
	JC	SHORT BUFOUT_RETN
	JMP	SHORT TAISTRT
AUXILP:
	CALL	SPOOLINT
TAISTRT:
	MOV	AH,1
	CALL	IOFUNC
	JZ	SHORT AUXILP
	XOR	AH,AH
	CALL	IOFUNC
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_OUTPUT - Output character to AUX
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_AUX_OUTPUT:	;System call 4

	PUSH	BX
	MOV	BX,3
	JMP	SHORT SENDOUT

;
;----------------------------------------------------------------------------
;
;**	$STD_PRINTER_OUTPUT - Output character to printer
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_PRINTER_OUTPUT:	;System call 5

	PUSH	BX
	MOV	BX,4

SENDOUT:
	MOV	AL,DL
	PUSH	AX
	CALL	STATCHK
	POP	AX
	PUSH	DS
	PUSH	SI
LISSTRT2:
	CALL	RAWOUT2
TRIPOP:
	POP	SI
	POP	DS
	POP	BX
SCIS_RETN:	; 20/07/2018
	RETN
;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_STATUS - System Call 11
;
;	Check console input status
;
;	ENTRY	none
;	EXIT	AL = -1 character available, = 0 no character
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_STATUS:		 ;System call 11

	CALL	STATCHK
	MOV	AL,0			; no xor!!
	;retz
	JZ	SHORT SCIS_RETN ; 15/04/2018
	OR	AL,-1
;SCIS_RETN:
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_FLUSH - System Call 12
;
;	Flush console input buffer and perform call in AL
;
;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
;		return arguments for the fcn supplied in (AL)
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_FLUSH:		;System call 12

	PUSH	AX
	PUSH	DX
	XOR	BX,BX
	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
	JC	SHORT BADJFNCON
	MOV	AH,4
	CALL	IOFUNC

BADJFNCON:
	POP	DX
	POP	AX
	MOV	AH,AL
	CMP	AL,1
	JZ	SHORT REDISPJ
	CMP	AL,6
	JZ	SHORT REDISPJ
	CMP	AL,7
	JZ	SHORT REDISPJ
	CMP	AL,8
	JZ	SHORT REDISPJ
	CMP	AL,10
	JZ	SHORT REDISPJ
	MOV	AL,0
	RETN

REDISPJ:
	CLI
	;transfer REDISP
	JMP	REDISP

;============================================================================
; FCBIO.ASM, MSDOS 6.0, 1991
;============================================================================
; 20/07/2018 - Retro DOS v3.0

;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
;
;	$GET_FCB_POSITION
;	$FCB_DELETE
;	$GET_FCB_FILE_LENGTH
;	$FCB_CLOSE
;	$FCB_RENAME
;	SaveFCBInfo
;	ResetLRU
;	SetOpenAge
;	LRUFCB
;	FCBRegen
;	BlastSFT
;	CheckFCB
;	SFTFromFCB
;	FCBHardErr
;
;	Revision history:
;
;		Created: ARR 4 April 1983"
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;					  times.  Change so successive closes work by
;					  always returning OK.	Also, detect I/O to
;					  already closed FCB and return EOF.
;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
;					  out of sft into FCB for reconnection
;
;		A000	 version 4.00  Jan. 1988

;Break <$Get_FCB_Position - set random record fields to current pos>
;----------------------------------------------------------------------------
;
;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
;	extent and next record field and set the random record field to point
;	to that record
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	The random record field of the FCB is set to the current record
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

_$GET_FCB_POSITION:
	call	GetExtended		; point to FCB
	call	GetExtent		; DX:AX is current record
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX ; drop in low order piece
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
	;cmp	word [si+0Eh],64
	CMP	word [SI+SYS_FCB.RECSIZ],64
	JAE	short GetFCBBye
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
GetFCBBye:
	jmp	FCB_RET_OK


;Break <$FCB_Delete - remove several files that match the input FCB>
;----------------------------------------------------------------------------
;
;**	$FCB_Delete - Delete from FCB Template
;
;	given an FCB, remove all directory entries in the current
;	directory that have names that match the FCB's ?  marks.
;
;	ENTRY	(DS:DX) = address of FCB
;	EXIT	entries matching the FCB are deleted
;		(al) = ff iff no entries were deleted
;	USES	all
;
;----------------------------------------------------------------------------
;

_$FCB_DELETE:		; System call 19
					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF 		; appropriate place 

	call	TransFCB		; convert FCB to path
	JC	short BadPath 		; signal no deletions

	push	SS
	pop	DS			; SS is DOSDATA

	call	DOS_DELETE		; wham
	JC	short BadPath
GoodPath:
	jmp	FCB_RET_OK		; do a good return
BadPath:
	; Error code is in AX

	jmp	FCB_RET_ERR		; let someone else signal the error


;Break <$Get_FCB_File_Length - return the length of a file>
;----------------------------------------------------------------------------
;
;   $Get_FCB_File_Length - set the random record field to the length of the
;	file in records (rounded up if partial).
;
;   Inputs:	DS:DX - point to a possible extended FCB
;   Outputs:	Random record field updated to reflect the number of records
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

_$GET_FCB_FILE_LENGTH:

	call	GetExtended		; get real FCB pointer
					; DX points to Input FCB

					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF		; appropriate buffer

	push	ds			; save pointer to true FCB
	push	si
	call	TransFCB		; Trans name DS:DX, sets SATTRIB
	pop	si
	pop	ds
	JC	short BadPath
	push	ds			; save pointer
	push	si
	push	ss		
	pop	ds
	call	GET_FILE_INFO		; grab the info
	pop	si			; get pointer back
	pop	ds
	JC	short BadPath 		; invalid something
	MOV	DX,BX			; get high order size
	MOV	AX,DI			; get low order size
	;mov	 bx,[si+0Eh]
	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
	OR	BX,BX			; empty record => 0 size for file
	JNZ	short GetSize 		; not empty
	MOV	BX,128
GetSize:
	MOV	DI,AX			; save low order word
	MOV	AX,DX			; move high order for divide
	XOR	DX,DX			; clear out high
	DIV	BX			; wham
	PUSH	AX			; save dividend
	MOV	AX,DI			; get low order piece
	DIV	BX			; wham
	MOV	CX,DX			; save remainder
	POP	DX			; get high order dividend
	JCXZ	LengthStore		; no roundup
	ADD	AX,1
	ADC	DX,0			; 32-bit increment
LengthStore:
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX	; store low order
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
	OR	DH,DH
	JZ	short GoodPath		; not storing insignificant zero
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
GoodRet:
	;jmp	FCB_RET_OK
	jmp	short GoodPath

;Break <$FCB_Close - close a file>
;----------------------------------------------------------------------------
;
;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
;	as the FCB may be used for further I/O
;
;   Inputs:	DS:DX point to FCB
;   Outputs:	AL = FF if file was not found on disk
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

_$FCB_CLOSE:		; System call 16

	XOR	AL,AL			; default search attributes
	call	GetExtended		; DS:SI point to real FCB
	JZ	short NoAttr		; not extended
	MOV	AL,[SI-1]		; get attributes
NoAttr:
					; SS override
	MOV	[SS:ATTRIB],AL		; stash away found attributes
	call	SFTFromFCB
	JC	short GoodRet 		; MZ 16 Jan Assume death

	;
	; If the sharer is present, then the SFT is not regenable. Thus, 
	; there is no need to set the SFT's attribute.
	;

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	;mov	al,[es:di+4]
	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
	XOR	AH,AH
	PUSH	AX

	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
	;;; done

	call	CheckShare
	JNZ	short NoStash
	MOV	AL,[SS:ATTRIB]
	;mov	[es:di+4],al
	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
NoStash:
	;mov	ax,[si+14h]
	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
	;mov	[es:di+0Fh],ax
	MOV	[ES:DI+SF_ENTRY.sf_date],AX
	;mov	ax,[si+16h]
	MOV	AX,[SI+SYS_FCB.FTIME]
	;mov	[es:di+0Dh],ax
	MOV	[ES:DI+SF_ENTRY.sf_time],AX
	;mov	ax,[si+10h]
	MOV	AX,[SI+SYS_FCB.FILSIZ]
	;mov	[es:di+11h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size],AX
	;mov	ax,[si+12h]
	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
	;mov	[es:di+13h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
	;or	word [es:di+5],4000h
	OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
	push	ss
	pop	ds
	call	DOS_CLOSE	; wham
	LES	DI,[THISSFT]

	;;; 9/8/86 F.C. restore SFT attribute
	POP	CX
	;mov	[es:di+4],cl
	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
	;;; 9/8/86 F.C. restore SFT attribute

	PUSHF
	;test	word [es:di],0FFFFh
	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
				; zero ref count gets blasted
	cmp	word [ES:DI],0
	jnz     short CloseOK
	PUSH	AX
	MOV	AL,'M'
	call	BlastSFT
	POP	AX
CloseOK:
	POPF
	JNC	short GoodRet
	;cmp	al,6
	CMP	AL,error_invalid_handle
	JZ	short GoodRet
	;mov	al,2
	MOV	AL,error_file_not_found
fcb_close_err:
	jmp	FCB_RET_ERR

;
;----------------------------------------------------------------------------
;
;**	$FCB_Rename - Rename a File
;
;	$FCB_Rename - rename a file in place within a directory.  Renames
;	multiple files copying from the meta characters.
;
;	ENTRY	DS:DX point to an FCB.	The normal name field is the source
;		    name of the files to be renamed.  Starting at offset 11h
;		    in the FCB is the destination name.
;	EXIT	AL = 0 -> no error occurred and all files were renamed
;		AL = FF -> some files may have been renamed but:
;			rename to existing file or source file not found
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$FCB_RENAME:		; System call 23

	call	GetExtended		; get pointer to real FCB
	push	dx
	MOV	AL,[SI] 		; get drive byte
	ADD	SI,10h			; point to destination

					; RenBuf is in DOSDATA
	MOV	DI,RENBUF		; point to destination buffer
	push	word [SI]
	push	ds
	;push	di			; save source pointer for TransFCB
	; 16/01/2024 - BugFix !
	push	si
	MOV	[SI],AL			; drop in real drive
	MOV	DX,SI			; let TransFCB know where the FCB is
	call	TransFCB		; munch this pathname
	pop	si
	pop	ds	
	pop	WORD [SI]		; get path back
	pop	dx			; Original FCB pointer
	JC	short fren90		; bad path -> error

					; SS override for WFP_Start & Ren_WFP
	MOV	SI,[ss:WFP_START]	; get pointer
	MOV	[ss:REN_WFP],SI		; stash it

					; OpenBuf is in DOSDATA
	MOV	DI,OPENBUF		; appropriate spot
	call	TransFCB		; wham
					; NOTE that this call is pointing
					;  back to the ORIGINAL FCB so
					;  SATTRIB gets set correctly
	JC	short fren90		; error
	call	DOS_RENAME
	JC	short fren90
	jmp	FCB_RET_OK

;	Error -
;
;	(al) = error code

fren90:	
	jmp	FCB_RET_ERR


;Break <Misbehavior fixers>
;
;   FCBs suffer from several problems.	First, they are maintained in the
;   user's space so he may move them at will.  Second, they have a small
;   reserved area that may be used for system information.  Third, there was
;   never any "rules for behavior" for FCBs; there was no protocol for their
;   usage.
;
;   This results in the following misbehavior:
;
;	infinite opens of the same file:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB);		    FCBOpen (FCB);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	infinite opens of different files:
;
;	While (TRUE) {			While (TRUE) {
;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
;	    Read (FCB); 		    Write (FCB);
;	    }				    }
;
;	multiple closes of the same file:
;
;	FCBOpen (FCB);
;	while (TRUE)
;	    FCBClose (FCB);
;
;	I/O after closing file:
;
;	FCBOpen (FCB);
;	while (TRUE) {
;	    FCBWrite (FCB);
;	    FCBClose (FCB);
;	    }
;
;   The following is am implementation of a methodology for emulating the
;   above with the exception of I/O after close.  We are NOT attempting to
;   resolve that particular misbehavior.  We will enforce correct behaviour in
;   FCBs when they refer to a network file or when there is file sharing on
;   the local machine.
;
;   The reserved fields of the FCB (10 bytes worth) is divided up into various
;   structures depending on the file itself and the state of operations of the
;   OS.  The information contained in this reserved field is enough to
;   regenerate the SFT for the local non-shared file.  It is assumed that this
;   regeneration procedure may be expensive.  The SFT for the FCB is
;   maintained in a LRU cache as the ONLY performance inprovement.
;
;   No regeneration of SFTs is attempted for network FCBs.
;
;   To regenerate the SFT for a local FCB, it is necessary to determine if the
;   file sharer is working.  If the file sharer is present then the SFT is not
;   regenerated.
;
;   Finally, if there is no local sharing, the full name of the file is no
;   longer available.  We can make up for this by using the following
;   information:
;
;	The Drive number (from the DPB).
;	The physical sector of the directory that contains the entry.
;	The relative position of the entry in the sector.
;	The first cluster field.
;	The last used SFT.
;      OR In the case of a device FCB
;	The low 6 bits of sf_flags (indicating device type)
;	The pointer to the device header
;
;
;   We read in the particular directory sector and examine the indicated
;   directory entry.  If it matches, then we are kosher; otherwise, we fail.
;
;   Some key items need to be remembered:
;
;	Even though we are caching SFTs, they may contain useful sharing
;	information.  We enforce good behavior on the FCBs.
;
;	Network support must not treat FCBs as impacting the ref counts on
;	open VCs.  The VCs may be closed only at process termination.
;
;	If this is not an installed version of the DOS, file sharing will
;	always be present.
;
;	We MUST always initialize lstclus to = firclus when regenerating a
;	file. Otherwise we start allocating clusters up the wazoo.
;
;	Always initialize, during regeneration, the mode field to both isFCB
;	and open_for_both.  This is so the FCB code in the sharer can find the
;	proper OI record.
;
;   The test bits are:
;
;	00 -> local file
;	40 -> sharing local
;	80 -> network
;	C0 -> local device

;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
;----------------------------------------------------------------------------
;
;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
;	pieces of information into the FCB to allow for subsequent
;	regeneration. Poke LRU also.
;
;   Inputs:	ThisSFT points to a complete SFT.
;		DS:SI point to the FCB (not an extended one)
;   Outputs:	The relevant reserved fields in the FCB are filled in.
;		DS:SI preserved
;		ES:DI point to sft
;   Registers modified: All
;
;
;----------------------------------------------------------------------------
;

SaveFCBInfo:

	LES	DI,[SS:THISSFT]		; SS override
	call	IsSFTNet
	JZ	short SaveLocal		; if not network then save local info
;
;----- In net support -----
;
	; MSDOS 6.0
	;MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
	;MOV	[SI+fcb_netID],ax	;AN000;;IFS.
	; MSDOS 3.3
	;mov	ax,[es:di+1Dh]
	mov	ax,[es:di+SF_ENTRY.sf_dirsec]
	;mov	[si+1Ah],ax
	mov	[si+fcb_net_handle],ax

	; MSDOS 3.3
	push	es
	push	di
	;les	di,[es:di+19h]
	LES	DI,[ES:DI+sf_netid]
	;mov	[si+1Ch],di
	MOV	[SI+fcb_netID],DI	; save net ID
	;mov 	[si+1Eh],es
	MOV	[SI+fcb_netID+2],ES
	pop	di
	pop	es

	;mov	bl,80h
	MOV	BL,FCBNETWORK
;
;----- END In net support -----
;
	jmp	SHORT SaveSFN

SaveLocal:
	;IF	Installed
	call	CheckShare
	JZ	short SaveNoShare	; no sharer
	JMP	short SaveShare		; sharer present

SaveNoShare:
	;test 	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	JNZ	short SaveNoShareDev	; Device
	;
	; Save no sharing local file information
	;
	;mov	ax,[es:di+1Dh]
	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
	;mov	[si+1Dh],ax
	MOV	[SI+fcb_nsl_dirsec],AX

	; MSDOS 6.0
	;SR; Store high byte of directory sector
	;mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
	;
	; SR;
	; We have to store the read-only and archive attributes of the file.
	; We extract it from the SFT and store it in the top two bits of the 
	; sector number ( sector number == 22 bits only )
	;
	;mov	bl,[es:di+SF_ENTRY.sf_attr]
	;mov	bh,bl
	;ror	bl,1
	;shl	bh,1
	;or	bl,bh
	;and	bl,0C0h
	;
	;or	al,bl
	;mov	[si+fcb_sfn],al	;sector number = 22-bits

	; MSDOS 3.3 ($ MSDOS 6.0)
	;mov	al,[es:di+1Fh]
	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
	;mov	[si+1Fh],al
	MOV	[SI+fcb_nsl_dirpos],AL
	;mov	ax,[es:di+0Bh]
	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
	;mov	[si+1Bh],ax
	MOV	[SI+fcb_nsl_firclus],AX
	MOV	BL,0

	; Create the bits field from the dirty/device bits of the flags word 
	; and the mode byte

SetFCBBits:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AL,0C0h 		; mask off drive bits
	;or	al,[es:di+2]
	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
	;mov	[si+1Ah], al
	MOV	[SI+fcb_nsl_bits],AL	; save dirty info

	; MSDOS 6.0
	; SR;
	; Check if we came here for local file or device. If for local file, 
	; skip setting of SFT index
	;
	;or	bl,bl
	;jz	short SaveNoSFN		; do not save SFN if local file

	JMP	short SaveSFN 		; go and save SFN

	; Save no sharing local device information

SaveNoShareDev:
	;mov	ax,[es:di+7]
	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
	;mov	[si+1Ah],ax
	MOV	[SI+fcb_nsld_drvptr],AX
	;mov	ax,[es:di+9]
	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
	MOV	[SI+fcb_nsld_drvptr+2],AX
	;mov	bl,40h
	MOV	BL,FCBDEVICE
	JMP	SetFCBBits		; go and save SFN

SaveShare:
	;ENDIF
;
;----- In share support -----
;
	;call	far [ss:ShSave]
	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
;
;----- end in share support -----
;
SaveSFN:
	; MSDOS 3.3
	;mov	ax,[es:di+5]
	;and	al,3Fh
	;or	al,bl
	;mov	[si+19h],al

	;lea	ax, [di-6]
	LEA	AX,[DI-SFT.SFTable]
	
	; Adjust for offset to table.
	
	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB

	push	bx			;bx = FCB type (net/Share or local)
	mov	bl,53
	MOV	BL,SF_ENTRY.size
	DIV	BL
	MOV	[SI+fcb_sfn],AL		; last used SFN
	pop	bx			;restore bx

SaveNoSFN:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AL,3Fh			; get real drive
	OR	AL,BL
	;mov	[si+19h],al
	MOV	[SI+fcb_l_drive],AL

	MOV	AX,[SS:FCBLRU]		; get lru count
	INC	AX
	;mov	[es:di+15h],ax
	MOV	[ES:DI+sf_LRU],AX
	JNZ	short SimpleStuff
	
	; lru flag overflowed.	Run through all FCB sfts and adjust:  
	; LRU < 8000H get set to 0.  Others -= 8000h.  This LRU = 8000h
	
	;mov	bx,15h
	MOV	BX,SF_ENTRY.sf_position
	call	ResetLRU

	;	Set new LRU to AX
SimpleStuff:
	MOV	[SS:FCBLRU],AX
	retn

;Break	<ResetLRU - reset overflowed lru counts>
;----------------------------------------------------------------------------
;
;   ResetLRU - during lru updates, we may wrap at 64K.	We must walk the
;   entire set of SFTs and subtract 8000h from their lru counts and truncate
;   at 0.
;
;   Inputs:	BX is offset into SFT field where lru firld is kept
;		ES:DI point to SFT currently being updated
;   Outputs:	All FCB SFTs have their lru fields truncated
;		AX has 8000h
;   Registers modified: none
;
;----------------------------------------------------------------------------
;

ResetLRU:

	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
	; DOSDATA

	MOV	AX,8000h
	push	es
	push	di
	LES	DI,[CS:SFTFCB]		; get pointer to head
	;mov	cx,[es:di+4]
	MOV	CX,[ES:DI+SFT.SFCount]
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable] 	; point at table
ovScan:
	SUB	[ES:DI+BX],AX		; decrement lru count
	JA	short ovLoop
	MOV	[ES:DI+BX],AX		; truncate at 0
ovLoop:
	;add	di,53
	ADD	DI,SF_ENTRY.size	; advance to next
	LOOP	ovScan
	pop	di
	pop	es
	MOV	[ES:DI+BX],AX
	retn

;IF  0  ; We dont need this routine any more.

;Break	<SetOpenAge - update the open age of a SFT>
;----------------------------------------------------------------------------
;
;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
;   we keep the 'open age' or an LRU count based on opens.  We update the
;   count here and fill in the appropriate field.
;
;   Inputs:	ES:DI point to SFT
;   Outputs:	ES:DI has the open age field filled in.
;		If open age has wraparound, we will have subtracted 8000h
;		    from all open ages.
;   Registers modified: AX
;
;----------------------------------------------------------------------------
;

SetOpenAge:

	; 20/07/2018 - Retro DOS v3.0
	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
	; (& MSDOS 6.0, FCBIO.ASM)

	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.

	MOV	AX,[CS:OpenLRU]	; SS override
	INC	AX
	;mov	[es:di+17h],ax
	MOV	[ES:DI+sf_OpenAge],AX
	JNZ	short SetDone
	;mov	bx,17h
	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
	call	ResetLRU
SetDone:
	MOV	[CS:OpenLRU],AX
	retn

;ENDIF	; SetOpenAge no longer needed


; 21/07/2018 - Retro DOS v3.0

; LRUFCB for MSDOS 3.3 !

;Break	<LRUFCB - perform LRU on FCB sfts>
;----------------------------------------------------------------------------
;
;   LRUFCB - find LRU fcb in cache.  Set ThisSFT and return it.  We preserve
;	the first keepcount sfts if they are network sfts or if sharing is
;	loaded.  If carry is set then NO BLASTING is NECESSARY.
;
;   Inputs:	none
;   Outputs:	ES:DI point to SFT
;		ThisSFT points to SFT
;		SFT is zeroed
;		Carry set of closes failed
;   Registers modified: none
;
;----------------------------------------------------------------------------
;

; MSDOS 6.0
;IF 0	; rewritten this routine

LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
	call	save_world
	
; Find nth oldest NET/SHARE FCB.  We want to find its age for the second scan
; to find the lease recently used one that is younger than the open age.  We
; operate be scanning the list n times finding the least age that is greater
; or equal to the previous minimum age.
;
;   BP is the count of times we need to go through this loop.
;   AX is the current acceptable minimum age to consider
;
	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
	XOR	AX,AX			; low = 0;
;
; If we've scanned the table n times, then we are done.
;
lru1:
	CMP	bp,0			; while (k--) {
	JZ	short lru75
	DEC	bp
;
; Set up for scan.
;
;   AX is the minimum age for consideration
;   BX is the minimum age found during the scan
;   SI is the position of the entry that corresponds to BX
;
	MOV	BX,-1			;     min = 0xffff;
	MOV	si,BX			;     pos = 0xffff;
	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
	;mov	cx,[es:di+4]
	MOV	CX,[ES:DI+SFT.SFCount]
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable]
;
; Innermost loop.  If the current entry is free, then we are done.  Or, if the
; current entry is busy (indicating a previous aborted allocation), then we
; are done.  In both cases, we use the found entry.
;
lru2:
	cmp	word [es:di],0
	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
	jz	short lru25
	;cmp	word [es:di],-1
	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
	cmp	word [es:di],sf_busy
	jnz	short lru3
;
; The entry is usable without further scan.  Go and use it.
;
lru25:
	MOV	si,DI			;	      pos = i;
	JMP	short lru11		;	      goto got;
;
; See if the entry is for the network or for the sharer.
;
;  If for the sharer or network then
;	if the age < current minimum AND >= allowed minimum then
;	    this entry becomes current minimum
;
lru3:
	;test	word [es:di+5],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
					;	  if (!net[i]
	JNZ	short lru35
;if installed
	call	CheckShare		;		&& !sharing)
	JZ	short lru5		;	  else
;ENDIF
;
; This SFT is for the net or is for the sharer.  See if it less than the
; current minimum.
;
lru35:
	;mov	dx,[es:di+17h]
	MOV	DX,[ES:DI+sf_OpenAge]
	CMP	DX,AX			;	  if (age[i] >= low &&
	JB	short lru5
	CMP	DX,BX
	JAE	short lru5		;	      age[i] < min) {
;
; entry is new minimum.  Remember his age.
;
	mov	bx,DX			;	      min = age[i];
	mov	si,di			;	      pos = i;
;
; End of loop.	gp back for more
;
lru5:
	;add	di,53
	add	di,SF_ENTRY.size
	loop	lru2			;	      }
;
; The scan is complete.  If we have successfully found a new minimum (pos != -1)
; set then threshold value to this new minimum + 1.  Otherwise, the scan is
; complete.  Go find LRU.
;
lru6:	
	cmp	si,-1			; position not -1?
	jz	short lru75		; no, done with everything
	lea	ax,[bx+1]		; set new threshold age
	jmp	short lru1		; go and loop for more
lru65:	
	stc
	jmp	short LRUDead		;	  return -1;
;
; Main loop is done.  We have AX being the age+1 of the nth oldest sharer or
; network entry.  We now make a second pass through to find the LRU entry
; that is local-no-share or has age >= AX
;
lru75:
	mov	bx,-1			; min = 0xffff;
	mov	si,bx			; pos = 0xffff;
	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
	;mov	cx,[es:di+4]
	MOV	CX,[ES:DI+SFT.SFCount]
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable]
;
; If this is is local-no-share then go check for LRU else if age >= threshold
; then check for lru.
;
lru8:
	;test	word [es:di+5],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	jnz	short lru85		; is for network, go check age
	call	CheckShare		; sharer here?
	jz	short lru86		; no, go check lru
;
; Network or sharer.  Check age
;
lru85:
	;cmp	[es:di+17h],ax
	cmp	[es:di+sf_OpenAge],ax
	jb	short lru9		; age is before threshold, skip it
;
; Check LRU
;
lru86:
	;cmp	[es:di+15h],bx
	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
	jae	short lru9		; no, skip this
	mov	si,di			; remember position
	;mov	bx,[es:di+15h]
	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
;
; Done with this entry, go back for more.
;
lru9:
	;add	di, 53
	add	di,SF_ENTRY.size
	loop	lru8
;
; Scan is complete.  If we found NOTHING that satisfied us then we bomb
; out.	The conditions here are:
;
;   No local-no-shares AND all net/share entries are older than threshold
;
lru10:
	cmp	si,-1			; if no one f
	jz	short lru65		;     return -1;
lru11:
	mov	di,si
	MOV	[CS:THISSFT],DI		; set thissft
	MOV	[CS:THISSFT+2],ES
;
; If we have sharing or thisSFT is a net sft, then close it until ref count
; is 0.
;
	;test	word [es:di+5],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JNZ	short LRUClose
;IF INSTALLED
	call	CheckShare
	JZ	short LRUDone
;ENDIF
;
; Repeat close until ref count is 0
;
LRUClose:
	push	ss
	pop	ds
	LES	DI,[THISSFT]
	cmp     word [es:di],0
	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
	JZ	short LRUDone 		; nope, all done
	call	DOS_CLOSE
	jnc	short LRUClose		; no error => clean up
	;cmp	al,6
	cmp	al,error_invalid_handle
	jz	short LRUClose
	stc
	JMP	short LRUDead
LRUDone:
	XOR	AL,AL
	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared

LRUDead:
	call	restore_world
 	LES     DI,[CS:THISSFT]
	jnc	short LRUFCB_retn
LRUFCB_err:
	; mov	al, 23h	
	MOV	AL,error_FCB_unavailable
LRUFCB_retn:	
	retn:

;ENDIF

FCBRegen:
	; called from SFTFromFCB. SS already DOSDATA

	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
	; we do not fill, size we do no fill, position we do not fill,
	; bit 14 of flags = TRUE, other bits = FALSE

	;mov	al,[si+19h]
	MOV	AL,[SI+fcb_l_drive]

	; We discriminate based on the first two bits in the reserved field.
	
	;test	al,80h
	test	AL,FCBSPECIAL		; check for no sharing test
	JZ	short RegenNoSharing	; yes, go regen from no sharing

	;
	; The FCB is for a network or a sharing based system.  At this point 
	; we have already closed the SFT for this guy and reconnection is 
	; impossible.
	;
	; Remember that he may have given us a FCB with bogus information in
	; it. Check to see if sharing is present or if the redir is present.
	; If either is around, presume that we have cycled out the FCB and 
	; give the hard error. Otherwise, just return with carry set.
	;

	call	CheckShare		; test for sharer
	JNZ	short RegenFail		; yep, fail this.
	;mov	ax,1100h
	MOV	AX,MultNET<<8		; install check on multnet
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
			; Return: AL = 00h  not installed, OK to install
			; 01h  not installed, not OK to install
			; FFh  installed
	OR	AL,AL			; is it there?
	JZ	short RegenDead		; no, just fail the operation
RegenFail:
	MOV     AX,[CS:USER_IN_AX]	; SS override
	;cmp	ah,10h
	cmp	AH,FCB_CLOSE
	jz	short RegenDead
	call	FCBHardErr		; massive hard error.
RegenDead:
	STC				; carry set
FCBRegen_retn:
	retn

	;
	; Local FCB without sharing. Check to see if sharing is loaded. If 
	; so fail the operation.
	;
RegenNoSharing:
	call	CheckShare		; Sharing around?
	JNZ	short RegenFail
	
	; Find an SFT for this guy.
	
	; MSDOS 6.0
	;push	ax
	;mov	al,0			;indicate it is a regen operation
	;call	LRUFCB
	;pop	ax
	;jc	short FCBRegen_retn

	; MSDOS 3.3
	call	LRUFCB
	jc	short FCBRegen_retn

	;mov	word [es:di+2],8002h
	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
	AND	AL,3Fh			; get drive number for flags
	CBW
	;or	ax,4000h
	OR	AX,sf_close_nodate	; normal FCB operation

	;
	; The bits field consists of the upper two bits (dirty and device) 
	; from the SFT and the low 4 bits from the open mode.
	;

	;mov	cl,[si+1Ah]
	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
	MOV	CH,CL
	AND	CH,0C0h 		; mask off the dirty/device bits
	OR	AL,CH
	;and	cl,0Fh
	AND	CL,access_mask		; get the mode bits
	;mov	[es:di+2],cl
	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
	;mov	[es:di+5],ax
	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
	MOV     AX,[CS:PROC_ID]		; SS override
	;mov	[es:di+31h],ax
	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
	push	ds
	push	si
	push	es
	push	di
	push	ss
	pop	es
	MOV	DI,NAME1		; NAME1 is in DOSDATA

	MOV	CX,8
	INC	SI			; Skip past drive byte to name in FCB

	; MSDOS 6.0
	;call	RegenCopyName		;copy the name to NAME1

	; MSDOS 3.3
RegenCopyName:
	lodsb
	call	UCase
	stosb
	loop	RegenCopyName

	push	ss	; SS is DOSDATA
	pop	ds

	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
					; Must set this to something interesting
					; to call DEVNAME.
	call	DEVNAME 		; check for device
	pop	si
	pop	es
	pop	si
	pop	ds
	JC	short RegenFileNoSharing ; not found on device list => file

	;
	; Device found.  We can ignore disk-specific info
	;

	;mov	[es:di+5],bh
	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
	;mov	byte [es:di+4],0
	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
					; SS override
	LDS	SI,[CS:DEVPT]		; get device driver
	;mov	[es:di+7],si
	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
	;mov	[es:di+9],ds
	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
	retn				; carry is clear

RegenDeadJ:
	JMP	RegenDead

	;
	; File found.  Just copy in the remaining pieces.
	;

RegenFileNoSharing:
	;mov	ax,[es:di+5]
	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
	AND	AX,03Fh
	push	ds
	push	si
	call	FIND_DPB
	;mov	[es:di+7],si
	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
	;mov	[es:di+9],ds
	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
	pop	si
	pop	ds
	jc	short RegenDeadJ	; if find DPB fails, then drive
					; indicator was bogus
	;mov	ax,[si+1Dh]
	MOV	AX,[SI+fcb_nsl_dirsec]
	;mov	[es:di+1Dh],ax
	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX

	;MSDOS6.0
	; SR;
	; Update the higher word of the directory sector from the FCB
	;

	;MOV	word [ES:DI+SF_ENTRY.sf_dirsec+2],0	;AN000;>32mb

	; SR;
	; Extract the read-only and archive bits from the top 2 bits of the sector
	; number
	;

	;mov	al,[si+fcb_sfn]
	;and	al,0C0h		;get the 2 attribute bits
	;mov	ah,al
	;rol	ah,1
	;shr	al,1
	;or	al,ah
	;and	al,03Fh		;mask off unused bits
	;mov	[es:di+SF_ENTRY.sf_attr],al

	;mov	al,[si+fcb_sfn]
	;and	al,03Fh		;mask off top 2 bits -- attr bits
	;sub	ah,ah
	;mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ax,[si+1Bh]
	MOV	AX,[SI+fcb_nsl_firclus]
	;mov	[es:di+0Bh],ax
	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
	;mov	[es:di+1Bh],ax
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
	;mov	al,[si+1Fh]
	MOV	AL,[SI+fcb_nsl_dirpos]
	;mov  	[es:di+1Fh], al
	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
	inc	word [ES:DI]		; Increment reference count.
					; Existing FCB entries would be
					; flushed unnecessarily because of
					; check in CheckFCB of the ref_count.
					; July 22/85 - BAS
	;lea	si,[si+1]
	LEA	SI,[SI+SYS_FCB.name]
	;lea	di,[di+20h] ; MSDOS 3.3 
	LEA	DI,[DI+SF_ENTRY.sf_name]
	;mov	cx,11
	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
	
	; 17/05/2019
	; MSDOS 6.0
	;call	RegenCopyName	;copy name to SFT 
	;
	; MSDOS3.3
RegenCopyName2:
	lodsb
	call    UCase
	stosb
	loop    RegenCopyName2

	clc
	retn

;**	BlastSFT - FIll SFT with Garbage
;
;	BlastSFT is used when an SFT is no longer needed; it's called with
;	various garbage values to put into the SFT.  I don't know why,
;	presumably to help with debugging (jgl).  We clear the few fields
;	necessary to show that the SFT is free after filling it.
;
;	ENTRY	(es:di) = address of SFT
;		(al) = fill character
;	EXIT	(ax) = -1
;		'C' clear
;	USES	AX, CX, Flags

BlastSFT:
	push	di
	;mov	cx,53
	mov	cx,SF_ENTRY.size
	rep	stosb
	pop	di
	sub	ax,ax	; 0		; clear 'C'-----------------;
	mov	[es:di],ax
	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
	;mov	[es:di+15h],ax
	mov	[es:di+sf_LRU],ax	; set lru		    ;
	dec	ax	; -1					    ;
	;mov	[es:di+17h],ax ; 0FFFFh ; -1
	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
BlastSFT_retn:
	retn				; return with 'C' clear     ;


;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
;----------------------------------------------------------------------------
;
;   CheckFCB - examine an FCB and its contents to see if it needs to be
;   regenerated.
;
;   Inputs:	DS:SI point to FCB (not extended)
;		AL is SFT index
;   Outputs:	Carry Set - FCB needs to be regened
;		Carry clear - FCB is OK. ES:DI point to SFT
;   Registers modified: AX and BX
;
;----------------------------------------------------------------------------
;

CheckFCB:
		
	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA

	; MSDOS6.0
	; SR;
	; We check if the given FCB is for a local file. If so, we return a 
	; bad SFT status forcing the caller to regenerate the SFT.

	;test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
	;jz	short BadSFT		;Local file, return bad SFT

	; MSDOS 3.3 (& MSDOS6.0)
	LES     DI,[CS:SFTFCB]		; SS override
	;cmp	[es:di+4],al
	CMP	[ES:DI+SFT.SFCount],AL
	JC	short BadSFT
	MOV	BL,SF_ENTRY.size
	MUL	BL
	;lea	di,[di+6]
	LEA	DI,[DI+SFT.SFTable]
	ADD	DI,AX
	MOV     AX,[CS:PROC_ID]		; SS override
	;cmp	[es:di+31h],ax
	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
	JNZ	short BadSFT		; must match process
	cmp	word [es:di],0
	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
	JZ	short BadSFT		; must also be in use
	;mov	al,[si+19h]
	MOV	AL,[SI+fcb_l_drive]
	;test	al,80h
	test	AL,FCBSPECIAL		; a special FCB?
	JZ	short CheckNoShare	; No. try local or device

	; Since we are a special FCB, try NOT to use a bogus test instruction.
	; FCBSHARE is a superset of FCBNETWORK.

	PUSH	AX
	;and	al,0C0h
	AND	AL,FCBMASK
	;cmp	al,0C0h
	CMP	AL,FCBSHARE		; net FCB?
	POP	AX
	JNZ	short CheckNet		; yes
;
;----- In share support -----
;
	; 26/07/2019
	call	far [cs:JShare+(11*4)]  ; 11 = ShChk
	;Call	far [ss:JShare+(11*4)]	; SS Override
	JC	short BadSFT
	JMP	SHORT CheckD
;
;----- End in share support -----
;
CheckFirClus:
	cmp     bx,[es:di+0Bh]
	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
	JNZ	short BadSFT
CheckD: 
	AND	AL,3Fh
	;mov	ah,[es:di+5]
	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
	AND	AH,3Fh
	CMP	AH,AL
	jz	short BlastSFT_retn	; carry is clear
BadSFT: 
	STC
	retn				; carry is clear
CheckNet:
;
;----- In net support -----
;
	; MSDOS 6.0
	;MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
	;CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
	;JNZ	short BadSFT

	; MSDOS 3.3
	;mov	ax,[si+1Ah]
	mov	ax,[si+fcb_net_handle]
	;cmp	ax,[es:di+1Dh]
	cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
	jnz	short BadSFT
	;cmp	ax,[es:di+19h]
	cmp	ax,[ES:DI+sf_netid]
	jnz     short BadSFT
	;mov	ax,[si+1Eh]
	mov	ax,[si+fcb_l_attr]
	;cmp	ax,[es:di+1Bh]
	cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
	jnz     short BadSFT
;
;----- END In net support -----
;
CheckNet_retn:
	retn

CheckNoShare:
	;test	al,40h
	test	AL,FCBDEVICE		; Device?
	JNZ	short CheckNoShareDev 	; Yes

	; MSDOS6.0
	; SR;
	; The code below to match a local FCB with its SFT can no longer be
	; used. We just return a no-match status. This check is done right
	; at the top.
	;

	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
	;mov	bx,[si+1Dh]
	MOV	BX,[SI+fcb_nsl_dirsec]
	;cmp	bx,[es:di+1Dh]
	cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
	jnz	short BadSFT
	;mov	bl,[si+1Fh]
	MOV	bl,[SI+fcb_nsl_dirpos]
	;cmp	bl,[es:di+1Fh]
	cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
	jnz     short BadSFT
	;mov	bl,[si+1Ah]
	MOV	bl,[SI+fcb_nsl_bits]
	;mov	bh,[es:di+5]
	MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
	xor     bh,bl
	and     bh,0C0h
	jnz     short BadSFT
	;xor	bl,[es:di+2]
	xor	bl,[ES:DI+SF_ENTRY.sf_mode]
	and     bl,0Fh
	jnz     short BadSFT
	push    di
	push    si
	;lea	di,[di+20h]  ; MSDOS 3.3
	LEA	DI,[DI+SF_ENTRY.sf_name]
	;lea	si,[si+1]
	LEA	SI,[SI+SYS_FCB.name]
	;mov	cx,11
	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
	repe	cmpsb
	pop     si
	pop     di
	jnz     short BadSFT
	;mov	bx,[si+1Bh]
	MOV	bX,[SI+fcb_nsl_firclus]
	jmp     short CheckFirClus

CheckNoShareDev:
	;mov	bx,[si+1Ah]
	MOV	BX,[SI+fcb_nsld_drvptr]
	;cmp	bx,[es:di+7]
	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
	JNZ	short BadSFT
	;mov	bx,[si+1Ch]
	MOV	BX,[SI+fcb_nsld_drvptr+2]
	;cmp	bx,[es:di+9]
	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
	JNZ	short BadSFT
	JMP	CheckD

;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
;----------------------------------------------------------------------------
;
;   SFTFromFCB - the workhorse of this compatability crap.  Check to see if
;	the SFT for the FCB is Good.  If so, make ThisSFT point to it.	If not
;	good, get one from the cache and regenerate it.  Overlay the LRU field
;	with PID
;
;   Inputs:	DS:SI point to FCB
;   Outputs:	ThisSFT point to appropriate SFT
;		Carry clear -> OK ES:DI -> SFT
;		Carry set -> error in ax
;   Registers modified: ES,DI, AX
;
;----------------------------------------------------------------------------

SFTFromFCB:

	; called from fcbio and $fcb_close. SS already set up to DOSDATA

	push	ax
	push	bx
	;mov	al,[si+18h]
	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
	call	CheckFCB
	pop	bx
	pop	ax
	MOV	[CS:THISSFT],DI		; SS override
	MOV	[CS:THISSFT+2],ES
	JNC	short Set_SFT		; no problems, just set thissft
	call	save_world
	call	FCBRegen
	call	restore_world		; use macro restore world
	MOV     AX,[CS:EXTERR]		; SS override
	jc	short CheckNet_retn

Set_SFT: 
	LES     DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
	PUSH    word [CS:PROC_ID]	; set process id
	;pop	word [es:di+31h]
	POP     word [ES:DI+SF_ENTRY.sf_PID]
	retn				; carry is clear

;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
;----------------------------------------------------------------------------
;
;   FCBHardErr - signal to a user app that he is trying to use an
;	unavailable FCB.
;
;   Inputs:	none.
;   Outputs:	none.
;   Registers modified: all
;
;----------------------------------------------------------------------------
;

FCBHardErr:
	;mov	ax,23h
	MOV	AX,error_FCB_unavailable
	;mov	byte [cs:ALLOWED],8
	MOV	byte [CS:ALLOWED],Allowed_FAIL
	LES	BP,[CS:THISDPB]
	MOV	DI,1			; Fake some registers
	MOV	CX,DI
	;mov	dx,[es:bp+0Bh]
	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
	call	HARDERR
	STC
	retn

;============================================================================
; FCBIO2.ASM, MSDOS 6.0, 1991
;============================================================================
; 21/07/2018 - Retro DOS v3.0

;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
;
;	GetRR
;	GetExtent
;	SetExtent
;	GetExtended
;	GetRecSize
;	FCBIO
;	$FCB_OPEN
;	$FCB_CREATE
;	$FCB_RANDOM_WRITE_BLOCK
;	$FCB_RANDOM_READ_BLOCK
;	$FCB_SEQ_READ
;	$FCB_SEQ_WRITE
;	$FCB_RANDOM_READ
;	$FCB_RANDOM_WRITE
;
;	Revision history:
;
;		Created: ARR 4 April 1983
;			 MZ  6 June  1983 completion of functions
;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
;				  times.  Change so successive closes work by
;				  always returning OK.	Also, detect I/O to
;				  already closed FCB and return EOF.
;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
;				  out of sft into FCB for reconnection
;
;	    A000   version 4.00	Jan. 1988

; Defintions for FCBOp flags

RANDOM	equ 2				; random operation
FCBREAD equ 4				; doing a read
BLOCK	equ 8				; doing a block I/O

;Break <GetRR - return the random record field in DX:AX>
;---------------------------------------------------------------------------
;
;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
;	from the FCB pointed to by DS:SI
;
;   Inputs:	DS:SI point to an FCB
;		BX has record size
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

GetRR:
	;mov	ax,[si+21h]
	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
	;mov	dx,[si+23h]
	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
	CMP	BX,64			; ignore MSB of RR if recsiz > 64
	JB	short GetRRBye
	XOR	DH,DH
GetRRBye:
	retn

;Break <GetExtent - retrieve next location for sequential IO>
;---------------------------------------------------------------------------
;
;   GetExtent - Construct the next record to perform I/O from the EXTENT and
;	NR fields in the FCB.
;
;   Inputs:	DS:SI - point to FCB
;   Outputs:	DX:AX contain the contents of the random record field
;   Registers modified: none
;---------------------------------------------------------------------------

GetExtent:
	;mov	al,[si+20h]
	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
	;mov	dx,[si+0Ch]
	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
	SHL	AL,1
	SHR	DX,1
	RCR	AL,1	; move low order bit of DL to high order of AH
	MOV	AH,DL
	MOV	DL,DH
	XOR	DH,DH
	retn

;Break <SetExtent - update the extent/NR field>
;---------------------------------------------------------------------------
;
;   SetExtent - change the position of an FCB by filling in the extent/NR
;	fields
;
;   Inputs:	DS:SI point to FCB
;		DX:AX is a record location in file
;   Outputs:	Extent/NR fields are filled in
;   Registers modified: CX
;---------------------------------------------------------------------------

SetExtent:
	push	ax
	push	dx
	MOV	CX,AX
	AND	AL,7FH			; next rec field
	;mov	[si+20h],al
	MOV	[SI+SYS_FCB.NR],AL
	AND	CL,80H			; save upper bit
	SHL	CX,1
	RCL	DX,1			; move high bit of CX to low bit of DX
	MOV	AL,CH
	MOV	AH,DL
	;mov	[si+0Ch], ax
	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
	pop	dx
	pop	ax
	retn

;Break <GetExtended - find FCB in potential extended fcb>
;---------------------------------------------------------------------------
;
;   GetExtended - Make DS:SI point to FCB from DS:DX
;
;   Inputs:	DS:DX point to a possible extended FCB
;   Outputs:	DS:SI point to the FCB part
;		zeroflag set if not extended fcb
;   Registers modified: SI
;---------------------------------------------------------------------------

GetExtended:
	MOV	SI,DX			; point to Something
	CMP	BYTE [SI],-1		; look for extention
	JNZ	short GetBye		; not there
	ADD	SI,7			; point to FCB
GetBye:
	CMP	SI,DX			; set condition codes
getextd_retn:
	retn

;Break <GetRecSize - return in BX the FCB record size>
;---------------------------------------------------------------------------
;
;   GetRecSize - return in BX the record size from the FCB at DS:SI
;
;   Inputs:	DS:SI point to a non-extended FCB
;   Outputs:	BX contains the record size
;   Registers modified: None
;---------------------------------------------------------------------------

GetRecSize:
	mov	bx,[si+0Eh]
	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
	OR	BX,BX			; is it nul?
	jz	short getextd_retn
	MOV	BX,128			; use default size
	;mov	[si+0Eh],bx
	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
	retn

;BREAK <FCBIO - do internal FCB I/O>
;---------------------------------------------------------------------------
;
;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
;
;   Inputs:	FCBOP flags which operations need to be performed
;		DS:DX point to FCB
;		CX may have count of number of records to xfer
;   Outputs:	AL has error code
;   Registers modified: all
;---------------------------------------------------------------------------

FCBIO:

FEOF	EQU	1
FTRIM	EQU	2

%define	FCBErr	byte [bp-1]  ; byte	
%define	cRec	word [bp-3]  ; word	
;%define RecPos	word [bp-7]  ; dword
%define RecPosL	word [bp-7]  ; word
%define RecPosH	word [bp-5]  ; word
%define	RecSize	word [bp-9]  ; word
;%define bPos	word [bp-13] ; dword
%define bPosL	word [bp-13] ; word
%define bPosH	word [bp-11] ; word
%define cByte	word [bp-15] ; word	
%define cResult word [bp-17] ; word	
%define	cRecRes	word [bp-19] ; word
%define	FCBOp	byte [bp-20] ; byte

	;Enter

	push	bp
	mov	bp,sp
	sub	sp,20
	;mov	[bp-20],al
	MOV	FCBOp,AL
	;mov	byte [bp-1],0
	MOV	FCBErr,0		;   FCBErr = 0;
	call	GetExtended		;   FCB = GetExtended ();
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
	JNZ	short GetPos
	MOV	CX,1			;	cRec = 1;
GetPos:
	;mov	[bp-3],cx
	MOV	cRec,CX 		;*Tail coalesce
	call	GetExtent		;   RecPos = GetExtent ();
	call	GetRecSize		;   RecSize = GetRecSize ();
	;mov	[bp-9],bx
	MOV	RecSize,BX
	;test	byte [bp-20],2
	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
	JZ	short GetRec
	call	GetRR			;	RecPos = GetRR ();
GetRec:
	;mov	[bp-7],ax
	MOV	RecPosL,AX		;*Tail coalesce
	;mov	[bp-5],dx
	MOV	RecPosH,DX
	call	SetExtent		;   SetExtent (RecPos);
	;mov	ax,[bp-5]
	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
	MUL	BX
	MOV	DI,AX
	;mov	ax,[bp-7]
	MOV	AX,RecPosL
	MUL	BX
	ADD	DX,DI
	;mov	[bp-13],ax
	MOV	bPosL,AX
	;mov	[bp-11],dx
	MOV	bPosH,DX
	;mov	ax,[bp-3]
	MOV	AX,cRec 		;   cByte = cRec * RecSize;
	MUL	BX
	;mov	[bp-15],ax
	MOV	cByte,AX

;hkn; 	SS override
	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
	ADC	DX,0
	JZ	short DoOper
	;mov	byte [bp-1],2
	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;

;hkn; 	SS override
	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
	NEG	AX
	JNZ	short DoDiv
	DEC	AX
DoDiv:
	XOR	DX,DX
	DIV	BX
	;mov	[bp-3],ax
	MOV	cRec,AX
	MUL	BX			;	cByte = cRec * RecSize;
	;mov	[bp-15],ax
	MOV	cByte,AX		;	}
DoOper:
	XOR	BX,BX
	;mov	[bp-17],bx
	MOV	cResult,BX		;   cResult = 0;
	;cmp	[bp-15],bx
	CMP	cByte,BX		;   if (cByte <> 0 ||
	JNZ	short DoGetExt
	;test	byte [bp-1],2
	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
	;JZ	short DoGetExt
	;JMP	short SkipOp
	jnz	short SkipOp
DoGetExt:
	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
	JNC	short ContinueOp
FCBDeath:
	call	FCB_RET_ERR		; signal error, map for extended
	;mov	word [bp-19],0
	MOV	cRecRes,0		; no bytes transferred
	;mov	byte [bp-1],1
	MOV	FCBErr,FEOF		;	    return FTRIM;
	JMP	FCBSave 		; bam!
ContinueOp:
	;mov	di,offset DOS_READ
	;test	byte [bp-14h],4
	;jnz	short DoContext
	;mov	di,DOS_WRITE

	;mov	ax,[si+10h]
	MOV	AX,[SI+SYS_FCB.FILSIZ]
	;mov	[es:di+11h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size],AX
	;mov	ax,[si+12h]
	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
	;mov	[es:di+13h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
	;mov	ax,[bp-13]
	MOV	AX,bPosL
	;mov	dx,[bp-11]
	MOV	DX,bPosH
	;mov	[es:di+15h],ax
	MOV	[ES:DI+SF_ENTRY.sf_position],AX
	;xchg	dx,[es:di+17h]
	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
	PUSH	DX			; save away Open age.
	;mov	cx,[bp-15]
	MOV	CX,cByte		;	cResult =

;hkn; DOS_Read is in DOSCODE
	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
	JNZ	short DoContext

;hkn; DOS_Write is in DOSCODE
	MOV	DI,DOS_WRITE
DoContext:
	push	bp
	push	ds
	push	si

;hkn; SS is DOSDATA
	push	ss
	pop	ds

;; Fix for disk full
	CALL	DI
	
	pop	si
	pop	ds
	pop	bp
	JC	short FCBDeath
	
	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
	JZ	short NODSKFULL
	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
	;mov	byte [bp-1],1 
	MOV	FCBErr,FEOF		; set disk full flag
NODSKFULL:
;; Fix for disk full
	;mov	[bp-17],cx
	MOV	cResult,CX
	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
	;pop	word [es:di+17h]	
	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
	;mov	ax,[es:di+11h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
	;mov	[si+10h],ax
	MOV	[SI+SYS_FCB.FILSIZ],AX
	;mov	ax,[es:di+13h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
	;mov	[si+12h],ax
	MOV	[SI+SYS_FCB.FILSIZ+2],AX
					;	}
SkipOp:
	;mov	ax,[bp-17]
	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
	XOR	DX,DX
	;div	word [bp-9]
	DIV	RecSize
	;mov	[bp-19],ax
	MOV	cRecRes,AX
	;add	[bp-7],ax
	ADD	RecPosL,AX		;   RecPos += cRecResult;
	;adc	word [bp-5],0
	ADC	RecPosH,0
;
; If we have not gotten the expected number of records, we signal an EOF
; condition.  On input, this is EOF.  On output this is usually disk full.
; BUT...  Under 2.0 and before, all device output IGNORED this condition.  So
; do we.
;
	;cmp	ax,[bp-3]
	CMP	AX,cRec 		;   if (cRecRes <> cRec)
	JZ	short TryBlank
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
	JNZ	short SetEOF
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	JNZ	short TryBlank
SetEOF:
	;mov	byte [bp-1],1
	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
TryBlank:				;
	OR	DX,DX			;   if (cResult%RecSize <> 0) {
	JZ	short SetExt
	;add	word [bp-7],1
	ADD	RecPosL,1		;	RecPos++;
	;adc	word [bp-5],0
	ADC	RecPosH,0
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
	JZ	short SetExt
	;inc	word [bp-19]
	INC	cRecRes 		;	cRecRes++;
	;mov	byte [bp-1],3
	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
	;mov	cx,[bp-9]
	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
	SUB	CX,DX			;	       DMA+cResult);
	XOR	AL,AL
;hkn; 	SS override
	les     di,[ss:DMAADD]
	;add	di,[bp-17]
	ADD	DI,cResult
	REP	STOSB			;   }	}
SetExt:
	;mov	dx,[bp-5]
	MOV	DX,RecPosH
	;mov	ax,[bp-7]
	MOV	AX,RecPosL
	;test	byte [bp-20],2
	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
	JZ	short DoSetExt
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
	JZ	short TrySetRR
DoSetExt:
	call	SetExtent		;	SetExtent (RecPos, FCB);
TrySetRR:
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	JZ	short TryReturn
	;mov	[si+21h],ax
	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
	;mov	[si+23h],dl
	MOV	[SI+SYS_FCB.RR+2],DL
	;cmp	word [si+0Eh],64
	CMP	word [SI+SYS_FCB.RECSIZ],64
	JAE	short TryReturn
	;mov	[si+24h],dh
	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
TryReturn: 
	;test	byte [bp-20],4
	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
	JNZ	short FCBSave
	push	ds			;	FCB->FDate = date;
	call	DATE16			;	FCB->FTime = time;
	pop	ds
	;mov	[si+14h],ax
	MOV	[SI+SYS_FCB.FDATE],AX
	;mov	[si+16h],dx
	MOV	[SI+SYS_FCB.FTIME],DX	;	}
FCBSave: 
	;test	byte [bp-20],8
	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
	jz	short DoReturn
	;mov	cx,[bp-19]
	MOV	CX,cRecRes		;	user_CX = cRecRes;
	call    Get_User_Stack
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
DoReturn:
	;mov	al,[bp-1]
	MOV	AL,FCBErr		;   return (FCBERR);
	;Leave	
	mov     sp,bp
	pop     bp
	retn

; 22/07/2018 - Retro DOS v3.0

;Break <$FCB_Open - open an old-style FCB>
;---------------------------------------------------------------------------
;
;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
;	for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;---------------------------------------------------------------------------

_$FCB_OPEN:			; System call 15

	MOV	AX,SHARING_COMPAT+open_for_both

;hkn; DOS_Open is in DOSCODE
	MOV	CX,DOS_OPEN
;
; The following is common code for Creation and openning of FCBs.  AX is
; either attributes (for create) or open mode (for open)...  DS:DX points to
; the FCB
;
DoAccess:
	pushj	ds
	push	dx
	push	cx
	push	ax			; save FCB pointer away

;hkn; 	OpenBuf is in DOSDATA
	MOV	DI,OPENBUF
	call	TransFCB		; crunch the fcb
	pop	ax
	pop	cx
	pop	dx
	pop	ds			; get fcb
	JNC	short FindFCB		; everything seems ok
FCBOpenErr:
;
; AL has error code
;
	jmp	FCB_RET_ERR
FindFCB:
	call	GetExtended		; DS:SI will point to FCB

	; MSDOS 6.0
	;push	ax
	;mov	al,1			;indicate Open/Create operation
	;call	LRUFCB			; get a sft entry (no error)
	;pop	ax
	;jc	short HardMessage
	
	; MSDOS 3.3
	call	LRUFCB
	JC	short HardMessage

	;mov	word [es:di+2],8000h
	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
	push	ds
	push	si
	push	bx			; save fcb pointer
	MOV	SI,CX

;hkn; SS is DOSDATA
	push	ss
	pop	ds			; let DOS_Open see variables
	CALL	SI			; go open the file
	pop	bx
	pop	si
	pop	ds			; get fcb

;hkn; SS override
	LES	DI,[SS:THISSFT]		; get sf pointer
	JNC	short FCBOK		; operation succeeded
failopen:
	PUSH	AX
	MOV	AL,"R"                  ; clear out field (free sft)
	call	BlastSFT
	POP	AX
	;cmp	ax,4
	CMP	AX,error_too_many_open_files
	JZ	short HardMessage
	;cmp	ax,24h
	CMP	AX,error_sharing_buffer_exceeded
	jnz	short DeadFCB
HardMessage:
	PUSH	AX
	call	FCBHardErr
	POP	AX
DeadFCB:
	jmp	FCB_RET_ERR
FCBOK:
	; MSDOS 6.0
	;call	IsSFTNet		       ;AN007;F.C. >32mb  Non Fat file?
	;JNZ	short FCBOK2		       ;AN007;F.C. >32mb  yes
	;call	CheckShare		       ;AN000;F.C. >32mb  share around?
	;JNZ	short FCBOK2		       ;AN000;F.C. >32mb  yes
;SR;
; If we reach here, we know we have got a local SFT. Let's update the 
; LocalSFT variable to reflect this.
;
	;mov	[cs:LocalSFT],di	;
	;mov	[cs:LocalSFT+2],es; Store the SFT address
;;SR;
;; The check below is not valid anymore since we regenerate for media > 32M.
;;
;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
;;					       ;AN000;F.C. >32mb  if dirsec >32mb
;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
;;	JMP	short failopen		       ;AN000;F.C. >32mb

FCBOK2:
	; MSDOS 3.3 (& MSDOS 6.0)
	inc	word [es:di]
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
	call	SaveFCBInfo
	; MSDOS 3.3
	call	SetOpenAge
	; MSDOS 3.3 (& MSDOS 6.0)
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	JNZ	short FCBNoDrive	; do not munge drive on devices
	MOV	AL,[SI]			; get drive byte
	call	GETTHISDRV		; convert
	INC	AL
	MOV	[SI],AL			; stash in good drive letter
FCBNoDrive:
	;mov	word [si+0Eh],128
	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size

	;mov	ax,[es:di+0Dh]
	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
	;mov	[si+16h],ax
	MOV	[SI+SYS_FCB.FTIME],AX
	;mov	ax,[es:di+0Fh]
	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
	;mov	[si+14h],ax
	MOV	[SI+SYS_FCB.FDATE],AX
	;mov	ax,[es:di+11h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
	;mov	[si+10h],ax
	MOV	[SI+SYS_FCB.FILSIZ],AX
	;mov	ax,[es:di+13h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
	;mov	[si+12h],ax
	MOV	[SI+SYS_FCB.FILSIZ+2],AX
	XOR	AX,AX			; convenient zero
	;mov	[si+0Ch],ax
	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
;
; We must scan the set of FCB SFTs for one that appears to match the current
; one.	We cheat and use CheckFCB to match the FCBs.
;

;hkn; 	SS override
	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
	;mov	ah,[es:di+4]
	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
OpenScan:
	;cmp	al,[si+18h]
	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
	JZ	short SkipCheck
	push	ax			; preserve count
	call	CheckFCB		; do they match
	pop	ax			; get count back
	JNC	short OpenFound		; found a match!
SkipCheck:
	INC	AL			; advance to next FCB
	CMP	AL,AH			; table full?
	JNZ	short OpenScan		; no, go for more
OpenDone:
	xor	al,al			; return success
	retn
;
; The SFT at ES:DI is the one that is already in use for this FCB. We set the
; FCB to use this one. We increment its ref count. We do NOT close it at all.
; Consider:
;
;   open (foo)	delete (foo) open (bar)
;
; This causes us to recycle (potentially) bar through the same local SFT as
; foo even though foo is no longer needed; this is due to the server closing
; foo for us when we delete it. Unfortunately, we cannot see this closure.
; If we were to CLOSE bar, the server would then close the only reference to
; bar and subsequent I/O would be lost to the redirector.
;
; This gets solved by NOT closing the sft, but zeroing the ref count
; (effectively freeing the SFT) and informing the sharer (if relevant) that
; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
; around.  This will allow us to access the same file through multiple network
; connections and NOT prematurely terminate when the ref count on one
; connection goes to zero.
;
OpenFound:
	;mov	[si+18h],al
	MOV	[SI+fcb_sfn],AL 	; assign with this
	inc	word [es:di]
	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] 
					; remember this new invocation
	MOV	AX,[SS:FCBLRU]		; update LRU counts
	;mov	[es:di+15h],ax
	MOV	[ES:DI+sf_LRU],AX
;
; We have an FCB sft that is now of no use.  We release sharing info and then
; blast it to prevent other reuse.
;
	push	ss
	pop	ds
	LES	DI,[THISSFT]
	dec	word [es:di]
	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
					; free the newly allocated SFT
	call	ShareEnd
	MOV	AL,'C'
	call	BlastSFT
	JMP	short OpenDone

;BREAK	<$FCB_Create - create a new directory entry>
;----------------------------------------------------------------------------
;
;   $FCB_Create - CPM compatability file create. The user has formatted an
;	FCB for us and asked to have the rest filled in.
;
;   Inputs:	DS:DX point to an unopenned FCB
;   Outputs:	AL indicates status 0 is ok FF is error
;		FCB has the following fields filled in:
;		    Time/Date Extent/NR Size
;----------------------------------------------------------------------------

_$FCB_CREATE:		; System call 22

;hkn; DOS_Create is in DOSCODE
	MOV	CX,DOS_CREATE		; routine to call
	XOR	AX,AX			; attributes to create
	call	GetExtended		; get extended FCB
	JZ	short DoAccessJ		; not an extended FCB
	MOV	AL,[SI-1]		; get attributes
DoAccessJ:
	JMP	DoAccess		; do dirty work

; 22/07/2018 - Retro DOS v3.0

;BREAK <$FCB_Random_write_Block - write a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
;	and write a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = 0 write was successful and the FCB position is updated
;		AL <> 0 Not enough room on disk for the output
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_WRITE_BLOCK:
	;mov	AL,0Ah	
	MOV	AL,RANDOM+BLOCK
	JMP	FCBIO

;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
;	and read a number of blocks from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_READ_BLOCK:
	;mov	AL,0Eh	
	MOV	AL,RANDOM+FCBREAD+BLOCK
	JMP	FCBIO

;BREAK <$FCB_Seq_Read - read the next record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
;	memory
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_SEQ_READ:
	;mov	AL,4	
	MOV	AL,FCBREAD
	JMP	FCBIO

;BREAK <$FCB_Seq_Write - write the next record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
;	file
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_SEQ_WRITE:
	MOV	AL,0
	jmp	FCBIO

;BREAK <$FCB_Random_Read - Read a single record from a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
;	record from it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_READ:
	;mov	AL,6	
	MOV	AL,RANDOM+FCBREAD
	jmp	FCBIO			; single block

;BREAK <$FCB_Random_Write - write a single record to a file >
;----------------------------------------------------------------------------
;
;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
;	a record to it.
;
;   Inputs:	DS:DX point to an FCB
;   Outputs:	AL = error codes defined above
;
;----------------------------------------------------------------------------

_$FCB_RANDOM_WRITE:
	;mov	AL,2	
	MOV	AL,RANDOM
	jmp	FCBIO

;============================================================================
; SEARCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 22/07/2018 - Retro DOS v3.0

;**	Search.asm
;
;	Directory search system calls.
;	These will be passed direct text of the pathname from the user. 
;	They will need to be passed through the macro expander prior to
;	being sent through the low-level stuff. 
;	I/O specs are defined in DISPATCH. The system calls are:
;
;	$Dir_Search_First	  written
;	$Dir_Search_Next	  written
;	$Find_First	  written
;	$Find_Next		  written
;	PackName		  written
;
;	Modification history:
;
;	  Created: ARR 4 April 1983

;----------------------------------------------------------------------------
; Procedure Name : $DIR_SEARCH_FIRST
;
; Inputs:
;	DS:DX Points to unopenned FCB
; Function:
;	Directory is searched for first matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h

_$DIR_SEARCH_FIRST:
	MOV	[SS:THISFCB],DX
	MOV	[SS:THISFCB+2],DS
	MOV	SI,DX
	CMP	BYTE [SI],0FFH
	JNZ	short NORMFCB4
	ADD	SI,7			; Point to drive select byte
NORMFCB4:
	push	word [SI]		; Save original drive byte for later

	push	ss
	pop	es			; get es to address DOSGroup

	MOV	DI,OPENBUF		; appropriate buffer
	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
	JNC	short SearchIt		; no error, go and look
	pop	bx			; Clean stack
;
; Error code is in AX
;
	jmp	FCB_RET_ERR		; error

SearchIt:
	push	ss
	pop	ds			; get ready for search
	push	word [DMAADD]
	push	word [DMAADD+2]
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	; MSDOS 6.0
	;call	GET_FAST_SEARCH 	; search
	; MSDOS 3.3
	call	DOS_SEARCH_FIRST
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JNC	short SearchSet		; no error, transfer info
	pop	bx			; Clean stack
;
; Error code is in AX
;
	jmp	FCB_RET_ERR

;
; The search was successful (or the search-next).  We store the information
; into the user's FCB for continuation.
;
SearchSet:
	MOV	SI,SEARCHBUF
	LES	DI,[THISFCB]		; point to the FCB
	TEST	byte [EXTFCB],0FFh		;
	JZ	short NORMFCB1
	ADD	DI,7			; Point past the extension
NORMFCB1:
	pop	bx			; Get original drive byte
	OR	BL,BL
	JNZ	short SearchDrv
	MOV	BL,[CURDRV]
	INC	BL
SearchDrv:
	LODSB				; Get correct search contin drive byte
	XCHG	AL,BL			; Search byte to BL, user byte to AL
	INC	DI
	;STOSB				; Store the correct "user" drive byte
					;  at the start of the search info
	MOV	CX,20/2
	REP	MOVSW			; Rest of search cont info, SI -> entry
	XCHG	AL,BL			; User drive byte back to BL, search
					;   byte to AL
	STOSB				; Search contin drive byte at end of
					;   contin info
	LES	DI,[DMAADD]
	TEST	byte [EXTFCB],0FFh
	JZ	short NORMFCB2
	MOV	AL,0FFh
	STOSB
	INC	AL
	MOV	CX,5
	REP	STOSB
	MOV	AL,[SATTRIB]
	STOSB
NORMFCB2:
	MOV	AL,BL			; User Drive byte
	STOSB
	MOV	CX,16			; 32 / 2 words of dir entry
	REP	MOVSW
	jmp	FCB_RET_OK

;----------------------------------------------------------------------------
;
; Procedure Name : $DIR_SEARCH_NEXT
;
; Inputs:
;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
; Function:
;	Directory is searched for the next matching entry and the directory
;	entry is loaded at the disk transfer address
; Returns:
;	AL = -1 if no entries matched, otherwise 0
;----------------------------------------------------------------------------

_$DIR_SEARCH_NEXT:
	MOV	[SS:THISFCB],DX
	MOV	[SS:THISFCB+2],DS
	MOV	byte [SS:SATTRIB],0
	MOV	byte [SS:EXTFCB],0

	push	ss
	pop	es

	MOV	DI,SEARCHBUF

	MOV	SI,DX
	CMP	BYTE [SI],0FFh
	JNZ	short NORMFCB6
	ADD	SI,6
	LODSB

	MOV	[SS:SATTRIB],AL
	DEC	byte [SS:EXTFCB]
NORMFCB6:
	LODSB				; Get original user drive byte
	push	ax			; Put it on stack
	MOV	AL,[SI+20]		; Get correct search contin drive byte
	STOSB				; Put in correct place
	MOV	CX,20/2
	REP	MOVSW			; Transfer in rest of search contin info

	push	ss
	pop	ds

	push	word [DMAADD]
	push	word [DMAADD+2]
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	call	DOS_SEARCH_NEXT 	; Find it
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JC	short SearchNoMore
	JMP	SearchSet		; Ok set return

SearchNoMore:
	LES	DI,[THISFCB]
	TEST	byte [EXTFCB],0FFh
	JZ	short NORMFCB8
	ADD	DI,7			; Point past the extension
NORMFCB8:
	pop	bx			; Get original drive byte
	MOV	[ES:DI],BL		; Store the correct "user" drive byte
					;  at the right spot
;
; error code is in AX
;
	jmp	FCB_RET_ERR

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_FIRST
; 
;   Assembler usage:
;	    MOV AH, FindFirst
;	    LDS DX, name
;	    MOV CX, attr
;	    INT 21h
;	; DMA address has datablock
;
;   Error Returns:
;	    AX = error_path_not_found
;	       = error_no_more_files
;---------------------------------------------------------------------------

_$FIND_FIRST:
	MOV	SI,DX			; get name in appropriate place
	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc

	MOV	DI,OPENBUF		; appropriate buffer

	call	TransPathSet		; convert the path
	JNC	short Find_it 		; no error, go and look
FindError:
	;mov	al,3
	mov	al, error_path_not_found ; error and map into one.
	jmp	SYS_RET_ERR
Find_it:
	push	ss
	pop	ds

	push	word [DMAADD]
	push	word [DMAADD+2]
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	; MSDOS 6.0
	;call	GET_FAST_SEARCH 	; search
	; MSDOS 3.3
	call	DOS_SEARCH_FIRST
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JNC	short FindSet 		; no error, transfer info
	jmp	SYS_RET_ERR

FindSet:
	MOV	SI,SEARCHBUF
	LES	DI,[DMAADD]
	MOV	CX,21
	REP	MOVSB
	PUSH	SI			; Save pointer to start of entry
	;mov	al,[si+0Bh]
	MOV	AL,[SI+dir_entry.dir_attr]
	STOSB
	;add	si,16h
	ADD	SI,dir_entry.dir_time
	MOVSW				; dir_time
	MOVSW				; dir_date
	INC	SI
	INC	SI			; Skip dir_first
	MOVSW				; dir_size (2 words)
	MOVSW
	POP	SI			; Point back to dir_name
 	CALL	PackName
	jmp	SYS_RET_OK		; bye with no errors

;---------------------------------------------------------------------------
;
;   Procedure Name : $FIND_NEXT
;
;   Assembler usage:
;	; dma points at area returned by find_first
;	    MOV AH, findnext
;	    INT 21h
;	; next entry is at dma
;
;   Error Returns:
;	    AX = error_no_more_files
;---------------------------------------------------------------------------

_$FIND_NEXT:
	push	ss
	pop	es

	MOV	DI,SEARCHBUF

	LDS	SI,[SS:DMAADD]

	MOV	CX,21
	REP	MOVSB			; Put the search continuation info
					;  in the right place
	push	ss
	pop	ds			; get ready for search
	
	push	word [DMAADD]
	push	word [DMAADD+2]
	MOV	WORD [DMAADD],SEARCHBUF
	MOV	WORD [DMAADD+2],DS
	call	DOS_SEARCH_NEXT 	; Find it
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	JNC	short FindSet 		; No error, set info
	jmp	SYS_RET_ERR

;---------------------------------------------------------------------------
;**	PackName - Convert file names from FCB to ASCIZ format.
;
;	PackName transfers a file name from DS:SI to ES:DI and converts it to
;	the ASCIZ format.
;
;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
;		(ES:DI) = destination area (13 bytes)
;	EXIT	(ds:SI) and (es:DI) advanced
;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
;---------------------------------------------------------------------------

PackName:
;	Move over 8 characters to cover the name component, then trim it's
;	trailing blanks.

	MOV	CX,8			; Pack the name
	REP	MOVSB			; Move all of it
main_kill_tail:
	CMP	BYTE [ES:DI-1]," "
	JNZ	short find_check_dot
	DEC	DI			; Back up over trailing space
	INC	CX
	CMP	CX,8
	JB	short main_kill_tail
find_check_dot:
	;CMP	WORD [SI],(" " << 8) | " "
	cmp     word [si],2020h 
	JNZ	short got_ext 		; Some chars in extension
	CMP	BYTE [SI+2]," "
	JZ	short find_done		; No extension
got_ext:
	MOV	AL,"."
	STOSB
	MOV	CX,3
	REP	MOVSB
ext_kill_tail:
	CMP	BYTE [ES:DI-1]," "
	JNZ	short find_done
	DEC	DI			; Back up over trailing space
	JMP	short ext_kill_tail
find_done:
	XOR	AX,AX
	STOSB				; NUL terminate
	retn

;GET_FAST_SEARCH:
;	; 22/07/2018
;	; MSDOS 6.0
;	OR	word [DOS34_FLAG],SEARCH_FASTOPEN 
;					;FO.trigger fastopen ;AN000;
;	call	DOS_SEARCH_FIRST
;	retn


;============================================================================
; PATH.ASM, MSDOS 6.0, 1991
;============================================================================
; 06/08/2018 - Retro DOS v3.0

;**	Directory related system calls. These will be passed direct text of the
;	pathname from the user. They will need to be passed through the macro
;	expander prior to being sent through the low-level stuff. I/O specs are
;	defined in DISPATCH. The system calls are:
;
;	$CURRENT_DIR  Written
;	$RMDIR	  Written
;	$CHDIR	  Written
;	$MKDIR	  Written
;
;
;	Modification history:
;
;	    Created: ARR 4 April 1983
;		 MZ 10 May 1983     CurrentDir implemented
;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
;				    current directory.
;		 MZ 19 Jan 1983     Brain damaged applications rely on success

;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
;	I_Need	OpenBuf,128		; temp spot for translated name
;	I_need	fSplice,BYTE		; TRUE => do splice
;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
;	I_Need	cMeta,BYTE
;	I_Need	DrvErr,BYTE					;AN000;


;BREAK <$CURRENT_DIR - dump the current directory into user space>
;---------------------------------------------------------------------------
;
;   Procedure Name : $CURRENT_DIR
;
;   Assembler usage:
;		LDS	SI,area
;		MOV	DL,drive
;		INT	21h
;	    ; DS:SI is a pointer to 64 byte area that contains drive
;	    ; current directory.
;   Error returns:
;	    AX = error_invalid_drive
;
;---------------------------------------------------------------------------

_$CURRENT_DIR:
	;06/08/2018 - Retro DOS v3.0
	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
	call	EcritDisk
	MOV	AL,DL			; get drive number (0=def, 1=A)
	call	GetVisDrv		; grab it
	JNC	short CurrentValidate 	; no error -> go and validate dir
CurdirErr:
	call	LcritDisk
	
	; MSDOS 6.0
	;MOV	AL,[CS:DrvErr]		;IFS.			;AN000;

	; MSDOS 3.3
	mov	al,0Fh

curdir_errj:
	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;

CurrentValidate:
	push	ds		; save destination
	push	si
	LDS	SI,[CS:THISCDS]
	;TEST	word [SI+curdir.flags],curdir_isnet
	;JNZ	short DoCheck
; Random optimization nuked due to some utilities using GetCurrentDir to do
; media check.
;	CMP	word [SI+curdir.ID],0
;	JZ	short GetDst
DoCheck:
	MOV	byte [cs:NoSetDir],0	; interested only in contents

	MOV	DI,OPENBUF

	call	ValidateCDS		; output is ES:DI -> CDS
	push	es	 		; swap source and destination
	push	di
	pop	si
	pop	ds
GetDst:
	pop	di
	pop	es			; get real destination
	JC	short CurdirErr
	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
	ADD	SI,[SI+curdir.end]
	CMP	BYTE [SI],'\'		; root or subdirs present?
	JNZ	short CurrentCopy
	INC	SI
CurrentCopy:
;	call	FStrCpy
;; 10/29/86 E5 char
	PUSH	AX
	LODSB				; get char
	OR	AL,AL
	JZ	short FOK
	CMP	AL,05
	JZ	short FCHANGE
	JMP	short FFF
FCPYNEXT:
	LODSB				; get char
FFF:
	CMP	AL,'\'			; beginning of directory
	JNZ	short FOK		; no
	STOSB				; put into user's buffer
	LODSB				; 1st char of dir is 05?
	CMP	AL,05H
	JNZ	short FOK		; no
FCHANGE:
	MOV	AL,0E5H			; make it E5
FOK:
	STOSB				; put into user's buffer
	OR	AL,AL			; final char
	JNZ	short FCPYNEXT		; no
	POP	AX

;; 10/29/86 E5 char
	xor	AL,AL			; MZ 19 Jan 84
	call	LcritDisk
	jmp	SYS_RET_OK		; no more, bye!


;BREAK <$RmDir -- Remove a directory>
;---------------------------------------------------------------------------
;
; Procedure Name : $RmDir
;
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Delete directory if empty
; Returns:
;	STD XENIX Return
;	AX = error_path_not_found If path bad
;	AX = error_access_denied If
;		Directory not empty
;		Path not directory
;		Root directory specified
;		Directory malformed (. and .. not first two entries)
;		User tries to delete a current directory
;	AX = error_current_directory
;
;----------------------------------------------------------------------------

_$RMDIR:
	push	dx			; Save ptr to name
	push	ds
	mov	si,dx			; Load ptr into si
	mov	di,OPENBUF		; di = ptr to buf for trans name
	push	di
	call	TransPathNoSet		; Translate the name
	pop	di			; di = ptr to buf for trans name
	jnc	short rmlset		; If transpath succeeded, continue
	pop	ds
	pop	dx			; Restore the	 name
	mov	al,error_path_not_found ; Otherwise, return an error
	;jmp	short curdir_errj
rmdir_errj: ; 10/08/2018
	jmp	SYS_RET_ERR
rmlset:
	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
	Jnz	short rmerr		;	return (-1);
	push	ss
	pop	es
	xor	al,al			; al = 0 , ie drive a:
rmloop: 
	call	GetCDSFromDrv		; Get curdir for drive in al
	jc	short rmcont		; If error, exit loop & cont normally
	call	StrCmp			; Are the 2 paths the same?
	jz	short rmerr		; Yes, report error.
	inc	al			; No, inc al to next drive number
	jmp	short rmloop		; Go check next drive.
rmerr:
	pop	ds
	pop	dx			; Restore the name
	mov	al,error_current_directory ;  error
	;jmp	short curdir_errj
	jmp	short rmdir_errj
rmcont:
	pop	ds
	pop	dx			; Restore the name
	MOV	SI,DOS_RMDIR
	JMP	short DoDirCall ; 07/09/2018

;BREAK <$ChDir -- Change current directory on a drive>
;----------------------------------------------------------------------------
;
; $ChDir - Top-level change directory system call.  This call is responsible
; for setting up the CDS for the specified drive appropriately.  There are
; several cases to consider:
;
;   o	Local, simple CDS.  In this case, we take the input path and convert
;	it into a WFP.	We verify the existance of this directory and then
;	copy the WFP into the CDS and set up the ID field to point to the
;	directory cluster.
;   o	Net CDS.  We form the path from the root (including network prefix)
;	and verify its existance (via DOS_Chdir).  If successful, we copy the
;	WFP back into the CDS.
;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
;	call TransPath, we will get the PHYSICAL CDS that the path refers to
;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
;	good for the validation but not for currency.  We call TransPathNoSet
;	to process the path but to return the logical CDS and the logical
;	path.  We then copy the logical path into the logical CDS.
;
; Inputs:
;	DS:DX Points to asciz name
; Returns:
;	STD XENIX Return
;	AX = chdir_path_not_found if error
;
;----------------------------------------------------------------------------

_$CHDIR:
	MOV	DI,OPENBUF		; spot for translated name
	MOV	SI,DX			; get source
	call	TransPath		; go munge the path and get real CDS
	JNC	short ChDirCrack	; no errors, try path
ChDirErrP:
	MOV	AL,error_path_not_found
ChDirErr:
	jmp	SYS_RET_ERR 	; oops!

ChDirCrack:
	CMP	byte [CMETA],-1		; No meta chars allowed.
	JNZ	short ChDirErrP
;
; We cannot do a ChDir (yet) on a raw CDS.  This is treated as a path not
; found.
;
	LES	DI,[THISCDS]
	CMP	DI,-1			;   if (ThisCDS == NULL)
	JZ	short ChDirErrP		;	error ();
 ;
 ; Find out if the directory exists.
 ;
	call	DOS_CHDIR
	Jc	short ChDirErr
;
; Get back CDS to see if a join as seen.  Set the currency pointer (only if
; not network).  If one was seen, all we need to do is copy in the text
;
	LES	DI,[THISCDS]
	TEST	word [ES:DI+curdir.flags],curdir_splice
	JZ	short GotCDS
;
; The CDS was joined.  Let's go back and grab the logical CDS.
;
	push	es	
	push	di
	push	cx			; save CDS and cluster...
	call	Get_User_Stack		; get original text
	MOV	DI,[SI+user_env.user_DX]
	MOV	DS,[SI+user_env.user_DS]
	MOV	SI,OPENBUF		; spot for translated name
	XCHG	SI,DI
	XOR	AL,AL			; do no splicing
	push	di
	call	TransPathNoSet		; Munge path
	pop	si
;
; There should NEVER be an error here.
;

;IF FALSE
;	JNC SKipErr
;	fmt <>,<>,<"$p: Internal CHDIR error\n">
;SkipErr:
;ENDIF
	LES	DI,[THISCDS]		; get new CDS
	MOV	word [ES:DI+curdir.ID],-1
					; no valid cluster here...
	pop	cx
	pop	di
	pop	es
;
; ES:DI point to the physical CDS, CX is the ID (local only)
;
GotCDS:
;
; wfp_start points to the text. See if it is long enough
;
	; MSDOS 3.3
	;push	ss
	;pop	ds
	;mov	si,[WFP_START]
	;push	cx
	;call	DStrLen
	;cmp	cx,67 ; cmp cx,DIRSTRLEN
	;pop	cx
	;ja	short ChDirErrP

	; MSDOS 6.0
	CALL	Check_PathLen		;PTM.		;AN000;
	JA	short ChDirErrP
	; MSDOS 3.3 (& MSDOS 6.0)
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JNZ	short SkipRecency
	; MSDOS 6.0
	;TEST	word [ES:DI+curdir.flags],curdir_splice 
	;				;PTM. for Join and Subst ;AN000;
	;JZ	short setdirclus	;PTM.		;AN000;
	;MOV	CX,-1			;PTM.		;AN000;
;setdirclus:
	MOV	[ES:DI+curdir.ID],CX
	LES	DI,[THISCDS]		; get logical CDS
SkipRecency:
	call	FStrCpy
	XOR	AL,AL
mkdir_ok:
	jmp	SYS_RET_OK


;BREAK <$MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : $MkDir
; Inputs:
;	DS:DX Points to asciz name
; Function:
;	Make a new directory
; Returns:
;	STD XENIX Return
;	AX = mkdir_path_not_found if path bad
;	AX = mkdir_access_denied  If
;		Directory cannot be created
;		Node already exists
;		Device name given
;		Disk or directory(root) full
;---------------------------------------------------------------------------

_$MKDIR:
	MOV	SI,DOS_MKDIR
DoDirCall:
	MOV	DI,OPENBUF		; spot for translated name

	push	si
	MOV	SI,DX			; get source
	call	TransPath		; go munge the path
	pop	si
	JNC	short MkDirCrack	; no errors, try path
MkErrP:
	MOV	AL,error_path_not_found	; oops!
MkErr:
	jmp	SYS_RET_ERR
MkDirCrack:
	CMP	byte [SS:CMETA],-1
	JNZ	short MkErrP

	; MSDOS 3.3
	;push	ss
	;pop	ds
	;call	si
	;jb	short MkErr
	;;jmp	short mkdir_ok
	;jmp	SYS_RET_OK

	; MSDOS 6.0
	PUSH	SI			;PTM.			;AN000;
	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
	POP	SI			;PTM.			;AN000;
	JBE	short pathok		;PTM.			;AN000;
	MOV	AL,error_access_denied	;PTM. ops!
	;jmp	SYS_RET_ERR		;PTM.
	jmp	short MkErr
pathok:
	CALL	SI			; go get file
	JC	short MkErr		; no errors
	;jmp	short mkdir_ok
	jmp	SYS_RET_OK

;----------------------------------------------------------------------------
;
; Procedure Name : Check_PathLen
;
; Inputs:
;	nothing
; Function:
;	check if final path length greater than 67
; Returns:
;	Above flag set if > 67
;
;---------------------------------------------------------------------------

Check_PathLen:
	; 09/09/2018
	;;MOV	SI,[WFP_START]
	;MOV	SI,[SS:WFP_START] ; MSDOS 6.0
;check_PathLen2:
	push	ss
	pop	ds
	mov	SI,[WFP_START] ; MSDOS 3.3
	push	CX	
	CALL	DStrLen
	CMP	CX,DIRSTRLEN
	POP	CX
	retn

;============================================================================
; IOCTL.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/08/2018 - Retro DOS v3.0

;**	IOCTL system call.
;
;	$IOCTL
;
;	  Revision history:
;
;		Created: ARR 4 April 1983
;
;		GenericIOCTL added:		KGS	22 April 1985
;
;		A000	version 4.00	Jan. 1988
;
;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
;

;BREAK <IOCTL - munge on a handle to do device specific stuff>
;---------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, Handle
;	    MOV     DX, Data
;
;	(or LDS     DX,BUF
;	    MOV     CX,COUNT)
;
;	    MOV     AH, Ioctl
;	    MOV     AL, Request
;	    INT     21h
;
;   AH = 0  Return a combination of low byte of sf_flags and device driver
;	    attribute word in DX, handle in BX:
;	    DH = high word of device driver attributes
;	    DL = low byte of sf_flags
;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
;	    in BX.
;	 2  Read CX bytes from the device control channel for handle in BX
;	    into DS:DX.  Return number read in AX.
;	 3  Write CX bytes to the device control channel for handle in BX from
;	    DS:DX.  Return bytes written in AX.
;	 4  Read CX bytes from the device control channel for drive in BX
;	    into DS:DX.  Return number read in AX.
;	 5  Write CX bytes to the device control channel for drive in BX from
;	    DS:DX.  Return bytes written in AX.
;	 6  Return input status of handle in BX. If a read will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 7  Return output status of handle in BX. If a write will go to the
;	    device, AL = 0FFh, otherwise 0.
;	 8  Given a drive in BX, return 1 if the device contains non-
;	    removable media, 0 otherwise.
;	 9  Return the contents of the device attribute word in DX for the
;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
;	    network. 8000h is the bit for local use.
;	 A  Return 8000h if the handle in BX is for the network or not.
;	 B  Change the retry delay and the retry count for the system. BX is
;	    the count and CX is the delay.
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_invalid_data
;
;-------------------------------------------------------------------------------
;
;   This is the documentation copied from DOS 4.0 it is much better
;   than the above
;
;	There are several basic forms of IOCTL calls:
;
;
;	** Get/Set device information:	**
;
;	ENTRY	(AL) = function code
;		  0 - Get device information
;		  1 - Set device information
;		(BX) = file handle
;		(DX) = info for "Set Device Information"
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = info for "Get Device Information"
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Handle  **
;
;	ENTRY	(AL) = function code
;		  2 - Read device control info
;		  3 - Write device control info
;		(BX) = file handle
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Read/Write Control Data From/To Block Device  **
;
;	ENTRY	(AL) = function code
;		  4 - Read device control info
;		  5 - Write device control info
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;		(CX) = transfer count
;		(DS:DX) = address for data
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = count of bytes transfered
;	USES	ALL
;
;
;	**  Get Input/Output Status  **
;
;	ENTRY	(AL) = function code
;		  6 - Get Input status
;		  7 - Get Output Status
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AL) = 00 if not ready
;		  (AL) = FF if ready
;	USES	ALL
;
;
;	**  Get Drive Information  **
;
;	ENTRY	(AL) = function code
;		  8 - Check for removable media
;		  9 - Get device attributes
;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (AX) = 0/1 media is removable/fixed (func. 8)
;		  (DX) = device attribute word (func. 9)
;	USES	ALL
;
;
;	**  Get Redirected bit	**
;
;	ENTRY	(AL) = function code
;		  0Ah - Network stuff
;		(BX) = file handle
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DX) = SFT flags word, 8000h set if network file
;	USES	ALL
;
;
;	**  Change sharer retry parameters  **
;
;	ENTRY	(AL) = function code
;		  0Bh - Set retry parameters
;		(CX) = retry loop count
;		(DX) = number of retries
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;	USES	ALL
;
;
;   =================================================================
;
;	**  New Standard Control  **
;
;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
;	FORMS ARE OBSOLETE.
;
;   =================================================================
;
;	ENTRY	(AL) = function code
;		  0Ch - Control Function subcode
;		(BX) = File Handle
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (SI) = Return value, meaning is function dependent
;		  (DI) = Return value, meaning is function dependent
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;    ============== Generic IOCTL Definitions for DOS 3.2 ============
;     (See inc\ioctl.inc for more info)
;
;	ENTRY	(AL) = function code
;		  0Dh - Control Function subcode
;		(BL) = Drive Number (0 = Default, 1= 'A')
;		(CH) = Category Indicator
;		(CL) = Function within category
;		(DS:DX) = address for data, if any
;		(SI) = Passed to device as argument, use depends upon function
;		(DI) = Passed to device as argument, use depends upon function
;
;	EXIT	'C' set if error
;		  (AX) = error code
;		'C' clear if OK
;		  (DS:DX) = Return address, use is function dependent
;	USES	ALL
;
;---------------------------------------------------------------------------
	
	; MSDOS 6.0
IOCTLJMPTABLE:	;label	word
	; MSDOS 3.3 (& MSDOS 6.0)
	dw	ioctl_getset_data	; 0
	dw	ioctl_getset_data   	; 1
	dw	ioctl_control_string	; 2
	dw	ioctl_control_string	; 3
	dw	ioctl_get_dev		; 4
	dw	ioctl_get_dev		; 5
	dw	ioctl_status		; 6
	dw	ioctl_status		; 7
	dw	ioctl_rem_media		; 8
	dw	Ioctl_Drive_attr	; 9
	dw	IOCTL_Handle_Redir	; A
	dw	Set_Retry_Parameters	; B
	dw	GENERICIOCTLHANDLE	; C
	dw	GENERICIOCTL		; D
	; MSDOS 6.0 (& MSDOS 3.3)
	dw	ioctl_drive_owner	; E
	dw	ioctl_drive_owner	; F
	; MSDOS 6.0
	;dw	query_handle_support	; 10h
	;dw	query_device_support	; 11h

_$IOCTL:
	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
	push	ss
	pop	ds			;hkn; SS is DOSDATA

	; MSDOS 3.3
	cmp	al,0Fh 
	; MSDOS 6.0
	;cmp	al,11h			; al must be between 0 & 11h
	ja	short ioctl_bad_funj2	; if not bad function #

	; 09/09/2018
	;push	AX			; Need to save AL for generic IOCTL
	mov	di,ax			; di NOT a PARM
	and	di,0FFh			; di = al
	shl	di,1			; di = index into jmp table
	;pop	AX			; Restore AL for generic IOCTL

	jmp	word [CS:DI+IOCTLJMPTABLE]


ioctl_bad_funj2:
	JMP	ioctl_bad_fun  ; 10/08/2018

;--------------------------------------------------------------------------
;
; IOCTL: AL= 0,1
;
; ENTRY : DS = DOSDATA
;
;---------------------------------------------------------------------

ioctl_getset_data:
	; MSDOS 6.0
	call	SFFromHandle		; ES:DI -> SFT
	JNC	short ioctl_check_permissions ; have valid handle
ioctl_bad_handle:
	mov	al,error_invalid_handle
ioctl_error:
	jmp	SYS_RET_ERR

ioctl_check_permissions:
	CMP	AL,0
	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
	JZ	short ioctl_read	; read the byte

	or	dh, dh
	JZ	short ioctl_check_device ; can I set with this data?
	mov	al,error_invalid_data	; no DH <> 0
	;jmp	SYS_RET_ERR
	jmp	short ioctl_error

ioctl_check_device:
	test	AL,devid_device 	; can I set this handle?
	jz	short ioctl_bad_funj2
	OR	DL,devid_device 	; Make sure user doesn't turn off the
					;   device bit!! He can muck with the
					;   others at will.
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags

ioctl_ok:
	jmp	SYS_RET_OK

ioctl_read:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	XOR	AH,AH
	test	AL,devid_device 	; Should I set high byte
	JZ	short ioctl_no_high	; no
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
ioctl_no_high:
	MOV	DX,AX
	call	Get_User_Stack
	MOV	[SI+user_env.user_DX],DX
	;;jmp	SYS_RET_OK
	;jmp	short ioctl_ok
	; 26/07/2019
	jmp	SYS_RET_OK_clc

;--------------------------------------------------------------------------
;
; IOCTL: 2,3
;
; ENTRY : DS = DOSDATA
;	  SI = user's DS
;
;--------------------------------------------------------------------------

ioctl_control_string:

	call	SFFromHandle		; ES:DI -> SFT
	JC	short ioctl_bad_handle	; invalid handle
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
	jz	short ioctl_bad_funj2			; No it is a file
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
	XOR	BL,BL			; Unit number of char dev = 0
	JMP	ioctl_do_string

;--------------------------------------------------------------------------
;
; IOCTL: AL = 6,7
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

ioctl_status:

	MOV	AH,1
	SUB	AL,6			; 6=0,7=1
	JZ	short ioctl_get_status
	MOV	AH,3
ioctl_get_status:
	PUSH	AX
	call	GET_IO_SFT
	POP	AX
	JNC	short DO_IOFUNC
	JMP	short ioctl_bad_handle	; invalid SFT

DO_IOFUNC:
	call	IOFUNC
	MOV	AH,AL
	MOV	AL,0FFH
	JNZ	short ioctl_status_ret
	INC	AL
ioctl_status_ret:
	jmp	SYS_RET_OK

;------------------------------------------------------------------------
;
; IOCTL: AL = B
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

Set_Retry_Parameters:
	; 09/09/2018
	MOV	[RetryLoop],CX		; 0 retry loop count allowed
	OR	DX,DX			; zero retries not allowed
	JZ	short ioctl_bad_fun
	MOV	[RetryCount],DX		; Set new retry count
doneok:
	jmp	SYS_RET_OK		; Done

;--------------------------------------------------------------------------
;
; Generic IOCTL entry point. AL = C, D, 10h, 11h
;
;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
;	SI:DX -> Users Device Parameter Table
;	IOCALL -> IOCTL_Req structure
;
; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
;	call.
;
; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;----------------------------------------------------------------------------

query_handle_support:	; Entry point for handles
GENERICIOCTLHANDLE:

	call	SFFromHandle		; Get SFT for device.
	jc	short ioctl_bad_handlej

	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
	jnz	short ioctl_bad_fun	; Cannot do this over net.

	mov	byte [EXTERR_LOCUS],errLOC_SerDev
	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
	jmp	short Do_GenIOCTL

query_device_support:	; Entry point for devices:
GENERICIOCTL:

	mov	byte [EXTERR_LOCUS],errLOC_Disk
	cmp	ch,IOC_DC		; Only disk devices are allowed to use
	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.

	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
	JNZ	short ioctl_bad_fun	; There are no "net devices", and they

Do_GenIOCTL:
	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 ; Can device handle Generic IOCTL funcs
	; 09/09/2018
	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
	jz	short ioctl_bad_fun

	; MSDOS 6.0
	;mov	byte [IOCALL_REQFUNC],GENIOCTL ;Assume real Request
	;cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
	;jl	short SetIOCtlBlock
	;
	;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
	;jz	short ioctl_bad_fun	; No support for query 
	;
	;mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)

;SetIOCtlBlock:
	PUSH	ES			; DEVIOCALL2 expects Device header block
	PUSH	DI			; in DS:SI
					; Setup Generic IOCTL Request Block
	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size
	; 07/09/2018 (MSDOS 3.3)
	;mov	byte [IOCALL_REQFUNC],19
	mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
	;
	MOV	byte [IOCALL_REQUNIT],BL
	MOV	byte [IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
	MOV	byte [IOCALL+IOCTL_REQ.MINORFUNCTION],CL
	MOV	word [IOCALL+IOCTL_REQ.REG_SI],SI
	MOV	word [IOCALL+IOCTL_REQ.REG_DI],DI
	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI

;hkn; IOCALL is in DOSDATA
	MOV	BX,IOCALL

	PUSH	SS
	POP	ES
					; DS:SI -> Device header.
	POP	SI
	POP	DS
	; 10/08/2018
	jmp	ioctl_do_IO		; Perform Call to device driver

ioctl_bad_fun:
	mov	al, error_invalid_function
	jmp	SYS_RET_ERR	

ioctl_bad_handlej:
	jmp	ioctl_bad_handle

;---------------------------------------------------------------------------
;
; IOCTL AL = 8
;
; ENTRY:  DS = DOSDATA
;
; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ioctl_rem_media:
	; MSDOS 3.3 (& MSDOS 6.0)
	CALL	Check_If_Net
	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
	JZ	short ioctl_bad_fun		; NO

;hkn; SS override for IOCALL
	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD
	MOV	AL,REMHL
	MOV	AH,BL			; Unit number
	MOV	[SS:IOCALL_REQLEN],AX
	XOR	AX,AX
	MOV	[SS:IOCALL_REQSTAT],AX
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

;hkn; IOCALL is in DOSDATA (msconst.asm)
	MOV	BX,IOCALL		; ES:BX -> Call header
	push	ds
	push	si
	call	DEVIOCALL2
	pop	si
	pop	ds

;hkn; SS override
	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
	AND	AX,STBUI		; Mask to busy bit
	MOV	CL,9
	SHR	AX,CL			; Busy bit to bit 0
	jmp	SYS_RET_OK

;-------------------------------------------------------------------------
;
; IOCTL: AL = 9
;
; ENTRY: DS = DOSDATA
;
;-------------------------------------------------------------------------

Ioctl_Drive_attr:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	al, bl
	call	GETTHISDRV
	jc	short ioctl_drv_err
	call	Get_Driver_BL
	; MSDOS 6.0
	JC	short ioctl_drv_err	; drive not valid

	mov	dx,[es:di+SYSDEV.ATT]	
					; get device attribute word
	MOV	BL,AL			; Phys letter to BL (A=0)

;hkn; SS override
	LES	DI,[SS:THISCDS]
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JZ	short IOCTLShare

	;or	dx,1000h ; msdos 3.3

;	Net devices don't return a device attribute word.
;	Bit 12 = 1, meaning net device, all others = 0.

	MOV	DX,1000h ;  MSDOS 6.0
IOCTLShare:
	push	ss
	pop	ds
	MOV	SI,OPENBUF
	ADD	BL,"A"
	MOV	[SI],BL
	MOV	WORD [SI+1],003AH ; ":",0
	MOV	AX,0300h
	CLC
	;INT	int_IBM
	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
			; DS:SI -> ASCIZ disk device name (may be full path or only drive
			; specifier--must include the colon)
			; Return: CF clear if absolute disk access allowed
	JNC	short IOCTLLocal	; Not shared
	OR	DX,0200H		; Shared, bit 9
IOCTLLocal:
	TEST	word [ES:DI+curdir.flags],curdir_local
	JZ	short ioctl_set_DX
	OR	DX,8000h
ioctl_set_DX:
	call	Get_User_Stack
	MOV	[SI+user_env.user_DX],DX
	;jmp	SYS_RET_OK
	; 26/07/2019
	jmp	SYS_RET_OK_clc

ioctl_drv_err:
	mov	al, error_invalid_drive
	jmp	SYS_RET_ERR

;--------------------------------------------------------------------------
; IOCTL: AL = A
;
; ENTRY: DS = DOSDATA
;
;--------------------------------------------------------------------------

IOCTL_Handle_Redir:
	call	SFFromHandle		; ES:DI -> SFT
	JNC	short ioctl_got_sft	; have valid handle
	jmp	ioctl_bad_handle ; 10/08/2018

ioctl_got_sft:
	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
	JMP	short ioctl_set_DX	; pass dx to user and return

ioctl_bad_funj:
	JMP	ioctl_bad_fun

;--------------------------------------------------------------------------
;
; IOCTL: AL= 4,5
;
; ENTRY: DS = DOSDATA
;	 SI = user's DS
;
;
; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;-------------------------------------------------------------------------

ioctl_get_dev:
	CALL	Check_If_Net
	JNZ	short ioctl_bad_funj	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
ioctl_do_string:
	TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
	JZ	short ioctl_bad_funj		; NO
					; assume IOCTL read
	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL

	TEST	AL,1			; is it func. 4/5 or 2/3
	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call

					; it is an IOCTL write
	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL

ioctl_control_call:
	MOV	AL,DRDWRHL
ioctl_setup_pkt:
	MOV	AH,BL			; Unit number
	MOV	[IOCALL_REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL_REQSTAT],AX
	MOV	[IOMED],AL
	MOV	[IOSCNT],CX
	MOV	[IOXAD],DX
	MOV	[IOXAD+2],SI
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES

	MOV	BX,IOCALL		; ES:BX -> Call header
ioctl_do_IO:
	call	DEVIOCALL2

;hkn; SS override for IOCALL
	TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
	JNZ	short ioctl_string_err

;hkn; SS override
	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
	jmp	SYS_RET_OK

ioctl_string_err:
	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
device_err:
	AND	DI,STECODE		; mask out irrelevant bits
	MOV	AX,DI
	call	SET_I24_EXTENDED_ERROR

;hkn; use SS override
;hkn;	mov	ax,[CS:EXTERR]
	mov	ax,[SS:EXTERR]
	jmp	SYS_RET_ERR

;--------------------------------------------------------------------------
; Proc name : Get_Driver_BL
;
;	DS is DOSDATA
;	BL is drive number (0=default)
;	Returns pointer to device in ES:DI, unit number in BL if carry clear
;	No regs modified
;
;---------------------------------------------------------------------------

Get_Driver_BL:
	PUSH	AX
	MOV	AL,BL			; Drive
	call	GETTHISDRV
	jc	short ioctl_bad_drv
	XOR	BL,BL			; Unit zero on Net device
	MOV	byte [EXTERR_LOCUS],errLOC_Net
	LES	DI,[THISCDS]
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	LES	DI,[ES:DI+curdir.devptr]; ES:DI -> Dpb or net dev
	JNZ	short got_dev_ptr	; Is net
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
got_dev_ptr:
	CLC
ioctl_bad_drv:
	POP	AX
	retn

;-------------------------------------------------------------------------
; Proc Name : Check_If_Net:
;
;
; Checks if the device is over the net or not. Returns result in ZERO flag.
; If no device is found, the return address is popped off the stack, and a
; jump is made to ioctl_drv_err.
;
; On Entry:
; Registers same as those for Get_Driver_BL
;
; On Exit:
; ZERO flag	- set if not a net device
;		- reset if net device
; ES:DI -> the device
;
;
; BUGBUG: This function assumes the following stack setup on entry
;
;	  SP+2 -> Error return address
;	  SP   -> Normal return address
;
;-------------------------------------------------------------------------

Check_If_Net:
	; MSDOS 3.3 (& MSDOS 6.0)
	CALL	Get_Driver_BL
	JC	short ioctl_drv_err_pop	; invalid drive letter
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	POP	DI
	POP	ES
	retn

ioctl_drv_err_pop:
	pop	ax			; pop off return address
	jmp	ioctl_drv_err

ioctl_bad_funj3:
	jmp	ioctl_bad_fun

ioctl_string_errj:
	jmp	ioctl_string_err

;--------------------------------------------------------------------------
;
; IOCTL: AL = E, F
;
; ENTRY: DS = DOSDATA
;
;
; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
;         the call to Check_If_Net because Check_If_Net gets our
;         return address off the stack if the drive is invalid.
;
;--------------------------------------------------------------------------

ioctl_drive_owner:
	; MSDOS 3.3 (& MSDOS 6.0)
	Call	Check_If_Net
	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
					;   certainly don't know how to do this
					;   call.
	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
	; 09/09/2018
	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
	JZ	short ioctl_bad_funj3 	; NO
	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
	cmp	al,0Eh			; Get Owner ?
	jz	short GetOwner
SetOwner:
	MOV	byte [IOCALL_REQFUNC],DEVSETOWN
GetOwner:
	MOV	AL,OWNHL
	MOV	AH,BL			; Unit number
	MOV	[IOCALL_REQLEN],AX
	XOR	AX,AX
	MOV	[IOCALL_REQSTAT],AX
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> driver
	PUSH	SS
	POP	ES
	MOV	BX,IOCALL		; ES:BX -> Call header
	push	ds
	push	si
	call	DEVIOCALL2
	pop	si
	pop	ds
;hkn; SS override
	TEST	word [SS:IOCALL_REQSTAT],STERR
	jnz	short ioctl_string_errj
	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
					; owner returned is 1-based.
	jmp	SYS_RET_OK

;============================================================================
; DELETE.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/08/2018 - Retro DOS v3.0

;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
;	NAME	DOS_DELETE

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	DELETE.ASM - Low level routine for deleting files
;
;		DOS_DELETE
;		REN_DEL_Check
;		FastOpen_Delete	       ; DOS 3.3
;		FastOpen_Update	       ; DOS 3.3


;   Revision history:
;
;   A000  version 4.00	Jan. 1988
;   A001  Fastopen Rename fix	April 1989


;Installed = TRUE

;	i_need	NoSetDir,BYTE
;	i_need	Creating,BYTE
;	i_need	DELALL,BYTE
;	i_need	THISDPB,DWORD
;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	i_need	CURBUF,DWORD
;	i_need	ATTRIB,BYTE
;	i_need	SATTRIB,BYTE
;	i_need	WFP_START,WORD
;	i_need	REN_WFP,WORD			 ;BN001
;	i_need	NAME1,BYTE			 ;BN001
;	i_need	FoundDel,BYTE
;	i_need	AUXSTACK,BYTE
;	i_need	VOLCHNG_FLAG,BYTE
;	i_need	JShare,DWORD
;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
;	i_need	FastTable,BYTE			  ; DOS 4.00
;
;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
;
;	i_need	SAVE_BX,WORD			  ; DOS 4.00
;	i_need	DMAADD,DWORD
;	i_need	RENAMEDMA,BYTE

;---------------------------------------------------------------------------
;
; Procedure Name : DOS_DELETE
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Delete the specified file(s)
; Outputs:
;	CARRY CLEAR
;		OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to delete device or directory
;		***error_sharing_violation***
;			Deny both access required, generates an INT 24.
;			This error is NOT returned. The INT 24H is generated,
;			  and the file is ignored (not deleted). Delete will
;			  simply continue on looking for more files.
;			  Carry will NOT be set in this case.
; DS preserved, others destroyed
;
;---------------------------------------------------------------------------

FILEFOUND   equ 01h
FILEDELETED equ 10h

DOS_DELETE:

;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
;hkn; appropriately at this point.

	call	TestNet
	JNC	short LOCAL_DELETE

;IF NOT Installed
;	transfer NET_DELETE
;ELSE
	;MOV	AX,(MultNET SHL 8) | 19
	;INT	2FH
	;return

	mov	ax,1113h
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
			; SS = DS = DOS CS, SDA first filename pointer -> 
			;		fully-qualified filename in DOS CS
			; SDA CDS pointer -> current directory structure for drive with file
			; Return: CF set on error
	retn

;ENDIF

LOCAL_DELETE:
	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
	call	EcritDisk
	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
	MOV	SI,[WFP_START]
SKPNUL:
	LODSB
	OR	AL,AL
	JNZ	short SKPNUL		; go to end
	SUB	SI,4			; Back over possible "*.*"
	CMP	WORD [SI],2E2Ah ; "*."
	JNZ	short TEST_QUEST
	CMP	BYTE [SI+2],"*"
	JZ	short CHECK_ATTS
TEST_QUEST:
	SUB	SI,9		; Back over possible "????????.???"
	XCHG	DI,SI

	push	ss
	;pop	ds ; ! Retro DOS v3.0 BUG !
	pop	es ; 17/05/2019 (BugFix)

	MOV	AX,"??"
	MOV	CX,4		; four sets of "??"
	REPE	SCASW
	JNZ	short NOT_ALL
	XCHG	DI,SI
	LODSW
	CMP	AX,3F2Eh ; ".?"
	JNZ	short NOT_ALL
	LODSW
	CMP	AX,"??"
	JNZ	short NOT_ALL
CHECK_ATTS:
	MOV	AL,[SATTRIB]
	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; Look only at hidden bits
	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
					; All must be set
	JNZ	short NOT_ALL

; NOTE WARNING DANGER-----
;    This DELALL stuff is not safe. It allows directories to be deleted.
;	It should ONLY be used by FORMAT in the ROOT directory.

	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
NOT_ALL:
	MOV	byte [NoSetDir],1
	call	GetPathNoSet
	JNC	short Del_found
	JNZ	short _bad_path
	OR	CL,CL
	JZ	short _bad_path
No_file:
	MOV	AX,error_file_not_found
ErrorReturn:
	STC
	call	LcritDisk
	retn

_bad_path:
	MOV	AX,error_path_not_found
	JMP	short ErrorReturn

Del_found:
	JNZ	short NOT_DIR		; Check for dir specified
	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
	JZ	short NOT_DIR
Del_access_err:
	MOV	AX,error_access_denied
	JMP	short ErrorReturn

NOT_DIR:
	OR	AH,AH			; Check if device name
	JS	short Del_access_err	; Can't delete I/O devices

; Main delete loop. CURBUF+2:BX points to a matching directory entry.

DELFILE:
	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet

; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
; DOS issue a build BPB call the next time this drive is accessed.

	PUSH	DS
	MOV	AH,[DELALL]
	LDS	DI,[CURBUF]
	
;hkn; SS override
	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
	JNZ	short DoDelete		; yes

	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
	JZ	short DoDelete		; not read only

	POP	DS
	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)

DoDelete:
	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
	JNC	short DEL_SHARE_OK
	POP	DS
	JMP	SHORT DELNXT		; Skip it

DEL_SHARE_OK:
	; MSDOS 6.0
	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty 
	;				;LB. if already dirty		  ;AN000;
	;JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
;yesdirty:
	MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
	MOV	BX,[SI] 		; Get firclus pointer
	POP	DS
	OR	byte [FOUNDDEL],FILEDELETED ; Deleted file

	CMP	BX,2
	JB	short DELNXT		; File has invalid FIRCLUS (too small)
	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	JA	short DELNXT		; File has invalid FIRCLUS (too big)

	call	RELEASE 		; Free file data
	JC	short No_fileJ

; DOS 3.3  FastOpen

	CALL	FastOpen_Delete 	; delete the dir info in fastopen

; DOS 3.3  FastOpen

DELNXT:
	LES	BP,[THISDPB]		; Possible to get here without this set
	call	GETENTRY		; Registers need to be reset
	JC	short No_fileJ
	call	NEXTENT
	JNC	short DELFILE
	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
	;MOV	AL,[ES:BP+DPB.DRIVE]
	MOV	AL,[ES:BP]
	call	FLUSHBUF
	JC	short No_fileJ
;
; Now we need to test FoundDel for our flags. The cases to consider are:
;
;   not found not deleted		file not found
;   not found	  deleted		*** impossible ***
;	found not deleted		access denied (read-only)
;	found	  deleted		no error
;
	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
	JZ	short DelError		; no, figure out what's wrong.
; We set VOLCHNG_FLAG to indicate that we have changed the volume label
; and to force the DOS to issue a media check.
	TEST	byte [ATTRIB],attr_volume_id
	jz	short No_Set_Flag
	PUSH	AX
	PUSH	ES
	PUSH	DI
	LES	DI,[THISCDS]
	MOV	AH,[ES:DI]		; Get drive
	SUB	AH,'A'                  ; Convert to 0-based
	mov	[VOLCHNG_FLAG],AH
	
	; MSDOS 6.0
	;XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
	;call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
	 
	call	FATREAD_CDS		; force media check
	POP	DI
	POP	ES
	POP	AX
No_Set_Flag:
	call	LcritDisk		; carry is clear
	retn
DelError:
	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
	JNZ	short Del_access_errJ 	; yes. Access denied
No_fileJ:
	JMP	No_file ; 10/08/2018 		; Nope
Del_access_errJ:
	JMP	Del_access_err ; 10/08/2018

; 08/08/2018 - Retro DOS v3.0

;Break	<REN_DEL_Check - check for access for rename and delete>
;---------------------------------------------------------------------------
; Procedure Name : REN_DEL_Check
;
; Inputs:
;	[THISDPB] set
;	[CURBUF+2]:BX points to entry
;	[CURBUF+2]:SI points to firclus field of entry
;	[WFP_Start] points to name
; Function:
;	Check for Exclusive access on given file.
;	  Used by RENAME, SET_FILE_INFO, and DELETE.
; Outputs:
;	ES:BP = [THISDPB]
;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
;		last element will be loaded from the directory entry.  This is
;		so the name given to the sharer doesn't have any meta chars in
;		it.
;	Carry set if sharing violation, INT 24H generated
;	    NOTE THAT AX IS NOT error_sharing_violation.
;		This is because input AX is preserved.
;		Caller must set the error if needed.
;	Carry clear
;		OK
; AX,DS,BX,SI,DI preserved
;---------------------------------------------------------------------------

REN_DEL_Check:

	PUSH	DS
	PUSH	DI
	PUSH	AX
	PUSH	BX
	PUSH	SI		; Save CURBUF pointers
	
	push	ss
	pop	es

;hkn; context ES will assume ES to DOSDATA
;hkn; ASSUME	ES:DOSGROUP

;hkn; SS override
	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
	MOV	SI,BX

;hkn; SS override
	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
	MOV	BX,DI		; Set backup limit for skipback
	ADD	BX,2		; Skip over d: to point to leading '\'
	call	StrLen		; CX is length of ES:DI including NUL
	DEC	CX		; Don't include nul in count
	ADD	DI,CX		; Point to NUL at end of string
	call	SkipBack	; Back up one element
	INC	DI		; Point to start of last element

;hkn; SS override
	; MSDOS 6.0
	;MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
	;
	call	PackName	; Transfer name from entry to ASCIZ tail.
	POP	SI		; Get back entry pointers
	POP	BX
	PUSH	BX
	PUSH	SI		; Back on stack
	
	push	ss
	pop	ds

;hkn; context DS will assume ES to DOSDATA
;hkn; ASSUME	DS:DOSGROUP

;
; Close the file if possible by us.
;
;if installed
	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
;else
;	Call	ShCloseFile
;endif
	MOV	[THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size
				; Scratch space
	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
	call	DOOPEN		; Fill in SFT for share check
	LES	DI,[THISSFT]
	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH
				; requires exclusive access
	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
	mov	word [ES:DI],1
	call	ShareEnter
	jc	short CheckDone
	LES	DI,[THISSFT]
	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
	mov	word [ES:DI],0	; Pretend closed and free
	
	call	ShareEnd	; Tell sharer we're done with THISSFT
	CLC
CheckDone:
	LES	BP,[THISDPB]
	POP	SI
	POP	BX
	POP	AX
	POP	DI
	POP	DS
	retn

;Break	<FastOpen_Delete - delete dir info in fastopen>
;---------------------------------------------------------------------------
; Procedure Name : FastOpen_Delete
; Inputs:
;	None
; Function:
;	Call FastOpen to delete the dir info.
; Outputs:
;	None
;---------------------------------------------------------------------------

FastOpen_Delete:
	PUSHF			; save flag
	PUSH	SI		; save registers
	PUSH	BX
	PUSH	AX
;hkn; SS override
	MOV	SI,[WFP_START]	; ds:si points to path name
	MOV	AL,FONC_delete	; al = 3
fastinvoke:
;hkn; FastTable is in DOSDATA
	MOV	BX,FastTable+2
	CALL	far [BX]	; call fastopen
	POP	AX		; restore registers
	POP	BX
	POP	SI
	POPF			; restore flag
	retn

;Break	<FastOpen_Update - update dir info in fastopen>
;---------------------------------------------------------------------------
; Procedure Name : FastOpen_Update
;
; Inputs:
;	DL     drive number (A=0,B=1,,,)
;	CX     first cluster #
;	AH     0 updates dir entry
;	       1 updates CLUSNUM , BP = new CLUSNUM
;	ES:DI  directory entry
; Function:
;	Call FastOpen to update the dir info.
; Outputs:
;	None
;---------------------------------------------------------------------------

FastOpen_Update:
	PUSHF			; save flag
	PUSH	SI
	PUSH	BX		; save regs
	PUSH	AX
	MOV	AL,FONC_update	; al = 4
	JMP	short fastinvoke

;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
;---------------------------------------------------------------------------
; PROCEDURE Name : FastOpen_Rename
;
; Inputs:
;	 REN_WFP   = Path Name
;	 NAME1	   = New Name
; Function:
;	Call FastOpen to rename the dir entry in the cache
; Outputs:
;	None
;---------------------------------------------------------------------------

FastOpen_Rename:
	; 08/08/2018 - Retro DOS v3.0
	; MSDOS 6.0
	;PUSHF			;AN001 save flag
	;PUSH	SI		;AN001 save registers
	;PUSH	DI		;AN001
	;PUSH	BX		;AN001
	;PUSH	AX		;AN001
	;
;hkn; SS override
	;;MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
	;
	; ? - 08/08/2018 - Retro DOS v3.0
	;push	ss
	;pop	ds
	;mov	si,[REN_WFP]
	;
;hkn; NAME1 is in DOSDATA
	;MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
	;MOV	AL,FONC_Rename	;;AN001  al = 6
	;
;hkn; FastTable is in DOSDATA
	;MOV	BX,FastTable+2
	;CALL	far [BX]	;;AN001  call fastopen
	;
	;POP	AX		; restore registers  ;AN001
	;POP	BX				     ;AN001
	;POP	DI				     ;AN001
	;POP	SI				     ;AN001
	;POPF			; restore flag	     ;AN001
	;retn					     ;AN001

	; MSDOS 6.0
;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
Fast_Dispatch:
;hkn; FastTable is in DOSDATA
	;MOV	SI,FastTable+2	; index to the	     ;AN000;
;hkn; use SS override
	;CALL	far [SS:SI]	; RMFD call fastopen
	;retn

;============================================================================
; RENAME.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
;	NAME	DOS_RENAME

;**	Low level routine for renaming files
;
;	DOS_RENAME
;
;	Modification history:
;
;	    Created: ARR 30 March 1983

;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RENAME
;
; Inputs:
;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
;		chars, NUL terminated)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Rename the specified file(s)
;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
; Outputs:
;	CARRY CLEAR
;	    OK
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			No match for source, or dest path invalid
;		error_not_same_device
;			Source and dest are on different devices
;		error_access_denied
;			Directory specified (not simple rename),
;			Device name given, Destination exists.
;			NOTE: In third case some renames may have
;			 been done if metas.
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;			SOURCE ONLY
;		error_bad_curr_dir
;			Bad path in current directory part of path
;			SOURCE ONLY
;		error_sharing_violation
;			Deny both access required, generates an INT 24.
; DS preserved, others destroyed
;
;----------------------------------------------------------------------------

DOS_RENAME:

;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
;hkn; at this point to DOSDATA.

	call	TestNet
	JNC	short LOCAL_RENAME

;IF NOT Installed
;	transfer NET_RENAME
;ELSE
	;MOV	AX,(MultNET SHL 8) OR 17
	;INT	2FH
	;return

	mov     ax, 1111h
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
			; SS = DS = DOS CS, 
			; SDA first filename pointer = offset of fully-qualified old name
			; SDA CDS pointer -> current directory
			; Return: CF set on error
	retn
;ENDIF

LOCAL_RENAME:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	MOV	SI,[WFP_START]
	MOV	DI,[REN_WFP]
	MOV	AL,[SI]
	MOV	AH,[DI]
	OR	AX,2020H		; Lower case
	CMP	AL,AH
	JZ	short SAMEDRV
	MOV	AX,error_not_same_device
	STC
	retn

SAMEDRV:
	PUSH	WORD [DMAADD+2]
	PUSH	WORD [DMAADD]
	MOV	[DMAADD+2],DS

;hkn; RENAMEDMA is in DOSDATA
	MOV	WORD [DMAADD],RENAMEDMA
	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
	call	EcritDisk
	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
					;    points to entry
	JNC	short Check_Dev
	CMP	AX,error_no_more_files
	JNZ	short GOTERR
	MOV	AX,error_file_not_found
GOTERR:
	STC
RENAME_POP:
	POP	WORD [DMAADD]
	POP	WORD [DMAADD+2]
	call	LcritDisk
	retn

Check_Dev:
	MOV	AX,error_access_denied	; Assume error
	;
	; MSDOS 6.0
	;PUSH	DS			      ;PTM.			    ;AN000;
	;LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
	;!?;ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
	;!?;TEST byte [SI+dir_entry.dir_attr],attr_directory  ;PTM.	    ;AN000;
	;JZ	short notdir		      ;PTM.			    ;AN000;
	;MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
	;call	Check_Pathlen2		      ;PTM.   length < 67	    ;AN000;
;notdir:
	;POP	DS			      ;PTM.			    ;AN000;
	;JA	short GOTERR		      ;PTM.			    ;AN000;
	;
	; MSDOS 3.3 (& MSDOS 6.0)
	CMP	byte [FOUND_DEV],0
	JNZ	short GOTERR
; At this point a source has been found. There is search continuation info (a
; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
; directory entry found.
; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
; throughout the RENAME since it is known at this point that the source and
; destination are both on the same device.
; [SATTRIB] is also set.
	MOV	SI,BX
	ADD	SI,dir_entry.dir_first
	call	REN_DEL_Check
	JNC	short REN_OK1
	MOV	AX,error_sharing_violation
	JMP	short RENAME_POP

;------------------------------------------------------------------------------
; Check if the source is a file or directory. If file, delete the entry
; from the Fastopen cache. If directory, rename it later
;------------------------------------------------------------------------------
REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	; MSDOS 6.0
	;PUSH	SI
	;LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
	;!?;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		   ;AN000;
	;!?;TEST byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.   ;AN000;
	;JZ	short NOT_DIR1		;;BN00XPTM.			   ;AN000;
	;POP	SI			;BN00X
	;JMP	SHORT SWAP_SOURCE	;BN00X
	;
;NOT_DIR1:				;;BN00X it is a file, delete the entry
	;POP	SI
	;
	; MSDOS 3.3 (& MSDOS 6.0)	
	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3

;SWAP_SOURCE:
	; MSDOS 3.3
	;MOV	SI,[REN_WFP]
	;MOV	[WFP_START],SI
	; MSDOS 6.0
	MOV	AX,[WFP_START]		; Swap source and destination
	MOV	SI,[REN_WFP]		; Swap source and destination
	MOV	[WFP_START],SI		; WFP_START = Destination path
	MOV	[REN_WFP],AX		; REN_WFP   = Source path
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	word [CURR_DIR_END],-1	; No current dir on dest
	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
					; A rename is like a CREATE_NEW as far
					; as the destination is concerned.
	call	GetPathNoSet
;   If this GETPATH fails due to file not found, we know all renames will work
;   since no files match the destination name. If it fails for any other
;   reason, the rename fails on a path not found, or whatever (also fails if
;   we find a device or directory). If the GETPATH succeeds, we aren't sure
;   if the rename should fail because we haven't built an explicit name by
;   substituting for the meta chars in it. In this case the destination file
;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
;   in the directory entry part.
	JC	short NODEST
	;; MSDOS 6.0
	;; JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
	; !! MSDOS 3.3 !!
	JZ	short BAD_ACC ; !!	; Dest string is a directory
	;
	OR	AH,AH			; Device?
	JNS	short SAVEDEST		; No, continue
BAD_ACC:
	MOV	AX,error_access_denied
	STC
RENAME_CLEAN:
	PUSHF				; Save carry state
	PUSH	AX			; and error code (if carry set)
	MOV	AL,[THISDRV]
	call	FLUSHBUF
	POP	AX
	CMP	byte [FAILERR],0
	JNZ	short BAD_ERR		; User FAILed to I 24
	POPF
	JMP	short RENAME_POP

BAD_ERR:
	POP	AX			; Saved flags
	MOV	AX,error_path_not_found
	JMP	short GOTERR

NODEST:
	JNZ	short BAD_PATH
	CMP	byte [FAILERR],0
	JNZ	short BAD_PATH	; Search for dest failed because user FAILed on
				;	I 24
	OR	CL,CL
	JNZ	short SAVEDEST
BAD_PATH:
	MOV	AX,error_path_not_found
	STC
	JMP	short RENAME_POP

SAVEDEST:
	push	ss
	pop	es

;hkn; NAME1 & NAME2 is in DOSDATA
	MOV	DI,NAME2
	MOV	SI,NAME1

	MOV	CX,11
	REP	MOVSB			; Save dest with metas at NAME2
	MOV	AX,[DIRSTART]
	MOV	[DESTSTART],AX
BUILDDEST:
	push	ss
	pop	es			; needed due to JMP BUILDDEST below

;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
	MOV	BX,RENAMEDMA+21		; Source of replace chars
	MOV	DI,NAME1		; Real dest name goes here
	MOV	SI,NAME2		; Raw dest

	MOV	CX,11
	
	; MSDOS 6.0
	;CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;

	; MSDOS 3.3

; 08/08/2018 - Retro DOS v3.0
; MSDOS 6.0 
;---------------------------------------------------------------------------
;Procedure: NEW_RENAME
;
;Input: DS:SI -> raw string with ?
;	ES:DI -> destination string
;	DS:BX -> source string
;Function: replace ? chars of raw string with chars in source string and
;	   put in destination string
;Output: ES:DI-> new string
;---------------------------------------------------------------------------

NEW_RENAME:
NEWNAM:
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
	LODSB
	CMP	AL,"?"
	JNZ	short NOCHG
	MOV	AL,[BX] 		; Get replace char
NOCHG:
	STOSB
	INC	BX			; Next replace char
	LOOP	NEWNAM
	; MSSOS 6.0
	;retn

	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
	MOV	byte [CREATING],0FFH
	call	DEVNAME 		; Check if we built a device name
	JNC	short BAD_ACC
	MOV	BX,[DESTSTART]
	LES	BP,[THISDPB]
	call	SETDIRSRCH		; Reset search to start of dir
	JC	short BAD_ACC 		; Screw up
	call	FINDENTRY		; See if new name already exists
	JNC	short BAD_ACC 		; Error if found
	CMP	byte [FAILERR],0
	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
	MOV	AX,[DESTSTART]		; DIRSTART of dest
	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
	JZ	short SIMPLE_RENAME	; If =, just give new name

	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
	TEST	AL,attr_directory
	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
					; otherwise the . and .. entries get
					; wiped.
	MOV	[ATTRIB],AL
	MOV	[THISSFT+2],DS

;hkn; AUXSTACK is in DOSDATA
	MOV	SI,AUXSTACK-SF_ENTRY.size
	MOV	[THISSFT],SI
	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
	XOR	CX,CX			; Set "device ID" for call into makenode
	call	RENAME_MAKE		; This is in mknode
	JNC	short GOT_DEST
BAD_ACCJ:
	JMP	BAD_ACC

GOT_DEST:
	push	bx
	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
	call	ShareEnd		; we need to remove it.
	pop	bx
; A zero length entry with the correct new name has now been made at
;   [CURBUF+2]:BX.
	LES	DI,[CURBUF]

	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
	;				;LB. if already dirty		  ;AN000;
	;JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
;yesdirty:
	MOV	DI,BX
	ADD	DI,dir_entry.dir_attr	; Skip name

;hkn; RENAMEDMA is in DOSDATA
	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
	MOV	CX,dir_entry.size-dir_entry.dir_attr ; mov cx,21
	REP	MOVSB
	CALL	GET_SOURCE
	JC	short RENAME_OVER
	MOV	DI,BX
	MOV	ES,[CURBUF+2]
	MOV	AL,DIRFREE
	STOSB				; "free" the source
	JMP	SHORT DIRTY_IT

SIMPLE_RENAME:
	CALL	GET_SOURCE		; Get the source back
	JC	short RENAME_OVER
	MOV	DI,BX
	MOV	ES,[CURBUF+2]

;hkn; NAME1 is in DOSDATA
	MOV	SI,NAME1		; New Name
	MOV	CX,11
	REP	MOVSB
DIRTY_IT:
	MOV	DI,[CURBUF]

	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
	;				;LB. if already dirty		  ;AN000;
	;JNZ	short Yesdirty2		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
;------------------------------------------------------------------------------
; Check if the source is a directory of file. If directory rename it to the
; the new name in the Fastopen cache buffer.  If file name it has been
; previously deleted.
;------------------------------------------------------------------------------
;Yesdirty2:
	; MSDOS 6.0
	;PUSH	SI
	;LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
	;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
	;TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
	;JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
	;call	FASTOPEN_RENAME		;;BN00X rename dir entry in fastopen
	;POP	SI
	;JMP	SHORT NOT_DIRTY1
;NOT_DIR2:				;;BN00X it is a file, delete the entry
	;POP	SI
;NOT_DIRTY1:				;;BN00X
NEXT_SOURCE:
;hkn; RENAMEDMA is in DOSDATA
	MOV	SI,RENAMEDMA+1		;Name
;
; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
; to enter it before going to RENAME_Next.
;
	call	EcritDisk
	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
				  ;  to FF when we made the prev new file).
	call	RENAME_NEXT
;
; Note, now, that we have exited the previous ENTER and so are back to where
; we were before.
;
	JC	short RENAME_OVER
	LEA	SI,[BX+dir_entry.dir_first]
	call	REN_DEL_Check
	JNC	short REN_OK2
	MOV	AX,error_sharing_violation
	JMP	RENAME_CLEAN ; 10/08/2018

;------------------------------------------------------------------------------
; Check if file or directory. If file, delete file from the Fastopen cache,
; if directory, rename directory name in the Fastopen cache.
;-----------------------------------------------------------------------------
REN_OK2:
	; MSDOS 6.0
	;MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
	;TEST	AL,attr_directory	;;BN00X directory
	;JZ	short Ren_Directory	;;BN00X no - file, delete it
	
	; MSDOS 3.3 (& MSDOS 6.0)
	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
	JMP	BUILDDEST		;;BN00X

	; MSDOS 6.0
;Ren_Directory:
	;call	FASTOPEN_RENAME 	;;BN00X delete dir info in fastopen DOS 3.3
	;JMP	BUILDDEST

RENAME_OVER:
	CLC
	JMP	RENAME_CLEAN ; 10/08/2018

;----------------------------------------------------------------------------
; Procedure: GET_SOURCE
;
; Inputs:
;	RENAMEDMA has source info
; Function:
;	Re-find the source
; Output:
;	[CURBUF] set
;	[CURBUF+2]:BX points to entry
;	Carry set if error (currently user FAILed to I 24)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

GET_SOURCE:
	MOV	BX,[RENAMEDMA+15]	; DirStart
	LES	BP,[THISDPB]
	call	SETDIRSRCH
	JC	short gs_ret_label	; retc
	call	STARTSRCH
	MOV	AX,[RENAMEDMA+13]	; Lastent
	call	GETENT

gs_ret_label:
	retn

;============================================================================
; FINFO.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;**	Low level routines for returning file information and setting file
;	attributes
;
;	GET_FILE_INFO
;	SET_FILE_ATTRIBUTE
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	M025: Return access_denied if attempting to set
;	      attribute of root directory.
;

;SUBTTL GET_FILE_INFO -- Get File Information

;---------------------------------------------------------------------------
; Procedure Name : GET_FILE_INFO
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
; Function:
;	Get Information about a file
; Returns:
;	CARRY CLEAR
;	    AX = Attribute of file
;	    CX = Time stamp of file
;	    DX = Date stamp of file
;	    BX:DI = Size of file (32 bit)
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------

GET_FILE_INFO:

;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	call	TestNet
	JNC	short LOCAL_INFO

;IF NOT Installed
;	transfer NET_GET_FILE_INFO
;ELSE
;	MOV	AX,(MultNET SHL 8) OR 15
;	INT	2FH
;	return

	mov     ax, 110Fh
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = file attributes
	retn
;ENDIF

LOCAL_INFO:
	call	EcritDisk
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	; MSDOS 6.0
	;call	Get_FAST_PATH
	; MSDOS 3.3
	call	GETPATH
info_check:
	JNC	short info_check_dev
NO_PATH:
	JNZ	short bad_path1
	OR	CL,CL
	JZ	short bad_path1
info_no_file:
	MOV	AX,error_file_not_found
BadRet:
	STC
JustRet:
	call	LcritDisk
	retn

bad_path1:
	MOV	AX,error_path_not_found
	jmp	short BadRet

info_check_dev:
	OR	AH,AH
	JS	short info_no_file	; device

	; MSDOS 6.0
;SR;
; If root dir then CurBuf == -1. Check for this case and return subdir attr
;for a root dir
;
	cmp	word [CURBUF],-1	;is it a root dir?
	jne	short not_root		;no, CurBuf ptr is valid

	xor	ah,ah
	mov	al,attr_directory
	clc
	jmp	short JustRet

not_root:
	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	DS
	MOV	DS,[CURBUF+2]
	MOV	SI,BX
	XOR	BX,BX			; Assume size=0 (dir)
	MOV	DI,BX
	MOV	CX,[SI+dir_entry.dir_time]
	MOV	DX,[SI+dir_entry.dir_date]
	XOR	AH,AH
	MOV	AL,[SI+dir_entry.dir_attr]
	TEST	AL,attr_directory
	JNZ	short NO_SIZE
	MOV	DI,[SI+dir_entry.dir_size_l]
	MOV	BX,[SI+dir_entry.dir_size_h]
NO_SIZE:
	POP	DS
	CLC
	jmp	short JustRet

;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
;-------------------------------------------------------------------------------
; Procedure Name : SET_FILE_ATTRIBUTE
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] is attribute of search (determines what files may be found)
;	AX is new attributes to give to file
; Function:
;	Set File Attributes
; Returns:
;	CARRY CLEAR
;	    No error
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Attempt to set an attribute which cannot be set
;			(attr_directory, attr_volume_ID)
;		error_sharing_violation
;			Sharing mode of file did not allow the change
;			(this request requires exclusive write/read access)
;			(INT 24H generated)
; DS preserved, others destroyed
;----------------------------------------------------------------------------

SET_FILE_ATTRIBUTE:

;hkn; set_file_attr is called from file.asm. DS has been set 
;hkn; to DOSDATA at this point. So DOSassume is OK.

	TEST	AX,~attr_changeable ; 0FFD8h
	JZ	short set_look
_BAD_ACC:
	MOV	byte [EXTERR_LOCUS],errLOC_Unk
	MOV	byte [EXTERR_CLASS],errCLASS_Apperr
	MOV	byte [EXTERR_ACTION],errACT_Abort
	MOV	AX,error_access_denied
	STC
	retn

set_look:
	call	TestNet
	JNC	short LOCAL_SET

;IF NOT Installed
;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
;ELSE
	PUSH	AX
	
	;MOV	AX,(MultNET SHL 8) OR 14
	;INT	2FH

	mov     ax, 110Eh
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
			; SDA CDS pointer -> current directory
			; STACK: WORD new file attributes
			; Return: CF set on error

	POP	BX			; clean stack
	retn
;ENDIF

LOCAL_SET:
	call	EcritDisk
	PUSH	AX			; Save new attributes
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	call	GETPATH 		; get path through fastopen if there	 ;AC000;
	JNC	short set_check_device
	POP	BX			; Clean stack (don't zap AX)
	JMP	short NO_PATH

set_check_device:
	OR	AH,AH
	JNS	short set_check_share
	POP	AX
	call	LcritDisk
	JMP	short _BAD_ACC 		; device

set_check_share:
	POP	AX			; Get new attributes

	; MSDOS 6.0
	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
	je	short cannot_set_root	; M025: Y: return error

	; MSDOS 3.3 (& MSDOS 6.0)
	call	REN_DEL_Check
	JNC	short set_do
	MOV	AX,error_sharing_violation
	jmp	short OK_BYE

	; MSDOS 6.0
cannot_set_root:			; M025:
	mov	ax, error_access_denied	; M025: return error is attempting
	stc				; M025: to set attr. of root
	jmp	short OK_BYE		; M025:

set_do:
	; MSDOS 3.3 (& MSDOS 6.0)
	LES	DI,[CURBUF]
	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
	OR	BYTE [ES:BX+dir_entry.dir_attr],AL

	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
	;				;LB. if already dirty		  ;AN000;
	;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
;yesdirty3:
	MOV	AL,[THISDRV]
;;;; 10/1/86 F.C update fastopen cache
	PUSH	DX
	PUSH	DI
	MOV	AH,0		  ; dir entry update
	MOV	DL,AL		  ; drive number A=0,B=1,,
	MOV	DI,BX		  ; ES:DI -> dir entry
	call	FastOpen_Update
	POP	DI
	POP	DX
;;;; 9/11/86 F.C update fastopen cache
	call	FLUSHBUF
	JNC	short OK_BYE
	MOV	AX,error_file_not_found
OK_BYE:
	call	LcritDisk
	retn

	; MSDOS 6.0
;GET_FAST_PATH:
;hkn; use SS override for FastOpenFlg
	;OR	byte [FastOpenFlg],FastOpen_Set
	;				;FO. trigger fastopen	;AN000;
	;call	GETPATH
	;PUSHF			 	;FO.			;AN000;
	;AND	byte [FastOpenFlg],Fast_yes 
	;				;FO. clear all fastopen flags ;AN000;
	;POPF				;FO.			;AN000;
	;retn

;============================================================================
; DUP.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;**	Low level DUP routine for use by EXEC when creating a new process. Exports
;	  the DUP to the server machine and increments the SFT ref count
;
;	DOS_DUP
;
;	Modification history:
;
;	  Created: ARR 30 March 1983

;BREAK <DOS_DUP -- DUP SFT across network>
;---------------------------------------------------------------------------
; Procedure Name : DOS_DUP
;
; Inputs:
;	[THISSFT] set to the SFT for the file being DUPed
;		(a non net SFT is OK, in this case the ref
;		 count is simply incremented)
; Function:
;	Signal to the devices that a logical open is occurring
; Returns:
;	ES:DI point to SFT
;    Carry clear
;	SFT ref_count is incremented
; Registers modified: None.
; NOTE:
;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
;	time with SS NOT DOSGROUP. There will be no Network handles at
;	that time.
;---------------------------------------------------------------------------

DOS_DUP:
	LES	DI,[CS:THISSFT]

	;Entry	Dos_Dup_Direct
DOS_Dup_Direct:
	call	IsSFTNet
	JNZ	short DO_INC
	call	DEV_OPEN_SFT
DO_INC:

	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
	inc	word [ES:DI]		; Clears carry (if this ever wraps
					;   we're in big trouble anyway)
	retn

;============================================================================
; CREATE.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
;NAME	DOS_CREATE

;**	Internal Create and Create new to create a local or NET file and SFT.
;
;	DOS_CREATE
;	DOS_CREATE_NEW
;	SET_MKND_ERR
;	SET_Media_ID
;	SET_EXT_Mode
;
;	Revision history:
;
;	    A000 version 4.00	  Jan. 1988
;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h

;Installed = TRUE

;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	I_need	EXTERR,WORD
;	I_Need	ExtErr_locus,BYTE
;	I_need	JShare,DWORD
;	I_need	VOLCHNG_FLAG,BYTE
;	I_need	SATTRIB,BYTE
;	I_need	CALLVIDM,DWORD
;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
;	I_need	NAME1,BYTE			  ;AN000;
;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
;	I_need	Packet_Temp,WORD		  ;AN000;
;	I_need	DOS34_FLAG,WORD 		  ;AN000;
;	I_need	SAVE_BX,WORD			  ;AN000;

;***	DOS_CREATE - Create a File
;----------------------------------------------------------------------------
;	DOS_Create is called to create the specified file, truncating
;	the old one if it exists.
;
;
;	ENTRY	AX is Attribute to create
;		(ds) = DOSDATA
;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;			terminated)
;		[CURR_DIR_END] Points to end of Current dir part of string
;			( = -1 if current dir not involved, else
;			 Points to first char after last "/" of current dir part)
;		[THISCDS] Points to CDS being used
;			(Low word = -1 if NUL CDS (Net direct request))
;		[THISSFT] Points to SFT to fill in if file created
;			(sf_mode field set so that FCB may be detected)
;		[SATTRIB] Is attribute of search, determines what files can be found
;
;	EXIT	sf_ref_count is NOT altered
;		CARRY CLEAR
;		    THISSFT filled in.
;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
;		CARRY SET
;		    AX is error code
;			error_path_not_found
;				Bad path (not in curr dir part if present)
;			error_bad_curr_dir
;				Bad path in current directory part of path
;			error_access_denied
;				Attempt to re-create read only file , or
;				create a second volume id or create a dir
;			error_sharing_violation
;				The sharing mode was correct but not allowed
;				generates an INT 24
;	USES	all but DS
;----------------------------------------------------------------------------

DOS_CREATE:

;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
;hkn; this point.

	XOR	AH,AH		; Truncate is OK

;	Enter here from Dos_Create_New
;
;	(ah) = 0 iff truncate OK

Create_inter:
	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
				; Mask out any meaningless bits
	JNZ	short AttErr
	TEST	AL,attr_volume_id
	JZ	short NoReset
	;
	; MSDOS 6.0
	;OR	[DOS34_FLAG],DBCS_VOLID      ;AN000;FOR dbcs volid
	;
	MOV	AL,attr_volume_id
NoReset:
	OR	AL,attr_archive ; File changed
	TEST	AL,attr_directory+attr_device
	JZ	short ATT_OK
AttErr:
	MOV	AX,5		; Attribute problem
	MOV	byte [EXTERR_LOCUS],errLOC_Unk
	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
				   ;	attr_device to be set.
ATT_OK:
	LES	DI,[THISSFT]
	PUSH	ES
	LES	SI,[THISCDS]
	CMP	SI,-1
	JNE	short TEST_RE_NET

;	No CDS, it must be redirected.

	POP	ES

	; MSDOS 6.0
;Extended open hooks
	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
	;JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
;IFS_extopen:				    ;AN000;EO.
	;PUSH	AX			    ;AN000;EO. pass create attr
	;;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
	;mov	ax,112Eh
	;INT	2FH			    ;AN000;EO.
	;POP	BX			    ;AN000;EO. trash bx
	;MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
	;retn				    ;AN000;EO.
;NOEXTOP:				    ;AN000;
;Extended open hooks

;IF NOT Installed
;	transfer NET_SEQ_CREATE
;ELSE
	PUSH	AX

	;MOV	AX,(MultNET SHL 8) OR 24
	;INT	2FH

	mov     ax,1118h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file
			; STACK: WORD file creation mode???

	POP	BX			; BX is trashed anyway
	retn
;ENDIF

;	We have a CDS. See if it's network

TEST_RE_NET:
	TEST	word [ES:SI+curdir.flags],curdir_isnet
	POP	ES
	JZ	short LOCAL_CREATE

	; MSDOS 6.0
	;CALL	Set_EXT_mode		    ;AN000;EO.
	;JC	SHORT dochk		    ;AN000;EO.
	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.

;Extended open hooks
;dochk:
	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
	;JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
;Extended open hooks

;IF NOT Installed
;	transfer NET_CREATE
;ELSE
	PUSH	AX
	
	;MOV	AX,(MultNET SHL 8) OR 23
	;INT	2FH
	
	mov     ax, 1117h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file to open
			; SDA CDS pointer -> current directory
			; Return: CF set on error

	POP	BX			; BX is trashed anyway
;nomore:
	retn
;ENDIF


;**	It's a local create.  We have a local CDS for it.

LOCAL_CREATE:
	; MSDOS 6.0
	;CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
	;JC	short setdone	;AN000;EO.
	
	; MSDOS 3.3 (& MSDOS 6.0)
	OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
;setdone:
	call	EcritDisk
	call	MakeNode
	JNC	short Create_ok
	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
	call	LcritDisk

	;entry	SET_MKND_ERR
SET_MKND_ERR:

;	Looks up MakeNode errors and converts them. AL is MakeNode
;	error, SI is GETPATH bad spot return if path_not_found error.

;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
	MOV     BX,CRTERRTAB
	XLAT
	;XLAT	byte [CS:BX]
CreatBadRet:
	STC
	retn

; We have just created a new file. This results in the truncation of old
; files. We must inform the sharer to slash all the open SFT's for this
; file to the current size.

; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
; drive number to force a Build BPB after Media Check.

;;; FASTOPEN 8/29/86
Create_ok:
	call	FastOpen_Delete
;;; FASTOPEN 8/29/86
	mov	al,[SATTRIB]
	test	al,attr_volume_id
	jz	short NoVolLabel
	LES	DI,[THISCDS]
	;mov	ah,[ES:DI+curdir.text]	; get drive letter
	mov	ah,[ES:DI] ; 09/08/2018
	sub	ah,'A'                  ; convert to drive letter
	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
	
	; MSDOS 6.0
	;MOV	BH,1			;AN000;>32mb set volume id to boot record
	;CALL	Set_Media_ID		;AN000;>32mb
	
	call	EcritDisk
	call	FATREAD_CDS		; force a media check
	call	LcritDisk

NoVolLabel:
	MOV	ax,2
	LES	DI,[THISSFT]
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)] ; 14 = ShSU
;else
;	Call	ShSU
;endif
	call	LcritDisk
	jmp	SET_SFT_MODE

;---------------------------------------------------------------------------
; Procedure Name : Dos_Create_New
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file created
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Attribute to create
; Function:
;	Try to create the specified file truncating an old one that exists
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
;	CARRY SET
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Create a second volume id or create a dir
;		error_file_exists
;			Already a file by this name
; DS preserved, others destroyed
;---------------------------------------------------------------------------

DOS_Create_New:
	MOV	AH,1		; Truncate is NOT OK
	JMP	Create_inter

; MSDOS 6.0
;---------------------------------------------------------------------------
; Procedure Name : Set_Media_ID
;
; Inputs:
;	NAME1= Volume ID
;	BH= 0, delete volume id
;	    1, set new volume id
;	DS= DOSGROUP
; Function:
;	Set Volume ID to DOS 4.00 Boot record.
; Outputs:
;	CARRY CLEAR
;	    volume id set
;	CARRY SET
;	    AX is error code
;---------------------------------------------------------------------------
;
;procedure   Set_Media_ID,NEAR
;	DOSAssume   <DS>,"SetMedID"
;
;	PUSH	AX		;AN000;;>32mb
;	PUSH	ES		;AN000;;>32mb
;	PUSH	DI		;AN000;;>32mb
;
;	INC	AH		;AN000;;>32mb  bl=drive #
;	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
;	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
;	MOV	CX,0866H	;AN001;;>32mb  get media id
;
;hkn; PACKET_TEMP is in DOSDATA
;	MOV	DX,OFFSET DOSDATA:PACKET_TEMP	;AN000;>32mb
;
;	PUSH	BX		;AN000;;>32mb
;	PUSH	DX		;AN000;;>32mb
;	XOR	BH,BH		;AN000;;>32mb
;
;	invoke	$IOCTL		;AN000;;>32mb
;	POP	DX		;AN000;;>32mb
;	POP	BX		;AN000;;>32mb
;	JC	geterr		;AN000;;>32mb
;
;	OR	BH,BH		;AN000;;>32mb delete volume id
;	JZ	NoName		;AN000;>32mb yes
;
;hkn; NAME1 is in DOSDATA
;	MOV	SI,OFFSET DOSDATA:NAME1   ;AN000;>32mb
;
;	JMP	SHORT doset	;AN000;>32mb yes
;Noname: 			;AN000;
;
;hkn; NO_NAME_ID is in DOSDATA
;	MOV	SI,OFFSET DOSDATA:NO_NAME_ID  ;AN000;>32mb
;
;doset:					       ;AN000;
;	MOV	DI,DX		;AN000;;>32mb
;	ADD	DI,MEDIA_LABEL	;AN000;;>32mb
;
;hkn; ES & DS must point to SS
;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
;	PUSH	SS		;AN000;;>32mb  move new volume id to packet
;
;	POP	DS		;AN000;;>32mb
;
;hkn;	PUSH	CS		;AN000;;>32mb
;	PUSH	SS		;AN000;;>32mb
;
;	POP	ES		;AN000;;>32mb
;	MOV	CX,11		;AN000;;>32mb
;	REP	MOVSB		;AN000;;>32mb
;	MOV	CX,0846H	;AN001;;>32mb
;	MOV	AL,0DH		;AN000;;>32mb
;	XOR	BH,BH		;AN000;;>32mb
;	invoke	$IOCTL		;AN000;;>32mb  set volume id
;geterr: 			;AN000;
;
;hkn;	PUSH	CS		;AN000;>32mb
;	PUSH	SS		;AN000;>32mb
;
;	POP	DS		;AN000;>32mb   ds= dosgroup
;
;	POP	DI		;AN000;;>32mb
;	POP	ES		;AN000;;>32mb
;	POP	AX		;AN000;;>32mb
;	return			;AN000;>32mb
;
;EndProc Set_Media_ID		;AN000;

; MSDOS 6.0
;---------------------------------------------------------------------------
; Procedure Name : Set_EXT_mode
;
; Inputs:
;	[EXTOPEN_ON]= flag for extended open
;	SAVE_BX= mode specified in Extended Open
; Function:
;	Set mode in ThisSFT
; Outputs:
;	carry set,mode is set if from Extended Open
;	carry clear, mode not set yet
;---------------------------------------------------------------------------
;
;procedure   Set_EXT_mode,NEAR
;
;hkn; SS override
;	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extended open
;	JZ	NOTEX			    ;AN000;EO. no, do normal
;	PUSH	AX			    ;AN000;EO.
;
;hkn; SS override
;	MOV	AX,[SAVE_BX]		    ;AN000;EO.
;	OR	ES:[DI.sf_mode],AX	    ;AN000;EO.
;	POP	AX			    ;AN000;EO.
;	STC				    ;AN000;EO.
;NOTEX:					    ;AN000;
;	return				    ;AN000;EO.
;
;EndProc Set_EXT_mode			    ;AN000;

;============================================================================
; OPEN.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
;	NAME	DOS_OPEN

;**	OPEN.ASM - File Open
;----------------------------------------------------------------------------
;	Low level routines for openning a file from a file spec.
;	Also misc routines for sharing errors
;
;	DOS_Open
;	Check_Access_AX
;	SHARE_ERROR
;	SET_SFT_MODE
;	Code_Page_Mismatched_Error		   ; DOS 4.00
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00   Jan. 1988
;
;	M034 - The value in save_bx must be pushed on to the stack for
; 	       remote extended opens and not save_cx.
;
;	M035 - if open made from exec then we must set the appropriate bits
;	       on the stack before calling off to the redir.
;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
;	       to handle open from exec. In this case set the appropriate bit
;	       else do not.
;----------------------------------------------------------------------------	

;Installed = TRUE

;	i_need	NoSetDir,BYTE
;	i_need	THISSFT,DWORD
;	i_need	THISCDS,DWORD
;	i_need	CURBUF,DWORD
;	i_need	CurrentPDB,WORD
;	i_need	CURR_DIR_END,WORD
;	I_need	RetryCount,WORD
;	I_need	Open_Access,BYTE
;	I_need	fSharing,BYTE
;	i_need	JShare,DWORD
;	I_need	FastOpenFlg,byte
;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
;	I_need	SAVE_BX,WORD			  ;M034
;
;	I_need	DOS_FLAG,BYTE
;	I_need	DOS34_FLAG,WORD			  ;M042

;Break	<DOS_Open - internal file access>
;---------------------------------------------------------------------------
; Procedure Name : DOS_Open
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[THISSFT] Points to SFT to fill in if file found
;		(sf_mode field set so that FCB may be detected)
;	[SATTRIB] Is attribute of search, determines what files can be found
;	AX is Access and Sharing mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
;
;	  For FCB SFTs AL should = sharing_compat + open_for_both
;		(not checked)
; Function:
;	Try to open the specified file
; Outputs:
;	sf_ref_count is NOT altered
;	CARRY CLEAR
;	    THISSFT filled in.
;	CARRY SET
;	    AX is error code
;		error_file_not_found
;			Last element of path not found
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_invalid_access
;			Bad sharing mode or bad access mode or bad combination
;		error_access_denied
;			Attempt to open read only file for writting, or
;			open a directory
;		error_sharing_violation
;			The sharing mode was correct but not allowed
;			generates an INT 24 on compatibility mode SFTs
; DS preserved, others destroyed
;----------------------------------------------------------------------------

DOS_OPEN:
	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 

	MOV	byte [NoSetDir],0
	CALL	Check_Access_AX
	JC	short do_ret_label		    ; retc

	LES	DI,[THISSFT]
	XOR	AH,AH

	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged

	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
	PUSH	ES
	LES	SI,[THISCDS]
	; 18/08/2018
	CMP	SI,-1
	JNZ	short TEST_RE_NET1
	POP	ES

	; MSDOS 6.0
;Extended open hooks
	;TEST	byte [EXTOPEN_ON],ext_open_on	;FT. from extnded open		;AN000;
	;JZ	short NOEXTOP 		    ;FT. no, do normal			;AN000;
IFS_extopen:									;AN000;
	;MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
	;				    ; with which call was made. This
	;				    ; has the open access bits. 
	;;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
	;
	;PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
	;;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
	;mov	ax,(MultNET*256)+46 
	;INT	2FH			    ;FT.				;AN000;
	;POP	BX			    ;FT. trash bx			;AN000;
	;MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;

;do_ret_label:
	;retn				    ;FT.				;AN000;
;NOEXTOP:
;Extended open hooks
	;
;IF NOT Installed
	;transfer NET_SEQ_OPEN
;ELSE
	;
do_net_int2f:
	;
	;test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
	;jz	short not_exec_open	; N: just do net open
	;				; Y: check to see if redir is aware
	;				;    of this 
	;
	;				; M042 - start
	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR
	;				; Q: does this redir know how to 
	;				;    this
	;jz	short not_exec_open	; N: just do net open
	;				; Y: set bit 3 of access byte and 
	;				;    set sharing mode to DENY_WRITE
	;				; M042 - end
	;
	; NOTE: This specific mode has not been set for the code assembled
	; under the "NOT Installed" conditional. Currently Installed is 
	; always one.
	;				; M035 - set the bits on the stack
	;mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
	;
;not_exec_open:

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	AX

	;MOV	AX,(MultNET SHL 8) OR 22
	;INT	2FH

	mov     ax,1116h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
			; ES:DI -> uninitialized SFT, SS = DOS CS
			; SDA first filename pointer -> fully-qualified name of file to open
			; STACK: WORD file open mode
			; Return: CF set on error

	POP	BX			; clean stack
do_ret_label: ; 09/08/2018
	retn
;ENDIF

TEST_RE_NET1:
	TEST	word [ES:SI+curdir.flags],curdir_isnet
	; 18/08/2018
	POP	ES
	;JZ	short LOCAL_OPEN

	jnz	short do_net_int2f ; (*)

;Extended open hooks
	; MSDOS 6.0
	;TEST	byte [EXTOPEN_ON],ext_open_on ;FT. from extended open	;AN000;
	;JNZ	short IFS_extopen	      ;FT. isuue extended open	;AN000;
;Extended open hooks

;IF NOT Installed
;	transfer NET_OPEN
;ELSE
	;jmp	short do_net_int2f (*)
;ENDIF

LOCAL_OPEN:
	; MSDOS 3.3 (& MSDOS 6.0)
	call	EcritDisk

; DOS 3.3 FastOPen 6/16/86

	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can

	call	GETPATH

; DOS 3.3 FastOPen 6/16/86

	JNC	short Open_found
	JNZ	short bad_path2
	OR	CL,CL
	JZ	short bad_path2

OpenFNF:
	MOV	AX,error_file_not_found

OpenBadRet:
;hkn; FastOpenFlg is in DOSDATA use SS override
	; 12/08/2018
	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
	; MSDOS 6.0
	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
	STC
	call	LcritDisk
	;JMP	Clear_FastOpen ; 10/08/2018
	retn 	; 08/09/2018

bad_path2:
	MOV	AX,error_path_not_found
	JMP	short OpenBadRet

Open_Bad_Access:
	MOV	AX,error_access_denied
	JMP	short OpenBadRet

Open_found:
	JZ	short Open_Bad_Access 	; test for directories
	OR	AH,AH
	JS	short open_ok		; Devices don't have attributes
	MOV	ES,[CURBUF+2]		; get buffer location
	MOV	AL,[ES:BX+dir_entry.dir_attr]
	TEST	AL,attr_volume_id	; can't open volume ids
	JNZ	short Open_Bad_Access
	TEST	AL,attr_read_only	; check write on read only
	JZ	short open_ok
;
; The file is marked READ-ONLY. We verify that the open mode allows access to
; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
; determine at the OPEN time if such access is allowed. Thus, we defer such
; processing until the actual write operation:
;
; If FCB, then we change the mode to be read_only.
; If net_FCB, then we change the mode to be read_only.
; If not open for read then error.
;
	push	ds
	push	si
	LDS	SI,[THISSFT]
	MOV	CX,[SI+SF_ENTRY.sf_mode]
	TEST	CX,sf_isFCB		; is it FCB?
	JNZ	short ResetAccess	; yes, reset the access
	MOV	DL,CL
	AND	DL,SHARING_MASK
	CMP	DL,SHARING_NET_FCB	; is it net FCB?
	JNZ	short NormalOpen	; no
ResetAccess:
	AND	CX,~access_mask	;0FFF0h	; clear access
;	OR	CX,open_for_read	; stick in open_for_read
	MOV	[SI+SF_ENTRY.sf_mode],CX
	JMP	SHORT FillSFT
;
; The SFT is normal.  See if the requested access is open_for_read
;
NormalOpen:
	AND	CL,access_mask	;0Fh	; remove extras
	CMP	CL,open_for_read	; is it open for read?
	JZ	short FillSFT
	pop	si
	pop	ds
	JMP	short Open_Bad_Access
;
; All done, restore registers and fill the SFT.
;
FillSFT:
	pop	si
	pop	ds
open_ok:
	call	DOOPEN			; Fill in SFT

;hkn; FastOpenFlg is in DOSDATA. use SS override
	;12/08/2018
	;AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
	and	byte [FastOpenFlg],Fast_yes	

	; MSDOS 6.0
	;CALL	DO_SHARE_CHECK
	;JNC	short SHARE_OK
	;call	LcritDisk
	;JMP	short Clear_FastOpen	

	; MSDOS 3.3
DO_SHARE_CHECK:
	MOV	CX,[RetryCount]		; Get # tries to do
OpenShareRetry:
	push	cx			; Save number left to do
	call	SHARE_CHECK		; Final Check
	pop	cx			; CX = # left
	JNC	short SHARE_OK		; No problem with access
	call	Idle
	LOOP	OpenShareRetry		; One more retry used up
OpenShareFail:
	LES	DI,[THISSFT]
	call	SHARE_ERROR
	JNC	short DO_SHARE_CHECK	; User wants more retry
	
	;12/08/2018
	;mov	byte [ss:FastOpenFlg],0
	;08/09/2018
	;mov	byte [FastOpenFlg],0
	call	LcritDisk
	;JMP	short Clear_FastOpen
	retn

SHARE_OK:
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	AX,3
	LES	DI,[THISSFT]
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)]  ; 14 = ShSU
;else
;	Call	ShSU
;endif
	call	LcritDisk
	
	;FallThru Set_SFT_Mode

;----------------------------------------------------------------------------
; Procedure Name : SET_SFT_MODE
;
; Finish SFT initialization for new reference. Set the correct mode.
;
;   Inputs:
;	ThisSFT points to SFT
;
;   Outputs:
;	Carry clear
;   Registers modified: AX.
;---------------------------------------------------------------------------

;hkn; called from create. DS already set up to DOSDATA.

SET_SFT_MODE:
	LES	DI,[THISSFT]
	call	DEV_OPEN_SFT
	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
	JZ	short Clear_FastOpen	; sf_mode correct (retz)
	MOV	AX,[CurrentPDB]
	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB

Clear_FastOpen:
	retn			       ;;;;; DOS 3.3

;----------------------------------------------------------------------------
; Procedure Name : SHARE_ERROR
;
; Called on sharing violations. ES:DI points to SFT. AX has error code
; If SFT is FCB or compatibility mode gens INT 24 error.
; Returns carry set AX=error_sharing_violation if user says ignore (can't
; really ignore).  Carry clear
; if user wants a retry. ES, DI, DS preserved
;---------------------------------------------------------------------------

SHARE_ERROR:
	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	JNZ	short _HARD_ERR
	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
	AND	CL,SHARING_MASK
	CMP	CL,SHARING_COMPAT
	JNE	short _NO_HARD_ERR
_HARD_ERR:
	call	SHARE_VIOLATION
	;retnc				; User wants retry
	jnc	short Clear_FastOpen
_NO_HARD_ERR:
	MOV	AX,error_sharing_violation
	STC
	retn

; MSDOS 6.0
;----------------------------------------------------------------------------
; Procedure Name : DO_SHARE_CHECK
;
; Input: THISDPB, WFP_Start, THISSFT set
; Functions: check file sharing mode is valid
; Output: carry set, error
;	  carry clear, share ok
;----------------------------------------------------------------------------
;
;DO_SHARE_CHECK:
;	call	EcritDisk		; enter critical section
;OPN_RETRY:
;	MOV	CX,[RetryCount]		; Get # tries to do
;OpenShareRetry:
;	push	cx			; Save number left to do
;	call	SHARE_CHECK		; Final Check
;	pop	cx			; CX = # left
;	JNC	short Share_Ok2		; No problem with access
;	call	Idle
;	LOOP	OpenShareRetry		; One more retry used up
;OpenShareFail:
;	LES	DI,[THISSFT]
;	call	SHARE_ERROR
;	JNC	short OPN_RETRY		; User wants more retry
;Share_Ok2:
;	call	LcritDisk		; leave critical section
;	retn

;-----------------------------------------------------------------------------
; Procedure Name : Check_Access
;
; Inputs:
;	AX is mode
;	  High NIBBLE of AL (Sharing Mode)
;		sharing_compat	   file is opened in compatibility mode
;		sharing_deny_none  file is opened Multi reader, Multi writer
;		sharing_deny_read  file is opened Only reader, Multi writer
;		sharing_deny_write file is opened Multi reader, Only writer
;		sharing_deny_both  file is opened Only reader, Only writer
;	  Low NIBBLE of AL (Access Mode)
;		open_for_read	file is opened for reading
;		open_for_write	file is opened for writing
;		open_for_both	file is opened for both reading and writing.
; Function:
;	Check this access mode for correctness
; Outputs:
;	[open_access] = AL input
;	Carry Clear
;		Mode is correct
;		AX unchanged
;	Carry Set
;		Mode is bad
;		AX = error_invalid_access
; No other registers effected
;----------------------------------------------------------------------------

Check_Access_AX:

	MOV	[OPEN_ACCESS],AL
	PUSH	BX

;	If sharing, then test for special sharing mode for FCBs

	MOV	BL,AL
	AND	BL,SHARING_MASK
	CMP	byte [FSHARING],-1
	JNZ	short CheckShareMode	; not through server call, must be ok
	CMP	BL,SHARING_NET_FCB
	JZ	short CheckAccessMode	; yes, we have an FCB
CheckShareMode:
	CMP	BL,40h			; is this a good sharing mode?
	JA	short Make_Bad_Access
CheckAccessMode:
	MOV	BL,AL
	AND	BL,access_mask
	CMP	BL,2
	JA	short Make_Bad_Access
	POP	BX
	CLC
	retn

Make_Bad_Access:
	MOV	AX,error_invalid_access
	POP	BX
	STC
	retn

;============================================================================
; DINFO.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/08/2018 - Retro DOS v3.0

;**	Low level routine for returning disk drive information from a local
;	  or NET device
;
;	DISK_INFO
;
;	  Modification history:
;
;		Created: ARR 30 March 1983

;	Break	<DISK_INFO -- Get Disk Drive Information>
;---------------------------------------------------------------------------
; Procedure Name : DISK_INFO
;
; Inputs:
;	[THISCDS] Points to the Macro List Structure of interest
;		(It MAY NOT be NUL, error not detected)
; Function:
;	Get Interesting Drive Information
; Returns:
;	DX = Number of free allocation units
;	BX = Total Number of allocation units on disk
;	CX = Sector size
;	AL = Sectors per allocation unit
;	AH = FAT ID BYTE
;	Carry set if error (currently user FAILed to I 24)
; Segs except ES preserved, others destroyed
;----------------------------------------------------------------------------

;hkn; called from getset.asm and misc.asm. DS has already been set up to 
;hkn; DOSDATA. 

DISK_INFO:
	; 08/08/2018 - Retro DOS v3.0
	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h

	call	TestNet
	JNC	short LOCAL_DSK_INFO

;IF NOT Installed
;	transfer NET_DISK_INFO
;ELSE
	;MOV	AX,(MultNET SHL 8) OR 12
	;INT	2FH
	;return

	mov     ax,110Ch
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
			; ES:DI -> current directory
			; Return: AL = sectors per cluster, BX = total clusters
			; CX = bytes per sector, DX = number of available clusters
	retn
;ENDIF

LOCAL_DSK_INFO:
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	EcritDisk
	call	FATREAD_CDS		; perform media check.
	JC	short CRIT_LEAVE
	MOV	BX,2
	call	UNPACK			; Get first FAT sector into CURBUF
	JC	short CRIT_LEAVE
	LDS	SI,[CURBUF]
	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
;
; Examine the current free count.  If it indicates that we have an invalid
; count, do the expensive calculation.
;
	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
	CMP	DX,-1			; is it valid?
	JZ	short DoScan
;
; Check to see if it is in a reasonalbe range.	If so, trust it and return.
; Otherwise, we need to blast out an internal error message and then recompute
; the count.
;
	CMP	DX,CX			; is it in a reasonable range?
	JB	short GotVal		; yes, trust it.
DoScan:
	XOR	DX,DX
	DEC	CX
SCANFREE:
	call	UNPACK
	JC	short CRIT_LEAVE
	JNZ	short NOTFREECLUS
	INC	DX			; A free one
NOTFREECLUS:
	INC	BX			; Next cluster
	LOOP	SCANFREE
	DEC	BX			; BX was next cluster.	Convert to
ReturnVals:
	DEC	BX			; count
	MOV	AL,[ES:BP+DPB.CLUSTER_MASK] 
	INC	AL			; Sectors/cluster
	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
	MOV	[ES:BP+DPB.FREE_CNT],DX
	CLC
CRIT_LEAVE:
	call	LcritDisk
	retn
;
; We have correctly computed everything previously. Load up registers for
; return.
;
GotVal: 
	MOV	BX,CX			; get cluster count
	JMP	short ReturnVals

;============================================================================
; ISEARCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 22/07/2018 - Retro DOS v3.0

;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
;	NAME	DOS_SEARCH

;**	Low level routines for doing local and NET directory searches
;
;	DOS_SEARCH_FIRST
;	DOS_SEARCH_NEXT
;	RENAME_NEXT
;
;	Revision history:
;
;	    Created: ARR 30 March 1983
;	    A000	version 4.00  Jan. 1988
;	    A001	PTM 3564 -- search for fastopen

;Installed = TRUE

;--------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_FIRST
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[DMAADD] Points to 53 byte buffer
; Function:
;	Initiate a search for the given file spec
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes ot DMAADD are filled in as follows:
;
;	LOCAL
;	    Drive Byte (A=1, B=2, ...) High bit clear
;		NEVER STORE DRIVE BYTE AFTER  found_it
;	    11 byte search name with Meta chars in it
;	    Search Attribute Byte, attribute of search
;	    WORD LastEnt value
;	    WORD DirStart
;	    4 byte pad
;	    32 bytes of the directory entry found
;	NET
;	    21 bytes First byte has high bit set
;	    32 bytes of the directory entry found
;
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No match for this file
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
; DS preserved, others destroyed
;---------------------------------------------------------------------------

DOS_SEARCH_FIRST:
	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h

	LES	DI,[THISCDS]
	CMP	DI,-1
	JNZ	short TEST_RE_NET2

;IF NOT Installed
;	transfer NET_SEQ_SEARCH_FIRST
;ELSE
	;mov	ax,1119h
	MOV	AX,(MultNET<<8)|25
	INT	2Fh
	retn
;ENDIF

TEST_RE_NET2:
	;test	word [es:di+43h],8000h
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JZ	short LOCAL_SEARCH_FIRST

;IF NOT Installed
;	transfer NET_SEARCH_FIRST
;ELSE
	;mov	ax,111Bh
	MOV	AX,(MultNET<<8)|27
	INT	2FH
	retn
;ENDIF

LOCAL_SEARCH_FIRST:
	call	EcritDisk
	; MSDOS 6.0
	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
	;JZ	short NOFN			;AN000;
	;OR	byte [FastOpenflg],Fastopen_Set	;AN000;
;NOFN:						;AN000;
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	; MSDOS 6.0
	;CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
	;JNC	short norm_GETPATH	;AN000;;FO. no
	;AND	byte [FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
;norm_GETPATH:
	call	GETPATH
	; BX = offset NAME1
;_getdone:
	JNC	short find_check_dev
	JNZ	short bad_path3
	OR	CL,CL
	JZ	short bad_path3
find_no_more:
	;mov	ax,12h
	MOV	AX,error_no_more_files
BadBye:
	; MSDOS 6.0
	;AND	[SS:FastOpenflg],Fast_yes  ;AN000;;FO. reset fastopen

	STC
	call	LcritDisk
	retn

bad_path3:
	;mov	ax,3
	MOV	AX,error_path_not_found
	JMP	short BadBye

find_check_dev:
	OR	AH,AH
	JNS	short found_entry
	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
found_entry:
;
; We set the physical drive byte here Instead of after found_it; Doing
; a search-next may not have wfp_start set correctly
;
	LES	DI,[DMAADD]
	MOV	SI,[WFP_START]		; get pointer to beginning
	LODSB
	SUB	AL,'A'-1                ; logical drive
	STOSB				; High bit not set (local)
found_it:
	LES	DI,[DMAADD]
	INC	DI

	; MSDOS 6.0
	;PUSH	DS				  ;FO.;AN001; save ds
	;TEST	byte [Fastopenflg],Set_For_Search ;FO.;AN001; from fastopen
	;JZ	short notfast 			  ;FO.;AN001;
	;MOV	SI,BX				  ;FO.;AN001;
	;MOV	DS,[CURBUF+2]			  ;FO.;AN001;
	;JMP	SHORT movmov			  ;FO.;AN001;

notfast:
	MOV	SI,NAME1		; find_buf 2 = formatted name
movmov:
; Special E5 code
	MOVSB
	CMP	BYTE [ES:DI-1],5
	JNZ	short NOTKANJB
	MOV	BYTE [ES:DI-1],0E5H
NOTKANJB:
	MOV	CX,10
	REP	MOVSB

	; 08/09/2018
	;POP	DS			;FO.;AN001; restore ds

	MOV	AL,[ATTRIB]
	STOSB
	PUSH	AX			; Save AH device info
	MOV	AX,[LASTENT]
	STOSW
	MOV	AX,[DIRSTART]
	STOSW
; 4 bytes of 21 byte cont structure left for NET stuff
	ADD	DI,4
	POP	AX			; Recover AH device info
	OR	AH,AH
	JS	short DOSREL		; Device entry is DOSGROUP relative
	CMP	WORD [CURBUF],-1
	JNZ	short OKSTORE

	; MSDOS 6.0
	;TEST	byte [FastOPenFlg],Set_For_Search
					;AN000;;FO. from fastopen and is good
	;JNZ	short OKSTORE		;AN000;;FO.

	; The user has specified the root directory itself, rather than some
	; contents of it. We can't "find" that.
	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
					;   stuffing a -1 at Lastent
	JMP	short find_no_more

OKSTORE:
	MOV	DS,[CURBUF+2]
DOSREL:
	; BX = offset NAME1 (from GETPATH)
	MOV	SI,BX			; SI-> start of entry

; NOTE: DOS_RENAME depends on BX not being altered after this point

	;mov	cx,32
	MOV	CX,dir_entry.size
;;;;; 7/29/86
	MOV	AX,DI			; save the 1st byte addr
	REP	MOVSB
	MOV	DI,AX			; restore 1st byte addr
	CMP	BYTE [ES:DI],05H	; special char check
	JNZ	short NO05
	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
NO05:

;;;;; 7/29/86

;hkn; FastOpenflg is in DOSDATA use SS
	; MSDOS 6.0
	;AND	byte [SS:FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
	;push	ss
	;pop	ds
	;AND	byte [FastOpenflg],Fast_yes

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	CLC
	call	LcritDisk
	retn

;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_SEARCH_NEXT
;
; Inputs:
;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
;	    (only first 21 bytes must have valid information)
; Function:
;	Look for subsequent matches
; Outputs:
;	CARRY CLEAR
;	    The 53 bytes at DMAADD are updated for next call
;		(see DOS_SEARCH_FIRST)
;	CARRY SET
;	    AX = error code
;		error_no_more_files
;			No more files to find
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; called from search.asm. DS already set up at this point.

DOS_SEARCH_NEXT:
	LES	DI,[DMAADD]
	MOV	AL,[ES:DI]
	TEST	AL,80H			; Test for NET
	JZ	short LOCAL_SEARCH_NEXT
;IF NOT Installed
;	transfer NET_SEARCH_NEXT
;ELSE
	;mov	ax,111Ch
	MOV	AX,(MultNET<<8)|28
	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
		     ; Return: CF set on error, AX = DOS error code
		     ; CF clear if successful
	retn
;ENDIF

LOCAL_SEARCH_NEXT:
	;AL is drive A=1
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	EcritDisk

;hkn; DummyCDS is in DOSDATA
	MOV     word [THISCDS],DUMMYCDS
;hkn; Segment address is DOSDATA - use ds
;hkn;	MOV     WORD [THISCDS+2],CS
	mov	[THISCDS+2],DS

	ADD	AL,'A'-1
	call	InitCDS

;	call	GETTHISDRV		; Set CDS pointer

	JC	short No_files		; Bogus drive letter
	LES	DI,[THISCDS]		; Get CDS pointer
	;les	bp,[es:di+45h]
	LES	BP,[ES:DI+curdir.devptr]; Get DPB pointer
	call	GOTDPB			; [THISDPB] = ES:BP

	mov	al,[ES:BP]
	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
	mov	[THISDRV],AL
	;mov	word [CREATING], 0E500h
	MOV	WORD [CREATING],(DIRFREE*256)+0
	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
	LDS	SI,[DMAADD]
	LODSB				; Drive Byte

	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
RENAME_NEXT:
	;context ES
	push	ss
	pop	es			; THIS BLOWS ES:BP POINTER TO DPB

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1

	MOV	CX,11
	REP	MOVSB			; Search name
	LODSB				; Attribute

;hkn; SS override
	MOV	[SS:ATTRIB],AL
	LODSW				; LastEnt
	OR	AX,AX
	JNS	short cont_load
No_files:
	JMP	find_no_more

cont_load:
	PUSH	AX			; Save LastEnt
	LODSW				; DirStart
	MOV	BX,AX

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	LES	BP,[THISDPB]		; Recover ES:BP
	;invoke	SetDirSrch
	call	SETDIRSRCH
	JNC	short SEARCH_GOON
	POP	AX			; Clean stack
	JMP	short No_files

SEARCH_GOON:
	call	STARTSRCH
	POP	AX
	call	GETENT
	JC	short No_files
	call	NEXTENT
	JC	short No_files
	XOR	AH,AH			; If Search_Next, can't be a DEV
	JMP	found_it ; 10/08/2018

; MSDOS6.0
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_QUESTION
;
; Input: [WFP_START]= pointer to final path
; Function: check '?' char
; Output: carry clear, if no '?'
;	 carry set, if '?' exists
;---------------------------------------------------------------------------

;CHECK_QUESTION:
;;hkn;	wfp_start is in DOSDATA;hkn;	MOV     WORD PTR ThisCDS+2,CS
;;hkn;	PUSH	CS			;AN000;;FO.
;	push	ss
;
;	POP	DS			;AN000;;FO. ds:si -> final path
;	MOV	SI,[WFP_START]		;AN000;;FO.
;getnext:				;AN000;
;	LODSB				;AN000;;FO. get char
;	OR	AL,AL			;AN000;;FO. is it null
;	JZ	short NO_Question	;AN000;;FO. yes
;	CMP	AL,'?'                  ;AN000;;FO. is '?'
;	JNZ	short getnext 		;AN000;;FO. no
;	STC				;AN000;;FO.
;NO_Question:				;AN000;
;	retn				;AN000;;FO.

;============================================================================
; ABORT.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0

;**
;
; Internal Abort call closes all handles and FCBs associated with a process.
;  If process has NET resources a close all is sent out over the net.
;
;   DOS_ABORT
;
;   Modification history:
;
;       Created: ARR 30 March 1983
;
;	M038	SR	10/16/90	Free SFT with the PSP of the process
;				being terminated only if it is busy.
;

;Break   <DOS_ABORT -- CLOSE all files for process>
;--------------------------------------------------------------------------
;
; Procedure Name : DOS_ABORT
;
; Inputs:
;       [CurrentPDB] set to PID of process aborting
; Function:
;       Close all files and free all SFTs for this PID
; Returns:
;       None
; All destroyed except stack
;---------------------------------------------------------------------------

DOS_ABORT:
	MOV     ES,[SS:CurrentPDB]	; SS override
	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
reset_free_jfn:
	MOV     BX,CX
	PUSH    CX
	DEC     BX                      ; get jfn (start with last one)

	CALL	_$CLOSE
	POP     CX
	LOOP    reset_free_jfn          ; and do 'em all
;
; Note:  We do need to explicitly close FCBs. Reasons are as follows: If we
; are running in the no-sharing no-network environment, we are simulating the
; 2.0 world and thus if the user doesn't close the file, that is his problem
; BUT...  the cache remains in a state with garbage that may be reused by the
; next process.  We scan the set and blast the ref counts of the FCBs we own.
;
; If sharing is loaded, then the following call to close process will
; correctly close all FCBs.  We will then need to walk the list AFTER here.
;
; Finally, the following call to NET_Abort will cause an EOP to be sent to all
; known network resources.  These resources are then responsible for cleaning
; up after this process.
;
; Sleazy, eh?
;
	;context DS			; SS is DOSDATA
	push	ss
	pop	ds  ; 09/09/2018

	;CallInstall Net_Abort, MultNET, 29
	mov	ax, 111Dh
	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
			; DS???, SS = DOS CS
;if installed
	call	far [JShare+(4*4)]	; 4 = MFTCloseP
;else
;	call 	mftCloseP
;endif

; Scan the FCB cache for guys that belong to this process and zap their ref
; counts.
					; SS override
	les     di,[ss:SFTFCB]		; grab the pointer to the table
	;mov	cx,[es:di+4]
	mov     cx,[es:di+SFT.SFCount]
	jcxz    FCBScanDone
	;lea	di,[di+6]
	LEA     DI,[DI+SFT.SFTable]	; point at table
	mov     ax,[SS:PROC_ID]		; SS override
FCBTest:
	;cmp	[es:di+31h],ax
	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
	jnz	short FCBNext		; no, skip it
	mov	word [es:di],0
	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
FCBNext:
	add     di,SF_ENTRY.size
	loop    FCBTest
FCBScanDone:

;
; Walk the SFT to eliminate all busy SFT's for this process.
;
	XOR     BX,BX
Scan:
	push    bx
	call	SFFromSFN
	pop     bx
	jnc     short Scan1
	retn

;M038
; Do what the comment above says, check for busy state
;
Scan1:
	;cmp	word [es:di],0
	;jz	short scan_next  ; MSDOS 3.3
	; MSDOS6.0
	cmp	word [es:di],sf_busy ; -1
	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
				; Is Sft busy? ;M038
	jnz	short scan_next
;
; we have a SFT that is busy. See if it is for the current process
;
	mov     ax,[SS:PROC_ID]		; SS override
	;cmp	[es:di+31h],ax
	cmp	[es:di+SF_ENTRY.sf_PID],ax
	jnz	short scan_next
	mov     ax,[SS:USER_ID]		; SS override
	;cmp	[es:di+2Fh],ax
	cmp	[es:di+SF_ENTRY.sf_UID],ax
	jnz	short scan_next
;
; This SFT is labelled as ours.
;
	mov	word [es:di],0
	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
scan_next:
	inc     bx
	jmp     short Scan


;============================================================================
; CLOSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0

;**	Internal Close and Commit calls to close a local or NET SFT.
;
;	DOS_CLOSE
;	DOS_COMMIT
;	FREE_SFT
;	SetSFTTimes
;
;	Revision history:
;
;	   AN000  version 4.00	Jan. 1988
;	   A005   PTM 3718 --- lost clusters when fastopen installed
;	   A011   PTM 4766 --- C2 fastopen problem

;Installed = TRUE

;Break <DOS_CLOSE -- CLOSE FILE from SFT>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_CLOSE
;
; Inputs:
;	[THISSFT] set to the SFT for the file being used
; Function:
;	Close the indicated file via the SFT
; Returns:
;	sf_ref_count decremented otherwise
;	ES:DI point to SFT
;	Carry set if error
;	    AX has error code
; DS preserved, others destroyed
;---------------------------------------------------------------------------

;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.

; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h

DOS_CLOSE:
	LES	DI,[THISSFT]
	;mov	bx,[ES:DI+5]
	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]

;	Network closes are handled entirely by the net code.

	;test	bx,8000h
	TEST	BX,sf_isnet
	JZ	short LocalClose

	;CallInstall Net_Close,MultNET,6
	mov     ax, 1106h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn

;
; All closes release the sharing information.
; No commit releases sharing information
;
; All closes decrement the ref count.
; No commit decrements the ref count.
;
LocalClose:
	call	EcritDisk
	CALL	SetSFTTimes
	CALL	FREE_SFT		; dec ref count or mark as busy

;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds

	push	ax
	push	bx
	call	ShareEnd
	pop	bx
	pop	ax
;
; Commit enters here. AX from commit MUST be <> 1, BX is flags word
;
CloseEntry:
	PUSH	AX
;
; File clean or device does not get stamped nor disk looked at.
;
	;test	bx,0C0h
	TEST	BX,devid_file_clean+devid_device
	;JZ	short rdir
	;JMP	FREE_SFT_OK		; either clean or device
	jnz	short FREE_SFT_OK
;
; Retrieve the directory entry for the file
;
rdir:
	CALL	DirFromSFT
	;mov	al,5
	MOV	AL,error_access_denied
	;JNC	short clook
	;JMP	CloseFinish		; pretend the close worked.
	jc	short CloseFinish
clook:
;
; ES:DI points to entry
; DS:SI points to SFT
; ES:BX points to buffer header
;
	push	di
	push	si
	;lea	si,[si+20h] ; MSDOS 3.3
	LEA	SI,[SI+SF_ENTRY.sf_name]
;
; ES:DI point to directory entry
; DS:SI point to unpacked name
;
	call	XCHGP
;
; ES:DI point to unpacked name
; DS:SI point to directory entry
;
	call	MetaCompare
	call	XCHGP
	pop	si
	pop	di
	JZ	short CLOSE_GO		; Name OK
Bye:	
	MOV	DI,SI
	PUSH	DS
	POP	ES			; ES:DI points to SFT
	PUSH	SS
	POP	DS
	STC
	;mov	al,2
	MOV	AL,error_file_not_found
	JMP	short CloseFinish

CLOSE_GO:
	; MSDOS 6.0
	;TEST	[SI+SF_ENTRY.sf_mode],sf_isFCB	; FCB ?
	;JZ	short nofcb		; no, set dir attr, sf_attr
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ch,[es:di+0Bh]
	MOV	CH,[ES:DI+dir_entry.dir_attr]
	;mov	al,[si+4]
	MOV	AL,[SI+SF_ENTRY.sf_attr]

;hkn; SS override
	MOV	[SS:ATTRIB],AL
	; MSDOS 3.3
	call	MatchAttributes
	JNZ	short Bye		; attributes do not match
	;JMP	SHORT setattr		;FT.
	; MSDOS 6.0
;nofcb:
	;MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
	;MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
setattr:
	; MSDOS 3.3 (& MSDOS6.0)
	;or	byte [es:di+0Bh],20h
	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
	; MSDOS6.0
	;MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
					;F.O. save old first cluster
;hkn; SS override
	;MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster

	;mov	ax,[si+0Bh]
	MOV	AX,[SI+SF_ENTRY.sf_firclus]
	;mov	[es:di+1Ah],ax
	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
	;mov	ax,[si+11h]
	MOV	AX,[SI+SF_ENTRY.sf_size]
	;mov	[es:di+1Ch],ax
	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
	;mov	ax,[si+13h]
	MOV	AX,[SI+SF_ENTRY.sf_size+2]
	;mov	[es:di+1Eh],ax
	MOV	[ES:DI+dir_entry.dir_size_h],AX
	;mov	ax,[si+0Fh]
	MOV	AX,[SI+SF_ENTRY.sf_date]
	;mov	[es:di+18h],ax
	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
	;mov	ax,[si+0Dh]
	MOV	AX,[SI+SF_ENTRY.sf_time]
	;mov	[es:di+16h],ax
	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time

	; MSDOS 6.0
;; File Tagging
	;TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
	;			  ;LB. if already dirty		    ;AN000;
	;JNZ	short yesdirty	  ;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
	; MSDOS 3.3 (& MSDOS6.0)
	;or	byte [es:bx+5],40h
	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
yesdirty:
	push	ds
	push	si
	; MSDOS 6.0
	;MOV	CX,[SI.sf_firclus]	; do this for Fastopen

;hkn; SS override
	;MOV	AL,[SS:THISDRV]
	; MSDOS3.3 
	push	ss
	pop	ds
	MOV	AL,[THISDRV]
;;; 10/1/86  update fastopen cache
	; MSDOS 3.3 (& MSDOS6.0)
	PUSH	DX
	MOV	AH,0			; dir entry update
	MOV	DL,AL			; drive number A=0, B=1,,,
	; MSDOS 6.0
	;OR	CX,CX			;AN005; first cluster 0; may be truncated
	;JNZ	short do_update2	;AN005; no, do update
	;MOV	AH,3			;AN005; do a delete cache entry
	;MOV	DI,[SI+SF_ENTRY.sf_dirsec]   ;AN005; cx:di = dir sector
	;MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
	;MOV	DH,[SI+SF_ENTRY.sf_dirpos]   ;AN005; dh= dir pos
	;JMP	SHORT do_update 	;AN011;F.O.
;do_update2:				;AN011;F.O.
;hkn; SS override fort OLD_FIRSTCLUS
	;CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
	;JZ	short do_update		;AN011;F.O. yes
	;MOV	AH,2			;AN011;F.O. delete the old entry
	;MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
do_update:				;AN005;
;hkn; SS is DOSDATA
	;Context DS
	;push	ss
	;pop	ds	
	; MSDOS 3.3 (& MSDOS6.0)
	call	FastOpen_Update 	; invoke fastopen
	POP	DX

;;; 10/1/86  update fastopen cache
	call	FLUSHBUF		; flush all relevant buffers
	pop	di
	pop	es
	;mov	al,5
	MOV	AL,error_access_denied
	JC	short CloseFinish
FREE_SFT_OK:
	CLC				; signal no error.
CloseFinish:
;
; Indicate to the device that the SFT is being closed.
;
;;;; 7/21/86
	PUSHF				; save flag from DirFromSFT
	call	DEV_CLOSE_SFT
	POPF
;;;; 7/21/86
;
; See if the ref count indicates that we have busied the SFT. If so, mark the
; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
; going to be moving from busy to free.
;
	POP	CX			; get old ref count
	PUSHF
	DEC	CX			; if cx != 1
	JNZ	short NoFree		; then do NOT free SFT
	mov	[es:di],cx
	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
NoFree:
	call	LcritDisk
	POPF
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : FREE_SFT
;
; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
; Flags preserved. Return old ref count in AX
;
; Note that busy is indicated by the SFT ref count being -1.
;
;---------------------------------------------------------------------------

FREE_SFT:
	PUSHF		; Save carry state
	mov	ax,[es:di]
	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	DEC	AX
	JNZ	short SetCount
	DEC	AX
SetCount:
	xchg	ax,[es:di]
	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	POPF
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : DirFromSFT
;
;   DirFromSFT - locate a directory entry given an SFT.
;
;   Inputs:	ES:DI point to SFT
;		DS = DOSDATA
;   Outputs:
;		EXTERR_LOCUS = errLOC_Disk
;		CurBuf points to buffer
;		Carry Clear -> operation OK
;		    ES:DI point to entry
;		    ES:BX point to buffer
;		    DS:SI point to SFT
;		Carry SET   -> operation failed
;		    registers trashified
;   Registers modified: ALL
;----------------------------------------------------------------------------

DirFromSFT:
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	push	es
	push	di
	; MSDOS 3.3
	;mov	dx,[es:di+1Dh]
	MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
	; MSDOS 6.0
	;MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
	;MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
	;MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
	;PUSH	word [HIGH_SECTOR]	;F.C. >32mb
	; MSDOS 3.3 (& MSDOS6.0)
	PUSH	DX
	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
					; [THISDPB] set
	POP	DX
	;POP	word [HIGH_SECTOR]	;F.C. >32mb
	JC	short PopDone
	XOR	AL,AL			; Pre read
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	call	GETBUFFR
	JC	short PopDone
	pop	si
	pop	ds			; Get back SFT pointer

;hkn; SS override
	LES	DI,[SS:CURBUF]
	;or	byte [es:di+5],4
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
	MOV	BX,DI			; ES:BX point to buffer header
	;lea	di,[di+10h]
	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
	;mov	al,32
	MOV	AL,dir_entry.size
	MUL	byte [SI+SF_ENTRY.sf_dirpos]
	ADD	DI,AX			; Point at the entry
	retn				; carry is clear

PopDone:
	pop	di
	pop	es
PopDone_retn:
	retn

;----------------------------------------------------------------------------
;
;**	DOS_Commit - UPdate Directory Entries
;
;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
;		(DS) = DOSGROUP
;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
;	USES	all but DS
;
;----------------------------------------------------------------------------
;

DOS_COMMIT:
	;hkn; called from srvcall. DS already set up.
	LES	DI,[THISSFT]
	;mov	bx,[es:di+5]
	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
	;test	bx,0C0h
	TEST	BX,devid_file_clean+devid_device ;Clears carry
	jnz	short PopDone_retn
	;test	bx,8000h
	TEST	BX,sf_isnet
	JZ	short LOCAL_COMMIT

;IF NOT Installed
;	transfer NET_COMMIT
;ELSE
	;mov	ax,1107h
	MOV	AX,(MultNET<<8)|7
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

;
; Perform local commit operation by doing a close but not releaseing the SFT.
; There are three ways we can do this.	One is to enter a critical section to
; protect a potential free.  The second is to increment the ref count to mask
; the close decrementing.
;
; The proper way is to let the caller's of close decide if a decrement should
; be done.  We do this by providing another entry into close after the
; decrement and after the share information release.
;
LOCAL_COMMIT:
	call	EcritDisk
	; MSDOS6.0
	;call	EcritDisk	;PTM.
	call	SetSFTTimes
	MOV	AX,-1
	call	CloseEntry
	; MSDOS 6.0
	;PUSHF			;PTM.				;AN000;
	;call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
	;POPF			;PTM.				;AN000;
	;call	LcritDisk	;PTM.				;AN000;
localcommit_retn:
	retn

;Break	<SetSFTTimes - signal a change in the times for an SFT>
;----------------------------------------------------------------------------
;
; Procedure Name : SetSFTTimes
;
;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
;   Reflect these times in other SFT's for the same file.
;
;   Inputs:	ES:DI point to SFT
;		BX = sf_flags set apprpriately
;   Outputs:	Set sft times to current time iff File & dirty & !nodate
;   Registers modified: All except ES:DI, BX, AX
;
;----------------------------------------------------------------------------

SetSFTTimes:
;	File clean or device does not get stamped nor disk looked at.
	
	;test	bx,0C0h
	TEST	BX,devid_file_clean+devid_device
	;retnz				; clean or device => no timestamp
	jnz	short localcommit_retn

;	file and dirty. See if date is good

	;test	bx,4000h
	TEST	BX,sf_close_nodate
	;retnz				; nodate => no timestamp
	jnz	short localcommit_retn

	push	ax
	push	bx
	call	DATE16			; Date/Time to AX/DX
	;mov	[es:di+0Fh],ax
	MOV	[ES:DI+SF_ENTRY.sf_date],AX
	;mov	[es:di+0Dh],dx
	MOV	[ES:DI+SF_ENTRY.sf_time],DX
	XOR	AX,AX
;if installed
	;call	JShare + 14 * 4
	call	far [JShare+(14*4)]	; 14 = ShSU
;else
;	call	ShSU
;endif
	pop	bx
	pop	ax
	retn

;============================================================================
; DIRCALL.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0

;TITLE DIRCALL - Directory manipulation internal calls
;NAME  DIRCALL

;**	Low level directory manipulation routines for making removing and
;	  verifying local or NET directories
;
;	DOS_MKDIR
;	DOS_CHDIR
;	DOS_RMDIR
;
;	Modification history:
;
;		Created: ARR 30 March 1983

;BREAK <DOS_MkDir - Make a directory entry>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_MkDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Make a new directory
; Returns:
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			Already exists, device name
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

DOS_MKDIR:
	call	TestNet
	JNC	short LOCAL_MKDIR

;IF NOT Installed
;	transfer NET_MKDIR
;ELSE
	;mov	ax,1103h
	MOV	AX,(MultNET<<8)|3
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

NODEACCERRJ:
	;mov	ax,5
	MOV	AX,error_access_denied
_BadRet:
	STC
	call	LcritDisk
	retn

PATHNFJ:
	call	LcritDisk
	jmp	SET_MKND_ERR	; Map the MakeNode error and return

LOCAL_MKDIR:
	call	EcritDisk
;
; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
;
	MOV	[THISSFT+2],SS

;hkn; DOSDATA
	MOV	WORD [THISSFT],RENBUF
;
;  NOTE: Need WORD PTR because MASM takes type of
;   TempSFT (byte) instead of type of sf_mft (word).
;
	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
				; make sure SHARER won't complain.
	;mov	al,10h
	MOV	AL,attr_directory
	call	MakeNode
	JC	short PATHNFJ
	CMP	AX,3
	JZ	short NODEACCERRJ ; Can't make a device into a directory
	LES	BP,[THISDPB]	; Makenode zaps this
	LDS	DI,[CURBUF]
	SUB	SI,DI
	PUSH	SI		; Pointer to dir_first
	; MSDOS 6.0
	;PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
	; MSDOS 3.3 (& MSDOS 6.0)
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
	push	ss
	pop	ds
	PUSH	word [DIRSTART]	; Parent for .. entry
	XOR	AX,AX
	MOV	[DIRSTART],AX	; Null directory
	call	NEWDIR
	JC	short NODEEXISTSPOPDEL ; No room
	call	GETENT		; First entry
	JC	short NODEEXISTSPOPDEL ; Screw up
	LES	DI,[CURBUF]

	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
	;			 ;LB. if already dirty		    ;AN000;
	;JNZ	short yesdirty_	 ;LB.   don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;or	byte [es:di+5],40h
	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
;yesdirty_:
	;add	di,16
	ADD	DI,BUFINSIZ	; Point at buffer
	MOV	AX,202EH	; ". "
	MOV	DX,[DIRSTART]	; Point at itself
	call	SETDOTENT
	MOV	AX,2E2EH	; ".."
	POP	DX		; Parent
	call	SETDOTENT
	LES	BP,[THISDPB]
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	POP	DX		; Entry sector
	; MSDOS 6.0
	;POP	word [HIGH_SECTOR] ;F.C. >32mb

	XOR	AL,AL		; Pre read
	call	GETBUFFR
	JC	short NODEEXISTSP
	MOV	DX,[DIRSTART]
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	MOV	[SI],DX
	XOR	DX,DX
	MOV	[SI+2],DX	; Zero size
	MOV	[SI+4],DX
DIRUP:
	; MSDOS 6.0
	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
	;			 ;LB. if already dirty 		   ;AN000;
	;JNZ	short yesdirty2	 ;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;or	byte [di+5],40h
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
;yesdirty2:
	push	ss
	pop	ds
	mov	al,[es:bp]
	; 18/05/2019
	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
	call	FLUSHBUF
	;mov	ax,5
	MOV	AX,error_access_denied
	call	LcritDisk
	retn

NODEEXISTSPOPDEL:
	POP	DX		; Parent
	POP	DX		; Entry sector
	; MSDOS 6.0 
	;POP	word [HIGH_SECTOR] ; F.C. >32mb
	LES	BP,[THISDPB]
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	XOR	AL,AL		; Pre read
	call	GETBUFFR
	JC	short NODEEXISTSP
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	SI		; dir_first pointer
	ADD	SI,DI
	;sub	si,1Ah ; 26
	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
	MOV	BYTE [SI],0E5H	; Free the entry
	CALL	DIRUP		; Error doesn't matter since erroring anyway
NODEEXISTS:
	JMP	NODEACCERRJ ; 10/08/2018

NODEEXISTSP:
	POP	SI		; Clean stack
	JMP	short NODEEXISTS

;BREAK <DOS_ChDir -- Verify a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_ChDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used May not be NUL
; Function:
;	Validate the path for potential new current directory
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;	    CX is cluster number of the DIR, LOCAL CDS ONLY
;		Caller must NOT set ID fields on a NET CDS.
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path
;		error_access_denied
;			device or file name
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm and dir2.asm. DS already set up.

DOS_CHDIR:
	call	TestNet
	JNC	short LOCAL_CHDIR

;IF NOT Installed
;	transfer NET_CHDIR
;ELSE
	;mov	ax,1105h
	MOV	AX,(MultNET<<8)|5
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

LOCAL_CHDIR:
	call	EcritDisk
	; MSDOS 6.0
	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
	;JZ	short nojoin			   ;PTM.
	;MOV	word [ES:DI+curdir.ID],0FFFFH	   ;PTM.
;nojoin:
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	byte [NoSetDir],0 ; FALSE
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
				; Dir calls can find these
; DOS 3.3  6/24/86 FastOpen
	OR	byte [FastOpenFlg],FastOpen_Set	   ; set fastopen flag
	call	GETPATH
	;PUSHF							;AN000;
	;AND	byte [FastOpenFlg],Fast_yes	   ; clear it all ;AC000;
	;POPF							;AN000;
; DOS 3.3  6/24/86 FastOpen

	; MSDOS 3.3
	mov	byte [FastOpenFlg],0
	;mov	ax,3
	MOV	AX,error_path_not_found
	JC	short ChDirDone
	JNZ	short NOTDIRPATH	; Path not a DIR
	MOV	CX,[DIRSTART]		; Get cluster number
	CLC
ChDirDone:
	call	LcritDisk
	retn

;BREAK <DOS_RmDir -- Remove a directory>
;----------------------------------------------------------------------------
;
; Procedure Name : DOS_RmDir
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;		terminated)
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;		(Low word = -1 if NUL CDS (Net direct request))
; Function:
;	Remove a directory
;	NOTE: Attempt to remove current directory must be detected by caller
; Returns:
;	NOTE:
;	    [SATTRIB] is modified by this call
;	Carry Clear
;		No error
;	Carry Set
;	    AX is error code
;		error_path_not_found
;			Bad path (not in curr dir part if present)
;		error_bad_curr_dir
;			Bad path in current directory part of path
;		error_access_denied
;			device or file name, root directory
;			Bad directory ('.' '..' messed up)
; DS preserved, Others destroyed
;----------------------------------------------------------------------------

;hkn; called from path.asm. DS already set up.

DOS_RMDIR:
	call	TestNet
	JNC	short LOCAL_RMDIR

;IF NOT Installed
;	transfer NET_RMDIR
;ELSE
	;mov	ax,1101h
	MOV	AX,(MultNET<<8)|1
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
			; SS = DOS CS
			; SDA first filename pointer -> fully-qualified directory name
			; SDA CDS pointer -> current directory
			; Return: CF set on error, AX = DOS error code
			; CF clear if successful
	retn
;ENDIF

LOCAL_RMDIR:
	call	EcritDisk
	MOV	byte [NoSetDir],0
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
					; Dir calls can find these
	call	GETPATH
	JC	short NOPATH		; Path not found
	JNZ	short NOTDIRPATH	; Path not a DIR
	MOV	DI,[DIRSTART]
	OR	DI,DI			; Root ?
	JNZ	short rmdir_get_buf	; No
	JMP	SHORT NOTDIRPATH

NOPATH:
	;mov	ax,3
	MOV	AX,error_path_not_found
	JMP	_BadRet

NOTDIRPATHPOP:
	; MSDOS 6.0
	;POP	AX			  ;F.C. >32mb
	POP	AX
NOTDIRPATHPOP2:
	POP	AX
NOTDIRPATH:
	JMP	NODEACCERRJ

rmdir_get_buf:
	LDS	DI,[CURBUF]
	SUB	BX,DI		; Compute true offset
	PUSH	BX		; Save entry pointer
	
	; MSDOS 6.0
	;PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	;context ES
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	MOV	AL,'?'
	MOV	CX,11
	REP	STOSB
	XOR	AL,AL
	STOSB				; Nul terminate it
	call	STARTSRCH		; Set search
	call	GETENTRY		; Get start of directory
	JC	short NOTDIRPATHPOP	; Screw up
	MOV	DS,[CURBUF+2]
	MOV	SI,BX
	LODSW
	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
	cmp	ax,202Eh ; ". "
	JNZ	short NOTDIRPATHPOP	; Nope
	;add     si,30
	ADD	SI,dir_entry.size-2 ; Next entry
	LODSW
	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
	;cmp	ax, '..'
	cmp	ax,2E2Eh
	JNZ	short NOTDIRPATHPOP	; Nope

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	MOV	word [LASTENT],2	; Skip . and ..
	call	GETENTRY		; Get next entry
	JC	short NOTDIRPATHPOP	; Screw up
	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
	call	SRCH			; Do a search
	JNC	short NOTDIRPATHPOP	; Found another entry!
	CMP	byte [FAILERR],0
	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
	LES	BP,[THISDPB]
	MOV	BX,[DIRSTART]
	call	RELEASE 		; Release data in sub dir
	JC	short NOTDIRPATHPOP	; Screw up
	POP	DX			; Sector # of entry
	;POP	word [HIGH_SECTOR]	; F.C. >32mb
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	XOR	AL,AL			; Pre read
	call	GETBUFFR		; Get sector back
	JC	short NOTDIRPATHPOP2	; Screw up
	LDS	DI,[CURBUF]
	;or	byte [di+5],4
	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
	POP	BX			; Pointer to start of entry
	ADD	BX,DI			; Corrected
	MOV	BYTE [BX],0E5H		; Free the entry

;DOS 3.3 FastOpen  6/16/86  F.C.
	PUSH	DS

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds

	; MSDOS 6.0
	;call	FastOpen_Delete 	; call fastopen to delete an entry

	; MSDOS 3.3
_FastOpen_Delete:
	push	ax
	mov	si,[WFP_START]
	mov	bx,FastTable
	;mov	al,3  ; FONC_delete
	mov	al,FONC_delete
	call	far [BX+2]  ; FastTable+2
	pop	ax

	POP	DS
;DOS 3.3 FastOpen  6/16/86  F.C.

	JMP	DIRUP			; In MKDIR, dirty buffer and flush

;============================================================================
; DISK.ASM, MSDOS 6.0, 1991
;============================================================================
; 23/07/2018 - Retro DOS v3.0 

;	TITLE	DISK - Disk utility routines
;	NAME	Disk

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	SWAPCON
;	SWAPBACK
;	DOS_READ
;	DOS_WRITE
;	get_io_sft
;	DirRead
;	FIRSTCLUSTER
;	SET_BUF_AS_DIR
;	FATSecRd
;	DREAD
;	CHECK_WRITE_LOCK
;	CHECK_READ_LOCK
;
;	Revision history:
;
;		A000   version 4.00  Jan. 1988
;
;----------------------------------------------------------------------------
;
; M065 : B#5276. On raw read/write of a block of characters if a critical
;		error happens, DOS retries the entire block assuming that
;		zero characters were transferred. Modified the code to take
;		into account the number of characters transfered before
;		retrying the operation.
;
;----------------------------------------------------------------------------
;

;Installed = TRUE

;Break	<SwapCon, Swap Back - Old-style I/O to files>

; **** Drivers for file input from devices ****
;----------------------------------------------------------------------------
;   Indicate that there is no more I/O occurring through another SFT outside
;   of handles 0 and 1
;
;   Inputs:	DS is DOSDATA
;   Outputs:	CONSWAP is set to false.
;   Registers modified: none
;----------------------------------------------------------------------------

; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h

SWAPBACK:
	MOV	BYTE [CONSWAP],0	; signal no conswaps
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : SWAPCON
;
;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
;
;   Inputs:	ThisSFT as the sft of the desired file
;		DS is DOSDATA
;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
;   Registers modified: none
;--------------------------------------------------------------------------

SWAPCON:
	; MSDOS 3.3
	;push	es
	;push	di
	;mov	byte [CONSWAP],1
	;les	di,[THISSFT]
	;mov	word [CONSFT],di
	;mov	word [CONSFT+2],es
	;pop	di
	;pop	es
	;retn

	; MSDOS 6.0
	mov	byte [CONSWAP],1	; ConSwap = TRUE
	push	ax
	mov	ax,[THISSFT]
	mov	[CONSFT],ax
	mov	ax,[THISSFT+2]
	mov	[CONSFT+2],ax
	pop	ax
	retn


;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
;-----------------------------------------------------------------------------
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to read
;	DS = DOSDATA
; Function:
;	Perform read operation
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes read
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;
;-----------------------------------------------------------------------------

;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.

DOS_READ:
	LES	DI,[THISSFT]

; Verify that the sft has been opened in a mode that allows reading.

	;mov	al,[es:di+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0Fh
	AND	AL,access_mask
	;cmp	al,1
	CMP	AL,open_for_write
	JNE	short READ_NO_MODE		;Is read or both
	jmp	SET_ACC_ERR

READ_NO_MODE:
	call	SETUP
	JCXZ	NoIORet 		; no bytes to read - fast return
	call	IsSFTNet
	JZ	short LOCAL_READ

;IF NOT Installed
;	transfer NET_READ
;ELSE
	;mov	ax,1108h
	MOV	AX,(MultNET<<8)|8
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
			; Return: CF set on error, CX = bytes read
	retn
;ENDIF

; The user ended up requesting 0 bytes of input.  We do nothing for this case
; except return immediately.

NoIORet:
	CLC
	retn

LOCAL_READ:
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
	JNZ	short READDEV
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	EcritDisk
	call	DISKREAD

critexit:
	call	LcritDisk
	retn

; We are reading from a device. Examine the status of the device to see if we
; can short-circuit the I/O. If the device in the EOF state or if it is the
; null device, we can safely indicate no transfer.

READDEV:
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;mov	bl,[es:di+5]
	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
	LES	DI,[DMAADD]
	;test	bl,40h
	test	BL,devid_device_EOF	; End of file?
	JZ	short ENDRDDEVJ3
	;test	bl,4
	test	BL,devid_device_null	; NUL device?
	JZ	short TESTRAW 		; NO
	XOR	AL,AL			; Indicate EOF by setting zero
ENDRDDEVJ3:
	JMP	ENDRDDEVJ2

;
; We need to hit the device.  Figure out if we do a raw read or we do the
; bizarre std_con_string_input.
;
TESTRAW:
	;test	bl,20h
	test	BL,devid_device_raw	; Raw mode?
	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
	;test	bl,1
	test	BL,devid_device_con_in	; Is it console device?
	JZ	short NOTRDCON
	JMP	READCON

DVRDRAW:
	PUSH	ES
	POP	DS			; Xaddr to DS:DI

	; MSDOS 6.0
;SR;
;Check for win386 presence -- if present, do polled read of characters
;
	;test	byte [ss:IsWIN386],1
	;jz	short ReadRawRetry	;not present
	;test	bl,devid_device_con_in	;is it console device
	;jz	short ReadRawRetry	;no, do normal read
	;jmp	do_polling		;yes, do win386 polling loop

ReadRawRetry:
	MOV	BX,DI			; DS:BX transfer addr
	XOR	AX,AX			; Media Byte, unit = 0
	MOV	DX,AX			; Start at 0
	call	SETREAD
	PUSH	DS			; Save Seg part of Xaddr

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	call	DEVIOCALL
	MOV	DX,DI			; DS:DX is preserved by INT 24
	MOV	AH,86H			; Read error

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	; MSDOS 3.3
	;test	di,8000h
	;jz	short CRDROK
	; MSDOS 6.0
	or	di,di
	jns	short CRDROK		; no errors
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD
	MOV	DI,DX			; DS:DI is Xaddr

	; MSDOS 6.0
	;add	di,[ss:callscnt]	; update ptr and count to reflect the	M065
	;sub	cx,[ss:callscnt]	; number of chars xferred		M065

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL
	JZ	short CRDROK		; Ignore
	CMP	AL,3
	JZ	short CRDFERR 		; fail.
	POP	DS			; Recover saved seg part of Xaddr
	; 19/05/2019
	JMP	short ReadRawRetry	; Retry

;
; We have encountered a device-driver error.  We have informed the user of it
; and he has said for us to fail the system call.
;
CRDFERR:
	POP	DI			; Clean stack
DEVIOFERR:

;hkn; SS override
	LES	DI,[SS:THISSFT]
	jmp	SET_ACC_ERR_DS

CRDROK:
	POP	DI			; Chuck saved seg of Xaddr
	MOV	DI,DX

;hkn; SS override
	ADD	DI,[ss:CALLSCNT]	; Amount transferred
	JMP	SHORT ENDRDDEVJ3

; We are going to do a cooked read on some character device. There is a
; problem here, what does the data look like? Is it a terminal device, line
; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
; included in data). this "simulates" the way con works in cooked mode
; reading one line at a time. With file data, however, the lines will look
; like, LF line CR. This is a little weird.

NOTRDCON:
	MOV	AX,ES
	MOV	DS,AX
	MOV	BX,DI
	XOR	DX,DX
	MOV	AX,DX
	PUSH	CX
	MOV	CX,1
	call	SETREAD
	POP	CX

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	;lds	si,[si+7]
	LDS	SI,[SI+SF_ENTRY.sf_devptr]
DVRDLP:
	call	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI		; Save "count" done
	MOV	AH,86H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	
	; MSDOS 3.3
	;test	di, 8000h
	;jz	short CRDOK
	; MSDOS 6.0
	or	di,di
	jns	short CRDOK
	
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	word [SS:CALLSCNT],1
	CMP	AL,1
	JZ	short DVRDLP		;Retry
	CMP	AL,3
	JZ	short DEVIOFERR		; FAIL
	XOR	AL,AL			; Ignore, Pick some random character
	JMP	SHORT DVRDIGN

CRDOK:
	POP	DI

;hkn; SS override
	CMP	word [SS:CALLSCNT],1
	JNZ	short ENDRDDEVJ2
	PUSH	DS

;hkn; SS override
	MOV	DS,[SS:CALLXAD+2]
	MOV	AL,[DI]			; Get the character we just read
	POP	DS
DVRDIGN:

;hkn; SS override
	INC	WORD [SS:CALLXAD]	; Next character
	MOV	word [SS:DEVCALL_REQSTAT],0
	INC	DI			; Next character
	CMP	AL,1AH			; ^Z?
	JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
	CMP	AL,c_CR 		; CR?
	LOOPNZ	DVRDLP			; Loop if no, else done
	INC	AX			; Resets zero flag so NOT EOF, unless
					;  AX=FFFF which is not likely
ENDRDDEVJ2:
	JMP	short ENDRDDEV		;changed short to long for win386

	;  MSDOS 6.0
;;SR;
;;Polling code for raw read on CON when WIN386 is present
;;
;;At this point -- ds:di is transfer address
;;		  cx is count
;;
;
;do_polling:
;	mov	bx,di			;ds:bx is Xfer address
;	xor	ax,ax
;	mov	dx,ax
;	call	setread			;prepare device packet
;
;do_io:
;;
;;Change read to a NON-DESTRUCTIVE READ, NO WAIT
;;
;	mov	byte ptr es:[bx+2],DEVRDND	;Change command code
;	push	ds
;	lds	si,[THISSFT]		;get device header
;	call	deviocall		;call device driver
;	pop	ds
;	
;	test	es:[bx.REQSTAT],STERR	;check if error
;	jz	check_busy		;no
;
;	push	ds
;	mov	dx,di
;	invoke 	charhard		;invoke int 24h handler
;	mov	di,dx
;	or	al,al
;	jz	pop_done_read		;ignore by user, assume read done
;	cmp	al,3
;	jz	devrderr		;user asked to fail
;	pop	ds
;	jmp	do_io			;user asked to retry
;
;check_busy:
;	test	es:[bx.REQSTAT],0200h	;see if busy bit set
;	jnz	no_char			;yes, no character available
;;
;;Character is available. Read in 1 character at a time until all characters
;;are read in or no character is available
;;
;	mov	byte ptr es:[bx+2],DEVRD	;command code is READ now
;	mov	word ptr es:[bx+18],1		;change count to 1 character
;	push	ds
;	lds	si,[THISSFT]
;	call	deviocall
;
;	mov	dx,di
;	mov	ah,86h
;	mov	di,es:[bx.REQSTAT]	;get returned status
;	test	di,STERR		;was there an error during read?
;	jz	next_char		;no,read next character
;
;	invoke	charhard		;invoke int 24h handler
;	mov	di,dx			;restore di
;	or	al,al			;
;	jz	pop_done_read		;ignore by user,assume read is done
;	cmp	al,3
;	jz	devrderr		;user issued a 'fail',indicate error
;	pop	ds
;	jmp	do_io			;user issued a retry
;
;next_char:
;	pop	ds
;	mov	di,dx
;	dec	cx			;decrement count
;	jcxz	done_read		;all characters read in
;	inc	word ptr es:[bx+14]	;update transfer address
;	jmp	do_io			;read next character in
;
;devrderr:
;	pop	di			;discard segment address
;	les	di,[THISSFT]
;	transfer SET_ACC_ERR_DS		;indicate error
;
;no_char:
;;
;;Since no character is available, we let win386 switch the VM out
;;
;	push	ax
;	mov	ah,84h
;	int	2ah			;indicate idle to WIN386
;;
;;When control returns from WIN386, we continue the raw read
;;
;	pop	ax
;	jmp	do_io
;
;pop_done_read:
;	pop	ds
;done_read:
;	add	di,[CALLSCNT]
;	jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit

TRANBUF:
	LODSB
	STOSB
	CMP	AL,c_CR 	; Check for carriage return
	JNZ	short NORMCH
	MOV	BYTE [SI],c_LF
NORMCH:
	CMP	AL,c_LF
	LOOPNZ	TRANBUF
	JNZ	short ENDRDCON
	XOR	SI,SI		; Cause a new buffer to be read
	call	OUTT		; Transmit linefeed
	OR	AL,1		; Clear zero flag--not end of file
ENDRDCON:

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	CALL	SWAPBACK
	MOV	[CONTPOS],SI
ENDRDDEV:

;hkn; SS is DOSDATA
	push	ss
	pop	ds

	MOV	[NEXTADD],DI
	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
	LES	DI,[THISSFT]
	;and	byte [es:di+5],0BFh
	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
					; Mark as no more data available
SETSFTC:
	call	SETSFT
	retn

READCON:
	CALL	SWAPCON
	MOV	SI,[CONTPOS]
	OR	SI,SI
	JNZ	short TRANBUF
	CMP	BYTE [CONBUF],128
	JZ	short GETBUF
	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
GETBUF:
	PUSH	CX
	PUSH	ES
	PUSH	DI

;hkn; CONBUF is in DOSDATA
	MOV	DX,CONBUF

	call	_$STD_CON_STRING_INPUT	; Get input buffer
	POP	DI
	POP	ES
	POP	CX

;hkn; CONBUF is in DOSDATA
	MOV	SI,CONBUF+2

	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
	JNZ	short TRANBUF
	MOV	AL,1AH
	STOSB
	DEC	DI
	MOV	AL,c_LF
	call	OUTT		; Send linefeed
	XOR	SI,SI
	JMP	ENDRDCON

; 24/07/2018 - Retro DOS v3.0

;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
;---------------------------------------------------------------------------
;
; Procedure Name : DOS_WRITE
;
; Inputs:
;	ThisSFT set to the SFT for the file being used
;	[DMAADD] contains transfer address
;	CX = No. of bytes to write
; Function:
;	Perform write operation
;	NOTE: If CX = 0 on input, file is truncated or grown
;		to current sf_position
; Outputs:
;    Carry clear
;	SFT Position and cluster pointers updated
;	CX = No. of bytes written
;	ES:DI point to SFT
;    Carry set
;	AX is error code
;	CX = 0
;	ES:DI point to SFT
; DS preserved, all other registers destroyed
;---------------------------------------------------------------------------

;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
;hkn; point to DOSDATA.

DOS_WRITE:
	LES	DI,[THISSFT]
	;mov	al,[ES:DI+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0Fh
	AND	AL,access_mask
	;cmp	al,0
	CMP	AL,open_for_read
	JNE	short Check_FCB_RO		 ;Is write or both
BadMode:
	jmp	SET_ACC_ERR

;
; NOTE: The following check for writting to a Read Only File is performed
;	    ONLY on FCBs!!!!
;	We ALLOW writes to Read Only files via handles to allow a CREATE
;	    of a read only file which can then be written to.
;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
;	    CREATing a NEW RO file, or RE-CREATing an existing file which
;	    is NOT RO to be RO, via handles are the only times we can write
;	    to a read-only file.
;
Check_FCB_RO:
	;test	word [es:di+2],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	JZ	short WRITE_NO_MODE	; Not an FCB
	;test	byte [es:di+4],1
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
WRITE_NO_MODE:
	call	SETUP
	call	IsSFTNet
	JZ	short LOCAL_WRITE

;IF NOT Installed
;	transfer NET_WRITE
;ELSE
	;mov	ax,1109h
	MOV	AX,(MultNET<<8)|9
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
			; ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file
			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
			; Return: CF set on error, CX = bytes written
	retn
;ENDIF

LOCAL_WRITE:
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
	jnz	short WRTDEV
	;mov	byte [EXTERR_LOCUS],2
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	call	EcritDisk

	call	DISKWRITE

	; MSDOS 6.0
;; Extended Open
	;JC	short nocommit
	;LES	DI,[THISSFT]
	;TEST	word [ES:DI+SF_ENTRY.sf_mode],auto_commit_write
	;JZ	short nocommit
	;PUSH	CX
	;call	DOS_COMMIT
	;POP	CX
;nocommit:
;; Extended Open
	call	LcritDisk
	retn

DVWRTRAW:
	XOR	AX,AX			; Media Byte, unit = 0
	call	SETWRITE
	PUSH	DS			; Save seg of transfer

;hkn; SS override
	LDS	SI,[SS:THISSFT]
	call	DEVIOCALL		; DS:SI -> DEVICE

	MOV	DX,DI			; Offset part of Xaddr saved in DX
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]

	; MSDOS 3.3
	;test	di,8000h
	;jz	short CWRTROK

	; MSDOS 6.0
	or	di,di
	jns	short CWRTROK
	
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD

	; MSDOS 6.0
	;sub	cx,[ss:callscnt]	; update ptr & count to reflect	M065
	;mov	bx,dx			; number of chars xferred	M065
	;add	bx,[ss:callscnt]		;				M065
	;mov	di,bx			;				M065
	
	; MSDOS 3.3
	MOV	BX,DX			; Recall transfer addr		M065

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL
	JZ	short CWRTROK 		; Ignore
	CMP	AL,3
	JZ	short CWRFERR
	POP	DS			; Recover saved seg of transfer
	JMP	short DVWRTRAW		; Try again

CWRFERR:
	POP	AX			; Chuck saved seg of transfer
	JMP	CRDFERR 		; Will pop one more stack element

CWRTROK:
	POP	AX			; Chuck saved seg of transfer
	POP	DS
	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
ENDWRDEV:
	LES	DI,[THISSFT]
	MOV	CX,AX
	call	ADDREC
	retn

WRTNUL:
	MOV	DX,CX			;Entire transfer done
WRTCOOKJ:
	JMP	WRTCOOKDONE

WRTDEV:
	;mov	byte [EXTERR_LOCUS],4
	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
	;or	byte [es:di+5],40h
	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
					; Reset EOF for input
	;mov	bl,[es:di+5]
	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
	XOR	AX,AX
	JCXZ	ENDWRDEV		; problem of creating on a device.
	PUSH	DS
	MOV	AL,BL
	LDS	BX,[DMAADD]		; Xaddr to DS:BX
	MOV	DI,BX			; Xaddr to DS:DI
	XOR	DX,DX			; Set starting point
	;test	al,20h
	test	AL,devid_device_raw	; Raw?
	;JZ	short TEST_DEV_CON
	;JMP	DVWRTRAW
	jnz	short DVWRTRAW

TEST_DEV_CON:
	;test	al,2
	test	AL,devid_device_con_out ; Console output device?
	jnz	short WRITECON
	;test	al,4
	test	AL,devid_device_null
	JNZ	short WRTNUL
	MOV	AX,DX
	CMP	BYTE [BX],1Ah		; ^Z?
	JZ	short WRTCOOKJ		; Yes, transfer nothing
	PUSH	CX
	MOV	CX,1
	call	SETWRITE
	POP	CX

;hkn; SS override
	LDS	SI,[SS:THISSFT]
;
;SR; Removed X25 support from here
;
	;lds	si,[si+7]
	LDS	SI,[SI+SF_ENTRY.sf_devptr]
DVWRTLP:
	call	DSKSTATCHK
	call	DEVIOCALL2
	PUSH	DI
	MOV	AH,87H

;hkn; SS override
	MOV	DI,[SS:DEVCALL_REQSTAT]
	
	; MSDOS 3.3
	;test	di,8000h
	;jz	short CWROK

	; MSDOS 6.0
	or	di,di
	jns	short CWROK
	
	; MSDOS 3.3 (& MSDOS 6.0)
	call	CHARHARD
	POP	DI

;hkn; SS override
	MOV	word [SS:CALLSCNT],1
	CMP	AL,1
	JZ	short DVWRTLP 	; Retry
	OR	AL,AL
	JZ	short DVWRTIGN	; Ignore
	; 10/08/2018
	JMP	CRDFERR 	; Fail, pops one stack element

CWROK:
	POP	DI

;hkn; SS override
	CMP	word [SS:CALLSCNT],0
	JZ	short WRTCOOKDONE
DVWRTIGN:
	INC	DX

;hkn; SS override for CALLXAD
	INC	WORD [SS:CALLXAD]
	INC	DI
	PUSH	DS
	MOV	DS,[SS:CALLXAD+2]
	CMP	BYTE [DI],1Ah	; ^Z?
	POP	DS
	JZ	short WRTCOOKDONE

;hkn; SS override
	MOV	word [SS:DEVCALL_REQSTAT],0
	LOOP	DVWRTLP
WRTCOOKDONE:
	MOV	AX,DX
	POP	DS
	JMP	ENDWRDEV ; 10/08/2018

WRITECON:
	PUSH	DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	CALL	SWAPCON
	POP	DS
	MOV	SI,BX
	PUSH	CX
WRCONLP:
	LODSB
	CMP	AL,1Ah		; ^Z?
	JZ	short CONEOF
	call	OUTT
	LOOP	WRCONLP
CONEOF:
	POP	AX			; Count
	SUB	AX,CX			; Amount actually written
	POP	DS
	CALL	SWAPBACK
	JMP	ENDWRDEV

;---------------------------------------------------------------------------
;
; Procedure Name : get_io_sft
;
;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
;   CONSWAP is FALSE or if the handle desired is 2 or more.  Otherwise, we
;   retrieve the sft from ConSFT which is set by SwapCon.
;
;---------------------------------------------------------------------------

GET_IO_SFT:
	;test	byte [SS:CONSWAP],0FFh
	cmp	byte [SS:CONSWAP],0			;smr;SS Override
	JNZ	short GetRedir
GetNormal:
	push	ss
	pop	ds
	PUSH	ES
	PUSH	DI
	call	SFFromHandle
	JC	short RET44P
	MOV	SI,ES
	MOV	DS,SI
	MOV	SI,DI
RET44P:
	POP	DI
	POP	ES
	retn
GetRedir:
	CMP	BX,1
	JA	short GetNormal
	LDS	SI,[SS:CONSFT]
	CLC
get_io_sft_retn:
	retn

;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : DIRREAD
;
; Inputs:
;	AX = Directory block number (relative to first block of directory)
;	ES:BP = Base of drive parameters
;	[DIRSEC] = First sector of first cluster of directory
;	[CLUSNUM] = Next cluster
;	[CLUSFAC] = Sectors/Cluster
; Function:
;	Read the directory block into [CURBUF].
; Outputs:
;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
;	[SECCLUSPOS] Set
;	ES:BP unchanged
;	[CURBUF] Points to Buffer with dir sector
;	Carry set if error (user said FAIL to I 24)
; DS preserved, all other registers destroyed.
;---------------------------------------------------------------------------

;hkn; called from dir.asm. DS already set up to DOSDATA.

DIRREAD:

; Note that ClusFac is the sectors per cluster. This is NOT necessarily
; the same as what is in the DPB! In the case of the root directory, we have
; ClusFac = # sectors in the root directory. The root directory is detected
; by DIRStart = 0.

	XOR	DX,DX
	CMP	word [DIRSTART],0
	jnz	short SubDir
	XCHG	AX,DX
	JMP	short DoRead

; Convert the sector number in AX into cluster and sector-within-cluster pair

SubDir:
	MOV	DL,AL
	;and	dl,[es:bp+4]
	AND	DL,[ES:BP+DPB.CLUSTER_MASK]

;	(DX) = sector-in-cluster

	;mov	cl,[es:bp+5]
	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	SHR	AX,CL

;	(DX) = position in cluster
;	(AX) = number of clusters to skip

DoRead:
	MOV	[SECCLUSPOS],DL
	MOV	CX,AX
	MOV	AH,DL

;	(CX) = number of clusters to skip.
;	(AH) = remainder

	; MSDOS 6.0
	;MOV	DX,[DIRSEC+2]	     	  ;>32mb
	;MOV	[HIGH_SECTOR],DX	  ;>32mb
	MOV	DX,[DIRSEC]
	ADD	DL,AH
	ADC	DH,0
	;ADC	word [HIGH_SECTOR],0	  ;>32mb

	MOV	BX,[CLUSNUM]
	MOV	[NXTCLUSNUM],BX
	JCXZ	FIRSTCLUSTER
SKPCLLP:
	call	UNPACK
	jc	short get_io_sft_retn
	XCHG	BX,DI
	call	IsEOF			; test for eof based on fat size
	JAE	short HAVESKIPPED
	LOOP	SKPCLLP
HAVESKIPPED:
	MOV	[NXTCLUSNUM],BX
	MOV	DX,DI
	MOV	BL,AH
	call	FIGREC

	;entry	FIRSTCLUSTER

FIRSTCLUSTER:
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
	XOR	AL,AL		; Indicate pre-read
	call	GETBUFFR
	jc	short get_io_sft_retn

	;entry	SET_BUF_AS_DIR

SET_BUF_AS_DIR:

;	Set the type of CURBUF to be a directory sector.
;	Only flags are modified.

	PUSH	DS
	PUSH	SI
	LDS	SI,[CURBUF]
	;or	byte [si+5],4
	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
	POP	SI
	POP	DS
dirread_retn:
	retn

;Break	<FATSECRD -- READ A FAT SECTOR>
;----------------------------------------------------------------------------
;
; Procedure Name : FATSECRD
; Inputs:
;	Same as DREAD
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number
;	ES:BP = Base of drive parameters
; Function:
;	Calls BIOS to perform FAT read.
; Outputs:
;	Same as DREAD
;---------------------------------------------------------------------------

FATSECRD:
;hkn; SS override
	;mov	byte [ss:ALLOWED],18h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
	MOV	DI,CX
	;mov	cl,[es:bp+8]
	MOV	CL,[ES:BP+DPB.FAT_COUNT]
	; MSDOS 6.0
	;MOV	AX,[ES:BP+DPB.FAT_SIZE] 	;>32mb
	; MSDOS 3.3
	;mov	al,[es:bp+0Fh]
	MOV	AL,[ES:BP+DPB.FAT_SIZE] 
	XOR	AH,AH
	XOR	CH,CH				;>32mb
	PUSH	DX
NXTFAT:
	; MSDOS 6.0
;hkn; SS override
	;MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
	PUSH	CX			;32mb
	PUSH	AX
	MOV	CX,DI
	call	DSKREAD
	POP	AX
	POP	CX
	JZ	short RET41P		; Carry clear
	ADD	DX,AX
	LOOP	NXTFAT
	POP	DX
	MOV	CX,DI

; NOTE FALL THROUGH

;Break	<DREAD -- DO A DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DREAD
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	DX = Absolute record number	      (LOW)
;	[HIGH_SECTOR]= Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case call to HARDERR needed
; Function:
;	Calls BIOS to perform disk read. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Outputs:
;	Carry set if error (currently user FAILED to INT 24)
; DS,ES:BP preserved. All other registers destroyed.
;---------------------------------------------------------------------------

	;entry	DREAD
DREAD:
	call	DSKREAD
	jz	short dirread_retn	; Carry clear
;hkn; SS override
	MOV	BYTE [SS:READOP],0
	call	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	short DREAD
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	short NO_CAR		; Ignore
	STC
NO_CAR:
	retn
RET41P: 
	POP	DX
	retn

; 24/07/2018 - Retro DOS v3.0

;Break	<CHECK_WRITE_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_WRITE_LOCK
;
; Inputs:
;	output of SETUP
;	ES:DI -> SFT
; Function:
;	check write lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;
;----------------------------------------------------------------------------

CHECK_WRITE_LOCK:
	; MSDOS 6.0
	;test	byte [es:di+4],8
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
	;JZ	short write_cont			     ;no
	;call	SET_ACC_ERR_DS		;
	;retn
	;jnz	SET_ACC_ERR_DS
	; 19/08/2018
	jz	short write_cont
	jmp	SET_ACC_ERR_DS
write_cont:				;
	PUSH	CX			;save reg
	OR	CX,CX			;
	JNZ	short Not_Truncate	;
	dec	cx			;(cx) = -1; check for lock on whole file
Not_Truncate:				;
	MOV	AL,80H			;check write access
	call	LOCK_CHECK		;check lock
	POP	CX			;restore reg
	JNC	short WRITE_OK		;lock ok
	call	WRITE_LOCK_VIOLATION	;issue I24
	JNC	short write_cont	;retry
WRITE_OK:				;
	retn				;

;Break	<CHECK_READ_LOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_READ_LOC
;
; Inputs:
;	ES:DI -> SFT
;	output of SETUP
; Function:
;	check read lock
; Outputs:
;	Carry set if error
;	Carry clear if ok
;----------------------------------------------------------------------------

CHECK_READ_LOCK:
	; MSDOS 6.0
	;test	byte [es:di+4],8
	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
	;JZ	short do_retry			   	     ; no
	;call	SET_ACC_ERR		;
	;retn
	jnz	SET_ACC_ERR		;
do_retry:				;
	xor	al,al			;check read access
	call	LOCK_CHECK		;check lock
	JNC	short READLOCK_OK 	;lock ok
	call	READ_LOCK_VIOLATION	;issue I24
	JNC	short do_retry		;retry
READLOCK_OK:				;
	retn				;

;============================================================================
; DISK2.ASM, MSDOS 6.0, 1991
;============================================================================
; 24/07/2018 - Retro DOS v3.0 

;	TITLE	DISK2 - Disk utility routines
;	NAME	Disk2

;**	Low level Read and write routines for local SFT I/O on files and devs
;
;	DskRead
;	DWRITE
;	DSKWRITE
;	HarderrRW
;	SETUP
;	BREAKDOWN
;	READ_LOCK_VIOLATION
;	WRITE_LOCK_VIOLATION
;	DISKREAD
;	SET_ACC_ERR_DS
;	SET_ACC_ERR
;	SETSFT
;	SETCLUS
;	AddRec
;
;	Revision history:
;
;		AN000 version 4.00 Jan. 1988
;		M039 DB 10/17/90 - Disk read/write optimization

;Break	<DSKREAD -- PHYSICAL DISK READ>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKREAD
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;---------------------------------------------------------------------------

DSKREAD:
	PUSH	CX
	;mov	ah,[es:bp+16h]
	MOV	AH,[ES:BP+DPB.MEDIA]
	;mov	al,[es:bp+1]
	MOV	AL,[ES:BP+DPB.UNIT]
	PUSH	BX
	PUSH	ES
	call	SETREAD
	JMP	short DODSKOP

;Break	<DWRITE -- SEE ABOUT WRITING>
;--------------------------------------------------------------------------
;
; Procedure Name : DWRITE
;
; Inputs:
;	DS:BX = Transfer address
;	CX = Number of sectors
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	DX = Absolute record number	       (LOW)
;	ES:BP = Base of drive parameters
;	[ALLOWED] must be set in case HARDERR called
; Function:
;	Calls BIOS to perform disk write. If BIOS reports
;	errors, will call HARDERRRW for further action.
; Output:
;	Carry set if error (currently, user FAILed to I 24)
; BP preserved. All other registers destroyed.
;----------------------------------------------------------------------------


	;entry	DWRITE
DWRITE:
	CALL	DSKWRITE
	jz	short dw_ret_label	; Carry clear (retz)

;hkn; SS override
	MOV	BYTE [SS:READOP],1
	call	HARDERRRW
	CMP	AL,1		; Check for retry
	JZ	short DWRITE
	CMP	AL,3		; Check for FAIL
	CLC
	JNZ	short NO_CAR2 	; Ignore
	STC
NO_CAR2:
dw_ret_label:
	retn

;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
;---------------------------------------------------------------------------
;
; Procedure Name : DSKWRITE
;
; Inputs:
;	DS:BX = Transfer addr
;	CX = Number of sectors
;	DX = Absolute record number	       (LOW)
;	[HIGH_SECTOR] = Absolute record number (HIGH)
;	ES:BP = Base of drive parameters
; Function:
;	Call BIOS to perform disk read
; Outputs:
;	DI = CX on entry
;	CX = Number of sectors unsuccessfully transfered
;	AX = Status word as returned by BIOS (error code in AL if error)
;	Zero set if OK (from BIOS) (carry clear)
;	Zero clear if error (carry clear)
; SI Destroyed, others preserved
;
;----------------------------------------------------------------------------

	;entry	DSKWRITE
DSKWRITE:
	PUSH	CX
	;mov	ah,[es:bp+16h]
	MOV	AH,[ES:BP+DPB.MEDIA]
	;mov	al,[es:bp+1]
	MOV	AL,[ES:BP+DPB.UNIT]
	PUSH	BX
	PUSH	ES
	call	SETWRITE
DODSKOP:
	MOV	CX,DS		; Save DS
	POP	DS		; DS:BP points to DPB
	PUSH	DS
	;lds	si,[ds:bp+12h]
	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
	call	DEVIOCALL2
	MOV	DS,CX		; Restore DS
	POP	ES		; Restore ES
	POP	BX

;hkn; SS override
	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
	POP	DI
	SUB	CX,DI
	NEG	CX		; Number of sectors not transferred

;hkn; SS override
	MOV	AX,[SS:DEVCALL_REQSTAT]
	;test	ax,8000h
	test	AX,STERR
	retn

;Break	<HardErrRW - map extended errors and call harderr>
;---------------------------------------------------------------------------
;
; Procedure Name : HardErrRW
;
; Inputs:
;	AX is error code from read or write
;	Other registers set as per HARDERR
; Function:
;	Checks the error code for special extended
;	errors and maps them if needed. Then invokes
;	Harderr
; Outputs:
;	Of HARDERR
; AX may be modified prior to call to HARDERR.
; No other registers altered.
;
;---------------------------------------------------------------------------

HARDERRRW:
	;cmp	al,0Fh
	CMP	AL,error_I24_wrong_disk
	JNZ	short DO_ERR				; Nothing to do

	; MSDOS 3.3
	;push	ds
	;push	si
	;lds	si,[ss:CALLVIDRW]
	;mov	[ss:EXTERRPT+2], ds
	;mov	[ss:EXTERRPT], si
	;pop	si
	;pop	ds

	; MSDOS 6.0
	push	ax
	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
	pop	ax
DO_ERR:
	call	HARDERR
	retn

; 24/07/2018 - Retro DOS v3.0

;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
;----------------------------------------------------------------------------
;
; Procedure Name : SETUP
;
; Inputs:
;	ES:DI point to SFT (value also in THISSFT)
;	DMAAdd contains transfer address
;	CX = Byte count
;	DS = DOSDATA
;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
;		2nd of caller of caller.
; Outputs:
;	    CX = byte count
;	    [THISDPB] = Base of drive parameters if file
;		      = Pointer to device header if device or NET
;	    ES:DI Points to SFT
;	    [NEXTADD] = Displacement of disk transfer within segment
;	    [TRANS] = 0 (No transfers yet)
;	    BytPos = Byte position in file
;
;	The following fields are relevant to local files (not devices) only:
;
;	    SecPos = Position of first sector (local files only)
;	    [BYTSECPOS] = Byte position in first sector (local files only)
;	    [CLUSNUM] = First cluster (local files only)
;	    [SECCLUSPOS] = Sector within first cluster (local files only)
;	    [THISDRV] = Physical unit number (local files only)
;
;      RETURNS ONE LEVEL UP WITH:
;	   CX = 0
;	   CARRY = Clear
;	IF AN ERROR IS DETECTED
; All other registers destroyed
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS has been set up to DOSDATA.

SETUP:
	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh

	;lds 	si,[es:di+7]
	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]

;hkn; SS override
	MOV	[SS:THISDPB+2],DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds

	MOV	[THISDPB],SI

	MOV	BX,[DMAADD]
	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
	MOV	BYTE [TRANS],0		;No transferes
	;mov	ax,[es:di+15h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
	;mov	dx,[es:di+17h]
	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
	MOV	[BYTPOS+2],DX	;Set it
	MOV	[BYTPOS],AX
	;test	word [es:di+5],8080h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
	JNZ	short NOSETSTUFF	;Following not done on devs or NET
	PUSH	ES
	LES	BP,[THISDPB]		;Point at the DPB
	;mov	bl,[es:bp+0]
	;MOV	BL,[ES:BP+DPB.drive]
	mov	bl,[es:bp]
	MOV	[THISDRV],BL		;Set THISDRV
	;mov	bx,[es:bp+2]
	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]

	; MSDOS 3.3
	cmp	dx, bx
	jnb	short EOFERR
	div	bx
	mov	[SECPOS],ax
	mov	[BYTSECPOS],dx
	mov	dx,ax
	;and	al,[es:bp+4]
	AND	AL,[ES:BP+DPB.CLUSTER_MASK]
	mov	[SECCLUSPOS],al
	mov	ax,cx
	;mov	cl,[es:bp+5]
	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	shr	dx,cl
	mov	[CLUSNUM],dx
	pop	es
	mov	cx,ax

	; MSDOS 6.0
;M039: Optimized this section.
        ;PUSH    CX                            ;SHR32 and DIV32 use CX.
	;call	DIV32			      ;DX:AX/BX = CX:AX + DX (rem)
	;MOV	[BYTSECPOS],DX
	;MOV	[SecPos],AX
	;MOV	[SecPos+2],CX
	;MOV	DX,CX

	;MOV	BX,AX
	;;and	bl,[es:bp+4]
	;AND	BL,[ES:BP+DPB.CLUSTER_MASK]
	;MOV	[SECCLUSPOS],BL

	;call	SHR32			     ;(DX:AX SHR dpb_cluster_shift)
	;POP	CX			     ;CX = byte count.
	;JNZ	short EOFERR		     ;cluster number above 64k
	;CMP	AX,[ES:BP+DPB.MAX_CLUSTER]   ;>32mb    if > disk size ;AN000;
	;JA	short EOFERR		     ;>32mb    then EOF       ;AN000;

	;MOV	[CLUSNUM],AX
	;POP	ES			     ; ES:DI point to SFT
;M039

NOSETSTUFF:
	MOV	AX,CX		; AX = Byte count.
	ADD	AX,[DMAADD]	 ; See if it will fit in one segment
	JNC	short setup_OK		; Must be less than 64K
	MOV	AX,[DMAADD]
	NEG	AX		; Amount of room left in segment (know
				;    less than 64K since max value of CX
				;    is FFFF).
	JNZ	short NoDec
	DEC	AX
NoDec:
	MOV	CX,AX		; Can do this much
	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
setup_OK:
	retn

EOFERR:
	POP	ES		; ES:DI point to SFT
	XOR	CX,CX		; No bytes read
;;;;;;;;;;; 7/18/86
	; MSDOS 3.3
	MOV	BYTE [DISK_FULL],1 ; set disk full flag
;;;;;;;;;;;
NOROOM:
	POP	BX		; Kill return address
	CLC
	retn			; RETURN TO CALLER OF CALLER

;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
;---------------------------------------------------------------------------
;
; Procedure Name : BREAKDOWN
;
; Inputs:
;	CX = Length of disk transfer in bytes
;	ES:BP = Base of drive parameters
;	[BYTSECPOS] = Byte position within first sector
;	DS = DOSDATA
; Outputs:
;	[BYTCNT1] = Bytes to transfer in first sector
;	[SECCNT] = No. of whole sectors to transfer
;	[BYTCNT2] = Bytes to transfer in last sector
; AX, BX, DX destroyed. No other registers affected.
;---------------------------------------------------------------------------

BREAKDOWN:
	MOV	AX,[BYTSECPOS]
	MOV	BX,CX
	OR	AX,AX
	JZ	short SAVFIR	; Partial first sector?
	;sub	ax,[es:bp+2]
	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
	NEG	AX		; Max number of bytes left in first sector
	SUB	BX,AX		; Subtract from total length
	JAE	short SAVFIR
	ADD	AX,BX		; Don't use all of the rest of the sector
	XOR	BX,BX		; And no bytes are left
SAVFIR:
	MOV	[BYTCNT1],AX
	MOV	AX,BX
	XOR	DX,DX
	;div	word [ES:BP+2]
	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
	MOV	[SECCNT],AX
	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
	; MSDOS 3.3
;	OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
;	retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
;	CMP	AX,1
;	retnz
;	MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
;	MOV	[BYTCNT2],AX
;	MOV	[SECCNT],DX	; DX = 0
_RET45:
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : READ_LOCK_VIOLATION
;
; ES:DI points to SFT. This entry used by NET_READ
; Carry set if to return error (CX=0,AX=error_sharing_violation).
; Else do retrys.
; ES:DI,DS,CX preserved
;
;----------------------------------------------------------------------------

READ_LOCK_VIOLATION:
	MOV	byte [READOP],0
ERR_ON_CHECK:
	;test	word [es:di+2],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	JNZ	short HARD_ERR
	PUSH	CX
	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
	;and	cl,0F0h
	AND	CL,SHARING_MASK
	;cmp	cl,0
	CMP	CL,SHARING_COMPAT
	POP	CX
	JNE	short NO_HARD_ERR
HARD_ERR:
	call	LOCK_VIOLATION
	jnc	short _RET45		; User wants Retrys
NO_HARD_ERR:
	XOR	CX,CX			;No bytes transferred
	;mov	ax, 21h
	MOV	AX,error_lock_violation
	STC
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : WRITE_LOCK_VIOLATION
;
; Same as READ_LOCK_VIOLATION except for READOP.
; This entry used by NET_WRITE
;
;----------------------------------------------------------------------------

WRITE_LOCK_VIOLATION:
	MOV	byte [READOP],1
	JMP	short ERR_ON_CHECK

;Break	<DISKREAD -- PERFORM USER DISK READ>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKREAD
;
; Inputs:
;	Outputs of SETUP
; Function:
;	Perform disk read
; Outputs:
;    Carry clear
;	CX = No. of bytes read
;	ES:DI point to SFT
;	SFT offset and cluster pointers updated
;    Carry set
;	CX = 0
;	ES:DI point to SFT
;	AX has error code
;----------------------------------------------------------------------------

;hkn; called from disk.asm. DS already set up.

DISKREAD:
	;mov	ax,[es:di+11h]
	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
	;mov	bx,[es:di+13h]
	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
	SUB	AX,[BYTPOS]
	SBB	BX,[BYTPOS+2]
	JB	short RDERR		;Read starts past EOF
	JNZ	short ENUF		;More than 64k to EOF
	OR	AX,AX
	JZ	short RDERR		;Read starts at EOF
	CMP	AX,CX
	JAE	short ENUF		;I/O fits
	MOV	CX,AX			;Limit read to up til EOF
ENUF:
	; MSDOS 3.3
	;test	byte [es:di+4],8
	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
	;jnz	short SET_ACC_ERR
	;call	LOCK_CHECK
	;jnb	short _READ_OK
	;call	READ_LOCK_VIOLATION
	;jnb	short ENUF
	;retn

	; MSDOS 6.0
	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
	JNC	short _READ_OK 		; There are no locks
	retn

_READ_OK:
	LES	BP,[THISDPB]
	CALL	BREAKDOWN
	MOV	CX,[CLUSNUM]
	call	FNDCLUS
     	; MSDOS 6.0			;M022 conditional removed here
	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
					; migrated from 330a - HKN
	OR	CX,CX
	JZ	short SKIPERR
RDERR:
	MOV	AH,0EH			;MS. read/data/fail ;AN000;
	jmp	WRTERR22

;RDLASTJ: 
	;JMP	RDLAST                  ;M039

SETSFTJ2: 
	JMP	SETSFT

CANOT_READ:
	; MSDOS 3.3
	POP	CX		;M039.
	; MSDOS 3.3 (& MSDOS 6.0)
	POP	CX              ;Clean stack.
	POP	BX

	;entry	SET_ACC_ERR_DS
SET_ACC_ERR_DS:
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds

	;entry	SET_ACC_ERR
SET_ACC_ERR:
	XOR	CX,CX
	;mov	ax,5
	MOV	AX,error_access_denied
	STC
	retn

SKIPERR:
	MOV	[LASTPOS],DX
	MOV	[CLUSNUM],BX
	CMP	word [BYTCNT1],0
	JZ	short RDMID
	call	BUFRD
	JC	short SET_ACC_ERR_DS
RDMID:
	CMP	word [SECCNT],0
	JZ	RDLAST ; 10/08/2018
	call	NEXTSEC
	JC	short SETSFTJ2
	MOV	BYTE [TRANS],1		; A transfer is taking place
ONSEC:
	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
	MOV	CX,[SECCNT]
	MOV	BX,[CLUSNUM]
RDLP:
	call	OPTIMIZE
	JC	short SET_ACC_ERR_DS
	PUSH	DI                      ;DI = Next physical cluster.
	PUSH	AX                      ;AX = # of sectors remaining.
	PUSH	BX			;[DMAADD+2]:BX = Transfer address.
	;mov	byte [ALLOWED],38h
	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
	MOV	DS,[DMAADD+2]

	PUSH	DX                      ;[HIGH_SECTOR]:DX = phys. sector #.
	PUSH	CX                      ;CX = # of contiguous sectors to read.

	; MSDOS 6.0
	;call	SET_RQ_SC_PARMS 	 ;LB. do this for SC ;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	call	DREAD

	; MSDOS 3.3 
	pop	bx
	pop	dx
	jc	short CANOT_READ
	add	bx,dx	; (bx = Extent end)
	mov	al,[es:bp] ; mov al,[es:bp+0]
	;mov	al,[ES:BP+DPB.DRIVE] 
	call	SETVISIT
	; ->***

;M039
	; MSDOS 6.0 
	;pop	cx
	;pop	dx
	;pop	WORD [TEMP_VAR]
	;jc	short CANOT_READ

	;mov	[TEMP_VAR2],ds

;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
;	The Buffer Queue must now be scanned: the contents of any dirty
;	buffers must be "read" into the transfer memory block, so that the
;       transfer memory reflects the most recent data.

	;call    DskRdBufScan

	;;Context DS
	;push	ss
	;pop	ds
        
	;pop	cx
        ;pop	bx

;       CX = # of sector remaining.
;       BX = Next physical cluster.
;M039
	; 25/07/2018 - Retro DOS v3.0
	; ***->
	; MSDOS 3.3
	; IBMDOS.COM (1987) - Offset 42BDh
bufq:
;	DX = Extent start.
;	BX = Extent end.
;	 AL = Drive #.
;     DS:DI-> 1st buffer in queue.

	;or	byte [di+5],20h
	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
	;cmp	al,[di+4]	
	cmp	al,[DI+BUFFINFO.buf_ID]
	jnz	short bufq3
	;cmp	[di+6],dx
	cmp	[DI+BUFFINFO.buf_sector],dx
	jb	short bufq3	; Jump if Extent start > buffer sector.
	;cmp	[di+6],bx
	cmp	[DI+BUFFINFO.buf_sector],bx
	jnb	short bufq3	; Jump if Extent end >= buffer sector.
	
	; Buffer sector is in the Extent (contiguous sectors to read)

;       Buffer's sector is in Extent: if it is dirty, copy its contents to
;	transfer memory; otherwise, just re-position it in the buffer queue
;       as MRU (Most Recently Used).

	;test	byte [di+5],40h
	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
	jz	short bufq2	; clear buffer, check the next buff sec
	pop	ax ; transfer address
	push	ax
	push	di
	push	dx
	;sub	dx,[di+6]
	sub	dx,[DI+BUFFINFO.buf_sector]
	neg	dx

;       DX = offset (in sectors) of buffer sector within Transfer memory
;            block.

	mov	si,di
	mov	di,ax
	mov	ax,dx
	;mov	cx,[es:bp+6]	
	mov     cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
	mul	cx
	add	di,ax

	lea	si,[si+16]
	lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
       	shr	cx,1
	push	es
	mov	es,[SS:DMAADD+2]

;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
;       DS:SI-> Buffer sector data.
;       ES:DI-> Destination within Transfer memory block.

	rep	movsw			;Copy buffer sector to Transfer memory
	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	;rep	movsb                   ;Copy last byte.
	jnc	short bufq1
	movsb
bufq1:
	pop	es
	pop	dx
	pop	di
	mov	al,[es:bp]  ; mov al,[es:bp+0]
	;mov	al,[ES:BP+DPB.DRIVE]
bufq2:
	call	SCANPLACE
bufq3:
	call	SKIPVISIT
	jnz	short bufq
	
	push	ss
	pop	ds
	pop	cx
	pop	cx
	pop	bx	
bufq4:
	JCXZ	RDLAST
	call	IsEOF			; test for eof on fat size
	JAE	short SETSFT
	MOV	DL,0
	INC	word [LASTPOS]		; We'll be using next cluster
	JMP	RDLP

RDLAST:
	MOV	AX,[BYTCNT2]
	OR	AX,AX
	JZ	short SETSFT
	MOV	[BYTCNT1],AX
	call	NEXTSEC
	JC	short SETSFT
	MOV	word [BYTSECPOS],0
	call	BUFRD
	; 10/08/2018
	JNC	short SETSFT
	JMP	SET_ACC_ERR_DS

;------------------------------------------------------------------------------
;
; Procedure Name : SETSFT
; Inputs:
;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
;		and set cluster fields
; Function:
;	Update [THISSFT] based on the transfer
; Outputs:
;	sf_position, sf_lstclus, and sf_cluspos updated
;	ES:DI points to [THISSFT]
;	CX No. of bytes transferred
;	Carry clear
;
;----------------------------------------------------------------------------

	;entry	SETSFT

; 26/07/2018 - Retro DOS v3.0
SETSFT:
	LES	DI,[THISSFT]

; Same as SETSFT except ES:DI already points to SFT
	;entry	SETCLUS
SETCLUS:	
	MOV	CX,[NEXTADD]
	SUB	CX,[DMAADD]		; Number of bytes transfered
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	JNZ	short ADDREC		; don't set clusters if device
	MOV	AX,[CLUSNUM]
	;mov	[es:di+1Bh],ax
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
	MOV	AX,[LASTPOS]
	;mov	[es:di+19h],ax
	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX

;----------------------------------------------------------------------------
;
; Procedure : AddRec
; Inputs:
;	ES:DI points to SFT
;	CX is No. Bytes transferred
; Function:
;	Update the SFT offset based on the transfer
; Outputs:
;	sf_position updated to point to first byte after transfer
;	ES:DI points to SFT
;	CX No. of bytes transferred
;	Carry clear
;----------------------------------------------------------------------------

	;entry	AddRec
ADDREC:
	JCXZ	RET28		; If no records read,  don't change position
	;add	[es:di+15h],cx
	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
	;adc	word [es:di+17h], 0
	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
RET28:	
	CLC
	retn

; 25/07/2018
; MSDOS 6.0
;Break   <DskRdBufScan -- Disk Read Buffer Scan>
;----------------------------------------------------------------------------
;
; Procedure Name : DskRdBufScan
;
; Inputs:
;       CX = # of contiguous sectors read.  (These constitute a block of
;            sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;	The Buffer Queue is scanned: the contents of any dirty buffers are
;	"read" into the transfer memory block, so that the transfer memory
;	reflects the most recent data.
;
; Outputs:
;       Transfer memory updated as required.
;
; Uses:
;       DS,AX,BX,CX,SI,DI destroyed.
;       SS override for all global variables.
;
; Notes:
;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
;	than the FIRST.
;----------------------------------------------------------------------------
;M039: Created

;procedure   DskRdBufScan,NEAR
;
;ASSUME  DS:NOTHING
;
;	cmp	[DirtyBufferCount],0	;Any dirty buffers?
;	je	bufx			; -no, skip all work.
;
;       mov     bx,[HIGH_SECTOR]
;       mov     si,bx
;       add     cx,dx
;       adc     si,0
;
;	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
;       mov     ax,[di].buf_prev
;       mov     [FIRST_BUFF_ADDR],ax
;
;       Assert  ISDPB,<ES,BP>,"DISKREAD/bufchk"
;	mov	al,es:[bp].dpb_drive
;
;;            BX:DX = Extent start.
;;            SI:CX = Extent end + 1.
;;               AL = Drive #.
;;            DS:DI-> 1st buffer in queue.
;;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
;
;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
;	jne     bufq1        		;  -no, jump.
;
;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	bufq1			;Jump if Extent start > buffer sector.
;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	bufq2                   ;Jump if Extent end >= buffer sector.
;
;bufq1:	cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
;       mov     di,[di].buf_next        ; Set-up for next buffer.
;       jne     bufq                    ; -no, do next buffer
;
;bufx:   return                          ;Exit.
;
;;       Buffer's sector is in Extent: if it is dirty, copy its contents to
;;	transfer memory; otherwise, just re-position it in the buffer queue
;;       as MRU (Most Recently Used).
;
;bufq2:	SaveReg <ax>
;	testb   [di.buf_flags],buf_dirty ;Buffer dirty?
;	jz      bufq3                    ; -no, jump.
;
;        SaveReg <cx,dx,si,di,es>
;
;	mov     ax,dx
;	sub	ax, word ptr [di].buf_sector
;	neg	ax
;
;;       AX = offset (in sectors) of buffer sector within Transfer memory
;;            block.  (Note: the upper word of the sector # may be ignored
;;	     since no more than 64k bytes will ever be read.  This 64k limit
;;            is imposed by the input parameters of the disk read operation.)
;
;	lea	si,[di].BUFINSIZ	;DS:SI -> buffer data.
;	mov     cx,es:[bp].dpb_sector_size ;CX = sector size (in bytes).
;	mul     cx			;AX = offset (in bytes) of buf. sector
;	mov     di,WORD PTR [TEMP_VAR]
;	add	di,ax
;	mov	es,WORD PTR [TEMP_VAR2]
;	shr	cx,1
;
;;	   CX = sector size (in WORDs); CF=1 if odd # of bytes.
;;       DS:SI-> Buffer sector data.
;;       ES:DI-> Destination within Transfer memory block.
;
;	rep	movsw			;Copy buffer sector to Transfer memory
;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
;	rep	movsb                   ;Copy last byte.
;	RestoreReg <es,di,si,dx,cx>
;
;       DS:DI -> current buffer.
;
;bufq3:	mov     ax,di			;DS:AX -> Current buffer.
;       invoke  SCANPLACE
;       cmp	ax,[FIRST_BUFF_ADDR]    ;Last buffer?
;       RestoreReg <ax>
;       jnz    	bufq                   	; -no, jump.
;       jmp     short bufx              ; -yes, exit.
;
;EndProc DskRdBufScan

;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
;----------------------------------------------------------------------------
;
; Procedure Name : DISKWRITE
;
; Inputs:
;       Outputs of SETUP
; Function:
;       Perform disk write
; Outputs:
;    Carry clear
;       CX = No. of bytes read
;       ES:DI point to SFT
;       SFT offset and cluster pointers updated
;    Carry set
;       CX = 0
;       ES:DI point to SFT
;       AX has error code
;----------------------------------------------------------------------------

;hkn; called by DOS_WRITE. DS already set up at this point.

DISKWRITE:
	; MSDOS 3.3
	; IBMDOS.COM - Offset 436Dh
	;;test	byte [es:di+4],8
	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
	;jz	short write_cont
	;jmp	SET_ACC_ERR_DS
;write_cont:
	;push	cx
	;or	cx, cx
	;jnz	short Not_Truncate
	;;mov	cx,-1
	;dec	cx
;Not_Truncate:
	;call	LOCK_CHECK
	;pop	cx
	;jnb	short _WRITE_OK
	;call	WRITE_LOCK_VIOLATION
	;jnb	short DISKWRITE
	;retn

	; MSDOS 6.0
	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
	; 19/08/2018
	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
	retn

WRTEOFJ:
	JMP     WRTEOF

_WRITE_OK:
 	; 27/07/2018
	; IBMDOS.COM - Offset 438Eh
	
	; MSDOS 3.3 (& MSDOS 6.0)
	;and	word [es:di+5],0BFBFh
	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
				; Mark file as dirty, clear no date on close
	; MSDOS 6.0
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
        ;MOV	[TEMP_VAR],AX                           ;M039
	;MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
        ;MOV	[TEMP_VAR2],AX                          ;M039

;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039

	; MSDOS 3.3 (& MSDOS 6.0)
	LES     BP,[THISDPB]

	call	BREAKDOWN

	MOV     AX,[BYTPOS]
	MOV     DX,[BYTPOS+2]
	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
	ADD     AX,CX
	ADC     DX,0                    ;DX:AX = last byte to write + 1.

	;mov	bx,[es:bp+2]
	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]

	; MSDOS 6.0
	;CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
	;MOV	SI,AX
        ;MOV	[HIGH_SECTOR],CX

;       [HIGH_SECTOR]:SI = Last full sector to write.

	;OR	DX,DX
	;PUSH	DX			;M039: Free DX for use by SHR32
	;MOV	DX,CX			;M039
	;JNZ	short CALCLUS
	;SUB	AX,1                    ;AX must be zero base indexed	;AC000;
	;SBB	DX,0			;M039 ;F.C. >32mb		;AN000;

	; MSDOS 3.3
	cmp	dx,bx
	jnb	short WRTERR33
	div	bx
	mov	bx,ax
	OR	DX,DX
	JNZ	short CALCLUS
	dec	ax

CALCLUS:
	; MSDOS 3.3
	;mov	cl,[es:bp+5]
	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
	shr	ax,cl
	push	ax
	push	dx
	push	es
	les	di,[THISSFT]
	;mov	ax,[es:di+11h]
	;mov	dx,[es:di+13h]
	mov	ax,[ES:DI+SF_ENTRY.sf_size]
	mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
	pop	es
	;DX:AX = current file size (in bytes).
	;div	word [es:bp+2]
	div	word [ES:BP+DPB.SECTOR_SIZE]
	mov	cx,ax
	or	dx,dx
	jz	short NORND
	inc	ax

	; MSDOS 6.0
	;CALL	SHR32                   ;F.C. >32mb			;AN000;
	;POP	DX

;       AX = Last cluster to write.
;       DX = # of bytes in last sector to write (the "tail").
;       BX = ES:[BP.dpb_sector_size]

	;PUSH	AX
	;PUSH	DX
;M039
	;mov	dx,[TEMP_VAR2]
	;mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
	;call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
	;mov	[TEMP_VAR2],cx
	;mov	[VALSEC+2],cx
	;mov	cx,ax
	;mov	bx,si

;       [HIGH_SECTOR]:BX = Last full sector to write.
;          [VALSEC+2]:CX = Last full sector of current file.
;         [TEMP_VAR2]:CX = Last full sector of current file.
;                     DX = # of bytes in last sector of current file.
;M039
	;OR	DX,DX
	;JZ	short NORND
	;ADD	AX,1            	;Round up if any remainder	;AC000;
	;ADC	word [VALSEC+2],0
NORND:	
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV     [VALSEC],AX

;       [VALSEC] = Last sector of current file.

	XOR     AX,AX
	MOV     [GROWCNT],AX
	MOV     [GROWCNT+2],AX
	POP     AX

	; MSDOS 6.0
	;MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
	;CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb			;AN000;
	;JB	short NOGROW		;F.C. >32mb                             ;AN000;
	;JZ	short lowsec		;F.C. >32mb                             ;AN000;
	;SUB	BX,CX                   ;F.C. >32mb                             ;AN000;
	;SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors	;AN000;
	;JMP	short yesgrow           ;F.C. >32mb                             ;AN000;
;lowsec:
	;MOV	DI,0			;F.C. >32mb
	; MSDOS 3.3 (& MSDOS 6.0)
	SUB	BX,CX			; Number of full sectors
	JB	short NOGROW
	JZ	short TESTTAIL
;yesgrow:
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV     CX,DX
	XCHG    AX,BX
	;mul	word [es:bp+2]
	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
	
	; MSDOS 6.0
	;MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
	;MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
	;MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
	;;mul	word [es:bp+2]
	;MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
	
	;ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
	;MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
	;MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;

	; MSDOS 3.3 (& MSDOS 6.0)
	SUB     AX,CX           ; Take off current "tail"
	SBB     DX,0            ; 32-bit extension
	ADD     AX,BX           ; Add on new "tail"
	ADC     DX,0            ; ripple tim's head off
	JMP     SHORT SETGRW

HAVSTART:
	;int 3
	MOV     CX,AX
	call	SKPCLP
	;JCXZ	DOWRTJ
	jcxz	DOWRT

	call	ALLOCATE
	;JNC	short DOWRTJ
	jnc	short DOWRT

	;entry   WRTERR
WRTERR:
	MOV     AH,0FH                          ;MS. write/data/fail/abort      ;AN000;

	;entry WRTERR22
WRTERR22:
	MOV     AL,[THISDRV]                    ;MS.                            ;AN000;

	; 27/07/2018
WRTERR33:
	;MOV	CX,0                    	;No bytes transferred
	XOR     CX,CX
					
	LES     DI,[THISSFT]
	;CLC	; 19/05/2019
	retn

;DOWRTJ: 
;	JMP     short DOWRT

ACC_ERRWJ:
	; 10/08/2018
	;JMP	SET_ACC_ERRW
	jmp	SET_ACC_ERR_DS

TESTTAIL:
	SUB     AX,DX
	JBE	short NOGROW
	XOR     DX,DX
SETGRW:
	MOV	[GROWCNT],AX
	MOV	[GROWCNT+2],DX
NOGROW:
	POP     AX
	MOV     CX,[CLUSNUM]    ; First cluster accessed
	call	FNDCLUS
	JC	short ACC_ERRWJ
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX

	SUB     AX,DX           ; Last cluster minus current cluster
	JZ	short DOWRT	; If we have last clus, we must have first
	JCXZ    HAVSTART        ; See if no more data
	PUSH    CX              ; No. of clusters short of first
	MOV     CX,AX
	call	ALLOCATE
	POP     CX
	JC	short WRTERR
	MOV     DX,[LASTPOS]
	INC     DX
	DEC     CX
	JZ	short NOSKIP
	call	SKPCLP
	JC	short ACC_ERRWJ
NOSKIP:
	MOV     [CLUSNUM],BX
	MOV     [LASTPOS],DX
DOWRT:
	CMP     word [BYTCNT1],0
	JZ	short WRTMID
	MOV     BX,[CLUSNUM]
	call	BUFWRT
	JC	short ACC_ERRWJ
	;JC	short SET_ACC_ERRW
WRTMID:
	MOV     AX,[SECCNT]
	OR      AX,AX
	JZ	short WRTLAST		;M039
	ADD     [SECPOS],AX
	; MSDOS 6.0
	;ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
	call	NEXTSEC
	JC	short ACC_ERRWJ
	;JC	short SET_ACC_ERRW	;M039
	MOV     BYTE [TRANS],1		; A transfer is taking place
	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
	MOV     BX,[CLUSNUM]
	MOV     CX,[SECCNT]
WRTLP:
	call	OPTIMIZE
	JC	short ACC_ERRWJ
	;JC	short SET_ACC_ERRW

;M039
;       DI = Next physical cluster.
;       AX = # sectors remaining.
;       [DMAADD+2]:BX = transfer address (source data address).
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.

	push    di
	push    ax

        ; MSDOS 6.0
	;call	DskWrtBufPurge          ;DS trashed.
;ASSUME DS:NOTHING
;M039
	; MSDOS 3.3
	; IBMDOS.COM (1987) - Offset 4497h
	push	dx
	push	bx
	mov	al,[es:bp]
	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
	mov	bx,cx
	add	bx,dx	; (bx = Extent end)

;	DX = Extent start.
;	BX = Extent end.
;	 AL = Drive #.

	call	SETVISIT

wbufq1:
	;or	byte [di+5],20h
	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
	;cmp	al,[di+4]	
	cmp	al,[DI+BUFFINFO.buf_ID]
	jnz	short wbufq2	; Jump if Extent start > buffer sector.
	;cmp	[di+6],dx
	cmp	[DI+BUFFINFO.buf_sector],dx
	jb	short wbufq2
	;cmp	[di+6],bx
	cmp	[DI+BUFFINFO.buf_sector],bx
	jnb	short wbufq2	; Jump if Extent end >= buffer sector.

	; Buffer sector is in the Extent

	;mov	word [di+4],20FFh
	mov	word [DI+BUFFINFO.buf_ID],20FFh
					; .buf_ID,    AL = FFh (Free buffer)
					; .buf_flags, AH = 0, reset/clear
	call	SCANPLACE
wbufq2:
	call	SKIPVISIT
	jnz	short wbufq1
	pop	bx
	pop	dx
	
	; MSDOS 3.3 (& MSDOS 6.0)
;hkn; SS override for DMAADD and ALLOWED
	MOV     DS,[SS:DMAADD+2]
	;mov	byte [ss:ALLOWED],38h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE

;	put logic from DWRITE in-line here so we can modify it
;	for DISK FULL conditions.

DWRITE_LUP:
	; MSDOS 6.0
	;call	DSKWRITE
	;jz	short DWRITE_OKAY

;;	int	3
	;cmp	al,error_handle_Disk_Full	; compressed volume full?
	;jz	short DWRITE_DISK_FULL

;;hkn; SS override
	;MOV	BYTE [SS:READOP],1
	;call	HARDERRRW
	;CMP	AL,1		; Check for retry
	;JZ	short DWRITE_LUP
	;CMP	AL,3		; Check for FAIL
	;CLC
	;JNZ	short DWRITE_OKAY ; Ignore
	;STC

	; MSDOS 3.3
	call	DWRITE

DWRITE_OKAY:
	; MSDOS 3.3 (& MSDOS 6.0)

	POP     CX
	POP     BX

;       CX = # sectors remaining.
;       BX = Next physical cluster.

;hkn; SS override
        ;Context DS
	push	ss
	pop	ds

	JC      short SET_ACC_ERRW ; 16/12/2022
	JCXZ    WRTLAST
	MOV     DL,0
	INC     word [LASTPOS]	; We'll be using next cluster
	JMP     short WRTLP

	; 09/08/2018
	; MSDOS 6.0
;DWRITE_DISK_FULL:
	;;Context DS		;SQ 3-5-93 DS must be setup on return!
	;push	ss
	;pop	ds
	;pop	cx		; unjunk stack
	;pop	bx
	;mov	byte [DISK_FULL],1
	;stc
	;jmp	short WRTERR	; go to disk full exit

SET_ACC_ERRW:
	jmp	SET_ACC_ERR_DS

WRTLAST:
	MOV     AX,[BYTCNT2]
	OR      AX,AX
	JZ	short FINWRT
	MOV     [BYTCNT1],AX
	call	NEXTSEC
	JC	short SET_ACC_ERRW
	MOV     word [BYTSECPOS],0
	call	BUFWRT
	JC	short SET_ACC_ERRW
FINWRT:
	LES     DI,[THISSFT]
	MOV     AX,[GROWCNT]
	MOV     CX,[GROWCNT+2]
	OR      AX,AX
	JNZ	short UPDATE_size
	JCXZ    SAMSIZ
UPDATE_size:
	;add	[es:di+11h],ax
	ADD     [ES:DI+SF_ENTRY.sf_size],AX
	;adc	[es:di+13h],cx
	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
;
; Make sure that all other SFT's see this growth also.
;
	MOV     AX,1
;if installed
	;Call	JShare + 14 * 4
	call    far [JShare+(14*4)]	; 14 = ShSU
;else
;	Call    ShSU
;endif

SAMSIZ:
	jmp	SETCLUS	; ES:DI already points to SFT

WRTEOF:
	MOV     CX,AX
	OR      CX,DX
	JZ	short KILLFIL
	SUB     AX,1
	SBB     DX,0

	; MSDOS 3.3
	;div	word [es:bp+2]
	div	word [ES:BP+DPB.SECTOR_SIZE]
	;mov	cl,[es:bp+5]
	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
	shr     ax,cl

	; MSDOS 6.0
	;PUSH	BX
	;MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
	;CALL	DIV32                         ;F.C. >32mb                       ;AN000;
	;POP	BX			      ;F.C. >32mb			;AN000;
	;MOV	DX,CX			      ;M039
        ;MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
	;CALL	SHR32                         ;F.C. >32mb                       ;AN000;

	MOV     CX,AX
	call	FNDCLUS
SET_ACC_ERRWJ2:
	JC	short SET_ACC_ERRW

	JCXZ    RELFILE
	call	ALLOCATE
	JC	short WRTERRJ              ;;;;;;;;; disk full

UPDATE:
	LES	DI,[THISSFT]
	MOV	AX,[BYTPOS]
	;mov	[es:di+11h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size],AX
	MOV	AX,[BYTPOS+2]
	;mov	[es:di+13h],ax
	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
;
; Make sure that all other SFT's see this growth also.
;
	MOV     AX,2
;if installed
	;Call	JShare + 14 * 4
	call    far [JShare+(14*4)]	; 14 = ShSU
;else
;	Call    ShSU
;endif
	XOR     CX,CX
	jmp	ADDREC

WRTERRJ: 
	JMP     WRTERR

;;;;;;;;;;;;;;;; 7/18/86
;;;;;;;;;;;;;;;;

RELFILE:
	; MSDOS 6.0
	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
	JAE	short SKIPRESET	      		;AN002; BL
	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
SKIPRESET:                            		;AN002; BL
	POP     ES                    		;AN002; BL
;
	MOV     DX,0FFFFH
	call	RELBLKS
	jnc	short UPDATE
SET_ACC_ERRWJJ:
	;JC	short SET_ACC_ERRWJ2
	;JMP	SHORT UPDATE
	jmp	SET_ACC_ERR_DS

KILLFIL:
	XOR     BX,BX
	PUSH    ES
	LES     DI,[THISSFT]
	mov	[es:di+19h],bx
	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
	;mov	[es:di+1Bh],bx
	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
	;xchg	bx,[es:di+0Bh]
	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
	POP	ES

	OR	BX,BX
	;JZ	short UPDATEJ
	jz	short UPDATE
;; 10/23/86 FastOpen update
	PUSH	ES              ; since first cluster # is 0
	PUSH	BP              ; we must delete the old cache entry
	PUSH	AX
	PUSH	CX
	PUSH	DX
	LES	BP,[THISDPB]             ; get current DPB
	mov	dl,[ES:BP] ; mov al,[es:bp+0]
	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
	MOV	CX,BX                    ; first cluster #
	MOV	AH,2                     ; delete cache entry by drive:firclus
	call	FastOpen_Update          ; call fastopen
	POP	DX
	POP	CX
	POP	AX
	POP	BP
	POP	ES
;; 10/23/86 FastOpen update

	call	RELEASE
	JC	short SET_ACC_ERRWJJ
UpDateJ:
	JMP	UPDATE ; 10/08/2018

;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
;----------------------------------------------------------------------------
;
; Procedure Name : DskWrtBufPurge
;
; Inputs:
;       CX = # of contiguous sectors to write. (These constitute a block of
;	     sectors, also termed an "Extent".)
;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
;       ES:BP -> Drive Parameter Block (DPB).
;
; Function:
;       Purge the Buffer Queue and the Secondary Cache of any buffers which
;	are in Extent; they are being over-written.
;
; Outputs:
;       (Same as Input.)
; Uses:
;       All registers except DS,AX,SI,DI preserved.
;       SS override for all global variables.
;----------------------------------------------------------------------------
;M039: Created

;procedure   DskWrtBufPurge,NEAR
;
;ASSUME  DS:NOTHING
;
;       SaveReg <bx,cx>
;       mov	bx,[HIGH_SECTOR]	;BX:DX = Extent start (sector #).
;       mov     si,bx
;       add     cx,dx
;       adc     si,0                    ;SI:CX = Extent end + 1.
;
;	Assert  ISDPB,<ES,BP>,"DskWrtBufPurge"
;	mov     al,es:[bp.dpb_drive]
;
;;      BX:DX = Extent start.
;;      SI:CX = Extent end + 1.
;;      AL = Drive #
;
;	cmp     [SC_CACHE_COUNT],0      ;Secondary cache in-use?
;	je      nosc                    ; -no, jump.
;
;;      If any of the sectors to be written are in the secondary cache (SC),
;;      invalidate the entire SC. (This is an optimization; we really only
;;	need to invalidate those sectors which intersect, but that's slower.)
;
;       cmp     al,[CURSC_DRIVE]        ;Same drive?
;       jne     nosc                    ; -no, jump.
;
;       push    ax
;       mov     ax,[CURSC_SECTOR]
;       mov     di,[CURSC_SECTOR+2]     ;DI:AX = SC start.
;       Cmp32   si,cx,di,ax             ;Extent end < SC start?
;       jbe     sc5                     ; -yes, jump.
;       add     ax,[SC_CACHE_COUNT]
;       adc     di,0                    ;DI:AX = SC end + 1.
;       Cmp32   bx,dx,di,ax             ;Extent start > SC end?
;       jae     sc5                     ; -yes, jump.
;       mov     [SC_STATUS],0           ;Extent intersects SC: invalidate SC.
;sc5:	pop     ax
;
;;	Free any buffered sectors which are in Extent; they are being over-
;;	written.
;
;nosc:	invoke  GETCURHEAD              ;DS:DI -> first buffer in queue.
;
;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
;	jne     bufq5                   ; -no, jump.
;
;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       ja	bufq5			;Jump if Extent start > buffer sector.
;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
;       jbe	bufq5                   ;Jump if Extent end < buffer sector.
;
;;      Buffer's sector is in Extent, so free it; it is being over-written.
;
;       testb   [di.buf_flags],buf_dirty ;Buffer dirty?
;       jz      bufq2                    ; -no, jump.
;       invoke  DEC_DIRTY_COUNT          ; -yes, decrement dirty count.
;bufq2: mov     WORD PTR [di.buf_ID],((buf_visit SHL 8) OR 0FFh)
;
;       invoke  SCANPLACE
;       jmp     short bufq6
;
;bufq5: mov     di,[di.buf_next]
;bufq6: cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
;       jne     bufq	                ; --no, go do next buffer.
;
;       RestoreReg <cx,bx>
;       return
;
;EndProc DskWrtBufPurge


;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
;----------------------------------------------------------------------------
;
; Procedure Name : DIV32
;
; Inputs:
;       DX:AX = 32 bit dividend   BX= divisor
; Function:
;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
; Outputs:
;       CX:AX = quotient , DX= remainder
; Uses:
;       All registers except AX,CX,DX preserved.
;----------------------------------------------------------------------------
;M039: DIV32 optimized for divisor of 512 (common sector size).

;DIV32:
;
;       cmp     bx,512
;       jne    	short div5
;
;	mov     cx,dx
;       mov     dx,ax           ; CX:AX = Dividend
;       and     dx,(512-1)      ; DX = Remainder
;       mov     al,ah
;       mov     ah,cl
;       mov     cl,ch
;       xor     ch,ch
;       shr     cx,1
;       rcr     ax,1
;       retn
;
;div5:	mov     cx,ax
;       mov     ax,dx
;       xor     dx,dx
;       div     bx              ; 0:AX/BX
;       xchg    cx,ax
;       div     bx              ; DX:AX/BX
;       retn

;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
;----------------------------------------------------------------------------
;
; Procedure Name : SHR32
;
; Inputs:
;	DX:AX = 32 bit sector number
; Function:
;       Perform 32 bit shift right
; Outputs:
;	AX = cluster number
;	ZF = 1 if no error
;	   = 0 if error (cluster number > 64k)
; Uses:
;       DX,CX
;---------------------------------------------------------------------------
; M017	- SHR32 rewritten for better performance
; M039	- Additional optimization

;SHR32:
;
;	mov     cl,[ES:BP+DPB.CLUSTER_SHIFT]
;	xor	ch,ch	    ;ZF=1
;	jcxz	norota
;
;rotashft2:
;	shr	dx,1	    ;ZF reflects state of DX.
;	rcr	ax,1	    ;ZF not affected.
;	loop	rotashft2
;
;norota:
;	retn

;============================================================================
; DIR.ASM, MSDOS 6.0, 1991
;============================================================================
; 27/07/2018 - Retro DOS v3.0 

;	TITLE	DIR - Directory and path cracking
;	NAME	Dir

;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
;---------------------------------------------------------------------------
;
; Procedure Name : FINDENTRY,SEARCH
;
; Inputs:
;	[THISDPB] set
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Starting directory sector number
;	[CLUSNUM] = Next cluster of directory
;	[CLUSFAC] = Sectors/Cluster
;	[NAME1] = Name to look for
; Function:
;	Find file name in disk directory.
;	"?" matches any character.
; Outputs:
;	Carry set if name not found
;	ELSE
;	Zero set if attributes match (always except when creating)
;	AH = Device ID (bit 7 set if not disk)
;	[THISDPB] = Base of drive parameters
;	DS = DOSGROUP
;	ES = DOSGROUP
;	[CURBUF+2]:BX = Pointer into directory buffer
;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
;	[CURBUF] has directory record with match
;	[NAME1] has file name
;	[LASTENT] is entry number of the entry
; All other registers destroyed.
;----------------------------------------------------------------------------

;hkn; called from rename.asm and dir2.asm. DS must be already set up at
;hkn; this point.

SEARCH:
	; 27/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
	; 15/03/2018 - Retro DOS v2.0

	;entry	FindEntry
FINDENTRY:
	call	STARTSRCH
	MOV	AL,[ATTRIB]
	;and	al,9Eh
	AND	AL,~attr_ignore		; Ignore useless bits
	;cmp	al,8
	CMP	AL,attr_volume_id	; Looking for vol ID only ?
	JNZ	short NOTVOLSRCH	; No
	CALL	SETROOTSRCH		; Yes force search of root
NOTVOLSRCH:
	CALL	GETENTRY
	JNC	short SRCH
	JMP	SETESRET

	;entry	Srch
SRCH:
	PUSH	DS
	MOV	DS,[CURBUF+2]

;	(DS:BX) = directory entry address

	mov	ah,[BX]
	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
	OR	AH,AH			; End of directory?
	JZ	short FREE

;hkn; SS override
	CMP	AH,[SS:DELALL]		; Free entry?
	JZ	short FREE
	;test	byte [bx+0Bh],8
	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
					; Volume ID file?
	JZ	short CHKFNAM 		; NO

;hkn; SS override
	INC	BYTE [SS:VOLID]
CHKFNAM:
;	Context ES
	MOV	SI,SS
	MOV	ES,SI
	MOV	SI,BX

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
;;;;; 7/29/86

;hkn; SS override for NAME1
	CMP	BYTE [SS:NAME1],0E5H	; special char check
	JNZ	short NO_E5
	MOV	BYTE [SS:NAME1],05H
NO_E5:
;;;;; 7/29/86
	CALL	MetaCompare
	JZ	short FOUND
	POP	DS

	;entry	NEXTENT
NEXTENT:
	LES	BP,[THISDPB]
	CALL	NEXTENTRY
	JNC	short SRCH
	JMP	SHORT SETESRET

FREE:
	POP	DS
	MOV	CX,[LASTENT]
	CMP	CX,[ENTFREE]
	JAE	short TSTALL
	MOV	[ENTFREE],CX
TSTALL:
	CMP	AH,[DELALL]		; At end of directory?
NEXTENTJ:
	je	short NEXTENT 		; No - continue search
	MOV	[ENTLAST],CX
	STC
	JMP	SHORT SETESRET

FOUND:
;
; We have a file with a matching name.	We must now consider the attributes:
; ATTRIB	Action
; ------	------
; Volume_ID	Is Volume_ID in test?
; Otherwise	If no create then Is ATTRIB+extra superset of test?
;		If create then Is ATTRIB equal to test?
;
	MOV	CH,[SI] 		; Attributes of file
	POP	DS
	MOV	AH,[ATTRIB]		; Attributes of search
	;and	ah,9Eh
	AND	AH,~attr_ignore
	;lea	si,[si+15]
	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
					; point to first cluster field
	;test	ch,8
	TEST	CH,attr_volume_id	; Volume ID file?
	JZ	short check_one_volume_id ; Nope check other attributes
	;test	ah,8
	TEST	AH,attr_volume_id	; Can we find Volume ID?
	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
	jz	short NEXTENT ; 19/05/2019
	XOR	AH,AH			; Set zero flag for $FCB_CREATE
	JMP	SHORT RETFF		; Found Volume ID
check_one_volume_id:
	;CMP	ah,8
	CMP	AH,attr_volume_id	; Looking only for Volume ID?
	;JZ	short NEXTENTJ		; Yes, continue search
	je	short NEXTENT ; 19/05/2019
	CALL	MatchAttributes
	JZ	SHORT RETFF
	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
	;JZ	short NEXTENTJ		; Otherwise continue searching
	jz	short NEXTENT ; 19/05/2019
RETFF:
	LES	BP,[THISDPB]
	MOV	AH,[ES:BP]
	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
SETESRET:
	PUSH	SS
	POP	ES
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : MetaCompare
;
; Inputs:
;	DS:SI -> 11 character FCB style name NO '?'
;	    Typically this is a directory entry.  It MUST be in upper case
;	ES:DI -> 11 character FCB style name with possible '?'
;	    Typically this is a FCB or SFT.  It MUST be in upper case
; Function:
;	Compare FCB style names allowing for ? match to any char
; Outputs:
;	Zero if match else NZ
; Destroys CX,SI,DI all others preserved
;----------------------------------------------------------------------------

MetaCompare:
	MOV	CX,11
WILDCRD:
	REPE	CMPSB
	JZ	short MetaRet 		; most of the time we will fail.
CHECK_META:
	CMP	BYTE [ES:DI-1],"?"
	JZ	short WILDCRD
MetaRet:
 	retn				; Zero set, Match

;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
;----------------------------------------------------------------------------
;
; Procedure Name : NEXTENTRY
;
; Inputs:
;	Same as outputs of GETENTRY, above
; Function:
;	Update BX, and [LASTENT] for next directory entry.
;	Carry set if no more.
;----------------------------------------------------------------------------

NEXTENTRY:
	; 27/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
	; 15/03/2018 - Retro DOS v2.0

	MOV	AX,[LASTENT]
	CMP	AX,[ENTLAST]
	JZ	short NONE
	INC	AX
	;ADD	BX,32
	LEA	BX,[BX+32]
	CMP	BX,DX
	JB	short HAVIT
	MOV	BL,[SECCLUSPOS]
	INC	BL
	CMP	BL,[CLUSFAC]
	JB	short SAMECLUS
	MOV	BX,[NXTCLUSNUM]
	call	IsEOF
	JAE	short NONE
	CMP	BX,2
	JB	short NONE
	JMP	short GETENT
NONE:
	STC
	retn
HAVIT:
	MOV	[LASTENT],AX
	CLC
nextentry_retn:
	retn
SAMECLUS:
	MOV	[SECCLUSPOS],BL
	MOV	[LASTENT],AX
	PUSH	DS
	LDS	DI,[CURBUF]
	;MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
;hkn; SS override
	;MOV	[HIGH_SECTOR],DX		;AN000; >32mb
	;mov	dx,[di+6]
	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
	;ADD	DX,1				;AN000; >32mb
	;ADC	word [HIGH_SECTOR],0 		;AN000; >32mb
	inc	dx
	POP	DS
	call	FIRSTCLUSTER
	XOR	BX,BX
	JMP	short SETENTRY

;----------------------------------------------------------------------------
;
; Procedure Name : GETENTRY
;
; Inputs:
;	[LASTENT] has directory entry
;	ES:BP points to drive parameters
;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
; Function:
;	Locates directory entry in preparation for search
;	GETENT provides entry for passing desired entry in AX
; Outputs:
;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
;	[LASTENT] = New directory entry number
;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
;	Carry set if error (currently user FAILed to I 24)
;----------------------------------------------------------------------------

GETENTRY:
	; 27/07/2018 - Retro DOS v3.0
	MOV	AX,[LASTENT]

	;entry	GETENT
GETENT:
	MOV	[LASTENT],AX
;
; Convert the entry number in AX into a byte offset from the beginning of the
; directory.
;
	mov	cl,5			; shift left by 5 = mult by 32
	rol	ax,cl			; keep hight order bits
	mov	dx,ax
	;and	ax,0FFE0h
	;;and	ax,~(32-1)		; mask off high order bits
	and	al,0E0h ; ~31 ; 19/05/2019
	and	dx,1Fh
	;and	dx,32-1			; mask off low order bits
;
; DX:AX contain the byte offset of the required directory entry from the
; beginning of the directory. Convert this to a sector number. Round the
; sector size down to a multiple of 32.
;
	;mov	bx,[es:bp+2]
	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
	and	bl,0E0h
	;AND	BL,255-31		; Must be multiple of 32
	DIV	BX
	MOV	BX,DX			; Position within sector
	PUSH	BX
	call	DIRREAD
	POP	BX
	;retc
	jc	short nextentry_retn	
SETENTRY:
	MOV	DX,[CURBUF]
	;add	dx,16
	ADD	DX,BUFINSIZ
	ADD	BX,DX
	;add	dx,[es:bp+2]
	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
	retn

;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
;----------------------------------------------------------------------------
;
; Procedure Name : SETDIRSRCH,SETROOTSRCH
;
; Inputs:
;	BX cluster number of start of directory
;	ES:BP Points to DPB
;	DI next cluster number from fastopen extended info. DOS 3.3 only
; Function:
;	Set up a directory search
; Outputs:
;	[DIRSTART] = BX
;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
;	Carry set if error (currently user FAILed to I 24)
; destroys AX,DX,BX
;----------------------------------------------------------------------------

SETDIRSRCH:
	OR	BX,BX
	JZ	short SETROOTSRCH
	MOV	[DIRSTART],BX
	;mov	al,[es:bp+4]
	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
	INC	AL
	MOV	[CLUSFAC],AL

; DOS 3.3 for FastOPen	F.C. 6/12/86
	;SAVE	<SI>
	push	si
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JNZ	short UNP_OK

; DOS 3.3 for FastOPen	F.C. 6/12/86
	;invoke	UNPACK
	call	UNPACK
	JNC	short UNP_OK
	;RESTORE <SI>
	pop	si
	;return
	retn

UNP_OK:
	MOV	[CLUSNUM],DI
	MOV	DX,BX
	XOR	BL,BL
	MOV	[SECCLUSPOS],BL
	;invoke	FIGREC
	call	FIGREC
	;RESTORE <SI>
	pop	si
	
	; MSDOS 6.0
	;PUSH	DX			   ;AN000; >32mb
	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
	;POP	DX			   ;AN000; >32mb
	
	MOV	[DIRSEC],DX
	CLC
	retn

	;entry	SETROOTSRCH
SETROOTSRCH:
	XOR	AX,AX
	MOV	[DIRSTART],AX
	MOV	[SECCLUSPOS],AL
	DEC	AX
	MOV	[CLUSNUM],AX
	;mov	ax,[es:bp+0Bh]
	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
	;mov	dx,[es:bp+10h]
	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
	SUB	AX,DX
	MOV	[CLUSFAC],AL
	MOV	[DIRSEC],DX		      ;F.C. >32mb
	; MSDOS 6.0
	;MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
	CLC
	retn

;============================================================================
; DIR2.ASM, MSDOS 6.0, 1991
;============================================================================
; 27/07/2018 - Retro DOS v3.0 

;	TITLE	DIR2 - Directory and path cracking
;	NAME	Dir2

;Break	<GETPATH -- PARSE A WFP>
;----------------------------------------------------------------------------
;
; Procedure Name : GETPATH
;
; Inputs:
;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
;		terminated; d:/ (note forward slash) indicates a real device).
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[SATTRIB] Is attribute of search, determines what files can be found
;	[NoSetDir] set
;	[THISDPB] set to DPB if disk otherwise garbage.
; Function:
;	Crack the path
; Outputs:
;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
;	Sets EXTERR_LOCUS = errLOC_Unk if char device
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path or attribute mismatch
;		or path too long or malformed path
;	ELSE
;	   [CurBuf] = -1 if root directory
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   [NAME1] Has name looked for
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it.
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; DS preserved, Others destroyed
;---------------------------------------------------------------------------

;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
;hkn; DS already set up at this point.

GETPATH:
	;mov	word [CREATING],0E500h
	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*

; Same as GetPath only CREATING and DELALL already set

	;entry	GetPathNoSet
GetPathNoSet:
	;mov	byte [EXTERR_LOCUS],2	
	MOV	byte [EXTERR_LOCUS],errLOC_Disk
	MOV	word [CURBUF],-1	; initial setting

; See if the input indicates a device that has already been detected. If so,
; go build the guy quickly. Otherwise, let findpath find the device.

	MOV	DI,[WFP_START]		; point to the beginning of the name
	;cmp	word [DI+1],5C3Ah
	;CMP	WORD [DI+1],'\' << 8 + ':'
	cmp	word [DI+1],':\'
	JZ	short CrackIt

; Let ChkDev find it in the device list

	ADD	DI,3
	; 18/08/2018
	;MOV	SI,DI			; let CHKDEV see the original name
	CALL	CHKDEV
	JC	short InternalError
Build_devJ:

	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL
	;mov	byte [EXTERR_LOCUS],1
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
					; "finding" a char device
					; set LOCUS to Unknown. This makes
					; certain idiotic problems reported
					; by a certain 3 letter OEM go away.

; Take name in name1 and pack it back into where wfp_start points. This
; guarantees wfp_start pointing to a canonical representation of a device.
; We are allowed to do this as GetPath is *ALWAYS* called before entering a
; wfp into the share set.
;
; We copy chars from name1 to wfp_start remembering the position of the last
; non-space seen +1.  This position is kept in DX.

;hkn; SS is DOSDATA
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	mov	si,NAME1
	mov	di,[WFP_START]
	mov	dx,di
	mov	cx,8			; 8 chars in device name
MoveLoop:
	lodsb
	stosb
	cmp	al," "
	jz	short NoSave

	mov	dx,di
NoSave:
	loop	MoveLoop
;
; DX is the position of the last seen non-space + 1. We terminate the name
; at this point.
;
	mov	di,dx
	mov	byte [di],0		; end of string
	call	Build_device_ent	; Clears carry sets zero
	INC	AL			; reset zero
	retn

InternalError:
InternalError_loop:
	JMP	short InternalError_loop	; freeze

; Start off at the correct spot. Optimize if the current dir part is valid.

CrackIt:
	MOV	SI,[CURR_DIR_END]	; get current directory pointer
	CMP	SI,-1			; valid?
	JNZ	short LOOK_SING		; Yes, use it.
	LEA	SI,[DI+3]		; skip D:\.
LOOK_SING:
	;mov	byte [ATTRIB],16h
	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
					; Attributes to search through Dirs
	LES	DI,[THISCDS]
	MOV	AX,-1
	;mov	bx,[es:di+73]
	MOV	BX,[ES:DI+curdir.ID]
	MOV	SI,[CURR_DIR_END]

; AX = -1
; BX = cluster number of current directory.  THis number is -1 if the media
;      has been uncertainly changed.
; SI = offset in DOSGroup into path to end of current directory text.  This
;      may be -1 if no current directory part has been used.

	CMP	SI,AX			; if Current directory is not part
	JZ	short NO_CURR_D		; then we must crack from root
	CMP	BX,AX			; is the current directory cluster valid

; DOS 3.3  6/25/86
	JZ	short NO_CURR_D		; no, crack form the root
	;test	byte [FastOpenFlg],1
	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
	JZ	short GOT_SEARCH_CLUSTER	; no
	PUSH	ES			; save registers
	PUSH	DI
	PUSH	CX
	PUSH	word [SI-1]		; save \ and 1st char of next element
	PUSH	SI
	PUSH	BX

	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
	MOV	SI,[WFP_START]

;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
	MOV	BX,FastOpenTable
	MOV	DI,Dir_Info_Buff
	MOV	CX,FastOpen_Ext_Info
	;mov	al,1
	MOV	AL,FONC_Look_up
	PUSH	DS
	POP	ES
	;call	far [BX+2]
	CALL	far [BX+fastopen_entry.name_caching]
	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
					; Go to Got_Srch_cluster
	CMP	BYTE [SI],0		;fastopen has current dir info?
	JE	short GO_Chk_end	;yes. Go to got_search_cluster
	stc
	jmp	short GO_Chk_end	;Go to No_Curr_D
GO_Chk_end1:
	clc
GO_Chk_end:				; restore registers
	POP	BX
	POP	SI
	POP	word [SI-1]
	POP	CX
	POP	DI
	POP	ES
	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir

; DOS 3.3  6/25/86
;
; We must cract the path beginning at the root. Advance pointer to beginning
; of path and go crack from root.

NO_CURR_D:
	MOV	SI,[WFP_START]
	LEA	SI,[SI+3]		; Skip "d:/"
	LES	BP,[THISDPB]		; Get ES:BP
	JMP	short ROOTPATH

; We are able to crack from the current directory part. Go set up for search
; of specified cluster.

GOT_SEARCH_CLUSTER:
	LES	BP,[THISDPB]		; Get ES:BP
	call	SETDIRSRCH
	;JC	short SETFERR
	;JMP	short FINDPATH
	jnc	short FINDPATH ; 17/08/2018
SETFERR:
	XOR	CL,CL			; set zero
	STC
	retn

;---------------------------------------------------------------------------
;
; Procedure Name : ChkDev
;
; Check to see if the name at DS:DI is a device. Returns carry set if not a
;   device.
; Blasts CX,SI,DI,AX,BX
;---------------------------------------------------------------------------

CHKDEV:
	MOV	SI,DI
	MOV	DI,SS
	MOV	ES,DI

	MOV	DI,NAME1
	MOV	CX,9
TESTLOOP:
	call	GETLET

	CMP	AL,'.'
	JZ	short TESTDEVICE
	call	PATHCHRCMP
	JZ	short NOTDEV
	OR	AL,AL
	JZ	short TESTDEVICE

	STOSB
	LOOP	TESTLOOP
NOTDEV:
	STC
	retn

TESTDEVICE:
	ADD	CX,2
	MOV	AL,' '
	REP	STOSB
	MOV	AX,SS
	MOV	DS,AX
	call	DEVNAME
	retn

;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
;----------------------------------------------------------------------------
;
; Procedure Name : ROOTPATH,FINDPATH
;
; Inputs:
;	Same as FINDPATH but,
;	SI Points to asciz string of path which is assumed to start at
;		the root (no leading '/').
; Function:
;	Search from root for path
; Outputs:
;	Same as FINDPATH but:
;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
;	[NoSetDir] is ignored.
;----------------------------------------------------------------------------

ROOTPATH:
	call	SETROOTSRCH
	CMP	BYTE [SI],0
	JNZ	short FINDPATH

; Root dir specified
	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL
	XOR	AH,AH			; Sets "device ID" byte, sets zero
					; (dir), clears carry.
	retn

; Inputs:
;	[ATTRIB] Set to get through directories
;	[SATTRIB] Set to find last element
;	ES:BP Points to DPB
;	SI Points to asciz string of path (no leading '/').
;	[SECCLUSPOS] = 0
;	[DIRSEC] = Phys sec # of first sector of directory
;	[CLUSNUM] = Cluster # of next cluster
;	[CLUSFAC] = Sectors per cluster
;	[NoSetDir] set
;	[CURR_DIR_END] Points to end of Current dir part of string
;		( = -1 if current dir not involved, else
;		 Points to first char after last "/" of current dir part)
;	[THISCDS] Points to CDS being used
;	[CREATING] and [DELALL] set
; Function:
;	Parse path name
; Outputs:
;	ID1 field of [THISCDS] updated appropriately
;	[ATTRIB] = [SATTRIB]
;	ES:BP Points to DPB
;	[THISDPB] = ES:BP
;	Carry set if bad path
;	   SI Points to path element causing failure
;	   Zero set
;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;	      start a search on the last directory
;	      CL is zero if there is a bad name in the path
;	      CL is non-zero if the name was simply not found
;		 [ENTFREE] may have free spot in directory
;		 [NAME1] is the name.
;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
;	   Zero reset
;	      File in middle of path or bad name in path
;		or path too long or malformed path
;	ELSE
;	   [CURBUF] contains directory record with match
;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
;	   [NAME1] Has name looked for
;	   AH = device ID
;	      bit 7 of AH set if device SI and BX
;	      will point DOSGROUP relative The firclus
;	      field of the device entry contains the device pointer
;	   If last element is a directory zero is set and:
;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;	      are set up to start a search on it,
;	      unless [NoSetDir] is non zero in which case the return is
;	      like that for a file (except for zero flag)
;	   If last element is a file zero is reset
;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
;	      [LASTENT], [ENTLAST] are set to continue search of last
;	      directory for furthur matches on NAME1 via the NEXTENT
;	      entry point in FindEntry (or GETENT entry in GETENTRY in
;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
; Destroys all other registers

    	;entry	FINDPATH
FINDPATH:
	PUSH	ES			; Save ES:BP
	PUSH	SI
	MOV	DI,SI
	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
	CMP	word [CURR_DIR_END],-1
	JZ	short NOIDS		; No current dir part
	CMP	DI,[CURR_DIR_END]
	JNZ	short NOIDS		; Not to current dir end yet
	LES	DI,[THISCDS]
	;mov	[es:di+73],cx
	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
NOIDS:

; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
; character in the string. CX,DI may be destroyed.
;
;	invoke	NAMETRANS
;	MOV	CL,AL
;
; The above is the slow method. The name has *already* been munged by
; TransPath so no special casing needs to be done. All we do is try to copy
; the name until ., \ or 0 is hit.

	MOV	AX,SS
	MOV	ES,AX

;hkn; Name1 is in DOSDATA
	MOV	DI,NAME1
	MOV	AX,'  ' ; 2020h
	STOSB
	STOSW
	STOSW
	STOSW
	STOSW
	STOSW

;hkn; Name1 is in DOSDATA
	MOV	DI,NAME1
	XOR	AH,AH			; bits for CL
GetNam:
	;INC	CL			;AN000; KK incrment volid count
	LODSB
	CMP	AL,'.'
	JZ	short _SetExt
	OR	AL,AL
	JZ	short _GetDone
	CMP	AL,'\'
	JZ	short _GetDone
	CMP	AL,'?'
	JNZ	short StoNam
	OR	AH,1
StoNam: 
	STOSB
	JMP	short GetNam
_SetExt:
	MOV	DI,NAME1+8
GetExt:
	LODSB
	OR	AL,AL
	JZ	short _GetDone
	CMP	AL,'\'
	JZ	short _GetDone
	CMP	AL,'?'
	JNZ	short StoExt
	OR	AH,1
StoExt: 
	STOSB
	JMP	short GetExt
_GetDone:
	DEC	SI
	MOV	CL,AH
	OR	CL,80H
	POP	DI			; Start of this element
	POP	ES			; Restore ES:BP
	CMP	SI,DI
	JNZ	short check_device
	JMP	_BADPATH		; NUL parse (two delims most likely)
check_device:
	PUSH	SI			; Start of next element
	MOV	AL,[SI]
	OR	AL,AL
	JNZ	short NOT_LAST

; for last element of the path switch to the correct search attributes

	MOV	BH,[SATTRIB]
	MOV	[ATTRIB],BH

NOT_LAST:

; check name1 to see if we have a device...

	PUSH	ES			; Save ES:BP

;hkn; SS is DOSDATA
	;context ES
	push	ss
	pop	es
	call	DEVNAME 		; blast BX
	POP	ES			; Restore ES:BP
	JC	short FindFile		; Not a device
	OR	AL,AL			; Test next char again
	JZ	short GO_BDEV
	JMP	FILEINPATH		; Device name in middle of path

GO_BDEV:
	POP	SI			; Points to NUL at end of path
	JMP	Build_devJ

FindFile:
;;;; 7/28/86
	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
	JNZ	short NOE5		; no
	MOV	BYTE [NAME1],05H	; change it to 05
NOE5:
;;;; 7/28/86
	PUSH	DI			; Start of this element
	PUSH	ES			; Save ES:BP
	PUSH	CX			; CL return from NameTrans
;DOS 3.3 FastOPen 6/12/86 F.C.

	CALL	LookupPath		; call fastopen to get dir entry
	JNC	short DIR_FOUND		; found dir entry

;DOS 3.3 FastOPen 6/12/86 F.C.
	call	FINDENTRY
DIR_FOUND:
	POP	CX
	POP	ES
	POP	DI
	JNC	short LOAD_BUF
	JMP	BADPATHPOP

LOAD_BUF:
	LDS	DI,[CURBUF]
	;test	byte [bx+0Bh],10h
	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
	JNZ	short GO_NEXT 		; DOS 3.3
	JMP	FILEINPATH		; Error or end of path

; if we are not setting the directory, then check for end of string

GO_NEXT:
;hkn; SS override
	CMP	BYTE [SS:NoSetDir],0
	JZ	short SetDir
	MOV	DX,DI			; Save pointer to entry
	MOV	CX,DS

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	POP	DI			; Start of next element
	; MSDOS 6.0
	;TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
	;JZ	short nofast			; the FastOpen
	;TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
	;JZ	short nofast			; no
	;MOV	DI,[Next_Element_Start]	; no need to insert it again
;nofast:
	CMP	BYTE [DI],0
	JNZ	short NEXT_ONE		; DOS 3.3
	;JMP	_SETRET			; Got it
	retn	; 05/09/2018
NEXT_ONE:
	PUSH	DI			; Put start of next element back on stack
	MOV	DI,DX
	MOV	DS,CX			; Get back pointer to entry
SetDir:
	MOV	DX,[SI] 		; Dir_first

;DOS 3.3 FastOPen 6/12/86 F.C.
	PUSH	DS		      ; save [curbuf+2]
;hkn; SS is DOSDATA
	push	ss
	pop	ds		      ; set DS Dosgroup
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
	MOV	BX,DX		      ; not found
	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
	PUSH	AX		      ; save device id (AH)
	call	SETDIRSRCH
	POP	AX		      ; restore device id (AH)
	ADD	SP,2		      ; pop ds in stack
	JMP	short FAST_OPEN_SKIP

DO_NORMAL:
	POP	DS			; DS = [curbuf + 2]
;DOS 3.3 FastOPen 6/12/86 F.C.

	SUB	BX,DI			; Offset into sector of start of entry
	SUB	SI,DI			; Offset into sector of dir_first
	PUSH	BX
	PUSH	AX
	PUSH	SI
	PUSH	CX
	;push	word [di+6]
	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
	; MSDOS 6.0
	;PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
	MOV	BX,DX

;hkn; SS is DOSDATA
	;context DS
	push	ss
	pop	ds
	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
	call	SETDIRSRCH		; the entry sector buffer
	; MSDOS 6.0
	;POP	word [HIGH_SECTOR]
	POP	DX
	JC	short SKIP_GETB
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
	XOR	AL,AL
	;invoke	GETBUFFR		; Get the entry buffer back
	call	GETBUFFR
SKIP_GETB:
	POP	CX
	POP	SI
	POP	AX
	POP	BX
	JNC	short SET_THE_BUF ; 19/05/2019
	POP	DI			; Start of next element
	MOV	SI,DI			; Point with SI
	JMP	SHORT _BADPATH

SET_THE_BUF:
	call	SET_BUF_AS_DIR
	MOV	DI,[CURBUF]
	ADD	SI,DI			; Get the offsets back
	ADD	BX,DI
; DOS 3.3 FastOpen 6/12/86  F.C.
FAST_OPEN_SKIP:
	POP	DI			; Start of next element
	CALL	InsertPath		; insert dir entry info
; DOS 3.3 FastOpen 6/12/86  F.C.
	MOV	AL,[DI]
	OR	AL,AL
	JZ	short _SETRET		; At end
	INC	DI			; Skip over "/"
	MOV	SI,DI			; Point with SI
	call	PATHCHRCMP
	JNZ	short find_bad_name	; oops
	JMP	FINDPATH		; Next element

find_bad_name:
	DEC	SI			; Undo above INC to get failure point
_BADPATH:
	XOR	CL,CL			; Set zero
	JMP	SHORT BADPRET

FILEINPATH:
	POP	DI			; Start of next element

;hkn; SS is DOSDATA
	;context DS			; Got to from one place with DS gone
	push	ss
	pop	ds

; DOS 3.3 FastOpen
	;test	byte [FastOpenFlg],1
	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
	JZ	short NO_FAST		; device info to fastopen
	;test	byte [FastOpenFlg],2
	TEST	byte [FastOpenFlg],Lookup_Success
	JZ	short NO_FAST
	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
					 ; success
NO_FAST:
; DOS 3.3 FastOpen

	MOV	AL,[DI]
	OR	AL,AL
	JZ	short INCRET
	MOV	SI,DI			; Path too long
	JMP	SHORT BADPRET

INCRET:
; DOS 3.3 FasOpen 6/12/86  F.C.

	CALL   InsertPath		; insert dir entry info

; DOS 3.3 FasOpen 6/12/86  F.C.
	INC	AL			; Reset zero
_SETRET:
	retn

BADPATHPOP:
	POP	SI			; Start of next element
	MOV	AL,[SI]
	MOV	SI,DI			; Start of bad element
	OR	AL,AL			; zero if bad element is last, non-zero if path too long
BADPRET:
	MOV	AL,[SATTRIB]
	MOV	[ATTRIB],AL		; Make sure return correct
	STC
	retn

;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
;---------------------------------------------------------------------------
;
; Procedure Name : STARTSRCH
;
; Inputs:
;	[THISDPB] Set
; Function:
;	Set up a search for GETENTRY and NEXTENTRY
; Outputs:
;	ES:BP = Drive parameters
;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
; Destroys ES,BP,AX
;--------------------------------------------------------------------------

STARTSRCH:
	LES	BP,[THISDPB]
	XOR	AX,AX
	MOV	[LASTENT],AX
	MOV	[VOLID],AL		; No volume ID found
	DEC	AX
	MOV	[ENTFREE],AX
	MOV	[ENTLAST],AX
	retn

;BREAK <MatchAttributes - the final check for attribute matching>
;----------------------------------------------------------------------------
; Procedure Name : MatchAttributes
;
; Input:    [Attrib] = attribute to search for
;	    CH = found attribute
; Output:   JZ <match>
;	    JNZ <nomatch>
; Registers modified: noneski
;----------------------------------------------------------------------------

MatchAttributes:
	PUSH	AX

;hkn; SS override
	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
	NOT	AL			; AL <- SearchSet'
	AND	AL,CH			; AL <- SearchSet' and FoundSet
	;and	al,16h
	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
;
; the result is non-zero if an attribute is not in the search set
; and in the found set and in the important set. This means that we do not
; have a match. Do a JNZ <nomatch> or JZ <match>
;
	POP	AX
	retn

;Break <DevName - Look for name of device>
;---------------------------------------------------------------------------
;
; Procedure Name : DevName
;
; Inputs:
;	DS,ES:DOSDATA
;	Filename in NAME1
;	ATTRIB set so that we can error out if looking for Volume IDs
; Function:
;	Determine if file is in list of I/O drivers
; Outputs:
;	Carry set if not a device
;	ELSE
;	Zero flag set
;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
;	     bits 0-4 set from low byte of attribute word
;	DEVPT = DWORD pointer to Device header of device
; BX destroyed, others preserved
;---------------------------------------------------------------------------

DEVNAME:
	; 28/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh

	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

; E5 special code
	PUSH	WORD [NAME1]
	CMP	byte [NAME1],5
	JNZ	short NOKTR
	MOV	byte [NAME1],0E5h
NOKTR:
	;test	byte [ATTRIB],8
	TEST	byte [ATTRIB],attr_volume_id
					; If looking for VOL id don't find devs
	JNZ	short RET31

;hkn; NULDEV is in DOSDATA
	MOV	SI,NULDEV
LOOKIO:
	;test	word [si+4],8000h
	TEST	word [SI+SYSDEV.ATT],DEVTYP
	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
	MOV	AX,SI
	;add	si,10
	ADD	SI,SYSDEV.NAME

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	MOV	CX,4			; All devices are 8 letters
	REPE	CMPSW			; Check for name in list
	MOV	SI,AX
	JZ	short IOCHK		; Found it?
SKIPDEV:
	LDS	SI,[SI]			; Get address of next device
	CMP	SI,-1			; At end of list?
	JNZ	short LOOKIO
RET31:	
	STC				; Not found
RETNV:	
	MOV	CX,SS
	MOV	DS,CX

	POP	WORD [NAME1]
	POP	AX
	POP	CX
	POP	DI
	POP	SI
	RETN

IOCHK:
;hkn; SS override for DEVPT
	MOV	[SS:DEVPT+2],DS		; Save pointer to device
	;mov	bh,[si+4]
	MOV	BH,[SI+SYSDEV.ATT]
	OR	BH,0C0h
	and	bh,0DFh
	;AND	BH,~(020h)		; Clears Carry
	MOV	[SS:DEVPT],SI
	JMP	short RETNV

;BREAK <Build_device_ent - Make a Directory entry>
;---------------------------------------------------------------------------
; Procedure Name : Build_device_ent
;
; Inputs:
;	[NAME1] has name
;	BH is attribute field (supplied by DEVNAME)
;	[DEVPT] points to device header (supplied by DEVNAME)
; Function:
;	Build a directory entry for a device at DEVFCB
; Outputs:
;	BX points to DEVFCB
;	SI points to dir_first field
;	AH = input BH
;	AL = 0
;	dir_first = DEVPT
;	Zero Set, Carry Clear
; DS,ES,BP preserved, others destroyed
;--------------------------------------------------------------------------

Build_device_ent:
	MOV	AX,"  " ; 2020h

;hkn; DEVFCB is in DOSDATA
	MOV	DI,DEVFCB+8		; Point to extent field

;	Fill dir_ext	BUGBUG - use ERRNZs for this stuff!

	STOSW
	STOSB				; Blank out extent field
	;mov	al,40h
	MOV	AL,attr_device

;	Fill Dir_attr

	STOSB				; Set attribute field
	XOR	AX,AX
	MOV	CX,10

; Fill dir_pad

	REP	STOSW			; Fill rest with zeros
	call	DATE16

;hkn; DEVFCB is in DOSDATA
	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
	XCHG	AX,DX

; Fill dir_time

	STOSW
	XCHG	AX,DX

; Fill dir_date

	STOSW
	MOV	SI,DI			; SI points to dir_first field
	MOV	AX,[DEVPT]

; Fill dir_first

	STOSW				; Dir_first points to device
	MOV	AX,[DEVPT+2]
;
; Fill dir_size_l
;
	STOSW
	MOV	AH,BH			; Put device atts in AH

;hkn; DEVFCB is in DOSDATA
	MOV	BX,DEVFCB
	XOR	AL,AL			; Set zero, clear carry
	retn

;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
;----------------------------------------------------------------------------
;
;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
;   media. If media has been changed, do DOS_Chdir to validate path.
;   If invalid, reset original CDS to root.
;
;   Inputs:	ThisCDS points to CDS of interest
;		SS:DI points to temp buffer
;   Outputs:	The current directory string is validated on the appropriate
;		    drive
;		ThisDPB changed
;		ES:DI point to CDS
;		Carry set if error (currently user FAILed to I 24)
;   Registers modified: all
;----------------------------------------------------------------------------

ValidateCDS:
	; 28/07/2018 - Retro DOS v3.0

   %define  Temp	[bp-2]	; word
   %define  SaveCDS	[bp-6]	; dword
   %define  SaveCDSL	[bp-6]	; word
   %define  SaveCDSH	[bp-4]	; word

	;Enter
	push	bp
	mov	bp,sp
	sub	sp,6

	MOV	Temp,DI

;hkn; SS override
	LDS	SI,[SS:THISCDS]
	MOV	SaveCDSL,SI
	MOV	SaveCDSH,DS
	;EnterCrit critDisk
	call	EcritDisk
	;test	word [si+67],8000h
	TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
	JZ	short _DoSplice
	JMP	FatFail
_DoSplice:
	XOR	DL,DL
	XCHG	DL,[SS:NoSetDir]

;hkn; SS is DOSDATA
	;Context ES
	push	ss
	pop	es
	;Invoke	FStrcpy
	call	FStrCpy
	MOV	SI,Temp

;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds	
	;Invoke	Splice
	call	Splice

 ;hkn; SS is DOSDATA
	;Context DS			;   FatReadCDS (ThisCDS);
	push	ss
	pop	ds
	MOV	[NoSetDir],DL
	LES	DI,[THISCDS]
	;SAVE	<BP>
	push	bp
	;Invoke	FATREAD_CDS
	call	FATREAD_CDS	
	;RESTORE <BP>
	pop	bp
	JC	short FatFail

	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
	;cmp	word [si+73], -1
	CMP	word [SI+curdir.ID],-1
	JNZ	short RestoreCDS

;hkn; SS is DOSDATA
	;Context ES
	push	ss
	pop	es

;hkn; SS override
	;SAVE	<wfp_Start>		;	t = wfp_Start;
	push	word [SS:WFP_START]
	;cmp	si,[bp-6]
	CMP	SI,SaveCDSL		; if not spliced
	JNZ	short DoChdir
	;mov	di,[bp-2]
	MOV	DI,Temp

;hkn; SS override
	MOV	[SS:WFP_START],DI	;	wfp_start = d;
	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
	call	FStrCpy
DoChdir:
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds
	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
	push	word [SATTRIB]
	push	bp
	;Invoke	DOS_ChDir
	call	DOS_CHDIR
	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
	pop	bp
	pop	bx
	pop	word [WFP_START]
	MOV	[SATTRIB],BL
	LDS	SI,SaveCDS
	JNC	short SetCluster	;	if (c == -1) {

;hkn; SS override for THISCDS
	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
	MOV	[SS:THISCDS+2],DS
	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
	MOV	[SI+3],CL		;	    }
SetCluster:
	;mov	word [si+73],0FFFFh
	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
	; MSDOS 6.0
	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
	;JZ	short setdirclus		     ;AN000;;MS.
	;MOV	CX,-1				     ;AN000;;MS.
setdirclus:
	;mov	[si+73],cx
	MOV	[SI+curdir.ID],CX	;	}
RestoreCDS:
	LES	DI,SaveCDS
	MOV	[SS:THISCDS],DI
	MOV	[SS:THISCDS+2],ES
	CLC
FatFail:
	;LeaveCrit critDisk
	call	LcritDisk

	;les	di,[bp-6]
	LES	DI,SaveCDS
	;Leave
	mov	sp,bp
	pop	bp
	retn

; 28/07/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh

;Break	<CheckThisDevice - Check for being a device>
;---------------------------------------------------------------------------
;
;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
;   device specified. We will return carry if there is a device present. 
;   The forms of devices we will recognize are:
;
;	[path]device
;
;   Note that the drive letter has *already* been removed. All other forms
;   are not considered to be devices. If such a device is found we change
;   the source pointer to point to the device component.
;
;   Inputs:	ES is DOSDATA
;		DS:SI contains name
;   Outputs:	ES is DOSDATA
;		DS:SI point to name or device
;		Carry flag set if device was found
;		Carry flag reset otherwise
;   Registers Modified: all except ES:DI, DS
;----------------------------------------------------------------------------

CheckThisDevice:
	push	di
	push	si
	MOV	DI,SI
;
; Check for presence of \dev\ (Dam multiplan!)
;
	MOV	AL,[SI]
	call	PATHCHRCMP		; is it a path char?
	JNZ	short ParseDev		; no, go attempt to parse device
	INC	SI			; simulate LODSB
;
; We have the leading path separator. Look for DEV part.
;
	LODSW
	OR	AX,2020h
	cmp	ax,"de"
	;CMP	AX,"e"<< 8 + "d"
	JNZ	short NotDevice		; not "de", assume not device
	LODSB
	OR	AL,20h
	CMP	AL,"v"                  ; Not "v", assume not device
	JNZ	short NotDevice
	LODSB
	call	PATHCHRCMP		; do we have the last path separator?
	JNZ	short NotDevice		; no. go for it.
;
; DS:SI now points to a potential drive. Preserve them as NameTrans advances
; SI and DevName may destroy DS.
;
ParseDev:
	push	ds
	push	si			; preserve the source pointer
	call	NameTrans		; advance DS:SI
	CMP	BYTE [SI],0		; parse entire string?
	STC				; simulate a Carry return from DevName
	JNZ	short SkipSearch	; no parse. simulate a file return.

;hkn; SS is DOSDATA
	push	ss
	pop	ds

; M026 - start - fix ported from ROMDOS2 for bug # 2849
;
; SR;
; We have to set Attrib before invoking DevName. Otherwise, the value from
; a previous DOS call is used and DevName thinks it is not a device if the
; old call set the volume attribute bit.
;
	mov	al,[SATTRIB]
	mov	[ATTRIB],al		;set Attrib for DevName

; M026 - end

	call	DEVNAME

SkipSearch:
	pop	si
	pop	ds
;
; SI points to the beginning of the potential device. If we have a device
; then we do not change SI. If we have a file, then we reset SI back to the
; original value. At this point Carry set indicates FILE.
;
CheckReturn:
	pop	di			; get original SI
	JNC	short Check_Done	; if device then do not reset pointer
	MOV	SI,DI
Check_Done:
	pop	di
	CMC				; invert carry. Carry => device
	retn
NotDevice:
	STC
	JMP	short CheckReturn

;BREAK <LookupPath - call fastopen to get dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : LookupPath
;
; Output  DS:SI -> path name,
;	  ES:DI -> dir entry info buffer
;	  ES:CX -> extended dir info buffer
;
;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
;			     FastOpen, DS:SI points to char just one after
;			     the last char of path name which is fully or
;			     partially found in FastOPen
;	  carry flag set : FastOpen not in memory or path name not found
;
;----------------------------------------------------------------------------

LookupPath:
;	PUSH	AX

;hkn; SS override
	;test	byte [ss:FastOpenFlg],1
	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSPEN
	JNZ	short FASTINST			    ; and this routine is
NOLOOK:
	JMP	NOLOOKUP			    ; executed once

FASTINST:
;hkn; SS override
	;test	byte [ss:FastOpenFlg],8
	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
	JNZ	short NOLOOK			    ; yes

	MOV	BX,FastOpenTable		    ; get fastopen related tab

;hkn; SS override
	MOV	SI,[SS:WFP_START]		    ; si points to path name
	MOV	DI,Dir_Info_Buff
	MOV	CX,FastOpen_Ext_Info
	MOV	AL,FONC_Look_up 		    ; al = 1
	PUSH	DS
	POP	ES

;hkn; SS override
	;call	far [bx+2]
	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
	JC	short NOTFOUND			    ; fastopen not in memory

	LEA	BX,[SI-2]

;hkn; SS override
	CMP	BX,[SS:WFP_START]		    ; path found ?
	JZ	short NOTFOUND			    ; no

	; MSDOSD 6.0				    ; fully or partially found
	;CMP	BYTE [SI],0			    ;AN000;FO.
	;JNZ	short parfnd			    ;AN000;FO.; partiallyfound
	;PUSH	CX				    ;AN000;FO.; is attribute matched ?

;hkn; SS override for attrib/sattrib
	;MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
	;MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
	;MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
	;MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
	;call	Matchattributes 		    ;AN000;FO.;
;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
	;POP	CX				    ;AN000;FO.;
	;JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
;parfnd:

;hkn; SS override
	MOV	[SS:Next_Element_Start],SI	    ; save si
	MOV	BX,CX
	; MSDOS 6.0
	;MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
	;MOV	[SS:LASTENT],AX			    ;AN000;;FO.
	;MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
	;MOV	[SS:DIRSTART],AX			    ;AN001;;FO.
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ax,[bx+3] ; MSDOS 3.3
	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
	MOV	[SS:CLUSNUM],AX			    ;

	PUSH	ES				    ; save ES
;hkn; SS override
	LES	BX,[SS:THISDPB]			    ; put drive id
	mov	ah,[ES:BX] ; 15/08/2018
	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
	POP	ES				    ; pop ES
;SR;
; We cannot have a root dir if we have come here. So, we zero out CurBuf to
;indicate it is not a root dir
;
	mov	word [SS:CURBUF],0		    ; indicate not root dir

	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
	MOV	BX,DI				    ; start of entry
	;lea	si,[di+1Ah]
	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
						    ; dir_first field in the
						    ; dir entry
;hkn; SS override for FastOpenFlg
	;or	byte [ss:FastOpenFlg],2
	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
;	POP	AX
	RETN
NOTFOUND:
	CMP	AX,-1				    ; not in memory ?
	JNZ	short Partial_Success 		    ; yes, in memory
	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
Partial_Success:
	;and	byte [SS:FastOpenFlg],0FBh
	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
NOLOOKUP:
;	POP	AX
	STC
	RETN

;BREAK <InsertPath - call fastopen to insert dir entry info>
;-----------------------------------------------------------------------------
;
; Procedure Name : InsertPath
; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
;	  Lookup_Success flag set when got dir entry info from FASTOPEN
;	  DS = DOSDATA
; Output: FastOPen_Ext_Info is set and path dir info is inserted
;
;-----------------------------------------------------------------------------

InsertPath:
	PUSHF
;hkn; SS override for FastOpenFlag
	;test	byte [SS:FastOpenFlg], 1
	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
	JZ	short GET_NEXT_ELEMENT		; the FastOpen
	;test	byte [ss:FastOpenFlg],2
	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
	JZ	short INSERT_DIR_INFO		; no
	;and	byte [ss:FastOpenFlg],0FDh
	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
	JMP	short GET_NEXT2
INSERT_DIR_INFO:				; save registers
	PUSH	DS
	PUSH	ES
	PUSH	BX
	PUSH	SI
	PUSH	DI
	PUSH	CX
	PUSH	AX

;hkn; SS override
	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
	MOV	SI,FastOpen_Ext_Info
	;mov	ax,[di+6]
	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
	; MSDOS 6.0
	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
	;MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	; MSDOS6.0
	;MOV	[SI+FEI.dirsec+2],AX  ;AN000;>32mb save high dir sector
	; MSDOS 3.3	
	;mov	[si+1],ax	
	MOV	[SI+FEI.dirsec],AX
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	AX,[CLUSNUM]		; save next cluster number
	;;mov	[si+5],ax ; MSDOS 6.0
	;mov	[si+3],ax ; MSDOS 3.3
	MOV	[SI+FEI.clusnum],AX
	;MSDOS 6.0
	;MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
	;MOV	[SI+FEI.lastent],AX	;AN000;FO.
	;MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
	;MOV	[SI+FEI.dirstart],AX	;AN001;FO.
	; MSDOS 3.3 (& MSDOS 6.0)
	MOV	AX,BX
	;add	di,16
	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
	SUB	AX,DI			; AX=BX relative to start of sector
	;mov	cl,32
	MOV	CL,dir_entry.size
	DIV	CL
	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
	mov	[si],al

	PUSH	DS
	POP	ES

	MOV	DS,[CURBUF+2]
	MOV	DI,BX			; DS:DI -> dir entry info
	;cmp	word [di+1Ah],0
	CMP	word [DI+dir_entry.dir_first],0 
					; never insert info when file is empty
	JZ	short SKIP_INSERT	; e.g. newly created file

	PUSH	SI			; ES:BX -> extended info
	POP	BX

	;mov	al,2
	MOV	AL,FONC_insert		; call fastopen insert operation
	MOV	SI,FastOpenTable
	;call	far [es:si+2]
	CALL	far [SI+fastopen_entry.name_caching]

	CLC
SKIP_INSERT:
	POP	AX
	POP	CX			; restore registers
	POP	DI
	POP	SI
	POP	BX
	POP	ES
	POP	DS
GET_NEXT2:
	;or	[ss:FastOpenFlg],8
	OR	byte [SS:FastOpenFlg],No_Lookup
					; we got dir info from fastopen so
GET_NEXT_ELEMENT:
	POPF
	RETN


;============================================================================
; DEV.ASM, MSDOS 6.0, 1991
;============================================================================
; 28/07/2018 - Retro DOS v3.0

; DEV.ASM: Retro DOS v2.0 - 14/03/2018

;TITLE   DEV - Device call routines
;NAME    Dev

;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
;----------------------------------------------------------------------------
;
; Procedure Name : IOFUNC
;
; Inputs:
;	DS:SI Points to SFT
;	AH is function code
;		= 0 Input
;		= 1 Input Status
;		= 2 Output
;		= 3 Output Status
;		= 4 Flush
;		= 5 Input Status - System WAIT invoked for K09 if no char
;				   present.
;	AL = character if output
; Function:
;	Perform indicated I/O to device or file
; Outputs:
;	AL is character if input
;	If a status call
;		zero set if not ready
;		zero reset if ready (character in AL for input status)
; For regular files:
;	Input Status
;		Gets character but restores position
;		Zero set on EOF
;	Input
;		Gets character advances position
;		Returns ^Z on EOF
;	Output Status
;		Always ready
; AX altered, all other registers preserved
;----------------------------------------------------------------------------

IOFUNC:
	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
					; DEVIOBUF
	MOV	WORD [SS:IOXAD],DEVIOBUF
	MOV	WORD [SS:IOSCNT],1
	MOV	WORD [SS:DEVIOBUF],AX
	;test	word [si+5],8000h
	TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet
	JZ	short IOTO22		;AN000;
	JMP	IOTOFILE		;AN000;
IOTO22:
	;test	word [si+5],80h ; 17/05/2019
	TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
	JNZ	short IOTO33		;AN000;
	JMP	IOTOFILE		;AN000;
IOTO33:
	call	save_world
	MOV	DX,DS
	MOV	BX,SS
	MOV	DS,BX
	MOV	ES,BX
	XOR	BX,BX
	cmp	ah,5		    ; system wait enabled?
	jnz	short _no_sys_wait
	or	bx,0400H	    ; Set bit 10 in status word for driver
				    ; It is up to device driver to carry out
				    ; appropriate action.
_no_sys_wait:
	MOV	[IOCALL_REQSTAT],BX
	XOR	BX,BX
	MOV	[IOMED],BL

	MOV	BL,AH		 	; get function
	MOV	AH,[BX+LenTab]
	SHL	BX,1
	MOV	CX,[BX+CmdTab]
	MOV	BX,IOCALL
	MOV	[IOCALL_REQLEN],AH
	MOV	[IOCALL_REQFUNC],CH

	MOV	DS,DX
	CALL	DEVIOCALL
	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
	;test	di,8000h
	;jnz	short DevErr
	and	di,di
	js	short DevErr

OKDevIO:
	MOV	AX,SS
	MOV	DS,AX

	;cmp	ch, 5
	CMP	CH,DEVRDND
	JNZ	short DNODRD
	MOV	AL,[IORCHR]
	MOV	[DEVIOBUF],AL

DNODRD: 
	MOV	AH,[IOCALL_REQSTAT+1]
	NOT	AH			; Zero = busy, not zero = ready
	;and	ah,2
	AND	AH,STBUI>>8

QuickReturn:				;AN000; 2/13/KK
	call	restore_world

	; SR;
	; We return ax = -1 if the user failed on I24. This is the case if 
	; IoStatFail = -1 (set after return from the I24)
	;

	; MSDOS 6.0
	;pushf
	;mov	al,[ss:IoStatFail]	;assume fail error
	;cbw				;sign extend to word
	;cmp	ax,-1
	;jne	short not_fail_ret
	;inc	byte [ss:IoStatFail]
	;popf
	;retn

;not_fail_ret:
	MOV	AX,[SS:DEVIOBUF]	;ss override
	;popf
	retn

;IOTOFILEJ:
;	JMP	SHORT IOTOFILE

DevErr:
	MOV	AH,CL
	call	CHARHARD
	CMP	AL,1
	JNZ	short NO_RETRY
	call	restore_world		
	JMP	IOFUNC	; 10/08/2018

NO_RETRY:

	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
	; ready so that DOS doesn't get caught in a status loop when user 
	; simply wants to ignore the error.
	;
	; SR; If fail wanted by user set ax to special value (ax = -1). This 
	; should be checked by the caller on return
	;

					; SS override
	and	byte [SS:IOCALL_REQSTAT+1],0FDh
	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI >> 8)

	; SR;
	; Check if user failed
	;

	; MSDOS 6.0
	;cmp	al,3
	;jnz	short not_fail
	;dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
;not_fail:
	JMP	short OKDevIO

IOTOFILE:
	OR	AH,AH
	JZ	short IOIN
	DEC	AH
	JZ	short IOIST
	DEC	AH
	JZ	short IOUT
	retn				; NON ZERO FLAG FOR OUTPUT STATUS

IOIST:
	;push	word [si+15h]
	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
	;push	word [si+17h]
	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
	CALL	IOIN
	;pop	word [si+17h]
	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
	;pop	word [si+15h]
	POP	WORD [SI+SF_ENTRY.sf_position]
	retn

IOUT:
	CALL	SETXADDR
	call	DOS_WRITE
	CALL	RESTXADDR	; If you change this into a jmp don't
IOUT_retn:
	retn			; come crying to me when things don't
				; work ARR
IOIN:
	CALL	SETXADDR
					; SS override for DOS34_FLAG
	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
	CALL	DOS_READ
	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
	OR	CX,CX			; Check EOF
	CALL	RESTXADDR
					; SS override
	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
	jnz	short IOUT_retn	
	MOV	AL,1AH			; ^Z if no bytes
	retn

SETXADDR:
					; SS override
	POP	WORD [SS:CALLSCNT]	; Return address

	call	save_world

					; SS override for DMAADD and THISSFT
	PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
	PUSH	WORD [SS:DMAADD+2]
	MOV	[SS:THISSFT+2],DS

	push	ss
	pop	ds

	MOV	[THISSFT],SI		; Finish setting SFT pointer
	MOV	CX,[IOXAD+2]
	MOV	[DMAADD+2],CX
	MOV	CX,[IOXAD]
	MOV	[DMAADD],CX		; Set byte trans addr
	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
	JMP	SHORT RESTRET		; RETURN ADDRESS

RESTXADDR:
	POP	WORD [CALLSCNT]		; Return address
	POP	WORD [DMAADD+2]		; Restore Disk trans addr
	POP	WORD [DMAADD]

	call	restore_world
					; SS override
RESTRET:
	JMP	WORD [SS:CALLSCNT]	; Return address


; 29/07/2018 - Retro DOS v3.0
; IBMDOS.COM (1987) - Offset 4D82h

;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>

;----------------------------------------------------------------------------
;**	Dev_Open_SFT - Open the Device for an SFT
;
;	Dev_Open_SFT issues an open call to the device associated with
;	the SFT.
;
;	ENTRY	(ES:DI) = SFT
;	EXIT	none
;	USES	all
;----------------------------------------------------------------------------

DEV_OPEN_SFT:
	call	save_world
	;mov	al,0Dh	
	MOV	AL,DEVOPN
	JMP	SHORT DO_OPCLS

;----------------------------------------------------------------------------
; Procedure Name : DEV_CLOSE_SFT
;
; Inputs:
;	ES:DI Points to SFT
; Function:
;	Issue a CLOSE call to the correct device
; Outputs:
;	None
; ALL preserved
;----------------------------------------------------------------------------

DEV_CLOSE_SFT:
	call	save_world
	;mov	al,0Eh	
	MOV	AL,DEVCLS

	; Main entry for device open and close. AL contains the function 
	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
	; open/close to block devices. This allows networks to function but 
	; does NOT hang up with bogus change-line code.

	;entry	DO_OPCLS
DO_OPCLS:
	; Is the SFT for the net?  If so, no action necessary.

	; MSDOS 3.3
	;call	IsSFTNet
	;jnz	short OPCLS_DONE

	; MSDOS 6.0
	;test	word [es:di+5],8000h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JNZ	short OPCLS_DONE	; NOP on net SFTs
	XOR	AH,AH			; Unit
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
	;les	di,[es:di+7]
	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
	JNZ	short GOT_DEV_ADDR

	; We are about to call device open/close on a block driver. If no 
	; sharing then just short circuit to done.
	
;;;;;	invoke	CheckShare

	; MSDOS 3.3
	;call	CheckShare	; cmp byte [cs:fShare],0
	;jz	short OPCLS_DONE

	; MSDOS 6.0
					; SS override
	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
	JBE	short OPCLS_DONE	;AN010; yes

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ah,[es:di+1]
	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
	mov	cl,[es:di]
	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
	;les	di,[es:di+12h]
	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
GOT_DEV_ADDR:				; ES:DI -> device
	;test	word [es:di+4],800h
	TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
	JZ	short OPCLS_DONE	; Device can't
	PUSH	ES
	POP	DS
	MOV	SI,DI			; DS:SI -> device
OPCLS_RETRY:
	;Context ES
	push	ss
	pop	es
					; DEVCALL is in DOSDATA
	MOV	DI,DEVCALL

	MOV	BX,DI
	PUSH	AX
	;mov	al,13
	MOV	AL,DOPCLHL
	STOSB				; Length
	POP	AX
	XCHG	AH,AL
	STOSB				; Unit
	XCHG	AH,AL
	STOSB				; Command
	MOV	WORD [ES:DI],0		; Status
	PUSH	AX			; Save Unit,Command
	;invoke	DEVIOCALL2
	call	DEVIOCALL2

	;mov	di,[es:bx+3]
	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
	;test	di,8000h
	;jz	short OPCLS_DONEP	
	and	di,di
	jns	short OPCLS_DONEP	; No error
	;test	word [si+4],8000h
	; 22/11/2022 (BugFix)
	;TEST	word [ES:DI+SYSDEV.ATT],DEVTYP
	TEST	word [SI+SYSDEV.ATT],DEVTYP
	JZ	short BLKDEV
	MOV	AH,86H			; Read error in data, Char dev
	JMP	SHORT HRDERR

BLKDEV:
	MOV	AL,CL			; Drive # in AL
	MOV	AH,6			; Read error in data, Blk dev
HRDERR:
	;invoke	CHARHARD
	call	CHARHARD
	CMP	AL,1
	JNZ	short OPCLS_DONEP	; IGNORE or FAIL
					;  Note that FAIL is essentually IGNORED
	POP	AX			; Get back Unit, Command
	JMP	short OPCLS_RETRY

OPCLS_DONEP:
	POP	AX			; Clean stack
OPCLS_DONE:
	call	restore_world
	retn

;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
;----------------------------------------------------------------------------
;**	DevIoCall  - Call Device
;
;	ENTRY	DS:SI Points to device SFT
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX
;----------------------------------------------------------------------------
;**	DevIoCall2 - Call Device
;
;	ENTRY	DS:SI Points to DPB
;		ES:BX Points to request data
;	EXIT	DS:SI -> Device driver
;	USES	DS:SI,AX
;----------------------------------------------------------------------------

DEVIOCALL:
					; SS override for CALLSSEC, 
	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
	LDS	SI,[SI+SF_ENTRY.sf_devptr]

	;entry	DEVIOCALL2
DEVIOCALL2:
	;EnterCrit critDevice
	call	EcritDevice

	; MSDOS 6.0
	;TEST	word [SI+SYSDEV.ATT],DevTyp ;AN000; >32mb   block device ?
	;JNZ	short chardev2		;AN000; >32mb   no
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb   read ?
	;JZ	short chkext		;AN000; >32mb   yes
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb   write ?
	;JZ	short chkex		;AN000; >32mb   yes
	;CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
	;				;AN000; >32mb   write/verify ?
	;JNZ	short chardev2		;AN000; >32mb   no
;chkext:
	;CALL	RW_SC			;AN000;LB. use secondary cache if there
	;JC	short dev_exit		;AN000;LB. done
	;
	;TEST	word [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb   extended driver?
	;JZ	short chksector		;AN000;>32mb   no
	;ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
	;MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
	;MOV	[SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
	;MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
	;MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
	;MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
	;JMP	short chardev2		;AN000; >32mb
;chksector:				;AN000; >32mb
	;CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
	;JZ	short chardev2		;AN000; >32mb   then fake error
	;MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+ERROR_I24_NOT_DOS_DISK 
	;				;AN000; >32mb
	;JMP	SHORT dev_exit		;AN000; >32mb

;chardev2:				;AN000;

	; As above only DS:SI points to device header on entry, and DS:SI is 
	; preserved

	;mov	ax,[si+6]
	MOV	AX,[SI+SYSDEV.STRAT]
	MOV	[SS:CALLDEVAD],AX
	MOV	[SS:CALLDEVAD+2],DS
	CALL	far [SS:CALLDEVAD]
	;mov	ax,[si+8]
	MOV	AX,[SI+SYSDEV.INT]
	MOV	[SS:CALLDEVAD],AX
	CALL	far [SS:CALLDEVAD]
	; MSDOS 6.0
	;CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
	;JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
dev_exit:
	;LeaveCrit critDevice
	call	LcritDevice
	retn

;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
;---------------------------------------------------------------------------
;
; Procedure Name : SETREAD, SETWRITE
;
; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected
;
;---------------------------------------------------------------------------

SETREAD:
	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVRD ; mov cl,4
SETCALLHEAD:
	MOV	AL,DRDWRHL ; mov al,16h
	PUSH	SS
	POP	ES
					; DEVCALL is in DOSDATA
	MOV	DI,DEVCALL

	STOSB				; length
	POP	AX
	STOSB				; Unit
	PUSH	AX
	MOV	AL,CL
	STOSB				; Command code
	XOR	AX,AX
	STOSW				; Status
	ADD	DI,8			; Skip link fields
	POP	AX
	XCHG	AH,AL
	STOSB				; Media byte
	XCHG	AL,AH
	PUSH	AX
	MOV	AX,BX
	STOSW
	MOV	AX,DS
	STOSW				; Transfer addr
	POP	CX			; Real AX
	POP	AX			; Real CX
	STOSW				; Count
	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
	STOSW				; Start
	XCHG	AX,CX
	XCHG	DX,CX
	POP	DI
					; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	retn

	;entry	SETWRITE
SETWRITE:

; Inputs:
;	DS:BX = Transfer Address
;	CX = Record Count
;	DX = Starting Record
;	AH = Media Byte
;	AL = Unit Code
; Function:
;	Set up the device call header at DEVCALL
; Output:
;	ES:BX Points to DEVCALL
; No other registers effected

	PUSH	DI
	PUSH	CX
	PUSH	AX
	MOV	CL,DEVWRT ; mov cl,8
	ADD	CL,[SS:VERFLG]		; SS override
	JMP	SHORT SETCALLHEAD

;Break	<RW_SC -- Read Write Secondary Cache>
;---------------------------------------------------------------------------
;
; Procedure Name : RW_SC
;
; Inputs:
;	 [SC_CACHE_COUNT]= secondary cache count
;	 [SC_STATUS]= SC validity status
;	 [SEQ_SECTOR]= last sector read
; Function:
;	Read from or write through secondary cache
; Output:
;	ES:BX Points to DEVCALL
;	carry clear, I/O is not done
;		     [SC_FLAG]=1 if continuos sectors will be read
;	carry set, I/O is done
;
;----------------------------------------------------------------------------

;procedure   RW_SC,NEAR		;AN000;
;
;	; SS override for all variables used.
;
;	CMP	[SC_CACHE_COUNT],0	;AN000;LB. secondary cache exists?
;	JZ	scexit4 		;AN000;LB. no, do nothing
;	CMP	[CALLSCNT],1		;AN000;LB. sector count = 1 (buffer I/O)
;	JNZ	scexit4 		;AN000;LB. no, do nothing
;	PUSH	CX			    ;AN000;;LB.
;	PUSH	DX			    ;AN000;;LB. yes
;	PUSH	DS			    ;AN000;;LB. save registers
;	PUSH	SI			    ;AN000;;LB.
;	PUSH	ES			    ;AN000;;LB.
;	PUSH	DI			    ;AN000;;LB.
;	MOV	DX,WORD PTR [CALLSSEC]	    ;AN000;;LB.  starting sector
;	CMP	BYTE PTR [DEVCALL.REQFUNC],DEVRD ;AN000;LB. read ?
;	JZ	doread			    ;AN000;LB. yes
;	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
;	JMP	scexit2 		    ;AN000;LB. back to normal
;scexit4:				    ;AN000;
;	CLC				    ;AN000;LB. I/O not done yet
;	return				    ;AN000;LB.
;doread: 				    ;AN000;
;	CALL	SC2BUF			    ;AN000;LB. check if in SC
;	JC	readSC			    ;AN000;LB.
;	MOV	[DEVCALL.REQSTAT],STDON     ;AN000;LB. fake done and ok
;	STC				    ;AN000;LB. set carry
;	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
;readSC: 				    ;AN000;
;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
;	MOV	CX,WORD PTR [CALLSSEC]	    ;AN000;;LB. saved sequential sector
;	SUB	CX,WORD PTR [SEQ_SECTOR]    ;AN000;;LB. number
;	SBB	AX,WORD PTR [SEQ_SECTOR+2]  ;AN000;;LB.
;	CMP	AX,0			    ;AN000;;LB. greater than 64K
;	JNZ	saveseq2		    ;AN000;;LB. yes,save seq. sector #
;chklow: 						
;	CMP	CX,1			    ;AN000;;LB. <= 1
;	JA	saveseq2		    ;AN000;;LB. no, not sequential
;	MOV	[SC_STATUS],-1		    ;AN000;;LB. prsume all SC valid
;	MOV	AX,[SC_CACHE_COUNT]	    ;AN000;;LB. yes, sequential
;	MOV	[CALLSCNT],AX		    ;AN000;;LB. read continuous sectors
;readsr:
;	MOV	AX,WORD PTR [CALLXAD+2]     ;AN000;;LB. save buffer addr
;	MOV	[TEMP_VAR2],AX		    ;AN000;;LB. in temp vars
;	MOV	AX,WORD PTR [CALLXAD]	    ;AN000;;LB.
;	MOV	[TEMP_VAR],AX		    ;AN000;;LB.
;						
;	MOV	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;LB. use SC cache addr as
;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;LB. transfer addr
;	MOV	AX,WORD PTR [SC_CACHE_PTR+2] ;AN000;LB.
;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;LB.
;	MOV	[SC_FLAG],1		    ;AN000;LB. flag it for later;
;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
;	MOV	[CURSC_DRIVE],AL	    ;AN000;;LB. set current drive
;	MOV	AX,WORD PTR [CALLSSEC]	    ;AN000;;LB. current sector
;	MOV	[CURSC_SECTOR],AX	    ;AN000;;LB. set current sector
;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB.
;	MOV	[CURSC_SECTOR+2],AX	    ;AN000;;LB.
;saveseq2:				    ;AN000;
;	CLC				    ;AN000;LB. clear carry
;saveseq:				    ;AN000;	
;	MOV	AX,[HIGH_SECTOR]	    ;AN000;LB. save current sector #
;	MOV	WORD PTR [SEQ_SECTOR+2],AX  ;AN000;LB. for access mode ref.
;	MOV	AX,[CALLSSEC]		    ;AN000;LB.	
;	MOV	WORD PTR [SEQ_SECTOR],AX    ;AN000;LB.	
;	JMP	short scexit 		    ;AN000;LB.	
;						
;scexit2:				    ;AN000;LB.
;	CLC				    ;AN000;LB.	clear carry
;scexit: 				    ;AN000;		
;	POP	DI			    ;AN000;;LB.
;	POP	ES			    ;AN000;;LB. restore registers
;	POP	SI			    ;AN000;;LB.
;	POP	DS			    ;AN000;;LB.
;	POP	DX			    ;AN000;;LB.
;	POP	CX			    ;AN000;;LB.
;	return				    ;AN000;;LB.
;							
;EndProc RW_SC				    ;AN000;

;Break	<IN_SC -- check if in secondary cache>
;--------------------------------------------------------------------------
;
; Procedure Name : IN_SC
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [HIGH_SECTOR]:DX= sector number
; Function:
;	Check if the sector is in secondary cache
; Output:
;	carry clear, in SC
;	   CX= the index in the secondary cache
;	carry set, not in SC
;
;---------------------------------------------------------------------------

;procedure   IN_SC,NEAR		    ;AN000;
;
;	; SS override for all variables used
;
;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
;	CMP	AL,[CURSC_DRIVE]	    ;AN000;;LB. same as SC drive
;	JNZ	outrange2		    ;AN000;;LB. no
;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
;	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
;	SUB	CX,WORD PTR [CURSC_SECTOR]    ;AN000;;LB. number
;	SBB	AX,WORD PTR [CURSC_SECTOR+2]  ;AN000;;LB.
;	CMP	AX,0			    ;AN000;;LB. greater than 64K
;	JNZ	outrange2		    ;AN000;;LB. yes
;	CMP	CX,[SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
;	JAE	outrange2		    ;AN000;;LB. yes
;	CLC				    ;AN000;;LB. clear carry
;	JMP	short inexit		    ;AN000;;LB. in SC
;outrange2:				    ;AN000;;LB. set carry
;	STC				    ;AN000;;LB.
;inexit: 				    ;AN000;;LB.
;	return				    ;AN000;;LB.
;
;EndProc IN_SC				    ;AN000;

;Break	<INVALIDATE_SC - invalide secondary cache>
;---------------------------------------------------------------------------
;
; Procedure Name : Invalidate_Sc
;
; Inputs:  [SC_DRIVE]= requesting drive
;	   [CURSC_DRIVE]= current SC drive
;	   [CURSC_SECTOR] = starting scetor # of SC
;	   [SC_CACHE_COUNT] = SC count
;	   [SC_STAUS] = SC status word
;	   [HIGH_SECTOR]:DX= sector number
;
; Function:
;	invalidate secondary cache if in there
; Output:
;	[SC_STATUS] is updated
;---------------------------------------------------------------------------

;procedure   INVALIDATE_SC,NEAR	    ;AN000;
;
;	; SS override for all variables used
;
;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
;	JC	outrange		    ;AN000;;LB. no
;	MOV	AX,1			    ;AN000;;LB. invalidate the sector
;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
;	NOT	AX			    ;AN000;;LB.
;	AND	[SC_STATUS],AX		    ;AN000;;LB. save the status
;outrange:				    ;AN000;;LB.
;	return				    ;AN000;;LB.
;
;EndProc INVALIDATE_SC			    ;AN000;


;Break	<VIRREAD- virtually read data into buffer>
;--------------------------------------------------------------------------
;
; Procedure Name : SC_FLAG
;
; Inputs:  SC_FLAG = 0 , no sectors were read into SC
;		     1, continous sectors were read into SC
; Function:
;	   Move data from SC to buffer
; Output:
;	 carry clear, data is moved to buffer
;	 carry set, bad sector or exceeds maximum sector
;	   SC_FLAG =0
;	   CALLSCNT=1
;	   SC_STATUS= -1 if succeeded
;     
;		       0 if failed
;--------------------------------------------------------------------------

;procedure   VIRREAD,NEAR	    ;AN000;
;
;	; SS override for all variables used
;
;	CMP	[SC_FLAG],0		    ;AN000;;LB.  from SC fill
;	JZ	sc2end			    ;AN000;;LB.  no
;	MOV	AX,[TEMP_VAR2]		    ;AN000;;LB. restore buffer addr
;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;;LB.
;	MOV	AX,[TEMP_VAR]		    ;AN000;;LB.
;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;;LB.
;	MOV	[SC_FLAG],0		    ;AN000;;LB.  reset sc_flag
;	MOV	[CALLSCNT],1		    ;AN000;;LB.  one sector transferred
;
;	TESTB	[DEVCALL.REQSTAT],STERR     ;AN000;;LB.  error?
;	JNZ	scerror 		    ;AN000;;LB. yes
;	PUSH	DS			    ;AN000;;LB.
;	PUSH	SI			    ;AN000;;LB.
;	PUSH	ES			    ;AN000;;LB.
;	PUSH	DI			    ;AN000;;LB.
;	PUSH	DX			    ;AN000;;LB.
;	PUSH	CX			    ;AN000;;LB.
;	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
;	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buffer
;	POP	CX			    ;AN000;;LB.
;	POP	DX			    ;AN000;;LB.
;	POP	DI			    ;AN000;;LB.
;	POP	ES			    ;AN000;;LB.
;	POP	SI			    ;AN000;;LB.
;	POP	DS			    ;AN000;;LB.
;	JMP	SHORT sc2end		    ;AN000;;LB. return
;
;scerror:				    ;AN000;
;	MOV	[CALLSCNT],1		    ;AN000;;LB. reset sector count to 1
;	MOV	[SC_STATUS],0		    ;AN000;;LB. invalidate all SC sectors
;	MOV	[CURSC_DRIVE],-1	    ;AN000;;LB. invalidate drive
;	STC				    ;AN000;;LB. carry set
;	return				    ;AN000;;LB.
;
;sc2end: 				    ;AN000;
;	CLC				    ;AN000;;LB. carry clear
;	return				    ;AN000;;LB.
;
;EndProc VIRREAD 			    ;AN000;

;Break	<SC2BUF- move data from SC to buffer>
;----------------------------------------------------------------------------
;
; Procedure Name : SC2BUF
;
; Inputs:  [SC_STATUS] = SC validity status
;	   [SC_SECTOR_SIZE] = request sector size
;	   [SC_CACHE_PTR] = pointer to SC
; Function:
;	   Move data from SC to buffer
; Output:
;	   carry clear, in SC  and data is moved
;	   carry set, not in SC and data is not moved
;---------------------------------------------------------------------------

;procedure   SC2BUF,NEAR 	    ;AN000;
;
;	; SS override for all variables used
;
;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
;	JC	noSC			    ;AN000;;LB. no
;	MOV	AX,1			    ;AN000;;LB. check if valid sector
;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
;	TEST	[SC_STATUS],AX		    ;AN000;;LB.
;	JZ	noSC			    ;AN000;;LB. invalid
;entry SC2BUF2				    ;AN000;
;	MOV	AX,CX			    ;AN000;;LB. times index with
;	MUL	[SC_SECTOR_SIZE]	    ;AN000;;LB. sector size
;	ADD	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;;LB. add SC starting addr
;	ADC	DX,WORD PTR [SC_CACHE_PTR+2];AN000;;LB.
;	MOV	DS,DX			    ;AN000;    ;LB. DS:SI-> SC sector addr
;	MOV	SI,AX			    ;AN000;    ;LB.
;	MOV	ES,WORD PTR [CALLXAD+2]     ;AN000;    ;LB. ES:DI-> buffer addr
;	MOV	DI,WORD PTR [CALLXAD]	    ;AN000;    ;LB.
;	MOV	CX,[SC_SECTOR_SIZE]	    ;AN000;    ;LB. count= sector size
;	SHR	CX,1			    ;AN000;    ;LB. may use DWORD move for 386
;entry MOVWORDS				    ;AN000;
;	CMP	[DDMOVE],0		    ;AN000;    ;LB. 386 ?
;	JZ	nodd			    ;AN000;    ;LB. no
;	SHR	CX,1			    ;AN000;    ;LB. words/2
;	DB	66H			    ;AN000;    ;LB. use double word move
;nodd:
;	REP	MOVSW			    ;AN000;    ;LB. move to buffer
;	CLC				    ;AN000;    ;LB. clear carry
;	return				    ;AN000;    ;LB. exit
;noSC:					    ;AN000;
;	STC				    ;AN000;    ;LB. set carry
;sexit:					    ;AN000;
;	return				    ;AN000;    ;LB.
;
;EndProc SC2BUF


;============================================================================
; MKNODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/07/2018 - Retro DOS v3.0

;	TITLE	MKNODE - Node maker
;	NAME	MKNODE

;**	MKNODE.ASM
;
;	Low level routines for making a new local file system node
;	and filling in an SFT from a directory entry
;
;	BUILDDIR
;	SETDOTENT
;	MakeNode
;	NEWENTRY
;	FREEENT
;	NEWDIR
;	DOOPEN
;	RENAME_MAKE
;	CHECK_VIRT_OPEN
;
;	Revision history:
;
;	 AN000	version 4.0  Jan. 1988
;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30

;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
;----------------------------------------------------------------------------
;
; Procedure Name : BUILDDIR,NEWDIR
;
; Inputs:
;       ES:BP Points to DPB
;       [THISSFT] Set if using NEWDIR entry point
;               (used by ALLOCATE)
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [DIRSTART] Points to first cluster of dir (0 means root)
; Function:
;       Grow directory if no free entries and not root
; Outputs:
;       CARRY SET IF FAILURE
;       ELSE
;          AX entry number of new entry
;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
;               AX = first entry of new dir
;       GETENT should be called to set [LASTENT]
;
;----------------------------------------------------------------------------

BUILDDIR:
	; 29/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h

        MOV     AX,[ENTFREE]
        CMP     AX,-1
        JZ	short CHECK_IF_ROOT
        CLC
        retn

CHECK_IF_ROOT:
        CMP     word [DIRSTART],0
        JNZ	short NEWDIR
        STC
builddir_retn:
        retn				; Can't grow root

	;entry   NEWDIR
NEWDIR:        
	MOV     BX,[DIRSTART]
        OR      BX,BX
        JZ	short NULLDIR
	call	GETEOF
        jc	short builddir_retn	; Screw up
NULLDIR:
        MOV     CX,1
	call	ALLOCATE
        jc	short  builddir_retn
        MOV     DX,[DIRSTART]
        OR      DX,DX
        JNZ	short ADDINGDIR
	call	SETDIRSRCH
        jc	short  builddir_retn
        MOV     word [LASTENT],-1
        JMP     SHORT GOTDIRREC
ADDINGDIR:
        PUSH    BX
        MOV     BX,[CLUSNUM]
        call	IsEOF
        POP     BX
        JB	short NOTFIRSTGROW
;;;; 10/17/86 update CLUSNUM in the fastopen cache
        MOV     [CLUSNUM],BX
        PUSH    CX
        PUSH    AX
        PUSH    BP
        MOV     AH,1			; CLUSNUM update
	;mov	dl,[es:bp+0]
	mov	dl,[ES:BP] ; 09/09/2018
        ;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
        MOV     CX,[DIRSTART]		; first cluster #
        MOV     BP,BX 			; CLUSNUM
	call	FastOpen_Update
        POP     BP
        POP     AX
        POP     CX

;;;; 10/17/86 update CLUSNUM in the fastopen cache
NOTFIRSTGROW:
        MOV     DX,BX
        XOR     BL,BL
	call	FIGREC
GOTDIRREC:
	;mov	cl,[es:bp+4]
        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
        INC     CL
        XOR     CH,CH
ZERODIR:
        PUSH    CX
	;mov	byte [ALLOWED],18h
        MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
        MOV     AL,0FFH
        call	GETBUFFR
        JNC	short GET_SSIZE
        POP     CX
        retn

GET_SSIZE:
	;mov	cx,[es:bp+2]
        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
        PUSH    ES
        LES     DI,[CURBUF]
	;or	byte [es:di+5],4
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
        PUSH    DI
	;add	di,16
        ADD     DI,BUFINSIZ
        XOR     AX,AX
        SHR     CX,1
        REP     STOSW
        JNC	short EVENZ
        STOSB
EVENZ:
        POP     DI

	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
	;				;LB. if already dirty		  ;AN000;
        ;JNZ	short _yesdirty_	;LB.  don't increment dirty count ;AN000;
        ;call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
        
	;or	byte [es:di+5],40h
	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
;_yesdirty_:
        POP	ES
        POP	CX

	; MSDOS 6.0
	;add	dx, 1
	;adc	word [HIGH_SECTOR],0

	INC	DX
        LOOP    ZERODIR

        MOV     AX,[LASTENT]
        INC     AX
        CLC
        retn

;--------------------------------------------------------------------------
;
; Procedure Name : SETDOTENT
;
; set up a . or .. directory entry for a directory.
;
;   Inputs:     ES:DI point to the beginning of a directory entry.
;               AX contains ". " or ".."
;               DX contains first cluster of entry
;
;----------------------------------------------------------------------------

SETDOTENT:
;	Fill in name field
        STOSW
        MOV     CX,4
        MOV     AX,"  " ; 2020h
        REP     STOSW
        STOSB

;	Set up attribute
	;mov	al, 10h
        MOV     AL,attr_directory
        STOSB

;	Initialize time and date of creation
        ADD     DI,10
        MOV     SI,[THISSFT]
	;mov	ax,[si+0Dh]
        MOV     AX,[SI+SF_ENTRY.sf_time]
        STOSW
	;mov	ax,[si+0Fh]
        MOV     AX,[SI+SF_ENTRY.sf_date]
	STOSW

;	Set up first cluster field
        MOV     AX,DX
        STOSW

;	0 file size
        XOR     AX,AX
        STOSW
        STOSW
        retn

;Break   <MAKENODE -- CREATE A NEW NODE>
;---------------------------------------------------------------------------
;
; Procedure Name : MakeNode
;
; Inputs:
;       AL - attribute to create
;       AH = 0 if it is ok to truncate a file already by this name
;	AH != 0 if truncation not allowed (prexisting file is an error)
;               (AH ignored on dirs and devices)
;
;        NOTE: When making a DIR or volume ID, AH need not be set since
;               a name already existant is ALWAYS an error in these cases.
;
;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
;               terminated)
;       [CURR_DIR_END] Points to end of Current dir part of string
;               ( = -1 if current dir not involved, else
;                Points to first char after last "/" of current dir part)
;       [THISCDS] Points to CDS being used
;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
; Function:
;       Make a new node
; Outputs:
;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
;       CARRY SET IF ERROR
;          AX = 1 A node by this name exists and is a directory
;          AX = 2 A new node could not be created
;          AX = 3 A node by this name exists and is a disk file
;               (AH was NZ on input)
;          AX = 4 Bad Path
;               SI return from GetPath maintained
;          AX = 5 Attribute mismatch
;          AX = 6 Sharing Violation
;               (INT 24 generated ALWAYS since create is always compat mode
;          AX = 7 file not found for Extended Open (not exists and fails)
;       ELSE
;          AX = 0       Disk Node
;          AX = 3       Device Node (error in some cases)
;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
;               containing new node.
;          [CURBUF+2]:BX Points to entry
;          [CURBUF+2]:SI Points to entry.dir_first
;          [THISSFT] is filled in
;               sf_mode = unchanged.
;          Attribute byte in entry is input AL
; DS preserved, others destroyed
;
;-------------------------------------------------------------------------

MakeNode:
	;mov	word [CREATING],0E5FFh
	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
        PUSH    AX              ; Save AH value
	MOV	byte [NoSetDir],0
	MOV	[SATTRIB],AL
	call	GetPathNoSet
        MOV     DL,CL           ; Save CL info
        MOV     CX,AX           ; Device ID to CH
        POP     AX              ; Get back AH
        JNC	short make_exists ; File existed
        JNZ	short make_err_4 ; Path bad
        CMP     DL,80h          ; Check "CL" return from GETPATH
        JZ	short make_type	; Name simply not found, and no metas
make_err_4:
        MOV     AL,4            ; case 1 bad path
make_err_ret:
        XOR     AH,AH
        STC
make_retn:
        retn

        ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
RENAME_MAKE:
make_type:
;Extended Open hooks
	; MSDOS 6.0
	;TESTB	EXTOPEN_ON,ext_open_on	;FT. from extended open		;AN000;
	;JZ	make_type2		;FT. no				;AN000;
	;OR	EXTOPEN_ON,ext_file_not_exists ;FT. set for extended open ;AN000;
	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
	;JNZ    make_type2		;FT. no				;AN000;
	;STC				;FT. set carry			;AN000;
	;MOV    AX,7			;FT. file not found		;AN000;
	;return				;FT.				;AN000;
;	Extended Open hooks

make_type2:
        LES     DI,[THISSFT]
        XOR     AX,AX           ; nothing exists Disk Node
        STC                     ; Not found
        JMP     short make_new

; The node exists.  It may be either a device, directory or file:
;   Zero set => directory
;   High bit of CH on => device
;   else => file
make_exists:
        JZ	short make_exists_dir
        MOV     AL,3            ; file exists type 3  (error or device node)
	;test	byte [ATTRIB],18h
	TEST	byte [ATTRIB],attr_volume_id+attr_directory
        JNZ	short make_err_ret_5
				; Cannot already exist as Disk or Device Node
                                ;       if making DIR or Volume ID
        OR      CH,CH
        JS	short make_share ; No further checks on attributes if device
        OR      AH,AH
        JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
        PUSH    CX              ; Save device ID
        MOV     ES,[CURBUF+2]
	;mov	ch,[es:bx+0Bh]
        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
	;test	ch,1
	test	CH,attr_read_only
        JNZ	short make_err_ret_5P ; Cannot create on read only files
	call	MatchAttributes
        POP     CX              ; Devid back in CH
        JNZ	short make_err_ret_5 ; Attributes not ok
        XOR     AL,AL           ; AL = 0, Disk Node
make_share:
        XOR     AH,AH
        PUSH    AX              ; Save Disk or Device node
        PUSH    CX              ; Save Device ID
        MOV     AH,CH           ; Device ID to AH
        CALL    DOOPEN          ; Fill in SFT for share check
        LES     DI,[THISSFT]
	push	si
	push	bx		; Save CURBUF pointers
	call	ShareEnter
        jnc	short MakeEndShare

; User failed request.
	pop	bx
	pop	si
	pop	cx
	pop	ax

Make_Share_ret:
        MOV     AL,6
        JMP	short make_err_ret

make_err_ret_5P:
        POP     CX              ; Get back device ID
make_err_ret_5:
        MOV     AL,5            ; Attribute mismatch
        JMP     make_err_ret

make_exists_dir:
        MOV     AL,1            ; exists as directory, always an error
        JMP     make_err_ret

make_save:
        PUSH    AX              ; Save whether Disk or File
        MOV     AX,CX           ; Device ID to AH
        CALL    NEWENTRY
        POP     AX              ; 0 if Disk, 3 if File
        jnc	short make_retn
        MOV     AL,2            ; create failed case 2
make_save_retn:
        retn

make_new:
        call    make_save
        jc	short make_save_retn	; case 2 fail
	test	BYTE [ATTRIB],attr_directory
        jnz	short make_save_retn	; Don't "open" directories, so don't
                                ;   tell the sharer about them
	push	ax
	push	bx
	push	si		
        call	ShareEnter
	pop	si
	pop	bx
	pop	ax
	jnc	short make_save_retn
;
; We get here by having the user FAIL a share problem. Typically a failure of
; this nature is an out-of-space or an internal error. We clean up as best as
; possible: delete the newly created directory entry and return share_error.
;
        PUSH    AX
        LES     DI,[CURBUF]
	;mov	byte [es:bx],0E5h
	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
	
	; MSDOS 6.0
	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
	;				;LB. if already dirty		  ;AN000;
        ;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	;or	byte [es:di+5],40h
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
;yesdirty3:
        LES     BP,[THISDPB]
        mov	al,[ES:BP]
	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
        call	FLUSHBUF		; write out buffer.
        POP     AX
        jmp	short Make_Share_ret
;
; We have found an existing file. We have also entered it into the share set.
; At this point we need to call newentry to correctly address the problem of
; getting rid of old data (create an existing file) or creating a new
; directory entry (create a new file). Unfortunately, this operation may
; result in an INT 24 that the user doesn't return from, thus locking the file
; irretrievably into the share set. The correct solution is for us to LEAVE
; the share set now, do the operation and then reassert the share access.
;
; We are allowed to do this! There is no window! After all, we are in
; critDisk here and for someone else to get in, they must enter critDisk also.
;
MakeEndShare:
        LES     DI,[THISSFT]		; grab SFT
        XOR     AX,AX
	call	EcritSFT
	xchg	AX,[ES:DI]
	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
	push	ax
	push	di
	push	es
        PUSHF
        call	ShareEnd                ; remove sharing
        POPF
	pop	es
	pop	di
        pop	word [ES:DI]	
	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
	call	LcritSFT
	pop	bx
	pop	si
	pop	cx
	pop	ax
        CALL    make_save

; If the user failed, we do not reenter into the sharing set.

        jc	short make_save_retn	; bye if error
	push	ax
	push	bx
	push	si
        PUSHF
        call	ShareEnter
        POPF
	pop	si
	pop	bx
	pop	ax

; If Share_check fails, then we have an internal ERROR!!!!!

makeendshare_retn:
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : NEWENTRY
;
; Inputs:
;       [THISSFT] set
;       [THISDPB] set
;       [LASTENT] current last valid entry number in directory if no free
;               entries
;       [VOLID] set if a volume ID was found during search
;	Attrib Contains attributes for new file
;       [DIRSTART] Points to first cluster of dir (0 means root)
;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
;               NC means file existed (device)
;               C  means file did not exist
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Make a new directory entry
;       If an old one existed it is truncated first
; Outputs:
;       Carry set if error
;               Can't grow dir, atts didn't match, attempt to make 2nd
;               vol ID, user FAILed to I 24
;       else
;               outputs of DOOPEN
; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
;
;----------------------------------------------------------------------------

NEWENTRY:
        LES     BP,[THISDPB]
        JNC	short EXISTENT	
        CMP     byte [FAILERR],0
        STC
        jnz	short makeendshare_retn	; User FAILed, node might exist
        CALL    BUILDDIR        ; Try to build dir
        jc	short makeendshare_retn	; Failed
        call	GETENT          ; Point at that free entry
        jc	short makeendshare_retn	; Failed
        JMP     SHORT FREESPOT

ERRRET3:
        STC
newentry_retn:
        retn

EXISTENT:
        OR      AH,AH           ; Check if file is I/O device
        JNS	short NOT_DEV1
        JMP     DOOPEN          ; If so, proceed with open

NOT_DEV1:
        call	FREEENT		; Free cluster chain
        jc	short newentry_retn ; Failed
FREESPOT:
	;test	byte [ATTRIB],8
	test	BYTE [ATTRIB],attr_volume_id
        JZ	short NOTVOLID
        CMP     BYTE [VOLID],0
        JNZ	short ERRRET3	; Can't create a second volume ID
NOTVOLID:
        MOV     ES,[CURBUF+2]
        MOV     DI,BX

        MOV     SI,NAME1

        MOV     CX,5
        REP     MOVSW
        MOVSB                   ; Move name into dir entry
	MOV	AL,[ATTRIB]
	STOSB                   ; Attributes

;; File Tagging for Create DOS 4.00
        MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
;; File Tagging for Create DOS 4.00

        XOR     AX,AX
        REP     STOSW           ; Zero pad
        call	DATE16
        XCHG    AX,DX
        STOSW                   ; dir_time
        XCHG    AX,DX
        STOSW                   ; dir_date
        XOR     AX,AX
        PUSH    DI              ; Correct SI input value
				; 	(recomputed for new buffer)
        STOSW                   ; Zero dir_first and size
        STOSW
        STOSW
updnxt:
	MOV	SI,[CURBUF]

	; MSDOS 6.0
	;TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
	;			;LB. if already dirty		  ;AN000;
        ;JNZ	short yesdirty4	;LB.  don't increment dirty count ;AN000;
        ;call	INC_DIRTY_COUNT	;LB.				  ;AN000;
        
	;or	byte [es:si+5],40h
	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
;yesdirty4:
        LES     BP,[THISDPB]
	MOV	AL,[ES:BP]	; mov al,[es:bp+0] 
        ;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
        PUSH    AX
        PUSH    BX
; If we have a file, we need to increment the open ref. count so that
; we have some protection against invalid media changes if an Int 24
; error occurs.
; Do nothing for a device.
	push	es
	push	di
        LES     DI,[THISSFT]
	;test	word [es:di+5],80h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
        jnz	short GotADevice
	push	ds
	push	bx
        LDS     BX,[THISDPB]
	;mov	[es:di+7],bx
        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
        MOV     BX,DS
	;mov	[es:di+9],bx
        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
	pop	bx
	pop	ds ; need to use DS for segment later on
	call	DEV_OPEN_SFT    ; increment ref. count
        mov	byte [VIRTUAL_OPEN],1; set flag
GotADevice:
	pop	di
	pop	es

        call	FLUSHBUF
        Call    CHECK_VIRT_OPEN ; decrement ref. count                          ;AN000;
        POP     BX
        POP     AX
        POP     SI              ; Get SI input back
        MOV     AH,AL           ; Get I/O driver number back
        jnc	short DOOPEN    ; Failed
	retn

;NOTE FALL THROUGH

; Inputs:
;       [THISDPB] points to DPB if file
;       [THISSFT] points to SFT being used
;       AH = Device ID byte
;       If FILE
;           [CURBUF+2]:BX points to start of directory entry
;           [CURBUF+2]:SI points to dir_first of directory entry
;       If device
;           DS:BX points to start of "fake" directory entry
;           DS:SI points to dir_first of "fake" directory entry
;               (has DWORD pointer to device header)
; Function:
;       Fill in SFT from dir entry
; Outputs:
;       CARRY CLEAR
;       sf_ref_count and sf_mode fields not altered
;       sf_flags high byte = 0
;       sf_flags low byte = AH except
;       sf_flags Bit 6 set (not dirty or not EOF)
;       sf_attr sf_date sf_time sf_name set from entry
;       sf_position = 0
;       If device
;           sf_devptr = dword at dir_first (pointer to device header)
;           sf_size = 0
;       If file
;           sf_firclus sf_size set from entry
;           sf_devptr = [THISDPB]
;           sf_cluspos = 0
;           sf_lstclus = sf_firclus
;           sf_dirsec sf_dirpos set
; DS,SI,BX preserved, others destroyed

	;entry	DOOPEN
DOOPEN:
;	Generate and store attribute

        MOV     DH,AH           ; AH to different place
        LES     DI,[THISSFT]
	;add	di,4
        ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
        XOR     AL,AL           ; Assume it's a device, devices have an
                                ;   attribute of 0 (for R/O testing etc).
        OR      DH,DH           ; See if our assumption good.
        JS	short DEV_SFT1	; If device DS=DOSGROUP
        MOV     DS,[CURBUF+2]
	;mov	al,[BX+0Bh]
        MOV     AL,[BX+dir_entry.dir_attr]
				; If file, get attrib from dir entry
DEV_SFT1:
        STOSB                   ; sf_attr, ES:DI -> sf_flags

;	Generate and store flags word

        XOR     AX,AX
        MOV     AL,DH
	;or	al,40h
        OR      AL,devid_file_clean
        STOSW                   ; sf_flags, ES:DI -> sf_devptr

;	Generate and store device pointer

        PUSH    DS
	;lds	ax,[bx+1Ah]
        LDS     AX,[BX+dir_entry.dir_first] ; Assume device
        OR      DH,DH
        JS	short DEV_SFT2

;hkn; SS override
        LDS     AX,[SS:THISDPB]	; Was file
DEV_SFT2:
        STOSW 			; store offset
        MOV     AX,DS
        POP     DS
	STOSW			; store segment
				; ES:DI -> sf_firclus

;	Generate pointer to, generate and store first cluster 
;	(irrelevant for devices)

        PUSH    SI              ; Save pointer to dir_first
        MOVSW                   ; dir_first -> sf_firclus
                                ; DS:SI -> dir_size_l, ES:DI -> sf_time

;	Copy time/date of last modification

	;sub	si,6
        SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
				; DS:SI->dir_time
        MOVSW                   ; dir_time -> sf_time
                                ; DS:SI -> dir_date, ES:DI -> sf_date
        MOVSW                   ; dir_date -> sf_date
                                ; DS:SI -> dir_first, ES:DI -> sf_size

;	Generate and store file size (0 for devices)

        LODSW                   ; skip dir_first, DS:SI -> dir_size_l
        LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
        MOV     CX,AX           ; dir_size_l in CX
        LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
        OR      DH,DH
        JNS	short FILE_SFT1
        XOR     AX,AX
        MOV     CX,AX           ; Devices are open ended
FILE_SFT1:
        XCHG    AX,CX
        STOSW                   ; Low word of sf_size
        XCHG    AX,CX
        STOSW                   ; High word of sf_size
                                ; ES:DI -> sf_position
; Initialize position to 0

        XOR     AX,AX
        STOSW
        STOSW                   ; sf_position
                                ; ES:DI -> sf_cluspos

; Generate cluster optimizations for files

        OR      DH,DH
        JS	short DEV_SFT3
        STOSW                   ; sf_cluspos
	;mov	ax,[bx+1Ah]
        MOV     AX,[BX+dir_entry.dir_first]
	; MSDOS 3.3
	STOSW                   ; sf_lstclus
	; MSDOS 6.0
        ;PUSH	DI              ;AN004; save dirsec offset
        ;SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
        ;MOV	[ES:DI.sf_lstclus],AX	;AN004; save it
        ;POP	DI              ;AN004; restore dirsec offset

; DOS 3.3  FastOpen  6/13/86

	PUSH	DS

;hkn; SS is DOSDATA
	push	ss
	pop	ds
	;test	byte [FastOpenFlg],4
	TEST	byte [FastOpenFlg],Special_Fill_Set
	JZ	short Not_FastOpen

;hkn; FastOpen_Ext_Info is in DOSDATA
        MOV     SI,FastOpen_Ext_Info

        MOV     AX,[SI+FEI.dirsec]
        STOSW                   ; sf_dirsec
	; MSDOS 6.0
        ;MOV	AX,[SI+FEI.dirsec+2]
				;;; changed for >32mb
        ;STOSW                   ; sf_dirsec
	; 19/08//2018
	mov	al,[SI]
        ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
        STOSB                   ; sf_dirpos
        POP	DS
        JMP     short Next_Name

; DOS 3.3  FastOpen  6/13/86

Not_FastOpen:
        POP     DS		; normal path

;hkn; SS override
        MOV     SI,[SS:CURBUF]	; DS:SI->buffer header

        MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
        STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
        ; MSDOS 6.0
	;MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
        ;STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
        
	MOV     AX,BX
	;add	si,16
        ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
        SUB     AX,SI           ; AX = BX relative to start of sector
        ;mov	cl,32
	MOV     CL,dir_entry.size
        DIV     CL
        STOSB                   ; sf_dirpos

Next_Name:
        JMP     SHORT FILE_SFT2

DEV_SFT3:
	;add	di,7
        ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
FILE_SFT2:
;
; Copy in the object's name
;
        MOV     SI,BX           ; DS:SI points to dir_name
        MOV     CX,11
        REP     MOVSB           ; sf_name
        POP     SI              ; recover DS:SI -> dir_first

;hkn; SS is DOSDATA
        push	ss
	pop	ds
        CLC
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : FREEENT
;
; Inputs:
;       ES:BP -> DPB
;       [CURBUF] Set
;       [CURBUF+2]:BX points to directory entry
;       [CURBUF+2]:SI points to above dir_first
; Function:
;       Free the cluster chain for the entry if present
; Outputs:
;       Carry set if error (currently user FAILed to I 24)
;       (NOTE dir_firclus and dir_size_l/h are wrong)
; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
;---------------------------------------------------------------------------

FREEENT:
        PUSH    DS
        LDS     DI,[CURBUF]
        MOV     CX,[SI]         ; Get pointer to clusters
	; 19/05/2019
	; MSDOS 6.0
	;MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
;hkn; SS override
        ;MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
        MOV     DX,[DI+BUFFINFO.buf_sector]
        POP     DS
	CMP	CX,2
        JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
	;cmp	cx,[es:bp+0Dh]
        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
        JA	short RET1	; Treat like zero length file (firclus mucked)
        SUB     BX,DI
        PUSH    BX              ; Save offset
	;PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
        PUSH    DX              ; Save sector number
        MOV     BX,CX
        call	RELEASE         ; Free any data allocated
        POP     DX
        ;POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
        JNC	short GET_BUF_BACK
        POP     BX
freeent_retn:
        retn			; Screw up

GET_BUF_BACK:
	;mov	byte [ALLOWED],18h
        MOV     byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
        XOR     AL,AL
	call	GETBUFFR        ; Get sector back
        POP     BX              ; Get offset back
        jc	short freeent_retn
	call	SET_BUF_AS_DIR
        ADD     BX,[CURBUF]	; Correct it for new buffer
        MOV     SI,BX
	;add	si,1Ah
        ADD     SI,dir_entry.dir_first	; Get corrected SI
RET1:
        CLC
        retn

;---------------------------------------------------------------------------
;
; Procedure Name : CHECK_VIRT_OPEN
;
; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
; flag [VIRTUAL_OPEN].
; No registers affected (including flags).
; On input, [THISSFT] points to current SFT.
;
;---------------------------------------------------------------------------

CHECK_VIRT_OPEN:
	        PUSH    AX
        lahf                    ; preserve flags
        CMP     byte [VIRTUAL_OPEN],0
        JZ	short ALL_CLOSED
        mov     byte [VIRTUAL_OPEN],0	; reset flag
	push	es
	push	di
        LES     DI,[THISSFT]
        call	DEV_CLOSE_SFT
	pop	di
	pop	es

ALL_CLOSED:
        sahf                    ; restore flags
        POP     AX
        retn

;============================================================================
; ROM.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/07/2018 - Retro DOS v3.0

;	TITLE	ROM - Miscellaneous routines
;	NAME	ROM

;**	Misc Low level routines for doing simple FCB computations, Cache
;       reads and writes, I/O optimization, and FAT allocation/deallocation
;
;	SKPCLP
;	FNDCLUS
;	BUFSEC
;	BUFRD
;	BUFWRT
;	NEXTSEC
;	OPTIMIZE
;	FIGREC
;	ALLOCATE
;	RESTFATBYT
;	RELEASE
;	RELBLKS
;	GETEOF
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;               M039: DB 10/25/90 - Disk read/write optimization.

;Break   <FNDCLUS -- Skip over allocation units>
;--------------------------------------------------------------------------
;
; Procedure Name : FNDCLUS
;
; Inputs:
;       CX = No. of clusters to skip
;       ES:BP = Base of drive parameters
;       [THISSFT] point to SFT
; Outputs:
;       BX = Last cluster skipped to
;       CX = No. of clusters remaining (0 unless EOF)
;       DX = Position of last cluster
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;--------------------------------------------------------------------------

FNDCLUS:
	PUSH	ES
        LES     DI,[THISSFT]		; setup addressability to SFT
	;mov	bx,[es:di+1Bh]
	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
	;mov	dx,[es:di+19h]
        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
	OR	BX,BX
	JZ	short NOCLUS

        SUB     CX,DX
        JNB	short FINDIT

        ADD     CX,DX
        XOR     DX,DX
	;mov	bx,[es:di+0Bh]
        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
FINDIT:
        POP	ES
	JCXZ	RET9

	;entry	SKPCLP
SKPCLP:
	call	UNPACK
        jc	short fndclus_retn	; retc
	
	; 09/09/2018

	; MSDOS 6.0
	;xchg	bx,di
	;call	IsEOF
	;pop	bx
	;xchg	bx,di
	;jae	short RET9

	; MSDOS 3.3
	push	bx
	mov	bx,di
	call	IsEOF
	pop	bx	
	jae	short RET9

        XCHG    BX,DI
        INC     DX
	LOOP	SKPCLP			; RMFS
RET9:	
	CLC
        retn
NOCLUS:
        POP	ES
        INC	CX
        DEC	DX
        CLC

fndclus_retn:
        retn

;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
;--------------------------------------------------------------------------
;
; Procedure Name : BUFSEC
;
; Inputs:
;       AH = priority of buffer
;       AL = 0 if buffer must be read, 1 if no pre-read needed
;       ES:BP = Base of drive parameters
;       [CLUSNUM] = Physical cluster number
;       [SECCLUSPOS] = Sector position of transfer within cluster
;       [BYTCNT1] = Size of transfer
; Function:
;       Insure specified sector is in buffer, flushing buffer before
;       read if necessary.
; Outputs:
;       ES:DI = Pointer to buffer
;       SI = Pointer to transfer address
;       CX = Number of bytes
;       [NEXTADD] updated
;       [TRANS] set to indicate a transfer will occur
;       Carry set if error (user FAILed to I 24)
;--------------------------------------------------------------------------

BUFSEC:
        MOV     DX,[CLUSNUM]
        MOV     BL,[SECCLUSPOS]
	;mov	byte [ALLOWED],38h
        MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
        CALL    FIGREC
	call	GETBUFFR
        jc	short fndclus_retn

        MOV     BYTE [TRANS],1	; A transfer is taking place
        MOV     SI,[NEXTADD]
        MOV     DI,SI
        MOV     CX,[BYTCNT1]
        ADD     DI,CX
        MOV     [NEXTADD],DI
        LES     DI,[CURBUF]
	;or	byte [es:di+5],8
        OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
	;lea	di,[di+16]
        LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
        ADD     DI,[BYTSECPOS]
        CLC
        retn

;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>

;---------------------------------------------------------------------------
;
; Procedure Name : BUFRD
;
; Do a partial sector read via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------

BUFRD:
        PUSH	ES
        xor	ax, ax			; pre-read sector
        CALL    BUFSEC
        JNC	short BUF_OK

BUF_IO_FAIL:				; this label used by BUFWRT also
        POP	ES
        JMP     SHORT RBUFPLACED

BUF_OK:
        MOV     BX,ES
        MOV     ES,[DMAADD+2]
        MOV     DS,BX
	XCHG    DI,SI
        SHR     CX,1
;M039
	; MSDOS 3.3
	JNC	short EVENRD
	MOVSB
EVENRD:
	REP     MOVSW

;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
;       DS:SI-> Source within Buffer.
;       ES:DI-> Destination within Transfer memory block.

	; MSDOS 6.0
;	rep	movsw			;Copy Buffer to Transfer memory.
;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
;	rep	movsb                   ;Copy last byte.
;M039

        POP	ES
;hkn; SS override
        LDS     DI,[SS:CURBUF]
	;lea	bx,[di+16]
	LEA     BX,[DI+BUFINSIZ]
        SUB     SI,BX                   ; Position in buffer
        call	PLACEBUF
	;cmp	si,[es:bp+2]
	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
        JB	short RBUFPLACEDC	; No, leave buf where it is

;M039
	; MSDOS 3.3
	call	PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.
        ; MSDOS 6.0
	;MOV	[BufferQueue],DI	; Make it prime candidate for
;M039					; chucking even though it is MRU.

RBUFPLACEDC:
        CLC
RBUFPLACED:
	push	ss
	pop	ds
        retn

;----------------------------------------------------------------------------
;
; Procedure : BUFWRT
;
; Do a partial sector write via one of the system buffers
; ES:BP Points to DPB
; Carry set if error (currently user FAILed to I 24)
;
; DS - set to DOSDATA
;
;----------------------------------------------------------------------------

BUFWRT:
        MOV     AX,[SECPOS]
        ; MSDOS 6.0
	;ADD	AX,1            	; Set for next sector
        ;MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
        ;ADC	[SECPOS+2],0		;F.C. >32mb	;AN000;
        ;MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
        ;CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
        ;MOV	AL,1			;F.C. >32mb	;AN000;
        ;JA	short NOREAD		;F.C. >32mb	;AN000;
        ;JB	short doread		;F.C. >32mb	;AN000;
        ;MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
	; MSDOS 3.3
	INC	AX
	MOV	[SECPOS],AX ; 09/09/2018
	; MSDOS 3.3 (& MSDOS 6.0)
        CMP     AX,[VALSEC]		; Has sector been written before?
        MOV     AL,1
        JA	short NOREAD		; Skip preread if SECPOS>VALSEC
;doread:
        XOR     AL,AL
NOREAD:
        PUSH	ES
        CALL    BUFSEC
	JC	short BUF_IO_FAIL
        MOV     DS,[DMAADD+2]
        SHR     CX,1

;M039
	; MSDOS 3.3
	JNC     short EVENWRT ; 09/09/2018
	MOVSB
EVENWRT:
	REP     MOVSW

;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
;       DS:SI-> Source within Transfer memory block.
;       ES:DI-> Destination within Buffer.

	; MSDOS 6.0
	;rep	movsw			;Copy Transfer memory to Buffer.
	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
	;rep	movsb                   ;Copy last byte.
;M039
        POP	ES

;hkn; SS override
        LDS     BX,[SS:CURBUF]

	; MSDOS 6.0
        ;TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
	;				;LB. if already dirty		  ;AN000;
        ;JNZ	short yesdirty5		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	
	;or	byte [bx+5],40h
        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
;yesdirty5:
	;lea	si,[bx+16]
        LEA     SI,[BX+BUFINSIZ]
        SUB     DI,SI                   ; Position in buffer
;M039
	; MSDOS 3.3
	MOV     SI,DI
	MOV     DI,BX
	call	PLACEBUF
	;cmp	si,[es:bp+2]
	CMP     SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
	JB	short WBUFPLACED	; No, leave buf where it is
	call	PLACEHEAD               ; Make it prime candidate for chucking
                                        ;  even though it is MRU.
	; MSDOS 6.0
	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
        ;JB	short WBUFPLACED	; No, leave buf where it is
        ;MOV	[BufferQueue],BX	; Make it prime candidate for
					; chucking even though it is MRU.
;M039

WBUFPLACED:
        CLC
	push	ss
	pop	ds
        retn

;Break   <NEXTSEC -- Compute next sector to read or write>
;---------------------------------------------------------------------------
;
; Procedure Name : NEXTSEC
;
; Compute the next sector to read or write
; ES:BP Points to DPB
;
;---------------------------------------------------------------------------

NEXTSEC:
	test	byte [TRANS],0FFh ; -1 
        JZ	short CLRET

        MOV     AL,[SECCLUSPOS]
        INC     AL
	;cmp	al,[es:bp+4]
        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
        JBE	short SAVPOS

        MOV     BX,[CLUSNUM]
        call	IsEOF
        JAE	short NONEXT

        call	UNPACK
        JC	short NONEXT
clusgot:
        MOV     [CLUSNUM],DI
        INC     word [LASTPOS]
        MOV     AL,0
SAVPOS:
        MOV     [SECCLUSPOS],AL
CLRET:
        CLC
        retn
NONEXT:
        STC
        retn

;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
;----------------------------------------------------------------------------
;
; Procedure Name : OPTIMIZE
;
; Inputs:
;       BX = Physical cluster
;       CX = No. of records
;       DL = sector within cluster
;       ES:BP = Base of drives parameters
;       [NEXTADD] = transfer address
; Outputs:
;       AX = No. of records remaining
;       BX = Transfer address
;       CX = No. or records to be transferred
;       DX = Physical sector address            (LOW)
;       [HIGH_SECTOR] = Physical sector address (HIGH)
;       DI = Next cluster
;       [CLUSNUM] = Last cluster accessed
;       [NEXTADD] updated
;       Carry set if error (currently user FAILed to I 24)
; ES:BP unchanged. Note that segment of transfer not set.
;
;---------------------------------------------------------------------------

OPTIMIZE:
	PUSH    DX
        PUSH    BX
	;mov	al,[es:bp+4]
        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
        INC     AL              ; Number of sectors per cluster
        MOV     AH,AL
        SUB     AL,DL           ; AL = Number of sectors left in first cluster
        MOV     DX,CX
        MOV     CX,0
OPTCLUS:
; AL has number of sectors available in current cluster
; AH has number of sectors available in next cluster
; BX has current physical cluster
; CX has number of sequential sectors found so far
; DX has number of sectors left to transfer
; ES:BP Points to DPB
; ES:SI has FAT pointer

do_norm3:
        call	UNPACK
        JC	short OP_ERR
clusgot2:
	ADD	CL,AL
        ADC     CH,0
        CMP     CX,DX
        JAE	short BLKDON
        MOV     AL,AH
        INC     BX
        CMP     DI,BX
        JZ	short OPTCLUS
        DEC     BX
FINCLUS:
        MOV     [CLUSNUM],BX    ; Last cluster accessed
        SUB     DX,CX           ; Number of sectors still needed
        PUSH    DX
        MOV     AX,CX
	;mul	word[ES:BP+2]
        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
				; Number of sectors times sector size
        MOV     SI,[NEXTADD]
        ADD     AX,SI           ; Adjust by size of transfer
        MOV     [NEXTADD],AX
        POP     AX              ; Number of sectors still needed
        POP     DX              ; Starting cluster
        SUB     BX,DX           ; Number of new clusters accessed
        ADD     [LASTPOS],BX
        POP     BX              ; BL = sector postion within cluster
	call	FIGREC
        MOV     BX,SI
	CLC
        retn

OP_ERR:
        ADD     SP,4
	STC
        retn

BLKDON:
        SUB     CX,DX           ; Number of sectors in cluster we don't want
        SUB     AH,CL           ; Number of sectors in cluster we accepted
        DEC     AH              ; Adjust to mean position within cluster
        MOV     [SECCLUSPOS],AH
        MOV     CX,DX           ; Anyway, make the total equal to the request
        JMP     SHORT FINCLUS

;Break	<FIGREC -- Figure sector in allocation unit>
;---------------------------------------------------------------------------
;
; Procedure Name : FIGREC
;
; Inputs:
;       DX = Physical cluster number
;       BL = Sector position within cluster
;       ES:BP = Base of drive parameters
; Outputs:
;       DX = physical sector number           (LOW)
;       [HIGH_SECTOR] Physical sector address (HIGH)
; No other registers affected.
;
;---------------------------------------------------------------------------

FIGREC:
        PUSH    CX
	;mov	cl,[es:bp+5]
        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
        DEC     DX
        DEC     DX

;hkn; SS override HIGH_SECTOR
	; MSDOS 6.0
	;MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
	;OR	CL,CL				;F.C. >32mb
	;JZ	short noshift			;F.C. >32mb
	;XOR	CH,CH 				;F.C. >32mb
;rotleft:					;F.C. >32mb
	;CLC					;F.C. >32mb
	;RCL	DX,1				;F.C. >32mb
	;RCL	word [HIGH_SECTOR],1		;F.C. >32mb
	;LOOP	rotleft				;F.C. >32mb
;noshift:

	; MSDOS 3.3
	SHL     DX,CL
	; MSDOS 3.3 (& MSDOS 6.0)
        OR      DL,BL
	;add	dx,[es:bp+0Bh]
        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
	; MSDOS 6.0
        ;ADC	word [HIGH_SECTOR],0		;F.C. >32mb
	; MSDOS 3.3 (& MSDOS 6.0)        
	POP     CX
figrec_retn:
        retn

; 30/07/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS3.3, 1987) - Offset 

;Break   <ALLOCATE -- Assign disk space>
;---------------------------------------------------------------------------
;
; Procedure Name : ALLOCATE - Allocate Disk Space
;
;   ALLOCATE is called to allocate disk clusters. The new clusters are
;   FAT-chained onto the end of the existing file.
;
;   The DPB contains the cluster # of the last free cluster allocated
;   (dpb_next_free). We start at this cluster and scan towards higher
;   numbered clusters, looking for the necessary free blocks.
;
;   Once again, fancy terminology gets in the way of corrct coding. When
;   using next_free, start scanning AT THAT POINT and not the one following it.
;   This fixes the boundary condition bug when only free = next_free = 2.
;
;       If we get to the end of the disk without satisfaction:
;
;           if (dpb_next_free == 2) then we've scanned the whole disk.
;               return (insufficient_disk_space)
;           ELSE
;               dpb_next_free = 2; start scan over from the beginning.
;
;   Note that there is no multitasking interlock. There is no race when
;   examining the entrys in an in-core FAT block since there will be no
;   context switch. When UNPACK context switches while waiting for a FAT read
;   we are done with any in-core FAT blocks, so again there is no race. The
;   only special concern is that V2 and V3 MSDOS left the last allocated
;   cluster as "00"; marking it EOF only when the entire alloc request was
;   satisfied. We can't allow another activation to think this cluster is
;   free, so we give it a special temporary mark to show that it is, indeed,
;   allocated.
;
;   Note that when we run out of space this algorithem will scan from
;   dpb_next_free to the end, then scan from cluster 2 through the end,
;   redundantly scanning the later part of the disk. This only happens when
;   we run out of space, so sue me.
;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;                                                                          ;
;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
;   explanation:
;
;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
;   entry BX = 0. What needs to be done in this case is to stuff the cluster
;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
;   errors. This "stuff" is done by the call to PACK which is right before
;   the
;           LOOP   findfre         ; alloc more if needed
;   instruction when the first cluster is allocated to the nul file. The
;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
;
;   This method is obviously useless (because it is non-reentrant) for
;   multitasking, and will have to be changed. Storing the required value on
;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
;   (instead of actually doing the PACK) is BAD because it doesn't handle
;   problems with INT 24 well.
;
;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;                                                                          ;
;       ENTRY   BX = Last cluster of file (0 if null file)
;               CX = No. of clusters to allocate
;               ES:BP = Base of drive parameters
;               [THISSFT] = Points to SFT
;
;       EXIT    'C' set if insufficient space
;                 [FAILERR] can be tested to see the reason for failure
;                 CX = max. no. of clusters that could be added to file
;               'C' clear if space allocated
;                 BX = First cluster allocated
;                 FAT is fully updated
;                 sf_FIRCLUS field of SFT set if file was null
;
;       USES    ALL but SI, BP

;callmagic  proc near
;       push    ds                             ;push segment of routine 
;       push    Offset MagicPatch              ;push offset for routine
;       retf                                   ;simulate jmp far
;                                              ;far return address is on
;                                              ;stack, so far return from
;                                              ;call will return this routine
;callmagic  endp

ALLOCATE:
	; 10/09/2018
;BEGIN MAGICDRV MODIFICATIONS
;
;7/5/92 scottq
;
;This is the disk compression patch location which allows
;the disk compression software to fail allocations if the
;FAT would allows allocation, but the free space for compressed
;data would not.
;        
;;;	call    far ptr MAGICPATCH
;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
;;; but we do know the segment and offset of the routine
;;; so simulate a far call to dosdata:magicpatch
;;; note dosassume above, so DS -> dosdata

	; MSDOS 6.0
        ;clc				;clear carry so we fall through
	;				;if no patch is present
	;push	cs			;push segment for far return
        ;call	callmagic		;this is a near call
        ;jnc	short Regular_Allocate_Path
	;jmp	Disk_Full_Return

	; MSDOS 6.0
        ;clc				;clear carry so we fall through
	;				;if no patch is present
	;push	cs			;push segment for far return
        ;call	callmagic		;this is a near call
        ;jnc	short Regular_Allocate_Path
	;jmp	Disk_Full_Return ; 10/09/2018 !

;Regular_Allocate_Path:
;END MAGICDRV MODIFICATIONS

        PUSH    BX                      ; save (bx)
        XOR     BX,BX
	call	UNPACK
        MOV     [FATBYT],DI             ; save correct cluster 0 value
        POP     BX
        jc	short figrec_retn	; abort if error   [INTERR?]

        PUSH    CX
        PUSH    BX

        MOV     DX,BX
	;mov	bx,[es:bp+1Ch]
        mov     bx,[ES:BP+DPB.NEXT_FREE]
        cmp     bx,2
        ja	short FINDFRE

;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
;   <2 or >dpb_max_clus. Reset it and restart the scan

ads1:
	;mov	word [es:bp+1Ch],2
        mov     word [ES:BP+DPB.NEXT_FREE],2
        mov     bx,1                    ; Counter next instruction so first
                                        ;       cluster examined is 2

;   Scanning both forwards and backwards for a free cluster
;
;       (BX) = forwards scan pointer
;       (CX) = clusters remaining to be allocated
;       (DX) = current last cluster in file
;       (TOS) = last cluster of file

FINDFRE:
        INC     BX
	;cmp	bx,[es:bp+0Dh]
        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	ja	short ads7	; at end of disk
        call	UNPACK          ; check out this cluster
        jc	short ads4	; FAT error             [INTERR?]
        jnz	short FINDFRE	; not free, keep on truckin

;   Have found a free cluster. Chain it to the file
;
;       (BX) = found free cluster #
;       (DX) = current last cluster in file

	;mov	[es:bp+1Ch],bx
        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
        xchg    ax,dx           ; save (dx) in ax
        mov     dx,1            ; mark this free guy as "1"
	call	PACK            ; set special "temporary" mark
        jc	short ads4	; FAT error             [INTERR?]
	;cmp	word [es:bp+1Eh],-1
        CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
        JZ	short NO_ALLOC	; No
	;dec	word [es:bp+1Eh]
        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
NO_ALLOC:
        xchg    ax,dx           ; (dx) = current last cluster in file
        XCHG    BX,DX
        MOV     AX,DX
	call	PACK            ; link free cluster onto file
                                ;  CAVEAT.. On Nul file, first pass stuffs
                                ;    cluster 0 with FIRCLUS value.
        jc	short ads4	; FAT error [INTERR?]
        xchg    BX,AX           ; (BX) = last one we looked at
        mov     dx,bx           ; (dx) = current end of file
        LOOP    FINDFRE         ; alloc more if needed

;   We've successfully extended the file. Clean up and exit
;
;       (BX) = last cluster in file

        MOV     DX,0FFFFH
	call	PACK            ; mark last cluster EOF

;   Note that FAT errors jump here to clean the stack and exit. This saves us
;   2 whole bytes.  Hope its worth it...
;
;       'C' set iff error
;       calling (BX) and (CX) pushed on stack

ads4:   
	POP     BX
        POP     CX              ; Don't need this stuff since we're successful
        jc	short figrec_retn
        call	UNPACK          ; Get first cluster allocated for return
                                ; CAVEAT... In nul file case, UNPACKs cluster 0.
        jc	short figrec_retn
	call	RESTFATBYT      ; Restore correct cluster 0 value
        jc	short figrec_retn
        XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
        OR      DI,DI           ; clear 'C'
	jnz	short figrec_retn ; we were extending an existing file

;   We were doing the first allocation for a new file. Update the SFT cluster
;   info
dofastk:
        PUSH	ES
        LES     DI,[THISSFT]
	;mov	[es:di+0Bh],bx
        MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
	;mov	[es:di+1Bh],bx
        MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
        POP	ES
        retn

;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
;   of the disk...

ads7:   
	cmp	word [ES:BP+DPB.NEXT_FREE],2
	jnz	short ads1	; start scan from front of disk

;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
;   the space back to the free list and tell the caller how much he could have
;   had.  We have to make sure we remove the "special mark" we put on the last
;   cluster we were able to allocate, so it doesn't become orphaned.
;
;       (CX) = clusters remaining to be allocated
;       (TOS) = last cluster of file (before call to ALLOCATE)
;       (TOS+1) = # of clusters wanted to allocate

        POP     BX              ; (BX) = last cluster of file
        MOV     DX,0FFFFH
	call	RELBLKS         ; give back any clusters just alloced
        POP     AX              ; No. of clusters requested
                                ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed, so proceed with return CX
                                ;   setup.
        SUB     AX,CX           ; AX=No. of clusters allocated
	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
                                ;   Alloc failed.
Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
        ; MSDOS 6.0
	;MOV	byte [DISK_FULL],1 ;MS. indicating disk full
        STC
        retn

;-----------------------------------------------------------------------
;
; Procedure Name : RESTFATBYT
;
; SEE ALLOCATE CAVEAT
;       Carry set if error (currently user FAILed to I 24)
;-----------------------------------------------------------------------

RESTFATBYT:
        PUSH    BX
        PUSH    DX
        PUSH    DI
        XOR     BX,BX
        MOV     DX,[FATBYT]
	call	PACK
        POP     DI
        POP     DX
        POP     BX
RELEASE_flush:
	retn

;Break	<RELEASE -- DEASSIGN DISK SPACE>
;---------------------------------------------------------------------------
;
; Procedure Name : RELEASE
;
; Inputs:
;       BX = Cluster in file
;       ES:BP = Base of drive parameters
; Function:
;       Frees cluster chain starting with [BX]
;       Carry set if error (currently user FAILed to I 24)
; AX,BX,DX,DI all destroyed. Other registers unchanged.
;
;-----------------------------------------------------------------------------

RELEASE:
        XOR     DX,DX

	;entry	RELBLKS
RELBLKS:

;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
;   and free the rest in the chain.

	call	UNPACK
	jc	short RELEASE_flush
	jz	short RELEASE_flush
        MOV     AX,DI
        PUSH    DX
	call	PACK
        POP     DX
	jc	short RELEASE_flush
        OR      DX,DX
        JNZ	short NO_DEALLOC	; Was putting EOF mark
	;cmp	word [es:bp+1Eh],-1
	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
        JZ	short NO_DEALLOC	; No
        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
NO_DEALLOC:
        MOV     BX,AX
        dec     ax              ; check for "1"
	jz	short RELEASE_flush	; is last cluster of incomplete chain
	call	IsEOF
        JB	short RELEASE	; Carry clear if JMP not taken

;RELEASE_flush:
	; MSDOS 6.0
	;mov	al,[es:bp]
	;;MOV	AL,[ES:BP+DPB.DRIVE]
	;push	si		; FLUSHBUF may trash these and we guarantee
	;push	cx		;  them to be preserved.
	;push	es
	;push	bp
	;call	FLUSHBUF	; commit buffers for this drive
	;pop	bp
	;pop	es
	;pop	cx
	;pop	si
RET12:
	retn

;Break	<GETEOF -- Find the end of a file>
;------------------------------------------------------------------------
;
; Procedure Name : GETEOF
;
; Inputs:
;       ES:BP Points to DPB
;       BX = Cluster in a file
;       DS = CS
; Outputs:
;       BX = Last cluster in the file
;       Carry set if error (currently user FAILed to I 24)
; DI destroyed. No other registers affected.
;
;--------------------------------------------------------------------------

GETEOF:
	call	UNPACK
        jc	short RET12
        PUSH    BX
        MOV     BX,DI
	call	IsEOF
        POP     BX
        JAE     short RET12
        MOV     BX,DI
        JMP     short GETEOF

;============================================================================
; FCB.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0

;	TITLE	FCB - FCB parse calls for MSDOS
;	NAME	FCB

;**	FCB.ASM -  Low level routines for parsing names into FCBs and analyzing
;		   filename characters
;
;	MakeFcb
;	NameTrans
;	PATHCHRCMP
;	GetLet
;	UCase
;	GetLet3
;	GetCharType
;	TESTKANJ
;	NORMSCAN
;	DELIM
;
;	Revision history:
;
;		A000  version 4.00  Jan. 1988
;	
;	M048 - access FILE_UCASE_TAB using DS rather than SS.

TableLook	EQU -1

SCANSEPARATOR	EQU	1
DRVBIT		EQU	2
NAMBIT		EQU	4
EXTBIT		EQU	8

;
;----------------------------------------------------------------------------
;
; Procedure : MakeFcb
;
;----------------------------------------------------------------------------
;

MAKEFCB:
;hkn; SS override
	MOV	BYTE [SS:SpaceFlag],0
	XOR	DL,DL		; Flag--not ambiguous file name
	;test	al,2
	test	AL,DRVBIT	; Use current drive field if default?
	JNZ	short DEFDRV
	MOV	BYTE [ES:DI],0	; No - use default drive
DEFDRV:
	INC	DI
	MOV	CX,8
	;test	al,4
	test	AL,NAMBIT	; Use current name fields as default?
	XCHG	AX,BX		; Save bits in BX
	MOV	AL," "
	JZ	short FILLB	; If not, go fill with blanks
	ADD	DI,CX
	XOR	CX,CX		; Don't fill any
FILLB:
	REP	STOSB
	MOV	CL,3
	test	BL,EXTBIT	; Use current extension as default
	JZ	short FILLB2
	ADD	DI,CX
	XOR	CX,CX
FILLB2:
	REP	STOSB
	XCHG	AX,CX		; Put zero in AX
	STOSW
	STOSW			; Initialize two words after to zero
	SUB	DI,16		; Point back at start
	;test	bl,1
	test	BL,SCANSEPARATOR; Scan off separators if not zero
	JZ	short SKPSPC
	CALL	SCANB		; Peel off blanks and tabs
	CALL	DELIM		; Is it a one-time-only delimiter?
	JNZ	short NOSCAN
	INC	SI		; Skip over the delimiter
SKPSPC:
	CALL	SCANB		; Always kill preceding blanks and tabs
NOSCAN:
	CALL	GETLET
	JBE	short NODRV	; Quit if termination character
	CMP	BYTE [SI],":"	; Check for potential drive specifier
	JNZ	short NODRV
	INC	SI		; Skip over colon
	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
	JBE	short BADDRV	; Drive letter out of range

	PUSH	AX
	call	GetVisDrv
	POP	AX
	JNC	short HAVDRV

	; MSDOS 6.0
;hkn; SS override
	;CMP	byte [SS:DrvErr],error_not_DOS_disk
	;				; if not FAT drive ;AN000;
	;JZ	short HAVDRV		; assume ok	   ;AN000;
BADDRV:
	MOV	DL,-1
HAVDRV:
	STOSB			; Put drive specifier in first byte
	INC	SI
	DEC	DI		; Counteract next two instructions
NODRV:
	DEC	SI		; Back up
	INC	DI		; Skip drive byte

	;entry	NORMSCAN
NORMSCAN:
	MOV	CX,8
	CALL	GETWORD 	; Get 8-letter file name
	CMP	BYTE [SI],"."
	JNZ	short NODOT
	INC	SI		; Skip over dot if present

	; MSDOS6.0
;hkn; SS override
	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2	;AN000;
	;JZ	short VOLOK				;AN000;
	;MOVSB			; 2nd byte of DBCS	;AN000;
	;MOV	CX,2					;AN000;
	;JMP	SHORT contvol				;AN000;
;VOLOK:
	MOV	CX,3		; Get 3-letter extension
contvol:
	CALL	MUSTGETWORD
NODOT:
	MOV	AL,DL

	; MSDOS 6.0
	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###

	retn

NONAM:
	ADD	DI,CX
	DEC	SI
	retn

GETWORD:
	CALL	GETLET		
	JBE	short NONAM	; Exit if invalid character
	DEC	SI

;	UGH!!! Horrible bug here that should be fixed at some point:
;	If the name we are scanning is longer than CX, we keep on reading!

MUSTGETWORD:
	CALL	GETLET

;	If spaceFlag is set then we allow spaces in a pathname

;IF NOT TABLELOOK
	JB	short FILLNAM
;ENDIF
	JNZ	short MustCheckCX

;hkn; SS override
	test	BYTE [SS:SpaceFlag],0FFh
	JZ	short FILLNAM
	CMP	AL," "
	JNZ	short FILLNAM

MustCheckCX:
	JCXZ	MUSTGETWORD
	DEC	CX
	CMP	AL,"*"          ; Check for ambiguous file specifier
	JNZ	short NOSTAR
	MOV	AL,"?"
	REP	STOSB
NOSTAR:
	STOSB
	CMP	AL,"?"
	JNZ	short MUSTGETWORD
	OR	DL,1		; Flag ambiguous file name
	JMP	short MUSTGETWORD
FILLNAM:
	MOV	AL," "
	REP	STOSB
	DEC	SI
	retn

SCANB:
	LODSB
	CALL	SPCHK
	JZ	short SCANB
	DEC	SI
scanb_retn:
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : NameTrans
;
; NameTrans is used by FindPath to scan off an element of a path. We must
; allow spaces in pathnames
;
;   Inputs:	DS:SI points to start of path element
;   Outputs:	Name1 has unpacked name, uppercased
;		ES = DOSGroup
;		DS:SI advanced after name
;   Registers modified: DI,AX,DX,CX
;
;----------------------------------------------------------------------------

NameTrans:
;hkn; SS override
	MOV	BYTE [SS:SpaceFlag],1
	push	ss
	pop	es

;hkn; NAME1 is in DOSDATA
	MOV	DI,NAME1
	PUSH	DI
	MOV	AX,'  '
	MOV	CX,5
	STOSB
	REP	STOSW		; Fill "FCB" at NAME1 with spaces
	XOR	AL,AL		; Set stuff for NORMSCAN
	MOV	DL,AL
	STOSB
	POP	DI

	CALL	NORMSCAN

;hkn; SS override for NAME1
	CMP	byte [SS:NAME1],0E5H
	jnz	short scanb_retn
	MOV	byte [SS:NAME1],5 ; Magic name translation
	retn

;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>

;----------------------------------------------------------------------------
;
; Procedure Names : GetLet, UCase, GetLet3
;
; These routines take a character, convert it to upper case, and check
; for delimiters.  Three different entry points:
;	GetLet -  DS:[SI] = character to convert
;	UCase  -  AL = character to convert
;	GetLet3 - AL = character
;		  [BX] = translation table to use
;
;	Exit (in all cases) : AL = upper case character
;			      CY set if char is control char other than TAB
;			      ZF set if char is a delimiter
;	Uses : AX, flags
;
; NOTE: This routine exists in a fast table lookup version, and a slow
; inline version.  Return with carry set is only possible in the inline
; version.  The table lookup version is the one in use.
;
;----------------------------------------------------------------------------


; This entry point has character at [SI]

	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
GETLET:	
	LODSB

; This entry point has character in AL

	;entry	UCase
UCase:	
	; 09/08/2018
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
_UCase:
	PUSH	BX
	MOV	BX,FILE_UCASE_TAB+2

; Convert the character in AL to upper case

gl_0:
	CMP	AL,"a"
	JB	short gl_2	; Already upper case, go check type
	CMP	AL,"z"
	JA	short gl_1
	SUB	AL,20H		; Convert to upper case

; Map European character to upper case

gl_1:
	CMP	AL,80H
	JB	short gl_2	; Not EuroChar, go check type
	SUB	AL,80H		; translate to upper case with this index

	; M048 - Start 
	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
	; preserve it.
	;

	;push	ds
	;push	cs
	;pop	ds

	; 09/08/2018
	;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
	CS	XLAT

	;pop	ds

	; M048 - End

; Now check the type

;If TableLook

gl_2:
	PUSH	AX
	
	; MSDOS 6.0
	;CALL	GetCharType	; returns type flags in AL
	
	; MSDOS 3.3
	mov	bx,CharType
	; 09/08/2018
	;xlat	byte [cs:bx]
	cs	xlat	

	;test	al,1	
	TEST	AL,FCHK 	; test for normal character
	POP	AX
	POP	BX
	RETN

; This entry has character in AL and lookup table in BX

	; MSDOS 6.0
;	;entry GetLet3
GETLET3: ; 10/08/2018
	PUSH	BX
	JMP	short gl_0

;ELSE
;
;gl_2:
;	POP	BX
;	CMP	AL,"."
;	retz
;	CMP	AL,'"'
;	retz
;	CALL	PATHCHRCMP
;	retz
;	CMP	AL,"["
;	retz
;	CMP	AL,"]"
;	retz
;ENDIF

;---------------------------------------------------------------------
;
; DELIM - check if character is a delimiter
;	Entry : AX = character to check
;	Exit  : ZF set if character is not a delimiter
;	Uses  : Flags
;
;--------------------------------------------------------------------

	;entry	DELIM
DELIM:
;IF TableLook
	PUSH	AX

	; MSDOS 6.0
	;CALL	GetCharType
	
	; MSDOS 3.3
	push	bx
	mov	bx,CharType
	;09/08/2018
	;xlat	byte [cs:bx]
	cs	xlat
	pop	bx

	;test	al,2
	TEST	AL,FDELIM
	POP	AX
	RETN
;ELSE
;	CMP	AL,":"
;	retz
;
;	CMP	AL,"<"
;	retz
;	CMP	AL,"|"
;	retz
;	CMP	AL,">"
;	retz
;
;	CMP	AL,"+"
;	retz
;	CMP	AL,"="
;	retz
;	CMP	AL,";"
;	retz
;	CMP	AL,","
;	retz
;ENDIF

;-------------------------------------------------------------------------
;
;  SPCHK - checks to see if a character is a space or equivalent
;	Entry : AL = character to check
;	Exit  : ZF set if character is a space
;	Uses  : flags
;
;-------------------------------------------------------------------------

	;entry SPCHK
SPCHK:
;IF TableLook
	PUSH	AX

	; MSDOS 6.0
	;CALL	GetCharType
	
	; MSDOS 3.3
	push	bx
	mov	bx,CharType
	; 09/08/2018
	;xlat	byte [cs:bx]
	cs	xlat
	pop	bx

	;test	al,4
	TEST	AL,FSPCHK
	POP	AX
	RETN
;ELSE
;	CMP	AL,9		; Filter out tabs too
;	retz
;; WARNING! " " MUST be the last compare
;	CMP	AL," "
;	return
;ENDIF

; MSDOS 6.0
;-------------------------------------------------------------------------
;
;  GetCharType - return flag bits indicating character type
;	Bits are defined in DOSSYM.INC. Uses lookup table
;	defined above at label CharType.
;
;	Entry : AL = character to return type flags for
;	Exit  : AL = type flags
;	Uses  : AL, flags
;
;-------------------------------------------------------------------------
;
;GetCharType:
;	cmp	al,CharType_last	; beyond end of table?
;	jae	short gct_90		; return standard value
;
;	push	bx
;	mov	bx,CharType		; load lookup table
;	shr	al,1			; adjust for half-byte table entry size
;	;xlat	cs:[bx] 		; get flags
;	cs	xlat	
;	pop	bx
;
; carry clear from previous shift means we want the low nibble.  Otherwise
; we have to shift the flags down to the low nibble
;
;	jnc	short gct_80		; carry clear, no shift needed
;
;	shr	al,1			; we want high nibble, shift it down
;	shr	al,1
;	shr	al,1
;	shr	al,1
;
;gct_80:
;	and	al,0Fh			; clear the unused nibble
;	retn
;
;gct_90:
;	mov	al,0Fh			; set all flags
;	retn

;----------------------------------------------------------------------------
;
; Procedure : PATHCHRCMP
;
;----------------------------------------------------------------------------

PATHCHRCMP:
	CMP	AL,'/'
	JBE	short PathRet
	CMP	AL,'\'
	retn
GotFor:
	MOV	AL,'\'
	retn
PathRet:
	JZ	short GotFor
	retn


;============================================================================
; MSCRTLC.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0

; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)

;**	MSCTRLC.ASM - ^C and error handler for MSDOS

;	TITLE	Control C detection, Hard error and EXIT routines
;	NAME	IBMCTRLC

;**	Low level routines for detecting special characters on CON input,
;	the ^C exit/int code, the Hard error INT 24 code, the
;	process termination code, and the INT 0 divide overflow handler.
;
;	FATAL
;	FATAL1
;	reset_environment
;	DSKSTATCHK
;	SPOOLINT
;	STATCHK
;	CNTCHAND
;	DIVOV
;	CHARHARD
;	HardErr
;
;	Revision history:
;
;	    AN000	version 4.0   Jan 1988
;	    A002	PTM    -- dir >lpt3 hangs
;	    A003	PTM 3957- fake version for IBMCAHE.COM
;
; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
;	      flags register. In order to return to user normally DOS used to
;	      move F202 into flags, which sets bit number 1 in flags uncondit-
;	      ionally. Now it is modified to maintain the state of bit 1.
;
; 	M024: suppressed fail and ignore options if not in the middle of int 
;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
;	      charhard.


	; MSDOS 6.0
;		public	LowInt23Addr		
;LowInt23Addr	LABEL	DWORD
;	DW	offset DOSDATA:LowInt23, 0
;
;		public	LowInt24Addr
;LowInt24Addr	LABEL	DWORD
;	DW	offset DOSDATA:LowInt24, 0
;
;		public	LowInt28Addr
;LowInt28Addr	LABEL	DWORD
;	DW	offset DOSDATA:LowInt28, 0

;Break	<Checks for ^C in CON I/O>

;---------------------------------------------------------------------------
;
; Procedure Name : DSKSTATCHK
;
; Check for ^C if only one level in
;
;---------------------------------------------------------------------------

        ;procedure   DSKSTATCHK,NEAR ; Check for ^C if only one level in

DSKSTATCHK:        
	;CMP	BYTE [INDOS],1
        CMP     BYTE [SS:INDOS],1 ; 15/03/2018
	;retnz			; Do NOTHING
	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         

	PUSH    CX
        PUSH    ES
        PUSH    BX
        PUSH    DS
        PUSH    SI
        
	;PUSH	CS
        ;POP	ES
        ;PUSH	CS
        ;POP	DS

	MOV	BX, SS		; SS is DOSDATA. ES:BX must be set up
	MOV	ES, BX		; for deviocall2
	MOV	DS, BX

	; 09/09/2018
        MOV     BYTE [DSKSTCOM],DEVRDND
        MOV     BYTE [DSKSTCALL],DRDNDHL
	mov	word [DSKSTST],0

        MOV     BX,DSKSTCALL
        LDS     SI,[BCON]
        CALL	DEVIOCALL2
 	; 15/03/2018
	;test	word [ss:DSKSTST],200h
        TEST    WORD [SS:DSKSTST],STBUI
	;JNZ	SHORT ZRET		; No characters available
	; 30/07/2018
	jz	short _GotCh
;ZRET:
        XOR     AL,AL                   ; Set zero
RET36:
        POP     SI
        POP     DS
        POP     BX
        POP     ES
        POP     CX
_RET37:
        RETN

_GotCh:
        MOV     AL,[SS:DSKCHRET]	; SS override

        CMP     AL,"C"-"@" ; cmp al,3
        JNZ     SHORT RET36
        MOV     BYTE [SS:DSKSTCOM],DEVRD
        MOV     BYTE [SS:DSKSTCALL],DRDWRHL
        MOV     [SS:DSKCHRET],CL
	; 09/09/2018
	MOV	word [SS:DSKSTST],0
	MOV	word [SS:DSKSTCNT],1
	CALL	DEVIOCALL2              ; Eat the ^C
        POP     SI
        POP     DS
        POP     BX                      ; Clean stack
        POP     ES
        POP     CX
        JMP	CNTCHAND ; 10/08/2018

NOSTOP:
	; MSDOS 6.0
	;CMP	AL,"P"-"@"
	;JNZ	short check_next
				    	; SS override
	;CMP	BYTE [SS:Scan_Flag],0	; ALT_Q ?
	;JZ	short INCHKJ		; no
	;retn
;check_next:
	;;IF	NOT TOGLPRN
	;CMP	AL,"N"-"@"
	;JZ	short INCHKJ
	;;ENDIF

	;CMP	AL,"C"-"@"
	;JZ	short INCHKJ
;check_end:
	;retn

	; MSDOS 3.3
        CMP     AL,"P"-"@"  ; cmp al,16	
        JZ	short INCHKJ

	; 15/04/2018
        ;;IF	NOT TOGLPRN
        ;CMP	AL,"N"-"@"
        ;JZ	SHORT INCHKJ
        ;;ENDIF

        CMP     AL,"C"-"@"  ; cmp al,3	
        JZ	short INCHKJ
	RETN

	; 08/09/2018
INCHKJ:	; 10/08/2018
	JMP	INCHK

;----------------------------------------------------------------------------
;
; Procedure Name : SpoolInt
;
; SpoolInt - signal processes that the DOS is truly idle.  We are allowed to
; do this ONLY if we are working on a 1-12 system call AND if we are not in
; the middle of an INT 24.
;
;----------------------------------------------------------------------------

SPOOLINT:
        PUSHF
	; 15/03/2018
        CMP     BYTE [SS:IDLEINT],0	; SS override
        JZ      SHORT POPFRET
        CMP     BYTE [SS:ERRORMODE],0
        JNZ     SHORT POPFRET		;No spool ints in error mode

	; 30/07/2018

	; Note that we are going to allow an external program to issue system 
	; calls at this time.  We MUST preserve IdleInt across this.


	PUSH	WORD [SS:IDLEINT]
 
	; MSDOS 6.0
	;cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
	;jne	short do_low_int28	; Y: the int must be done from low mem
	;INT	int_spooler		; N: Execute user int 28 handler
	;jmp	short spool_ret_addr

;do_low_int28:
	;call	far [SS:LowInt28Addr]

;spool_ret_addr:

        INT     int_spooler		; INT 28h

	POP	WORD [SS:IDLEINT]

POPFRET:
        POPF
_RET18:  
	RETN

;----------------------------------------------------------------------------
;
; Procedure Name : STATCHK
;
;----------------------------------------------------------------------------

STATCHK:
        CALL	DSKSTATCHK              ; Allows ^C to be detected under
                                        ; input redirection
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_SFT
        POP     BX
        JC      SHORT _RET18
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT SPOOLINT
        CMP     AL,'S'-'@'
        JNZ     SHORT NOSTOP

	; MSDOS 6.0			; SS override
	;CMP	BYTE [SS:Scan_Flag],0	; AN000; ALT_R ?
	;JNZ	short check_end		; AN000; yes

        XOR     AH,AH
        CALL	IOFUNC                  ; Eat Cntrl-S
        JMP     SHORT PAUSOSTRT

PRINTOFF:
PRINTON:
	NOT	BYTE [SS:PFLAG] ; 14/03/2018

	; 30/07/2018 - Retro DOS v3.0
	PUSH	BX
	MOV	BX,4
	call	GET_IO_SFT
	POP	BX
	jc	short _RET18
	PUSH	ES
	PUSH	DI
	PUSH	DS
	POP	ES
	MOV	DI,SI			; ES:DI -> SFT
	;test	word [es:di+5],800h
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
	JZ	short NORM_PR 		; Not redirected, echo is OK

	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
					; See if allowed
	push	ax
	mov	ax, 1126h
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
			; Return: CF set on error, AX = error code
			; STACK unchanged
	pop	ax

	JNC	short NORM_PR 		; Echo is OK

					; SS override
	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo

	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close

	push    ax
	mov     ax, 1124h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
			; ES:DI -> SFT, SS = DOS CS
	pop     ax

	JMP	SHORT RETP6

NORM_PR:
	CMP	BYTE [SS:PFLAG],0	; SS override
	JNZ	short PRNOPN
	call	DEV_CLOSE_SFT
	JMP	SHORT RETP6

PRNOPN:
	call	DEV_OPEN_SFT
RETP6:
	POP	DI
	POP	ES

STATCHK_RETN:
        RETN

PAUSOLP:
        CALL    SPOOLINT
PAUSOSTRT:
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT PAUSOLP
INCHK:
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_SFT
        POP     BX
        JC      SHORT STATCHK_RETN ; 30/07/2018
        XOR     AH,AH
        CALL	IOFUNC
	; 30/07/2018
	; MSDOS 3.3
        CMP     AL,'P'-'@' ;cmp al,16
        JNZ	SHORT NOPRINT

	cmp	byte [SS:SCAN_FLAG],0
	JZ	SHORT PRINTON	
	mov	byte [ss:SCAN_FLAG],0

	; MSDOS 6.0
	;CMP	AL,"P"-"@"
	;;;;;  7/14/86	ALT_Q key fix
	;JZ	short PRINTON		; no! must be CTRL_P

NOPRINT:	
	;IF	NOT TOGLPRN
	;CMP	AL,"N"-"@"
	;JZ	short PRINTOFF
	;ENDIF
	CMP	AL,"C"-"@" ; cmp al,3 
	;retnz
	jnz	short STATCHK_RETN

;	!! NOTE: FALL THROUGH !!

;---------------------------------------------------------------------------
;
; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
;
; "^C" and CR/LF is printed.  Then the user registers are restored and the
; user CTRL-C handler is executed.  At this point the top of the stack has 1)
; the interrupt return address should the user CTRL-C handler wish to allow
; processing to continue; 2) the original interrupt return address to the code
; that performed the function call in the first place.	If the user CTRL-C
; handler wishes to continue, it must leave all registers unchanged and RET
; (not IRET) with carry CLEAR.	If carry is SET then an terminate system call
; is simulated.
;
;---------------------------------------------------------------------------

CNTCHAND:
	; MSDOS 6.0			; SS override
					; AN002; from RAWOUT
	;TEST	word [SS:Dos34_Flag],CTRL_BREAK_FLAG  
	;JNZ	short around_deadlock 	; AN002;

        MOV     AL,3			; Display "^C"
        CALL	BUFOUT
        CALL	CRLF
;around_deadlock:
        PUSH    SS
        POP     DS
        CMP     BYTE [CONSWAP],0
        JZ      SHORT NOSWAP
        CALL	SWAPBACK
NOSWAP:
	CLI				; Prepare to play with stack
	MOV	SS,[USER_SS]		; User stack now restored
	MOV	SP,[USER_SP]
        CALL	restore_world       ; User registers now restored

	; 30/07/2018 - Retro DOS v3.0 
	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
        ; 14/03/2018 - Retro DOS v2.0
	MOV     BYTE [CS:INDOS],0	
        MOV     BYTE [CS:ERRORMODE],0
        MOV     [CS:ConC_Spsave],SP
	clc	;30/07/2018
        INT     int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
	;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
			; Return: return via RETF 2 with CF set
			; DOS will abort program with errorlevel 0
			; else
			; interrupted DOS call continues

	; 30/07/2018 

	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)

; The user has returned to us.	The circumstances we allow are:
;
;   IRET	We retry the operation by redispatching the system call
;   CLC/RETF	POP the stack and retry
;   ... 	Exit the current process with ^C exit
;
; User's may RETURN to us and leave interrupts on. 
; Turn 'em off just to be sure

	CLI

	MOV	[CS:USER_IN_AX],ax	; save the AX
	PUSHF				; and the flags (maybe new call)
	POP	AX

; See if the input stack is identical to the output stack

        CMP	SP,[CS:ConC_Spsave]
	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP

; Repeat the operation by redispatching the system call.

ctrlc_repeat:
        MOV     AX,[CS:USER_IN_AX]
	;transfer COMMAND           ; Repeat command otherwise
COMMANDJ:
	JMP	COMMAND

; The current SP is NOT the same as the input SP. Presume that he 
; RETF'd leaving some flags on the stack and examine the input

ctrlc_try_new:
	ADD	SP,2			; pop those flags
	;test	ax,1
	TEST	AX,f_Carry		; did he return with carry?
	JZ	short ctrlc_repeat	; no carry set, just retry

	; Well...  time to abort the user.  
	; Signal a ^C exit and use the EXIT system call..

ctrlc_abort:
        ;MOV	AX,(EXIT SHL 8) + 0
        MOV	AX, (EXIT*256) + 0  ; 4C00h
	mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
        ;transfer COMMAND	    ; give up by faking $EXIT
	;JMP	SHORT COMMANDJ
	JMP	COMMAND

;Break	<DIVISION OVERFLOW INTERRUPT>
;----------------------------------------------------------------------------
;
; Procedure Name : DIVOV
;
; Default handler for division overflow trap
;
;----------------------------------------------------------------------------

DIVOV: 
	; 30/07/2018
	; 07/07/2018 - Retro DOS v3.0
	mov	si,DIVMES
	mov	bx,[cs:DivMesLen]
	mov     ax,cs
	mov	ss,ax
	mov     sp,AUXSTACK
	call	RealDivOv
	;call	_outmes ; MSDOS 6.0
	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow

; 30/07/2018

; MSDOS 6.0
;---------------------------------------------------------------------------
;
; Procedure Name : OutMes
;
;
; OutMes: perform message output
; Inputs:   SS:SI points to message
;	    BX has message length
; Outputs:  message to BCON
;
;Actually, cs:si points to the message now. The segment address is filled in
;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
;NB. This procedure is called only from DIVOV. -SR
;
;---------------------------------------------------------------------------

;MSDOS 3.3
;---------------------------------------------------------------------------
; RealDivOv: perform actual divide overflow stuff.
; Inputs:   none
; Outputs:  message to BCON
;---------------------------------------------------------------------------

	; 30/07/2018
	; MSDOS 6.0
;_OUTMES:
	;MSDOS 3.3
RealDivOv:
	 
	; 07/07/2018 - Retro DOS v3.0
        ;Context ES
        ;push	ss ; 30/07/2018
	PUSH	CS			; get ES addressability
	POP	ES
        ;Context DS
	;push	ss ; 30/07/2018
	PUSH	CS			; get DS addressability
	POP	DS
        MOV     BYTE [DSKSTCOM],DEVWRT
        MOV     BYTE [DSKSTCALL],DRDWRHL
        MOV     WORD [DSKSTST],0
	; BX = [DivMesLen] = 19
        MOV     [DSKSTCNT],BX
        MOV     BX,DSKSTCALL
        ;MOV     [DSKCHRET+1],SI	; transfer address (need an EQU)
	; 08/09/2018
	mov	[DEVIOBUF_PTR],si
	; MSDOS 6.0
					; CS is used for string, fill in 
					; segment address 
	;MOV	[DskChRet+3],CS

        LDS     SI,[BCON]
        CALL	DEVIOCALL2
	; 14/03/2018
        ;MOV     WORD [CS:DSKCHRET+1],DEVIOBUF
	; 08/09/2018
	mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
        MOV     WORD [CS:DSKSTCNT],1
        RETN

;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
;---------------------------------------------------------------------------
;
; Procedure Name : CHARHARD
;
;
; Character device error handler
; Same function as HARDERR
;
;---------------------------------------------------------------------------

CHARHARD:
	; 30/07/2018
	; 08/07/2018 - Retro DOS v3.0

	; MSDOS 6.0
;		   			; M024 - start
;	cmp	byte ptr [ERRORMODE], 0	; Q: are we in the middle of int 24
;	jne	@f			; Y: allow fail
;
;	OR	AH, Allowed_RETRY	; assume ctrl p
;
;	test	byte ptr [PFLAG], -1	; Q: has ctrl p been pressed
;	jnz	ctrlp			; Y: 
;@@:					; M024 - end

; Character device error handler
; Same function as HARDERR

	;or	ah,38h
	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
;ctrlp:			; SS override for Allowed and EXITHOLD
	mov	[SS:ALLOWED],ah

	; 15/03/2018
        MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BP
        PUSH    SI
	;and	di,0FFh
        AND     DI,STECODE
        MOV     BP,DS                   ;Device pointer is BP:SI
        CALL    FATALC
        POP     SI
	;return
        RETN

;---------------------------------------------------------------------------
;
; Procedure Name : HardErr
;
; Hard disk error handler. Entry conditions:
;	DS:BX = Original disk transfer address
;	DX = Original logical sector number
;	CX = Number of sectors to go (first one gave the error)
;	AX = Hardware error code
;	DI = Original sector transfer count	
;	ES:BP = Base of drive parameters
;	[READOP] = 0 for read, 1 for write
;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
; Output:
;	[FAILERR] will be set if user responded FAIL
;
;--------------------------------------------------------------------------

HARDERR:
	; 30/07/2018
	; 08/07/2018 - Retro DOS v3.0
	XCHG    AX,DI                   ; Error code in DI, count in AX
        ;and	di,0FFh
	AND     DI,STECODE              ; And off status bits
        ;CMP	DI,WRECODE		; Write Protect Error?
	;cmp	di,0
	cmp	DI,error_I24_write_protect ; Write Protect Error?
        JNZ     short NOSETWRPERR
        PUSH    AX
	;MOV	AL,[ES:BP+DPB.DRIVE]
        ;MOV	AL,[ES:BP+0]
	mov	al,[ES:BP]
        	; 15/03/2018
        MOV     [SS:WPERR],AL		; Flag drive with WP error
        POP     AX
NOSETWRPERR:
        SUB     AX,CX                   ; Number of sectors successfully transferred
        ADD     DX,AX                   ; First sector number to retry
        PUSH    DX
	; 08/07/2018
        ;MUL	word [ES:BP+2] 		; Number of bytes transferred
	MUL	word [ES:BP+DPB.SECTOR_SIZE]
        POP     DX
        ADD     BX,AX                   ; First address for retry
        XOR     AH,AH                   ; Flag disk section in error
        ;CMP	DX,[ES:BP+6] 		; In reserved area?
	CMP	DX,[ES:BP+DPB.FIRST_FAT]
        JB      SHORT ERRINT
        INC     AH                      ; Flag for FAT
        ;CMP	DX,[ES:BP+10H] 		; In FAT?
	CMP	DX,[ES:BP+DPB.DIR_SECTOR]   
	JAE	short TESTDIR 		; No
		 ; Err in FAT must force recomp of freespace
	;mov	word[ES:BP+1Eh],-1
	MOV	word [ES:BP+DPB.FREE_CNT],-1
	JMP	SHORT ERRINT
TESTDIR:
        INC     AH
        ;CMP	DX,[ES:BP+0BH]		; In directory?
	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
        JB      SHORT ERRINT
        INC     AH                      ; Must be in data area
ERRINT:
        SHL     AH,1                    ; Make room for read/write bit
        OR      AH,[SS:READOP] ; 15/03/2018

	; 15/08/2018
					; SS override for allowed and EXITHOLD
	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits

        ;entry   FATAL
FATAL:
	;MOV	AL,[ES:BP+DPB.DRIVE]
        ;MOV	AL,[ES:BP+0]		; Get drive number
	MOV	AL,[ES:BP]        

	;entry   FATAL1
FATAL1:  
	; 15/03/2018      
	MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BP	; The only things we preserve	
	;LES	SI,[ES:BP+12H]
	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
        MOV     BP,ES                   ; BP:SI points to the device involved

	; DI has the INT-24-style extended error. We now map the error code 
	; for this into the normalized get extended error set by using the 
	; ErrMap24 table as a translate table. Note that we translate ONLY 
	; the device returned codes and leave all others beyond the look up 
	; table alone.

	; 08/07/2018 - Retro DOS v3.0
FATALC:
	call	SET_I24_EXTENDED_ERROR
	;cmp	di,0Ch
	CMP	DI,error_I24_gen_failure
	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
					;  Only come via GetExtendedError
;**
;
; Entry point used by REDIRector on Network I 24 errors.
;
;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
;
; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
;     EXITHOLD set for restore of ES:BP.
;
	;entry	NET_I24_ENTRY
NET_I24_ENTRY:
GOT_RIGHT_CODE:
	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
        JZ	SHORT NoSetFail
	MOV	AL,3
	JMP	short FailRet
NoSetFail:
        MOV     [SS:CONTSTK],SP		; SS override
        PUSH	SS
        POP	ES
    
	; Wango!!! We may need to free some user state info... In 
	; particular, we may have locked down a JFN for a user and he may 
	; NEVER return to us. Thus,we need to free it here and then 
	; reallocate it when we come back.

	CMP	word [SS:SFN],-1
	JZ	short _NoFree
	push	ds
	push	si
	LDS	SI,[SS:PJFN]
	MOV	BYTE [SI],0FFH
	pop	si
	pop	ds

_NoFree:
	CLI
					; Prepare to play with stack
        INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
        DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
        MOV     SS,[SS:USER_SS]
        MOV     SP,[ES:USER_SP]         ; User stack pointer restored
	;int	24h	
        INT     int_fatal_abort         ; Fatal error interrupt vector, must preserve ES
        MOV     [ES:USER_SP],SP         ; restore our stack
        MOV     [ES:USER_SS],SS
        MOV     BP,ES
        MOV     SS,BP
        MOV     SP,[SS:CONTSTK]
        INC     BYTE [SS:INDOS]		; Back in the DOS
        MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
        STI
FailRet:
        LES     BP,[SS:EXITHOLD]
	
	; 08/07/2018

	; Triage the user's reply.

	CMP	AL,1
	JB	short CheckIgnore	; 0 => ignore
	JZ	short CheckRetry	; 1 => retry
	CMP	AL,3			; 3 => fail
	JNZ	short DoAbort 		; 2, invalid => abort

	; The reply was fail.  See if we are allowed to fail.

				; SS override for ALLOWED, EXTOPEN_ON, 
				; ALLOWED, FAILERR, WPERR, SFN, pJFN
	;test	byte [ss:ALLOWED],8
	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
	jz	short DoAbort	; No, do abort
DoFail:
	MOV	AL,3		; just in case...
				; AN000;EO. I24 error disabled
	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
	;test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
	;jnz	short Cleanup 		; AN000;EO. no
	
	inc	byte [SS:FAILERR]	; Tell everybody

CleanUp:
	MOV	byte [SS:WPERR],-1
	CMP	word [SS:SFN],-1
	;jnz	short CleanUp2
	;retn
	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
;CleanUp2:
	push	ds
	push	si
	push	ax
	MOV	AX,[ss:SFN]
	LDS	SI,[ss:PJFN]
	MOV	[SI],AL
	pop	ax
	pop	si
	pop	ds
Cleanup_retn:
	retn

	; The reply was IGNORE. See if we are allowed to ignore.

CheckIgnore:
	;test	byte [ss:ALLOWED],20h
	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
	jz	short DoFail			 ; No, do fail
	jmp	short CleanUp

	; The reply was RETRY. See if we are allowed to retry.

CheckRetry:
	;test	byte [ss:ALLOWED],10h
	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
	jz	short DoFail			; No, do fail
	JMP	short CleanUp

	; The reply was ABORT.

DoAbort:
	push	ss
	pop	ds

	CMP	byte [CONSWAP],0
	JZ	short NOSWAP2
	call	SWAPBACK
NOSWAP2:
	; See if we are to truly abort. If we are in the process of aborting, 
	; turn this abort into a fail.

	;test	byte [fAborting],0FFh
	;jnz	short DoFail

	cmp	byte [fAborting],0
	JNZ	short DoFail

	; Set return code

	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR
	XOR	AL,AL

	; we are truly aborting the process. Go restore information from 
	; the PDB as necessary.

	jmp	exit_inner

;**
;
; reset_environment checks the DS value against the CurrentPDB. If they are
; different, then an old-style return is performed. If they are the same,
; then we release jfns and restore to parent. We still use the PDB at DS:0 as
; the source of the terminate addresses.
;
; Some subtlety: We are about to issue a bunch of calls that *may* generate
; INT 24s. We *cannot* allow the user to restart the abort process; we may
; end up aborting the wrong process or turn a terminate/stay/resident into a
; normal abort and leave interrupt handlers around. What we do is to set a
; flag that will indicate that if any abort code is seen, we just continue the
; operation. In essence, we dis-allow the abort response.
;
; output:   none.
;
	;entry	reset_environment
	
reset_environment:
	; 30/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS3.3) - Offset 588Ah 

;***	invoke	Reset_Version		; AN007 ;MS. reset version number

	PUSH	DS			; save PDB of process

	; There are no critical sections in force. Although we may enter 
	; here with critical sections locked down, they are no longer 
	; relevant. We may safely free all allocated resources.

	MOV	AH,82h
		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
	;int	2Ah 	
	INT	int_IBM

					; SS override
	MOV	byte [SS:fAborting],-1	; signal abort in progress

					; DOS 4.00 doesn't need it
	;CallInstall NetResetEnvironment, MultNET, 34  
					; Allow REDIR to clear some stuff
					; On process exit.
	mov     ax, 1122h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
			; SS = DOS CS
	;mov	al,22h	
	MOV	AL,int_terminate
	call	_$GET_INTERRUPT_VECTOR	; and who to go to

	POP	CX			; get ThisPDB
	push	es
	push	bx			; save return address

	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
	MOV	DS,BX
	MOV	AX,[PDB.PARENT_PID]	; get parentPDB

	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
	; is not Exit_keep_process
	
	CMP	AX,BX
	JZ	short reset_return	; parentPDB = CurrentPDB
	CMP	BX,CX
	JNZ	short reset_return	; CurrentPDB <> ThisPDB
	PUSH	AX			; save parent

					; SS override
	;cmp	byte [SS:EXIT_TYPE],3
	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
	JZ	short reset_to_parent 	; keeping this process

	; We are truly removing a process. Free all allocation blocks 
	; belonging to this PDB

	;invoke	arena_free_process
	call	arena_free_process

	; Kill off remainder of this process. Close file handles and signal 
	; to relevant network folks that this process is dead. Remember that 
	; CurrentPDB is STILL the current process!

	;invoke	DOS_ABORT
	call	DOS_ABORT

reset_to_parent:
					; SS override
	POP	word [SS:CurrentPDB]	; set up process as parent

reset_return:				; come here for normal return
	;Context DS			; DS is used to refer to DOSDATA  
	push	ss
	pop	ds	

	MOV	AL,-1

	; make sure that everything is clean In this case ignore any errors, 
	; we cannot "FAIL" the abort, the program being aborted is dead.

	;EnterCrit critDisk
	call	EcritDisk
	;invoke	FLUSHBUF
	call	FLUSHBUF
	;LeaveCrit critDisk
	call	LcritDisk

	; Decrement open ref. count if we had done a virtual open earlier.

	call	CHECK_VIRT_OPEN
	CLI
	MOV	BYTE [INDOS],0		; Go to known state
	MOV	BYTE [WPERR],-1		; Forget about WP error
	MOV	byte [fAborting],0	; let aborts occur
	POP	WORD [EXITHOLD]
	POP	WORD [EXITHOLD+2]

	; Snake into multitasking... Get stack from CurrentPDB person

	MOV	DS,[CurrentPDB]
	MOV	SS,[PDB.USER_STACK+2]
	MOV	SP,[PDB.USER_STACK]

	call	restore_world

	; MSDOS 6.0
	;push	ax			; set up ds, but save ds in TEMPSEG 
	;mov	ax, ds			; and not on stack.
	;getdseg <ds>			; ds -> dosdata
	;mov	TempSeg, ax
	;pop	ax
					; set up ds to DOSDATA
	MOV	[CS:USER_SP],AX

	POP	AX			; suck off CS:IP of interrupt...
	POP	AX
	POP	AX

; M011 : BEGIN

	; MSDOS 3.3
;	MOV	AX,0F202h	; STI

	; MSDOS 6.0
	LAHF
	XCHG	AH, AL
	AND	AL, 02
	MOV	AH, 0F2h

; M011 : END

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	AX
 
	PUSH	word [CS:EXITHOLD+2]
	PUSH	word [CS:EXITHOLD]

	MOV	AX,[CS:USER_SP]

	; MSDOS 6.0
	;mov	ds,TempSeg	; restore ds

	IRET			; Long return back to user terminate address

;---------------------------------------------------------------------------
;
; Procedure Name : SET_I24_EXTENDED_ERROR
;
; This routine handles extended error codes.
; Input : DI = error code from device
; Output: All EXTERR fields are set
;
;--------------------------------------------------------------------------

SET_I24_EXTENDED_ERROR:
	PUSH	AX
					; ErrMap24End is in DOSDATA
	MOV	AX,ErrMap24End
	SUB	AX,ErrMap24
					; Change to dosdata to access 
					; ErrMap24 and EXTERR -SR
	; MSDOS 6.0
	;push	ds
	;getdseg <ds>			; ds ->dosdata

	; AX is the index of the first unavailable error. Do not translate 
	; if greater or equal to AX.

	CMP	DI,AX
	MOV	AX,DI
	JAE	short NoTrans

	MOV	AL,[CS:DI+ErrMap24]
	XOR	AH,AH
NoTrans:
	MOV	[CS:EXTERR],AX
	;pop	ds
	;assume	ds:nothing
	POP	AX

	; Now Extended error is set correctly. Translate it to get correct 
	; error locus class and recommended action.

	PUSH	SI
					; ERR_TABLE_24 is in DOSCODE 
	MOV	SI,ERR_TABLE_24
	call	CAL_LK			; Set other extended error fields
	POP	SI
	retn

;============================================================================
; FAT.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/07/2018 - Retro DOS v3.0

;	TITLE	FAT - FAT maintenance routines
;	NAME	FAT

;**	FAT.ASM
;
;	Low level local device routines for performing disk change sequence,
;	setting cluster validity, and manipulating the FAT
;
;	IsEof
;	UNPACK
;	PACK
;	MAPCLUSTER
;	FATREAD_SFT
;	FATREAD_CDS
;	FAT_operation
;
;	Revision history:
;
;	  AN000  version Jan. 1988
;	   A001  PTM	      -- disk changed for look ahead buffers
;
;	M014 - if a request for pack\unpack cluster 0 is made we write\read
;	       from CL0FATENTRY rather than disk.
;

;Break <IsEOF - check the quantity in BX for EOF>
;----------------------------------------------------------------------------
;
; Procedure Name : IsEOF
;
; IsEOF - check the fat value in BX for eof.
;
;   Inputs:	ES:BP point to DPB
;		BX has fat value
;   Outputs:	JAE eof
;   Registers modified: none
;
;---------------------------------------------------------------------------

IsEOF:
	;cmp	word [es:bp+0Dh],0FF6h
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
	JAE	short EOF16			; yes, check for eof there

;J.K. 8/27/86
;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
;of any media that has "F0"(Other) as a MediaByte.
;Hopely, this does not create any side effect for those who may use any value
;other than "FF8-FFF" as an EOF for their own file.

	cmp	bx,0FF0h
	je	short IsEOF_other

	CMP	BX,0FF8h		; do the 12 bit compare
IsEOF_other:
	retn
EOF16:
	CMP	BX,0FFF8h		; 16 bit compare
	retn

;Break	<UNPACK -- UNPACK FAT ENTRIES>
;---------------------------------------------------------------------------
;
; Procedur Name : UNPACK
;
; Inputs:
;	BX = Cluster number (may be full 16-bit quantity)
;	ES:BP = Base of drive parameters
; Outputs:
;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
;	Zero set means DI=0 (free cluster)
;	Carry set means error (currently user FAILed to I 24)
; SI Destroyed, No other registers affected. Fatal error if cluster too big.
;
; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
;
;----------------------------------------------------------------------------

UNPACK:
	; MSDOS 6.0			; M014 - Start
	;or	bx, bx			; Q: are we unpacking cluster 0
	;jnz	short up_cont		; N: proceed with normal unpack
	;mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
	;or	di,di 			; return z if di=0
	;retn				; done
;up_cont:				; M014 - End
	;cmp	bx,[es:bp+0Dh]
	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
	JA	short HURTFAT
	CALL	MAPCLUSTER
	jc	short _DoContext
	MOV	DI,[DI]
	JNZ	short High12		; MZ if high 12 bits, go get 'em
	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
	CMP	SI,4096-10
	JB	short Unpack12		; MZ No, go 'AND' off bits
	OR	DI,DI			; MZ set zero condition code, clears carry
	JMP	SHORT _DoContext 	; MZ go do context

High12:
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
	SHR	DI,1
Unpack12:
	AND	DI,0FFFh		; Clears carry
_DoContext:
	PUSH	SS
	POP	DS
	retn

HURTFAT:
	;mov	word [es:bp+1Eh],0FFFFh
	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
	PUSH	AX
	MOV	AH,Allowed_FAIL+80h ; 88h

;hkn; SS override
	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
;
; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
;
	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
	call	FATAL
	CMP	AL,3
	CLC
	JNZ	short OKU_RET 		; Try to ignore bad FAT
	STC				; User said FAIL
OKU_RET:
	POP	AX
hurtfat_retn:
	retn

;Break	<PACK -- PACK FAT ENTRIES>
;----------------------------------------------------------------------------
;
; Procedure Name : PACK
;
; Inputs:
;	BX = Cluster number
;	DX = Data
;	ES:BP = Pointer to drive DPB
; Outputs:
;	The data is stored in the FAT at the given cluster.
;	SI,DX,DI all destroyed
;	Carry set means error (currently user FAILed to I 24)
;	No other registers affected
;
; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
;
;---------------------------------------------------------------------------

PACK:
	; MSDOS 6.0			; M014 - start
	;or	bx, bx			; Q: are we packing cluster 0
	;jnz	short p_cont		; N: proceed with normal pack
	;mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
	;retn				; done
;p_cont:				; M014 - end
	CALL	MAPCLUSTER
	JC	short _DoContext
	MOV	SI,[DI]
	JZ	short ALIGNED 		; byte (not nibble) aligned
	PUSH	CX			; move data to upper 12 bits
	MOV	CL,4
	SHL	DX,CL
	POP	CX
	AND	SI,0FH			; leave in original low 4 bits
	JMP	SHORT PACKIN
ALIGNED:
	;cmp	word [es:bp+0Dh],0FF6h
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
	JAE	short Pack16		; MZ yes, go clobber original data
	AND	SI,0F000h		; MZ leave in upper 4 bits of original
	AND	DX,0FFFh		; MZ store only 12 bits
	JMP	SHORT PACKIN		; MZ go store
Pack16:
	XOR	SI,SI			; MZ no original data
PACKIN:
	OR	SI,DX
	MOV	[DI],SI

;hkn; SS override
	LDS	SI,[SS:CURBUF]
	; MSDOS 6.0
	;TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
					;LB. if already dirty		  ;AN000;
	;JNZ	short yesdirty6		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
	
	;or	byte [si+5],40h
	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
;yesdirty6:				;LB.				  ;AN000;
;hkn; SS override
	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
;hkn; SS is DOSDATA
	push	ss
	pop	ds
	jz	short hurtfat_retn	; Carry clear
	PUSH	AX
	PUSH	BX
	PUSH	CX
	MOV	AX,[CLUSSAVE]
	MOV	DS,[CURBUF+2]
	ADD	SI,BUFINSIZ  ; add si,16
	MOV	[SI],AH
;hkn; SS is DOSDATA
	;Context DS
	push	ss
	pop	ds	
	PUSH	AX
	; MSDOS 6.0
	;MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
	;MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;

	MOV	DX,[CLUSSEC]
	MOV	SI,1
	XOR	AL,AL
	call	GETBUFFRB
	POP	AX
	JC	short POPP_RET
	LDS	DI,[CURBUF]
	; MSDOS 6.0
	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
	;				;LB. if already dirty		  ;AN000;
	;JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
	
	;or	byte [di+5],40h
	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
yesdirty7:
	ADD	DI,BUFINSIZ ; add di,16
	DEC	DI
	;add	di,[es:bp+2]
	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
	MOV	[DI],AL
	CLC
POPP_RET:
	PUSH	SS
	POP	DS
	POP	CX
	POP	BX
	POP	AX
	retn

; 31/07/2018 - Retro DOS v3.0

;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
;---------------------------------------------------------------------------
;
; Procedure Name : MAPCLUSTER
;
; Inputs:
;	ES:BP Points to DPB
;	BX Is cluster number
; Function:
;	Get a pointer to the cluster
; Outputs:
;	DS:DI Points to contents of FAT for given cluster
;	DS:SI Points to start of buffer
;	Zero Not set if cluster data is in high 12 bits of word
;	Zero set if cluster data is in low 12 or 16 bits
;	Carry set if failed.
; SI is destroyed.
;
;---------------------------------------------------------------------------

MAPCLUSTER:
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
	MOV	BYTE [CLUSSPLIT],0
	;SAVE	<AX,BX,CX,DX>
	push	ax
	push	bx
	push	cx
	push	dx
	MOV	AX,BX			; AX = BX
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
	JAE	short Map16		; MZ yes, do 16 bit algorithm
	SHR	AX,1			; AX = BX/2
Map16:	
	; MSDOS 6.0			; MZ skip prev => AX=2*BX
	;XOR	DI,DI			; >32mb fat ;AN000;
	
	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
	;ADC	DI,DI			; >32mb fat ;DI is zero before op;AN000;
	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]

;IF FastDiv
;
; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
; case and apply a really fast algorithm to get the desired results
;
; Divide method takes 157+4*4=173 (MOV and DIV)
; Fast method takes 39+20*4=119
;
; This saves a bunch.
;
	CMP	CX,512			; 4	Is this 512 byte sector?
	jne	short _DoDiv		; 4     for no jump
	MOV	DX,AX			; 2	get set for remainder
	AND	DX,512-1		; 4	Form remainder
	MOV	AL,AH			; 2     Quotient in formation in AL
	; MDOS 6.0
	;shr	di,1			; 2
	;rcr	al,1			; 2
	; MDOS 3.3
	shr	al,1	
	; MDOS 3.3 (& MSDOS 6.0)
	xor	ah,ah			; 3
	jmp	short DivDone		; 16
_DoDiv:
;ENDIF
	; MSDOS 6.0
	;mov	dx,di			; 2
	; MSDOS 3.3
	xor	dx,dx
	; MSDOS 3.3 (& MSDOS 6.0)	
	DIV	CX			; 155 AX is FAT sector # DX is sector index
;IF FastDiv
DivDone:
;ENDIF
	ADD	AX,[ES:BP+DPB.FIRST_FAT]
	DEC	CX			; CX is sector size - 1
	;SAVE	<AX,DX,CX>
	push	ax
	push	dx
	push	cx
	MOV	DX,AX
	; MSDOS 6.0
	;MOV	word [HIGH_SECTOR],0 	;F.C. >32mb  low sector #
	XOR	AL,AL
	MOV	SI,1
	;invoke	GETBUFFRB
	call	GETBUFFRB
	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
	pop	cx
	pop	ax
	pop	dx
	JC	short MAP_POP
	LDS	SI,[CURBUF]
	LEA	DI,[SI+BUFINSIZ]  ; [si+16]
	ADD	DI,AX
	CMP	AX,CX
	JNZ	short MAPRET
	MOV	AL,[DI]
	;Context DS		 	;hkn; SS is DOSDATA
	push	ss
	pop	ds	
	INC	BYTE [CLUSSPLIT]
	MOV	[CLUSSAVE],AL
	MOV	[CLUSSEC],DX
	; MSDOS 6.0
	;MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb		;AN000;
	INC	DX
	;MOV	word [HIGH_SECTOR],0	;F.C. >32mb FAT sector <32mb ;AN000;
	XOR	AL,AL
	MOV	SI,1
	;invoke	GETBUFFRB
	call	GETBUFFRB
	JC	short MAP_POP
	LDS	SI,[CURBUF]
	LEA	DI,[SI+BUFINSIZ]
	MOV	AL,[DI]
	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	[CLUSSAVE+1],AL

;hkn; CLUSSAVE is in DOSDATA
	MOV	DI,CLUSSAVE
MAPRET:
	;RESTORE <DX,CX,BX>
	pop	dx
	pop	cx
	pop	bx
	XOR	AX,AX			; MZ allow shift to clear carry
	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
	JAE	short MapSet		; MZ no, set flags
	MOV	AX,BX
MapSet:
	TEST	AL,1			; set zero flag if not on boundary
	;RESTORE <AX>
	pop	ax
	retn

MAP_POP:
	;RESTORE <DX,CX,BX,AX>
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn

;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_SFT
;
; Inputs:
;	ES:DI points to an SFT for the drive of intrest (local only,
;		giving a NET SFT will produce system crashing results).
;	DS DOSDATA
; Function:
;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
;	if disk changed.
;	In other respects, same as FATREAD_CDS.
;	(note ES:DI destroyed!)
; Outputs:
;	Carry set if error (currently user FAILed to I 24)
; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
;	as far as invalidating curdir_ID is concerned.
;	Since getting a true disk changed on this call is a screw up
;	anyway, that's the way it goes.
;
;---------------------------------------------------------------------------

FATREAD_SFT:
	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
	mov	AL,[ES:BP]
	MOV	[THISDRV],AL
	call	GOTDPB			;Set THISDPB
	CALL	FAT_GOT_DPB
fatread_sft_retn:
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : FATREAD_CDS
;
; Inputs:
;	DS:DOSDATA
;	ES:DI points to an CDS for the drive of intrest (local only,
;		giving a NET or NUL CDS will produce system crashing results).
; Function:
;	If disk may have been changed, media is determined and buffers are
;	flagged invalid. If not, no action is taken.
; Outputs:
;	ES:BP = Drive parameter block
;	THISDPB = ES:BP
;	THISDRV set
;	Carry set if error (currently user FAILed to I 24)
; DS preserved , all other registers destroyed
;
;---------------------------------------------------------------------------

FATREAD_CDS:
	PUSH	ES
	PUSH	DI
	;les	bp,[es:di+45h]
	LES	BP,[ES:DI+curdir.devptr]
	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
	mov	AL,[ES:BP]
	MOV	[THISDRV],AL
	call	GOTDPB			;Set THISDPB
	CALL	FAT_GOT_DPB
	POP	DI			;Get back CDS pointer
	POP	ES
	jc	short fatread_sft_retn
	JNZ	short NO_CHANGE		;Media NOT changed

;	Media changed. We now need to find all CDS structures which use this
;	DPB and invalidate their ID pointers.

MED_CHANGE:
	XOR	AX,AX
	DEC	AX			; AX = -1
	PUSH	DS
	MOV	CL,[CDSCOUNT]
	XOR	CH,CH			; CX is number of structures
	;lds	si,[es:di+45h]
	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr

;hkn; SS override

;	Find all CDSs with this DevPtr
;
;	(ax) = -1
;	(ds:si) = DevPtr

	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
frcd20: 
	;test	word [es:di+43h],8000h
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JNZ	short frcd25		; Leave NET guys alone!!

	; MSDOS 3.3
	;push	es
	;push	di
	;les	di,[es:di+45h]
	;;les	di,[ES:DI+curdir.devptr]
	;call	POINTCOMP
	;pop	di
	;pop	es
	;jnz	short frcd25

	; MSDOS 6.0
	cmp	si,[ES:DI+curdir.devptr]
	jne	short frcd25		; no match
	mov	bx,ds
	cmp	bx,[ES:DI+curdir.devptr+2]
	jne	short frcd25		; CDS not for this drive

	; MSDOS 3.3 (& MSDOS 6.0)
	;test	[es:di+49h],ax
	test	[ES:DI+curdir.ID],AX
	JZ	short frcd25		; If root (0), leave root
	;mov	[es:di+49h],ax
	MOV	[ES:DI+curdir.ID],AX	; else invalid
frcd25:	
	;add	di,81
	ADD	DI,curdir.size		; Point to next CDS
	LOOP	frcd20
	POP	DS
NO_CHANGE:
	LES	BP,[THISDPB]
	CLC
	retn

;Break	<Fat_Operation - miscellaneous fat stuff>
;----------------------------------------------------------------------------
;
; Procedure Name : FAT_operation
;
;----------------------------------------------------------------------------
FAT_operation:
	; 31/07/2018 - Retro DOS v3.0
FATERR:
	;mov	word [es:bp+1Eh],-1
	MOV	word [ES:BP+DPB.FREE_CNT],-1 
					; Err in FAT must force recomp of freespace
	;and	di,0FFh
	AND	DI,STECODE		; Put error code in DI
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	;mov	ah,1Ah
	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
	MOV	AL,[THISDRV]		; Tell which drive
	call	FATAL1
	LES	BP,[THISDPB]
	CMP	AL,3
	JNZ	short FAT_GOT_DPB	; User said retry
	STC				; User said FAIL
	retn

FAT_GOT_DPB:
	;Context DS			;hkn; SS is DOSDATA
	push	ss			
	pop	ds
	;mov	al,0Fh
	MOV	AL,DMEDHL
	;mov	al,[es:bp+1]
	MOV	AH,[ES:BP+DPB.UNIT] 
	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
	MOV	word [DEVCALL_REQSTAT],0
	;mov	al,[es:bp+16h]
	MOV	AL,[ES:BP+DPB.MEDIA]
	MOV	[CALLMED],AL
	PUSH	ES
	PUSH	DS

;hkn; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	;lds	si,[es:bp+12h]
	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
	POP	ES			; ES:BX Points to call header
	call	DEVIOCALL2
	;Context DS		 	;hkn; SS is DOSDATA
	push	ss
	pop	ds
	POP	ES			; Restore ES:BP
	MOV	DI,[DEVCALL_REQSTAT]
	;test	di,8000h
	;jnz	short FATERR
	or	di,di
	js	short FATERR		; have error
	XOR	AH,AH
	;xchg	ah,[es:bp+17h]
	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
	MOV	AL,[THISDRV]		; Use physical unit number
; See if we had changed volume id by creating one on the diskette
	cmp	[VOLCHNG_FLAG],AL
	jnz	short CHECK_BYT
	mov	byte [VOLCHNG_FLAG],-1
	jmp	GOGETBPB		; Need to get device driver to read in
					; new volume label.
CHECK_BYT:
	OR	AH,[CALLRBYT]
	;JNS	short CHECK_ZR		; ns = 0 or 1
	;JMP	short NEWDSK
	js	short NEWDSK

CHECK_ZR:
	JZ	short CHKBUFFDIRT	; jump if I don't know
	CLC
	retn				; If Media not changed (NZ)

DISK_CHNG_ERR:
	PUSH	ES
	PUSH	BP
	;les	bp,[es:bp+12h]
	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
	;test	word [es:bp+4],800h
	TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
	POP	BP
	POP	ES
	JZ	short FAIL_OPJ2		; Nope, FAIL
	PUSH	DS			; Save buffer pointer for ignore
	PUSH	DI
	push	ss			;hkn; SS is DOSDATA
	pop	ds
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	PUSH	ES
	LES	DI,[CALLVIDM]		; Get volume ID pointer
	MOV	[EXTERRPT+2],ES
	POP	ES
	MOV	[EXTERRPT],DI
	;mov	ax,0Fh
	MOV	AX,error_I24_wrong_disk
	MOV	byte [READOP],1		; Write
	;invoke	HARDERR
	call	HARDERR
	POP	DI			; Get back buffer for ignore
	POP	DS
	CMP	AL,3
FAIL_OPJ2:
	JZ	short FAIL_OP
	JMP	FAT_GOT_DPB		; Retry

CHKBUFFDIRT:
	; MSDOS 6.0
	;cmp	word [DirtyBufferCount],0	; any dirty buffers ? ;hkn;
	;je	short NEWDSK			; no, skip the check
	;call	GetCurHead			; get pointer to first buffer

	; MSDOS 3.3
	lds	di,[BUFFHEAD]
nbuffer:
	;cmp	al,[di+4]
	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
	jne	short lfnxt			; no, go for next buffer
	;test   byte [di+5],40h
	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty	; is the buffer dirty ?
	jz	short lfnxt			; no, go for next buffer
	;Context DS
	push	ss
	pop	ds
	clc
	retn

FAIL_OP:					; This label & code is here
	;Context DS				;  for reachability
	push	ss
	pop	ds
	STC
	retn

lfnxt:
	; 15/08/2018
	;mov	di,[di]
	;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
	;
	lds	di,[di]
	;
	; MSDOS 6.0
	;cmp	[FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
	;jne	short nbuffer			; no, check this guy also
	; MSDOS 3.3
	cmp	di,-1
	jne	short nbuffer

; If no dirty buffers, assume Media changed
NEWDSK:
	;mov	word [es:bp+1Eh],0FFFFh
	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
	; MSDOS 6.0				;  recompute
	;call	GetCurHead
	; MSDOS 3.3
	call	SETVISIT
nxbuffer:
	; MSDOS 3.3
	or 	byte [di+5],20h
	; MSDOS 3.3 (& MSDOS 6.0)
	;cmp	[di+4],al
	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
	jne	short lfnxt2
	;test	byte [di+5],40h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
	jnz	short DISK_CHNG_ERR
	;mov	word [di+4],20FFh
	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
	call	SCANPLACE
	; MSDOS 6.0
	;jmp	short skpbuff
;lfnxt2:
	;;mov	di,[di+BUFFINFO.buf_next]
	;mov	di,[di]
;skpbuff:
	;cmp	di,[FIRST_BUFF_ADDR]					;hkn;
	;jne	short nxbuffer

	;CMP	word [SC_CACHE_COUNT],0	;LB.  look ahead buffers ?	;AN001;
	;JZ	short GOGETBPB		;LB.  no			;AN001;
	;CMP	AL,[CURSC_DRIVE]	;LB.  same as changed drive	;AN001;
	;JNZ	short GOGETBPB		;LB.  no			;AN001;
	;MOV	byte [CURSC_DRIVE],-1	;LB.  invalidate look ahead buffers ;AN000;
lfnxt2:
	; MSDOS 3.3
	call	SKIPVISIT
	jnz	short nxbuffer
GOGETBPB:
	;lds	di,[es:bp+12h]
	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
	;test	word [di+4],2000h
	TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
	JNZ	short GETFREEBUF
	;context DS	    		;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	BX,2
	CALL	UNPACK			; Read the first FAT sector into CURBUF
FAIL_OPJ:
	JC	short FAIL_OP
	LDS	DI,[CURBUF]
	JMP	SHORT GOTGETBUF

GETFREEBUF:
	PUSH	ES			; Get a free buffer for BIOS to use
	PUSH	BP
	; MSDOS 3.3
	LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
	; MSDOS 6.0
	;XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
;hkn; SS override
	;MOV	[SS:HIGH_SECTOR],DX	;LB.  buffer addr	  ;AN000;
	;call	GETCURHEAD		;LB.			  ;AN000;
	; MSDOS 3.3 (& MSDOS 6.0)
	call	BUFWRITE
	POP	BP
	POP	ES
	;JC	short FAIL_OPJ
	jc	short FAIL_OP
GOTGETBUF:
	;add	di,16
	ADD	DI,BUFINSIZ

;hkn; SS override
	MOV	[SS:CALLXAD+2],DS
	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	MOV	[CALLXAD],DI
	;mov	al,16h
	MOV	AL,DBPBHL
	;mov	ah,[es:bp+1]
	MOV	AH,[ES:BP+DPB.UNIT]
	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
	MOV	word [DEVCALL_REQSTAT],0
	;mov	al,[es:bp+16h]
	MOV	AL,[ES:BP+DPB.MEDIA]
	MOV	[CALLMED],AL
	PUSH	ES
	PUSH	DS
	;push	word [es:bp+14h]
	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
	;push	word [es:bp+12h]
	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]

;hkn; DEVCALL is in DOSDATA
	MOV	BX,DEVCALL
	POP	SI
	POP	DS			; DS:SI Points to device header
	POP	ES			; ES:BX Points to call header
	;invoke	DEVIOCALL2
	call	DEVIOCALL2
	POP	ES			; Restore ES:BP
	;Context DS
	push	ss		 	;hkn; SS is DOSDATA
	pop	ds
	MOV	DI,[DEVCALL_REQSTAT]
	; MSDOS 3.3
	;test	di,8000h
	;jnz	short FATERRJ
	; MSDOS 6.0
	or	di,di
	js	short FATERRJ 		; have error
	;;mov	al,[es:bp+16h]
	MOV	AL,[ES:BP+DPB.MEDIA]
	LDS	SI,[CALLBPB]
	;mov	word [es:bp+1Ch],0
	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
	;invoke	$SETDPB
	call	_$SETDPB

;hkn; SS override
	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
	;mov	al,[es:bp+8]
	MOV	AL,[ES:BP+DPB.FAT_COUNT]

	; MSDOS 6.0
	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL ;>32mb		  ;AN000;
	;MOV	AX,[ES:BP+DPB.FAT_SIZE]		;>32mb			  ;AC000;
	;MOV	[DI.buf_wrtcntinc-BUFINSIZ],AX ;>32mb Correct buffer info ;AC000;

	; MSDOS 3.3
	;mov	ah,[es:bp+0Fh]
	MOV	AH,[ES:BP+DPB.FAT_SIZE]
	;mov	[DI-8],ax
	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX

	;Context DS			;hkn; SS is DOSDATA
	push	ss
	pop	ds
	XOR	AL,AL			;Media changed (Z), Carry clear
	retn

FATERRJ: 
	JMP	FATERR


;============================================================================
; STDBUF.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

;
; Standard buffer management for MSDOS
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;.cref
;.list

;TITLE	STDBUF - MSDOS buffer management
;NAME	STDBUF

;INCLUDE BUF.ASM

;============================================================================
; BUF.ASM
;============================================================================
; 31/07/2018 - Retro DOS v3.0
; Retro DOS v2.0 - 12/03/2018

;
; buffer management for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS

SETVISIT:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
; Inputs:
;       None
; Function:
;       Set up a scan of I/O buffers
; Outputs:
;       All visit flags = 0
;               NOTE: This pre-scan is needed because a hard disk error
;                     may cause a scan to stop in the middle leaving some
;                     visit flags set, and some not set.
;       DS:DI Points to [BUFFHEAD]
; No other registers altered

        LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
	PUSH    AX
        ;;XOR	AX,AX	  ;; MSDOS 2.11
	;mov	al,0DFh
	mov	al,~buf_visit
SETLOOP:
        ;;MOV	[DI+7],AL ;; MSDOS 2.11
	;and	[DI+5],al
	AND	[DI+BUFFINFO.buf_flags],AL
        LDS     DI,[DI]
        CMP     DI,-1
        JNZ     SHORT SETLOOP
        POP     AX ; 09/09/2018
	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
SVISIT_RETN:
        RETN

SKIPVISIT:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h

; Inputs:
;       DS:DI Points to a buffer
; Function:
;       Skip visited buffers
; Outputs:
;       DS:DI Points to next unvisited buffer
;       Zero is set if skip to LAST buffer
; No other registers altered

        CMP     DI,-1
        ;retz
        JZ	SHORT SVISIT_RETN

	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
        ;;;retnz
        ;;JNZ	SHORT SVISIT_RETN

	;test	byte [di+5],20h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
	JNZ	short SKIPLOOP
	
	push	ax
	or	al,1
	pop	ax
	retn	

SKIPLOOP:
	LDS     DI,[DI]
        JMP     SHORT SKIPVISIT

;============================================================================
; BUF.ASM, MSDOS 6.0, 1991
;============================================================================
; 31/07/2018 - Retro DOS v3.0

;	TITLE	BUF - MSDOS buffer management
;	NAME	BUF

;**	BUF.ASM - Low level routines for buffer cache management
;
;	GETCURHEAD
;	ScanPlace
;	PLACEBUF
;	PLACEHEAD
;	PointComp
;	GETBUFFR
;	GETBUFFRB
;	FlushBuf
;	BufWrite
;	SET_RQ_SC_PARMS
;
;	Revision history:
;
;		AN000  version 4.00  Jan. 1988
;		A004   PTM 3765 -- Disk reset failed
;		M039 DB 10/17/90 - Disk write optimization
;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA

;Break	<GETCURHEAD -- Get current buffer header>
;----------------------------------------------------------------------------
; Procedure Name : GetCurHead
; Inputs:
;	 No Inputs
; Function:
;	Returns the pointer to the first buffer in Queue
;	and updates FIRST_BUFF_ADDR
;       and invalidates LASTBUFFER (recency pointer)
; Outputs:
;	DS:DI = pointer to the first buffer in Queue
;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
;       LASTBUFFER = -1
; No other registers altered
;----------------------------------------------------------------------------

;procedure   GETCURHEAD,NEAR
;
;	lds	di, BufferQueue		; Pointer to the first buffer;smr;SS Override
;	mov	word ptr [LastBuffer],-1; invalidate last buffer;smr;SS Override
;	mov	[FIRST_BUFF_ADDR],di	;save first buffer addr;smr;SS Override
;	ret
;
;EndProc GETCURHEAD

;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
;----------------------------------------------------------------------------
; Procedure Name : ScanPlace
; Inputs:
;	Same as PLACEBUF
; Function:
;	Save scan location and call PLACEBUF
; Outputs:
;	DS:DI Points to saved scan location
; All registers, except DS:DI, preserved.
;----------------------------------------------------------------------------
;M039: Rewritten to preserve registers.

SCANPLACE:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
	push	es
	les	si,[di]
	;les	si,[DI+BUFFINFO.buf_link]
	call	PLACEBUF
	push	es
	pop	ds
	mov	di,si
	pop	es
scanplace_retn:
	retn	
	
	; MSDOS 6.0
;ScanPlace:
	;push	[di].buf_next		;Save scan location
	;call	PLACEBUF
	;pop	di
	;retn

;----------------------------------------------------------------------------
; Procedure Name : PlaceBuf
; Input:
;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
; Function:
;	Remove buffer from queue and re-insert it in proper place.
; NO registers altered
;----------------------------------------------------------------------------

;procedure   PLACEBUF,NEAR

;PLACEBUF:
	; 31/07/2018 - Retro DOS v3.0

	; MSDOS 6.0
	;push	AX			;Save only regs we modify	;AN000;
	;push	BX							;AN000;
	;push	SI							;AN000;
	;mov	ax, [di].BUF_NEXT
	;mov	bx, word ptr[BufferQueue]	; bx = offset of head of list;smr;SS Override
	;
	;cmp	ax,bx				;Buf = last?		;AN000;
	;je	nret				;Yes, special case	;AN000;
	;cmp	di,bx				;Buf = first?		;AN000;
	;jne	not_first 			;Yes, special case	;AN000;
	;mov	word ptr [BufferQueue],ax	;smr;SS Override
	;jmp	short nret 			;Continue with repositioning;AN000;
;not_first:
	;mov	SI,[DI].BUF_PREV		;No, SI = prior Buf	;AN000;
	;mov	[SI].BUF_NEXT,AX		; ax has di->buf_next	;AN000;
	;xchg	si, ax
	;mov	[SI].BUF_PREV,AX		;			;AN000;
	;
	;mov	SI,[BX].BUF_PREV		;SI-> last buffer	;AN000;
	;mov	[SI].BUF_NEXT,DI		;Add Buf to end of list ;AN000;
	;mov	[BX].BUF_PREV,DI					;AN000;
	;mov	[DI].BUF_PREV,SI		;Update link in Buf too	;AN000;
	;mov	[DI].BUF_NEXT,BX					;AN000;
;nret:									;AN000;
	;pop	SI							;AN000;
	;pop	BX							;AN000;
	;pop	AX							;AN000;
	;								;AN000;
	;cmp	[di.buf_ID],-1			; Buffer FREE?		;AN000;
        ;jne	pbx                             ; M039: -no, jump.
	;mov	WORD PTR [BufferQueue],di	; M039: -yes, make it LRU.
;pbx:	
;	ret								;AN000;

	; 31/07/2018 - Retro DOS v3.0

	; MSDOS 3.3
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh

PLACEBUF:
	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
	
        CALL	save_world
        LES     CX,[DI]
        CMP     CX,-1           	; Buf is LAST?
        JZ      SHORT NRET		; Buffer already last
        MOV     BP,ES           	; Pointsave = Buf.nextbuf
        PUSH    DS
        POP     ES              	; Buf is ES:DI
	; 15/03/2018
        LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
        CALL    POINTCOMP       	; Buf == HEAD?
        JNZ     SHORT BUFLOOP
        MOV     [SS:BUFFHEAD],CX
        MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
        JMP     SHORT LOOKEND

BUFLOOP:
	; 31/07/2018
	mov	ax,ds
	mov	bx,si
	;lds	si,[SI+BUFFINFO.buf_link]
        LDS     SI,[SI]
        CALL    POINTCOMP
        jnz	short BUFLOOP
	;
	mov	ds,ax
	mov	si,bx
	mov	[SI],cx
	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
	mov	[SI+2],bp
	;mov	[BX+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
LOOKEND:
	mov	ax,ds
	mov	bx,si
        LDS     SI,[SI]
        CMP     SI,-1
        jnz     short LOOKEND

GOTHEEND:
        mov	ds,ax
	mov	[BX],di
        MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
        MOV     WORD [ES:DI],-1
	;mov	word [ES:DI+BUFFINFO.buf_link],-1
        MOV     WORD [ES:DI+2],-1 	; Buf is LAST
	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
NRET:
        CALL	restore_world
	
	;cmp	byte [di+4],-1
	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
	jnz     short scanplace_retn
	call    PLACEHEAD
	retn

;EndProc PLACEBUF

;M039 - Removed PLACEHEAD.
;----------------------------------------------------------------------------
; places buffer at head
;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
;	ONE IN THE LIST!!!!!!!
; BUGBUG ---- this routine can be removed because it has only
; BUGBUG ---- one instruction. This routine is called from
; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
; BUGBUG ---- But kept as it is for modularity
;----------------------------------------------------------------------------
;procedure   PLACEHEAD,NEAR
;	mov	word ptr [BufferQueue], di
;	ret
;EndProc PLACEHEAD
;M039

;----------------------------------------------------------------------------
; Procedure Name : PLACEHEAD
;
; SAME AS PLACEBUF except places buffer at head
;----------------------------------------------------------------------------

	; MSDOS 3.3 (Retro DOS v3.0)
	; 05/09/2018
	; MSDOS 2.11 (Retro DOS v2.0)
PLACEHEAD:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah

        CALL	save_world
        PUSH	DS
        POP	ES
	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
        LDS     SI,[SS:BUFFHEAD]
	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
	CALL    POINTCOMP
        JZ      SHORT GOTHEEND2
	MOV	[ES:DI],SI
	;mov	[ES:DI+BUFFINFO.buf_link],si
        MOV	[ES:DI+2],DS
	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
        MOV	[SS:BUFFHEAD],DI
        MOV	[SS:BUFFHEAD+2],ES
LOOKEND2:
        mov	ax,ds
	mov	bx,si
	;lds	si,[SI+BUFFINFO.buf_link]
        LDS     SI,[SI]
        CALL    POINTCOMP
        JNZ	SHORT LOOKEND2 ; 05/09/2018
        mov	ds,ax
	mov	word [bx],-1
	;mov	word [BX+BUFFINFO.buf_link],-1
	mov	word [bx+2],-1
	;mov	word [BX+BUFFINFO.buf_link+2],-1
GOTHEEND2:
       	call	restore_world
placehead_retn:
	retn

;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
;----------------------------------------------------------------------------
;
; Procedure Name : PointComp
; Inputs:
;         DS:SI & ES:DI
; Function:
;          Checks for ((SI==DI) && (ES==DS))
;	   Assumes that pointers are normalized for the
;	   same segment
;
; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
; DO NOT USE FOR < or >
; No Registers altered
;
;----------------------------------------------------------------------------

POINTCOMP:
	; 31/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
	CMP	SI,DI
	;jnz	short _ret_label	; return if nz
	jnz	short placehead_retn 
	PUSH	CX
	PUSH	DX
	MOV	CX,DS
	MOV	DX,ES
	CMP	CX,DX
	POP	DX
	POP	CX
;_ret_label:
	retn


; 01/08/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 

;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>

;**	GetBuffr - Get a non-FAT Sector into a Buffer
;----------------------------------------------------------------------------
;	GetBuffr does normal ( non-FAT ) sector buffering
;	It gets the specified local sector into one of the I/O buffers
;	and shuffles the queue
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	      (LOW)
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CURBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags
;----------------------------------------------------------------------------

;**	GetBuffrb - Get a FAT Sector into a Buffer
;----------------------------------------------------------------------------
;	GetBuffr reads a sector from the FAT file system's FAT table.
;	It gets the specified sector into one of the I/O buffers
;	and shuffles the queue. We need a special entry point so that
;	we can read the alternate FAT sector if the first read fails, also
;	so we can mark the buffer as a FAT sector.
; 
;	ENTRY	(AL) = 0 means sector must be pre-read
;		       ELSE no pre-read
;		(DX) = Desired physical sector number	      (LOW)
;		(SI) != 0
;		HIGH_SECTOR = Desired physical sector number (HIGH)
;		(ES:BP) = Pointer to drive parameters
;		ALLOWED set in case of INT 24
;	EXIT	'C' set if error (user FAIL response to INT24)
;		'C' clear if OK
;		CUR ddBUF Points to the Buffer for the sector
;		    the buffer type bits OF buf_flags = 0, caller must set it
;	USES	AX, BX, CX, SI, DI, Flags
;----------------------------------------------------------------------------

GETBUFFR:
	XOR	SI,SI

;	This entry point is called for FAT buffering with SI != 0

GETBUFFRB:
	MOV	[PREREAD],AX			; save pre-read flag
	mov	al,[ES:BP]
	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
	LDS	DI,[LastBuffer]			; Get the recency pointer
	; MSDOS 6.0
;hkn; SS override
	;MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb		;AN000;

;	See if this is the buffer that was most recently returned.
;	A big performance win if it is.

	CMP	DI,-1				; Recency pointer valid?
	je	short getb5			; No
	;cmp	dx,[di+6]
	CMP	DX,[DI+BUFFINFO.buf_sector]
	JNZ	short getb5			; Wrong sector
	
	; MSDOS 6.0
	;CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb		;AN000;
	;JNZ	short getb5			; F.C. >32mb		;AN000;
	
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	JZ	getb35				; Just asked for same buffer

;	It's not the buffer most recently returned.  See if it's in the
;	cache.
;
;	(cx:dx) = sector #
;	(al) = drive #
;	(si) = 0 iff non fat sector, != 0 if FAT sector read
;	??? list may be incomplete ???

getb5:	
	; MSDOS 6.0
	;CALL	GETCURHEAD			; get Q Head
	; MSDOS 3.3
	lds	di,[SS:BUFFHEAD]
getb10:	
	;cmp	dx,[di+6]
	CMP	DX,[DI+BUFFINFO.buf_sector]
	jne	short getb12			; wrong sector lo
	
	; MSDOS 6.0
	;CMP	CX,[DI+BUFFINFO.buf_sector+2]
	;jne	short getb12			; wrong sector hi
	
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	je	short getb25 ; 05/09/2018	; Found the requested sector
getb12:	
	; MSDOS 6.0
	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
	;cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
	;jne	short getb10			; no, continue looking

	; MSDOS 3.3
	;mov	di,[DI]
	;mov	di,[DI+BUFFINFO.buf_link]
	;
	; 15/08/2018
	lds	di,[di]
	;
	cmp	di,-1 ; 0FFFFh
	jne	short getb10
	lds	di,[SS:BUFFHEAD]		

;	The requested sector is not available in the buffers. DS:DI now points
;	to the first buffer in the Queue. Flush the first buffer & read in the
;	new sector into it.
;
;	BUGBUG - what goes on here? Isn't the first guy the most recently
;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
;	him, we should take LRU. And the above lookup shouldn't be
;	down a chain, but should be hashed.
;
;	(DS:DI) = first buffer in the queue
;	(CX:DX) = sector # we want
;	(si) = 0 iff non fat sector, != 0 if FAT sector read

;hkn; SS override
	;PUSH	cx
	push	si
	push	dx
	push	bp
	push	es
	CALL	BUFWRITE			; Write out the dirty buffer
	pop	es
	pop	bp
	pop	dx
	pop	si
	;POP	word [SS:HIGH_SECTOR]
	jc	short getbx			; if got hard error

	; MSDOS 6.0
	;CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache

;	We're ready to read in the buffer, if need be. If the caller
;	wanted to just *write* the buffer then we'll skip reading it in.

	XOR	AH,AH				; initial flags
;hkn; SS override
	;test	byte [ss:PREREAD],0FFh
	;jnz	short getb20
	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
	JNZ	short getb20			; no, we're done
	LEA	BX,[DI+BUFINSIZ] ; [DI+16]	; (ds:bx) = data address
	MOV	CX,1
	push	si
	push	di
	push	dx
	; MSDOS 6.0
	;push	es
; Note:  As far as I can tell, all disk reads into buffers go through
;	 this point.  -mrw 10/88
	;cmp	BuffInHMA, 0		; is buffers in HMA?
	;jz	@f
	;push	ds
	;push	bx
	;lds	bx, dword ptr LoMemBuff	; Then let's read it into scratch buff
;@@:
;M039: Eliminated redundant HMA code.

	; MSDOS 3.3 (& MSDOS 6.0)
	OR	SI,SI			; FAT sector ?
	JZ	short getb15		

	call	FATSECRD
	;mov	ah,2
	MOV	AH,buf_isFAT		; Set buf_flags

	JMP	SHORT getb17		; Buffer is marked free if read barfs

getb15:
	call	DREAD			; Buffer is marked free if read barfs
	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
getb17:	
	; MSDOS 6.0							  ;I001
	;pushf								  ;I001
	;cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
	;jz	short not_in_hma	; no				  ;I001
	;mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
	;shr	cx,1							  ;I001
	;popf				; Retreive possible CY from DREAD ;I001
	;mov	si,bx							  ;I001
	;pop	di							  ;I001
	;pop	es							  ;I001
	;cld								  ;I001
	;pushf				; Preserve possible CY from DREAD ;I001
	;rep	movsw			; move the contents of scratch buf;I001
	;push	es							  ;I001
	;pop	ds							  ;I001
;not_in_hma:								  ;I001
	;popf							 	  ;I001
	;pop	es
	;
	pop	dx
	pop	di
	pop	si
	JC	short getbx

;	The buffer has the data setup in it (if we were to read)
;	Setup the various buffer fields
;
;	(ds:di) = buffer address
;	(es:bp) = DPB address
;	(HIGH_SECTOR:DX) = sector #
;	(ah) = BUF_FLAGS value
;	(si) = 0 if non fat sector, != 0 if FAT sector read

;hkn; SS override
getb20:	; MSDOS 6.0
	;MOV	CX,[SS:HIGH_SECTOR]
	;MOV	WORD [DI+BUFFINFO.buf_sector+2],CX
	; MSDOS 3.3 (& MSDOS 6.0)	
 	;mov	[di+6],dx
	MOV	[DI+BUFFINFO.buf_sector],DX
	;mov	[di+0Ah],bp
	MOV	[DI+BUFFINFO.buf_DPB],BP
	;mov	[di+0Ch], es
	MOV	[DI+BUFFINFO.buf_DPB+2],ES
	mov	al,[es:bp]
	;mov	al,[es:bp+0]
	;MOV	AL,[ES:BP+DPB.DRIVE]
	;mov	[di+4],ax
	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
getb25:	
	; MSDOS 6.0
	;MOV	[DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
	;XOR	AX,AX

	; MSDOS 3.3
	mov     ax,1

	OR	SI,SI				; FAT sector ?
	JZ	short getb30

	;mov	al,[es:bp+8]
	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
	; MSDOS 6.0
	;MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
	;MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
						;  sectors
	; MSDOS 3.3
	;mov	ah,[es:bp+0Fh]
	MOV	AH,[ES:BP+DPB.FAT_SIZE]

;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
;		is set

getb30:	
	; MSDOS 6.0
	;MOV	[DI+BUFFINFO.buf_wrtcntinc],AX

	; MSDOS 3.3
	;mov	[di+8],ax ; 15/08/2018	
	MOV	[DI+BUFFINFO.buf_wrtcnt],AX

	CALL	PLACEBUF

;hkn; SS override for next 4
getb35: 
	MOV	[SS:CURBUF+2],DS
	MOV	[SS:LastBuffer+2],DS
	MOV	[SS:CURBUF],DI
	MOV	[SS:LastBuffer],DI
	CLC

;	Return with 'C' set appropriately
;
;	(dx) = caller's original value

getbx:	
	push	ss
	pop	ds
	retn



;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
;----------------------------------------------------------------------------
; Input:
;	DS = DOSGROUP
;	AL = Physical unit number local buffers only
;	   = -1 for all units and all remote buffers
; Function:
;	Write out all dirty buffers for unit, and flag them as clean
;	Carry set if error (user FAILed to I 24)
;	    Flush operation completed.
; DS Preserved, all others destroyed (ES too)
;----------------------------------------------------------------------------

FLUSHBUF:
	; MSDOS 6.0
	;call	GetCurHead
	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
	;jnz	short scan_buf_queue
	;cmp	word [DirtyBufferCount], 0			;hkn;
	;je	short end_scan
	
	; MSDOS 3.3
	;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
	lds	di,[BUFFHEAD]
scan_buf_queue:
	call	CHECKFLUSH
	;push	ax  ; MSDOS 3.3
	; MSDOS 6.0
	mov	ah,[DI+BUFFINFO.buf_ID]
	cmp	[SS:WPERR],ah					;hkn;
	;je	short free_the_buf
	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
	;jz	short dont_free_the_buf
	; MSDOS 3.3
	;mov	al,[di+4]
	;mov	al,[DI+BUFFINFO.buf_ID]
	;cmp	[SS:WPERR],al					;hkn;
	; 15/08/2018
	jne	short dont_free_the_buf	
free_the_buf:
	; MSDOS 6.0 (& MSDOS 3.3)
	mov	word [DI+BUFFINFO.buf_ID],00FFh
dont_free_the_buf:
	;pop	ax  ; MSDOS 3.3 	   	
	
	; MSDOS 6.0
	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
	;cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
	;jne	short scan_buf_queue

	; MSDOS 3.3
	;mov	di,[DI]
	;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
	;
	; 15/08/2018
	lds	di,[di]
	;
	cmp	di,-1 ; 0FFFFh
	jnz	short scan_buf_queue 

end_scan:
	push	ss
	pop	ds
	; 01/08/2018 - Retro DOS v3.0
	;cmp	byte [FAILERR],0
	;jne	short bad_flush
	;retn
;bad_flush:
	;stc
	;retn
	; 01/08/2018 - Retro DOS v3.0
	cmp	byte [FAILERR],1
	cmc
flushbuf_retn:
	retn

;----------------------------------------------------------------------------
;
; Procedure Name : CHECKFLUSH
;
; Inputs : AL - Drive number, -1 means do not check for drive
;	   DS:DI - pointer to buffer
;
; Function : Write out a buffer if it is dirty
;
; Carry set if problem (currently user FAILed to I 24)
;
;----------------------------------------------------------------------------

CHECKFLUSH:
	; MSDOS 6.0
	mov	ah, -1 ; 01/08/2018 Retro DOS v3.0
	;cmp	[di+4],ah
	CMP	[DI+BUFFINFO.buf_ID],AH
	jz	short flushbuf_retn	; Skip free buffer, carry clear
	CMP	AH,AL			; 
	JZ	short DOBUFFER		; do this buffer
	;cmp	al,[di+4]
	CMP	AL,[DI+BUFFINFO.buf_ID]
	CLC
	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
DOBUFFER:
	;test	byte [di+5],40h
	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
	PUSH	AX
	;push	word [di+4]
	PUSH	WORD [DI+BUFFINFO.buf_ID]
	CALL	BUFWRITE
	POP	AX
	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
	;and	ah,0BFh
	AND	AH,~buf_dirty		; Buffer is clean, clears carry
	;mov	[di+4],ax
	MOV	[DI+BUFFINFO.buf_ID],AX
LEAVE_BUF:
	POP	AX			; Search info
checkflush_retn:
	retn

;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
;----------------------------------------------------------------------------
;
;	BufWrite writes a buffer to the disk, iff it's dirty.
;
;	ENTRY	DS:DI Points to the buffer
;
;	EXIT	Buffer marked free
;		Carry set if error (currently user FAILed to I 24)
;
;	USES	All buf DS:DI
;		HIGH_SECTOR
;----------------------------------------------------------------------------

BUFWRITE:
	; 10/09/2018
	; 01/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
	MOV	AX,00FFH
	;xchg	ax,[di+4]
	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
	CMP	AL,0FFH
	jz      short checkflush_retn	; Buffer is free, carry clear.
	;test	ah,40h
	test	AH,buf_dirty
	jz      short checkflush_retn	; Buffer is clean, carry clear.
	; MSDOS 6.0
	;call	DEC_DIRTY_COUNT 	; LB. decrement dirty count

;hkn; SS override
	CMP	AL,[SS:WPERR]
	jz      short checkflush_retn	; If in WP error zap buffer

;hkn; SS override
	; MSDOS 6.0
	;MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
	
	;les	bp,[di+10]
	LES	BP,[DI+BUFFINFO.buf_DPB]
	;lea	bx,[di+16]
	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
	;mov	dx,[di+6]
	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
	; MSDOS 6.0
	;MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;

;hkn; SS override
	;MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
	;MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
	; MSDOS 3.3
	; mov	cx,[DI+8]
	mov	cx,[DI+BUFFINFO.buf_wrtcnt]
	MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
	XOR	CH,CH
	;mov	ah,ch ; MSDOS 3.3

;hkn; SS override for ALLOWED
	;mov	byte [SS:ALLOWED],18h
	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
	;test	byte [di+5],8
	;test	ah,8
	test	AH,buf_isDATA
	JZ	short NO_IGNORE
	;or	byte [SS:ALLOWED],20h
	OR	byte [SS:ALLOWED],Allowed_IGNORE
NO_IGNORE:
	xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
	; MSDOS 6.0
	;MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;

	PUSH	DI		; Save buffer pointer
	XOR	DI,DI		; Indicate failure

	;push	ds
	;push	bx
WRTAGAIN:
	push	di
	push	cx
	push	ax
	MOV	CX,1
	push	bx
	push	dx
	push	ds

; Note:  As far as I can tell, all disk reads into buffers go through this point.  -mrw 10/88

	; MSDOS 6.0
	;cmp	byte [BuffInHMA], 0
	;jz	short NBUFFINHMA
	;push	cx
	;push	es
	;mov	si,bx
	;mov	cx,[es:bp+DPB.SECTOR_SIZE]
	;shr	cx,1
	;les	di,[LoMemBuff]
	;mov	bx,di
	;cld
	;rep	movsw
	;push	es
	;pop	ds
	;pop	es
	;pop	cx
;NBUFFINHMA:
	call	DWRITE		; Write out the dirty buffer
	pop	ds
	pop	dx
	pop	bx
	pop	ax
	pop	cx
	pop	di
	JC	short NOSET
	INC	DI		; If at least ONE write succeedes, the operation
NOSET:				;	succeedes.
	ADD	DX,AX
	LOOP	WRTAGAIN
	;pop	bx
	;pop	ds
	OR	DI,DI		; Clears carry
	JNZ	short BWROK	; At least one write worked
	STC			; DI never got INCed, all writes failed.
BWROK:	
	POP	DI
	retn

;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
;----------------------------------------------------------------------------
;	Set_RQ_SC_Parms sets the sector size and drive number value
;	for the secondary cache. This updates SC_SECTOR_SIZE &
;	SC_DRIVE even if SC is disabled to save the testing
;	code and time
;
;	ENTRY	ES:BP = drive parameter block
;
;	EXIT	[SC_SECTOR_SIZE]= drive sector size
;		[SC_DRIVE]= drive #
;
;	USES	Flags
;----------------------------------------------------------------------------

;procedure   SET_RQ_SC_PARMS,NEAR
;
;;hkn; SS override for all variables used in this procedure.
;
;	SAVE	<ax>
;
;	MOV	ax,ES:[BP].DPB_SECTOR_SIZE	; save sector size
;	MOV	SC_SECTOR_SIZE,ax
;
;	MOV	al,ES:[BP].DPB_DRIVE		; save drive #
;	MOV	SC_DRIVE,al
;
;	RESTORE <ax>
;
;srspx:	return
;
;EndProc SET_RQ_SC_PARMS 			;LB. return

;Break	<INC_DIRTY_COUNT-increment dirty count>
;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	increment dirty buffers count
; Output:
;	dirty buffers count is incremented
;
; All registers preserved
;----------------------------------------------------------------------------

;procedure   INC_DIRTY_COUNT,NEAR
;
;; BUGBUG  ---- remove this routine
;; BUGBUG ---- only one instruction is needed   (speed win, space loose)
;	inc	[DirtyBufferCount]			;hkn;
;	ret
;EndProc INC_DIRTY_COUNT

;Break	<DEC_DIRTY_COUNT-decrement dirty count>
;----------------------------------------------------------------------------
; Input:
;	none
; Function:
;	decrement dirty buffers count
; Output:
;	dirty buffers count is decremented
;
; All registers preserved
;----------------------------------------------------------------------------

;procedure   DEC_DIRTY_COUNT,NEAR
;	cmp	[DirtyBufferCount], 0	;hkn;
;	jz	ddcx			; BUGBUG - shouldn't it be an
;	dec	[DirtyBufferCount]	; error condition to underflow here? ;hkn;
;ddcx:	ret
;
;EndProc DEC_DIRTY_COUNT

;============================================================================
; MSPROC.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/08/2018 - Retro DOS v3.0

; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)

; Pseudo EXEC system call for DOS

;	TITLE	MSPROC - process maintenance
;	NAME	MSPROC

; =========================================================================
;**	Process related system calls and low level routines for DOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$WAIT
;	$EXEC
;	$Keep_process
;	Stay_resident
;	$EXIT
;	$ABORT
;	abort_inner
;
;	Modification history:
;
;		Created: ARR 30 March 1983
;		AN000	version 4.0 jan. 1988
;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
;		A008	PTM 4070 - fake version for MS WINDOWS
;
;		M000	added support for loading programs into UMBs 7/9/90
;
;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
;		       dossym.inc. 7/30/90
;		M005 - Support for EXE programs with out STACK segment and 
;		       with resident size < 64K - 256 bytes. A 256 byte 
;		       stack is provided at the end of the program. Note that
;		       only SP is changed.
;		M020 - Fix for Rational bug for details see exepatch.asm
;
;		M028 - 4b04 implementation
;
;		M029 - Support for EXEs without stack rewritten. If EXE is
;			in memory block >= 64K, sp = 0. If memory block
;			obtained is <64K, point sp at the end of the memory
;			block. For EXEs smaller than 64K, 256 bytes are still
;			added for a stack segment which may be needed if it
;			is loaded in low memory situations.
;
;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
;
;		M040 - Bug #3052. The environment sizing code would flag a
;			a bad environment if it reached 32767 bytes. Changed
;			to allow 32768 bytes of environment.
;
;		M047 - Release the allocated UMB when we failed to load a 
;		       COM file high. Also ensure that if the biggest block
;		       into which we load the com file is less than 64K then
;		       we provide atleast 256 bytes of stack to the user.
;
;		M050 - Made Lie table search CASE insensitive
;
;		M060 - Removed special version table from the kernal and
;                      put it in a device drive which puts the address
;                      in the DOS DATA area location UU_IFS_DOS_CALL
;		       as a DWORD.
;
;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
;		       entry do not try to load low if there is no space in
;		       UMBs.
;
;		M068 - Support for copy protect apps. Call ChkCopyProt to 
;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
;		       change return address to LeaveDos if AL=5.
;
;               20-Jul-1992 bens    Added ifdef RESTRICTED_BUILD code that
;                      controls building a version of MSDOS.SYS that only
;                      runs programs from a fixed list (defined in the
;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
;                      for details.  This feature is used to build a
;                      "special" version of DOS that can be handed out to
;                      OEM/ISV customers as part of a "service" disk.
;
; =========================================================================

;SAVEXIT 	EQU	10

;BREAK	<$WAIT - return previous process error code>
; =========================================================================
;	$WAIT - Return previous process error code.
;
;	Assembler usage:
;
;	    MOV     AH, WaitProcess
;	    INT     int_command
;
;	ENTRY	none
;	EXIT	(ax) = exit code
;	USES	all
; =========================================================================

_$WAIT:
	; 02/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h

	xor	AX,AX
	xchg	AX,[ss:exit_code]
	jmp	SYS_RET_OK

; =========================================================================
;BREAK <$exec - load/go a program>
;	EXEC.ASM - EXEC System Call
;
;
; Assembler usage:
;	    lds     DX, Name
;	    les     BX, Blk
;	    mov     AH, Exec
;	    mov     AL, FUNC
;	    int     INT_COMMAND
;
;	AL  Function
;	--  --------
;	 0  Load and execute the program.
;	 1  Load, create  the  program	header	but  do  not
;	    begin execution.
;	 3  Load overlay. No header created.
;
;	    AL = 0 -> load/execute program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;
;	    AL = 1 -> load program
;
;	    +---------------------------+
;	    | WORD segment address of	|
;	    | environment.		|
;	    +---------------------------+
;	    | DWORD pointer to ASCIZ	|
;	    | command line at 80h	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 5Ch	|
;	    +---------------------------+
;	    | DWORD pointer to default	|
;	    | FCB to be passed at 6Ch	|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | CS:IP			|
;	    +---------------------------+
;	    | DWORD returned value of	|
;	    | SS:IP			|
;	    +---------------------------+
;
;	    AL = 3 -> load overlay
;
;	    +---------------------------+
;	    | WORD segment address where|
;	    | file will be loaded.	|
;	    +---------------------------+
;	    | WORD relocation factor to |
;	    | be applied to the image.	|
;	    +---------------------------+
;
; Returns:
;	    AX = error_invalid_function
;	       = error_bad_format
;	       = error_bad_environment
;	       = error_not_enough_memory
;	       = error_file_not_found
; =========================================================================
;
;   Revision history:
;
;	 A000	version 4.00  Jan. 1988
;
; =========================================================================

Exec_Internal_Buffer		EQU	OPENBUF
Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)

; =========================================================================

;IF1		; warning message on buffers
;%out	Please make sure that the following are contiguous and of the
;%out	following sizes:
;%out
;%out	OpenBuf     128
;%out	RenBuf	    128
;%out	SearchBuf    53
;%out	DummyCDS    curdirLen
;ENDIF

; =========================================================================

; =========================================================================
;
; =========================================================================

_$EXEC:
	; 02/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h

EXEC001S:

	;LocalVar    Exec_Blk		,DWORD
	;LocalVar    Exec_Func		,BYTE
	;LocalVar    Exec_Load_High	,BYTE
	;LocalVar    Exec_FH		,WORD
	;LocalVar    Exec_Rel_Fac	,WORD
	;LocalVar    Exec_Res_Len_Para	,WORD
	;LocalVar    Exec_Environ	,WORD
	;LocalVar    Exec_Size		,WORD
	;LocalVar    Exec_Load_Block	,WORD
	;LocalVar    Exec_DMA		,WORD
	;LocalVar    ExecNameLen 	,WORD
	;LocalVar    ExecName		,DWORD
	;
	;LocalVar    Exec_DMA_Save	,WORD
	;LocalVar    Exec_NoStack	,BYTE

	; MSDOS 3.3 (& MSDOS 6.0)
	;%define	Exec_Blk	dword [bp-4]
	%define		Exec_Blk	[bp-4] ; 09/08/2018
	%define		Exec_BlkL	word [bp-4]	
	%define		Exec_BlkH	word [bp-2]
	%define		Exec_Func	byte [bp-5]
	%define		Exec_Load_High	byte [bp-6]
	%define		Exec_FH		word [bp-8]
	%define		Exec_Rel_Fac	word [bp-10]
	%define		Exec_Res_Len_Para word [bp-12]
	%define		Exec_Environ	word [bp-14]
	%define		Exec_Size	word [bp-16]
	%define		Exec_Load_Block	word [bp-18]
	%define		Exec_DMA	word [bp-20]
	%define		ExecNameLen	word [bp-22]
	;%define	ExecName	dword [bp-26]
	%define		ExecName	[bp-26] ; 09/08/2018
	%define		ExecNameL	word [bp-26]	
	%define		ExecNameH	word [bp-24]
	; MSDOS 6.0
	%define		Exec_DMA_Save	word [bp-28]
	%define		Exec_NoStack	byte [bp-29]
	
	; ==================================================================
	; validate function
	; ==================================================================
		      	
	;
	; M068 - Start
	;
	; Reset the A20OFF_COUNT to 0. This is done as there is a 
	; possibility that the count may not be decremented all the way to
	; 0. A typical case is if the program for which we intended to keep 
	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
	; calls), exits pre-maturely due to error conditions.
	;

	; MSDOS 6.0
	;mov	byte [SS:A20OFF_COUNT], 0

	;
	; If al=5 (ExecReady) we'll change the return address on the stack	
	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
	;
	
	;cmp	al, 5			; Q: is this ExecReady call
	;jne	@f			; N: continue
					; Y: change ret addr. to LeaveDos.
	;pop	cx			; Note CX is not input to ExecReady
	;mov	cx, offset DOSCODE:LeaveDos
	;push	cx
;@@:
	;
	; M068 - End
	;

	;Enter

	push	bp
	mov	bp,sp
	sub	sp,30 ; MSDOS 6.0
	;sub	sp,26 ; MSDOS 3.3

	; MSDOS 6.0
	;cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
					; M030
	;jna	short Exec_Check_2

	; MSDOS 3.3
	cmp	AL,3
	jna	short Exec_Check_2

Exec_Bad_Fun:
	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk 
					; Extended Error Locus	;smr;SS Override
	;mov	al,1
	mov	al,error_invalid_function

Exec_Ret_Err:
	;Leave
	mov	sp,bp
	pop	bp
	;transfer SYS_RET_ERR
	jmp	SYS_RET_ERR

	; MSDOS 6.0
;ExecReadyJ:
	;call	ExecReady		; M028
	;jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028

Exec_Check_2:
	cmp	AL,2			
	jz	short Exec_Bad_Fun

	; MSDOS 6.0
	;cmp	al,4			; 2 & 4 are not allowed
	;je	short Exec_Bad_Fun
	;
	;cmp	al,5			; M028 ; M030
	;je	short ExecReadyJ		; M028

	;mov	[bp-4],bx
	mov	Exec_BlkL,BX		; stash args
	;mov	[bp-2],es
	mov	Exec_BlkH,ES
	;mov	[bp-5],al
	mov	Exec_Func,AL
	;mov	byte [bp-6],0
	mov	Exec_Load_High,0

	;mov	[bp-26],dx
	mov	ExecNameL,DX		; set up length of exec name
	;mov	[bp-24],ds
	mov	ExecNameH,DS
	mov	SI,DX			; move pointer to convenient place
	;invoke	DStrLen
	call	DStrLen
	;mov	[bp-22],cx
	mov	ExecNameLen,CX		; save length

	; MSDOS 6.0
	;mov	al, [AllocMethod]	; M063: save alloc method in 
	;mov	[AllocMsave], al	; M063: AllocMsave

	xor	AL,AL			; open for reading
	push	BP

	; MSDOS 6.0
	;or	byte [DOS_FLAG], EXECOPEN ; this flag is set to indicate to 
					; the redir that this open call is
					; due to an exec.

	;invoke	$OPEN			; is the file there?
	call	_$OPEN

	; MSDOS 6.0
	;pushf
	;and	byte [DOS_FLAG],~EXECOPEN; reset flag
	;popf

	pop	BP
	;MSDOS 3.3
	jc	short Exec_Ret_Err

	;mov	[bp-8],ax
	mov	Exec_FH,AX
	mov	BX,AX
	xor	AL,AL
	;invoke	$Ioctl
	call	_$IOCTL
	jc	short Exec_BombJ

	;test	dl,80h
	test	DL,devid_ISDEV
	jz	short Exec_Check_Environ

	;mov	al,2
	mov	AL,error_file_not_found
Exec_BombJ:
	jmp	Exec_Bomb

BadEnv:
	;mov	al,0Ah
	mov	AL,error_bad_environment
	jmp	Exec_Bomb

Exec_Check_Environ:
	;mov	word [bp-18],0
	mov	Exec_Load_Block,0
	;mov	word [bp-14],0
	mov	Exec_Environ,0
					; overlays... no environment
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jnz	short Exec_Read_Header

	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get block
	mov	ax,[SI]
	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
	or	AX,AX
	jnz	short Exec_Scan_Env

	mov	DS,[SS:CurrentPDB]	;smr;SS Override
	;mov	ax,[44]
	mov	AX,[PDB.ENVIRON]

; MSDOS 6.0
;---------------------------------------------BUG 92 4/30/90-----------------
;
; Exec_environ is being correctly initialized after the environment has been
; allocated and copied form the parent's env. It must not be initialized here.
; Because if the call to $alloc below fails Exec_dealloc will deallocate the
; parent's environment.
;	mov	Exec_Environ,AX
;
;----------------------------------------------------------------------------

	;mov	[bp-14],ax
	;mov	Exec_Environ,ax

	or	AX,AX
	jz	short Exec_Read_Header

Exec_Scan_Env:
	mov	ES,AX
	xor	DI,DI
	;mov	cx,7FFFh ; MSDOS 3.3
	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
	xor	AL,AL

Exec_Get_Environ_Len:
	repnz	scasb			; find that nul byte
	jnz	short BadEnv

	dec	CX			; Dec CX for the next nul byte test
	js	short BadEnv		; gone beyond the end of the environment

	scasb				; is there another nul byte?
	jnz	short Exec_Get_Environ_Len ; no, scan some more

	push	DI
	;lea	bx,[DI+11h]
	lea	BX,[DI+0Fh+2]
	;add	bx,[bp-22]
	add	BX,ExecNameLen		; BX <- length of environment
					; remember argv[0] length
					; round up and remember argc
	mov	CL,4
	shr	BX,CL			; number of paragraphs needed
	push	ES
	;invoke	$Alloc			; can we get the space?
	call	_$ALLOC
	pop	DS
	pop	CX
	jnc	short Exec_Save_Environ

	jmp	SHORT Exec_No_Mem	; nope... cry and sob

Exec_Save_Environ:
	mov	ES,AX
	;mov	[bp-14],ax
	mov	Exec_Environ,AX 	; save him for a rainy day
	xor	SI,SI
	mov	DI,SI
	rep	movsb			; copy the environment
	mov	AX,1
	stosw
	;lds	si,[bp-26]
	lds	SI,ExecName
	;mov	cx,[bp-22]
	mov	CX,ExecNameLen
	rep	movsb

Exec_Read_Header:
	; We read in the program header into the above data area and
	; determine where in this memory the image will be located.

	;Context DS
	push	ss
	pop	ds
	;mov	cx,26
	mov	CX,Exec_Header_Len	; header size
	mov	DX,exec_signature
	push	ES
	push	DS
	call	ExecRead
	pop	DS
	pop	ES
	jc	short Exec_Bad_File

	or	AX,AX
	jz	short Exec_Bad_File
	;cmp	ax,26
	cmp	AX,Exec_Header_Len	; did we read the right number?
	jnz	short Exec_Com_Filej	; yep... continue

	test	word [exec_max_BSS],-1 	; indicate load high?
	jnz	short Exec_Check_Sig

	;mov	byte [bp-6],0FFh
	mov	Exec_Load_High,-1

Exec_Check_Sig:
	mov	AX,[exec_signature]	; rms;NSS
	;cmp	ax,5A4Dh ; 'MZ'
	cmp	AX,exe_valid_signature	; zibo arises!
	jz	short Exec_Save_Start 	; assume com file if no signature

	;cmp	ax,4D5Ah ; 'ZM'
	cmp	AX,exe_valid_old_signature  ; zibo arises!
	jz	short Exec_Save_Start 	; assume com file if no signature

Exec_Com_Filej:
	jmp	Exec_Com_File

	; We have the program header... determine memory requirements

Exec_Save_Start:
	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
	mov	CL,5			; convert to paragraphs
	shl	AX,CL
	sub	AX,[exec_par_dir] 	; AX = size in paragraphs;rms;NSS
	;mov	[bp-12],ax
	mov	Exec_Res_Len_Para,AX

		; Do we need to allocate memory?
		; Yes if function is not load-overlay

	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Allocate	; allocation of space

		; get load address from block

	;les	di,[bp-4]
	les	DI,Exec_Blk
	mov	ax,[es:di]
	;mov	AX,[ES:DI+EXEC3.load_addr]
	;mov	[bp-20],ax
	mov	Exec_DMA,AX
	mov	AX,[ES:DI+EXEC3.reloc_fac]
	;mov	[bp-10],ax
	mov	Exec_Rel_Fac,AX
	; 10/08/2018
	jmp	Exec_Find_Res		; M000

Exec_No_Mem:
	;mov	al,8
	mov	AL,error_not_enough_memory
	jmp	short Exec_Bomb

Exec_Bad_File:
	;mov	al,0Bh
	mov	AL,error_bad_format

Exec_Bomb:
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	call	Exec_Dealloc
	;LeaveCrit CritMem
	call	LcritMem
	;save	<AX,BP>
	push	ax
	push	bp
	;invoke	$CLOSE
	call	_$CLOSE
	;restore <BP,AX>
	pop	bp
	pop	ax
	jmp	Exec_Ret_Err

Exec_Chk_Mem: 
	; MSDOS 6.0    			; M063 - Start
	;mov	al,[AllocMethod]	; save current alloc method in ax
	;mov	bl,[AllocMsave]
	;mov	[AllocMethod], bl	; restore original allocmethod
	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	;jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
	;				; N: continue
	;
	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	;jz	short Exec_No_Mem	; N: no memory 
	;mov	ax,[save_AX]		; Y: restore ax and
	;jmp	short Exec_Norm_Alloc	;    Try again
	;				; M063 - End

Exec_Allocate:
	; 09/09/2018

	; M005 - START
	; If there is no STACK segment for this exe file and if this
	; not an overlay and the resident size is less than 64K - 
	; 256 bytes we shall add 256bytes bytes to the programs 
	; resident memory requirement and set Exec_SP to this value.

	; MSDOS 6.0
	mov	Exec_NoStack,0
	cmp	word [exec_SS],0	; Q: is there a stack seg
	jne	short ea1		; Y: continue normal processing
	cmp	word [exec_SP],0	; Q: is there a stack ptr
	jne	short ea1		; Y: continue normal processing

	inc	Exec_NoStack
	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
	jae	short ea1		; Y: don't set Exec_SP

	add	ax,10h			; add 10h paras to mem requirement
ea1:
	; M005 - END

	; MSDOS 6.0			; M000 - start
	;test	byte [AllocMethod],HIGH_FIRST
	;				; Q: is the alloc strat high_first
	;jz	short Exec_Norm_Alloc	; N: normal allocate
	;				; Y: set high_only bit
	;or	byte [AllocMethod],HIGH_ONLY
	;				; M000 - end

;Exec_Norm_Alloc:
	;mov	[save_ax],ax		; M000: save ax for possible 2nd  
					; M000: attempt at allocating memory
	;;push	ax			; M000

	; MSDOS 3.3
	push	ax	

	mov	BX,0FFFFh		; see how much room in arena
	push	DS
	;invoke	$Alloc			; should have carry set and BX has max
	call	_$ALLOC
	pop	DS

	; MSDOS 6.0
	;mov	ax,[save_ax]		; M000
	;;pop	AX			; M000

	; MSDOS 3.3
	pop	ax

	add	AX,10h			; room for header
	cmp	BX,11h			; enough room for a header
	; MSDOS 6.0
	;jb	short Exec_Chk_Mem	; M000
	; MSDOS 3.3	
	jb	short Exec_No_Mem

	cmp	AX,BX			; is there enough for bare image?
	; MSDOS 6.0
	;ja	short Exec_Chk_Mem	; M000
	; MSDOS 3.3
	ja	short Exec_No_Mem

	;test	byte [bp-6],0FFh
	test	Exec_Load_High,-1	; if load high, use max
	jnz	short Exec_BX_Max	; use max

	; 09/09/2018

	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
	; MSDOS 6.0
	;jc	short Exec_Chk_Mem		; M000
	; MSDOS 3.3
	jc	short Exec_No_Mem

	cmp	AX,BX			; enough space?
	; MSDOS 6.0
	;ja	short Exec_Chk_Mem	; M000: nope...	
	; MSDOS 3.3
	ja	short Exec_No_Mem

	sub	AX,[exec_min_BSS] 	; rms;NSS
	add	AX,[exec_max_BSS] 	; go for the MAX
	jc	short Exec_BX_Max

	cmp	AX,BX
	jbe	short Exec_Got_Block

Exec_BX_Max:
	mov	AX,BX

Exec_Got_Block:
	; 03/08/2018 - Retro DOS v3.0

	push	DS
	mov	BX,AX
	;mov	[bp-16],bx
	mov	Exec_Size,BX
	;invoke	$Alloc			; get the space
	call	_$ALLOC
	pop	DS
	; MSDOS 6.0
	;jc	short Exec_Chk_Mem	; M000
	; MSDOS 3.3
	jc	short Exec_No_Mem

	; MSDOS 6.0
	;mov	cl,[AllocMsave]		; M063: 
	;mov	[AllocMethod],cl	; M063: restore allocmethod

;M029; Begin changes
; This code does special handling for programs with no stack segment. If so,
;check if the current block is larger than 64K. If so, we do not modify
;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
;case Exec_SS is not changed.
;
	; MSDOS 6.0
	cmp	Exec_NoStack,0
	;je	@f
	je	short ea2

	cmp	bx,1000h		; Q: >= 64K memory block
	;jae	@f			; Y: Exec_SP = 0
	jae	short ea2
;
;Make Exec_SP point at the top of the memory block
;
	mov	cl,4
	shl	bx,cl			; get byte offset
	sub	bx,100h			; take care of PSP
	mov	[exec_SP],bx		; Exec_SP = top of block
ea2:
;@@:
;
;M029; end changes
;
	;mov	[bp-18],ax
	mov	Exec_Load_Block,AX
	add	AX,10h
	;test	byte [bp-6],0FFh
	test	Exec_Load_High,-1
	jz	short Exec_Use_AX	; use ax for load info

	;add	ax,[bp-16]
	add	AX,Exec_Size		; go to end
	;sub	ax,[bp-12]
	sub	AX,Exec_Res_Len_Para	; drop off header
	sub	AX,10h			; drop off pdb

Exec_Use_AX:
	;mov	[bp-10],ax
	mov	Exec_Rel_Fac,AX 	; new segment
	;mov	[bp-20],ax
	mov	Exec_DMA,AX		; beginning of dma

	; Determine the location in the file of the beginning of
	; the resident

Exec_Find_Res:
	; MSDOS 6.0
	;mov	dx,[bp-20]
	mov	DX,Exec_DMA
	;mov	[bp-28],dx
	mov	Exec_DMA_Save,DX

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	DX,[exec_par_dir]
	push	DX
	mov	CL,4
	shl	DX,CL			; low word of location
	pop	AX
	mov	CL,12
	shr	AX,CL			; high word of location
	mov	CX,AX			; CX <- high

		; Read in the resident image (first, seek to it)
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	push	DS
	xor	AL,AL
	;invoke	$Lseek			; Seek to resident
	call	_$LSEEK
	pop	DS
	jnc	short Exec_Big_Read

	jmp	Exec_Bomb

Exec_Big_Read:				; Read resident into memory
	;mov	bx,[bp-12]
	mov	BX,Exec_Res_Len_Para
	cmp	BX,1000h		; Too many bytes to read?
	jb	short Exec_Read_OK

	mov	BX,0FE0h		; Max in one chunk FE00 bytes

Exec_Read_OK:
	;sub	[bp-12],bx
	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
	push	BX
	mov	CL,4
	shl	BX,CL			; Get count in bytes from paras
	mov	CX,BX			; Count in correct register
	push	DS
	;mov	ds,[bp-20]
	mov	DS,Exec_DMA		; Set up read buffer

	xor	DX,DX
	push	CX			; Save our count
	call	ExecRead
	pop	CX			; Get old count to verify
	pop	DS
	jc	short Exec_Bad_FileJ

	cmp	CX,AX			; Did we read enough?
	pop	BX			; Get paragraph count back
	jz	short ExecCheckEnd	; and do reloc if no more to read

	; The read did not match the request. If we are off by 512
	; bytes or more then the header lied and we have an error.

	sub	CX,AX
	cmp	CX,512
	jae	short Exec_Bad_FileJ

	; We've read in CX bytes... bump DTA location

ExecCheckEnd:
	;add	[bp-20],bx
	add	Exec_DMA,BX		; Bump dma address
	;test	word [bp-12],0FFFFh
	test	Exec_Res_Len_Para,-1
	jnz	short Exec_Big_Read

	; The image has now been read in. We must perform relocation
	; to the current location.

exec_do_reloc:
	;mov	cx,[bp-10]
	mov	CX,Exec_Rel_Fac
	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
	add	AX,CX			; and relocate him
	mov	[exec_init_SS],AX 	; rms;NSS

	mov	AX,[exec_SP]		; initial SP ;rms;NSS
	mov	[exec_init_SP],AX 	; rms;NSS

	les	AX,[exec_IP]		; rms;NSS
	mov	[exec_init_IP],AX 	; rms;NSS
	mov	AX,ES			; rms;NSS
	add	AX,CX			; relocated...
	mov	[exec_init_CS],AX 	; rms;NSS

	xor	CX,CX
	mov	DX,[exec_rle_table]	; rms;NSS
	;mov	bx,[bp-8]
	mov	BX,Exec_FH
	push	DS
	xor	AX,AX
	;invoke	$Lseek
	call	_$LSEEK
	pop	DS
	jnc	short exec_get_entries

Exec_Bad_FileJ:
	jmp	Exec_Bad_File

exec_get_entries:
	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS

exec_read_reloc:
	push	DX
	;mov	dx,OPENBUF
	mov	DX,Exec_Internal_Buffer
	;mov	cx,388
	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (390>>2)<<2
	push	DS
	call	ExecRead
	pop	ES
	pop	DX
	jc	short Exec_Bad_FileJ

	;mov	cx,97
	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (390>>2)
					; Pointer to byte location in header
	;mov	di,OPENBUF
	mov	DI,Exec_Internal_Buffer
	;mov	si,[bp-10]
	mov	SI,Exec_Rel_Fac 	; Relocate a single address

exec_reloc_one:
	or	DX,DX			; Any more entries?
	jz	short Exec_Set_PDBJ

exec_get_addr:
	lds	BX,[ES:DI]		; Get ra/sa of entry
	mov	AX,DS			; Relocate address of item

	; MSDOS 6.0
;;;;;;	add	AX,SI  ; MSDOS 3.3
	;add	ax,[bp-28]
	add	AX,Exec_DMA_Save

	mov	DS,AX
	add	[BX],SI
	add	DI,4
	dec	DX
	loop	exec_reloc_one		; End of internal buffer?

	; We've exhausted a single buffer's worth. Read in the next
	; piece of the relocation table.

	push	ES
	pop	DS
	jmp	short exec_read_reloc

Exec_Set_PDBJ:

	; MSDOS 6.0
	;
	; We now determine if this is a buggy exe packed file and if 
	; so we patch in the right code. Note that fixexepatch will
	; point to a ret if dos loads low. The load segment as 
	; determined above will be in exec_dma_save
	;
	;push	es
	;push	ax			; M030
	;push	cx			; M030
	;mov	es,Exec_DMA_Save
	;mov	ax,[exec_init_CS]	; M030
	;mov	cx,[exec_init_IP]	; M030
	;call	word [fixexepatch]
	;call	word [Rational386PatchPtr]
	;pop	cx			; M030
	;pop	ax			; M030
	;pop	es

	jmp	Exec_Set_PDB

Exec_No_Memj:
	jmp	Exec_No_Mem

	; we have a .COM file.	First, determine if we are merely
	; loading an overlay.

Exec_Com_File:
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Alloc_Com_File
	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get arg block
	lodsw				; get load address
	;mov	[bp-20],ax
	mov	Exec_DMA,AX
	mov	AX,0FFFFh
	jmp	SHORT Exec_Read_Block	; read it all!

Exec_Chk_Com_Mem:			
	; MSDOS 6.0	     		; M063 - Start
	;mov	al,[AllocMethod]	; save current alloc method in ax
	;mov	bl,[AllocMsave]
	;mov	[AllocMethod],bl	; restore original allocmethod
	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
	;jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
	;				; N: continue
	;
	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
	;jz	short Exec_No_Memj	; N: no memory 
	;
	;mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
	;xor	bx,bx			; M047: bx => free arena
	;call	ChangeOwner		; M047: free this block
	;
	;jmp	short Exec_Norm_Com_Alloc
	;				; M063 - End
	
	; We must allocate the max possible size block (ick!)
	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
	; size of block.

Exec_Alloc_Com_File:

	; MSDOS 6.0			; M000 -start
	;test	byte [AllocMethod],HIGH_FIRST
	;				; Q: is the alloc strat high_first
	;jz	short Exec_Norm_Com_Alloc ; N: normal allocate
	;				; Y: set high_only bit
	;or	byte [AllocMethod],HIGH_ONLY
	;				; M000 - end
;Exec_Norm_Com_Alloc:			; M000
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	BX,0FFFFh
	;invoke	$Alloc			; largest piece available as error
	call	_$ALLOC
	or	BX,BX
	; MSDOS 6.0
	;jz	short Exec_Chk_Com_Mem	; M000
	; MSDOS 3.3
	jz	short Exec_No_Memj

	;mov	[bp-16],bx
	mov	Exec_Size,BX		; save size of allocation block
	push	BX
	;invoke	$ALLOC			; largest piece available as error
	call	_$ALLOC
	pop	BX			; get size of block...
	;mov	[bp-18],ax
	mov	Exec_Load_Block,AX
	add	AX,10h			; increment for header
	;mov	[bp-20],ax
	mov	Exec_DMA,AX
	xor	AX,AX			; presume 64K read...
	cmp	BX,1000h		; 64k or more in block?
	jae	short Exec_Read_Com	; yes, read only 64k

	mov	AX,BX			; convert size to bytes
	mov	CL,4
	shl	AX,CL
	; MSDOS 6.0
        cmp     AX,200h                 ; enough memory for PSP and stack?
;	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
;	;jbe	short Exec_No_Memj	; M000: jump if not
	; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
	;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
	jbe	short Exec_No_Memj	; M000: jump if not

					; M047: size of the block is < 64K
	sub	ax,100h			; M047: reserve 256 bytes for stack

Exec_Read_Com:
	; MSDOS 3.3 (& MSDOS 6.0)
	sub	AX,100h 		; remember size of psp

Exec_Read_Block:
	push	AX			; save number to read
	;mov	bx,[bp-8]
	mov	BX,Exec_FH		; of com file
	xor	CX,CX			; but seek to 0:0
	mov	DX,CX
	xor	AX,AX			; seek relative to beginning
	;invoke	$Lseek			; back to beginning of file
	call	_$LSEEK
	pop	CX			; number to read
	;mov	ds,[bp-20]
	mov	DS,Exec_DMA
	xor	DX,DX
	push	CX
	call	ExecRead
	pop	SI			; get number of bytes to read
	jnc	short OkRead

	jmp	Exec_Bad_File

	; 10/09/2018
OkRead:
	cmp	AX,SI			; did we read them all?
	; MSDOS 6.0
	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
	; MSDOS 3.3
	jz	short Exec_No_Memj	; M00: exactly the wrong number...
	
	; MSDOS 6.0
	;mov	bl,[AllocMsave]		; M063
	;mov	[AllocMethod],bl	; M063: restore allocmethod

	; MSDOS 3.3 (& MSDOS 6.0)
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jnz	short Exec_Set_PDB	; no starto, chumo!

	;mov	ax,[bp-20]
	mov	AX,Exec_DMA
	sub	AX,10h
	mov	[SS:exec_init_CS],AX
	mov	word [SS:exec_init_IP],100h ; initial IP is 100h

	; SI is AT MOST FF00h. Add FE to account for PSP - word
	; of 0 on stack.

	add	SI,0FEh 		; make room for stack

	; MSDOS 6.0
	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
	je	short Exec_St_Ok	; M047: Y: stack is fine
	add	si,100h			; M047: N: add the xtra 100h for stack

Exec_St_Ok:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
	mov	[SS:exec_init_SS],AX 					;smr;SS Override
	mov	DS,AX
	mov	WORD [SI],0		; 0 for return

	; MSDOS 6.0
	;
	; M068
	;
	; We now determine if this is a Copy Protected App. If so the 
	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
	; a ret if DOS is loaded low. Also DS contains the load segment.

	;call	word ptr [ChkCopyProt]	

Exec_Set_PDB:
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	bx,[bp-8]
	mov	BX,Exec_FH		; we are finished with the file.
	call	Exec_Dealloc
	push	BP
	;invoke	$Close			; release the jfn
	call	_$CLOSE
	pop	BP
	call	Exec_Alloc
	;test	byte [bp-5],2
	test	Exec_Func,exec_func_overlay
	jz	short Exec_Build_Header

	; MSDOS 6.0
	;call	Scan_Execname
	;call	Scan_Special_Entries
	;
;SR;
;The current lie strategy uses the PSP to store the lie version. However,
;device drivers are loaded as overlays and have no PSP. To handle them, we
;use the Sysinit flag provided by the BIOS as part of a structure pointed at
;by BiosDataPtr. If this flag is set, the overlay call has been issued from
;Sysinit and therefore must be a device driver load. We then get the lie 
;version for this driver and put it into the Sysinit PSP. When the driver
;issues the version check, it gets the lie version until the next overlay
;call is issued.
;
	;cmp	DriverLoad,0		;was Sysinit processing done?
	;je	norm_ovl		;yes, no special handling
	;push	si
	;push	es
	;les	si,BiosDataPtr		;get ptr to BIOS data block
	;cmp	byte ptr es:[si],0		;in Sysinit?
	;je	sysinit_done		;no, Sysinit is finished
	;
	;mov	es,CurrentPDB		;es = current PSP (Sysinit PSP)
	;push	Special_Version
	;pop	es:PDB_Version		;store lie version in Sysinit PSP
		;;; PDB.VERSION
	;jmp	short setver_done
;sysinit_done:
	;mov	DriverLoad,0		;Sysinit done,special handling off
;setver_done:
	;pop	es
	;pop	si
;norm_ovl:

	;leave
	mov	sp,bp		
	pop	bp

	;transfer SYS_RET_OK		; overlay load -> done
	jmp	SYS_RET_OK

Exec_Build_Header:
	;mov	dx,[bp-18]
	mov	DX,Exec_Load_Block
					; assign the space to the process
	;mov	si,1
	mov	SI,ARENA.OWNER		; pointer to owner field
	;mov	ax,[bp-14]
	mov	AX,Exec_Environ 	; get environ pointer
	or	AX,AX
	jz	short No_Owner		; no environment

	dec	AX			; point to header
	mov	DS,AX
	mov	[SI],DX 		; assign ownership

No_Owner:
	;mov	ax,[bp-18]
	mov	AX,Exec_Load_Block	; get load block pointer
	dec	AX
	mov	DS,AX			; point to header
	mov	[SI],DX 		; assign ownership

	; MSDOS 6.0
	;push	DS			;AN000;MS. make ES=DS
	;pop	ES			;AN000;MS.
	;mov	DI,Arena_Name		;AN000;MS. ES:DI points to destination
	;call	Scan_Execname		;AN007;MS. parse execname
	;				;	   ds:si->name, cx=name length
	;push	CX			;AN007;;MS. save for fake version
	;push	SI			;AN007;;MS. save for fake version
	;
;MoveName:				;AN000;
	;lodsb				;AN000;;MS. get char
	;cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
	;jz	Mem_Done		;AN000;;MS. no, move to header
	;				;AN000;
	;stosb				;AN000;;MS. move char
	;				; MSKK bug fix - limit length copied
	;cmp	di,16			; end of memory arena block?
	;jae	mem_done		; jump if so
	;
	;loop	movename		;AN000;;MS. continue
;Mem_Done:				;AN000;
	;xor	AL,AL			;AN000;;MS. make ASCIIZ
	;cmp	DI,SIZE ARENA		;AN000;MS. if not all filled
	;jae	Fill8			;AN000;MS.
	;
	;stosb				;AN000;MS.
	;
;Fill8:					;AN000;
	;pop	SI			;AN007;MS. ds:si -> file name
	;pop	CX			;AN007;MS.
	;
	;call	Scan_Special_Entries	;AN007;MS.

	; MSDOS 3.3 (& MSDOS 6.0)
	push	DX
	;mov	si,[bp-16]
	mov	SI,Exec_Size
	add	SI,DX
	;Invoke	$Dup_PDB		; ES is now PDB
	call	_$DUP_PDB
	pop	DX

	;push	word [bp-14]
	push	Exec_Environ
	;pop	WORD [ES:2Ch]
	pop	word [ES:PDB.ENVIRON]

	; MSDOS 6.0			; *** Added for DOS 5.00
					; version number in PSP
 	;push	word [Special_Version]	; Set the DOS version number to
	;pop	word [ES:PDB_Version]	; to be used for this application
		; PDB.VERSION

	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
	;lds	si,[bp-4]
	lds	SI,Exec_Blk		; get the block
	push	DS			; save its location
	push	SI
	;lds	si, [si+6]
	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb

	; DS points to user space 5C FCB

	mov	CX,12			; copy drive, name and ext
	push	CX
	mov	DI,5Ch
	mov	BL,[SI]
	rep	movsb

	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h

	xor	AX,AX			; zero extent, etc for CPM
	stosw
	stosw

	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch

	pop	CX
	pop	SI			; get block
	pop	DS
	push	DS			; save (again)
	push	SI
	;lds	si,[si+0Ah]
	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB

	; DS points to user space 6C FCB

	mov	BH,[SI] 		; do same as above
	rep	movsb
	stosw
	stosw
	pop	SI			; get block (last time)
	pop	DS
	;ld	si,[si+2]
	lds	SI,[SI+EXEC0.COM_LINE]	; command line

	; DS points to user space 80 command line

	or	CL,80h
	mov	DI,CX
	rep	movsb			; Wham!

	; Process BX into default AX (validity of drive specs on args).
	; We no longer care about DS:SI.

	dec	CL			; get 0FFh in CL
	mov	AL,BH
	xor	BH,BH
	;invoke	GetVisDrv
	call	GetVisDrv
	jnc	short Exec_BL

	mov	BH,CL

Exec_BL:
	mov	AL,BL
	xor	BL,BL
	;invoke	GetVisDrv
	call	GetVisDrv
	jnc	short Exec_Set_Return

	mov	BL,CL

Exec_Set_Return:
	;invoke	Get_User_Stack			; get his return address
	call	Get_User_Stack

	;push	word [si+14h]
	push	word [SI+user_env.user_CS]	; suck out the CS and IP
	;push	word [si+12h]
	push	word [SI+user_env.user_IP]
	;push	word [si+14h]
	push	word [SI+user_env.user_CS]	; suck out the CS and IP
	;push	word [si+12h]
	push	word [SI+user_env.user_IP]
	;pop	word [ES:0Ah]
	pop	WORD [ES:PDB.EXIT]
	;pop	word [ES:0Ch]
	pop	WORD [ES:PDB.EXIT+2]

	xor	AX,AX
	mov	DS,AX
					; save them where we can get them
					; later when the child exits.
	;pop	word [88h]
	pop	word [addr_int_terminate] ; 22h*4
	;pop	word [90h]
	pop	word [addr_int_terminate+2] ; (22h*4)+2

	mov	WORD [SS:DMAADD],80h	; SS Override
	mov	DS,[SS:CurrentPDB]	; SS Override
	mov	[SS:DMAADD+2],DS	; SS Override

	;test	byte [bp-5],1
	test	Exec_Func,exec_func_no_execute
	jz	short exec_go

	lds	SI,[SS:exec_init_SP]	; get stack SS Override
	;les	di,[bp-4]
	les	DI,Exec_Blk		; and block for return
	;mov	[es:di+10h],ds
	mov	[ES:DI+EXEC1.SS],DS	; return SS

	dec	SI			; 'push' default AX
	dec	SI
	mov	[SI],BX 		; save default AX reg
	;mov	[es:di+0Eh], si
	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'

	lds	AX,[SS:exec_init_IP]	; SS Override
	;mov	[es:di+14h],ds
	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
	;mov	[es:di+12h],ax
	mov	[ES:DI+EXEC1.IP],AX
	
	;leave
	mov	sp,bp
	pop	bp	

	;transfer SYS_RET_OK
	jmp	SYS_RET_OK

exec_go:
	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
	les	DI,[SS:exec_init_SP]	; new stack SS Override
	mov	AX,ES

	; MSDOS 6.0
	;cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
	;je	short Xfer_To_User	; N: transfer control to user

	;push	ds			; Y: control must go to low mem stub
	;	
	;push	cs			;    where we disable a20 and Xfer 
	;pop	ds			;    control to user 
	;
	;or	byte [DOS_FLAG],EXECA20OFF ; M068:
	;				; M004: Set bit to signal int 21
	;				; ah = 25 & ah= 49. See dossym.inc 
	;				; under TAG M003 & M009 for 
	;				; explanation
	;mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
	;				; M068: going to be turned OFF.
	;
	;mov	ax,ds			; ax = segment of low mem stub
	;pop	ds
	;
	;push	ax			; ret far into the low mem stub
	;mov	ax,Disa20_Xfer
	;push	ax
	;mov	AX,ES			; restore ax
	;retf

Xfer_To_User:
	; DS:SI points to entry point
	; AX:DI points to initial stack
	; DX has PDB pointer
	; BX has initial AX value

	cli
	; 15/08/2018
	mov	BYTE [SS:INDOS],0	; SS Override

	mov	SS,AX			; set up user's stack
	mov	SP,DI			; and SP
	sti

	push	DS			; fake long call to entry
	push	SI
	mov	ES,DX			; set up proper seg registers
	mov	DS,DX
	mov	AX,BX			; set up proper AX

	retf

; 04/08/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ExecRead:
	CALL	Exec_Dealloc
	;mov	bx,[bp-8]
	MOV	bx,Exec_FH
	PUSH	BP
	call	_$READ
	POP	BP
	CALL	Exec_Alloc
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

Exec_Dealloc:
	push	BX
	;mov	bx,0
	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
	call	EcritMem
	call	ChangeOwners
	pop	BX
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

Exec_Alloc:
	push	BX
	;mov	bx,[SS:CurrentPDB]	; SS Override
	mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
	call	ChangeOwners
	call	LcritMem
	pop	BX
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ChangeOwners:
	pushf
	push	AX
	;mov	ax,[bp-14]
	mov	AX,Exec_Environ
	call	ChangeOwner
	;mov	ax,[bp-18]
	mov	AX,Exec_Load_Block
	call	ChangeOwner
	pop	AX
	popf
chgown_retn:
	retn

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

ChangeOwner:
	or	AX,AX			; is area allocated?
	jz	short chgown_retn	; no, do nothing
	dec	AX
	push	DS
	mov	DS,AX
	mov	[ARENA.OWNER],BX
	pop	DS
	retn


; MSDOS 6.0
;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

;Procedure	Scan_Execname,near
;	ASSUME	SS:DosData
;
;	lds	SI,ExecName		; DS:SI points to name
;Entry	Scan_Execname1			; M028
;Save_Begin:				;
;	mov	CX,SI			; CX= starting addr
;Scan0:					;
;	lodsb				; get char
;
;	cmp	AL,':'			; is ':' , may be A:name
;	jz	save_begin		; yes, save si
;	cmp	AL,'\'                  ; is '\', may be A:\name
;	jz	save_begin		; yes, save si
;	cmp	AL,0			; is end of name
;	jnz	scan0			; no, continue scanning
;	sub	SI,CX			; get name's length
;	xchg	SI,CX			; cx= length, si= starting addr
;
;	return
;
;EndProc Scan_Execname

; MSDOS 6.0
;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

;Procedure    Scan_Special_Entries,near
;	assume	SS:DOSDATA
;
;	dec	CX			; cx= name length
;;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
;					;reset to current version
;	mov    [Special_Version],(Minor_Version SHL 8) + Major_Version
;;***	call	Reset_Version
;
;;M060	push	SS
;;M060	pop	ES
;
;	les	DI,SS:UU_IFS_DOS_CALL	;M060; ES:DI --> Table in SETVER.SYS
;	mov	AX,ES			;M060; First do a NULL ptr check to
;	or	AX,DI			;M060; be sure the table exists
;	jz	End_List		;M060; If ZR then no table
;
;GetEntries:
;	mov	AL,ES:[DI]		; end of list
;	or	AL,AL
;	jz	End_List		; yes
;
;	mov	[Temp_Var2],DI		; save di
;	cmp	AL,CL			; same length ?
;	jnz	SkipOne 		; no
;
;	inc	DI			; es:di -> special name
;	push	CX			; save length and name addr
;	push	SI
;
;;
;; M050 - BEGIN
;;
;	push	ax			; save len
;sse_next_char:
;	lodsb
;	call	UCase
;	scasb
;	jne	Not_Matched
;	loop	sse_next_char
;	
;;
;;	repz	cmpsb			; same name ?
;;
;;	jnz	Not_Matched		; no
;;
;	pop	ax			; take len off the stack
;;
;; M050 - END
;;
;	mov	AX,ES:[DI]		; get special version
;	mov	[Special_Version],AX	; save it
;
;;***	mov	AL,ES:[DI+2]		; get fake count
;;***	mov	[Fake_Count],AL 	; save it
;
;	pop	SI
;	pop	CX
;	jmp	SHORT end_list
;
;Not_Matched:
;	pop	ax			; get len from stack ; M050
;	pop	SI			; restore si,cx
;	pop	CX
;
;SkipOne:
;	mov	DI,[Temp_Var2]		; restore old di use SS Override
;	xor	AH,AH			; position to next entry
;	add	DI,AX
;
;	add	DI,3			; DI -> next entry length
;;***	add	DI,4			; DI -> next entry length
;
;	jmp	Getentries
;
;End_List:
;	return
;
;EndProc Scan_Special_Entries


; 04/08/2018 - Retro DOS v3.0
; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh

;----------------------------------------------------------------------------
;SUBTTL Terminate and stay resident handler
;
; Input:    DX is  an  offset  from  CurrentPDB  at which to
;	    truncate the current block.
;
; output:   The current block is truncated (expanded) to be [DX+15]/16
;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
;	    and restoring the vectors.
;
;----------------------------------------------------------------------------

_$KEEP_PROCESS:
	push	AX			; keep exit code around
	;mov	byte [SS:EXIT_TYPE],3
	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
	mov	ES,[SS:CurrentPDB]
	cmp	DX,6h			; keep enough space around for system
	jae	short Keep_Shrink	; info

	mov	DX,6h

Keep_Shrink:
	mov	BX,DX
	push	BX
	push	ES
	call	_$SETBLOCK		; ignore return codes.
	pop	DS
	pop	BX
	jc	short Keep_Done		; failed on modification

	mov	AX,DS
	add	AX,BX
	;mov	[2],ax
	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG

Keep_Done:
	pop	AX
	jmp	SHORT exit_inner	; and let abort take care of the rest

;----------------------------------------------------------------------------
;
;----------------------------------------------------------------------------

STAY_RESIDENT:
	;mov	ax,3100h
	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
	add	DX,15
	rcr	DX,1
	mov	CL,3
	shr	DX,CL

	jmp	COMMAND

;----------------------------------------------------------------------------
;SUBTTL $EXIT - return to parent process
;   Assembler usage:
;	    MOV     AL, code
;	    MOV     AH, Exit
;	    INT     int_command
;   Error return:
;	    None.
;
;----------------------------------------------------------------------------

_$EXIT:
	; 04/08/2018 - Retro DOS v3.0
	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
	xor	AH,AH
	xchg	AH,[SS:DidCTRLC]
	or	AH,AH
	;mov	BYTE [SS:EXIT_TYPE],0
	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
	jz	short exit_inner
	;mov	BYTE [SS:EXIT_TYPE],1
	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C

	;entry	Exit_inner
exit_inner:
	call	Get_User_Stack		;PBUGBUG

	push	word [ss:CurrentPDB]
	;pop	word [si+14h]
	pop	word [SI+user_env.user_CS] ;PBUGBUG
	jmp	short abort_inner

;BREAK <$ABORT -- Terminate a process>
;----------------------------------------------------------------------------
; Inputs:
;	user_CS:00 must point to valid program header block
; Function:
;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
;	to the terminate address
; Returns:
;	TO THE TERMINATE ADDRESS
;----------------------------------------------------------------------------

_$ABORT:
	xor	AL,AL
	;mov	byte [SS:EXIT_TYPE],0
	;mov	byte [SS:EXIT_TYPE],AL ; = 0
	mov	byte [SS:EXIT_TYPE],EXIT_ABORT

	; abort_inner must have AL set as the exit code! The exit type
	; is retrieved from exit_type. Also, the PDB at user_CS needs
	; to be correct as the one that is terminating.

abort_inner:
	mov	AH,[SS:EXIT_TYPE]
	mov	[SS:exit_code],AX
	call	Get_User_Stack

	;mov	ds,[si+14h]
	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
	xor	AX,AX
	mov	ES,AX
	;mov	si,10
	mov	SI,SAVEXIT
	;mov	di,88h
	mov	DI,addr_int_terminate
	movsw
	movsw
	movsw
	movsw
	movsw
	movsw
	jmp	reset_environment

; MSDOS 6.0
;----------------------------------------------------------------------------
;
; fixexepatch will point to this is DOS loads low. 
;
;----------------------------------------------------------------------------

;retexepatch	proc	near
;	
;	ret
;
;retexepatch 	endp


;============================================================================
; ALLOC.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0

;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc

;**
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;
;	Memory related system calls and low level routines for MSDOS 2.X.
;	I/O specs are defined in DISPATCH.
;
;	$ALLOC
;	$SETBLOCK
;	$DEALLOC
;	$AllocOper
;	arena_free_process
;	arena_next
;	check_signature
;	Coalesce
;
;	Modification history:
;
;	    Created: ARR 30 March 1983
;
;	    Revision: M000 - added support for allocing UMBs. 7/9/90
;		      M003 - added support for link/unlink UMBs from
;			     DOS arena chain. 7/18/90
;		      M009 - Added error returns invalid function and 
;			     arena trashed in set link state call.
;		      M010 - Release UMB arenas allocated to current PDB
;			     if UMB_HEAD is initialized.
;
;		      M016 - MACE utilities mkeyrate.com version 1.0 
;			     support. Please see under M009 in 
;			     ..\inc\dossym.inc. 8/31/90.
;
;		      M061 - In GetLastArena, if linking in UMBs check to make
;			     sure that umb_head arena is valid and also make
;			     sure that the previous arena is pointing to 
;			     umb_head.
;
;		      M064 - allow HIGH_ONLY bit to be set by a call to 
;			     set allloc strategy.
;			     use STRAT_MASK to mask out bits 6 & 7 of 
;			     bx in AllocSetStrat.
;
;		      M068 - use a count value (A20OFF_COUNT) rather than
;			     a bit to indicate to dos dispatcher to turn
;			     a20 off before iret. See M016.
;

;	BREAK	<memory allocation utility routines>


; 15/04/2018 - Retro DOS v2.0
;----------------------------------------------------------------------------
; xenix memory calls for MSDOS
;
; CAUTION: The following routines rely on the fact that arena_signature and
; arena_owner_system are all equal to zero and are contained in DI.
;
;INCLUDE DOSSEG.ASM

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;TITLE ALLOC.ASM - memory arena manager
;NAME Alloc

;SUBTTL memory allocation utility routines
;PAGE
;
; arena data
;
;       i_need  arena_head,WORD         ; seg address of start of arena
;       i_need  CurrentPDB,WORD         ; current process data block addr
;       i_need  FirstArena,WORD         ; first free block found
;       i_need  BestArena,WORD          ; best free block found
;       i_need  LastArena,WORD          ; last free block found
;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last

;**	Arena_Free_Process
;----------------------------------------------------------------------------
;	Free all arena blocks allocated to a prOcess
;
;	ENTRY	(bx) = PID of process
;	EXIT	none
;	USES	????? BUGBUG
;----------------------------------------------------------------------------

arena_free_process:
	; 04/08/2018 - Retro DOS v3.0
        MOV	AX,[SS:arena_head]
arena_free_process_start:
	MOV     DI,ARENA.SIGNATURE ; 0
	;MOV	AX,[SS:arena_head] ; 15/04/2018  
        CALL    check_signature         ; ES <- AX, check for valid block

arena_free_process_loop:
        ;retc
        JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
	PUSH    ES
        POP     DS
	;cmp	[1],bx 
        CMP     [ARENA.OWNER],BX	; is block owned by pid?
        JNZ     SHORT arena_free_next	; no, skip to next
	; 20/05/2019
	;mov	[1],di
        MOV     [ARENA.OWNER],DI	; yes... free him

arena_free_next:
	;cmp	byte [di],5Ah ;'Z'
        CMP     BYTE [DI],arena_signature_end
                                        ; end of road, Jack?
        ;retz				; never come back no more
	JZ	SHORT AFP_RETN  ;msdos 3.3 (& MSDOS 2.11)
	; MSDOS 6.0
	;jz	short arena_chk_umbs
        
	CALL    arena_next              ; next item in ES/AX carry set if trash
        JMP     SHORT arena_free_process_loop

	; MSDOS 6.0
;arena_chk_umbs:			; M010 - Start
	;mov	ax,[umb_head]		; ax = umb_head
	;cmp	ax,0FFFFh		; Q: is umb_head initialized
	;je	short ret_label		; N: we're done
	;
	;mov	di,ds			; di = last arena
	;cmp	di,ax			; Q: is last arena above umb_head
	;jae	short ret_label		; Y: we've scanned umbs also. done.
	;jmp	short arena_free_process_start
					; M010 - End

;AFP_RETN:
;	RETN

;	BREAK	<Arena Helper Routines>

;**	Arena_Next - Find Next item in Arena
;----------------------------------------------------------------------------
;	ENTRY	DS - pointer to block head
;		(di) = 0
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;----------------------------------------------------------------------------

arena_next:
        MOV     AX,DS                   ; AX <- current block
        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
        INC     AX                      ; remember that header!
;
;       fall into check_signature and return
;
;       CALL    check_signature         ; ES <- AX, carry set if error
;       RET

;**	Check_Signature - Check Memory Block Signature
;----------------------------------------------------------------------------
;	ENTRY	(AX) = address of block header
;		(di) = 0
;	EXIT	 ES = AX
;		'C' clear if signature good
;		'C' set if signature bad
;	USES	ES, Flags
;----------------------------------------------------------------------------

check_signature:        

	MOV     ES,AX                   ; ES <- AX
	;cmp	byte [es:di],4Dh ; 'M'
        CMP     BYTE [ES:DI],arena_signature_normal
                                        ; IF next signature = not_end THEN
        JZ      SHORT check_signature_ok ;   GOTO ok
	;cmp 	byte [es:di],5Ah ; 'Z'
        CMP     BYTE [ES:DI],arena_signature_end
                                        ; IF next signature = end then
        JZ      SHORT check_signature_ok ;   GOTO ok
        STC                             ; set error
;ret_label: ; MSDOS 6.0
AFP_RETN:
 	;  Retro DOS v.20 - 05/03/2018
check_signature_ok:
COALESCE_RETN:
	RETN

;**	Coalesce - Combine free blocks ahead with current block
;----------------------------------------------------------------------------
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	ENTRY	(ds) = pointer to the head of a free block
;		(di) = 0
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	(cx)
;----------------------------------------------------------------------------
        
Coalesce:
	;cmp	byte [di],5Ah ; 'Z'
	CMP     BYTE [DI],arena_signature_end
                                        ; IF current signature = END THEN
        ;retz				;   GOTO ok
        jz	short COALESCE_RETN
	CALL    arena_next              ; ES, AX <- next block, Carry set if error
        ;retc				; IF no error THEN GOTO check
	jc	short COALESCE_RETN

coalesce_check:
	;cmp	[es:1],di
        CMP     [ES:ARENA.OWNER],DI
        ;retnz				; IF next block isnt free THEN return
        JNZ	SHORT COALESCE_RETN
	;mov	cx,[ES:3]
	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
        INC     CX                      ; CX <- CX + 1 (for header size)
        ;ADD	[3],CX
	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
        MOV     CL,[ES:DI]              ; move up signature
        MOV     [DI],CL
        JMP     SHORT Coalesce		; try again

; 04/08/2018 - Retro DOS v3.0
; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh

;	BREAK  <$Alloc - allocate space in memory>

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$Alloc - Allocate Memory Space
;
;	$Alloc services the INT21 that allocates memory space to a program.
;	Alloc returns a pointer to a free block of memory that
;	has the requested size in paragraphs.
;
;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
;	scanned from umb_head if not from arena_head. If the strategy is
; 	HIGH_FIRST the scan is continued from arena_head if a block of 
;	appropriate size is not found in the UMBs. If the strategy is 
;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
;
;	In either case if bit 0 of UmbFlag is not initialized then the scan
;	starts from arena_head.
;
;	Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;
;	BUGBUG - a lot can be done to improve performance. We can set marks
;	so that we start searching the arena at it's first non-trivial free
;	block, we can peephole the code, etc. (We can move some subr calls
;	inline, etc.) I assume that this is called rarely and that the arena
;	doesn't have too many memory objects in it beyond the first free one.
;	verify that this is true; if so, this can stay as is
;
;	ENTRY	(bx) = requested size, in bytes
;		(DS) = (ES) = DOSGROUP
;	EXIT	'C' clear if memory allocated
;		  (ax:0) = address of requested memory
;		'C' set if request failed
;		  (AX) = error_not_enough_memory
;		    (bx) = max size we could have allocated
;		  (ax) = error_arena_trashed
;	USES	All
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $Alloc - allocate space in memory
;
;   Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;         AX:0 is pointer to allocated memory
;         BX is max size if not enough memory
;
;   Description:
;           Alloc returns  a  pointer  to  a  free  block of
;       memory that has the requested  size  in  paragraphs.
;
;   Error return:
;           AX = error_not_enough_memory
;              = error_arena_trashed
;----------------------------------------------------------------------------

_$ALLOC:
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit critMem
	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0

	; MSDOS 6.0
	;mov	ax,[arena_head]
	;mov	[start_arena],ax	; assume LOW_FIRST
	;			
	;test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
	;				; Q: should we start scanning from 
	;				;    UMB's
	;jz	short norm_alloc	; N: scan from arena_head
	;	
	;;cmp	word [umb_head],-1	; Q: Has umb_head been initialized
	;;je	short norm_alloc	; N: scan from arena_head
	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
	;jz	short norm_alloc	; N: scan from arena_head
	;
	;mov	ax,[umb_head]
	;mov	[start_arena],ax	; start_arena = umb_head
	;
					; M000 - end
;norm_alloc:
        XOR     AX,AX
        MOV     DI,AX
	; 15/03/2018
        MOV     [SS:FirstArena],AX	; init the options
        MOV     [SS:BestArena],AX
        MOV     [SS:LastArena],AX
        PUSH    AX                      ; alloc_max <- 0
	; 04/08/2018
start_scan:
	; MSDOS 6.0
	;mov	ax,[SS:start_arena]	; M000: AX <- beginning of arena
	;
	MOV     AX,[SS:arena_head]	; AX <- beginning of arena
	CALL    check_signature         ; ES <- AX, carry set if error
        JC      SHORT alloc_err		; IF error THEN GOTO err

alloc_scan:
        PUSH    ES
        POP     DS                      ; DS <- ES
        CMP     [ARENA.OWNER],DI
        JZ      SHORT alloc_free	; IF current block is free THEN examine

alloc_next:
	; MSDOS 6.0			; M000 - start 
	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
	;jz	short norm_strat	; N: see if we reached last arena
	;
	;test	byte [AllocMethod],HIGH_FIRST
	;				; Q: is alloc strategy high_first
	;jz	short norm_strat	; N: see if we reached last arena
	;mov	ax,[start_arena]
	;cmp	ax,[arena_head]		; Q: did we start scan from 
					;    arena_head
	;jne	short norm_strat	; N: see if we reached last arena
	;mov	ax,ds			; ax = current block
	;cmp	ax,[umb_head]		; Q: check against umb_head 
	;jmp	short alloc_chk_end

;norm_strat:
	;cmp	byte [di],5Ah ; 'Z'
        CMP     BYTE [DI],arena_signature_end
                                        ; IF current block is last THEN
        JZ      SHORT alloc_end		;   GOTO end
        CALL    arena_next              ; AX, ES <- next block, Carry set if error
        JNC     SHORT alloc_scan	; IF no error THEN GOTO scan

alloc_err:
        POP     AX

alloc_trashed:
	;LeaveCrit critMem
	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0	
        ;error	error_arena_trashed
	;mov	al,7
	MOV	AL,error_arena_trashed
alloc_errj:
	JMP	SYS_RET_ERR

alloc_end:
        CMP	WORD [SS:FirstArena],0	; 15/03/2018
	JNZ     SHORT alloc_do_split

	; MSDOS 6.0
	;mov	ax,[arena_head]
	;cmp	ax,[start_arena]	; Q: started scanning from arena_head
	;je	short alloc_fail	; Y: not enough memory
	;				; N:
	;				; Q: is the alloc strat HIGH_ONLY
	;test 	byte [AllocMethod],HIGH_ONLY
	;jnz	short alloc_fail	; Y: return size of largest UMB
	;
	;mov	[start_arena],ax	; N: start scanning from arena_head
	;jmp	short start_scan
	;				; M000 - end

alloc_fail:
        ;invoke Get_User_Stack
        CALL	Get_User_Stack
	POP     BX
        ;MOV	[SI].user_BX,BX
	;MOV	[SI+2],BX
	mov	[SI+user_env.user_BX],bx
	;LeaveCrit critMem
	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
	;error	error_not_enough_memory
	;mov	al,8
	MOV	AL,error_not_enough_memory
	;jmp	short alloc_errj
	JMP	SYS_RET_ERR

alloc_free:
        CALL    Coalesce		; add following free block to current
        JC	SHORT alloc_err		; IF error THEN GOTO err
        MOV     CX,[ARENA.SIZE]
        POP     DX                      ; check for max found size
        CMP     CX,DX
        JNA     SHORT alloc_test
        MOV     DX,CX

alloc_test:
        PUSH    DX
        CMP     BX,CX                   ; IF BX > size of current block THEN
        JA      SHORT alloc_next	;   GOTO next

	; 15/03/2018
        CMP     WORD [SS:FirstArena],0
	JNZ	SHORT alloc_best
        MOV     [SS:FirstArena],DS	; save first one found	
alloc_best:
        CMP     WORD [SS:BestArena],0
        JZ      SHORT alloc_make_best	; initial best
        PUSH	ES
        MOV     ES,[SS:BestArena]
        CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
        POP	ES
        JBE     SHORT alloc_last
alloc_make_best:
        MOV     [SS:BestArena],DS	; assign best
alloc_last:
        MOV     [SS:LastArena],DS 	; assign last
        JMP     SHORT alloc_next
;
; split the block high
;
alloc_do_split_high:
        MOV     DS,[SS:LastArena]
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX
        MOV     DX,DS
        JE      SHORT alloc_set_owner	; sizes are equal, no split
        ADD     DX,CX                   ; point to next block
        MOV     ES,DX                   ; no decrement!
        DEC     CX
        XCHG    BX,CX                   ; bx has size of lower block
        JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
;
; we have scanned memory and have found all appropriate blocks
; check for the type of allocation desired; first and best are identical
; last must be split high
;
alloc_do_split:
	; 04/08/2018
	; MSDOS 6.0			; M000 - start
	;xor	cx,cx
	;mov	cl,[AllocMethod]
	;and	cx,STRAT_MASK		; mask off bit 7
	;cmp	cx,BEST_FIT		; Q; is the alloc strategy best_fit

	; 15/03/2018
        ;CMP     BYTE [SS:AllocMethod], 1
	; 04/08/2018
	CMP     BYTE [SS:AllocMethod],BEST_FIT
        JA      SHORT alloc_do_split_high
        MOV     DS,[SS:FirstArena]        
	JB      SHORT alloc_get_size
	MOV     DS,[SS:BestArena]

alloc_get_size:
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX                   ; get room left over
        MOV     AX,DS
        MOV     DX,AX                   ; save for owner setting
        JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
        ADD     AX,BX
        INC     AX                      ; remember the header
        MOV     ES,AX                   ; ES <- DS + BX (new header location)
        DEC     CX                      ; CX <- size of split block
alloc_set_sizes:
        MOV     [ARENA.SIZE],BX		; current size <- BX
        MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
	;mov	bl,4Dh ; 'M'
        MOV     BL,arena_signature_normal
        XCHG    BL,[DI]			; current signature <- 4D
        MOV     [ES:DI],BL		; new block sig <- old block sig
        MOV     [ES:ARENA.OWNER],DI

alloc_set_owner:
        MOV     DS,DX
        MOV     AX,[SS:CurrentPDB] ; 15/03/2018
        MOV     [ARENA.OWNER],AX
        MOV     AX,DS
        INC     AX
        POP     BX
	;LeaveCrit critMem
	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK


;	BREAK $SETBLOCK - change size of an allocated block (if possible)

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$SETBLOCK - Change size of an Alocated Block
;
;	Setblock changes the size of an allocated block.  First, we coalesce
;	any following free space onto this block; then we try to trim the
;	block down to the size requested.
;
;	Note that if the guy wants to grow the block but that growth fails,
;	we still go ahead and coalesce any trailing free blocks onto it.
;	Thus the maximum-size-possible value that we return has already
;	been allocated!  This is a bug, dare we fix it?  BUGBUG
;
;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
;		finish it's work.  FOr this reason we build the allocsf
;		structure on the frame, to make us compatible with $ALLOCs
;		code.
;
;	ENTRY	(es) = segment of old block
;		(bx) = newsize
;		(ah) = SETBLOCK
;
;	EXIT	'C' clear if OK
;		'C' set if error
;		  (ax) = error_invalid_block
;		       = error_arena_trashed
;		       = error_not_enough_memory
;		       = error_invalid_function
;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
;	USES	???? BUGBUG
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     BX,newsize
;           MOV     AH,setblock
;           INT     21h
;         if setblock fails for growing, BX will have the maximum
;         size possible
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;              = error_not_enough_memory
;              = error_invalid_function
;----------------------------------------------------------------------------

_$SETBLOCK:        
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit   critMem
	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0

	MOV     DI,ARENA.SIGNATURE
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JNC     SHORT setblock_grab

setblock_bad:
        JMP     alloc_trashed

setblock_grab:
        MOV     DS,AX
        CALL    Coalesce
        JC      SHORT setblock_bad
        MOV     CX,[ARENA.SIZE]
        PUSH    CX
        CMP     BX,CX
        JBE     SHORT alloc_get_size
        JMP     alloc_fail

;	BREAK $DEALLOC - free previously allocated piece of memory

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$DEALLOC - Free Heap Memory
;
;	ENTRY	(es) = address of item
;
;	EXIT	'C' clear of OK
;		'C' set if error
;		  (AX) = error_invalid_block
;	USES	???? BUGBUG

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $DEALLOC - free previously allocated piece of memory
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     AH,dealloc
;           INT     21h
;
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;---------------------------------------------------------------------------- 

_$DEALLOC:    
	; 04/08/2018 - Retro DOS v3.0
	;EnterCrit   critMem
	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0

	; MSDOS 6.0			; M016, M068 - Start
	;test	byte [DOS_FLAG],EXECA20OFF
					; Q: was the previous call an int 21
					;    exec call
	;jz	short deallocate	; N: continue
	;cmp	byte [A20OFF_COUNT], 0	; Q: is count 0
	;jne	short deallocate	; N: continue
	;mov	byte [A20OFF_COUNT], 1	; Y: set count to 1
;deallocate:				; M016, M068 - End
    
	MOV     DI,ARENA.SIGNATURE ; = 0
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JC      SHORT dealloc_err
        MOV     [ES:ARENA.OWNER],DI
	;LeaveCrit critMem
	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

dealloc_err:
	;LeaveCrit critMem
	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
        ;error	error_invalid_block
	;mov	al,9
	MOV	AL,error_invalid_block
	JMP	SYS_RET_ERR

;	BREAK $AllocOper - get/set allocation mechanism

; MSDOS 6.0
;----------------------------------------------------------------------------
;**	$AllocOper - Get/Set Allocation Mechanism
;
;	Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;	ENTRY	
;		(al) = 0
;		  Get allocation Strategy in (ax)
;
;		(al) = 1, (bx) = method = zw0000xy
;		  Set allocation strategy.
;		   w  = 1  => HIGH_ONLY
;		   z  = 1  => HIGH_FIRST
;		   xy = 00 => FIRST_FIT
;		      = 01 => BEST_FIT
;		      = 10 => LAST_FIT
;
;		(al) = 2
;		  Get UMB link state in (al)
;
;		(al) = 3
;		  Set UMB link state
;		   (bx) = 0 => Unlink UMBs
;		   (bx) = 1 => Link UMBs
;
;
;	EXIT	'C' clear if OK
;
;		 if (al) = 0
;		  (ax) = existing method
;		 if (al) = 1
;		  Sets allocation strategy
;		 if (al) = 2
;		  (al) = 0 => UMBs not linked
;		  (al) = 1 => UMBs linked in
;		 if (al) = 3
;		  Links/Unlinks the UMBs into DOS chain
;
;		'C' set if error
;		  AX = error_invalid_function
;
;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
;		    umbhead has'nt been initialized by sysinit and 'trashed
;		    arena' if an arena sig is damaged.
;----------------------------------------------------------------------------

; MSDOS 2.11 (& MSDOS 3.3)
;----------------------------------------------------------------------------
;SUBTTL $AllocOper - get/set allocation mechanism
;
;   Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;   Error return:
;           AX = error_invalid_function
;----------------------------------------------------------------------------

_$ALLOCOPER:
	; MSDOS 6.0
	;or	al, al
	;jz	short AllocGetStrat
	;cmp	al, 1
	;jz	short AllocSetStrat
	;cmp	al, 2
	;jz	short AllocGetLink
	;cmp	al, 3
	;jz	short AllocSetLink

	; 15/04/2018
	CMP     AL,1
        JB      SHORT AllocOperGet
        JZ      SHORT AllocOperSet

AllocOperError:
	; 04/08/2018 - Retro DOS v3.0
	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
	;mov	byte [ss:EXTERR_LOCUS],5
        MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
	;error	error_invalid_function
	;mov	al,1
	MOV	AL,error_invalid_function
AllocOperErrj:
	JMP	SYS_RET_ERR

;AllocArenaError:
	; MSDOS 6.0
	;MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
	;				; M009: Extended Error Locus
	;;error   error_arena_trashed	; M009:
	;MOV	AL,error_arena_trashed
	;;JMP	SYS_RET_ERR
	;jmp	short AllocOperErrj

;AllocGetStrat: 
	; MSDOS 6.0
AllocOperGet:
        MOV     AL,[SS:AllocMethod]
        XOR     AH,AH
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;AllocSetStrat: 
	; MSDOS 6.0
	;push	bx			; M000 - start
	;and	bx,STRAT_MASK 		; M064: mask off bit 6 & 7
	;cmp	bx,2			; BX must be 0-2
	;pop	bx			; M000 - end
	;ja	short AllocOperError

AllocOperSet:
        MOV     [SS:AllocMethod],BL
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;AllocGetLink:
	; MSDOS 6.0
	;mov	al,[UmbFlag]		; return link state in al
	;and 	al,LINKSTATE		
	;;transfer SYS_RET_OK
	;jmp	SYS_RET_OK

;AllocSetLink:
	; MSDOS 6.0			; M009 - start
	;mov	cx,[umb_head]		; cx = umb_head
	;cmp	cx,0FFFFh		; Q: has umb_head been initialized
	;je	short AllocOperError	; N: error
	;				; Y: continue
	;				; M009 - end
	;cmp	bx,1			
	;jb	short UnlinkUmbs
	;jz	short LinkUmbs
	;
	;jmp	short AllocOperError
	;
;UnlinkUmbs:
	;test	byte[UmbFlag],LINKSTATE	; Q: umbs unlinked?
	;jz	short unlinked		; Y: return 
	;
	;call	GetLastArena		; get arena before umb_head in DS
	;jc	short AllocArenaError	; M009: arena trashed
	;
	;				; make it last
	;mov	byte [0],arena_signature_end
	;
	;and	byte [UmbFlag],~LINKSTATE ; indicate unlink'd state in umbflag
	;
;unlinked:
	;;transfer SYS_RET_OK
	;jmp	SYS_RET_OK

;LinkUmbs:
	;test	byte [UmbFlag],LINKSTATE ; Q: umbs linked?
	;jnz	short linked		; Y: return
	;
	;call	GetLastArena		; get arena before umb_head
	;jc	short AllocArenaError	; M009: arena trashed
	;
	;				; make it normal. M061: ds points to
	;				; arena before umb_head
	;mov	byte [0],arena_signature_normal
	;
	;or	byte [UmbFlag],LINKSTATE ; indicate link'd state in umbflag
;linked:
	;;transfer SYS_RET_OK
	;jmp	SYS_RET_OK

; MSDOS 6.0
;--------------------------------------------------------------------------
; Procedure Name : GetLastArena		-  M003
;
; Inputs	 : cx = umb_head
;
;
; Outputs	 : If UMBs are linked
;			ES = umb_head
;			DS = arena before umb_head
;		   else
;			DS = last arena
;			ES = next arena. will be umb_head if NC.
;
;		   CY if error
;
; Uses		 : DS, ES, DI, BX
;--------------------------------------------------------------------------
	
;Procedure	GetLastArena, NEAR
;
;	push	ax			; save ax
;
;	mov	ax, [arena_head]
;	mov	es, ax			; es = arena_head
;	xor	di, di
;
;	cmp     byte ptr es:[di],arena_signature_end
;					; Q: is this the last arena
;	je	GLA_done		; Y: return last arena in ES		
;					
;
;GLA_next:
;	mov	ds, ax
;	call	arena_next		; ax, es -> next arena
;	jc	GLA_err
;
;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
;	jnz	GLA_chkumb		; Y: terminating condition is 
;					;    umb_head
;					; N: terminating condition is 05Ah
;
;	cmp     byte ptr es:[di],arena_signature_end
;					; Q: is this the last arena
;	jmp	short @f
;GLA_chkumb:
;	cmp	ax, cx			; Q: is this umb_head
;@@:
;	jne	GLA_next		; N: get next arena
;
;GLA_done:
;					; M061 - Start
;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
;	jnz	GLA_ret			; Y: we're done
;					; N: let us confirm that the next 
;					;    arena is umb_head
;	mov	ds, ax
;	call	arena_next		; ax, es -> next arena
;	jc	GLA_err
;	cmp	ax, cx			; Q: is this umb_head
;	jne	GLA_err			; N: error
;					; M061 - End
;
;GLA_ret:				
;	clc
;	pop	ax			; M061
;	ret				; M061
;
;GLA_err:
;	stc				; M061
;	pop	ax
;	ret
;
;EndProc GetLastArena

;============================================================================
; SRVCALL.ASM, MSDOS 6.0, 1991
;============================================================================
; 04/08/2018 - Retro DOS v3.0

;	TITLE SRVCALL - Server DOS call
;	NAME  SRVCALL

;**	SRVCALL.ASM - Server DOS call functions
;
;
;	$ServerCall
;
;	Modification history:
;
;	    Created: ARR 08 August 1983

;AsmVars <Installed>

;include dpl.asm

;Installed = TRUE

;BREAK <ServerCall -- Server DOS call>
;----------------------------------------------------------------------------
;
; Procedure Name : $ServerCall
;
; Inputs:
;	DS:DX -> DPL  (except calls 7,8,9)
; Function:
;	AL=0	Server DOS call
;	AL=1	Commit All files
;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
;	AL=3	Close all files for DPL_UID
;	AL=4	Close all files for DPL_UID/PID_PID
;	AL=5	Get open file list entry
;		    IN: BX File Index
;			CX User Index
;		    OUT:ES:DI -> Name
;			BX = UID
;		    CX = # locked blocks held by this UID
;	AL=6	Get DOS data area
;		    OUT: DS:SI -> Start
;			CX size in bytes of swap if indos
;			DX size in bytes of swap always
;	AL=7	Get truncate flag
;	AL=8	Set truncate flag
;	AL=9	Close all spool files
;	AL=10	SetExtendedError
;
;----------------------------------------------------------------------------

_$ServerCall:
	; 05/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
	CMP	AL,7
	JB	short SET_STUFF
	CMP	AL,9
	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
SET_STUFF:
	MOV	SI,DX			; Point to DPL with DS:SI
	;mov	bx,[si+12h]
	MOV	BX,[SI+DPL.UID]

	; MSDOS 6.0
;SR;
; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
; of USER_ID
;
	;test	byte [SS:IsWin386],1
	;jnz	short skip_win386

;hkn; SS override for user_id and proc_id
	; 15/08/2018
	MOV	[SS:USER_ID],BX		; Set UID

;skip_win386:

	MOV	BX,[SI+DPL.PID]
	MOV	[SS:PROC_ID],BX		; Set process ID
NO_SET_ID:
	PUSH	word [SS:SERVERLEAVE]	; push return address
	PUSH	word [SS:SERVERTAB]	; push table address
	PUSH	AX
	call	TableDispatch

;hkn; SS override
	;mov 	byte [SS:EXETERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
	;error	error_invalid_function
	;mov	al,1
	MOV	AL,error_invalid_function
servercall_error:
	JMP	SYS_RET_ERR

SERVERRETURN:
	retn

; Commit - iterate through the open file list and make sure that the
; directory entries are correctly updated.

COMMIT_ALL:
	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
	push	ss
	pop	ds
	call	EcritSFT		; Gonna scan SFT cache, lock it down
CommitLoop:
	push	bx
	call	SFFromSFN
	JC	short CommitDone
	cmp	word [es:di],0
	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
					; if (ThisSFT->refcount != 0)
	JZ	short CommitNext
	;cmp	word [es:di],0FFFFh ; -1
	cmp	word [ES:DI],sf_busy
	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
					; BUSY SFTs have god knows what
	JZ	short CommitNext	;   in them.
	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
					;	doesn't deadlock
	MOV	[THISSFT],DI
	MOV	[THISSFT+2],ES
	call	DOS_COMMIT		;	DOSCommit ();
CommitNext:
	pop	bx
	INC	BX
	JMP	short CommitLoop
CommitDone:
	call	LcritSFT
	pop	bx
	jmp	SYS_RET_OK

CLOSE_NAME:

;if installed

;hkn; SS override
	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
;else
;	Call	MFTcloN
;endif

CheckReturns:
	JC	short func_err
	jmp	SYS_RET_OK
func_err:
	;transfer SYS_RET_ERR
	;jmp	SYS_RET_ERR
	jmp	short servercall_error

CLOSE_UID:

;if installed
;hkn; SS override
	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
;else
;	Call	MFTclU
;endif
	JMP	short CheckReturns

CLOSE_UID_PID:

;if installed
;hkn; SS override
	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
;else
;	Call	MFTCloseP
;endif
	JMP	CheckReturns

GET_LIST:

;if installed
;hkn; SS override
	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
;else
;	Call	MFT_get
;endif
	JC	short func_err
	call	Get_User_Stack
	;mov	[si+2],bx
	MOV	[SI+user_env.user_BX],BX
	;mov	[si+10],di
	MOV	[SI+user_env.user_DI],DI
	;mov	[si+16],es
	MOV	[SI+user_env.user_ES],ES
SetCXOK:
	;mov	[si+4],cx
	MOV	[SI+user_env.user_CX],CX
	jmp	SYS_RET_OK

SRV_CALL:
	POP	AX			; get rid of call to $srvcall
	push	ds
	push	si
	call	Get_User_Stack
	pop	di
	pop	es
;
; DS:SI point to stack
; ES:DI point to DPL
;
	call	XCHGP
;
; DS:SI point to DPL
; ES:DI point to stack
;
; We now copy the registers from DPL to save stack
;
	push	si
	MOV	CX,6
	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
	INC	DI
	INC	DI			; Skip user_BP
	MOVSW				; DS
	MOVSW				; ES
	pop	si			; DS:SI -> DPL
	mov	ax,[SI]
	;MOV	AX,[SI+DPL.AX]
	;mov	bx,[si+2]
	MOV	BX,[SI+DPL.BX]
	;mov	cx,[si+4]
	MOV	CX,[SI+DPL.CX]
	;mov	dx,[si+6]
	MOV	DX,[SI+DPL.DX]
	;mov	di,[si+10]
	MOV	DI,[SI+DPL.DI]
	;mov	es,[si+14]
	MOV	ES,[SI+DPL.ES]
	;push	word [si+8]
	PUSH	word [SI+DPL.SI]
	;mov	ds,[si+12]
	MOV	DS,[SI+DPL.DS]
	POP	SI

;hkn; SS override for next 3
	MOV	[SS:SAVEDS],DS
	MOV	[SS:SAVEBX],BX
	MOV	byte [SS:FSHARING],-1	; set no redirect flag
	jmp	REDISP

GET_DOS_DATA:
	push	ss
	pop	es
	MOV     DI,SWAP_START
	MOV     CX,SWAP_END
	MOV     DX,SWAP_ALWAYS
	SUB     CX,DI
	SUB     DX,DI
	SHR     CX,1                    ; div by 2, remainder in carry
	ADC     CX,0                    ; div by 2 + round up
	SHL     CX,1                    ; round up to 2 boundary.
	call	Get_User_Stack
	;mov	[si+14],es
	MOV     [SI+user_env.user_DS],ES
	;mov	[si+8],di
	MOV     [SI+user_env.user_SI],DI
	;mov	[si+6],dx
	MOV     [SI+user_env.user_DX],DX
	JMP	short SetCXOK

SPOOL_OPER:
	;CallInstall NETSpoolOper,MultNET,37,AX,BX

	push    ax
	mov     ax, 1125h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
			; STACK: WORD subfunction
			; Return: CF set on error, AX = error code
			; STACK unchanged
	pop	bx
	JC	short func_err2
	jmp	SYS_RET_OK
func_err2:
	jmp	SYS_RET_ERR

;Break	<$SetExtendedError - set extended error for later retrieval>
;--------------------------------------------------------------------------
;
; Procedure Name : $SetExtendedError
;
; $SetExtendedError takes extended error information and loads it up for the
; next extended error call.  This is used by interrupt-level proccessors to
; mask their actions.
;
;   Inputs: DS:SI points to DPL which contains all registers
;   Outputs: none
;
;---------------------------------------------------------------------------

_$SetExtendedError:

;hkn; SS override for all variables used

	mov	ax,[si]
	;MOV	AX,[SI+DPL.AX]
	MOV	[SS:EXTERR],AX
	;mov	ax,[si+10]
	MOV	AX,[SI+DPL.DI]
	MOV	[SS:EXTERRPT],AX
	;mov	ax,[si+14]
	MOV	AX,[SI+DPL.ES]
	MOV	[SS:EXTERRPT+2],AX
	;mov	ax,[si+2]
	MOV	AX,[SI+DPL.BX]
	MOV	[SS:EXTERR_ACTION],AX
	;mov	ax,[si+4]
	MOV	AX,[SI+DPL.CX]
	MOV	[SS:EXTERR_LOCUS],AH
	retn

;============================================================================
; UTIL.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/08/2018 - Retro DOS v3.0

;**	Handle related utilities for MSDOS 2.X.
;
;	pJFNFromHandle	written
;	SFFromHandle	written
;	SFFromSFN	written
;	JFNFree 	written
;	SFNFree 	written
;
;	Modification history:
;
;	    Created: MZ 1 April 1983

;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>

;**	pJFNFromHandle - Translate Handle to Pointer to JFN
;----------------------------------------------------------------------------
;	pJFNFromHandle takes a file handle and turns that into a pointer to
;	the JFN entry (i.e., to a byte holding the internal file handle #)
;
;	NOTE:
;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;	  at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	(bx) = handle
;	EXIT	'C' clear if ok
;		  (es:di) = address of JFN value
;		'C' set if error
;		  (ax) = error code
;	USES	AX, DI, ES, Flags
;----------------------------------------------------------------------------

pJFNFromHandle:

	MOV	ES,[cs:CurrentPDB]	; get user process data block
	;cmp	bx,[ES:32h]
	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
	JB	short pjfn10		; no, get offset
ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
	;mov	al,6
	MOV     AL,error_invalid_handle ; appropriate error
ReturnCarry:
	STC                             ; signal error
	retn				; go back
pjfn10: 
	;les	di,[es:34h]
	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
	ADD	DI,BX			; add in offset, clear 'C'
	;clc
pJFNFromHandle_error:
	retn

;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
;----------------------------------------------------------------------------
;
; Procedure Name : SFFromHandle
;
; SFFromHandle - Given a handle, get JFN and then index into SF table
;
;   Input:      BX has handle
;   Output:     Carry Set
;                   AX has error code
;               Carry Reset
;                   ES:DI has pointer to SF entry
;   Registers modified: If error, AX,ES, else ES:DI
; NOTE:
;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;----------------------------------------------------------------------------

SFFromHandle:
	CALL    pJFNFromHandle          ; get jfn pointer
	;retc				; return if error
	jc	short pJFNFromHandle_error
	CMP     BYTE [ES:DI],-1		; unused handle
	;JNZ	short GetSF		; nope, suck out SF
	;;mov	al,6
	;MOV	AL,error_invalid_handle ; appropriate error
	;jmp	short ReturnCarry	; signal it
	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
GetSF:
	push	bx			; save handle
	MOV     BL,[ES:DI]		; get SFN
	XOR     BH,BH                   ; ignore upper half
	CALL    SFFromSFN               ; get real sf spot
	pop	bx			; restore
	retn                          ; say goodbye

;BREAK <SFFromSFN - index into SF table for SFN>

;**	SFFromSFN - Get an SF Table entry from an SFN
;----------------------------------------------------------------------------
;	SFFromSfn uses an SFN to index an entry into the SF table.  This
;	is more than just a simple index instruction because the SF table
;	can be made up of multiple pieces chained together. We follow the
;	chain to the right piece and then do the index operation.
;
;   NOTE:
;	This routine is called from SFFromHandle which is called
;       at DOSINIT time with SS NOT DOSGROUP
;
;	ENTRY	BX has SF index
;	EXIT	'C' clear if OK
;		  ES:DI points to SF entry
;		'C' set if index too large
;	USES	BX, DI, ES
;----------------------------------------------------------------------------

SFFromSFN:
	LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
sfsfn5:	
	;cmp	bx,[es:di+4]
	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
	JB	short sfsfn7		; yes, go grab it
	;sub	bx,[es:di+4]
	SUB     BX,[ES:DI+SFT.SFCount]
	les	di,[es:di] ; 14/08/2018
	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
	CMP     DI,-1                   ; end of tables?
	JNZ	short sfsfn5		; no, try again
	STC
	retn				; return with error, not found

sfsfn7:
	push	ax
	;mov	ax,53
	MOV     AX,SF_ENTRY.size	; put it in a nice place
	MUL	BL			; (ax) = offset into this SF block
	ADD	DI,AX			; add base of SF block
	pop	ax
	;add	di,6
	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
	retn				; return with 'C' clear

;	BREAK <JFNFree - return a jfn pointer if one is free>

;**	JFNFree - Find a Free JFN Slot
;----------------------------------------------------------------------------
;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if OK
;		  (bx) = new handle
;		  (es:di) = pointer to JFN slot
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, flags
;----------------------------------------------------------------------------

JFNFree:
	XOR	BX,BX			; (bx) = initial JFN to try
jfnf1:	
	CALL	pJFNFromHandle		; get the appropriate handle
	JC	short jfnf5		; no more handles
	CMP     BYTE [ES:DI],-1		; free?
	je	short jfnfx		; yes, carry is clear
	INC     BX                      ; no, next handle
	JMP	short jfnf1		; and try again

;	Error.	'C' set
jfnf5:	
	;mov	al,4
	MOV	AL,error_too_many_open_files
jfnfx:	
	retn				; bye

;	BREAK <SFNFree - Allocate a free SFN>

;**	SFNFree - Allocate a Free SFN/SFT
;----------------------------------------------------------------------------
;	SFNFree scans through the sf table looking for a free entry
;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
;
;	The problem is that we want to mark the SFT busy so that other threads
;	can't allocate the SFT before we're finished marking it up.  However,
;	we can't just mark it busy because we may get blown out of our open
;	by INT24 and leave the thing orphaned.	To solve this we mark it
;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
;	an SFT with this value we look to see if it belongs to this user
;	and process.  If it does belong to us then it must be an orphan
;	and we reclaim it.
;
;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
;		over and over, but we could at least set a high water mark...
;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
;		even though this is not a frequently called routine - jgl
;
;	ENTRY	(ss) = DOSDATA
;	EXIT	'C' clear if no error
;		  (bx) = SFN
;		  (es:di) = pointer to SFT
;		  es:[di].SFT_REF_COUNT = -1
;		'C' set if error
;		  (al) = error code
;	USES	bx, di, es, Flags
;----------------------------------------------------------------------------

SFNFree:
	;12/08/2018
	;05/08/2018 - Retro DOS v3.0
	; MSDOS 6.0
	push	ax
	xor	bx,bx			; (bx) = SFN to consider
sfnf5:	
	push	bx
	call	SFFromSFN		; get the potential handle
	pop	bx
	jc	short sfnf95		; no more free SFNs
	cmp	word [ES:DI],0
	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
	je	short sfnf20			; yep, got one
	
	;cmp	word [es:di],0FFFFh ; -1
	cmp	word [ES:DI],sf_busy
	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
	je	short sfnf10		; special busy mark
sfnf7:	
	inc	bx			; try the next one
	jmp	short sfnf5

;	The SFT has the special "busy" mark; if it belongs to us then
;	it was abandoned during a earlier call and we can use it.
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf10:	
	mov	ax,[SS:USER_ID]
	;cmp	[es:di+2Fh],ax
	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
	jnz	short sfnf7		; not ours
	mov	ax,[SS:PROC_ID]
	;cmp	[es:di+31h],ax
	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
	jnz	short sfnf7		; can't use this one, try the next

;	We have an SFT to allocate
;
;	(bx)	= SFN
;	(es:di) = pointer to SFT
;	(TOS)	= caller's (ax)

sfnf20:
	; cf = 0 ;; Retro DOS v3.0

	;mov	word [es:di],0FFFFh
	mov	word [ES:DI],sf_busy
					; make sure that this is allocated
	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy

	mov	ax,[SS:USER_ID]
	;mov	[es:di+2Fh],ax
	mov	[ES:DI+SF_ENTRY.sf_UID],ax
	mov	ax,[SS:PROC_ID]
	;mov	[es:di+31h],ax
	mov	[es:DI+SF_ENTRY.sf_PID],ax
sfnf21: ;; Retro DOS v3.0
	pop	ax
	;clc
	retn				; return with no error

;**	Error - no more free SFNs
;
;	'C' set
;	(TOS) = saved ax

sfnf95: 
	pop	ax
	;mov	al,4
	mov	al,error_too_many_open_files
	retn				; return with 'C' and error

;============================================================================
; MACRO.ASM, MSDOS 6.0, 1991
;============================================================================
; Retro	DOS v3.0 - 11/07/2018

;	TITLE	MACRO - Pathname and macro related internal routines
;	NAME	MACRO

;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.

;**	MACRO.ASM
;
;	$AssignOper
;	FIND_DPB
;	InitCDS
;	$UserOper
;	GetVisDrv
;	GetThisDrv
;	GetCDSFromDrv
;
;   Revision history:
;
;	Created: MZ 4 April 1983
;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
;		 AR 2 June 1983     Define/Delete macro for NET redir.
;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
;		 MZ 18 Nov 83	    Rewrite string processing for subtree
;				    aliasing.
;
;   MSDOS performs several types of name translation. First, we maintain for
;   each valid drive letter the text of the current directory on that drive.
;   For invalid drive letters, there is no current directory so we pretend to
;   be at the root. A current directory is either the raw local directory
;   (consisting of drive:\path) or a local network directory (consisting of
;   \\machine\path. There is a limit on the point to which a .. is allowed.
;
;   Given a path, MSDOS will transform this into a real from-the-root path
;   without . or .. entries. Any component that is > 8.3 is truncated to
;   this and all * are expanded into ?'s.
;
;   The second part of name translation involves subtree aliasing. A list of
;   subtree pairs is maintained by the external utility SUBST. The results of
;   the previous 'canonicalization' are then examined to see if any of the
;   subtree pairs is a prefix of the user path. If so, then this prefix is
;   replaced with the other subtree in the pair.
;
;   A third part involves mapping this "real" path into a "physical" path.  A
;   list of drive/subtree pairs are maintained by the external utility JOIN.
;   The output of the previous translation is examined to see if any of the
;   subtrees in this list are a prefix of the string. If so, then the prefix
;   is replaced by the appropriate drive letter. In this manner, we can
;   'mount' one device under another.
;
;   The final form of name translation involves the mapping of a user's
;   logical drive number into the internal physical drive. This is
;   accomplished by converting the drive number into letter:CON, performing
;   the above translation and then converting the character back into a drive
;   number.
;
;   There are two main entry points: TransPath and TransFCB. TransPath will
;   take a path and form the real text of the pathname with all . and ..
;   removed. TransFCB will translate an FCB into a path and then invoke
;   TransPath.
;
;	A000	version 4.00  Jan. 1988

;Installed = TRUE

;	I_need	ThisCDS,DWORD		; pointer to CDS used
;	I_need	CDSAddr,DWORD		; pointer to CDS table
;	I_need	CDSCount,BYTE		; number of CDS entries
;	I_need	CurDrv,BYTE		; current macro assignment (old
;					; current drive)
;	I_need	NUMIO,BYTE		; Number of physical drives
;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
;	I_need	DummyCDS,80h		; buffer for dummy cds
;	I_need	DIFFNAM,BYTE		; flag for MyName being set
;	I_need	MYNAME,16		; machine name
;	I_need	MYNUM,WORD		; machine number
;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
;	I_need	DrvErr,BYTE		; drive error

;BREAK <$AssignOper -- Set up a Macro>
;----------------------------------------------------------------------------
; Inputs:
;	AL = 00 get assign mode 		    (ReturnMode)
;	AL = 01 set assign mode 		    (SetMode)
;	AL = 02 get attach list entry		    (GetAsgList)
;	AL = 03 Define Macro (attch start)
;	    BL = Macro type
;	       = 0 alias
;	       = 1 file/device
;	       = 2 drive
;	       = 3 Char device -> network
;	       = 4 File device -> network
;	    DS:SI -> ASCIZ source name
;	    ES:DI -> ASCIZ destination name
;	AL = 04 Cancel Macro
;	    DS:SI -> ASCIZ source name
;	AL = 05 Modified get attach list entry
;	AL = 06 Get ifsfunc item
;	AL = 07 set in_use of a drive's CDS
;	     DL = drive number, 0=default  0=A,,
;	AL = 08 reset in_use of a drive's CDS
;	     DL = drive number, 0=A, 1=B,,,
; Function:
;	Do macro stuff
; Returns:
;	Std Xenix style error return
;----------------------------------------------------------------------------

_$AssignOper:
	; MSDOS 6.0
	;CMP	AL,7			      ; set in_use ?		;AN000;
	;JNZ	short chk08		      ; no			;AN000;
;srinuse:								;AN000;
	;PUSH	AX			      ; save al 		;AN000;
	;MOV	AL,DL			      ; AL= drive id		;AN000;
	;CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
	;POP	AX			      ; 			;AN000;
	;JC	short baddrv		      ; bad drive		;AN000;
	;CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
	;JZ	short baddrv		      ;     no			;AN000;
	;CMP	AL,7			      ; set ?			;AN000;
	;JNZ	short resetdrv		      ; no			;AN000;
	;OR	word [SI+curdir.flags],curdir_inuse; set in_use		;AN000;
	;JMP	SHORT okdone		      ; 			;AN000;
;resetdrv:								;AN000;
	;AND	word [SI+curdir_flags],~curdir_inuse ; reset in_use	;AN000;
	;JMP	SHORT okdone			; 			;AN000;
;baddrv: 								;AN000;
	;MOV	AX,error_invalid_drive	      ; error			;AN000;
	;JMP	SHORT ASS_ERR		      ; 			;AN000;
;chk08:									;AN000;
	;CMP	AL,8			      ; reset inuse ?		;AN000;
	;JZ	short srinuse 		      ; yes			;AN000;

	;IF	NOT INSTALLED
	;transfer NET_ASSOPER
	;ELSE

	; MSDOS 3.3 (& MSDOS 6.0)
	PUSH	AX
	;mov	ax,111Eh
	;MOV	AX,(MultNET SHL 8) OR 30
	mov	ax,(MultNET*256)+30
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
			; SS = DOS CS
			; STACK: WORD function to execute
			; Return: CF set on error, AX = error code
			; STACK unchanged
	POP	BX			; Don't zap error code in AX
	JC	short ASS_ERR
okdone:
	jmp	SYS_RET_OK

ASS_ERR:
	jmp	SYS_RET_ERR

	;ENDIF

;Break <FIND_DPB - Find a DPB from a drive number>
;----------------------------------------------------------------------------
;**	FIND_DPB - Find a DPB from a Drive #
;
;	ENTRY	AL has drive number A = 0
;	EXIT	'C' set
;		    No DPB for this drive number
;		'C' clear
;		    DS:SI points to DPB for drive
;	USES	SI, DS, Flags
;----------------------------------------------------------------------------

FIND_DPB:
	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
fdpb5:	
	CMP	SI,-1
	JZ	short fdpb10
	cmp	al,[si]
	;CMP	AL,[SI+DPB.DRIVE]
	jz	short ret_label15	; Carry clear (retz)
	;lds	si,[si+18h]
	LDS	SI,[SI+DPB.NEXT_DPB]
	JMP	short fdpb5

fdpb10:	
	STC

ret_label15:
	retn

;	Break <InitCDS - set up an empty CDS>
;----------------------------------------------------------------------------
;**	InitCDS - Setup an Empty CDS
;
;	ENTRY	ThisCDS points to CDS
;		AL has uppercase drive letter
;	EXIT	ThisCDS is now empty
;		(ES:DI) = CDS
;		'C' set if no DPB associated with drive
;	USES	AH,ES,DI, Flags
;----------------------------------------------------------------------------

InitCDS:
	; 19/08/2018
	; 05/08/2018 - Retro DOS v3.0
	; MSDOS 6.0
	push	ax			; save (AL) for caller
	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
	;mov	word [es:di+67],0
	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
	SUB	AL,"A"-1                ; A = 1
	CMP	[SS:NUMIO],AL		;smr;SS Override
	JC	short icdsx		; Drive does not map a physical drive
	dec	ax			; (AL) = 0 if A, 1 if B, etc.
	PUSH	AX			; save drive number for later
	add	al,"A"
	MOV	AH,':'
	mov	[ES:DI],ax
	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
	;mov	ax,"\"
	;mov	[es:di+2],ax
	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
	;or	word [es:di+67],4000h
	;or	byte [es:di+68],40h
	OR	byte [ES:DI+curdir.flags+1],curdir_inuse>>8
	sub	ax,ax
	;MOV	[es:di+73],ax ; 0
	MOV	[ES:DI+curdir.ID],ax
	;mov	[es:di+75],ax ; 0
	MOV	[ES:DI+curdir.ID+2],ax
	mov	al,2
	;mov	[es:di+79],aX ; 2
	MOV	[ES:DI+curdir.end],ax
	POP	AX			; (al) = drive number
	push	ds
	push	si
	call	FIND_DPB
	JC	short icds5		; OOOOPPPPPSSSS!!!!
	;mov	[es:di+69],si
	MOV	[ES:DI+curdir.devptr],SI
	;mov	[es:di+71],ds
	MOV	[ES:DI+curdir.devptr+2],DS
icds5:	
	pop	si
	pop	ds
icdsx:	
	pop	ax
RET45:
	retn

;Break <$UserOper - get/set current user ID (for net)>
;----------------------------------------------------------------------------
;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
;	maintain this string and do no verifications.
;
;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
;				      4-printer-set-flags,5-printer-get-flags)
;		DS:DX is user string pointer (calls 1,2)
;		ES:DI is user buffer (call 3)
;		BX is assign index (calls 2,3,4,5)
;		CX is user number (call 1)
;		DX is flag word (call 4)
;   Outputs:	If AL = 0 then the current user string is written to DS:DX
;			and user CX is set to the user number
;		If AL = 3 then CX bytes have been put at input ES:DI
;		If AL = 5 then DX is flag word
;----------------------------------------------------------------------------

_$UserOper:
	; 05/08/2018 - Retro DOS v3.0
	; MSDOS 6.0 (& MSDOS 3.3)
	PUSH	AX
	SUB	AL,1			; quick dispatch on 0,1
	POP	AX
	JB	short UserGet 		; return to user the string
	JZ	short UserSet 		; set the current user
	CMP	AL,5			; test for 2,3,4 or 5
	JBE	short UserPrint		; yep
	;mov	byte [ss:EXTERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
					; Extended Error Locus
	;error	error_invalid_function	; not 0,1,2,3
	;mov	al,1
	MOV	AL,error_invalid_function
useroper_error:
	JMP	SYS_RET_ERR

UserGet:
; Transfer MYNAME to DS:DX
; Set Return CX to MYNUM
	PUSH	DS			; switch registers
	POP	ES
	MOV	DI,DX			; destination
	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
	call	Get_User_Stack
	MOV	[SI+user_env.user_CX],CX ; Set number return
	push	ss			; point to DOSDATA
	pop	ds
	MOV	SI,MYNAME		; point source to user string
UserMove:
	MOV	CX,15
	REP	MOVSB			; blam.
	XOR	AX,AX			; 16th byte is 0
	STOSB
UserBye:
	jmp	SYS_RET_OK		; no errors here

UserSet:
; Transfer DS:DX to MYNAME
; CX to MYNUM
	MOV	[SS:MYNUM],CX				;smr;SS Override
	MOV	SI,DX			; user space has source
	push	ss
	pop	es
	MOV	DI,MYNAME		; point dest to user string
	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
	JMP	short UserMove

UserPrint:

;IF NOT Installed
;	transfer PRINTER_GETSET_STRING
;ELSE
	PUSH	AX
	;mov	ax,111Fh
	;MOV	AX,(MultNET SHL 8) OR 31
	mov	ax,(MultNET<<8)|31
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
			; STACK: WORD function
			; Return: CF set on error, AX = error code
			; STACK unchanged
	POP	DX			; Clean stack
	JNC	short OKPA
	jmp	short useroper_error
OKPA:
	jmp	short UserBye
;ENDIF


;Break	<GetVisDrv - return visible drive>
;----------------------------------------------------------------------------
;   GetVisDrv - correctly map non-spliced inuse drives
;
;   Inputs:	AL has drive identifier (0=default)
;   Outputs:	Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		    ThisCDS points to CDS
;   Registers modified: AL
;----------------------------------------------------------------------------

GetVisDrv:
	; 05/08/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
	CALL	GETTHISDRV		; get inuse drive
	jc	short RET45
	push	ds
	push	si
	LDS	SI,[SS:THISCDS]			;smr;SS Override
	;test	word [si+67],2000h
	TEST	word [SI+curdir.flags],curdir_splice
	pop	si
	pop	ds
	jz	short RET45		; if not spliced, return OK
	; MSDOS 6.0
	;MOV	[SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
	;
	STC				; signal error
	retn

;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
;----------------------------------------------------------------------------
;   GetThisDrv - look through a set of macros and return the current drive and
;	macro pointer
;
;   Inputs:	AL has drive identifier (1=A, 0=default)
;   Outputs:
;		Carry Set - invalid drive/macro
;		Carry Clear - AL has physical drive (0=A)
;		   ThisCDS points to macro
;   Registers modified: AL
;----------------------------------------------------------------------------

GETTHISDRV:
	; 05/08/2018
	; 12/07/2018 - Retro DOS v3.0
	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
	; MSDOS 3.3 (& MSDOS 6.0)
	OR	AL,AL			; are we using default drive?
	JNZ	SHORT GTD10		; no, go get the CDS pointers
	MOV	AL,[SS:CURDRV]		; get the current drive
	;INC	ax			; Counteract next instruction
	; 04/09/2018
	inc	al
GTD10:	
	;DEC	ax			; 0 = A
	dec	al
	PUSH	DS			; save world
	PUSH	SI
	;mov	byte [ss:EXTERR_LOCUS],2
	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
	JZ	SHORT GTD20		; Logical
	PUSH	AX
	PUSH	ES
	PUSH	DI
	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
	mov	[SS:THISCDS+2],CS ; MSDOS 3.3
	;MOV	[SS:THISCDS+2],SS	;ThisCDS = &DummyCDS;smr;
	ADD	AL,'A'
	CALL	InitCDS			;	InitCDS(c);
	;test	word [es:di+67],4000h
	TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
	POP	DI
	POP	ES
	POP	AX
	JZ	SHORT GTD30		; Not a physical drive.
	JMP	SHORT GTDX		; carry clear
GTD20:
	CALL	GetCDSFromDrv
	JC	SHORT GTD30	; Unassigned CDS -> return error already set
	;test	word [si+43h],4000h
	TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
	JNZ	SHORT GTDX		; carry clear
GTD30:	
	; 14/08/2018
	;MOV	AL,error_invalid_drive	; invalid FAT drive
	;MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
	STC
GTDX:	
	POP	SI			; restore world
	POP	DS
	RETN
 

;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
;----------------------------------------------------------------------------
;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
;	pointer, returning an error if the drive number is greater than the
;	number of CDS's
;
;   Inputs:	AL is physical unit # A=0...
;   Outputs:	Carry Set if Bad Drive
;		Carry Clear
;		    DS:SI -> CDS
;		    [THISCDS] = DS:SI
;   Registers modified: DS,SI
;----------------------------------------------------------------------------

GetCDSFromDrv:
	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
	JB	SHORT GetCDS		; yes, go get the macro
	STC				; signal error
	RETN				; bye
GetCDS:
	PUSH	BX
	PUSH	AX
	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
	;mov	bl,81
	MOV	BL,curdir.size		; size in convenient spot
	MUL	BL			; get net offset
	ADD	SI,AX			; convert to true pointer
	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
	POP	AX
	POP	BX
	CLC				; no error
	RETN				; bye!

;============================================================================
; MACRO2.ASM, MSDOS 6.0, 1991
;============================================================================
; Retro	DOS v3.0 - 12/07/2018

;BREAK <TransFCB - convert an FCB into a path, doing substitution>
;----------------------------------------------------------------------------
;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
;       gritty substitution.
;
;   Inputs:     DS:DX - pointer to FCB
;               ES:DI - point to destination
;   Outputs:    Carry Set - invalid path in final map
;               Carry Clear - FCB has been mapped into ES:DI
;                   Sattrib is set from possibly extended FCB
;                   ExtFCB set if extended FCB found
;   Registers modified: most
;----------------------------------------------------------------------------

TransFCB:
	; 12/07/2018 - Retro DOS v3.0
	;LocalVar FCBTmp,16
	;ENTER
	push	bp
	mov	bp,sp
	;sub	sp,15	; MSDOS 3.3
	sub	sp,16	; MSDOS 6.0
	push	ss
	pop	es
	push	es
	push	di
	;lea	di,[bp-15] ; MSDOS 3.3
	;LEA	DI,FCBTmp 
	lea	di,[bp-16]		; point to FCB temp area
	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
	call	GetExtended             ; get FCB, extended or not
	jz	short GetDrive		; not an extended FCB, get drive
	mov	AL,[SI-1]               ; get attributes
	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
GetDrive:
	lodsb				; get drive byte
	call	GETTHISDRV
	jc	short BadPack
	call	TextFromDrive           ; convert 0-based drive to text
;
; Scan the source to see if there are any illegal chars
;
	mov	bx,CharType		; load lookup table
	mov	cx,11
	push	si			; back over name, ext
FCBScan:
	lodsb				; get a byte
	; 09/08/2018
	;xlat	byte [es:bx]
	es	xlat			; get flags
	;test	al,8	
	test	al,FFCB
	jz	short BadPack
NextCh: 
	loop	FCBScan
	pop	si
	mov	bx,di
	call	PackName                ; crunch the path
	pop	di			; get original destination
	pop	es
	push	ss			; get DS addressability
	pop	ds
	;lea	si,[bp-15] ; MSDOS 3.3
	;LEA	SI,FCBTmp		; point at new pathname
	lea	si,[bp-16]
	cmp	byte [bx],0
	jz	short BadPack
	push	bp
	call	TransPathSet            ; convert the path
	pop	bp
	jnc	short FCBRet		; bye with transPath error code
BadPack:
	STC
	;mov	al,3
	MOV     AL,error_path_not_found
FCBRet: 
	;LEAVE
	mov	sp,bp
	pop	bp
TransPath_retn:
	retn

; 12/07/2018 - Retro DOS v3.0

;BREAK <TransPath - copy a path, do string sub and put in current dir>
;----------------------------------------------------------------------------
;
;   TransPath - copy a path from DS:SI to ES:DI, performing component string
;       substitution, insertion of current directory and fixing . and ..
;       entries. Perform splicing. Allow input string to match splice
;       exactly.
;
;   TransPathSet - Same as above except No splicing is performed if input path
;       matches splice.
;
;   TransPathNoSet - No splicing/local using is performed at all.
;
;   The following anomalous behaviour is required:
;
;       Drive letters on devices are ignored. (set up DummyCDS)
;       Paths on devices are ignored. (truncate to 0-length)
;       Raw net I/O sets ThisCDS => NULL.
;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
;
;   Other behaviour:
;
;       ThisCDS set up.
;       FatRead done on local CDS.
;       ValidateCDS done on local CDS.
;
;   Brief flowchart:
;
;       if fSharing then
;           set up DummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           splice
;           fatRead
;           return
;       if \\ or d:\\ lead then
;           set up null CDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if device then
;           set up dummyCDS (ThisCDS)
;           canonicalize (sets cMeta)
;           return
;       if file then
;           getCDS (sets (ThisCDS) from name)
;           validateCDS (may reset current dir)
;           Copy current dir
;           canonicalize (set cMeta)
;           splice
;           generate correct CDS (ThisCDS)
;           if local then
;               fatread
;           return
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               DI - point to buffer in DOSDATA
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc. or user FAILed to I 24.
;               WFP_Start - points to beginning of buffer
;               Curr_Dir_End - points to end of current dir in path
;               DS - DOSDATA
;   Registers modified: most
;
;----------------------------------------------------------------------------

TransPath:
	XOR     AL,AL
	JMP     SHORT SetSplice
TransPathSet:
	MOV     AL,-1
SetSplice:
	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
	MOV     AL,-1
TransPathNoSet:
	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
	MOV	byte [ss:CMETA],-1      			;smr;SS Override
	MOV     [SS:WFP_START],DI 				;smr;SS Override
	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
	push	ss
	pop	es
	;lea	bp,[di+134]
	LEA     BP,[DI+TEMPLEN]         ; end of buffer
;
; if this is through the server dos call, fsharing is set. We set up a
; dummy cds and let the operation go.
;
	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
	JZ	short CheckUNC		; skip to UNC check
;
; ES:DI point to buffer
;
	CALL	DriveFromText           ; get drive and advance DS:SI
	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
	jc	short NoPath
	CALL	TextFromDrive		; drop in new
	LEA	BX,[DI+1]               ; backup limit
	CALL	Canonicalize            ; copy and canonicalize
	jc	short TransPath_retn	; errors
;
; Perform splices for net guys.
;
	push	ss
	pop	ds
	MOV     SI,[WFP_START] 		; point to name
	TEST	byte [FSPLICE],-1
	JZ	short NoServerSplice
	CALL    Splice
NoServerSplice:
	push	ss
	pop	ds                      ; for FATREAD
	LES     DI,[THISCDS]		; for fatread
	call	EcritDisk
	call	FATREAD_CDS
	call	LcritDisk
NoPath:
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	retn				; any errors are in Carry flag

;
; Let the network decide if the name is for a spooled device. It will map
; the name if so.
;
CheckUNC:
	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
	;CallInstall NetSpoolCheck,MultNET,35
	mov	ax,1123h
	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
			; DS:SI -> ASCIZ filename to canonicalize
			; ES:DI -> 128-byte buffer for qualified name
			; Return: CF set if not resolved
	JNC	short UNCDone
;
; At this point the name is either a UNC-style name (prefixed with two leading
; \\s) or is a local file/device. Remember that if a net-spooled device was
; input, then the name has been changed to the remote spooler by the above net
; call. Also, there may be a drive in front of the \\.
;
NO_CHECK:
	CALL    DriveFromText		; eat drive letter
	PUSH    AX                      ; save it
	MOV     AX,[SI]			; get first two bytes of path
	call    PATHCHRCMP              ; convert to normal form
	XCHG    AH,AL                   ; swap for second byte
	call    PATHCHRCMP              ; convert to normal form
	JNZ	short CheckDevice	; not a path char
	CMP     AH,AL                   ; are they same?
	JNZ	short CheckDevice	; nope
;
; We have a UNC request. We must copy the string up to the beginning of the
; local machine root path
;

	POP     AX
	MOVSW                           ; get the lead \\.
UNCCpy:
	LODSB                           ; get a byte
 	call	UCase                   ;AN000;; convert the char
	OR      AL,AL
	JZ	short UNCTerm		; end of string. All done.
	call    PATHCHRCMP              ; is it a path char?
	MOV     BX,DI                   ; backup position
	STOSB
	JNZ	short UNCCpy		; no, go copy
	CALL    Canonicalize            ; wham (and set cMeta)
UNCDone:
	push	ss
	pop	ds
 	retn				; return error code
UNCTerm:
	STOSB                           ;AN000;
	JMP	short UNCDone		;AN000;

CheckDevice:
;
; Check DS:SI for device. First eat any path stuff
;
	POP     AX                      ; retrieve drive info
	CMP     BYTE [SI],0		; check for null file
	JNZ	short CheckPath
	;mov	al,2 
	MOV     AL,error_file_not_found ; bad file error
	STC                             ; signal error on null input
	RETN				; bye!
CheckPath:
	push	ax
	push	bp			; save drive number

	; MSDOS 6.0
;;;BUGBUG BUG 10-26-1992 scottq
;;;This is a hack for the CDROM extensions (2.1) who scan looking
;;;for the following POP BP == 5Dh (restore <bp,ax>).
;;;The problem is that a direct call to CheckThisDevice can (and did)
;;;end up having a 5D in the opcode's displacement field. The
;;;scanning code would choke on this thinking it was a POP BP instruction.
;;;
;;;What we do here is do a call to a function that is less than 5Dh
;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
;;;to the correct function. This cannot accidently insert a 5Dh.
;;;
;;;More info:
;;;  This particular scan is begun at the UNCdone label for 32 bytes
;;;looking for pop BP, so you cannot put a 5D between here and there.
;;;
	call	no5Dshere
start5Dhack:
;following is replaced with 5Dhack code--Invoke  CheckThisDevice         
backfrom5Dhack:
	pop	bp
	pop	ax			; get drive letter back
	JNC	short DoFile		; yes we have a file.
;
; We have a device. AX has drive letter. At this point we may fake a CDS ala
; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
; call.
;
	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
;
; Now that we have noted that we have a device, we put it into a form that
; getpath can understand. Normally getpath requires d:\ to begin the input
; string. We relax this to state that if the d:\ is present then the path
; may be a file. If D:/ (note the forward slash) is present then we have
; a device.
;
	CALL    TextFromDrive
	MOV     AL,'/'                  ; path sep.
	STOSB
	call	StrCpy			; move remainder of string

	CLC                             ; everything OK.
	push	ss
	pop	ds                      ; remainder of OK stuff
DoFile_retn:
	retn

no5Dshere:
	; 10/08/2018
	jmp	CheckThisDevice		; snoop for device

;.erre (no5Dshere - start5Dhack - 5D)

;
; We have a file. Get the raw CDS.
;

DoFile:
	; MSDOS 3.3 (& MSDOS 6.0)

	call	GetVisDrv               ; get proper CDS
	;mov	al,3 
	MOV     AL,error_path_not_found ; Set up for possible bad file error
	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
;
; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
; Use the one that we are going to use (ES:DI).
;
	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
	push	ds
	push	si
	push	es
	push	di
	call	ValidateCDS             ; poke CDS and make everything OK
	;RESTORE <DI,ES,SI,DS>		; get back pointers
	pop	di
	pop	es
	pop	si
	pop	ds
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	;retc				; someone failed an operation
	jc	short DoFile_retn
;
; ThisCDS points to correct CDS. It contains the correct text of the
; current directory. Copy it in.
;
	push	ds
	push	si
	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
	MOV     BX,DI                   ; point to destination
	ADD     BX,[SI+curdir.end]	; point to backup limit
;       LEA     SI,[SI+curdir.text]	; point to text
	;lea	bp,[di+134]
	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
					;AN000;
	call	FStrCpy                 ; copy string. ES:DI point to end
	DEC     DI                      ; point to NUL byte

;
; Make sure that there is a path char at end.
;
	MOV     AL,'\'
	CMP     [ES:DI-1],AL
	JZ	short GetOrig
	STOSB
;
; Now get original string.
;
GetOrig:
	DEC     DI                      ; point to path char
	pop	si
	pop	ds
;
; BX points to the end of the root part of the CDS (at where a path char
; should be). Now, we decide whether we use this root or extend it with the
; current directory.  See if the input string begins with a leading \
;
	CALL    PathSep                 ; is DS:SI a path sep?
	JNZ	short PathAssure	; no, DI is correct. Assure a path char
	OR      AL,AL                   ; end of string?
	JZ	short DoCanon		; yes, skip.
;
; The string does begin with a \. Reset the beginning of the canonicalization
; to this root. Make sure that there is a path char there and advance the
; source string over all leading \'s.
;
	MOV     DI,BX                   ; back up to root point.
SkipPath:
	LODSB
	call    PATHCHRCMP
	JZ	short SkipPath
	DEC     SI
	OR      AL,AL
	JZ	short DoCanon
;
; DS:SI start at some file name. ES:DI points at some path char. Drop one in
; for yucks.
;
PathAssure:
	MOV     AL,'\'
	STOSB
;
; ES:DI point to the correct spot for canonicalization to begin.
; BP is the max extent to advance DI
; BX is the backup limit for ..
;
DoCanon:
	CALL    Canonicalize            ; wham.
	;retc				; badly formatted path.
	jc	short DoFile_retn

;
; The string has been moved to ES:DI. Reset world to DOS context, pointers
; to wfp_start and do string substitution. BP is still the max position in
; buffer.
;
	push	ss
	pop	ds
	MOV     DI,[WFP_START]		; DS:SI point to string
	LDS     SI,[THISCDS]		; point to CDS
;       LEA     SI,[SI+curdir.text]	; point to text
	CALL    PathPref                ; is there a prefix?
	JNZ	short DoSplice		; no, do splice
;
; We have a match. Check to see if we ended in a path char.
;
	MOV     AL,[SI-1]		; last char to match
	call    PATHCHRCMP              ; did we end on a path char? (root)
	JZ	short DoSplice		; yes, no current dir here.
Pathline:                               ; 2/13/KK
	CMP     BYTE [ES:DI],0		; end at NUL?
	JZ	short DoSplice
	INC     DI                      ; point to after current path char
	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
;
; Splice the result.
;
DoSplice:
	push	ss
	pop	ds			; back to DOSDATA
	MOV     SI,[WFP_START]		; point to beginning of string
	XOR     CX,CX
	TEST	byte [FSPLICE],-1
	JZ	short SkipSplice
	CALL    Splice                  ; replaces in place.
SkipSplice:
;
; The final thing is to assure ourselves that a FATREAD is done on the local
; device.
;
	push	ss
	pop	ds
	LES     DI,[THISCDS]		; point to correct drive
	;test	word [es:di+67],8000h
	TEST	word [ES:DI+curdir.flags],curdir_isnet
	JNZ	short Done		; net, no fatread necessary (retnz)
	JCXZ    Done
	call	EcritDisk
	call	FATREAD_CDS
	call	LcritDisk
	;mov	al, 3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
Done:   
	retn                         ; any errors in carry flag.

; 13/07/2018

;BREAK <Canonicalize - copy a path and remove . and .. entries>
;----------------------------------------------------------------------------
;   Canonicalize - copy path removing . and .. entries.
;
;   Inputs:     DS:SI - point to ASCIZ string path
;               ES:DI - point to buffer
;               BX - backup limit (offset from ES) points to slash
;               BP - end of buffer
;   Outputs:    Carry Set - invalid path specification: too many .., bad
;                   syntax, etc.
;               Carry Clear -
;                   DS:DI - advanced to end of string
;                   ES:DI - advanced to end of canonicalized form after nul
;   Registers modified: AX CX DX (in addition to those above)
;----------------------------------------------------------------------------

Canonicalize:
;
; We copy all leading path separators.
;
	LODSB                           ;   while (PathChr (*s))
	call    PATHCHRCMP
	JNZ	short CanonDec
	CMP     DI,BP                   ;       if (d > dlim)
	JAE	short CanonBad		;           goto error;
	STOSB
	JMP	short Canonicalize	;           *d++ = *s++;
CanonDec:
	DEC     SI
;
; Main canonicalization loop.  We come here with DS:SI pointing to a textual
; component (no leading path separators) and ES:DI being the destination
; buffer.
;
CanonLoop:
;
; If we are at the end of the source string, then we need to check to see that
; a potential drive specifier is correctly terminated with a path sep char.
; Otherwise, do nothing
;
	XOR     AX,AX
	CMP     [SI],AL                 ;       if (*s == 0) {
	JNZ	short DoComponent
	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
	JNZ	short DoTerminate
	MOV     AL,'\'                  ;               *d++ = '\';
	STOSB
	MOV     AL,AH
DoTerminate:
	STOSB                           ;           *d++ = 0;
	CLC                             ;           return (0);
	retn

CanonBad:
	CALL	ScanPathChar            ; check for path chars in rest of string
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for bad path error
	JZ	short PathEnc		; path character encountered in string
	;mov	al,2
	MOV     AL,error_file_not_found ; Set bad file error
PathEnc:
	STC
CanonBad_retn:
	retn
;
; We have a textual component that we must copy.  We uppercase it and truncate
; it to 8.3
;
DoComponent:                            ;           }
	CALL    CopyComponent		;       if (!CopyComponent (s, d))
	jc	short CanonBad_retn	;           return (-1);
;
; We special case the . and .. cases.  These will be backed up.
;
	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
	CMP	WORD [ES:DI],002Eh
	JZ	short Skip1
	;CMP	WORD PTR ES:[DI],'..'
	CMP     WORD [ES:DI],2E2Eh
	JNZ	short CanonNormal
	DEC     DI                      ;           d--;
Skip1:  
	CALL    SkipBack                ;           SkipBack ();
	;mov	al,3
	MOV     AL,error_path_not_found ; Set up for possible bad path error
	jc	short CanonBad_retn
	JMP     short CanonPath         ;           }
;
; We have a normal path.  Advance destination pointer over it.
;
CanonNormal:                            ;       else
	ADD     DI,CX                   ;           d += ct;
;
; We have successfully copied a component.  We are now pointing at a path
; sep char or are pointing at a nul or are pointing at something else.
; If we point at something else, then we have an error.
;
CanonPath:
	CALL    PathSep
	JNZ	short CanonBad		; something else...
;
; Copy the first path char we see.
;
	LODSB                           ; get the char
	call    PATHCHRCMP              ; is it path char?
	JNZ	short CanonDec		; no, go test for nul
	CMP     DI,BP                   ; beyond buffer end?
	JAE	short CanonBad		; yep, error.
	STOSB                           ; copy the one byte
;
; Skip all remaining path chars
;
CanonPathLoop:
	LODSB                           ; get next byte
	call    PATHCHRCMP              ; path char again?
	JZ	short CanonPathLoop	; yep, grab another
	DEC     SI                      ; back up
	JMP	short  CanonLoop	; go copy component

;BREAK <PathSep - determine if char is a path separator>
;----------------------------------------------------------------------------
;   PathSep - look at DS:SI and see if char is / \ or NUL
;   Inputs:     DS:SI - point to a char
;   Outputs:    AL has char from DS:SI (/ => \)
;               Zero set if AL is / \ or NUL
;               Zero reset otherwise
;   Registers modified: AL
;----------------------------------------------------------------------------

PathSep:
	MOV     AL,[SI]                 ; get the character
PathSepGotCh:				; already have character
	OR      AL,AL                   ; test for zero
	jz	short CanonBad_retn	; return if equal to zero (NUL)
	call    PATHCHRCMP              ; check for path character
	retn				; and return HIS determination

;BREAK <SkipBack - move backwards to a path separator>
;----------------------------------------------------------------------------
;   SkipBack - look at ES:DI and backup until it points to a / \
;   Inputs:     ES:DI - point to a char
;               BX has current directory back up limit (point to a / \)
;   Outputs:    ES:DI backed up to point to a path char
;               AL has char from output ES:DI (path sep if carry clear)
;               Carry set if illegal backup
;               Carry Clear if ok
;   Registers modified: DI,AL
;----------------------------------------------------------------------------

SkipBack:
	CMP     DI,BX                   ;   while (TRUE) {
	JB	short SkipBad		;       if (d < dlim)
	DEC     DI                      ;           goto err;
	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
	call    PATHCHRCMP              ;           break;
	JNZ	short SkipBack		;       }
	CLC                             ;   return (0);
	retn				;
SkipBad:                                ;err:
	;mov	al,3
	MOV     AL,error_path_not_found ; bad path error
	STC                             ;   return (-1);
	retn                          ;

;Break <CopyComponent - copy out a file path component>
;----------------------------------------------------------------------------
;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
;
;   Inputs:     DS:SI - source path
;               ES:DI - destination
;               ES:BP - end of buffer
;   Outputs:    Carry Set - too long
;               Carry Clear - DS:SI moved past component
;                   CX has length of destination
;   Registers modified: AX,CX,DX
;----------------------------------------------------------------------------

CopyComponent:

%define CopyBP	 [BP]		; word
%define CopyD	 [BP+2]		; dword
%define CopyDoff [BP+2]		; word
%define CopyS	 [BP+6]		; dword
%define CopySoff [BP+6]		; word
%define CopyTemp [BP+10]	; byte

	SUB     SP,14                   ; room for temp buffer
	push	ds
	push	si
	push	es
	push	di
	push	bp
	MOV     BP,SP
	MOV     AH,'.'
	LODSB
	STOSB
	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
	JNZ	short NormalComp
	CALL    PathSep                 ;       if (!pathsep(*s))
	JZ	short NulTerm
TryTwoDot:
	LODSB                           ;           if ((*d++=*s++) != '.'
	STOSB
	CMP     AL,AH
	JNZ	short CopyBad
	CALL    PathSep
	JNZ	short CopyBad		;               || !pathsep (*s))
NulTerm:                                ;               return -1;
	XOR     AL,AL                   ;       *d++ = 0;
	STOSB
	MOV     CopySoff,SI
	JMP     SHORT _GoodRet		;       }
NormalComp:                             ;   else {
	MOV     SI,CopySoff ; [bp+6]
	call	NameTrans               ;       s = NameTrans (s, Name1);
	CMP     SI,CopySoff             ;       if (s == CopySOff)
	JZ	short CopyBad		;           return (-1);
	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
	JNZ	short DoPack
	AND     DL,1                    ;           cMeta += fMeta;
	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
	JG	short CopyBad		;               return (-1);
	JNZ	short DoPack		;           else
	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
	JZ	short CopyBadPath	;               return (-1);
DoPack:                                 ;           }
	MOV     CopySoff,SI ; [bp+6]
	push	ss
	pop	ds
	MOV     SI,NAME1
	LEA     DI,CopyTemp ; [bp+10]
	push	di
	call	PackName                ;       PackName (Name1, temp);
	pop	di
	call	StrLen                  ;       if (strlen(temp)+d > bp)
	DEC     CX
	ADD     CX,CopyDoff ; [bp+2]
	CMP     CX,CopyBP   ; [bp+0]
	JAE	short CopyBad		;           return (-1);
	MOV     SI,DI                   ;       strcpy (d, temp);
	LES     DI,CopyD    ; [bp+2]	
	call	FStrCpy
_GoodRet:				;       }
	CLC
	JMP     SHORT CopyEnd           ;   return 0;
CopyBad:
	STC
	CALL    ScanPathChar            ; check for path chars in rest of string
	;mov	al,2
	MOV     AL,error_file_not_found ; Set up for bad file error
	JNZ	short CopyEnd
CopyBadPath:
	STC
	;mov	al,3
	MOV     AL,error_path_not_found ; Set bad path error
CopyEnd:
	pop	bp
	pop	di
	pop	es
	pop	si
	pop	ds
	LAHF
	ADD     SP,14                   ; reclaim temp buffer
	call	StrLen
	DEC     CX
	SAHF
	retn

;Break <Splice - pseudo mount by string substitution>
;----------------------------------------------------------------------------
;   Splice - take a string and substitute a prefix if one exists. Change
;       ThisCDS to point to physical drive CDS.
;   Inputs:     DS:SI point to string
;               NoSetDir = TRUE => exact matches with splice fail
;   Outputs:    DS:SI points to thisCDS
;               ES:DI points to DPB
;               String at DS:SI may be reduced in length by removing prefix
;               and substituting drive letter.
;               CX = 0 If no splice done
;               CX <> 0 otherwise
;               ThisCDS points to proper CDS if spliced, otherwise it is
;                   left alone
;               ThisDPB points to proper DPB
;   Registers modified: DS:SI, ES:DI, BX,AX,CX
;----------------------------------------------------------------------------

Splice:
	TEST	byte [SS:SPLICES],-1	;smr;SS Override
	JZ	short AllDone
	push	word [SS:THISCDS]
	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
	push	ds
	push	si
	pop	di
	pop	es
	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
SpliceScan:
	call	GetCDSFromDrv
	JC	short SpliceDone
	INC     AL
	;test	word [si+67],2000h
	TEST    word [SI+curdir.flags],curdir_splice
	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
	push	di
	CALL    PathPref                ;           if (!PathPref (s, d))
	JZ	short SpliceFound	;
SpliceSkip:
	pop	di
	JMP	short SpliceScan	;               continue;
SpliceFound:
	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
	JNZ	short SpliceDo
	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
	JNZ	short SpliceSkip
SpliceDo:
	MOV     SI,DI                   ;               p = src + strlen (p);
	push	es
	pop	ds
	pop	di
	CALL    TextFromDrive1          ;               src = TextFromDrive1(src,i);
	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
	OR      AX,AX
	JS	short NoPoke
	ADD     AX,DI                   ;               curdirend += src-p;
	SUB     AX,SI
	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
NoPoke:
	CMP     BYTE [SI],0		;               if (*p)
	JNZ	short SpliceCopy	;                   *src++ = '\\';
	MOV     AL,"\"
	STOSB
SpliceCopy:                             ;               strcpy (src, p);
	call	FStrCpy
	ADD     SP,4                    ; throw away saved stuff
	OR      CL,1                    ; signal splice done.
	JMP     SHORT DoSet             ;               return;
SpliceDone:                             ;               }
	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
	pop	word [SS:THISCDS]			;smr;SS Override
AllDone:
	XOR     CX,CX
DoSet:
	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
	;les	di,[si+69]
	LES     DI,[SI+curdir.devptr]	
	MOV	[SS:THISDPB],DI				;smr;SS Override
	MOV	[SS:THISDPB+2],ES			;smr;SS Override
Splice_retn:
	retn

;Break <$NameTrans - partially process a name>
;----------------------------------------------------------------------------
;   $NameTrans - allow users to see what names get mapped to. This call
;   performs only string substitution and canonicalization, not splicing.  Due
;   to Transpath playing games with devices, we need to insure that the output
;   has drive letter and : in it.
;
;   Inputs:     DS:SI - source string for translation
;               ES:DI - pointer to buffer
;   Outputs:
;       Carry Clear
;               Buffer at ES:DI is filled in with data
;               ES:DI point byte after nul byte at end of dest string in buffer
;       Carry Set
;               AX = error_path_not_found
;   Registers modified: all
;----------------------------------------------------------------------------

_$NameTrans:
	push	ds
	push	si
	push	es
	push	di
	push	cx ; MSDOS 6.0
	
	; MSDOS 6.0	
; M027 - Start
;
; Sattrib must be set up with default values here. Otherwise, the value from
; a previous DOS call is used for attrib and DevName thinks it is not a 
; device if the old call set the volume attribute bit. Note that devname in
; dir2.asm gets ultimately called by Transpath. See also M026. Also save
; and restore CX.
;
	mov     ch,attr_hidden+attr_system+attr_directory
	call	SetAttrib

; M027 - End

	; MSDOS 3.3 (& MSDOS 6.0)
	MOV     DI,OPENBUF
	CALL    TransPath               ; to translation (everything)
	pop	cx ; MSDOS 6.0
	pop     di
	pop	es
	pop     si
	pop     ds
	JNC	short TransOK
	jmp	SYS_RET_ERR
TransOK:
	MOV     SI,OPENBUF
	push	ss
	pop	ds
GotText:
	call	FStrCpy
	jmp	SYS_RET_OK

;Break   <DriveFromText - return drive number from a text string>
;----------------------------------------------------------------------------
;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
;   pointer.
;
;   Inputs:     DS:SI point to a text string
;   Outputs:    AL has drive number
;               DS:SI advanced
;   Registers modified: AX,SI.
;----------------------------------------------------------------------------

DriveFromText:
	XOR     AL,AL                   ;       drive = 0;
	CMP     BYTE [SI],0		;       if (*s &&
	jz	short Splice_retn
	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
	jnz	short Splice_retn
	LODSW                           ;           drive = (*s | 020) - 'a'+1;
	OR      AL,20h
	;sub	al,60h
	SUB     AL,'a'-1                ;           s += 2;
	jnz	short Splice_retn
	MOV     AL,-1                   ; nuke AL...
	retn				;           }

;Break   <TextFromDrive - convert a drive number to a text string>
;----------------------------------------------------------------------------
;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
;   trailing :. TextFromDrive1 takes a 1-based number.
;
;   Inputs:     AL has 0-based drive number
;   Outputs:    ES:DI advanced
;   Registers modified: AX
;----------------------------------------------------------------------------

TextFromDrive:
	INC     AL
TextFromDrive1:
	;add	al,40h
	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
	MOV     AH,":"                  ;   strcat (d, ":");
	STOSW
PathPref_retn:
	retn

;Break   <PathPref - see if one path is a prefix of another>
;----------------------------------------------------------------------------
;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
;   other.  Remember that only at a pathchar break are we allowed to have a
;   prefix: A:\ and A:\FOO
;
;   Inputs:     DS:SI potential prefix
;               ES:DI string
;   Outputs:    Zero set => prefix found
;                   DI/SI advanced past matching part
;               Zero reset => no prefix, DS/SI garbage
;   Registers modified: CX
;----------------------------------------------------------------------------

PathPref:
	call	DStrLen                 ; get length
	DEC     CX                      ; do not include nul byte
	REPZ    CMPSB                   ; compare
	jnz	short PathPref_retn	; if NZ then return NZ
	push	ax			; save char register
	MOV     AL,[SI-1]               ; get last byte to match
	call    PATHCHRCMP              ; is it a path char (Root!)
	JZ	short Prefix		; yes, match root (I hope)
NotSep:                                 ; 2/13/KK
	MOV     AL,[ES:DI]		; get next char to match
	CALL    PathSepGotCh            ; was it a pathchar?
Prefix:
	pop	ax			; get back original
	retn

;Break   <ScanPathChar - see if there is a path character in a string>
;----------------------------------------------------------------------------
;     ScanPathChar - search through the string (pointed to by DS:SI) for
;     a path separator.
;
;     Input:    DS:SI target string (null terminated)
;     Output:   Zero set => path separator encountered in string
;               Zero clear => null encountered
;     Registers modified: SI
;----------------------------------------------------------------------------

ScanPathChar:
	LODSB                           ; fetch a character
	call    PathSepGotCh
	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
	call    PATHCHRCMP              ; path separator?
	retn

;============================================================================
; HANDLE.ASM, MSDOS 6.0, 1991
;============================================================================
; 13/07/2018 - Retro DOS v3.0

;	BREAK <$Close - return a handle to the system>
;----------------------------------------------------------------------------
;
;**	$Close - Close a file Handle
;
;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
;		path
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Close
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	<normal INT21 return convention>
;	USES	all
;
;----------------------------------------------------------------------------

_$CLOSE:
;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	jc	short CloseError	; error return
	push	ss
	pop	ds			; For DOS_CLOSE
	MOV	[THISSFT],DI		; save offset of pointer
	MOV	[THISSFT+2],ES		; save segment value

; DS:SI point to JFN table entry.
; ES:DI point to SFT
;
; We now examine the user's JFN entry; If the file was a 70-mode file (network
; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
; If the file was not a net FCB, we free the JFN too.

	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
	cmp	word [ES:DI],1		; will the SFT become free?
	jz	short FreeJFN 		; yes, free JFN anyway.
	;mov	al,[ES:DI+2]
	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
	;and	al,0F0h
	AND	AL,SHARING_MASK
	;cmp	al,70h
	CMP	AL,SHARING_NET_FCB
	JZ	short PostFree		; 70-mode and big ref count => free it

; The JFN must be freed.  Get the pointer to it and replace the contents with
; -1.

FreeJFN:
	call	pJFNFromHandle		;   d = pJFN (handle);
	MOV	BYTE [ES:DI],0FFh	; release the JFN
PostFree:

; ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_CLOSE!

	call	DOS_CLOSE

; DOS_Close may return an error.  If we see such an error, we report it but
; the JFN stays closed because DOS_Close always frees the SFT!

	JC	short CloseError
	;mov	ah,3Eh
	MOV	AH,CLOSE		; MZ Bogus multiplan fix
	jmp	SYS_RET_OK
CloseError:
	jmp	SYS_RET_ERR


;	BREAK <$Commit - commit the file>
;----------------------------------------------------------------------------
;
;**	$Commit - Commit a File
;
;	$Commit "commits" a file to disk - all of it's buffers are
;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
;	the directory entry, etc., so this commit is pretty useless. check
;	and fix this!! jgl
;
;	Assembler usage:
;	    MOV     BX, handle
;	    MOV     AH, Commit
;	    INT     int_command
;
;	ENTRY	(bx) = handle
;	EXIT	none
;	USES	all
;;----------------------------------------------------------------------------

_$COMMIT:
;	Grab the SFT pointer from the JFN.

	call	CheckOwner		; get system file entry
	JC	short CommitError	; error return
	push	ss
	pop	ds			; For DOS_COMMIT
	MOV	[THISSFT],DI		; save offset of pointer
	MOV	[THISSFT+2],ES		; save segment value

;	ThisSFT is correctly set, we have DS = DOSDATA. Looks OK for a DOS_COMMIT
;
;	ES:DI point to SFT

	call	DOS_COMMIT
	JC	short CommitError
	;mov	ah,68h
	MOV	AH,COMMIT		;
	jmp	SYS_RET_OK
CommitError:
	jmp	SYS_RET_ERR

;	BREAK <$ExtHandle - extend handle count>

;**	$ExtHandle - Extend Handle Count
;----------------------------------------------------------------------------
;	Assembler usage:
;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
;	    MOV     AX, 6700H			 reserved to mark SFT
;	    INT     int_command 		 busy )
;
;	ENTRY	(bx) = new number of handles
;	EXIT	'C' clear if OK
;		'C' set iff err
;		  (ax) = error code
;			 AX = error_not_enough_memory
;			      error_too_many_open_files
;	USES	all
;----------------------------------------------------------------------------

_$ExtHandle:
	XOR	BP,BP			; 0: enlarge  1: shrink  2:psp
	;cmp	bx,20
	CMP	BX,FILPERPROC
	JAE	short exth2		; Don't set less than FilPerProc no
	MOV	BX,FILPERPROC
exth2:	
	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
	;mov	cx,[ES:32h]
	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
	CMP	BX,CX			; the requested == current
	JE	short ok_done 		; yes and exit
	JA	short larger		; go allocate new table

;	We're going to shrink the # of handles available

	MOV	BP,1			; shrink
	;mov	ds,[ES:36h]
	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
	MOV	SI,BX			;
	SUB	CX,BX			; get difference

;	BUGBUG - code a SCASB here, should be a bit smaller
chck_handles:
	CMP	BYTE [SI],-1		; scan through handles to ensure close
	JNZ	short too_many_files	; status
	INC	SI
	LOOP	chck_handles
	CMP	BX,FILPERPROC		; = 20
	JA	short larger		; no

	MOV	BP,2			; psp
	;mov	di,24
	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
	PUSH	BX
	JMP	short movhandl

larger:
	CMP	BX,-1			; 65535 is not allowed
	JZ	invalid_func ; 10/08/2018
	CLC
	PUSH	BX			; save requested number
	ADD	BX,0FH			; adjust to paragraph boundary
	MOV	CL,4
	;ror	bx,cl			; MSDOS 3.3
	RCR	BX,CL			; DOS 4.00 fix		;AC000;
	AND	BX,1FFFH		; clear most 3 bits

	PUSH	BP
	call	_$ALLOC			; allocate memory
	POP	BP
	JC	short no_memory		; not enough meory

	MOV	ES,AX			; es:di points to new table memory
	XOR	DI,DI
movhandl:
	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override

	test	BP,3			; enlarge ?
	JZ	short enlarge 		; yes
	POP	CX			; cx = the amount you shrink
	PUSH	CX
	JMP	short copy_hand

;	Done.  'C' clear

ok_done:
	jmp	SYS_RET_OK

too_many_files:
	;mov	al,4
	MOV	AL,error_too_many_open_files
	jmp	SYS_RET_ERR

enlarge:
	;mov	cx,[32h]
	MOV	CX,[PDB.JFN_Length]	; get number of old handles
copy_hand:
	MOV	DX,CX
	;lds	si,[34h]
	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
	REP	MOVSB			; copy information to new table
	POP	CX			; get new number of handles
	PUSH	CX			; save it again
	SUB	CX,DX			; get the difference
	MOV	AL,-1			; set availability to handles
	REP	STOSB
	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
	;cmp	word [34h],0
	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
	JNZ	short update_info	; yes, go update PDB entries
	PUSH	BP
	PUSH	DS			; save old table segment
	PUSH	ES			; save new table segment
	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
	call	_$DEALLOC		; deallocate old table meomory
	POP	ES			; restore new table segment
	POP	DS			; restore old table segment
	POP	BP

update_info:
	test	BP,2			; psp?
	JZ	short non_psp 		; no
	;mov	word [34h],18h ; 24
	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
	JMP	short final
non_psp:
	;mov	word [34h],0
	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
final:
	;mov	word [36h],es	
	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
	;pop	word [32h]
	POP	word [PDB.JFN_Length]	; restore new number of handles
	jmp	SYS_RET_OK

no_memory:
	POP	BX			; clean stack
	;mov	al,8
	MOV	AL,error_not_enough_memory
	jmp	SYS_RET_ERR
invalid_func:
	;mov	al,1
	MOV	AL,error_invalid_function
	jmp	SYS_RET_ERR


;	BREAK <$READ - Read from a file handle>
;----------------------------------------------------------------------------
;
;**	$Read - Read from a File Handle
;
;   Assembler usage:
;
;	LDS	DX, buf
;	MOV	CX, count
;	MOV	BX, handle
;	MOV	AH, Read
;	INT	int_command
;	  AX has number of bytes read
;
;	ENTRY	(bx) = file handle
;		(cx) = byte count
;		(ds:dx) = buffer address
;	EXIT	Through system call return so that to user:
;		  'C' clear if OK
;		    (ax) = bytes read
;		  'C' set if error
;		    (ax) = error code
;
;----------------------------------------------------------------------------

_$READ:
	MOV	SI,DOS_READ
ReadDo:
	call	pJFNFromHandle
	JC	short ReadError
	MOV	AL,[ES:DI]
	call	CheckOwner		; get the handle
	JNC	short ReadSetup		; no errors do the operation

;	Have an error.	'C' set

ReadError:
	jmp	SYS_RET_ERR		; go to error traps

ReadSetup:
	MOV	[SS:THISSFT],DI		; save offset of pointer;smr;SS Override
	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
	;;; MSDOS 6.0 
;; Extended Open
	;;;testb [ES:DI+SF_ENTRY.sf_mode],INT_24_ERROR  ;AN000;;EO. need i24
	;;;JZ	short needi24 		      ;AN000;;EO. yes
	;;;OR	byte [EXTOPEN_ON],EXT_OPEN_I24_OFF 
					;AN000;;EO. set it off;smr;SS Override
needi24:				;AN000;
;; Extended Open
	push	word [SS:DMAADD]
	push	word [SS:DMAADD+2]	;smr;SS Override
;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
	;;; MSDOS 6.0
	;;; CALL Align_Buffer		;AN000;MS. align user's buffer
	; MSDOS 3.3
	MOV	BX,DX			; copy offset
	push	cx			; don't stomp on count
	MOV	CL,4			; bits to shift bytes->para
	SHR	BX,CL			; get number of paragraphs
	pop	cx			; get count back
	MOV	AX,DS			; get original segment
	ADD	AX,BX			; get new segment
	MOV	DS,AX			; in seg register
	AND	DX,0Fh			; normalize offset
	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
						;smr;SS Override
;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
	push	ss			; go for DOS addressability
	pop	ds
	CALL	SI ; DOS_READ		; indirect call to operation
	pop	word [DMAADD+2]
	pop	word [DMAADD]
	;JNC	short READ_OK		;AN002;
	;JMP	ReadError		;AN002; if error, say bye bye
	jc	short ReadError
READ_OK:
	MOV	AX,CX			; get correct return in correct reg
	jmp	SYS_RET_OK		; successful return



; 13/07/2018 - Retro DOS v3.0

;
;   Input: DS:DX points to user's buffer addr
;   Function: rearrange segment and offset for READ/WRITE buffer
;   Output: [DMAADD] set
;

;Align_Buffer:
;	MOV	BX,DX			; copy offset
;	push	cx			; don't stomp on count
;	MOV	CL,4			; bits to shift bytes->para
;	SHR	BX,CL			; get number of paragraphs
;	pop	cx			; get count back
;	MOV	AX,DS			; get original segment
;	ADD	AX,BX			; get new segment
;	MOV	DS,AX			; in seg register
;	AND	DX,0Fh			; normalize offset
;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
;						;smr;SS Override
;	retn

;BREAK <$WRITE - write to a file handle>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    LDS     DX, buf
;	    MOV     CX, count
;	    MOV     BX, handle
;	    MOV     AH, Write
;	    INT     int_command
;	  AX has number of bytes written
;   Errors:
;	    AX = write_invalid_handle
;	       = write_access_denied
;
;   Returns in register AX
;
;----------------------------------------------------------------------------

_$WRITE:
	MOV	SI,DOS_WRITE
	JMP	short ReadDo

;BREAK <$LSEEK - move r/w pointer>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     DX, offsetlow
;	    MOV     CX, offsethigh
;	    MOV     BX, handle
;	    MOV     AL, method
;	    MOV     AH, LSeek
;	    INT     int_command
;	  DX:AX has the new location of the pointer
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;   Returns in registers DX:AX
;
;----------------------------------------------------------------------------

_$LSEEK:
	call	CheckOwner		; get system file entry
LSeekError:
	;JNC	short CHKOWN_OK		;AN002;
	;JMP	short ReadError		;AN002; error return
	jc	short ReadError ; 24/07/2019
CHKOWN_OK:				;AN002;
	CMP	AL,2			; is the seek value correct?
	JBE	short LSeekDisp		; yes, go dispatch
	;mov	byte [ss:EXTERR_LOCUS],1 
	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
					;smr;SS Override
	;mov	al,1
	mov	al, error_invalid_function ; invalid method
	jmp	short ReadError
LSeekDisp:
	CMP	AL,1			; best way to dispatch ; check middle
	JB	short LSeekStore	; just store CX:DX
	JA	short LSeekEOF		; seek from end of file
	;add	dx,[es:di+21]
	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
	;adc	cx,[es:di+23]
	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
LSeekStore:
	MOV	AX,CX			; AX:DX
	XCHG	AX,DX			; DX:AX is the correct value
LSeekSetpos:
	;mov	[es:di+21],ax
	MOV	[ES:DI+SF_ENTRY.sf_position],AX
	;mov	[es:di+23],dx
	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
	call	Get_User_Stack
	;mov	[si+6],dx
	MOV	[SI+user_env.user_DX],DX ; return DX:AX
	;jmp	SYS_RET_OK		; successful return
	; 26/07/2019
	jmp	SYS_RET_OK_clc

LSeekEOF:
	;test	word [es:di+5],8000h
	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JNZ	short Check_LSeek_Mode	; Is Net
LOCAL_LSeek:
	;add	dx,[es:di+17]
	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
	;adc	cx,[es:di+19]
	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
	JMP	short LSeekStore	; go and set the position

Check_LSeek_Mode:
	;test	word [es:di+2],8000h
	test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
	JNZ	short LOCAL_LSeek	; FCB treated like local file
	;mov	ax,[es:di+2]
	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
	;and	ax, 0F0h
	AND	AX,SHARING_MASK
	;cmp	ax,40h
	CMP	AX,SHARING_DENY_NONE
	JZ	short NET_LSEEK		; LSEEK exported in this mode
	;cmp	ax,30h
	CMP	AX,SHARING_DENY_READ
	JNZ	short LOCAL_LSeek	; Treated like local Lseek
NET_LSEEK:
;	JMP	short LOCAL_LSeek
; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
	;CallInstall Net_Lseek,MultNET,33
	;JNC	short LSeekSetPos

	mov     ax, 1121h
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
			; CX:DX = offset (in bytes) from end
			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
			; SS = DOS CS
			; Return: CF set on error
			; CF clear if successful, DX:AX = new file position
	jnb     short LSeekSetpos
	jmp	SYS_RET_ERR

;BREAK <FileTimes - modify write times on a handle>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV AH, FileTimes (57H)
;	    MOV AL, func
;	    MOV BX, handle
;	; if AL = 1 then then next two are mandatory
;	    MOV CX, time
;	    MOV DX, date
;	    INT 21h
;	; if AL = 0 then CX/DX has the last write time/date
;	; for the handle.
;
;	AL=02		 get extended attributes
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   DS:SI query list (si=-1, selects all EA)
;	   ES:DI buffer to hold EA list
;
;	AL=03		 get EA name list
;	   BX=handle
;	   CX=size of buffer (0, return max size )
;	   ES:DI buffer to hold name list
;
;	AL=04		 set extended attributes
;	   BX=handle
;	   ES:DI buffer of EA list
;
;
;   Error returns:
;	    AX = error_invalid_function
;	       = error_invalid_handle
;
;----------------------------------------------------------------------------

_$FILE_TIMES:
	; 13/07/2018 - Retro DOS v3.0

	; MSDOS 3.3
	cmp	al,2			; correct subfunction ?
	jb	short ft1

        ;mov	byte [ss:EXTERR_LOCUS], 1
	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
						;SS Overr
	;mov	al,1
	mov	al,error_invalid_function ; give bad return
	jmp     SYS_RET_ERR

	; MSDOS 6.0
	;cmp	al,2			; correct subfunction ?
	;jae	short inval_func
ft1:
	call	CheckOwner		; get sft
	jc	short LSeekError	; bad handle

	or	al,al			; get time/date ?
	jnz	short ft_set_time

;------ here we get the time & date from the sft for the user

	cli				; is this cli/sti reqd ? BUGBUG
	;mov	cx,[es:di+13]
	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
	;mov	dx,[es:di+15]
	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
	sti
	call	Get_User_Stack
	;mov	[si+4],cx
	mov	[si+user_env.user_CX],cx
	;mov	[si+6],dx
	mov	[si+user_env.user_DX],dx
	jmp	short ok_ret

;------ here we set the time in sft

ft_set_time:
	call    EcritSFT
	;mov	[es:di+13],cx
	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
	;mov	[es:di+15],dx
	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	

	xor	ax, ax
	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override

;------ set the flags in SFT entry
	;and	word [es:di+5],0FFBFh
	and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
							; mark file as dirty
	;or	word [es:di+5],4000h
	or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
							; ask close not to
							;   bother about date
							;   and time
	call	LcritSFT
ok_ret:
	jmp	SYS_RET_OK

;inval_func:
;	mov	byte [ss:EXTERR_LOCUS], 1
;	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
;						;SS Overr
;	;mov	al,1
;	mov	al,error_invalid_function ; give bad return
;	jmp     SYS_RET_ERR

;BREAK <$DUP - duplicate a jfn>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     AH, Dup
;	    INT     int_command
;	  AX has the returned handle
;   Errors:
;	    AX = dup_invalid_handle
;	       = dup_too_many_open_files
;
;----------------------------------------------------------------------------

_$DUP:
	MOV	AX,BX			; save away old handle in AX
	call	JFNFree 		; free handle? into ES:DI, new in BX
DupErrorCheck:
	JC	short DupErr		; nope, bye
	push	es
	push	di			; save away SFT
	pop	si			; into convenient place DS:SI
	pop	ds
	XCHG	AX,BX			; get back old handle
	call	CheckOwner		; get sft in ES:DI
	JC	short DupErr		; errors go home
	call	DOS_Dup_Direct
	call	pJFNFromHandle		; get pointer
	MOV	BL,[ES:DI]		; get SFT number
	MOV	[SI],BL			; stuff in new SFT
	jmp	SYS_RET_OK		; and go home
DupErr:
	jmp	SYS_RET_ERR

;BREAK <$DUP2 - force a dup on a particular jfn>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    MOV     BX, fh
;	    MOV     CX, newfh
;	    MOV     AH, Dup2
;	    INT     int_command
;   Error returns:
;	    AX = error_invalid_handle
;
;----------------------------------------------------------------------------

_$DUP2:
	push	bx
	push	cx			; save source
	MOV	BX,CX			; get one to close
	call	_$CLOSE			; close destination handle
	pop	bx
	pop	ax			; old in AX, new in BX
	call	pJFNFromHandle		; get pointer
	JMP	short DupErrorCheck	; check error and do dup

;Break	<CheckOwner - verify ownership of handles from server>
;----------------------------------------------------------------------------
;   CheckOwner - Due to the ability of the server to close file handles for a
;   process without the process knowing it (delete/rename of open files, for
;   example), it is possible for the redirector to issue a call to a handle
;   that it soes not rightfully own.  We check here to make sure that the
;   issuing process is the owner of the SFT.  At the same time, we do a
;   SFFromHandle to really make sure that the SFT is good.
;
;	ENTRY	BX has the handle
;		User_ID is the current user
;	EXIT	Carry Clear => ES:DI points to SFT
;		Carry Set => AX has error code
;	USES	none
;----------------------------------------------------------------------------

CheckOwner:
	; 13/07/2018 - Retro DOS v3.0

	call	SFFromHandle
	jc	short co_ret_label	; retc

	push	ax

	; MSDOS 6.0
;SR;
;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
;SR; are shared across multiple VMs in win386.
;SR;
	;test	byte [IsWin386],1
	;jz	short no_win386		;win386 is not present
	;xor	ax,ax			;set the zero flag
	;jmp	short skip_win386	

;no_win386:
	mov	ax,[SS:USER_ID]		;smr;SS Override
	;cmp	ax,[es:di+47]
	cmp	ax,[es:di+SF_ENTRY.sf_UID]

;skip_win386:
	pop	ax
	
	jz	short co_ret_label
	
	;mov	al,6
	mov	al,error_invalid_handle
	stc

co_ret_label:
	retn

;============================================================================
; FILE.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

; MSDOS 2.11
;BREAK <$Open - open a file handle>
;----------------------------------------------------------------------------
;   Assembler usage:
;           LDS     DX, Name
;           MOV     AH, Open
;           MOV     AL, access
;           INT     int_command
;
;       ACCESS          Function
;       ------          --------
;       open_for_read   file is opened for reading
;       open_for_write  file is opened for writing
;       open_for_both   file is opened for both reading and writing.
;
;   Error returns:
;           AX = error_invalid_access
;              = error_file_not_found
;              = error_access_denied
;              = error_too_many_open_files
;----------------------------------------------------------------------------

; MSDOS 6.0
;	BREAK <$Open - open a file from a path string>
;----------------------------------------------------------------------------
;
;**	$OPen - Open a File
;
;	given a path name in DS:DX and an open mode in AL, $Open opens the
;	file and and returns a handle
;
;	ENTRY	(DS:DX) = pointer to asciz name
;		(AL) = open mode
;	EXIT	'C' clear if OK
;		  (ax) = file handle
;		'C' set if error
;		  (ax) = error code
;	USES	all
;
;----------------------------------------------------------------------------

_$OPEN:       
	xor	ah,ah  ; MSDOS 6.0	
_$Open2:
	;mov	ch,16h
	mov	ch,attr_hidden+attr_system+attr_directory
	call	SetAttrib
	mov	cx,DOS_OPEN

	;xor	ah,ah  ; MSDOS 3.3

	push	ax

;*	General file open/create code. The $CREATE call and the various
;	$OPEN calls all come here.
;
;	We'll share a lot of the standard stuff of allocating SFTs, cracking
;	path names, etc., and then dispatch to our individual handlers.
;	WARNING - this info and list is just a guess, not definitive - jgl
;
;	(TOS) = create mode
;	(CX) = address of routine to call to do actual function
;	(DS:DX) = ASCIZ name
;	SAttrib = Attribute mask

;	Get a free SFT and mark it "being allocated"

AccessFile:
	call	EcritSFT
	call	SFNFree			; get a free sfn
	call	LcritSFT
	jc	short OpenFailJ		; oops, no free sft's
	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override

;	Find a free area in the user's JFN table.

	call	JFNFree			; get a free jfn
	jnc	short SaveJFN
OpenFailJ:
	JMP	OpenFail		; there were free JFNs... try SFN

SaveJFN:
	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override

;	We have been given an JFN. We lock it down to prevent other tasks from
;	reusing the same JFN.

	MOV	BX,[ss:SFN]					;smr;SS Override
	MOV	[ES:DI],BL		; assign the JFN
	MOV	SI,DX			; get name in appropriate place
	MOV	DI,OPENBUF		; appropriate buffer
	push	cx			; save routine to call
	call	TransPath		; convert the path
	pop	bx			; (bx) = routine to call

	LDS	SI,[SS:THISSFT]					;smr;SS Override
	JC	short OpenCleanJ	; no error, go and open file
	CMP	byte [ss:CMETA],-1				;smr;SS Override
	JZ	short SetSearch
	;mov	al,2
	MOV	AL,error_file_not_found ; no meta chars allowed
OpenCleanJ:
	JMP	short OpenClean

SetSearch:
	pop	ax			; Mode (Open), Attributes (Create)

;	We need to get the new inheritance bits.

	xor	cx,cx
	; MSDOS 6.0
	;mov	[si+2],cx ; 0
	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
	;mov    [si+51],cx ; 0
	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
	;
	CMP	BX,DOS_OPEN
	JNZ	short _DoOper
	;test   al,80h
	test	AL,SHARING_NO_INHERIT	; look for no inher
	JZ	short _DoOper ; 10/08/2018
	AND	AL,7Fh			; mask off inherit bit
	;mov	cx,1000h
	MOV	CX,sf_no_inherit
_DoOper:
	;; MSDOS 3.3
	;;mov	word [si+2], 0
	;;mov	word [si+33h], 0
	;MOV	word [SI+SF_ENTRY.sf_mode],0
	;MOV	word [SI+SF_ENTRY.sf_MFT],0

	; MSDOS 6.0
;**	Check if this is an extended open. If so you must set the
;	modes in sf_mode. Call Set_EXT_mode to do all this. See
;	Set_EXT_mode in creat.asm

	; MSDOS 6.0
	;;SAVE	<di, es>                ;M022 conditional removed here
	;push	di
	;push	es
	;push	ds
	;pop	es
	;push	si
	;pop	di			; (es:di) = SFT address
	;call	Set_EXT_mode
	;;RESTORE <es, di>
	;pop	es
	;pop	di

	;Context DS
	push	ss
	pop	ds	

	push	cx
	CALL	BX			; blam!
	pop	cx
	LDS	SI,[THISSFT]
	;JC	short OpenE2		;AN000;FT. chek extended open hooks first
	jc	short OpenE ; MSDOS 3.3

;	The SFT was successfully opened. Remove busy mark.

OpenOK:
	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
	mov	word [SI],1
	;or	[SI+5],cx
	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary

; If the open mode is 70, we scan the system for other SFT's with the same
; contents. If we find one, then we can 'collapse' thissft onto the already
; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
;
; Since this is only relevant on sharer systems, we stick this code into the
; sharer.

	MOV	AX,[ss:JFN]				;smr;SS Override
	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override

	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
	jmp	SYS_RET_OK		; bye with no errors

	; MSDOS 6.0
;Extended Open hooks check
;OpenE2:					;AN000;;EO.
;	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
;	JNZ	short OpenE		;AN000;;EO. no.
;	JMP	short OpenCritLeave	;AN000;;EO. keep handle

;	Extended Open hooks check
;
;	AL has error code.  Stack has argument to dos_open/dos_create.

OpenClean:
	pop	bx			; clean off stack
OpenE:
	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
	mov	word [SI],0
	LDS	SI,[ss:PJFN]				;smr;SS Override
	MOV	BYTE [SI],0FFh		; free the SFN...
	JMP	SHORT OpenCritLeave

OpenFail:
	STI
	pop	cx			; Clean stack
OpenCritLeave:
	MOV	word [SS:SFN],-1	; remove mark.

	; MSDOS 6.0
;; File Tagging DOS 4.00
;	CMP	[SS:EXTERR],error_Code_Page_Mismatched 
;				;AN000;;FT. code page mismatch;smr;SS Override
;	JNZ	short NORERR	  	;AN000;;FT. no
;	jmp	From_GetSet		;AN000;;FT. yes
;NORERR: 				;AN000;
;; File Tagging DOS 4.00

	jmp	SYS_RET_ERR		; no free, return error

; MSDOS 2.11
;BREAK <$CREAT - creat a new file and open him for input>
;----------------------------------------------------------------------------
;   Assembler usage:
;           LDS     DX, name
;           MOV     AH, Creat
;           MOV     CX, access
;           INT     21h
;       ; AX now has the handle
;
;   Error returns:
;           AX = error_access_denied
;              = error_path_not_found
;              = error_too_many_open_files
;----------------------------------------------------------------------------

; MSDOS 6.0
;	BREAK <$Creat - create a brand-new file>
;----------------------------------------------------------------------------
;
;**	$Creat - Create a File
;
;	$Creat creates the directory entry specified in DS:DX and gives it the
;	initial attributes contained in CX
;
;	ENTRY	(DS:DX) = ASCIZ path name
;		(CX) = initial attributes
;	EXIT	'C' set if error
;		  (ax) = error code
;		'C' clear if OK
;		  (ax) = file handle
;	USES	all
;
;----------------------------------------------------------------------------

_$CREAT:
	push	cx			; Save attributes on stack
	mov	CX,DOS_CREATE		; routine to call
AccessSet:
	;mov	byte [ss:SATTRIB],6
	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
	; 10/08/2018
	JMP	AccessFile		; use good ol' open


; MSDOS 6.0 (MSDOS 3.3)
;	BREAK <$CHMOD - change file attributes>
;----------------------------------------------------------------------------
;
;**	$CHMOD - Change File Attributes
;
;   Assembler usage:
;	    LDS     DX, name
;	    MOV     CX, attributes
;	    MOV     AL,func (0=get, 1=set)
;	    INT     21h
;   Error returns:
;	    AX = error_path_not_found
;	    AX = error_access_denied
;
;----------------------------------------------------------------------------

_$CHMOD:
	; 05/08/2018 - Retro DOS v3.0
	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
	MOV	DI,OPENBUF		; appropriate buffer
	push	ax
	push	cx			; save function and attributes
	MOV	SI,DX			; get things in appropriate places
	call	TransPathSet		; get correct path
	pop	cx
	pop	ax			; and get function and attrs back
	JC	short ChModErr		; errors get mapped to path not found
	push	ss			; set up for later possible calls
	pop	ds
	CMP	byte [CMETA],-1
	JNZ	short ChModErr
	;mov	byte [SATTRIB],16h
	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
	SUB	AL,1			; fast way to discriminate
	JB	short ChModGet		; 0 -> go get value
	JZ	short ChModSet		; 1 -> go set value
	;mov	byte [EXTERR_LOCUS],1
	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
	;mov	al,1
	mov	al,error_invalid_function ; bad value
	;jmp	SYS_RET_ERR
	jmp	short ChModE	
ChModGet:
	call	GET_FILE_INFO		; suck out the ol' info
	JC	short ChModE		; error codes are already set for ret
	call	Get_User_Stack		; point to user saved vaiables
	;mov	[SI+4],ax
	MOV	[SI+user_env.user_CX],AX  ; return the attributes
	;jmp	SYS_RET_OK		; say sayonara
	; 26/07/2019
	jmp	SYS_RET_OK_clc
ChModSet:
	MOV	AX,CX			; get attrs in position
	call	SET_FILE_ATTRIBUTE	; go set
	JC	short ChModE		; errors are set
	jmp	SYS_RET_OK
ChModErr:
	;mov	al, 3
	mov	al,error_path_not_found
ChModE:
	jmp	SYS_RET_ERR

;	BREAK <$UNLINK - delete a file entry>
;----------------------------------------------------------------------------
;
;**	$UNLINK - Delete a File
;
;
;	Assembler usage:
;	    LDS     DX, name
;	    IF VIA SERVER DOS CALL
;	     MOV     CX,SEARCH_ATTRIB
;	    MOV     AH, Unlink
;	    INT     21h
;
;	ENTRY	(ds:dx) = path name
;		(cx) = search_attribute, if via server_dos
;	EXIT	'C' clear if no error
;		'C' set if error
;		  (ax) = error code
;			= error_file_not_found
;			= error_access_denied
;
;----------------------------------------------------------------------------

_$UNLINK:
	push	cx			; Save possible CX input parm
	MOV	SI,DX			; Point at input string
	MOV	DI,OPENBUF		; temp spot for path
	call	TransPathSet		; go get normalized path
	pop	cx
	JC	short ChModErr		; badly formed path
	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
	JNZ	short NotFound
	push	ss
	pop	ds
	;mov	ch,6
	mov	ch,attr_hidden+attr_system ; unlink appropriate files
	call	SetAttrib
	call	DOS_DELETE		; remove that file
	JC	short UnlinkE 		; error is there
	jmp	SYS_RET_OK		; okey doksy
NotFound:
	;mov	al, 3
	MOV	AL,error_path_not_found
UnlinkE:
	jmp	SYS_RET_ERR		; bye

;BREAK <$RENAME - move directory entries around>
;----------------------------------------------------------------------------
;
;   Assembler usage:
;	    LDS     DX, source
;	    LES     DI, dest
;	    IF VIA SERVER DOS CALL
;	     MOV     CX,SEARCH_ATTRIB
;	    MOV     AH, Rename
;	    INT     21h
;
;   Error returns:
;	    AX = error_file_not_found
;	       = error_not_same_device
;	       = error_access_denied
;
;----------------------------------------------------------------------------

_$RENAME:
	; MSDOS 3.3 (& MSDOS 6.0)
	push	cx
	push	ds
	push	dx			; save source and possible CX arg
	PUSH	ES
	POP	DS			; move dest to source
	MOV	SI,DI			; save for offsets
	MOV	DI,RENBUF
	call	TransPathSet		; munge the paths
	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
	pop	si
	pop	ds
	pop	cx			; get back source and possible CX arg
epjc2:	
	JC	short ChModErr		; get old error
	CMP	byte [ss:CMETA],-1			;smr;SS Override
	JNZ	short NotFound
	push	cx			; Save possible CX arg
	MOV	DI,OPENBUF		; appropriate buffer
	call	TransPathSet		; wham
	pop	cx
	JC	short epjc2
	push	ss
	pop	ds
	CMP	byte [CMETA],-1
	JB	short NotFound

	; MSDOS 6.0
	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
	MOV	DI,OPENBUF		   ;AN000;;MS.
	PUSH	SS			   ;AN000;;MS.
	POP	ES			   ;AN000;;MS.es:di-> source
	XOR	AL,AL			   ;AN000;;MS.scan all CDS
rnloop: 				   ;AN000;
	call	GetCDSFromDrv		   ;AN000;;MS.
	JC	short dorn		   ;AN000;;MS.	end of CDS
	call	StrCmp			   ;AN000;;MS.	current dir ?
	JZ	short rnerr		   ;AN000;;MS.	yes
	INC	AL			   ;AN000;;MS.	next
	JMP	short rnloop		   ;AN000;;MS.
rnerr:					   ;AN000;
	ADD	SP,4			   ;AN000;;MS. pop thiscds
	;error	error_current_directory    ;AN000;;MS.
	mov	al,error_current_directory 
	jmp	SYS_RET_ERR
dorn:					   ;AN000;
	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??

	push	ss
	pop	ds

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ch,16h
	mov	ch,attr_directory+attr_hidden+attr_system
					; rename appropriate files
	call	SetAttrib
	call	DOS_RENAME		; do the deed
	JC	short UnlinkE 		; errors

	jmp	SYS_RET_OK


; 14/07/2018 - Retro DOS v3.0
; MSDOS 3.3 (& MSDOS 6.0)

;Break <$CreateNewFile - Create a new directory entry>
;----------------------------------------------------------------------------
;   CreateNew - Create a new directory entry.  Return a file handle if there
;	was no previous directory entry, and fail if a directory entry with
;	the same name existed previously.
;
;   Inputs:	DS:DX point to an ASCIZ file name
;		CX contains default file attributes
;   Outputs:	Carry Clear:
;		    AX has file handle opened for read/write
;		Carry Set:
;		    AX has error code
;   Registers modified: All
;----------------------------------------------------------------------------

_$CreateNewFile:
	push	cx			; Save attributes on stack
	MOV	CX,DOS_Create_New	; routine to call
	JMP	AccessSet		; use good ol' open

;**	BinToAscii - convert a number to a string.
;----------------------------------------------------------------------------
;	BinToAscii converts a 16 bit number into a 4 ascii characters.
;	This routine is used to generate temp file names so we don't spend
;	the time and code needed for a true hex number, we just use
;	A thorugh O.
;
;	ENTRY	(ax) = value
;		(es:di) = destination
;	EXIT	(es:di) updated by 4
;	USES	cx, di, flags
;----------------------------------------------------------------------------

; MSDOS 3.3
;BinToAscii:
;	mov     cx,4
;bta5:
;	push    cx
;	mov     cl,4
;	rol     ax,cl
;	push    ax
;	and     al,0Fh
;	add     al,'0'
;	cmp     al,'9'
;	jbe     short bta6
;	add     al,7
;bta6: 
;	stosb
;	pop     ax
;	pop     cx
;	loop    bta5
;	retn

; MSDOS 6.0
BinToAscii:
	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
bta5:	
	ROL	AX,CL			; move leftmost nibble into rightmost
	push	ax			; preserve remainder of digits
	AND	AL,0Fh			; grab low nibble
	ADD	AL,'A'			; turn into ascii
	STOSB				; drop in the character
	pop	ax			; (ax) = shifted number
	dec	ch
	jnz	short bta5		; process 4 digits
	retn

;Break	<$CreateTempFile - create a unique name>
;----------------------------------------------------------------------------
;   $CreateTemp - given a directory, create a unique name in that directory.
;	Method used is to get the current time, convert to a name and attempt
;	a create new.  Repeat until create new succeeds.
;
;   Inputs:	DS:DX point to a null terminated directory name.
;		CX  contains default attributes
;   Outputs:	Unique name is appended to DS:DX directory.
;		AX has handle
;   Registers modified: all
;----------------------------------------------------------------------------

_$CreateTempFile:
	;Enter
	push	bp
	mov	bp,sp

	;LocalVar    EndPtr,DWORD
	;LocalVar    FilPtr,DWORD
	;LocalVar    Attr,WORD

	sub	sp,10

	;test	cx,0FFD8h
	test	CX,~attr_changeable
	JZ	short OKatts		; Ok if no non-changeable bits set
;
; We need this "hook" here to detect these cases (like user sets one both of
; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
; below.  The code loops on error_access_denied, but if one of the non
; changeable attributes is specified, the loop COULD be infinite or WILL be
; infinite because CreateNewFile will fail with access_denied always.  Thus we
; need to detect these cases before getting to the loop.
;
	;mov	ax, 5
	MOV	AX,error_access_denied
	JMP	SHORT SETTMPERR

OKatts:
	;MOV	attr,CX 		; save attribute
	mov     [bp-10],cx
	;MOV	FilPtrL,DX		; pointer to file
	mov	[bp-8],dx
	;MOV	FilPtrH,DS
	mov	[bp-6],ds
	;MOV	EndPtrH,DS		; seg pointer to end of dir
	mov	[bp-2],ds
	PUSH	DS
	POP	ES			; destination for nul search
	MOV	DI,DX
	MOV	CX,DI
	NEG	CX			; number of bytes remaining in segment
	; MSDOS 6.0
	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
	JNZ	short okok		;AN000;MS. no
	;MOV	CX,-1			;AN000;MS.
	dec	cx  ; mov cx,-1
	;
okok:					;AN000;
	XOR	AX,AX			;AN000;
	REPNZ	SCASB			;AN000;
					;AN000;
	DEC	DI			; point back to the null
	MOV	AL,[ES:DI-1]		; Get char before the NUL
	call	PATHCHRCMP		; Is it a path separator?
	JZ	short SETENDPTR		; Yes
STOREPTH:
	MOV	AL,'\'
	STOSB				; Add a path separator (and INC DI)
SETENDPTR:
	;MOV	EndPtrL,DI		; pointer to the tail
	mov	[bp-4],dl
CreateLoop:
	push	ss			; let ReadTime see variables
	pop	ds
	push	bp
	call	READTIME		; go get time
	pop	bp
;
; Time is in CX:DX.  Go drop it into the string.
;
	;les	di,EndPtr		; point to the string
	les	di,[BP-4]
	mov	ax,cx
	call	BinToAscii		; store upper word
	mov	ax,dx
	call	BinToAscii		; store lower word
	xor	al,al
	STOSB				; nul terminate
	;LDS	DX,FilPtr		; get name
	lds	dx,[bp-8]
	;MOV	CX,Attr 		; get attr
	mov	cx,[bp-10]
	push	bp
	CALL	_$CreateNewFile		; try to create a new file
	pop	bp
	JNC	short CreateDone	; failed, go try again
;
; The operation failed and the error has been mapped in AX.  Grab the extended
; error and figure out what to do.
;
	;; MSDOS 3.3			; M049 - start
;;	mov	ax,[ss:EXTERR]				;smr;SS Override
;;	cmp	al,error_file_exists
;;	jz	short CreateLoop	; file existed => try with new name
;;	cmp	al,error_access_denied
;;	jz	short CreateLoop	; access denied (attr mismatch)

	; MSDOS 6.0
	;cmp	al,50h
	CMP	AL,error_file_exists	; Q: did file already exist
	JZ	short CreateLoop	; Y: try again
	;cmp	al,5
	CMP	AL,error_access_denied	; Q: was it access denied
	JNZ	short SETTMPERR		; N: Error out
					; Y: Check to see if we got this due
					;    to the network drive. Note that
					;    the redir will set the exterr
					;    to error_cannot_make if this is 
					;    so. 
	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
					; See if it's REALLY an att mismatch
	je	short SETTMPERR		; no, network error, stop
;M070
; If the user failed on an I24, we do not want to try again
;
	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
	je	short SETTMPERR		;yes, do not try again ;M070

	jmp	short CreateLoop	;attr mismatch, try again ;M070

;;	MOV	AL,error_access_denied	; Return this "extended" error
					; M049 - end
SETTMPERR:
	STC
CreateDone:
	;Leave
	mov	sp,bp
	pop	bp
	JC	short CreateFail
	jmp	SYS_RET_OK		; success!
CreateFail:
	jmp	SYS_RET_ERR

;
;   SetAttrib will set the search attribute (SAttrib) either to the normal
;   (CH) or to the value in CL if the current system call is through
;   serverdoscall.
;
;   Inputs:	fSharing == FALSE => set sattrib to CH
;		fSharing == TRUE => set sattrib to CL
;   Outputs:	none
;   Registers changed:	CX

SetAttrib:
	test	byte [SS:FSHARING],-1		;smr;SS Override
	jnz	short Set
	mov	cl,ch
Set:
	mov	byte [ss:SATTRIB],cl		;smr;SS Override
	retn

; 14/07/2018 - Retro DOS v3.0
; MSDOS 6.0

;Break	<Extended_Open- Extended open the file>
;----------------------------------------------------------------------------
; Input: AL= 0 reserved  AH=6CH
;	 BX= mode
;	 CL= create attribute  CH=search attribute (from server)
;	 DX= flag
;	 DS:SI = file name
;	 ES:DI = parm list
;			   DD  SET EA list (-1) null
;			   DW  n  parameters
;			   DB  type (TTTTTTLL)
;			   DW  IOMODE
; Function: Extended Open
; Output: carry clear
;		     AX= handle
;		     CX=1 file opened
;			2 file created/opened
;			3 file replaced/opened
;	  carry set: AX has error code
;----------------------------------------------------------------------------

;_$Extended_Open:			  ;AN000;
;	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
;	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
;	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
;	TEST	DX,reserved_bits_mask	  ;AN000;EO. reserved bits 0  ?
;	JNZ	short ext_inval2	  ;AN000;EO. no
;	MOV	AH,DL			  ;AN000;EO. make sure flag is right
;	CMP	DL,0			  ;AN000;EO. all fail ?
;	JZ	short ext_inval2	  ;AN000;EO. yes, error
;	AND	DL,exists_mask		  ;AN000;EO. get exists action byte
;	CMP	DL,2			  ;AN000;EO, > 02
;	JA	short ext_inval2	  ;AN000;EO. yes ,error
;	AND	AH,not_exists_mask	  ;AN000;EO. get no exists action byte
;	CMP	AH,10H			  ;AN000;EO. > 10
;	JA	short ext_inval2	  ;AN000;EO. yes error
;
;	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
;	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
;	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
;	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
;	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
;	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
;	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
;	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
;	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
;	MOV	AX,BX			  ;AN000;EO. ax= mode
;	JMP	SHORT goopen2		  ;AN000;;EO. do normal
;ext_inval2:				  ;AN000;;EO.
;	mov	al,error_invalid_function ;AN000;EO.. invalid function
;	jmp	SYS_RET_ERR
;error_return:				  ;AN000;EO.
;	retn				  ;AN000;EO.. return with error
;goopen2:				  ;AN000;
;	TEST	BX,int_24_error 	  ;AN000;EO.. disable INT 24 error ?
;	JZ	short goopen		  ;AN000;EO.. no
;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
;goopen:					  ;AN000;
;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
;	AND	word [SS:EXTOPEN_FLAG],0FFH  ;AN000;EO.create new ?;smr;SS Override
;	CMP	word [SS:EXTOPEN_FLAG],ext_exists_fail + ext_nexists_create ;AN000;FT.;smr;SS Override
;	JNZ	short chknext 		  ;AN000;;EO. no
;	call	_$CreateNewFile		  ;AN000;;EO. yes
;	JC	short error_return	  ;AN000;;EO. error
;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
;	JZ	short ok_return2	  ;AN000;;EO. yes
;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. creted/opened;smr;SS Override
;	JMP	short setXAttr		  ;AN000;;EO. set XAs
;ok_return2:
;	jmp	SYS_RET_OK		  ;AN000;;EO.
;chknext:
;	TEST	word [SS:EXTOPEN_FLAG],ext_exists_open ;AN000;;EO. exists open;smr;SS Override
;	JNZ	short exist_open	  ;AN000;;EO. yes
;	call	_$CREAT			  ;AN000;;EO. must be replace open
;	JC	short error_return	  ;AN000;;EO. return with error
;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
;	JZ	short ok_return2	  ;AN000;;EO. yes
;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. prsume create/open;smr;SS Override
;	TEST	byte [SS:EXTOPEN_ON],ext_file_not_exists ;AN000;;EO. file not exists ?;smr;SS Override
;	JNZ	short setXAttr		  ;AN000;;EO. no
;	MOV	word [SS:EXTOPEN_FLAG],action_replaced_opened ;AN000;;EO. replaced/opened;smr;SS Override
;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
;error_return2:
;	STC 				  ; Set Carry again to flag error ;AN001;
;	retn				  ;AN000;;EO. return with error
;					  ;AN000;
;exist_open:				  ;AN000;
;	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
;	jz	short noserver		  ;AN000;;EO. no
;	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
;noserver:
;	call	_$Open2			  ;AN000;;EO. do open
;	JNC	short ext_ok		  ;AN000;;EO.
;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
;	JZ	short error_return2	  ;AN000;;EO. return with error
;local_extopen:
;	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
;	JNZ	short error_return2	  ;AN000;;EO. no,
;	TEST	word [SS:EXTOPEN_FLAG],ext_nexists_create;AN000;;EO. want to fail;smr;SS Override
;	JNZ	short do_creat		  ;AN000;;EO. yes
;	JMP	short extexit 		  ;AN000;;EO. yes
;do_creat:
;	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
;	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
;	MOV	DX,SI			  ;AN000;;EO.
;	call	_$CREAT			  ;AN000;;EO. do create
;	JC	short extexit 		  ;AN000;;EO. error
;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened 
;					  ;AN000;;EO. is created/opened;smr;SS Override
;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
;
;ext_ok:
;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
;	JZ	short ok_return		  ;AN000;;EO. yes
;	MOV	[SS:EXTOPEN_FLAG],action_opened ;AN000;;EO.  opened;smr;SS Override
;setXAttr:
;	call	Get_User_Stack		  ;AN000;;EO.
;	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
;	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
;	POP	AX			  ;AN000;;EO.
;	MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
;
;ok_return:				  ;AN000;
;	jmp	SYS_RET_OK		  ;AN000;;EO.
;
;extexit2:				  ;AN000; ERROR RECOVERY
;	POP	BX			  ;AN000;EO. close the handle
;	PUSH	AX			  ;AN000;EO. save error code from set XA
;	CMP	word [SS:EXTOPEN_FLAG],action_created_opened 
;					  ;AN000;EO. from create;smr;SS Override
;	JNZ	short justopen		  ;AN000;EO.
;	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
;	LDS	DX,[SI]			  ;AN000;EO.
;	call	_$UNLINK 		  ;AN000;EO. delete the file
;	JMP	SHORT reserror		  ;AN000;EO.
;
;justopen:				  ;AN000;
;	call	$CLOSE			  ;AN000;EO. pretend never happend
;reserror:				  ;AN000;
;	POP	AX			  ;AN000;EO. restore error code from set XA
;	JMP	SHORT extexit		  ;AN000;EO.
;
;ext_file_unfound:			  ;AN000;
;	MOV	AX,error_file_not_found   ;AN000;EO.
;	JMP	SHORT extexit		  ;AN000;EO.
;ext_inval:				  ;AN000;
;	MOV	AX,error_invalid_function ;AN000;EO.
;extexit:
;	jmp	SYS_RET_ERR		  ;AN000;EO.

;============================================================================
; LOCK.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

;BREAK <$LockOper - Lock Calls>

;
;   Assembler usage:
;	    MOV     BX, Handle	       (DOS 3.3)
;	    MOV     CX, OffsetHigh
;	    MOV     DX, OffsetLow
;	    MOV     SI, LengthHigh
;	    MOV     DI, LengthLow
;	    MOV     AH, LockOper
;	    MOV     AL, Request
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation
;
;   Assembler usage:
;	    MOV     AX, 5C??	       (DOS 4.00)
;
;				    0? lock all
;				    8? lock write
;				    ?2 lock multiple
;				    ?3 unlock multiple
;				    ?4 lock/read
;				    ?5 write/unlock
;				    ?6 add (lseek EOF/lock/write/unlock)
;	    MOV     BX, Handle
;	    MOV     CX, count or size
;	    LDS     DX, buffer
;	    INT     21h
;
;   Error returns:
;	    AX = error_invalid_handle
;	       = error_invalid_function
;	       = error_lock_violation

_$LockOper:
	CMP	AL,1
	JA	short lock_bad_func

	PUSH	DI			       ; Save LengthLow
	call	SFFromHandle		       ; ES:DI -> SFT
	JNC	short lock_do 		       ; have valid handle
	POP	DI			       ; Clean stack
	;mov	al,6
	mov	al,error_invalid_handle
	jmp	SYS_RET_ERR

lock_bad_func:
	;mov	byte [ss:EXTERR_LOCUS],1
	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
	;mov	al,1
	mov	al,error_invalid_function
	jmp	SYS_RET_ERR

	; MSDOS 6.0 
; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
; Dead code deleted, MD, 23 Mar 90

lock_do:
	; MSDOS 3.3
	or	al,al
	pop	ax
	jz	short DOS_Lock
DOS_Unlock:
 	;test	word [es:di+5],8000h
	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JZ	short LOCAL_UNLOCK
	push    ax
	mov     ax,110Bh
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
			; BX = file handle, CX:DX = starting offset, SI = high word of size
			; STACK: WORD low word of size, ES:DI -> SFT for file
			; SFT DPB field -> DPB of drive containing file
			; Return: CF set error
	pop     bx
	jmp     short ValChk

LOCAL_UNLOCK:
	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
ValChk:
	JNC	short Lock_OK
lockerror:
	jmp	SYS_RET_ERR
Lock_OK:
	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
	jmp	SYS_RET_OK
DOS_Lock:
	;test	word [es:di+5],8000h
	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
	JZ	short LOCAL_LOCK
	;CallInstall NET_XLock,MultNET,10
	mov     ax, 110Ah
	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
			; BX = file handle, CX:DX = starting offset, SI = high word of size
			; STACK: WORD low word of size, ES:DI -> SFT
			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
			; Return: CF set error
	JMP	short ValChk

LOCAL_LOCK:
	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
	JMP	short ValChk

;lock_do:
;	; MSDOS 6.0
;	MOV	BX,AX				; save AX
;	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
;	MOV	[BP+LockBuf.Lock_position],DX	; set low offset
;	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
;	POP	CX				; get low length
;	MOV	[BP+LockBuf.Lock_length],CX	; set low length
;	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
;	MOV	CX,1				; one range
;
;;	PUSH	CS				;
;;	POP	DS				; DS:DX points to
;
;	push	ss
;	pop	ds
;
;	MOV	DX,BP				;   Lock_Buffer
;	TEST	AL,Unlock_all			; function 1
;	JNZ	short DOS_Unlock		; yes
;	JMP	short DOS_Lock			; function 0
;
;DOS_Unlock:
;	;test	word [es:di+5],8000h
;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	JZ	short LOCAL_UNLOCK
;	;CallInstall Net_Xlock,MultNET,10
;	mov     ax, 110Bh
;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
;			; BX = file handle, CX:DX = starting offset, SI = high word of size
;			; STACK: WORD low word of size, ES:DI -> SFT for file
;			; SFT DPB field -> DPB of drive containing file
;			; Return: CF set error
;
;	JMP	SHORT ValChk
;LOCAL_UNLOCK:
;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
;ValChk:
;	JNC	short Lock_OK
;lockerror:
;	jmp	SYS_RET_ERR
;Lock_OK:
;	MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
;	jmp	SYS_RET_OK
;DOS_Lock:
;	;test	word [es:di+5],8000h
;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
;	JZ	short LOCAL_LOCK
;	;CallInstall NET_XLock,MultNET,10
;	mov     ax,110Ah
;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
;			; BX = file handle, CX:DX = starting offset, SI = high word of size
;			; STACK: WORD low word of size, ES:DI -> SFT
;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
;			; Return: CF set error
;	JMP	short ValChk
;
;LOCAL_LOCK:
;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
;	JMP	short ValChk

; 14/07/2018 - Retro DOS v3.0
; LOC_CHECK
;MSDOS6.0 (& MSDOS3.3)

; Inputs:
;	Outputs of SETUP
;	[USER_ID] Set
;	[PROC_ID] Set
; Function:
;	Check for lock violations on local I/O
;	Retries are attempted with sleeps in between
; Outputs:
;    Carry clear
;	Operation is OK
;    Carry set
;	A lock violation detected
; Outputs of SETUP preserved

LOCK_CHECK:
	MOV	BX,[RetryCount]	; Number retries
LockRetry:
	; 26/07/2019
	push	bx		; save regs
	;push	ax ; MSDOS 6.0
	; MSDOS 3.3 (& msdos 6.0)
	Call	far [JShare+(8*4)] ; 8 = chk_block
	;pop	ax ; MSDOS 6.0
	pop	bx		; restrore regs
	jnc	short lc_ret_label ; There are no locks (retnc)
LockN:
	call	Idle		; wait a while
	DEC	BX		; remember a retry
	JNZ	short LockRetry	; more retries left...
	STC
lc_ret_label:
	retn

; 14/07/2018 - Retro DOS v3.0
; LOCK_VIOLATION
;MSDOS6.0 (& MSDOS3.3)

; Inputs:
;	[THISDPB] set
;	[READOP] indicates whether error on read or write
; Function:
;	Handle Lock violation on compatibility (FCB) mode SFTs
; Outputs:
;	Carry set if user says FAIL, causes error_lock_violation
;	Carry clear if user wants a retry
;
; DS, ES, DI, CX preserved, others destroyed

LOCK_VIOLATION:
	PUSH	DS
	PUSH	ES
	PUSH	DI
	PUSH	CX
	;mov	ax,21h
	MOV	AX,error_lock_violation
	;mov	byte [ALLOWED],18h
	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	LES	BP,[THISDPB]
	MOV	DI,1		; Fake some registers
	MOV	CX,DI
	;mov	dx,[es:bp+11]
	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
	call	HARDERR
	POP	CX
	POP	DI
	POP	ES
	POP	DS
	CMP	AL,1
	jz	short lc_ret_label ; 1 = retry, carry clear
	STC
	retn

; 14/07/2018 - Retro DOS v3.0

;	do a retz to return error

CheckShare:
	; MSDOS 6.0
	;push	ds			;smr;
	;;getdseg <ds>			; ds -> dosdata
	;push	cs
	;pop	ds
	;CMP	byte [fShare],0
	;pop	ds			;smr;
	;retn
	
	; MSDOS 3.3
	cmp	byte [cs:fShare],0
	retn

;============================================================================
; SHARE.ASM, MSDOS 6.0, 1991
;============================================================================
; 14/07/2018 - Retro DOS v3.0

; SHARE_CHECK

; Inputs:
;       [THISSFT] Points to filled in local file/device SFT for new
;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
;       [WFP_START] has full path of name
;       [USER_ID] Set
;       [PROC_ID] Set
; Function:
;       Check for sharing violations on local file/device access
; Outputs:
;    Carry clear
;       Sharing approved
;    Carry set
;       A sharing violation detected
;           AX is error code
; USES    ALL but DS

SHARE_CHECK:
	; 26/07/2019
	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
shchk_retn:
	retn

; SHARE_VIOLATION

; Inputs:
;       [THISDPB] Set
;       AX has error code
; Function:
;       Handle Sharing errors
; Outputs:
;       Carry set if user says FAIL, causes error_sharing_violation
;       Carry clear if user wants a retry
;
; DS, ES, DI preserved, others destroyed

SHARE_VIOLATION:
	PUSH    DS
	PUSH	ES
	PUSH    DI
	MOV     byte [READOP],0		; All share errors are reading
	;mov	byte [ALLOWED],18h
	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
	LES     BP,[THISDPB]
	MOV     DI,1			; Fake some registers
	MOV     CX,DI
	;mov	dx,[es:bp+16]
	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
	call	HARDERR
	POP     DI
	POP	ES
	POP     DS
	CMP     AL,1
	jz	short shchk_retn	; 1 = retry, carry clear
	STC
	retn

;   ShareEnd - terminate sharing info on a particular SFT/UID/PID.  This does
;       NOT perform a close, it merely asserts that the sharing information
;       for the SFT/UID/PID may be safely released.
;
;   Inputs:     ES:DI points to an SFT
;   Outputs:    None
;   Registers modified: all except DS,ES,DI

ShareEnd:
	; 26/07/2019
	call	far [JShare+(2*4)]	; 2 = MFTClose
	retn

;Break <ShareEnter - attempt to enter a node into the sharing set>

;
;   ShareEnter - perform a retried entry of a nodde into the sharing set.  If
;   the max number of retries is exceeded, we notify the user via int 24.
;
;   Inputs:     ThisSFT points to the SFT
;               WFP_Start points to the WFP
;   Outputs:    Carry clear => successful entry
;               Carry set => failed system call
;   Registers modified: all

ShareEnter:
	push	cx
retry:
	mov     cx,[RetryCount]
attempt:
	les     di,[THISSFT]		; grab sft
	XOR     AX,AX
 	;mov	[es:di+51],ax
	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
	push	cx
	call    SHARE_CHECK             ; attempt to enter into the sharing set
	pop	cx
	jnc	short done		; success, let the user see this
	call	Idle                    ; wait a while
	loop    attempt                 ; go back for another attempt
	call    SHARE_VIOLATION         ; signal the problem to the user
	jnc	short retry		; user said to retry, go do it
done:
	pop	cx
	retn

;----------------------------------------------------------------------------

;align 2 ; 05/09/2018 (Error!)

align 16 ; 08/09/2018 (OK.)

; 06/08/2018 - Retro DOS v3.0

;============================================================================
; MSINIT.ASM
;============================================================================
;
; MAIN ENTRY FOR DOS INITIALIZATION
;
	; 15/07/2018 - RetroDOS v3.0
	; (MSDOS 3.3, IBMDOS.COM, 1987)

SYSBUF:
IRETT:
	iret

	; 07/07/2018 - Retro DOS v3.0
	; Retro DOS v2.0 - 03/03/2018
DOSINIT:
	; Far call from SYSINIT
	; DX = Memory size in paragraphs
	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
	;	  (Retro DOS v2.0, 16/03/2018)
        CLI
        CLD
        MOV     [CS:ENDMEM],DX
        MOV     [CS:INITSP],SP
        MOV     [CS:INITSS],SS
        MOV     AX,CS
        MOV     SS,AX
        MOV     SP,INITSTACK
	; 08/08/2018
	MOV     [SS:NULDEV+2],DS
        MOV     [SS:NULDEV],SI	; DS:SI Points to CONSOLE Device
	; 15/07/2018
	; MSDOS 3.3 (IBMDOS.COM, 1987)
	; (Set INT 2Ah handler address to an 'IRET')
	push    ds
	xor     ax,ax
	mov     ds,ax
	mov     ax,IRETT
	mov     [2Ah*4],ax ; 00A8h
	mov     ax,cs
	mov     [(2Ah*4)+2],ax ; 00AAh
	pop     ds
	;
        CALL    CHARINIT	; initialize console driver

        PUSH	SI		; save pointer to header	
	PUSH	CS
        POP	ES
        ; 07/07/2018
	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
        MOV     AX,3
        STOSW           	; Refcount
        DEC     AL
        STOSW           	; Access rd/wr, compatibility
        XOR     AL,AL
        STOSB           	; attribute
	;mov	al,0C3h
	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
	STOSw			; flags
        mov	ax,si
        stosw			; device pointer in devptr	
        mov	ax,ds
	stosw
	xor	ax,ax	; 0
	stosw			; firclus
	stosw			; time
	stosw			; date
	dec	ax	; -1
	stosw			; size
	stosw
	inc	ax	; 0
	stosw			; position
	stosw
	;add	di,7
	add	di,SF_ENTRY.sf_name - SF_ENTRY.sf_cluspos
				; point at name
	;add	si,10
	add	si,SYSDEV.NAME	; sdevname
				; point to name
	mov	cx,4
	rep	movsw		; name
	mov	cl,3
	mov	al," "
	rep	stosb		; extension
	POP	SI		; get back pointer to header

				; mark device as CON I/O
	; 15/07/2018
        ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
	; 12/03/2018
	MOV     [SS:BCON],SI
        MOV     [SS:BCON+2],DS

CHAR_INIT_LOOP:
        LDS     SI,[SI]				; AUX device
        CALL    CHARINIT
       	;15/07/2018
	;test	byte [SI+4],8
	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
        JZ      SHORT CHAR_INIT_LOOP
	; 12/03/2018
        MOV     [SS:BCLOCK],SI
        MOV     [SS:BCLOCK+2],DS
        MOV     BP,MEMSTRT			; ES:BP points to DPB
PERDRV:
	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
        LDS     SI,[SI]				; Next device
        CMP     SI,-1
	JZ      SHORT CONTINIT

        CALL    CHARINIT

	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
	; (.. !DSK$IN' in MSBIO1.ASM)
	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)

        ; 15/07/2018
	;test	word [SI+4],8000h		; DEVTYP
        TEST    word [SI+SYSDEV.ATT],DEVTYP
	JNZ     SHORT PERDRV			; Skip any other character devs

        MOV	CL,[SS:CALLUNIT] ; 12/03/2018
	XOR     CH,CH
        ; 07/07/2018
	;MOV	[SI+10],CL		; Number of units in name field
	mov	[si+SYSDEV.NAME],cl	; sdevname        
	MOV     DL,[SS:NUMIO]	; 15/03/2018
	XOR     DH,DH
	ADD	[SS:NUMIO],CL	; 12/03/2018
	PUSH    DS
        PUSH    SI
	LDS	BX,[SS:CALLBPB]	; 12/03/2018
PERUNIT:
        MOV     SI,[BX]                 ; DS:SI Points to BPB
        INC     BX
        INC     BX                      ; On to next BPB
	;07/07/2018
        ;mov	[ES:BP+DPB.DRIVE],dl
	MOV     [ES:BP],DL
	;MOV	[ES:BP+1],DH
	MOV	[ES:BP+DPB.UNIT],DH
        PUSH    BX
        PUSH    CX
        PUSH    DX

        ;invoke	$SETDPB
        CALL	_$SETDPB

	; 07/07/2018
	;MOV	AX,[ES:BP+2]
	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
        ; 12/03/2018
	CMP	AX,[SS:MAXSEC]
	JBE     SHORT NOTMAX
	MOV	[SS:MAXSEC],AX
NOTMAX:
        POP     DX
        POP     CX
        POP     BX
        MOV     AX,DS                   ; save segment of bpb array
        POP     SI
        POP     DS
					; ds:si -> device header
					; store it in the corresponding dpb
	; 07/07/2018
        ;MOV	[ES:BP+18],SI
	mov	[ES:BP+DPB.DRIVER_ADDR],si
        ;MOV	[ES:BP+20],DS
	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds

        PUSH    DS			; save pointer to device header
        PUSH    SI
        INC     DH			; inc unit #
        INC     DL			; inc drive #
        MOV     DS,AX			; restore segment of BPB array
        ;add	bp,32 ;15/07/2018
	ADD     BP,DPBSIZ		; advance pointer to next dpb
	LOOP    PERUNIT			; process all units in each driver
        
	POP     SI			; restore pointer to device header
        POP     DS
	JMP	SHORT PERDRV		; process all drivers in chain

CONTINIT:
        PUSH    CS
        POP     DS
; Calculate true address of buffers, FATs, free space
        MOV     DI,BP           ; First byte after current DPBs
        MOV     BP,[MAXSEC]
        MOV     AX,SYSBUF	; = IRETT (15/07/2018)
        ; 07/07/2018
	;MOV	[BUFFSTRT],AX
        ADD     AX,BP           ; One I/O buffer
        ADD     AX,BUFINSIZ ; = 16
        MOV     [DPBHEAD],AX	; True start of DPBs
        MOV     DX,AX
        SUB     DX,SYSBUF	; = IRETT (15/07/2018)
        MOV     BP,DX
        ADD     BP,DI           ; Allocate buffer space
	;sub	bp,918 ; = ADJFAC for current DOSINIT (07/07/2018)
        SUB     BP,ADJFAC       ; True address of free memory
        PUSH    BP ; ###		
        MOV     DI,MEMSTRT	; Current start of DPBs
	;add	di,24
        ADD     DI,DPB.NEXT_DPB	; Point at dpb.next_dpb field
        MOV     CL,[NUMIO]
        XOR     CH,CH
TRUEDPBAD:
	;add	ax,32
        ADD     AX,DPBSIZ       ; Compute address of next DPB
        STOSW                   ; Set the link to next DPB
        ADD     DI,DPBSIZ-2     ; Point at next address
        LOOP    TRUEDPBAD
        SUB     DI,DPBSIZ       ; Point at last dpb.next_dpb field
        MOV     AX,-1
        STOSW                   ; End of list
        ADD     BP,15           ; True start of free space (round up to segment)
	; 15/07/2018
	;MOV	CL,4
        ;SHR	BP,CL           ; Number of segments for DOS resources
        rcr	bp,1
	mov	cl,3
	shr	bp,cl
	;
	MOV     DX,CS
        ADD     DX,BP           ; First free segment
	MOV	BX,15 ; 0Fh
	MOV	CX,[ENDMEM]
        MOV     BP,CS

; BP has segment of DOS (whether to load high or run in place)
; DX has program segment (whether after DOS or overlaying DOS)
; CX has size of memory in paragraphs (reduced by DOS size if HIGHMEM)
        MOV	[ENDMEM],CX
        MOV     ES,BP
        MOV     [ES:DSKCHRET+3],ES ; mov [ES:DOSEG_INIT],es
        XOR     AX,AX
        MOV     DS,AX
        MOV     ES,AX
	;mov	di,82h 
        MOV     DI,INTBASE+2
	; 15/07/2018
        MOV     AX,BP
	; Set INT 0 (divide by zero) handler
	mov     word [0],DIVOV
	mov     word [2],ax  ; = cs
	; Set INT 20h to INT 28h handler segments 
	mov	cx,17
	rep	stosw
	; DI points to INT 29h vector, offset
	add	di,6 
	; DI points to INT 2Ah vector, segment
	;Set  INT 2Ah to INT 3Fh handler segments		
	mov	cx,43
	rep	stosw
	; DI points to INT 40h vector, segment
	mov	di,80h
	; Set INT 20h to INT 28h vectors to their default handler offsets
	mov	ax,_IRET
	mov	cx,9
iset1:
	stosw
	add	di,2
	loop	iset1
	add	di,4
	; Set INT 2Ah to INT 3Fh vectors to their default handler offsets
	mov	cx,22
iset2:
	stosw
	add	di,2
	loop	iset2
	
	mov	ax,bp
	; Set	INT 2Fh handler offset to INT2F
	mov	word [2Fh*4],INT2F  ; 00BCh

	; set up entry point call at vectors 30-31h

        MOV     BYTE [ENTRYPOINT],mi_Long_JMP
        MOV     WORD [ENTRYPOINT+1],CALL_ENTRY
        MOV    [ENTRYPOINT+3],AX

	; Set	INT 20h, 21h, 22h, 23h handler offsets
        MOV     WORD [addr_int_abort],QUIT
        MOV     WORD [addr_int_command],COMMAND
        MOV     WORD [addr_int_terminate],100H
        MOV     [addr_int_terminate+2],DX
	; 15/07/2018 - Retro DOS v3.0
        MOV     WORD [addr_int_disk_read],ABSDRD   ; INT 25h
        MOV     WORD [addr_int_disk_write],ABSDWRT ; INT 26h
        MOV     WORD [addr_int_keep_process],STAY_RESIDENT ; INT 27h

	; 15/07/2018
	; MSDOS 3.3 (IBMDOS.COM, 1987)
	push	cs
	pop	ds
	push	cs
	pop	es
	; initialize the jump table for the sharer..
	;	(MSDOS 6.0, MSINIT.ASM, 1991, "patch_misc_segments")
	; MSDOS 3.3
	; (set JSharer jump table segments)
	mov	di,JShare
	mov	ax,cs
	mov	cx,15
iset3:
	add	di,2
	stosw
	loop	iset3

	; MSDOS 2.11, MSDOS 3.3
        MOV     AX,INITBLOCK
        ADD	AX,0Fh		; round to a paragraph
        MOV     CL,4
        SHR     AX,CL
        MOV     DI,DS
        ADD     DI,AX
        INC     DI
        MOV     [CurrentPDB],DI
        PUSH    BP ; ##
        PUSH    DX ; #		; Save COMMAND address
        MOV     AX,[ENDMEM]
        MOV     DX,DI

        ;invoke	SETMEM          ; Basic Header
	CALL	SETMEM
        PUSH	CS
        POP	DS
	;mov	di,24
        MOV     DI,PDB.JFN_TABLE
        XOR     AX,AX
        STOSW
        STOSB                   ; 0,1 and 2 are CON device
        MOV     AL,0FFH
	;mov	cx,17
        MOV     CX,FILPERPROC - 3 ; 17
        REP     STOSB           ; Rest are unused
        PUSH	CS
        POP	ES
        MOV     [SFT_ADDR+2],DS	; Must be set to print messages

	; 15/07/2018 - Retro DOS v3.0
	; MSDOS 3.3
	; (set country cdpg table segments)
	mov	si,COUNTRY_CDPG ; country_tab
	;mov	[es:si+79],es	; Ucase table segment
	;mov	[es:si+84],es	; File ucase table segment
	;mov	[es:si+89],es	; File char list segment
	;mov	[es:si+94],es	; Collate table segment
	;mov	[es:si+123],es	; Monocase routine segment
	mov	[si+79],es
	mov	[si+84],es
	mov	[Si+89],es
	mov	[si+94],es
	mov	[si+123],es
	; (set SysInitTable -sysinitvars and country_cdpg- segments)
	mov     si,SysInitTable
	;;mov	[es:si+6], es
	;;mov	[es:si+2], es
	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
	mov	[si+SYSI_EXT.Country_Tab+2],es
	mov	[si+SYSI_EXT.SysInitVars+2],es

	; (set FastOpen table FastRet segment)
	mov     si,FastTable
	;mov	[es:si+4],es
	;;mov	[es:si+8],es
	mov     [si+4],es
	;mov	[si+8],es
	; IBMDOS.COM (Offset 7259h), IBM PC DOS 3.30
	mov	word [FETCHI_TAG],5872h ; ? ('Xr')

	; 10/08/2018 - Retro DOS v3.0

	; MSDOS 2.11 (Retro DOS v2.0), MSDOS 3.3

; After this points the char device functions for CON will work for
; printing messages

	;;IF	NOT IBM
	;;IF	NOT ALTVECT
	;MOV	SI,HEADER
	;;invoke OUTMES
	;CALL	OUTMES
	;;PUSH	CS		; Outmes stomps on segments
	;;POP	DS
	;;PUSH	CS
	;;POP	ES
	;;ENDIF
	;;ENDIF

; Move the FATs into position
        POP     DX ; #			; Restore COMMAND address
        POP     BP ; ##
        POP     CX ; ###		; True address of free memory
        MOV     SI,MEMSTRT		; Place to move DPBs from
        MOV     DI,[DPBHEAD]		; Place to move DPBs to
        SUB     CX,DI                   ; Total length of DPBs
        CMP     DI,SI
        JBE     SHORT MOVJMP		; Are we moving to higher or 
					; lower memory?
        DEC     CX                      ; Move backwards to higher memory
        ADD     DI,CX
        ADD     SI,CX
        INC     CX
        STD
MOVJMP:
        MOV     ES,BP
        JMP     MOVDPB

CHARINIT:
	; 07/07/2018 - Retro DOS v3.0
        MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
        MOV	BYTE [SS:DEVCALL_REQUNIT],0
        MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
        MOV	WORD [SS:DEVCALL_REQSTAT],0
        PUSH	ES
        PUSH	BX
        PUSH	AX
        MOV	BX,DEVCALL
        PUSH	CS
        POP	ES
        CALL	DEVIOCALL2	
	POP	AX
        POP	BX
        POP	ES
        RETN

align 2
        ;;DB	80H DUP(?)
	;TIMES 	64 dw 0 ; 05/09/2018
	; 10/08/2018
	;times	128 dw 0
	; 12/08/2018
	;times	132 dW 0 ; ADJFAC = 918 ; 08/09/2018 (OK.)
	; 08/09/2018 
	times	136 db 0 ; ADJFAC = 790	; 08/09/2018 (OK.) 

INITSTACK:	; INITSTACK LABEL BYTE
	DW	0 ; DW ?

;MEMSTRT LABEL	WORD
MEMSTRT EQU	$

ADJFAC  EQU     MEMSTRT-SYSBUF

	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
	db 0
PcDosVersion:
	db 1Ah,'@@@### PC-DOS Version 3.30',0Dh,0Ah
	db 1Ah,0

        ;do_ext
;LAST	ENDS