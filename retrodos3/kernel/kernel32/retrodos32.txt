     1                                  ; ****************************************************************************
     2                                  ; RETRODOS.SYS (MSDOS 3.3 Kernel) - RETRO DOS v3.2 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 16/12/2022 (BugFix) - (Previous: 22/11/2022)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 25/05/2018 (Retro DOS 3.0), 29/06/2019 (Retro DOS 3.1)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.14  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm retrodos.asm -l retrodos.txt -o MSDOS.SYS)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; This assembly file has three parts: (BIOS+SYSINIT+KERNEL in one kernel file)
    13                                  ; 1a) IBMBIO.COM (IO.SYS) part from beginning to '%incbin MSDOS.BIN'
    14                                  ; 1b) SYSINIT part (at the end of IBMBIO.COM/IO.SYS) as '%incbin SYSINIT.BIN'
    15                                  ; 2) MSDOS.SYS (MSDOS 3.3 Kernel) as included binary file (MSDOS.BIN).
    16                                  ; source : 'retrodos.s' (main), 'sysinit.s' (included), 'msdos.s' (included)	
    17                                  ;
    18                                  ; (Note: RETRO DOS 3.0 boot sector code will load 'MSDOS.SYS' at 1000h:0000h)
    19                                  ; (Original MSDOS 3.3 IBMBIO.COM loads/runs its own init code at 0070h:0000h)
    20                                  
    21                                  ;=============================================================================
    22                                  ; Modified from 'retrodos3.s', Retro DOS v3.0 Kernel Source code
    23                                  ; by Erdogan Tan, 20/05/2019
    24                                  ;=============================================================================
    25                                  
    26                                  ; -------------------------------------------
    27                                  ; RETRODOS3.S - Retro DOS v3.0, 06/07/2019
    28                                  ; RETRODOS3.ASM - Retro DOS v3.1, 09/07/2019 
    29                                  ; RETRODOS32.ASM - Retro DOS v3.2, 09/07/2019 
    30                                  ; -------------------------------------------
    31                                  
    32                                  ; MSBIO (IO.SYS 3.3) source files:
    33                                  ; 	MSBIO1.ASM,MSCON.ASM,MSAUX.ASM,MSLPT.ASM,MSCLOCK.ASM,MSDISK.ASM
    34                                  ;	MSBIO2.ASM,MSHARD.ASM,MSINIT.ASM 
    35                                  ;	SYINIT1.ASM,SYSCONF.ASM,SYSINIT2.ASM,SYSIMES.ASM
    36                                  
    37                                  ;=============================================================================
    38                                  ; MSBIO
    39                                  ;=============================================================================
    40                                  ;msbio1+mscon+msaux+mslpt+msclock+msdisk+
    41                                  ;msbio2+mshard+msinit+sysinit1+sysconf+sysinit2+sysimes,
    42                                  ;msbio
    43                                  
    44                                  SECTOR_SIZE     equ     0200h		; size of a sector
    45                                  PAUSE_KEY       equ     7200h		; scancode + charcode of PAUSE key
    46                                  KEYBUF_NEXT     equ     041Ah		; next character in keyboard buffer
    47                                  KEYBUF_FREE     equ     041Ch		; next free slot in keyboard buffer
    48                                  KEYBUF          equ     041Eh		; keyboard buffer data
    49                                  LOGICAL_DRIVE   equ     0504h		; linear address of logical drive byte
    50                                  ;DOS_SEGMENT	equ     00BFh ; v1.1	; segment in which DOS will run
    51                                  DOS_SEGMENT	equ     00C4h		; Retro DOS v1.0 - 13/02/2018
    52                                  BIO_SEGMENT     equ     0060h		; segment in which BIO is running
    53                                  
    54                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "DISKPRM.INC" - 24/07/1987)
    55                                  ; The following structure defines the disk parameter table
    56                                  ; pointed to by Interrupt vector 1EH (location 0:78H)
    57                                  
    58                                  struc	DISK_PARMS
    59 00000000 ??                      .DISK_SPECIFY_1:  resb	1
    60 00000001 ??                      .DISK_SPECIFY_2:  resb	1
    61 00000002 ??                      .DISK_MOTOR_WAIT: resb  1	; Wait till motor off
    62 00000003 ??                      .DISK_SECTOR_SIZ: resb 	1	; Bytes/Sector (2 = 512)
    63 00000004 ??                      .DISK_EOT:	  resb  1	; Sectors per track (MAX)
    64 00000005 ??                      .DISK_RW_GAP:	  resb  1	; Read Write Gap
    65 00000006 ??                      .DISK_DTL:	  resb	1
    66 00000007 ??                      .DISK_FORMT_GAP:  resb  1	; Format Gap Length
    67 00000008 ??                      .DISK_FILL:	  resb  1	; Format Fill Byte
    68 00000009 ??                      .DISK_HEAD_STTL:  resb  1	; Head Settle Time (MSec)
    69 0000000A ??                      .DISK_MOTOR_STRT: resb  1	; Motor start delay
    70                                  .size:
    71                                  endstruc
    72                                  
    73                                  ROMStatus	equ	1
    74                                  ROMRead 	equ	2
    75                                  ROMWrite	equ	3
    76                                  ROMVerify	equ	4
    77                                  ROMFormat	equ	5  
    78                                  
    79                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "MSBDS.INC" - 24/07/1987)
    80                                  ; -------------------------------------------------------------------------
    81                                  ;  BDS is the Bios Data Structure.
    82                                  ;
    83                                  ;  There is one BDS for each logical drive in the system.  All the BDS's
    84                                  ;  are linked together in a list with the pointer to the first BDS being
    85                                  ;  found in START_BDS.	The BDS hold various values important to the disk
    86                                  ;  drive.  For example there is a field for last time accesses.  As actions
    87                                  ;  take place in the system the BDS are update to reflect the actions.
    88                                  ;  For example is there is a read to a disk the last access field for the
    89                                  ;  BDS for that drive is update to the current time.
    90                                  ;
    91                                  ; Values for various flags in BDS.Flags.
    92                                  ;
    93                                  
    94                                  fNon_Removable	    equ     01H 	;For non-removable media
    95                                  fChangeline	    equ     02H 	;If changeline supported on drive
    96                                  RETURN_FAKE_BPB     equ     04H 	; When set, don't do a build BPB
    97                                  					; just return the fake one
    98                                  GOOD_TRACKLAYOUT    equ     08H 	; The track layout has no funny sectors
    99                                  fI_Am_Mult	    equ     10H 	;If more than one logical for this physical
   100                                  fI_Own_Physical     equ     20H 	;Signify logical owner of this physical
   101                                  fChanged	    equ     40H 	;Indicates media changed
   102                                  SET_DASD_true	    equ     80H 	; Set DASD before next format
   103                                  fChanged_By_Format  equ    100h
   104                                  
   105                                  ;
   106                                  ; Various form factors to describe media
   107                                  ;
   108                                  
   109                                  ff48tpi 	    equ     0
   110                                  ff96tpi 	    equ     1
   111                                  ffSmall 	    equ     2
   112                                  ffHardFile	    equ     5
   113                                  ffOther 	    equ     7
   114                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
   115                                  ff288		    equ     9	; 2.88 MB drive
   116                                  ; Retro DOS v2.0 feature only !
   117                                  ff144		    equ	   10	; 1.44 MB drive			
   118                                  
   119                                  ; 26/05/2019
   120                                  
   121                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
   122                                  
   123                                  struc	BDS	; BDS_Type
   124 00000000 ????????                .link:		resd 1		; Link to next BDS
   125 00000004 ??                      .drivenum:	resb 1		; Physical drive number
   126 00000005 ??                      .drivelet:	resb 1		; DOS drive number
   127                                  
   128                                  	;We want to embed a BPB declaration here, but we can't initialize
   129                                  	;it properly if we do, so we duplicate the byte/word/dword architecture
   130                                  	;of the BPB declaration.
   131                                  .BPB:	
   132 00000006 ????                    .bytespersec:	resw 1		; bytes per sectors ; def = 512
   133 00000008 ??                      .secperclus:	resb 1		; sectors per cluster
   134 00000009 ????                    .resectors:	resw 1		; reserved sectors
   135 0000000B ??                      .fats:		resb 1		; number of fats
   136 0000000C ????                    .direntries:	resw 1		; number of root directory entries
   137 0000000E ????                    .totalsecs16:	resw 1		; total sectors on medium
   138 00000010 ??                      .media:		resb 1		; media descriptor byte ; def = 0F8h
   139 00000011 ????                    .fatsecs: 	resw 1		; number of fat sectors
   140 00000013 ????                    .secpertrack:	resw 1		; sectors per track
   141 00000015 ????                    .heads:		resw 1		; number of heads
   142                                  ;.hiddensecs:	resw 1		; hidden sectors
   143                                  ; MSDOS 6.0
   144 00000017 ????????                .hiddensecs:	resd 1		; hidden sectors	
   145 0000001B ????????                .totalsecs32:	resd 1		; big total sectors		
   146                                  ;
   147 0000001F ??                      .fatsiz:	resb 1		; flags...
   148 00000020 ????                    .opcnt:		resw 1		; open ref. count
   149                                  ;.volid:	resb 12		; volume ID of medium
   150 00000022 ??                      .formfactor:	resb 1		; form factor index
   151 00000023 ????                    .flags:		resw 1		; various flags ; def: 0020h
   152 00000025 ????                    .cylinders:	resw 1		; number of cylinders
   153                                  ;
   154                                  .R_BPB:  			; recommended BPB
   155 00000027 ????                    .rbytespersec:	resw 1		
   156 00000029 ??                      .rsecperclus:	resb 1
   157 0000002A ????                    .rresectors: 	resw 1
   158 0000002C ??                      .rfats:		resb 1
   159 0000002D ????                    .rdirentries:	resw 1
   160 0000002F ????                    .rtotalsecs16:	resw 1
   161 00000031 ??                      .rmedia: 	resb 1
   162 00000032 ????                    .rfatsecs:	resw 1
   163 00000034 ????                    .rsecpertrack: 	resw 1
   164 00000036 ????                    .rheads:	resw 1
   165 00000038 ????????                .rhidsecs: 	resd 1
   166 0000003C ????????                .rtotalsecs32: 	resd 1
   167 00000040 ????????????            .rreserved:	resb 6		; not used (reserved)
   168                                  ;
   169 00000046 ??                      .track:		resb 1		; last track accessed on drive
   170                                  .bdsm_ismini:
   171 00000047 ????                    .tim_lo:	resw 1		; time of last access. keep
   172                                  .bdsm_hidden_trks:
   173 00000049 ????                    .tim_hi:	resw 1		; these contiguous.
   174 0000004B <res Ch>                .volid:		resb 12		; volume id of medium
   175                                  	       ;db "NO NAME    ",0
   176 00000057 ????????                .vol_serial:	resd 1	; current volume serial number from boot record
   177 0000005B <res 9h>                .filesys_id:	resb 9	; current file system id from boot record
   178                                  	       ;db "FAT12   ",0
   179                                  .size:			
   180                                  endstruc
   181                                  
   182                                  BPBSize	equ	BDS.track - BDS.rbytespersec 
   183                                  				; size in bytes of RecBPB area in the BDS
   184                                  
   185                                  ; 11/07/2019 - Retro DOS v3.2 
   186                                  
   187                                  max_mini_dsk_num equ 23	; max # of mini disk ibmbio can support
   188                                  
   189                                  ; 29/12/2018
   190                                  ; Retro DOS v4.0
   191                                  ;
   192                                  ; MSDOS 6.0 - BOOTFORM.INC
   193                                  
   194                                  BOOT_SIZE	    EQU	 512
   195                                  EXT_BOOT_SIGNATURE  EQU	 29h ; 41 ; Extended boot signature
   196                                  
   197                                  struc EBPB ; EXT_BPB_INFO
   198 00000000 ????                    .BYTESPERSECTOR:    resw 1
   199 00000002 ??                      .SECTORSPERCLUSTER: resb 1
   200 00000003 ????                    .RESERVEDSECTORS:   resw 1
   201 00000005 ??                      .NUMBEROFFATS:	    resb 1
   202 00000006 ????                    .ROOTENTRIES:	    resw 1
   203 00000008 ????                    .TOTALSECTORS:	    resw 1
   204 0000000A ??                      .MEDIADESCRIPTOR:   resb 1
   205 0000000B ????                    .SECTORSPERFAT:	    resw 1
   206 0000000D ????                    .SECTORSPERTRACK:   resw 1
   207 0000000F ????                    .HEADS:		    resw 1
   208 00000011 ????????                .HIDDENSECTORS:	    resd 1
   209 00000015 ????????                .BIGTOTALSECTORS:   resd 1
   210                                  .size:
   211                                  endstruc
   212                                  
   213                                  ;EXT_PHYDRV, EXT_CURHD included in the header for OS2.
   214                                  struc EXT_BOOT ; EXT_IBMBOOT_HEADER
   215 00000000 ??????                  .JUMP:		resb 3
   216 00000003 ????????????????        .OEM:		resb 8
   217 0000000B <res 19h>               .BPB:		resb EBPB.size
   218 00000024 ??                      .PHYDRV:	resb 1
   219 00000025 ??                      .CURHD:		resb 1
   220 00000026 ??                      .SIG:		resb 1
   221 00000027 ????????                .SERIAL:	resd 1
   222 0000002B <res Bh>                .VOL_LABEL:	resb 11
   223 00000036 ????????????????        .SYSTEM_ID:	resb 8
   224                                  .size:
   225                                  endstruc
   226                                  
   227                                  %define BOOT_SIGNATURE	[BOOT_SIZE-2]
   228                                  
   229                                  ; 23/03/2018
   230                                  
   231                                  ;STATIC REQUEST HEADER (DEVSYM.INC, MSDOS 6.0, 1991)
   232                                  STRUC SRHEAD
   233 00000000 ??                      .REQLEN:	resb 1		;LENGTH IN BYTES OF REQUEST BLOCK
   234 00000001 ??                      .REQUNIT:	resb 1		;DEVICE UNIT NUMBER
   235 00000002 ??                      .REQFUNC:	resb 1		;TYPE OF REQUEST
   236 00000003 ????                    .REQSTAT:	resw 1		;STATUS WORD
   237 00000005 ????????????????        	       	resb 8		;RESERVED FOR QUEUE LINKS
   238                                  .size:
   239                                  endstruc
   240                                  
   241                                  ; GENERIC IOCTL REQUEST STRUCTURE (DEVSYM.INC, MSDOS 6.0, 1991)
   242                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
   243                                  ;
   244                                  struc IOCTL_REQ
   245                                  	       ;DB    (SIZE SRHEAD) DUP(?)
   246 00000000 <res Dh>                		resb SRHEAD.size	
   247                                  			    	; GENERIC IOCTL ADDITION.
   248 0000000D ??                      .MAJORFUNCTION:	resb 1		;FUNCTION CODE
   249 0000000E ??                      .MINORFUNCTION:	resb 1		;FUNCTION CATEGORY
   250 0000000F ????                    .REG_SI:	resw 1
   251 00000011 ????                    .REG_DI:	resw 1
   252 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
   253                                  endstruc
   254                                  
   255                                  ; GENERIC IOCTL CATEGORY CODES  (IOCTL.INC, MSDOS 6.0, 1991)
   256                                  IOC_OTHER	EQU	0	; Other device control J.K. 4/29/86
   257                                  IOC_SE		EQU	1	; SERIAL DEVICE CONTROL
   258                                  IOC_TC		EQU	2	; TERMINAL CONTROL
   259                                  IOC_SC		EQU	3	; SCREEN CONTROL
   260                                  IOC_KC		EQU	4	; KEYBOARD CONTROL
   261                                  IOC_PC		EQU	5	; PRINTER CONTROL
   262                                  IOC_DC		EQU	8	; DISK CONTROL (SAME AS RAWIO)
   263                                  
   264                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
   265                                  GEN_IOCTL_WRT_TRK   EQU   40H
   266                                  GEN_IOCTL_RD_TRK    EQU   60H
   267                                  GEN_IOCTL_FN_TST    EQU   20H	; USED TO DIFF. BET READS AND WRTS
   268                                  
   269                                  ;struc A_RETRYCOUNT  ; (IOCTL.INC, MSDOS 6.0, 1991)
   270                                  ;.RC_COUNT:	resw 	1
   271                                  ;endstruc
   272                                  
   273                                  ; 29/05/2019 - Retro DOS v4.0 (DEVSYM.INC, MSDOS 6.0, 1991)
   274                                  
   275                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   276                                  
   277                                  ;struc SYSDEV
   278                                  ; .NEXT:  resd 1	;POINTER TO NEXT DEVICE HEADER
   279                                  ; .ATT:	  resw 1	;ATTRIBUTES OF THE DEVICE
   280                                  ; .STRAT: resw 1	;STRATEGY ENTRY POINT
   281                                  ; .INT:	  resw 1	;INTERRUPT ENTRY POINT
   282                                  ; .NAME:  resb 8	;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   283                                  ; .size:
   284                                  ;endstruc
   285                                  
   286                                  ; 27/03/2018 - DEVSYM.INC - MSDOS 3.3 - 24/07/1987
   287                                  
   288                                  ;
   289                                  ; ATTRIBUTE BIT MASKS
   290                                  ;
   291                                  ; CHARACTER DEVICES:
   292                                  ;
   293                                  ; BIT 15 -> MUST BE 1
   294                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   295                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
   296                                  ;     12 -> UNUSED
   297                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
   298                                  ;     10 -> MUST BE 0
   299                                  ;      9 -> MUST BE 0
   300                                  ;      8 -> UNUSED
   301                                  ;      7 -> UNUSED
   302                                  ;      6 -> UNUSED
   303                                  ;      5 -> UNUSED
   304                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
   305                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
   306                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
   307                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
   308                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
   309                                  ;
   310                                  ; BLOCK DEVICES:
   311                                  ;
   312                                  ; BIT 15 -> MUST BE 0
   313                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   314                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
   315                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
   316                                  ;	    THE SAME PLACE.
   317                                  ;     12 -> UNUSED
   318                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
   319                                  ;     10 -> MUST BE 0
   320                                  ;      9 -> MUST BE 0
   321                                  ;      8 -> UNUSED
   322                                  ;      7 -> UNUSED
   323                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
   324                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
   325                                  ;      5 -> UNUSED
   326                                  ;      4 -> UNUSED
   327                                  ;      3 -> UNUSED
   328                                  ;      2 -> UNUSED
   329                                  ;      1 -> UNUSED
   330                                  ;      0 -> UNUSED
   331                                  ;
   332                                  
   333                                  DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   334                                  CHARDEV        EQU   8000H
   335                                  DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
   336                                  ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
   337                                  				    ;  COMP MEDIA.
   338                                  OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
   339                                  ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
   340                                  				    ;  NOT.  CURRENTLY BLOCK ONLY.
   341                                  DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
   342                                  				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
   343                                  				    ;  ENTRY POINTS, 0 IF NOT
   344                                  
   345                                  EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
   346                                  				    ;  THIS BIT IS RESERVED FOR FUTURE USE
   347                                  				    ;  TO EXTEND THE DEVICE HEADER BEYOND
   348                                  				    ;  ITS CURRENT FORM.
   349                                  
   350                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
   351                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
   352                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
   353                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
   354                                  
   355                                  ; 18/03/2019 - Retro DOS v4.0 (MSDOS 6.0)
   356                                  IOQUERY	       EQU   0080H	    ;Bit 7 - Supports generic IOCtl query M017
   357                                  
   358                                  DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
   359                                  				    ;DEVICE SUPPORTS SET/GET MAP OF
   360                                  				    ;LOGICAL DRIVES, AND SUPPORTS
   361                                  				    ;GENERIC IOCTL CALLS.
   362                                  				    ;FOR CHARACTER DEVICES, THIS
   363                                  				    ;DEVICE SUPPORTS GENERIC IOCTL.
   364                                  				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
   365                                  ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
   366                                  ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
   367                                  ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
   368                                  ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
   369                                  ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
   370                                  ; 23/07/2019 - Retro DOS v3.2
   371                                  EXTDRVR	       EQU   0002h	    ;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
   372                                  				    ; (MSDOS 6.0, DEVSYM.INC, 1991)
   373                                  
   374                                  ; 27/05/2018 - Retro DOS v3.0 
   375                                  ; [MSDOS 3.3, MSDISK.ASM]
   376                                  
   377                                  struc INT13FRAME
   378 00000000 ????                    .oldbp:	resw 1
   379 00000002 ????                    .oldax:	resw 1
   380 00000004 ????                    .oldbx:	resw 1
   381 00000006 ????                    .oldcx:	resw 1
   382 00000008 ????                    .olddx:	resw 1
   383 0000000A ????????                .olddd:	resd 1
   384 0000000E ????                    .oldf:	resw 1
   385                                  .size:
   386                                  endstruc
   387                                  
   388                                  ; 02/06/2018 - Retro DOS v3.0
   389                                  ; [MSDOS 3.3, BIOSTRUC.INC]
   390                                  
   391                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   392 00000000 ????                    .bios_SD_leng:		resw 1				  
   393 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   394                                  .bios_SD_scnd_modelbyte: 
   395 00000003 ??                      			resb 1					  
   396 00000004 ??                      			resb 1					  
   397 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   398 00000006 ????????                			resb 4					  
   399                                  endstruc
   400                                  							  
   401                                  ;*****************************************************************************
   402                                  
   403                                  KERNEL_SEGMENT	equ 0070h  ; Retro DOS v2.0 - 17/03/2018
   404                                  
   405                                  ;-----------------------------------------------------------------------------
   406                                  ; Start of code
   407                                  ;-----------------------------------------------------------------------------
   408                                  
   409                                          	[ORG 0]			; segment 0x0060
   410                                  
   411                                  ;-----------------------------------------------------------------------------
   412                                  ; MSDATA.INC - MSDOS 3.3 BIOS - 24/07/1987
   413                                  ;-----------------------------------------------------------------------------
   414                                  ; 21/03/2018 - Retro DOS v2.0
   415                                  
   416                                  ; 16/07/2019
   417                                  hdrv_pat:
   418                                  
   419                                  START$:
   420 00000000 E9FD2B                  		JMP	INIT		; START$ patch by init to point to
   421                                  					; hdrive BPB
   422                                  
   423                                  SYS_INIT_START EQU SYSINIT_START - START$
   424                                  KERNEL_BYTES EQU END_OF_KERNEL - START$
   425                                  MSDOS_BIN_ADDR EQU MSDOS_BIN_OFFSET - START$  ; 26/09/2019
   426                                  
   427                                  ; Retro DOS v2.0
   428                                  ;%define SYSINITSEG SYS_INIT_START >> 4 ; 26/03/2018
   429                                  ;%define MSDOS_BIN_SEGMENT MSDOS_BIN_ADDRESS >> 4 ; 26/03/2018 
   430                                  ;%define KERNEL_SIZE KERNEL_BYTES >> 1  ; 26/03/2018
   431                                  
   432                                  ; Retro DOS v4.0 - v3.1
   433                                  ;%define SYSINIT_SEG (KERNEL_SEGMENT+(SYS_INIT_START >> 4)) ; 11/05/2019
   434                                  %define MSDOS_BIN_SEGMENT (KERNEL_SEGMENT+(MSDOS_BIN_ADDR >> 4)) ; 11/05/2019 
   435                                  %define KERNEL_SIZE (KERNEL_BYTES >> 1) ; 24/04/2019
   436                                  
   437                                  ; 19/07/2019 - Retro DOS v3.2
   438                                  
   439                                  ;----------------------------------------------------------------------------
   440                                  ;
   441                                  ;		Command Jump Tables
   442                                  ;
   443                                  ;     These tables hold the entry points for the various service routines
   444                                  ; for the different drivers. The index in the table is the command code for
   445                                  ; that funcion plus two. For example the command code for Read (input) is 4,
   446                                  ; The 6th (4 plus 2) entry in the table DSKTBL is DSK$READ - the command to
   447                                  ; read a disk. Commands which do not exist for a device are filled with
   448                                  ; exit (e.g. MediaCheck for CONTBL). The first entry in the table is the
   449                                  ; largest command code implemented for that device. This value is used
   450                                  ; for error checking. If new command codes are added then the first entry
   451                                  ; in the table must be incremented.
   452                                  ;
   453                                  ;	BEWARE - These tables overlap somewhat! -c.p.
   454                                  ;
   455                                  ;----------------------------------------------------------------------------
   456                                  
   457                                  ;align 2
   458                                  
   459                                  		; 08/04/2018
   460                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
   461                                  		; ((Disassembler: IDA Pro Free))
   462                                  ;
   463                                  ; Disk:
   464                                  ;
   465                                  		;nop
   466                                  DSKTBL:
   467 00000003 18                      		DB	24		; This is the size of the table YUK!!!!
   468 00000004 [1A1A]                  		DW	DSK$INIT	; code	0: INIT
   469 00000006 [9D0B]                  		DW	MEDIA$CHK	; code	1: Media Check
   470 00000008 [550C]                  		DW	GET$BPB 	; code	2: BUILD BPB
   471 0000000A [5008]                  		DW	CMDERR		; code	3: IOCTL input
   472 0000000C [FA0E]                  		DW	DSK$READ	; code	4: INPUT
   473 0000000E [4C08]                  		DW	BUS$EXIT	; code	5: NONDESTRUCITVE INPUT, NO WAIT
   474 00000010 [6708]                  		DW	EXIT		; code	6: INPUT STATUS
   475 00000012 [6708]                  		DW	EXIT		; code	7: INPUT FLUSH
   476 00000014 [E80E]                  		DW	DSK$WRIT	; code	8: OUTPUT
   477 00000016 [DF0E]                  		DW	DSK$WRITV	; code	9: OUTPUT with verify
   478 00000018 [6708]                  		DW	EXIT		; code 10: OUTPUT STATUS
   479 0000001A [6708]                  		DW	EXIT		; code 11: OUTPUT FLUSH
   480 0000001C [5008]                  		DW	CMDERR		; code 12: IOCTL output
   481                                  ;TABLE_PATCH:
   482 0000001E [1E1B]                  		DW	DSK$OPEN	; code 13: DEVICE OPEN
   483 00000020 [2F1B]                  		DW	DSK$CLOSE	; code 14: DEVICE CLOSE
   484 00000022 [CF0E]                  		DW	DSK$REM 	; code 15: REMOVABLE MEDIA
   485 00000024 [6708]                  		DW	EXIT
   486 00000026 [6708]                  		DW	EXIT
   487 00000028 [6708]                  		DW	EXIT
   488 0000002A [5E14]                  		DW	GENERIC$IOCTL
   489 0000002C [6708]                  		DW	EXIT
   490 0000002E [6708]                  		DW	EXIT
   491 00000030 [6708]                  		DW	EXIT
   492 00000032 [9F18]                  		DW	IOCTL$GETOWN
   493 00000034 [C118]                  		DW	IOCTL$SETOWN
   494                                  ;
   495                                  ; Console:
   496                                  ;
   497                                  		;nop
   498 00000036 00                      		db	0
   499                                  CONTBL:
   500 00000037 0A                      		DB	10
   501 00000038 [6708]                  		DW	EXIT
   502 0000003A [6708]                  		DW	EXIT
   503 0000003C [6708]                  		DW	EXIT
   504 0000003E [5008]                  		DW	CMDERR
   505 00000040 [9308]                  		DW	CON$READ
   506 00000042 [BD08]                  		DW	CON$RDND
   507 00000044 [6708]                  		DW	EXIT
   508 00000046 [0109]                  		DW	CON$FLSH
   509 00000048 [1909]                  		DW	CON$WRIT
   510 0000004A [1909]                  		DW	CON$WRIT
   511 0000004C [6708]                  		DW	EXIT
   512                                  ;
   513                                  ; Auxilary:
   514                                  ;
   515                                  		;nop
   516 0000004E 00                      		db	0
   517                                  AUXTBL:
   518 0000004F 0A                      		DB	10
   519 00000050 [6708]                  		DW	EXIT
   520 00000052 [6708]                  		DW	EXIT
   521 00000054 [6708]                  		DW	EXIT
   522 00000056 [5008]                  		DW	CMDERR
   523 00000058 [2609]                  		DW	AUX$READ
   524 0000005A [4D09]                  		DW	AUX$RDND
   525 0000005C [6708]                  		DW	EXIT
   526 0000005E [8309]                  		DW	AUX$FLSH
   527 00000060 [8C09]                  		DW	AUX$WRIT
   528 00000062 [8C09]                  		DW	AUX$WRIT
   529 00000064 [6C09]                  		DW	AUX$WRST
   530                                  ;
   531                                  ; Clock:
   532                                  ;
   533                                  		;nop
   534 00000066 00                      		db	0
   535                                  TIMTBL:
   536 00000067 09                      		DB	9
   537 00000068 [6708]                  		DW	EXIT
   538 0000006A [6708]                  		DW	EXIT
   539 0000006C [6708]                  		DW	EXIT
   540 0000006E [5008]                  		DW	CMDERR
   541 00000070 [1A0B]                  		DW	TIM$READ
   542 00000072 [4C08]                  		DW	BUS$EXIT
   543 00000074 [6708]                  		DW	EXIT
   544 00000076 [6708]                  		DW	EXIT
   545 00000078 [C00A]                  		DW	TIM$WRIT
   546 0000007A [C00A]                  		DW	TIM$WRIT
   547                                  ;
   548                                  ; Printer:
   549                                  ;
   550                                  		;nop
   551 0000007C 00                      		db	0
   552                                  PRNTBL:
   553 0000007D 18                      		DB	24
   554 0000007E [6708]                  		DW	EXIT			;INIT
   555 00000080 [6708]                  		DW	EXIT
   556 00000082 [6708]                  		DW	EXIT
   557 00000084 [5008]                  		DW	CMDERR
   558 00000086 [5E08]                  		DW	EXIT$ZER		;INDICATE ZERO CHARS READ
   559 00000088 [4C08]                  		DW	BUS$EXIT
   560 0000008A [6708]                  		DW	EXIT
   561 0000008C [6708]                  		DW	EXIT
   562 0000008E [B009]                  		DW	PRN$WRIT
   563 00000090 [B009]                  		DW	PRN$WRIT
   564 00000092 [CC09]                  		DW	PRN$STAT
   565 00000094 [6708]                  		DW	EXIT
   566 00000096 [6708]                  		DW	EXIT
   567 00000098 [6708]                  		DW	EXIT
   568 0000009A [6708]                  		DW	EXIT
   569 0000009C [6708]                  		DW	EXIT
   570 0000009E [FC09]                  		DW	PRN$TILBUSY
   571 000000A0 [6708]                  		DW	EXIT
   572 000000A2 [6708]                  		DW	EXIT
   573 000000A4 [420A]                  		DW	PRN$GENIOCTL
   574 000000A6 [6708]                  		DW	EXIT
   575 000000A8 [6708]                  		DW	EXIT
   576 000000AA [6708]                  		DW	EXIT
   577 000000AC [5008]                  		DW	CMDERR
   578 000000AE [5008]                  		DW	CMDERR
   579                                  
   580                                  ; 19/07/2019 - Retro DOS v3.2
   581                                  ;-----------------------------------------------------------------------------
   582                                  
   583                                  ; PTRSAV - pointer save
   584                                  ;
   585                                  ; This variable holds the pointer to the Request Header passed by a program
   586                                  ; wishing to use a device driver. When the strategy routine is called it
   587                                  ; puts the address of the Request header in this variable and returns.
   588                                  
   589                                  	;EVENB
   590                                  align 2
   591                                  
   592                                  PTRSAV:
   593 000000B0 00000000                		DD	0
   594                                  
   595                                  AUXBUF:
   596 000000B4 00000000                		DB	0,0,0,0	; SET OF 1 BYTE BUFFERS FOR COM 1,2,3, AND 4
   597                                  
   598                                  
   599                                  ; 12/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987)
   600                                  
   601                                  	; EVENB
   602                                  ;align 2
   603                                  
   604                                  PrevOper:
   605 000000B8 0000                    		DW	0	; Holds ROM DISK INT request (i.e. Register AX).
   606                                  Number_Of_Sec:
   607 000000BA 00                      		DB	0	; Holds number of sectors to read on an ECC error
   608 000000BB 90                      align 2
   609                                  
   610                                  ; AUXNUM holds the number of the printer or AUX device requested. For
   611                                  ; example if printer 2 was called (PRN2$IN) AUXNUM is set to be one; with
   612                                  ; line printer 3 AUXNUM is set to 2. With this set the printer device driver
   613                                  ; can tell which printer to command applies to.
   614                                  ;
   615                                  ; WARNING!!!  These are addressed together in GETDX
   616                                  
   617                                  	;EVENB
   618                                  
   619                                  AUXNUM:
   620 000000BC 00                      		DB	0
   621 000000BD 00                      		DB	0
   622                                  
   623                                  ;align 2
   624                                  ;*****************************************************************************
   625                                  
   626                                  res_dev_list:	; 27/12/2018 (MSDOS 6.0, MSBIO1.ASM)
   627                                  
   628                                  ; 30/04/2019 - Retro DOS v4.0
   629                                  
   630                                  ; 29/06/2019 - Retro DOS v3.1
   631                                  
   632                                  ;
   633                                  ; Device Header for the CON Device Driver
   634                                  ;
   635                                  
   636                                  	;EVENB
   637                                  
   638                                  ;align 2
   639                                  
   640                                  CONHeader:
   641                                  		;DD	AUXDEV2
   642 000000BE [D000]                  		DW	AUXDEV2
   643 000000C0 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   644 000000C2 1380                    		DW	1000000000010011B	; Con in and con out + special
   645 000000C4 [9E07]                  		DW	STRATEGY		; Strategy entry point
   646 000000C6 [A907]                  		DW	CON$IN			; interrupt entry point
   647 000000C8 434F4E2020202020        		DB	'CON     '              ; device name
   648                                  
   649                                  ;
   650                                  ; Device Header for device "AUX"
   651                                  ;
   652                                  
   653                                  	;EVENB
   654                                  ;align 2
   655                                  
   656                                  AUXDEV2:					;HEADER FOR DEVICE "AUX"
   657                                  		;DD	PRNDEV2
   658 000000D0 [E200]                  		DW	PRNDEV2
   659 000000D2 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   660 000000D4 0080                    		DW	1000000000000000B	; attribute word, character device
   661 000000D6 [9E07]                  		DW	STRATEGY		; device strategy routine
   662 000000D8 [AF07]                  		DW	AUX0$IN 		; device interrupt routine
   663 000000DA 4155582020202020        		DB	'AUX     '              ; device name
   664                                  
   665                                  ;
   666                                  ; Device Header for device PRN
   667                                  ;
   668                                  
   669                                  	;EVENB
   670                                  ;align 2
   671                                  
   672                                  PRNDEV2:					 ;HEADER FOR DEVICE "PRN"
   673                                  		;DD	TIMDEV
   674 000000E2 [F400]                  		DW	TIMDEV
   675 000000E4 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   676 000000E6 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   677 000000E8 [9E07]                  		DW	STRATEGY
   678 000000EA [CA07]                  		DW	PRN0$IN
   679 000000EC 50524E2020202020        		DB	'PRN     '
   680                                  
   681                                  ;
   682                                  ; Device Header for device CLOCK$
   683                                  ;
   684                                  
   685                                  	;EVENB
   686                                  ;align 2
   687                                  
   688                                  TIMDEV:
   689                                  		;DD	DSKDEV
   690 000000F4 [0601]                  		DW	DSKDEV
   691 000000F6 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   692 000000F8 0880                    		DW	1000000000001000B
   693 000000FA [9E07]                  		DW	STRATEGY
   694 000000FC [F007]                  		DW	TIM$IN
   695 000000FE 434C4F434B242020        		DB	'CLOCK$  '
   696                                  
   697                                  ;
   698                                  ; Device Header for disk devices
   699                                  ;
   700                                  ;	Device attribute bits:
   701                                  ;		Bit 6 - DOS 3.2 Bit
   702                                  ;
   703                                  
   704                                  	;EVENB
   705                                  ;align 2
   706                                  
   707                                  DSKDEV:
   708                                  		;DD	COM1DEV
   709 00000106 [1801]                  		DW	COM1DEV
   710 00000108 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   711                                  		;DW	0000100001000000B	; DOS 3.2
   712                                  		; 27/07/2019 - Retro DOS v3.2
   713                                  		;DW	0000100011000010B ; 842h+IOQUERY ; MSDOS 6.0
   714 0000010A 4208                    		DW	0000100001000010B ; 842h ; Retro DOS v3.2	
   715 0000010C [9E07]                  		DW	STRATEGY		; strategy routine
   716 0000010E [F607]                  		DW	DSK$IN			; Interrupt entry point
   717                                  
   718                                  ;
   719                                  ; maximum number of drives
   720                                  ;
   721                                  
   722                                  DRVMAX:
   723 00000110 04                      		DB	4
   724                                  
   725                                  ; 25/05/2018 - Retro DOS 3.0
   726 00000111 FE                      STEP_DRV:	DB	-2
   727                                  ; 17/07/2019 - Retro DOS v3.2
   728                                  ;PHYS_DRV:	DB	0
   729                                  
   730                                  ; 11/06/2018 - Retro DOS 3.0
   731 00000112 00                      fHave96:	db	0
   732 00000113 00                      fHaveK09:	db	0
   733 00000114 00                      Single:		db	0 ; 13/06/2018
   734 00000115 00                      fSetOwner:	db	0
   735 00000116 00                      NEW_ROM:	db	0 ; MSDOS 3.3
   736                                  ; 17/07/2019
   737                                  ;Secrete_Code:	dw	'kj'		;Code for 3.30.
   738                                  
   739                                  ; 19/07/2019
   740                                  
   741                                  ;
   742                                  ; Last drive accessed
   743                                  ;
   744                                  
   745                                  		; 09/04/2018
   746                                  ;MEDIACHK_DRV:  ;; 13/04/2018
   747                                  ;		DB	0  ; 25/05/2018 
   748                                  		
   749                                  ;TIM_LO:
   750                                  ;		Dw	0FFFFh
   751                                  ;TIM_HI:
   752                                  ;		Dw	0FFFFh
   753                                  ;WRTVERIFY:
   754                                  ;RFLAG:
   755                                  ;		DB	ROMRead		;2 for read, 3 for write
   756                                  ;VERIFY:
   757                                  ;		DB	0		;1 if verify after write
   758                                  ;Single:
   759                                  ;		DB	0
   760                                  ;CURSECBUF:
   761                                  ;		DB	0
   762                                  ;SECCNT:
   763                                  ;		DW	0
   764                                  ;HARDNUM:
   765                                  ;		DB	99		;logical drive number of first hardfile	
   766                                  ;DRVNUM:
   767                                  ;		DB	0
   768                                  ;CURHD:
   769                                  ;		DB	0
   770                                  ;CURSEC:
   771                                  ;		DB	0
   772                                  ;CURTRK:
   773                                  ;		DW	0
   774                                  ;SPSAV:
   775                                  ;		DW	0
   776                                  
   777                                  ;
   778                                  ; Device Header for device "COM1"
   779                                  ;
   780                                  
   781                                  	;EVENB
   782                                  
   783 00000117 90                      align 2
   784                                  
   785                                  COM1DEV:
   786                                  		;DD	LPT1DEV
   787 00000118 [2A01]                  		DW	LPT1DEV
   788 0000011A 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   789 0000011C 0080                    		DW	1000000000000000B ; attribute word, character device
   790 0000011E [9E07]                  		DW	STRATEGY	; device strategy routine
   791 00000120 [AF07]                  		DW	AUX0$IN 	; device interrupt routine
   792 00000122 434F4D3120202020        		DB	'COM1    '	; device name
   793                                  
   794                                  ;
   795                                  ; Device Header for device LPT1
   796                                  ;
   797                                  
   798                                  	;EVENB
   799                                  ;align 2
   800                                  
   801                                  LPT1DEV:
   802                                  		;DD	LPT2DEV
   803 0000012A [3C01]                  		DW	LPT2DEV
   804 0000012C 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   805 0000012E 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   806 00000130 [9E07]                  		DW	STRATEGY
   807 00000132 [D007]                  		DW	PRN1$IN ; 03/08/2019
   808 00000134 4C50543120202020        		DB	'LPT1    '
   809                                  
   810                                  ;
   811                                  ; Device Header for device LPT2
   812                                  ;
   813                                  
   814                                  	;EVENB
   815                                  ;align 2
   816                                  LPT2DEV:
   817                                  		;DD	LPT3DEV
   818 0000013C [4E01]                  		DW	LPT3DEV
   819 0000013E 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   820 00000140 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   821 00000142 [9E07]                  		DW	STRATEGY
   822 00000144 [D807]                  		DW	PRN2$IN ; 03/08/2019
   823 00000146 4C50543220202020        		DB	'LPT2    '
   824                                  
   825                                  ; 18/07/2019 - Retro DOS v3.2
   826                                  ; 11/06/2018 - Retro DOS v3.0 (MSDOS 3.3, MSDATA.INC, 24/07/1987) 
   827                                  ;
   828                                  ;	;EVENB
   829                                  ;align 2
   830                                  ;OLD13:
   831                                  ;		db	'5986'		;Code for 3.30
   832                                  ;ORIG13:
   833                                  ;		db	'21',0,0	;Code for 3.30
   834                                  
   835                                  ;
   836                                  ; Device Header for device LPT3
   837                                  ;
   838                                  
   839                                  	;EVENB
   840                                  ;align 2
   841                                  
   842                                  LPT3DEV:
   843                                  		;DD	COM2DEV
   844 0000014E [6001]                  		DW	COM2DEV
   845 00000150 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   846 00000152 40A0                    		DW	CHARDEV + OUTTILBUSY + DEV320
   847 00000154 [9E07]                  		DW	STRATEGY
   848 00000156 [E007]                  		DW	PRN3$IN ; 03/08/2019
   849 00000158 4C50543320202020        		DB	'LPT3    '
   850                                  
   851                                  		; 25/05/2018
   852                                  ;
   853                                  ; Device Header for device "COM2"
   854                                  ;
   855                                  
   856                                  	;EVENB
   857                                  
   858                                  ;align 2
   859                                  
   860                                  COM2DEV:
   861                                  		;DD	COM3DEV
   862 00000160 [7201]                  		DW	COM3DEV
   863 00000162 7000                    		DW	KERNEL_SEGMENT
   864 00000164 0080                    		DW	1000000000000000B	; attribute word, character device
   865 00000166 [9E07]                  		DW	STRATEGY		; device strategy routine
   866 00000168 [B507]                  		DW	AUX1$IN 		; device interrupt routine
   867 0000016A 434F4D3220202020        		DB	'COM2    '              ; device name
   868                                  
   869                                  ;;Rev 3.30 Modification
   870                                  ;
   871                                  ; Device header for device "COM3"
   872                                  ;
   873                                  
   874                                  	;EVENB
   875                                  
   876                                  ;align 2 
   877                                  
   878                                  COM3DEV:
   879                                  		;DD	COM4DEV
   880 00000172 [8401]                  		DW	COM4DEV
   881 00000174 7000                    		DW	KERNEL_SEGMENT
   882 00000176 0080                    		DW	1000000000000000b	; character device attribute
   883 00000178 [9E07]                  		DW	STRATEGY
   884 0000017A [BB07]                  		DW	AUX2$IN			; com3 == aux2
   885 0000017C 434F4D3320202020        		DB	'COM3    '
   886                                  ;
   887                                  ; Device header for device "COM4"
   888                                  ;
   889                                  
   890                                  	;EVENB
   891                                  
   892                                  ;align 2 
   893                                  
   894                                  COM4DEV:
   895 00000184 FFFF                    		DW	-1
   896 00000186 7000                    		DW	KERNEL_SEGMENT
   897 00000188 0080                    		DW	1000000000000000b	; character device attribute
   898 0000018A [9E07]                  		DW	STRATEGY
   899 0000018C [C107]                  		DW	AUX3$IN			; com4 == aux3
   900 0000018E 434F4D3420202020        		DB	'COM4    '
   901                                  
   902                                  ; 19/07/2019 - Retro DOS v3.2
   903                                  ;----------------------------------------------------------------------------
   904                                  ; 29/06/2019 - Retro DOS v3.1
   905                                  
   906                                  ; Hard-wire the link to the next Int2f handler.
   907                                  ;;Rev 3.30 Modification
   908                                  		
   909                                  		;EVENB
   910                                  align 2
   911                                  
   912                                  NEXT2F_13:
   913                                  		; 13/06/2018
   914 00000196 [EF19]                  		DW	INT2F_DISK		; MSBIO2.ASM
   915 00000198 7000                    		DW	KERNEL_SEGMENT
   916                                  
   917                                  ;----------------------------------------------------------------------------
   918                                  ; 19/07/2019 - Retro DOS v3.2
   919                                  
   920                                  ;
   921                                  ; Start of linked list of BDS's
   922                                  ;
   923                                  
   924                                  		;EVENB
   925                                  ;align 2
   926                                  
   927                                  START_BDS:
   928                                  		; 13/06/2018
   929                                         		;Dw	BDS1			;START OF BDS LINKED LIST.
   930 0000019A [D003]                  		dw	bds1; 16/07/2019
   931 0000019C 7000                    		dw	KERNEL_SEGMENT
   932                                  
   933                                  ; Some floppy drives do not have changeline support. The result is a
   934                                  ; large amount of inefficiency in the code. A media-check always returns
   935                                  ; "I don`t know". This cause DOS to reread the FAT on every access and
   936                                  ; always discard any cached data.
   937                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
   938                                  ; The following three items are used to do this. The logical door latch is
   939                                  ; based on the premise that it is not physically possible to change floppy
   940                                  ; disks in a drive in under two seconds (most people take about 10). The
   941                                  ; logical door latch is implemented by saving the time of the last successful
   942                                  ; disk operation (in the value TIM_DRV). When a new request is made the
   943                                  ; current time is compared to the saved time. If less than two seconds have
   944                                  ; passed then the value "No Change" is returned. If more than two seconds
   945                                  ; have passed the value "Don't Know" is returned.
   946                                  ;    There is one complecation to this algorithm. Some programs change the
   947                                  ; value of the timer. In this unfortunate case we have an invalid timer.
   948                                  ; This possibility is detected by counting the number of disk operations
   949                                  ; which occur without any time passing. If this count exceeds the value of
   950                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
   951                                  ; Know". The variable "AccessCount" is used to keep track of the number
   952                                  ; of disk operation which occur without the time changing.
   953                                  ;
   954                                  
   955                                  AccessCount:
   956 0000019E 00                      		DB	0		; number of times media check called
   957                                  TIM_DRV:
   958 0000019F FF                      		DB	-1		; time when last disk I/O was performed
   959                                  ; 17/07/2019
   960                                  ;FlagBits:
   961                                  ;		DW	0		; Bits to set in flag field when doing
   962                                  					; a Set_Changed_DL
   963                                  MedByt:
   964 000001A0 00                      		DB	0		; hold media byte from floppy
   965                                  
   966                                  ;		;EVENB
   967 000001A1 90                      align 2
   968                                  		; 13/06/2018
   969                                  WRTVERIFY:
   970                                  RFLAG:
   971 000001A2 02                      		DB	ROMRead		;2 for read, 3 for write
   972                                  VERIFY:
   973 000001A3 00                      		DB	0		;1 if verify after write
   974                                  SECCNT:
   975 000001A4 0000                    		DW	0
   976                                  ;HARDNUM:
   977                                  ;		DB	99		;logical drive number of first hardfile
   978                                  ; 16/07/2019
   979 000001A6 01                      dsktnum: 	db	1		; number of diskette drives	
   980                                  
   981                                  ;
   982                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
   983                                  ; have to be made to read the diskette. Consequently a large head settle
   984                                  ; time was always used in the I/O operations.  To get around this problem
   985                                  ; we need to continually adjust the head settle time.  The following
   986                                  ; algorithm is used:
   987                                  ;
   988                                  ;   Get the current head settle value.
   989                                  ;   If it is 1, then
   990                                  ;	set slow = 15
   991                                  ;   else
   992                                  ;	set slow = value
   993                                  ;   ...
   994                                  ;   if we are seeking and writing then
   995                                  ;	use slow
   996                                  ;   else
   997                                  ;	use fast
   998                                  ;   ...
   999                                  ;   restore current head settle value
  1000                                  ;
  1001                                  
  1002                                  MotorStartup:
  1003 000001A7 00                      		DB	0			; value from table
  1004                                  SettleCurrent:
  1005 000001A8 00                      		DB	0			; value from table
  1006                                  SettleSlow:
  1007 000001A9 00                      		DB	0			; slow settle value
  1008                                  NextSpeed:
  1009 000001AA 00                       		DB	0			; value of speed to be used
  1010                                  Save_head_sttl:
  1011 000001AB 00                      		DB	0			;used by READ_SECTOR routine
  1012                                  EOT:
  1013 000001AC 09                      		DB	9
  1014                                  
  1015                                  ; 11/06/2018
  1016                                  
  1017                                  ;
  1018                                  ; pointer to Disk Parameter Table
  1019                                  ;
  1020                                  ;
  1021                                  ;		;EVENB
  1022 000001AD 90                      align 2
  1023                                  DPT:
  1024 000001AE 00000000                		dd	0
  1025                                  
  1026                                  ; 13/06/2018
  1027                                  ; 23/03/2018
  1028                                  ;
  1029                                  ; The following two sets of variables are used to hold values for
  1030                                  ; disk I/O operations
  1031                                  ; Keep the next two items contiguous - see IOCTL_Block for reason
  1032                                  
  1033                                  CURSEC:	
  1034 000001B2 00                      		DB	0			; current sector
  1035                                  CURHD:
  1036 000001B3 00                      		DB	0			; current head
  1037                                  CURTRK:
  1038 000001B4 0000                    		DW	0			; current track
  1039                                  SPSAV:
  1040 000001B6 0000                    		DW	0			; save the stack pointer
  1041                                  
  1042                                  ;
  1043                                  ; The following are used for IOCTL function calls
  1044                                  ;
  1045                                  
  1046                                  ; 11/06/2018 - Retro DOS v3.0
  1047                                  FORMT_EOT:
  1048 000001B8 08                      		DB	8			; EOT used for format
  1049                                  HDNUM:
  1050 000001B9 00                      		DB	0			; Head number
  1051                                  TRKNUM:
  1052 000001BA 0000                    		DW	0			; Track being manipulated
  1053                                  GAP_PATCH:
  1054 000001BC 50                      		DB	50h			; Format gap patched into DPT
  1055                                  
  1056                                  ;
  1057                                  ; Disk errors returned from the IBM rom
  1058                                  ;
  1059                                  
  1060 000001BD CC                      ERRIN:		db	0CCh ; MSDOS 6.0 ; write fault error  ; 17/07/2019
  1061 000001BE 80                      		DB	80H			; no response
  1062 000001BF 40                      		DB	40H			; seek failure
  1063 000001C0 10                      		DB	10H			; bad CRC
  1064 000001C1 08                      		DB	8			; DMA overrun
  1065 000001C2 06                      		DB	6			; media change
  1066 000001C3 04                      		DB	4			; sector not found
  1067 000001C4 03                      		DB	3			; write attempt to write-protect disk
  1068                                  LSTERR:
  1069 000001C5 00                      		DB	0			; all other errors
  1070                                  
  1071                                  ;
  1072                                  ; returned error code corresponding to above errors
  1073                                  ;
  1074                                  
  1075 000001C6 0A                      ERROUT:		db	10   ; MSDOS 6.0 ; write fault error  ; 17/07/2019
  1076 000001C7 02                      		DB	2			; no response
  1077 000001C8 06                      		DB	6			; seek failure
  1078 000001C9 04                      		DB	4			; bad CRC
  1079 000001CA 04                      		DB	4			; DMA overrun
  1080 000001CB 0F                      		DB	15			; invalid media change
  1081 000001CC 08                      		DB	8			; sector not found
  1082 000001CD 00                      		DB	0			; write attempt on write-protect disk
  1083 000001CE 0C                      		DB	12			; general error
  1084                                  
  1085                                  NUMERR	EQU	ERROUT-ERRIN
  1086                                  
  1087 000001CF 90                      align 2
  1088                                  
  1089                                  ;-------------------------------------------------------------
  1090                                  ;
  1091                                  ; DiskSector is a 512 byte sector into which the boot sector
  1092                                  ; is read. It is also used as read sector for DMA check for
  1093                                  ; hard disk.
  1094                                  
  1095                                  ; 10/07/2019 - Retro DOS v3.2
  1096                                  
  1097                                  DiskSector:
  1098 000001D0 00<rep 3Eh>             		times	EXT_BOOT.size db 0
  1099 0000020E 00<rep 1C2h>            		times	512-($-DiskSector) db 0
  1100                                  
  1101                                  ; 29/06/2019 - Retro DOS v3.1
  1102                                  
  1103                                  ; 25/05/2018 (04/04/2018)
  1104                                  
  1105                                  ;---------------------------------------------------------------------
  1106                                  ;
  1107                                  ;	The "BDS"'s contain information for each drive in the system.
  1108                                  ;  There is one BDS for each logical drive in the system. The BDS's
  1109                                  ;  are all linked together in a chain. The BDS contain various values
  1110                                  ;  important to the disk drive. Various values are updated whenever actions
  1111                                  ;  are performed. For example if a drive is read from the last time
  1112                                  ;  accessed fields are updated to the current time.
  1113                                  ;	Initial values:
  1114                                  ;    *	Sectors/Alloc. unit in BPB initially set to -1 to signify that
  1115                                  ;	the BPB has not been filled.
  1116                                  ;    *	Link is set to -1 to signify end of list.
  1117                                  ;    *	number of cylinders in MaxParms initialized to -1 to indicate
  1118                                  ;	that the parameters have not been set.
  1119                                  ;
  1120                                  ;  START_BDS contains a pointer to the first BDS. It is through this
  1121                                  ;  pointer that routines find particular BDS (see SetDrive to see how
  1122                                  ;  this is done).
  1123                                  ;
  1124                                  
  1125                                  	;EVENB
  1126                                  ;align 2
  1127                                  
  1128 000003D0 [3404]                  bds1:		dw	bds2			; dword link to next structure
  1129 000003D2 7000                    		dw	KERNEL_SEGMENT  ; 28/03/2018
  1130 000003D4 00                      		db	0			; int 13h drive number
  1131 000003D5 00                      		db	0			; logical drive letter
  1132                                  fdrive1:
  1133 000003D6 0002                    		dw	512			; physical sector size in bytes
  1134 000003D8 FF                      		db	-1			; sectors/allocation unit
  1135 000003D9 0100                    		dw	1			; reserved sectors for dos
  1136 000003DB 02                      		db	2			; number of allocation tables
  1137 000003DC 4000                    		dw	64			; number of directory entries
  1138 000003DE 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1139 000003E0 00                      		db	0			; media descriptor, initially 0
  1140 000003E1 0200                    		dw	2			; number of fat sectors
  1141 000003E3 0900                    		dw	9			; sector limit
  1142 000003E5 0100                    		dw	1			; head limit
  1143 000003E7 0000                    		dw	0			; hidden sector count (low word)
  1144 000003E9 0000                    		dw	0			; hidden sector (high)
  1145 000003EB 0000                    		dw	0			; number of sectors (low)
  1146 000003ED 0000                    		dw	0			; number of sectors (high)
  1147 000003EF 00                      		db	0			;  true => large fats
  1148                                  opcnt1:
  1149 000003F0 0000                    		dw	0			; open ref. count
  1150 000003F2 03                      		db	3			; form factor
  1151                                  flags1:
  1152 000003F3 2000                    		dw	20h			; various flags
  1153 000003F5 2800                    		dw	40			; number of cylinders
  1154                                  recbpb1: ; recommended bps for this drive
  1155 000003F7 0002                    		dw	512			; bytes per sector
  1156 000003F9 01                      		db	1			; sectors/allocation unit
  1157 000003FA 0100                    		dw	1			; reserved sectors for dos
  1158 000003FC 02                      		db	2			; number of allocation tables
  1159 000003FD E000                    		dw	224			; number of directory entries
  1160 000003FF 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1161 00000401 F0                      		db	0F0h			; media descriptor, initially 0F0h
  1162 00000402 0200                    		dw	2			; number of fat sectors
  1163 00000404 0900                    		dw	9			; sector limit
  1164 00000406 0200                    		dw	2			; head limit
  1165 00000408 0000                    		dw	0			; hidden sector count (low word)
  1166 0000040A 0000                    		dw	0			; hidden sector (high)
  1167 0000040C 0000                    		dw	0			; number of sectors (low)
  1168 0000040E 0000                    		dw	0			; number of sectors (high)
  1169                                  
  1170 00000410 00<rep 6h>              		times	6 db 0
  1171                                  
  1172 00000416 FF                      track1:		db	-1			; last track accessed on this drive
  1173 00000417 FFFF                    tim_lo1:	dw	-1			; keep these two contiguous (?)
  1174 00000419 FFFF                    tim_hi1:	dw	-1
  1175 0000041B 4E4F204E414D452020-     volid1:		db	"NO NAME    ",0		; volume id for this disk
  1175 00000424 202000             
  1176 00000427 00000000                volserial1:	dd	0			; current volume serial from boot record
  1177 0000042B 464154313220202000      systemid1:	db	"FAT12   ",0		; current file system id from boot record
  1178                                  
  1179                                  align 2
  1180                                  
  1181 00000434 [9804]                  bds2:		dw	bds3			; dword link to next structure
  1182 00000436 7000                    		dw	KERNEL_SEGMENT ; 28/03/2018
  1183 00000438 00                      		db	0			; int 13h drive number
  1184 00000439 00                      		db	0			; logical drive letter
  1185                                  fdrive2:
  1186 0000043A 0002                    		dw	512			; physical sector size in bytes
  1187 0000043C FF                      		db	-1			; sectors/allocation unit
  1188 0000043D 0100                    		dw	1			; reserved sectors for dos
  1189 0000043F 02                      		db	2			; number of allocation tables
  1190 00000440 4000                    		dw	64			; number of directory entries
  1191 00000442 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1192 00000444 00                      		db	0			; media descriptor, initially 0
  1193 00000445 0200                    		dw	2			; number of fat sectors
  1194 00000447 0900                    		dw	9			; sector limit
  1195 00000449 0100                    		dw	1			; head limit
  1196 0000044B 0000                    		dw	0			; hidden sector count (low word)
  1197 0000044D 0000                    		dw	0			; hidden sector (high)
  1198 0000044F 0000                    		dw	0			; number of sectors (low)
  1199 00000451 0000                    		dw	0			; number of sectors (high)
  1200 00000453 00                      		db	0			;  true => large fats
  1201                                  opcnt2:
  1202 00000454 0000                    		dw	0			; open ref. count
  1203 00000456 03                      		db	3			; form factor
  1204                                  flags2:
  1205 00000457 2000                    		dw	20h			; various flags
  1206 00000459 2800                    		dw	40			; number of cylinders
  1207                                  recbpb2: ; recommended bps for this drive
  1208 0000045B 0002                    		dw	512			; bytes per sector
  1209 0000045D 01                      		db	1			; sectors/allocation unit
  1210 0000045E 0100                    		dw	1			; reserved sectors for dos
  1211 00000460 02                      		db	2			; number of allocation tables
  1212 00000461 E000                    		dw	224			; number of directory entries
  1213 00000463 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1214 00000465 F0                      		db	0F0h			; media descriptor, initially 0F0h
  1215 00000466 0200                    		dw	2			; number of fat sectors
  1216 00000468 0900                    		dw	9			; sector limit
  1217 0000046A 0200                    		dw	2			; head limit
  1218 0000046C 0000                    		dw	0			; hidden sector count (low word)
  1219 0000046E 0000                    		dw	0			; hidden sector (high)
  1220 00000470 0000                    		dw	0			; number of sectors (low)
  1221 00000472 0000                    		dw	0			; number of sectors (high)
  1222                                  
  1223 00000474 00<rep 6h>              		times	6 db 0
  1224                                  
  1225 0000047A FF                      track2:		db	-1			; last track accessed on this drive
  1226 0000047B FFFF                    tim_lo2:	dw	-1			; keep these two contiguous (?)
  1227 0000047D FFFF                    tim_hi21:	dw	-1
  1228 0000047F 4E4F204E414D452020-     volid2:		db	"NO NAME    ",0		; volume id for this disk
  1228 00000488 202000             
  1229 0000048B 00000000                volserial2:	dd	0			; current volume serial from boot record
  1230 0000048F 464154313220202000      systemid2:	db	"FAT12   ",0		; current file system id from boot record
  1231                                  
  1232                                  align 2
  1233                                  
  1234 00000498 [FC04]                  bds3:		dw	bds4			; dword link to next structure
  1235 0000049A 7000                    		dw	KERNEL_SEGMENT ; 28/03/2018
  1236 0000049C 00                      		db	0			; int 13h drive number
  1237 0000049D 00                      		db	0			; logical drive letter
  1238                                  fdrive3:
  1239 0000049E 0002                    		dw	512			; physical sector size in bytes
  1240 000004A0 FF                      		db	-1			; sectors/allocation unit
  1241 000004A1 0100                    		dw	1			; reserved sectors for dos
  1242 000004A3 02                      		db	2			; number of allocation tables
  1243 000004A4 4000                    		dw	64			; number of directory entries
  1244 000004A6 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1245 000004A8 00                      		db	0			; media descriptor, initially 0
  1246 000004A9 0200                    		dw	2			; number of fat sectors
  1247 000004AB 0900                    		dw	9			; sector limit
  1248 000004AD 0100                    		dw	1			; head limit
  1249 000004AF 0000                    		dw	0			; hidden sector count (low word)
  1250 000004B1 0000                    		dw	0			; hidden sector (high)
  1251 000004B3 0000                    		dw	0			; number of sectors (low)
  1252 000004B5 0000                    		dw	0			; number of sectors (high)
  1253 000004B7 00                      		db	0			;  true => large fats
  1254                                  opcnt3:
  1255 000004B8 0000                    		dw	0			; open ref. count
  1256 000004BA 03                      		db	3			; form factor
  1257                                  flags3:
  1258 000004BB 2000                    		dw	20h			; various flags
  1259 000004BD 2800                    		dw	40			; number of cylinders
  1260                                  recbpb3: ; recommended bps for this drive
  1261 000004BF 0002                    		dw	512			; bytes per sector
  1262 000004C1 01                      		db	1			; sectors/allocation unit
  1263 000004C2 0100                    		dw	1			; reserved sectors for dos
  1264 000004C4 02                      		db	2			; number of allocation tables
  1265 000004C5 E000                    		dw	224			; number of directory entries
  1266 000004C7 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1267 000004C9 F0                      		db	0F0h			; media descriptor, initially 0F0h
  1268 000004CA 0200                    		dw	2			; number of fat sectors
  1269 000004CC 0900                    		dw	9			; sector limit
  1270 000004CE 0200                    		dw	2			; head limit
  1271 000004D0 0000                    		dw	0			; hidden sector count (low word)
  1272 000004D2 0000                    		dw	0			; hidden sector (high)
  1273 000004D4 0000                    		dw	0			; number of sectors (low)
  1274 000004D6 0000                    		dw	0			; number of sectors (high)
  1275                                  
  1276 000004D8 00<rep 6h>              		times	6 db 0
  1277                                  
  1278 000004DE FF                      track3:		db	-1			; last track accessed on this drive
  1279 000004DF FFFF                    tim_lo3:	dw	-1			; keep these two contiguous (?)
  1280 000004E1 FFFF                    tim_hi3:	dw	-1
  1281 000004E3 4E4F204E414D452020-     volid3:		db	"NO NAME    ",0		; volume id for this disk
  1281 000004EC 202000             
  1282 000004EF 00000000                volserial3:	dd	0			; current volume serial from boot record
  1283 000004F3 464154313220202000      systemid3:	db	"FAT12   ",0		; current file system id from boot record
  1284                                  
  1285                                  align 2
  1286                                  
  1287 000004FC FFFF                    bds4:		dw	-1			; end of link (the last BDS) = -1
  1288 000004FE 7000                    		dw	KERNEL_SEGMENT
  1289 00000500 00                      		db	0			; int 13h drive number
  1290 00000501 00                      		db	0			; logical drive letter
  1291                                  fdrive4:
  1292 00000502 0002                    		dw	512			; physical sector size in bytes
  1293 00000504 FF                      		db	-1			; sectors/allocation unit
  1294 00000505 0100                    		dw	1			; reserved sectors for dos
  1295 00000507 02                      		db	2			; number of allocation tables
  1296 00000508 4000                    		dw	64			; number of directory entries
  1297 0000050A 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1298 0000050C 00                      		db	0			; media descriptor, initially 0
  1299 0000050D 0200                    		dw	2			; number of fat sectors
  1300 0000050F 0900                    		dw	9			; sector limit
  1301 00000511 0100                    		dw	1			; head limit
  1302 00000513 0000                    		dw	0			; hidden sector count (low word)
  1303 00000515 0000                    		dw	0			; hidden sector (high)
  1304 00000517 0000                    		dw	0			; number of sectors (low)
  1305 00000519 0000                    		dw	0			; number of sectors (high)
  1306 0000051B 00                      		db	0			;  true => large fats
  1307                                  opcnt4:
  1308 0000051C 0000                    		dw	0			; open ref. count
  1309 0000051E 03                      		db	3			; form factor
  1310                                  flags4:
  1311 0000051F 2000                    		dw	20h			; various flags
  1312 00000521 2800                    		dw	40			; number of cylinders
  1313                                  ;;Rev 3.30 Modification
  1314                                  recbpb4: ; recommended bps for this drive
  1315 00000523 0002                    		dw	512			; bytes per sector
  1316 00000525 01                      		db	1			; sectors/allocation unit
  1317 00000526 0100                    		dw	1			; reserved sectors for dos
  1318 00000528 02                      		db	2			; number of allocation tables
  1319 00000529 E000                    		dw	224			; number of directory entries
  1320 0000052B 6801                    		dw	9*40			; number of sectors (at 512 bytes each)
  1321 0000052D F0                      		db	0F0h			; media descriptor, initially 0F0h
  1322 0000052E 0200                    		dw	2			; number of fat sectors
  1323 00000530 0900                    		dw	9			; sector limit
  1324 00000532 0200                    		dw	2			; head limit
  1325 00000534 0000                    		dw	0			; hidden sector count (low word)
  1326 00000536 0000                    		dw	0			; hidden sector (high)
  1327 00000538 0000                    		dw	0			; number of sectors (low)
  1328 0000053A 0000                    		dw	0			; number of sectors (high)
  1329                                  
  1330 0000053C 00<rep 6h>              		times	6 db 0
  1331                                  
  1332 00000542 FF                      track4:		db	-1			; last track accessed on this drive
  1333 00000543 FFFF                    tim_lo4:	dw	-1			; keep these two contiguous (?)
  1334 00000545 FFFF                    tim_hi4:	dw	-1
  1335 00000547 4E4F204E414D452020-     volid4:		db	"NO NAME    ",0		; volume id for this disk
  1335 00000550 202000             
  1336 00000553 00000000                volserial4:	dd	0			; current volume serial from boot record
  1337 00000557 464154313220202000      systemid4:	db	"FAT12   ",0		; current file system id from boot record
  1338                                  
  1339                                  struc bpbType
  1340 00000000 ??                      .spf:	resb 	1
  1341 00000001 ??                      .spt:	resb 	1
  1342 00000002 ??                      .cdire:	resb 	1
  1343 00000003 ????                    .csec:	resw 	1
  1344 00000005 ??                      .spa:	resb	1
  1345 00000006 ??                      .chead:	resb	1
  1346                                  .size:
  1347                                  endstruc
  1348                                  
  1349                                  SM92:   	; bpbtype <3,9,70h,2*9*80,2,2>
  1350 00000560 03                      		db	3	; .spf
  1351 00000561 09                      		db	9	; .spt
  1352 00000562 70                      		db	112	; .cdire
  1353 00000563 A005                    		dw	1440	; .csec
  1354 00000565 02                      		db	2	; .spau	
  1355 00000566 02                      		db	2	; .chead
  1356                                  
  1357                                  ; 19/07/2019
  1358                                  
  1359                                  ; This is a byte used for special key handling in the resident
  1360                                  ; console device driver. It must be here so that it can be included
  1361                                  ; in the WIN386 instance table (in INC\LMSTUB.ASM).
  1362                                  
  1363                                  ALTAH:
  1364 00000567 00                      		DB	0		;Special key handling
  1365                                  
  1366                                  ;
  1367                                  ; The following variable can be modified via IOCTL sub-function 16. In this
  1368                                  ; way, the wait can be set to suit the speed of the particular printer being
  1369                                  ; used. One for each printer device.
  1370                                  ;
  1371                                  
  1372                                  PRINTDEV:
  1373 00000568 00                      		DB	0		; Index into following array
  1374                                  
  1375                                  ;EVENB
  1376 00000569 90                      align 2
  1377                                  
  1378                                  WAIT_COUNT:
  1379                                  		;DW	4 dup (50h)	; Array of Retry counts for printer
  1380 0000056A 5000<rep 4h>            		times	4 dw 50h	 	
  1381                                  
  1382                                  ; DAYCNT is the number of days since 1-1-80.
  1383                                  ; Each time the clock is read it is necessary to check if another day has
  1384                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  1385                                  ; the time will be off by a day.
  1386                                  
  1387                                  ;EVENB
  1388                                  ;align 2
  1389                                  
  1390                                  DAYCNT:
  1391 00000572 0000                    		DW	0
  1392                                  
  1393                                  ;26/05/2018
  1394                                  
  1395                                  ; variables for real time clock setting
  1396                                  HaveCMOSClock:
  1397 00000574 00                      		db	0	;set by MSINIT.
  1398                                  base_century:
  1399 00000575 13                      		db	19
  1400                                  base_year:
  1401 00000576 50                      		db	80
  1402                                  month_tab:
  1403 00000577 1F1C1F1E1F1E1F1F1E-     		db	31,28,31,30,31,30,31,31,30,31,30,31
  1403 00000580 1F1E1F             
  1404                                  
  1405                                  ; The following are indirect intra-segment call addresses. The
  1406                                  ;procedures are defined in MSINIT for relocation. MSINIT will set these
  1407                                  ;address when the relocation is done.
  1408                                  	
  1409                                  BinToBCD:
  1410                                  		;dw	0	;should point to Bin_To_BCD proc in MSINIT
  1411                                  		; 17/07/2019
  1412 00000583 [9829]                  		dw	Bin_To_BCD	
  1413                                  
  1414                                  DaycntToDay:
  1415                                  		;dw	0	;should point to Daycnt_to_day in MSINIT
  1416                                  		; 17/07/2019
  1417 00000585 [C628]                  		dw	Daycnt_To_Day
  1418                                  
  1419                                  ; 19/07/2019 - Retro DOS v3.2
  1420                                  ; ----------------------------------------
  1421                                  ; 30/12/2018 - Retro DOS v4.0 (MSDOS 6.21)
  1422                                  ; MSBIO1.ASM (MSDOS 6.0)
  1423                                  
  1424                                  ; this stuff is related to the msdisk.asm module
  1425                                  
  1426 00000587 00                      set_id_flag:	db	0	;if 1, getbp routine will set the
  1427                                  				;vol_serial and filesys_id in bds table
  1428                                  				;from the media boot record, if it is > dos 4.00
  1429                                  				;formatted one. then set_id_flag will be set to 2
  1430                                  				;to signal that volume_label is set from the extended
  1431                                  				;boot record and do not set it from the root
  1432                                  				;directory as done in set_volume_id routine.
  1433                                  				;for the old version, vol_serial
  1434                                  				;will be set to -1, and filesys_id will be set
  1435                                  				;to "fat12   " if it is a floppy.
  1436                                  ; 15/07/2019
  1437 00000588 464154313220202000      fat_12_id:	db  "FAT12   ",0 ;  default system id for floppy.
  1438 00000591 464154313620202000      fat_16_id:	db  "FAT16   ",0
  1439 0000059A 4E4F204E414D452020-     vol_no_name:	db "NO NAME    ",0
  1439 000005A3 202000             
  1440 000005A6 0000                    temp_h:		dw	0	; temporary for 32 bit calculation.
  1441                                  ;21/07/2019
  1442 000005A8 0000                    start_sec_h:	dw	0	; starting sector number high word.
  1443 000005AA 0000                    saved_word:	dw	0	; tempory saving place for a word.
  1444 000005AC 0000                    vretry_cnt:	dw	0
  1445 000005AE 0000                    soft_ecc_cnt:	dw	0
  1446                                  
  1447                                  MAX_SECTORS_CURR_SUP	EQU	63	; CURRENT MAXIMUM SEC/TRK THAT	  ;3.30
  1448                                  					; WE SUPPORT (Was 40 in DOS 3.2)  ;3.30
  1449                                  ; 26/09/2019 - Retro DOS v3.1
  1450                                  ;A_SECTORTABLE_SIZE equ A_SECTORTABLE.size  ; = 4
  1451                                  
  1452                                  ;
  1453                                  ; TrackTable is an area for saving information passwd by the set device
  1454                                  ; parameter function for laster use my Read/Write/Format/Verify.
  1455                                  ;
  1456                                  ; Entries are 4-Tuples (C,H,R,N) where:
  1457                                  ;   C = Cylinder, H = Head, R = Sector, N = Bytes/Sector
  1458                                  ;
  1459                                  ; fixed for bug0016 - initialised table with values - sp
  1460                                  TrackTable:
  1461 000005B0 00000102                		db	0,0,1,2
  1462 000005B4 00000202                		db	0,0,2,2
  1463 000005B8 00000302                		db	0,0,3,2
  1464 000005BC 00000402                		db	0,0,4,2
  1465 000005C0 00000502                		db	0,0,5,2
  1466 000005C4 00000602                		db	0,0,6,2
  1467 000005C8 00000702                		db	0,0,7,2
  1468 000005CC 00000802                		db	0,0,8,2
  1469 000005D0 00000902                		db	0,0,9,2
  1470 000005D4 00000A02                		db	0,0,10,2
  1471 000005D8 00000B02                		db	0,0,11,2
  1472 000005DC 00000C02                		db	0,0,12,2
  1473 000005E0 00000D02                		db	0,0,13,2
  1474 000005E4 00000E02                		db	0,0,14,2
  1475 000005E8 00000F02                		db	0,0,15,2
  1476 000005EC 00001002                		db	0,0,16,2
  1477 000005F0 00001102                		db	0,0,17,2
  1478 000005F4 00001202                		db	0,0,18,2
  1479                                  		; 17/07/2019 - Retro DOS v3.2
  1480                                  		;times (MAX_SECTORS_CURR_SUP*A_SECTORTABLE_SIZE)-($-TrackTable) db 0
  1481 000005F8 00001302                		db	0,0,19,2
  1482 000005FC 00001402                		db	0,0,20,2
  1483 00000600 00001502                		db	0,0,21,2
  1484 00000604 00001602                		db	0,0,22,2
  1485 00000608 00001702                		db	0,0,23,2
  1486 0000060C 00001802                		db	0,0,24,2
  1487 00000610 00001902                		db	0,0,25,2
  1488 00000614 00001A02                		db	0,0,26,2
  1489 00000618 00001B02                		db	0,0,27,2
  1490 0000061C 00001C02                		db	0,0,28,2
  1491 00000620 00001D02                		db	0,0,29,2
  1492 00000624 00001E02                		db	0,0,30,2
  1493 00000628 00001F02                		db	0,0,31,2
  1494 0000062C 00002002                		db	0,0,32,2
  1495 00000630 00002102                		db	0,0,33,2
  1496 00000634 00002202                		db	0,0,34,2
  1497 00000638 00002302                		db	0,0,35,2
  1498 0000063C 00002402                		db	0,0,36,2
  1499 00000640 00<rep 6Ch>             		times	(4*MAX_SECTORS_CURR_SUP-($ -TrackTable)) db 0
  1500                                  
  1501                                  SectorsPerTrack:
  1502                                  		;dw	15
  1503 000006AC 2400                    		dw	36  ; 17/07/2019 - Retro DOS v3.2
  1504                                  
  1505                                  ; This is a real ugly place to put this
  1506                                  ; it should really go in the BDS
  1507 000006AE 00                      mediaType:	db	0
  1508                                  
  1509                                  Media_Set_For_Format:
  1510 000006AF 00                      		db	0		; 1 if we have done an Int 13 Set Media
  1511                                  					; Type for Format call
  1512                                  ; Rev 3.30 *****************************************************************
  1513                                  Had_Format_Error:
  1514 000006B0 00                      		db	0		; 1 if the previous format operation
  1515                                  					; failed.
  1516                                  Dsk_time_out_Err	equ	80h	; Time out error (No media present).
  1517                                  Dsk_change_line_Err	equ	6h	; Change line error
  1518                                  Dsk_illegal_combination equ	0Ch	; Return code of ah=18h function.
  1519                                  ; Rev 3.30 *****************************************************************
  1520                                  
  1521                                  ;
  1522                                  ; TempDPT is a temporary place to hold a pointer to the original
  1523                                  ; Disk Parameter Table while DPT is made to point to a table returned
  1524                                  ; by a BIOS call.  A value of -1 indicateds no value has been saved.
  1525                                  ;
  1526                                  
  1527                                  TempDPT:
  1528 000006B1 FFFFFFFF                		DD	-1
  1529                                  
  1530                                  MODEL_BYTE: 	
  1531 000006B5 FF                      		DB	0FFH		; MODEL BYTE. SET UP AT INIT TIME.
  1532                                  					; FF - PC-1, EXPANSION, OLD PC-2 
  1533                                  					; FE - NEWER PC-2 (64/256K PLANAR)
  1534                                  					; FD - 
  1535                                  					; FC - 
  1536                                  Secondary_Model_Byte:
  1537 000006B6 00                      		DB	0	
  1538                                  
  1539                                  ;-----------------------------------------------------------------------------
  1540                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  1541                                  ;-----------------------------------------------------------------------------
  1542                                  ; 29/05/2018 - Retro DOS v3.0
  1543                                  ; 25/03/2018 - Retro DOS v2.0 
  1544                                  
  1545                                  ; 18/07/2019 - Retro DOS v3.2
  1546                                  ; (MSDOS 6.0)
  1547                                  
  1548 000006B7 90                      align 2
  1549                                  
  1550 000006B8 00000000                ORIG13:		dd	0
  1551                                  
  1552                                  ; 30/12/2018 - Retro DOS v4.0
  1553                                  
  1554                                  RomVectors:
  1555 000006BC 10                      		db	10h
  1556 000006BD 00000000                Old10:		dd	0
  1557 000006C1 13                      		db	13h
  1558 000006C2 00000000                OLD13:		dd	0
  1559 000006C6 15                      		db	15h
  1560 000006C7 00000000                Old15:		dd	0
  1561 000006CB 19                      		db	19h
  1562 000006CC 00000000                OLD19:		dd	0
  1563 000006D0 1B                      		db	1Bh
  1564 000006D1 00000000                Old1B:		dd	0
  1565                                  
  1566                                  EndRomVectors	equ	$
  1567                                  
  1568                                  NUMROMVECTORS	equ	((EndRomVectors-RomVectors)/5)
  1569                                  
  1570                                  ; 18/07/2019 - Retro DOS v3.2
  1571                                  ; (MSDOS 3.3)
  1572                                  
  1573                                  ;;Rev 3.30 modification ----------------------------
  1574                                  
  1575                                  INT19SEM:
  1576 000006D5 00                      		DB	0		; INDICATE THAT ALL INT 19
  1577                                  					; INITIALIZATION IS COMPLETE
  1578                                  		;EVENB
  1579                                  ;align 4
  1580                                  
  1581                                  ;ORIG19:
  1582                                  ;		dd	0
  1583                                  
  1584                                  		; 18/07/2019 - Retro DOS v3.2
  1585                                  		; (MSDOS 6.0)
  1586                                  
  1587                                  ;; we assume the following remain contiguous and their order doesn't change
  1588                                  ;i19_lst:
  1589                                  ;	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
  1590                                  ;	public	int19old&aa
  1591                                  ;		db	aa&h	; store the number as a byte
  1592                                  ;int19old&aa	dd	-1	;original hardware int. vectors for int 19h.
  1593                                  ;	endm
  1594                                  
  1595                                  i19_lst:
  1596 000006D6 02                      		db	02h	
  1597 000006D7 FFFFFFFF                INT19OLD02:	dd	-1
  1598 000006DB 08                      		db	08h
  1599 000006DC FFFFFFFF                INT19OLD08:	dd	-1
  1600 000006E0 09                      		db	09h
  1601 000006E1 FFFFFFFF                INT19OLD09:	dd	-1
  1602 000006E5 0A                      		db	0Ah
  1603 000006E6 FFFFFFFF                INT19OLD0A:	dd	-1
  1604 000006EA 0B                      		db	0Bh
  1605 000006EB FFFFFFFF                INT19OLD0B:	dd	-1
  1606 000006EF 0C                      		db	0Ch
  1607 000006F0 FFFFFFFF                INT19OLD0C:	dd	-1
  1608 000006F4 0D                      		db	0Dh
  1609 000006F5 FFFFFFFF                INT19OLD0D:	dd	-1
  1610 000006F9 0E                      		db	0Eh
  1611 000006FA FFFFFFFF                INT19OLD0E:	dd	-1
  1612 000006FE 70                      		db	70h
  1613 000006FF FFFFFFFF                INT19OLD70:	dd	-1
  1614 00000703 72                      		db	72h	
  1615 00000704 FFFFFFFF                INT19OLD72:	dd	-1
  1616 00000708 73                      		db	73h
  1617 00000709 FFFFFFFF                INT19OLD73:	dd	-1
  1618 0000070D 74                      		db	74h
  1619 0000070E FFFFFFFF                INT19OLD74:	dd	-1
  1620 00000712 76                      		db	76h
  1621 00000713 FFFFFFFF                INT19OLD76:	dd	-1
  1622 00000717 77                      		db	77h
  1623 00000718 FFFFFFFF                INT19OLD77:	dd	-1
  1624                                  
  1625                                  num_i19	equ ($-i19_lst)/5  ; 18/03/2019	
  1626                                  
  1627                                  		;EVENB
  1628                                  align 2
  1629                                  		; 16/07/2019 - Retro DOS v3.2
  1630                                  DSKDRVS:	; 29/05/2018
  1631 0000071C [D603]                  		dw	fdrive1
  1632 0000071E [3A04]                  		dw	fdrive2
  1633 00000720 [9E04]                  		dw	fdrive3
  1634 00000722 [0205]                  		dw	fdrive4
  1635                                  
  1636                                  		; 17/07/2019
  1637                                  ;HDSKTAB:
  1638                                  ;		dw	HDRIVE
  1639                                  ;		dw	DRIVEX
  1640                                  
  1641                                  ;* Next area is reserved for mini disk BPB pointers *** 4/7/86
  1642                                  ;* Don't change this pos. Should be add. from DskDrvs *** 4/7/86
  1643                                  ;MINI_DISK_BPB_PTRS:	
  1644                                  		;times	40 db 0 ;4/7/86 - mem res for Mini disk.
  1645                                  		; 16/07/2019
  1646                                  		;times	20 dw 0
  1647                                  		; 17/07/2019
  1648 00000724 0000<rep 16h>           		times	22 dw 0  		
  1649                                  
  1650                                  	;EVENB
  1651                                  ;align 2
  1652                                  
  1653                                  INT_2F_NEXT:
  1654 00000750 00000000                		dd	0
  1655                                  ; 17/07/2019
  1656                                  ;RET_ADDR:
  1657                                  ;		dd	0
  1658                                  
  1659                                  ;;End of modification ----------------------------
  1660                                  
  1661                                  ; 19/07/2019 - Retro DOS v3.2
  1662                                  ; 29/06/2019 - Retro DOS v3.1
  1663                                  
  1664                                  ;-----------------------------------------------------------------------------
  1665                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  1666                                  ;-----------------------------------------------------------------------------
  1667                                  ; 29/05/2018 - Retro DOS v3.0
  1668                                  ; 25/03/2018 - Retro DOS v2.0 
  1669                                  
  1670                                  ;  INT19
  1671                                  ;
  1672                                  ;	We "hook" the INT_REBOOT vector, because contrary to IBM documentation,
  1673                                  ;  it does NOT "bootstrap" the machine. It leaves memory almost untouched.
  1674                                  ;  Since the BIOS_INIT code assumes that certain Interrupt Vectors point to
  1675                                  ;  the ROM_BIOS  we must "unhook" them before issuing the actual INT_REBOOT.
  1676                                  ;  Currently the following vectors need to be unhooked:
  1677                                  ;		  02,08,09,0A,0B,0C,0D,0E,70,72,73,74,75,76,77
  1678                                  ;
  1679                                  
  1680                                  INT19:
  1681                                  		; 18/07/2019 - Retro DOS v3.2
  1682                                  		; (MSDOS 3.3)
  1683                                  
  1684                                  		;xor	AX,AX		; get data segment to
  1685                                  		;mov	DS,AX		;   point to the vector table
  1686                                  		;les	DI,[CS:OLD13]	; get ES to point to this segment
  1687                                  		;mov	[13h*4],DI	; restore old int13 value
  1688                                  		;mov	[13h*4+2],ES
  1689                                  
  1690                                  		;cmp	byte [CS:INT19SEM], 0
  1691                                  		;jnz	short int19vecs
  1692                                  		;jmp	doint19
  1693                                  
  1694 00000754 0E                      		push	cs
  1695 00000755 1F                      		pop	ds
  1696                                  
  1697                                  		;mov	es,[zeroseg]
  1698 00000756 31C0                    		xor	ax,ax
  1699 00000758 8EC0                    		mov	es,ax
  1700                                  
  1701 0000075A B90500                  		mov	cx,5 ; NUMROMVECTORS ; no. of rom vectors to be restored
  1702 0000075D BE[BC06]                		mov	si,RomVectors	; point to list of saved vectors
  1703                                  next_int:
  1704 00000760 AC                      		lodsb			; get int number
  1705                                  
  1706 00000761 98                      		cbw			; assume < 128
  1707 00000762 D1E0                    		shl	ax,1
  1708 00000764 D1E0                    		shl	ax,1		; int * 4
  1709                                  		
  1710 00000766 89C7                    		mov	di,ax
  1711                                  		
  1712 00000768 A5                      		movsw			; install the saved vector
  1713 00000769 A5                      		movsw
  1714                                  		
  1715 0000076A E2F4                    		loop	next_int
  1716                                  
  1717 0000076C 803E[D506]00            		cmp	byte [INT19SEM],0 ; don't do the others unless we
  1718 00000771 7422                    		jz	short doint19	; set our initialization complete flag
  1719                                  int19vecs:
  1720                                  
  1721                                  ; we now need to unhook all the vector replace to prevent stack overflow
  1722                                  
  1723                                  		; 18/07/2019 - Retro DOS v3.2
  1724                                  		; (MSDOS 6.0)
  1725                                  
  1726                                  ; stacks code has changed these hardware interrupt vectors
  1727                                  ; stkinit in sysinit1 will initialize int19oldxx values.
  1728                                  
  1729 00000773 BE[D606]                		mov	si,i19_lst
  1730 00000776 B90E00                  		mov	cx,num_i19 ; 14
  1731                                  i19_restore_loop:
  1732 00000779 AC                      		lodsb			; get interrupt number
  1733 0000077A 98                      		cbw			; assume < 128
  1734 0000077B 89C7                    		mov	di,ax		; save interrupt number
  1735 0000077D AD                      		lodsw			; get original vector offset
  1736 0000077E 89C3                    		mov	bx,ax		; save it
  1737 00000780 AD                      		lodsw			; get original vector segment
  1738 00000781 83FBFF                  		cmp	bx,-1		; check for 0ffffh (unlikely segment)
  1739 00000784 740D                    		jz	short i19_restor_1 ;opt no need to check selector too 
  1740 00000786 83F8FF                  		cmp	ax,-1		;opt 0ffffh is unlikely offset
  1741 00000789 7408                    		jz	short i19_restor_1
  1742                                  
  1743 0000078B 01FF                    		add	di,di
  1744 0000078D 01FF                    		add	di,di
  1745 0000078F 93                      		xchg	ax,bx
  1746 00000790 AB                      		stosw
  1747 00000791 93                      		xchg	ax,bx
  1748 00000792 AB                      		stosw			; put the vector back
  1749                                  i19_restor_1:
  1750 00000793 E2E4                    		loop	i19_restore_loop
  1751                                  doint19:
  1752                                  		; 18/07/2019 - Retro DOS v3.2
  1753                                  		; (MSDOS 3.3)
  1754                                  		;LES	DI,[CS:ORIG19]
  1755                                  		;MOV	[19h*4],DI
  1756                                  		;MOV	[19h*4+2],ES
  1757                                  
  1758 00000795 CD19                    		INT	19h
  1759                                  
  1760                                  ;----------------------------------------------------------------------------
  1761                                  ;
  1762                                  ;----------------------------------------------------------------------------
  1763                                  
  1764                                  ; 29/06/2019 - Retro DOS v3.1
  1765                                  
  1766                                  ;************************************************************************
  1767                                  ;*									*
  1768                                  ;*	cbreak - break key handling - simply set altah=3 and iret	*
  1769                                  ;*									*
  1770                                  ;************************************************************************
  1771                                  
  1772                                  CBREAK:
  1773 00000797 2EC606[6705]03          		mov	byte [cs:ALTAH],3
  1774                                  INTRET:
  1775 0000079D CF                      		iret
  1776                                  
  1777                                  ;************************************************************************
  1778                                  ;*									*
  1779                                  ;*	strategy - store es:bx (device driver request packet)		*
  1780                                  ;*		     away at [ptrsav] for next driver function call	*
  1781                                  ;*									*
  1782                                  ;************************************************************************
  1783                                  
  1784                                  STRATEGY:
  1785 0000079E 2E891E[B000]            		mov	[CS:PTRSAV],BX
  1786 000007A3 2E8C06[B200]            		mov	[CS:PTRSAV+2],ES
  1787 000007A8 CB                      		retf					
  1788                                  
  1789                                  ;-----------------------------------------------------------------------------
  1790                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  1791                                  ;-----------------------------------------------------------------------------
  1792                                  ; 23/03/2018 - Retro DOS v2.0
  1793                                  
  1794                                  ; The next nine equ's describe the offset into the request header for
  1795                                  ; different information. For example STATUS is in byte 3 of the request
  1796                                  ; header (starting count at zero).
  1797                                  
  1798                                  CMDLEN	equ	0		; length of this command
  1799                                  UNIT	equ	1		; sub unit specifier
  1800                                  CMD	equ	2		; command code
  1801                                  STATUS	equ	3		; status
  1802                                  MEDIA	equ	13		; media descriptor
  1803                                  TRANS	equ	14		; transfer address
  1804                                  COUNT	equ	18		; count of blocks or characters
  1805                                  START	equ	20		; first block to transfer
  1806                                  EXTRA	equ	22		; Usually pointer to Vol Id for error 15
  1807                                  ; 21/07/2019 - Retro DOS v3.2
  1808                                  ; (MSDOS 6.0)
  1809                                  start_l equ	26	; extended start sector (low)
  1810                                  start_h equ	28	; extended start sector (high)
  1811                                  
  1812                                  ;------------------------------------------------------------------------------
  1813                                  ;
  1814                                  ;			Device entry point
  1815                                  ;
  1816                                  ; The following ten pieces of code are the interrupt entry points for the
  1817                                  ; default device drivers. These small pieces of code have two jobs.
  1818                                  ;
  1819                                  ;	1) Make SI point to the beginning of the proper command jump table.
  1820                                  ;	   SI must first be pushed to preserve original contents.
  1821                                  ;	2) If the call is an AUX or a printer save the number of the
  1822                                  ;	   request in AL. AL is moved to AUXNUM below.
  1823                                  ;
  1824                                  ;------------------------------------------------------------------------------
  1825                                  
  1826                                  ; Con device:
  1827                                  
  1828                                  CON$IN:
  1829 000007A9 56                      		PUSH	SI
  1830 000007AA BE[3700]                		MOV	SI,CONTBL
  1831 000007AD EB4B                    		JMP	SHORT ENTRY
  1832                                  AUX0$IN:
  1833 000007AF 56                      		PUSH	SI
  1834 000007B0 50                      		PUSH	AX
  1835 000007B1 30C0                    		XOR	AL,AL
  1836 000007B3 EB10                    		JMP	SHORT AUXENT
  1837                                  AUX1$IN:
  1838 000007B5 56                      		PUSH	SI
  1839 000007B6 50                      		PUSH	AX
  1840 000007B7 B001                    		MOV	AL,1
  1841 000007B9 EB0A                    		JMP	short AUXENT
  1842                                  
  1843                                  		; 25/05/2018
  1844                                  AUX2$IN:
  1845 000007BB 56                      		PUSH	SI
  1846 000007BC 50                      		PUSH	AX
  1847 000007BD B002                    		MOV	AL,2
  1848 000007BF EB04                    		JMP	short AUXENT
  1849                                  AUX3$IN:
  1850 000007C1 56                      		PUSH	SI
  1851 000007C2 50                      		PUSH	AX
  1852 000007C3 B003                    		MOV	AL,3
  1853                                  		;JMP	short AUXENT
  1854                                  AUXENT:
  1855 000007C5 BE[4F00]                		MOV	SI,AUXTBL
  1856 000007C8 EB31                    		JMP	SHORT ENTRY1
  1857                                  
  1858                                  PRN0$IN:
  1859 000007CA 56                      		PUSH	SI
  1860 000007CB 50                      		PUSH	AX
  1861 000007CC 31C0                    		XOR	AX,AX
  1862 000007CE EB16                    		JMP	SHORT PRNENT
  1863                                  PRN1$IN:
  1864 000007D0 56                      		PUSH	SI
  1865 000007D1 50                      		PUSH	AX
  1866 000007D2 30C0                    		XOR	AL,AL
  1867 000007D4 B401                    		MOV	AH,1
  1868 000007D6 EB0E                    		JMP	SHORT PRNENT
  1869                                  PRN2$IN:
  1870 000007D8 56                      		PUSH	SI
  1871 000007D9 50                      		PUSH	AX
  1872 000007DA B001                    		MOV	AL,1
  1873 000007DC B402                    		MOV	AH,2
  1874 000007DE EB06                    		JMP	SHORT PRNENT
  1875                                  PRN3$IN:
  1876 000007E0 56                      		PUSH	SI
  1877 000007E1 50                      		PUSH	AX
  1878 000007E2 B002                    		MOV	AL,2
  1879 000007E4 B403                    		MOV	AH,3
  1880                                  PRNENT:
  1881 000007E6 BE[7D00]                		MOV	SI,PRNTBL
  1882 000007E9 2E8826[6805]            		MOV	[CS:PRINTDEV],AH
  1883 000007EE EB0B                    		JMP	SHORT ENTRY1
  1884                                  
  1885                                  TIM$IN:
  1886 000007F0 56                      		PUSH	SI
  1887 000007F1 BE[6700]                		MOV	SI,TIMTBL
  1888 000007F4 EB04                    		JMP	SHORT ENTRY
  1889                                  
  1890                                  DSK$IN:
  1891 000007F6 56                      		PUSH	SI
  1892 000007F7 BE[0300]                		mov	SI,DSKTBL
  1893                                  
  1894                                  ; This section is the prolog to all default device drivers. All registers
  1895                                  ; are saved, the registers are filled with information from the request header,
  1896                                  ; and the routine from the jump table is called. Error checking is done
  1897                                  ; to assure command code is valid. Before calling the routine in the
  1898                                  ; jump table the register are:
  1899                                  ;
  1900                                  ;	AH = Media Descriptor
  1901                                  ;	AL = Unit Code
  1902                                  ;	BX = offset to PTRSAV (request header is therefore at DS:BX)
  1903                                  ;	CX = count from request header
  1904                                  ;	DX = start sector
  1905                                  ;	ES:DI = transfer address
  1906                                  ;	SI = points to jump table
  1907                                  ;	DS = points to this segment
  1908                                  ;
  1909                                  ; Once the routine finishes its job it jumps back to one of the eight
  1910                                  ; pieces of code below labeled Exit Points.
  1911                                  
  1912                                  ; 21/07/2019 - Retro DOS v3.2
  1913                                  ; (MSDOS 6.0)
  1914                                  		; 26/07/2019		
  1915                                  ENTRY:
  1916 000007FA 50                      		push	AX
  1917                                  ENTRY1:
  1918 000007FB 51                      		push	CX			; save all registers
  1919 000007FC 52                      		push	DX
  1920 000007FD 57                      		push	DI
  1921 000007FE 55                      		push	BP
  1922 000007FF 1E                      		push	DS
  1923 00000800 06                      		push	ES
  1924 00000801 53                      		push	BX
  1925                                  
  1926 00000802 2EA2[BC00]              		mov	[CS:AUXNUM],AL		; save choice of AUX/PRN device
  1927                                  
  1928 00000806 2EC51E[B000]            		lds	BX,[CS:PTRSAV]		; get pointer to I/O packet
  1929                                  	
  1930 0000080B 8A4701                  		mov	AL,[BX+UNIT]		;AL = UNIT CODE
  1931 0000080E 8A670D                  		mov	AH,[BX+MEDIA]		;AH = MEDIA DESCRIP
  1932 00000811 8B4F12                  		mov	CX,[BX+COUNT]		;CX = COUNT
  1933 00000814 8B5714                  		mov	DX,[BX+START]		;DX = START SECTOR
  1934                                  
  1935                                  ; 26/07/2019 - Retro DOS v3.2
  1936                                  
  1937 00000817 81FE[0300]              		cmp	si,DSKTBL  ; disk device call ?
  1938 0000081B 7517                    		jne	short Entry2
  1939                                  		
  1940                                  ;*************************************************************************
  1941                                  ;
  1942                                  ;	Special case for 32-bit start sector number:
  1943                                  ;	   if (si==dsktbl) /* if this is a disk device call */
  1944                                  ;	      set high 16 bits of secnum to 0
  1945                                  ;	      if (secnum == 0xffff) fetch 32 bit sector number
  1946                                  ;
  1947                                  ;	pass high word of sector number in start_sec_h, low word in dx
  1948                                  ;
  1949                                  ; note: start_l and start_h are the offsets within the io_request packet
  1950                                  ;	  which contain the low and hi words of the 32 bit start sector if
  1951                                  ;	  it has been used.
  1952                                  ;
  1953                                  ; note: remember not to destroy the registers which have been set up before
  1954                                  ;
  1955                                  ;*************************************************************************
  1956                                  
  1957                                  		; 26/07/2019
  1958                                  
  1959 0000081D 2EC706[A805]0000        		mov	word [cs:start_sec_h],0	; initialize to 0
  1960                                  
  1961 00000824 83FAFF                  		cmp	dx,-1
  1962 00000827 750B                    		jne	short no_sector32_mapping
  1963                                  
  1964                                  		; 27/07/2019
  1965 00000829 8B571C                  		mov	dx,[bx+start_h] ; 28	; 32 bits dsk req
  1966 0000082C 2E8916[A805]            		mov	[cs:start_sec_h],dx	; start_sec_h = packet.start_h
  1967 00000831 8B571A                  		mov	dx,[bx+start_l] ; 26	; dx = packet.start_l
  1968                                  no_sector32_mapping:
  1969                                  Entry2:
  1970 00000834 97                      		xchg	DI,AX
  1971 00000835 8A4702                  		mov	AL,[BX+CMD]
  1972                                  		; 11/04/2018 (25/05/2018)
  1973 00000838 2E3A04                  		cmp	AL,[CS:SI]		; is command code a valid number?
  1974 0000083B 7713                    		ja	SHORT CMDERR		; no, jump to handle error
  1975                                  
  1976                                  		;XOR	AH,AH
  1977 0000083D 98                      		CBW				; note that AL <= 15 means OK
  1978 0000083E D1E0                    		shl	AX,1
  1979 00000840 01C6                    		add	SI,AX			; get SI to point to address of routine
  1980                                  		
  1981 00000842 97                      		xchg	AX,DI			; put proper value back into AX
  1982 00000843 C47F0E                  		les	DI,[BX+TRANS]		; get ES:DI to point to transfer address
  1983 00000846 0E                      		push	CS			; get DS equal to CS
  1984 00000847 1F                      		pop	DS
  1985                                  
  1986 00000848 FC                      		cld				; clear the direction flag
  1987                                  		; 25/05/2018
  1988 00000849 FF6401                  		jmp	WORD [SI+1]		; go to the command
  1989                                  
  1990                                  ;=====================================================
  1991                                  ;=
  1992                                  ;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
  1993                                  ;=
  1994                                  ;=====================================================
  1995                                  
  1996                                  ;----------------------------------------------------------
  1997                                  ;
  1998                                  ;		Exit  Points
  1999                                  ;
  2000                                  ; All device driver call return through one of these eight
  2001                                  ; pieces of code. The code set error and status conditions
  2002                                  ; and then restores the registers.
  2003                                  ;
  2004                                  ;----------------------------------------------------------
  2005                                  		
  2006                                  BUS$EXIT:				; device busy exit
  2007                                  
  2008 0000084C B403                    		mov	AH,00000011b		; set error code
  2009 0000084E EB19                    		jmp	SHORT ERR1
  2010                                  CMDERR:
  2011 00000850 B003                    		mov	AL,3			; unknown command error
  2012                                  ERR$CNT:
  2013 00000852 2EC51E[B000]            		lds	BX,[CS:PTRSAV]
  2014                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  2015 00000857 294F12                  		sub	[BX+COUNT],CX		;# of successful I/O's
  2016                                  ERR$EXIT:
  2017 0000085A B481                    		mov	AH,10000001b		; mark error and return
  2018 0000085C EB0B                    		jmp	SHORT ERR1
  2019                                  
  2020                                  EXIT$ZER:
  2021                                  		;lds	BX,[CS:PTRSAV]
  2022 0000085E C51E[B000]              		lds	BX,[PTRSAV]		; IBMDOS 3.3 (IBMBIO.COM)
  2023 00000862 31C0                    		xor	AX,AX
  2024 00000864 894712                  		mov	[BX+COUNT],AX		; indicate no character read
  2025                                  		
  2026                                  		; 26/07/2019
  2027                                  EXIT:
  2028 00000867 B401                    		mov	AH,00000001b
  2029                                  ERR1:
  2030 00000869 2EC51E[B000]            		lds	BX,[CS:PTRSAV]
  2031                                  		;lds	BX,[PTRSAV]	; 11/04/2018
  2032 0000086E 894703                  		mov	[BX+STATUS],AX		; mark operation complete
  2033                                  
  2034 00000871 5B                      		pop	BX			; restore register and return
  2035 00000872 07                      		pop	ES
  2036 00000873 1F                      		pop	DS
  2037 00000874 5D                      		pop	BP
  2038 00000875 5F                      		pop	DI
  2039 00000876 5A                      		pop	DX
  2040 00000877 59                      		pop	CX
  2041 00000878 58                      		pop	AX
  2042 00000879 5E                      		pop	SI
  2043 0000087A CB                      		retf
  2044                                  
  2045                                  ;-----------------------------------------------------------------------------
  2046                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
  2047                                  ;-----------------------------------------------------------------------------
  2048                                  ; 23/03/2018 - Retro DOS v2.0
  2049                                  
  2050                                  ; 29/06/2019 - Retro DOS v3.1
  2051                                  
  2052                                  ;************************************************************************
  2053                                  ;*									*
  2054                                  ;*	outchr - this is our int 29h handler. it writes the		*
  2055                                  ;*	   character in al on the display using int 10h ttywrite	*
  2056                                  ;*									*
  2057                                  ;************************************************************************
  2058                                  
  2059                                  CHROUT	equ 29h
  2060                                  
  2061                                  OUTCHR:
  2062 0000087B 50                      		push	ax
  2063 0000087C 56                      		push	si
  2064 0000087D 57                      		push	di
  2065 0000087E 55                      		push	bp
  2066 0000087F 53                      		push	bx
  2067 00000880 B40E                    		mov	ah,0Eh	; set command to write a character
  2068 00000882 BB0700                  		mov	bx,7	; set foreground color
  2069 00000885 CD10                    		int	10h	; call rom-bios
  2070 00000887 5B                      		pop	bx
  2071 00000888 5D                      		pop	bp
  2072 00000889 5F                      		pop	di
  2073 0000088A 5E                      		pop	si
  2074 0000088B 58                      		pop	ax
  2075 0000088C CF                      		iret
  2076                                  
  2077                                  ;----------------------------------------------
  2078                                  ;
  2079                                  ; Fill DX register with value in AUXNUM
  2080                                  ;
  2081                                  ;----------------------------------------------
  2082                                  
  2083                                  GETDX:
  2084                                  		; IBMDOS 2.1
  2085                                  		;mov	dl,[AUXNUM]
  2086                                  		;xor	dh,dh
  2087                                  
  2088                                  		; MSDOS 3.3
  2089 0000088D 2E8B16[BC00]            		mov	DX,[CS:AUXNUM]
  2090 00000892 C3                      		retn
  2091                                  
  2092                                  ;-----------------------------------------------------------------------------
  2093                                  ; MSCON.ASM - MSDOS 3.3 - 24/07/1987
  2094                                  ;-----------------------------------------------------------------------------
  2095                                  ; 23/03/2018 - Retro DOS v2.0
  2096                                  
  2097                                  ;----------------------------------------------------------------
  2098                                  ;								:
  2099                                  ;	      CON - CONSOLE DEVICE DRIVER			:
  2100                                  ;								:
  2101                                  ;								:
  2102                                  ;   This file contains the Console Device Driver.  The		:
  2103                                  ; console device driver sends characters to the moniter and	:
  2104                                  ; gets characters from the keyboard.				:
  2105                                  ;								:
  2106                                  ;----------------------------------------------------------------
  2107                                  
  2108                                  
  2109                                  ;----------------------------------------------------------------
  2110                                  ;								:
  2111                                  ;		    Console read routine			:
  2112                                  ;								:
  2113                                  ;----------------------------------------------------------------
  2114                                  ;
  2115                                  
  2116                                  CON$READ:					; if CX is zero, no characters
  2117 00000893 E306                    		jcxz	CON$EXIT		;   to be read -- just exit
  2118                                  CON$LOOP:
  2119 00000895 E80500                  		call	CHRIN			; get char in AL
  2120 00000898 AA                      		stosb				; store char at ES:DI, specified buffer
  2121 00000899 E2FA                    		loop	CON$LOOP		; if CX is non-zero more char to read
  2122                                  CON$EXIT:
  2123 0000089B EBCA                    		jmp	short EXIT ; 19/07/2019 ; all done, successful return
  2124                                  
  2125                                  ;----------------------------------------------------------------
  2126                                  ;								:
  2127                                  ;	    Input single character into AL			:
  2128                                  ;								:
  2129                                  ;----------------------------------------------------------------
  2130                                  CHRIN:
  2131                                  						; set command to read character
  2132 0000089D 31C0                    		xor	AX, AX			;  and clear AL
  2133 0000089F 8606[6705]              		xchg	AL,[ALTAH]		; get character & zero ALTAH
  2134 000008A3 08C0                    		or	AL, AL			; see if buffer has a character
  2135 000008A5 7515                    		jnz	short KEYRET		; if so - return this character
  2136                                  						; if not - read single character
  2137 000008A7 CD16                    		int	16h			; call ROM-Bios keyboard routine
  2138                                  ALT10:
  2139 000008A9 09C0                    		or	AX,AX			; Check for non-key after BREAK
  2140 000008AB 74F0                    		jz	short CHRIN
  2141 000008AD 3D0072                  		cmp	AX,7200h		; Check for CTRL-PRTSC
  2142 000008B0 7502                    		jnz	short ALT15
  2143 000008B2 B010                    		mov	AL,16			; indicate prtsc
  2144                                  ALT15:
  2145 000008B4 08C0                    		or	AL,AL			; special case?
  2146 000008B6 7504                    		jnz	short KEYRET		; no, return with character
  2147 000008B8 8826[6705]              		mov	[ALTAH], AH		; yes, store special key
  2148                                  KEYRET:
  2149 000008BC C3                      		RETN
  2150                                  
  2151                                  ;----------------------------------------------------------------
  2152                                  ;								:
  2153                                  ;	   Keyboard non destructive read, no wait		:
  2154                                  ;								:
  2155                                  ; If bit 10 is set by the DOS in the status word of the request :
  2156                                  ; packet, and there is no character in the input buffer, the	:
  2157                                  ; driver issues a system WAIT request to the ROM. On return	:
  2158                                  ; from the ROM, it returns a 'char-not-found' to the DOS.       :
  2159                                  ;								:
  2160                                  ;----------------------------------------------------------------
  2161                                  
  2162                                  		; 13/06/2018 (Retro DOS v3.0, IBMDOS 3.0, IBMBIO.COM) 
  2163                                  ;CONBUSJ:
  2164                                  ;		JMP	short CONBUS
  2165                                  
  2166                                  CON$RDND:
  2167 000008BD A0[6705]                		mov	AL,[ALTAH]		; first see if there is a
  2168 000008C0 08C0                    		or	AL,AL			; character in the buffer?
  2169                                  		;jz	short RD1		; with debugging code it is
  2170                                  		;jmp	short RDEXIT		; too far for conditional jump
  2171 000008C2 7530                    		jnz	short RDEXIT
  2172                                  RD1:				     		; set command to 'see if
  2173 000008C4 B401                    		mov	AH,1	     		; character available'
  2174 000008C6 CD16                    		int	16h	     		; call ROM-BIOS keyboard routine
  2175                                  		;jz	short nochr		; with debugging code it is
  2176                                  		;jmp	short gotchr		; to far for conditional jump
  2177 000008C8 751B                    		jnz	short gotchr ; 19/07/2019
  2178                                  nochr:
  2179 000008CA 803E[1301]00            		cmp	byte [fHaveK09],0
  2180                                  		;jz	short CONBUSJ
  2181 000008CF 742D                    		jz	short CONBUS
  2182 000008D1 C51E[B000]              		lds	bx,[PTRSAV]		; get pointer to request header
  2183 000008D5 F747030004              		test	word [bx+STATUS],0400h	; System WAIT enabled?
  2184                                  		;jz	short CONBUSJ 		; no, get out
  2185 000008DA 7422                    		jz	short CONBUS
  2186                                  
  2187 000008DC B80041                  		mov	AX,4100h     		; set command for Wait on External
  2188                                  				      		; event and condition type to
  2189                                  				      		; any external event
  2190 000008DF 30DB                    		xor	BL,BL			; no timeout value
  2191 000008E1 CD15                    		int	15h	      		; call rom-bios sleep function
  2192 000008E3 EB19                    		jmp	short CONBUS		; after wait exit to con busy
  2193                                  gotchr:
  2194 000008E5 09C0                    		or	AX,AX			; check for null after break
  2195 000008E7 7504                    		JNZ	short NOTBRK		; no, skip down
  2196                                  		;mov	ah,0
  2197                                  ; note: AH is already zero, no need to set command
  2198 000008E9 CD16                    		int	16h			; yes, read the null
  2199 000008EB EBD0                    		Jmp	short CON$RDND		; and get a real status
  2200                                  
  2201                                  NOTBRK:
  2202 000008ED 3D0072                  		cmp	AX,7200H		; check for ctrl-prtsc
  2203 000008F0 7502                    		jnz	short RDEXIT		; no
  2204 000008F2 B010                    		mov	AL,16	; 10h		; yes, indicate ctrl-prtsc
  2205                                  RDEXIT:
  2206 000008F4 C51E[B000]              		lds	BX,[PTRSAV]		; get pointer to request header
  2207 000008F8 88470D                  		mov	[BX+MEDIA],AL		; move character into req. header
  2208                                  EXVEC:
  2209 000008FB E969FF                  		jmp	EXIT			; all done -- successful return
  2210                                  CONBUS:
  2211 000008FE E94BFF                  		Jmp	BUS$EXIT		; done -- con device is busy
  2212                                  
  2213                                  ;----------------------------------------------------------------
  2214                                  ;								:
  2215                                  ;		Keyboard flush routine				:
  2216                                  ;								:
  2217                                  ;----------------------------------------------------------------
  2218                                  
  2219                                  CON$FLSH:
  2220 00000901 E80300                  		call	FLUSH
  2221 00000904 E960FF                  		jmp	EXIT
  2222                                  
  2223                                  FLUSH:
  2224 00000907 C606[6705]00            		mov	byte [ALTAH], 0	; clear out holding buffer
  2225                                  FlLoop:
  2226                                  				 	; Is there a char there?
  2227 0000090C B401                    		mov	AH,1	 	; command code for check status
  2228 0000090E CD16                    		int	16h	 	; call rom-bios keyboard routine
  2229                                  					; if z flag is set then no character
  2230 00000910 7406                    		jz	short FlDone	; is ready, buffer is empty -- get out
  2231 00000912 30E4                    		xor	AH,AH	 	; if zf is nof set, get character
  2232 00000914 CD16                    		int	16h	 	; call rom-bios to get character
  2233 00000916 EBF4                    		jmp	short FlLoop	; repeat until buffer is empty
  2234                                  FlDone:
  2235 00000918 C3                      		retn
  2236                                  
  2237                                  ;----------------------------------------------------------------
  2238                                  ;								:
  2239                                  ;	       Console Write Routine				:
  2240                                  ;								:
  2241                                  ;----------------------------------------------------------------
  2242                                  	
  2243                                  CON$WRIT:
  2244 00000919 E3E0                    		jcxz	EXVEC			; if CX is zero, get out
  2245                                  CON$LP:
  2246                                  		; 13/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM)
  2247 0000091B 268A05                  		mov	AL,[ES:DI]		; get character
  2248 0000091E 47                      		inc	DI			; point to next character
  2249 0000091F CD29                    		int	CHROUT			; Output character
  2250 00000921 E2F8                    		loop	CON$LP			; repeat until all through
  2251 00000923 E941FF                  		jmp	EXIT
  2252                                  
  2253                                  ;-----------------------------------------------------------------------------
  2254                                  ; MSAUX.ASM - MSDOS 3.3 - 24/07/1987
  2255                                  ;-----------------------------------------------------------------------------
  2256                                  ; 23/03/2018 - Retro DOS v2.0
  2257                                  
  2258                                  ;----------------------------------------------------------------
  2259                                  ;								:
  2260                                  ;	     A U X - AUXILARY DEVICE DRIVER			:
  2261                                  ;								:
  2262                                  ;								:
  2263                                  ;   This file contains the Auxilary Device Driver. The 		:
  2264                                  ; auxilary driver handles calls to and from the RS-232 port.	:
  2265                                  ; Three devices uses this code: AUX, COM1, and COM2. AUX and	:
  2266                                  ; COM1 talk to the zero RS-232 card and COM2 talks to the	:
  2267                                  ; 'one' RS-232 card. The beginning of the interrupt entry       :
  2268                                  ; point for these devices sets the variable AUXNUM in the	:
  2269                                  ; msbio.asm module. If the value is 0 the routines in this	:
  2270                                  ; file will talk to the the 'zero' card.  If the value in       :
  2271                                  ; AUXNUM is 1 the routines will talk to the 'one' card.         :
  2272                                  ; The procedure GETDX is called to put the value 0 or 1 in	:
  2273                                  ; the DX register depending on the value in AUXBUF.		:
  2274                                  ;								:
  2275                                  ;   The routines in this files are:				:
  2276                                  ;								:
  2277                                  ;	routine 		function			:
  2278                                  ;	------- 		--------			:
  2279                                  ;	AUX$READ		Read characters from the	:
  2280                                  ;				  specified device.		:
  2281                                  ;	AUX$RDND		Non-desrucrtive read with	:
  2282                                  ;				  no waiting.			:
  2283                                  ;	AUX$FLSH		Flush specified device input	:
  2284                                  ;				  buffer.			:
  2285                                  ;	AUX$WRIT		Write characters to the 	:
  2286                                  ;				  specified device.		:
  2287                                  ;	AUX$WRST		Get status of specified 	:
  2288                                  ;				  device			:
  2289                                  ;								:
  2290                                  ;  These routines are not called directly.  Call are made via	:
  2291                                  ; the strategy and interrupt entry point (see Device Header).	:
  2292                                  ;								:
  2293                                  ;  Data structure:						:
  2294                                  ;    The Aux Device has a two byte buffer called AUXBUF.  The	:
  2295                                  ;  first byte is for the zero card, the second byte is for the	:
  2296                                  ;  one card.  A zero value in the byte indicates the buffer is	:
  2297                                  ;  empty.  The routines use GETBX to get the address of the	:
  2298                                  ;  buffer.							:
  2299                                  ;								:
  2300                                  ;----------------------------------------------------------------
  2301                                  
  2302                                  ;		VALUES IN AH, REQUESTING FUNCTION OF INT 14H IN ROM BIOS
  2303                                  AUXFUNC_SEND	 EQU	1	;TRANSMIT
  2304                                  AUXFUNC_RECEIVE  EQU	2	;READ
  2305                                  AUXFUNC_STATUS	 EQU	3	;REQUEST STATUS
  2306                                  
  2307                                  ;		ERROR FLAGS, REPORTED BY INT 14H
  2308                                  
  2309                                  ;	 THESE FLAGS REPORTED IN AH:
  2310                                  FLAG_DATA_READY  EQU	01H	;DATA READY
  2311                                  FLAG_OVERRUN	 EQU	02H	;OVERRUN ERROR
  2312                                  FLAG_PARITY	 EQU	04H	;PARITY ERROR
  2313                                  FLAG_FRAME	 EQU	08H	;FRAMING ERROR
  2314                                  FLAG_BREAK	 EQU	10H	;BREAK DETECT
  2315                                  FLAG_TRANHOL_EMP EQU	20H	;TRANSMIT HOLDING REGISTER EMPTY
  2316                                  FLAG_TRANSHF_EMP EQU	40H	;TRANSMIT SHIFT REGISTER EMPTY
  2317                                  FLAG_TIMEOUT	 EQU	80H	;TIMEOUT
  2318                                  
  2319                                  ;	THESE FLAGS REPORTED IN AL:
  2320                                  FLAG_DELTA_CTS	 EQU	01H	;DELTA CLEAR TO SEND
  2321                                  FLAG_DELTA_DSR	 EQU	02H	;DELTA DATA SET READY
  2322                                  FLAG_TRAIL_RING  EQU	04H	;TRAILING EDGE RING INDICATOR
  2323                                  FLAG_DELTA_SIG	 EQU	08H	;DELTA RECEIVE LINE SIGNAL DETECT
  2324                                  FLAG_CTS	 EQU	10H	;CLEAR TO SEND
  2325                                  FLAG_DSR	 EQU	20H	;DATA SET READY
  2326                                  FLAG_RING	 EQU	40H	;RING INDICATOR
  2327                                  FLAG_REC_SIG	 EQU	80H	;RECEIVE LINE SIGNAL DETECT
  2328                                  
  2329                                  ;------------------------------------------------------------------
  2330                                  ;								  :
  2331                                  ;	Read zero or more characters from Auxilary Device	  :
  2332                                  ;								  :
  2333                                  ;	input:es:[di] points to area to receive aux data	  :
  2334                                  ;	      cx has number of bytes to be read 		  :
  2335                                  ;	      "auxnum" first byte has number of aux device (rel 0):
  2336                                  ;								  :
  2337                                  ;------------------------------------------------------------------
  2338                                  
  2339                                  AUX$READ:
  2340 00000926 E311                    		jcxz	EXVEC2		; if no characters, get out
  2341 00000928 E87B00                  		call	GETBX		; put address of AUXBUF in BX
  2342 0000092B 31C0                    		xor	AX,AX		; clear AX register
  2343 0000092D 8607                    		xchg	AL,[BX] 	; Get character , if any, from
  2344                                  					;   buffer and clear buffer
  2345 0000092F 08C0                    		or	AL,AL		; if AL is nonzero there was a
  2346                                  					;   character in the buffer
  2347 00000931 7503                    		jnz	short AUX2	; if so skip AUXIN call
  2348                                  AUX1:					;
  2349 00000933 E80600                  		call	AUXIN		; get character from port
  2350                                  AUX2:					;
  2351 00000936 AA                      		stosb			; store character
  2352 00000937 E2FA                    		loop	AUX1		; if more character, go around again
  2353                                  EXVEC2: 				;
  2354 00000939 E92BFF                  		jmp	EXIT		; all done, successful exit
  2355                                  
  2356                                  ;
  2357                                  ; AUXIN: make a call on ROM BIOS to read character from
  2358                                  ;	 the auxilary device, then do some error checking.
  2359                                  ;	 If an error occurs then AUXIN jumps to ERR$CNT and
  2360                                  ;	 does NOT return to where it was called from.
  2361                                  ;
  2362                                  
  2363                                  AUXIN:
  2364 0000093C B402                    		mov	ah,AUXFUNC_RECEIVE
  2365 0000093E E83C00                  		call	AUXOP
  2366                                  		 			;check for Frame, Parity, or Overrun errors
  2367                                  		 			;WARNING: these error bits are unpredictable 
  2368                                  		 			;         if timeout (bit 7) is set
  2369 00000941 F6C40E                  		test	ah,FLAG_FRAME|FLAG_PARITY|FLAG_OVERRUN
  2370 00000944 7406                    		jz	short AROK	;No error if all bits are clear
  2371                                  
  2372                                  		; 26/05/2018
  2373                                  		;Error getting character
  2374                                  		;add	sp,2		;Remove rtn address (near call)
  2375                                  		;xor	al,al
  2376                                  		;or	al,FLAG_REC_SIG | FLAG_DSR | FLAG_CTS
  2377                                  
  2378                                  		; 13/06/2018 (IBMDOS 3.3, IBMBIO.COM)
  2379 00000946 58                      		pop	ax
  2380 00000947 B0B0                    		mov	al,FLAG_REC_SIG+FLAG_DSR+FLAG_CTS 
  2381                                  
  2382 00000949 E906FF                  		jmp	ERR$CNT
  2383                                  AROK:
  2384 0000094C C3                      		RETN			;CHAR JUST READ IS IN AL, STATUS IS IN AH
  2385                                  
  2386                                  ;----------------------------------------------------------------
  2387                                  ;								:
  2388                                  ;	Aux non-destructive read with no waiting		:
  2389                                  ;								:
  2390                                  ;	input: es:[di] points to area to receive aux data	:
  2391                                  ;								:
  2392                                  ;----------------------------------------------------------------
  2393                                  ;
  2394                                  
  2395                                  AUX$RDND:
  2396 0000094D E85600                  		call	GETBX		; have BX point to AUXBUF
  2397 00000950 8A07                    		mov	AL,[BX] 	; copy contents of buffer to AL
  2398 00000952 08C0                    		or	AL,AL		; if AL is non-zero (char in buffer)
  2399 00000954 7511                    		jnz	short AUXRDX	;   then return character
  2400 00000956 E82200                  		call	AUXSTAT 	;   if not, get status of AUX device
  2401 00000959 F6C401                  		TEST	AH,FLAG_DATA_READY ;TEST DATA READY
  2402 0000095C 740B                    		jz	short AUXBUS	;   then device is busy (not ready)
  2403                                  
  2404 0000095E A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  2405 00000960 7407                    		jz	short AUXBUS	;   then device is busy (not ready)
  2406 00000962 E8D7FF                  		call	AUXIN		;   else aux is ready, get character
  2407                                  		; 19/07/2019 - Retro DOS v3.2
  2408                                  		;call	GETBX		; have bx point to AUXBUF
  2409 00000965 8807                    		mov	[BX],AL 	; save character in buffer
  2410                                  AUXRDX: 				;
  2411 00000967 EB8B                    		jmp	RDEXIT		; return character
  2412                                  AUXBUS: 				;
  2413 00000969 E9E0FE                  		Jmp	BUS$EXIT	; jump to device busy exit
  2414                                  
  2415                                  ;----------------------------------------------------------------
  2416                                  ;								:
  2417                                  ;		Aux Output Status				:
  2418                                  ;								:
  2419                                  ;----------------------------------------------------------------
  2420                                  
  2421                                  AUX$WRST:
  2422 0000096C E80C00                  		call	AUXSTAT 	; get status of AUX in AX
  2423                                  					; now test to see if device is busy
  2424                                  					; if this bit is not set,
  2425 0000096F A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  2426 00000971 74F6                    		jz	short AUXBUS	;   then device is busy (not ready)
  2427 00000973 F6C420                  		TEST	AH,FLAG_TRANHOL_EMP ;TEST TRANSMIT HOLD REG EMPTY
  2428 00000976 74F1                    		jz	short AUXBUS	;   then device is busy (not ready)
  2429 00000978 E9ECFE                  		jmp	EXIT
  2430                                  
  2431                                  ;
  2432                                  ; AUXSTAT makes a call on the ROM-BIOS to determine the status
  2433                                  ;	  of the auxilary device
  2434                                  ;	  Outputs:
  2435                                  ;		AX is filled with status of port.
  2436                                  ;		DX is changes to specify which card - either 0, 1 (, 2, 3) ;ba
  2437                                  ;		NO other registers are modified
  2438                                  ;
  2439                                  
  2440                                  AUXSTAT:
  2441 0000097B B403                    		mov	ah,AUXFUNC_STATUS
  2442                                  		;call	AUXOP
  2443                                  		;retn
  2444                                  AUXOP:					;AH=FUNCTION CODE
  2445                                  					;0=INIT, 1=SEND, 2=RECEIVE, 3=STATUS
  2446 0000097D E80DFF                  		call	GETDX		; have DX point to proper card
  2447 00000980 CD14                    		int	14h		; call rom-bios for status
  2448 00000982 C3                      		retn
  2449                                  
  2450                                  ;----------------------------------------------------------------
  2451                                  ;								:
  2452                                  ;  Flush AUX Input buffer - set contents of AUXBUF to zero	:
  2453                                  ;								:
  2454                                  ;----------------------------------------------------------------
  2455                                  
  2456                                  AUX$FLSH:
  2457 00000983 E82000                  		call	GETBX		; get BX to point to AUXBUF
  2458 00000986 C60700                  		mov	byte [BX],0	; zero out buffer
  2459 00000989 E9DBFE                  		jmp	EXIT		; all done, successful return
  2460                                  	
  2461                                  ;----------------------------------------------------------------
  2462                                  ;								:
  2463                                  ;		Write to Auxilary Device			:
  2464                                  ;								:
  2465                                  ;----------------------------------------------------------------
  2466                                  
  2467                                  AUX$WRIT:
  2468 0000098C E3AB                    		jcxz	EXVEC2		; if CX is zero, no characters
  2469                                  				;   to be written, jump to exit
  2470                                  AUX$LOOP:
  2471 0000098E 268A05                  		mov	AL,[ES:DI]	; get character to be written
  2472 00000991 47                      		inc	DI		; move DI pointer to next character
  2473 00000992 B401                    		MOV	AH,AUXFUNC_SEND ;VALUE=1, INDICATES A WRITE
  2474 00000994 E8E6FF                  		CALL	AUXOP		;SEND CHARACTER OVER AUX PORT
  2475                                  
  2476 00000997 F6C480                  		TEST	AH,FLAG_TIMEOUT ;CHECK FOR ERROR
  2477 0000099A 7405                    		jz	short AWOK	;   then no error
  2478 0000099C B00A                    		mov	AL,10		;   else indicate write fault
  2479 0000099E E9B1FE                  		jmp	ERR$CNT 	; call error routines
  2480                                  
  2481                                  					; if CX is non-zero, still more
  2482                                  AWOK:
  2483 000009A1 E2EB                    		loop	AUX$LOOP	; more characrter to print
  2484 000009A3 E9C1FE                  		jmp	EXIT		; all done, successful return
  2485                                  
  2486                                  ;
  2487                                  ;  GETBX puts the address of AUXBUF (the Auxilary Device buffer)
  2488                                  ;	 in BX. After calling GETBX, a routine can get to AUXBUF
  2489                                  ;	 with [BX].
  2490                                  ;
  2491                                  ;  NOTE: The getdx routine is in msbio1 and looks like:
  2492                                  ;	mov	dx,word ptr cs:[auxnum]
  2493                                  ;
  2494                                  
  2495                                  GETBX:
  2496 000009A6 E8E4FE                  		call	GETDX
  2497 000009A9 89D3                    		mov	BX,DX
  2498 000009AB 81C3[B400]              		add	BX,AUXBUF
  2499 000009AF C3                      		retn
  2500                                  
  2501                                  ;-----------------------------------------------------------------------------
  2502                                  ; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
  2503                                  ;-----------------------------------------------------------------------------
  2504                                  ; 23/03/2018 - Retro DOS v2.0
  2505                                  
  2506                                  ;----------------------------------------------------------------
  2507                                  ;								:
  2508                                  ;	P R N - PRINTER DEVICE					:
  2509                                  ;								:
  2510                                  ;								:
  2511                                  ;   This file contains the Printer Device Driver. The		:
  2512                                  ; printer driver handles calls to the printers. Four devices	:
  2513                                  ; use this code: PRN, LPT1, LPT2, and LPT3. The beginning	:
  2514                                  ; of the interrupt entry point for these device sets the	:
  2515                                  ; variable AUXNUM in the msbio.asm module. The number is	:
  2516                                  ; in AUXNUM dictates which device will to written to: 0 for	:
  2517                                  ; PRN and LPT1, 1 for LPT2, and 2 for LPT3.			:
  2518                                  ;								:
  2519                                  ;   The routines in this files are:				:
  2520                                  ;								:
  2521                                  ;	routine 		function			:
  2522                                  ;	------- 		--------			:
  2523                                  ;	PRN$WRIT		Write to printer device 	:
  2524                                  ;	PRN$STAT		Printer status routine		:
  2525                                  ;	PRN$TilBusy		Print spooler routine		:
  2526                                  ;	Prn$GenIOCTL		Generic IOCTL routine		:
  2527                                  ;								:
  2528                                  ;  These routines are not called directly.  Call are made via	:
  2529                                  ; the strategy and interrupt entry point (see Device Header).	:
  2530                                  ;								:
  2531                                  ;----------------------------------------------------------------
  2532                                  
  2533                                  ; IBM ROM STATUS BITS (I DON'T TRUST THEM, NEITHER SHOULD YOU)             
  2534                                  									   
  2535                                  NOTBUSYSTATUS	equ 10000000b		; NOT BUSY			   
  2536                                  ACKSTATUS	equ 01000000b		; ACKNOWLEDGE (FOR WHAT?)	   
  2537                                  NOPAPERSTATUS	equ 00100000b		; NO MORE PAPER 		   
  2538                                  SELECTEDSTATUS	equ 00010000b		; THE PRINTER SAID IT WAS SELECTED 
  2539                                  IOERRSTATUS	equ 00001000b		; SOME KINDA ERROR		   
  2540                                  RESERVED	equ 00000110b		; NOPS				   
  2541                                  TIMEOUTSTATUS	equ 00000001b		; TIME OUT.			   
  2542                                  									   
  2543                                  									   
  2544                                  ; WARNING!!! THE IBM ROM DOES NOT RETURN JUST ONE BIT. IT RETURNS A	   
  2545                                  ; WHOLE SLEW OF BITS, ONLY ONE OF WHICH IS CORRECT.			   
  2546                                  									   
  2547                                  ;----------------------------------------------------------------
  2548                                  ;								:
  2549                                  ;		WRITE TO PRINTER DEVICE 			:
  2550                                  ;								:
  2551                                  ;   CX has count of bytes to be printed 			:
  2552                                  ;   ES:DI point to source buffer contains characters		:
  2553                                  ;   AuxNum (in msbio.asm) has printer number			:
  2554                                  ;								:
  2555                                  ;----------------------------------------------------------------
  2556                                  						   
  2557                                  PRN$WRIT:
  2558 000009B0 E310                    		jcxz	EXVEC3			; no chars to output, Get out
  2559                                  PRN$LOOP:
  2560 000009B2 BB0200                  		mov	BX,2			; Initialize retry flag
  2561                                  PRN$out:
  2562 000009B5 268A05                  		mov	AL,[ES:DI]		; Get a character into AL
  2563 000009B8 47                      		inc	DI			; Point to next character
  2564 000009B9 30E4                    		XOR	AH,AH			; AH=0 => OUTPUT CHAR IN DL	   
  2565 000009BB E82400                  		call	PRNOP			; print character
  2566 000009BE 7505                    		jnz	short PrRetry 		; if error, try to print again
  2567 000009C0 E2F0                    		loop	PRN$LOOP		; if more character, keep printing
  2568                                  EXVEC3:
  2569 000009C2 E9A2FE                  		jmp	EXIT
  2570                                  PrRetry:
  2571 000009C5 4F                      		dec	DI			; undo the inc above...
  2572 000009C6 4B                      		dec	BX			; Decrement retry count
  2573 000009C7 75EC                    		jnz	short PRN$out 		; See if done with retrys
  2574                                  PMESSG:
  2575 000009C9 E986FE                  		JMP	ERR$CNT 		; if so return with the error
  2576                                  
  2577                                  ;----------------------------------------------------------------
  2578                                  ;								:
  2579                                  ;		PRINTER STATUS ROUTINE				:
  2580                                  ;								:
  2581                                  ;----------------------------------------------------------------
  2582                                  ;
  2583                                  						   
  2584                                  PRN$STAT:
  2585 000009CC E81100                  		call	PRNSTAT 		; get the status
  2586 000009CF 75F8                    		jnz	short PMESSG		; if error jump to error routine
  2587 000009D1 B009                    		MOV	AL,9			; AGAIN, ASSUME OUT OF PAPER...    
  2588 000009D3 F6C420                  		TEST	AH,NOPAPERSTATUS					   
  2589 000009D6 75F1                    		JNZ	short PMESSG
  2590 000009D8 F6C480                  		TEST	AH,NOTBUSYSTATUS					   
  2591 000009DB 75E5                    		jnz	short EXVEC3		; if not busy return via EXVEC3
  2592 000009DD E96CFE                  		JMP	BUS$EXIT		; else busy, return to busy exit   
  2593                                  
  2594                                  ;
  2595                                  ;   PRNSTAT	get printer status
  2596                                  ;   PRNOP	print a character
  2597                                  ;
  2598                                  ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
  2599                                  ; printer routines.  The routines share code which calls on the bios and
  2600                                  ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
  2601                                  ; only by the value put into AH before the ROM-BIOS call.
  2602                                  ;
  2603                                  ;   INPUT	if PRNOP then character in AL
  2604                                  ;
  2605                                  ;   OUTPUT	- AL holds error code
  2606                                  ;		- AH status byte from printer
  2607                                  ;		- flag NZ if error
  2608                                  
  2609                                  PRNSTAT:						   
  2610 000009E0 B402                    		mov	AH,2			; set command for get status   *
  2611                                  PRNOP:
  2612 000009E2 E8A8FE                  		call	GETDX			; determine which printer      *
  2613 000009E5 CD17                    		int	17h			; call ROM-BIOS printer routine  *
  2614                                  
  2615 000009E7 F6C408                  		TEST	AH,IOERRSTATUS		; I/O ERROR?			   
  2616 000009EA 740A                    		JZ	short CHECKNOTREADY	; NO, TRY NOT READY		   
  2617                                  									   
  2618                                  ; AT THIS POINT, WE KNOW WE HAVE AN ERROR. THE CONVERSE IS NOT TRUE.	   
  2619                                  									   
  2620 000009EC B009                    		MOV	AL,9			; FIRST, ASSUME OUT OF PAPER	   
  2621 000009EE F6C420                  		TEST	AH,NOPAPERSTATUS	; OUT OF PAPER SET?		   
  2622 000009F1 7502                    		JNZ	short RET1			; YES, ERROR IS SET
  2623 000009F3 FEC0                    		INC	AL			; INDICATE I/O ERROR		   
  2624                                  RET1:									   
  2625                                  									   
  2626                                  ; WE HAVE TRIAGED NOW FOR OUT OF PAPER AND IO ERR (IGNORING TIME-OUT)	   
  2627                                  									   
  2628 000009F5 C3                      		RETN				; RETURN WITH ERROR		   
  2629                                  									   
  2630                                  ; THE BITS SAID NO ERROR.  UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WOR  K
  2631                                  ; HERE. 								   
  2632                                  									   
  2633                                  CHECKNOTREADY:								   
  2634 000009F6 B002                    		MOV	AL,2			; ASSUME NOT-READY		   
  2635 000009F8 F6C401                  		TEST	AH,TIMEOUTSTATUS	; IS TIME-OUT SET?		   
  2636                                  						; IF NZ THEN ERROR, ELSE OK???	   
  2637                                  PRNOP2: 								   
  2638 000009FB C3                      		RETN
  2639                                  
  2640                                  ;26/05/2018
  2641                                  
  2642                                  ;----------------------------------------------------------------
  2643                                  ;								:
  2644                                  ;		Output until Busy				:
  2645                                  ;								:
  2646                                  ; Output until busy. This entry point is used EXCLUSIVELY by	:
  2647                                  ; the print spoolers. Under no curcumstances should the device  :
  2648                                  ; driver block waiting for the device to become ready.		:
  2649                                  ;								:
  2650                                  ;   Inputs:	CX has count of bytes to output.		:
  2651                                  ;		ES:DI points to source buffer			:
  2652                                  ;   Outputs:	Set the number of bytes transferred		:
  2653                                  ;		  appropriately.				:
  2654                                  ;								:
  2655                                  ;----------------------------------------------------------------
  2656                                  
  2657                                  PRN$TILBUSY:
  2658 000009FC 1E                      	push	DS			; save DS
  2659 000009FD 06                      	push	ES			; copy ES to DS
  2660 000009FE 1F                      	pop	DS
  2661 000009FF 89FE                    	mov	SI,DI			; everything is set for LODSB
  2662                                  PRN$TilBLoop:
  2663 00000A01 51                      	push	CX
  2664 00000A02 53                      	push	BX
  2665 00000A03 31DB                    	xor	BX,BX
  2666 00000A05 2E8A1E[6805]            	mov	BL,[CS:PRINTDEV]
  2667 00000A0A D1E3                    	shl	BX,1
  2668 00000A0C 2E8B8F[6A05]            	mov	CX,[CS:BX+WAIT_COUNT]	; wait COUNT times to come ready
  2669 00000A11 5B                      	pop	BX
  2670                                  PRN$GetStat:
  2671 00000A12 E8CBFF                  	call	PRNSTAT 		; get status
  2672 00000A15 751E                    	jnz	short PRN$BPERR		; if error jump to error routine
  2673 00000A17 F6C480                  	TEST	AH,10000000b		; READY YET?
  2674 00000A1A E1F6                    	loopz	PRN$GetStat		; if busy keep trying
  2675 00000A1C 59                      	pop	CX			; get original count
  2676 00000A1D 7417                    	jz	short PRN$BErr		; still not ready => done
  2677 00000A1F AC                      	lodsb
  2678 00000A20 30E4                    	XOR	AH,AH
  2679 00000A22 E8BDFF                  	call	PRNOP			; print the character
  2680 00000A25 750F                    	jnz	short PRN$BErr		; error
  2681 00000A27 E2D8                    	loop	PRN$TilBLoop		; go for more
  2682                                  PRN$B:
  2683 00000A29 1F                      	pop	DS			; recover DS
  2684 00000A2A 2EC51E[B000]            	lds	BX,[CS:PTRSAV]		; get pointer to header
  2685                                  
  2686 00000A2F 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2687 00000A32 E932FE                  	jmp	EXIT			; all done, successful return
  2688                                  
  2689                                  PRN$BPERR:
  2690 00000A35 59                      	pop	CX			; recover number of char left
  2691                                  PRN$BErr:
  2692 00000A36 1F                      	pop	DS			; get pointer to header
  2693 00000A37 2EC51E[B000]            	lds	BX,[CS:PTRSAV]
  2694 00000A3C 294F12                  	sub	[BX+COUNT],CX		; Determine number of succ. I/O's
  2695 00000A3F E918FE                  	jmp	ERR$EXIT		; jump to error exit
  2696                                  
  2697                                  ;
  2698                                  ; Prn$GenIOCTL:
  2699                                  ;
  2700                                  ; Manipulates the value in WAIT_COUNT depending on the value passed in the
  2701                                  ; Generic IOCTL packet.
  2702                                  ; It either sets or returns the current value for the retry count for the
  2703                                  ; device.
  2704                                  ;
  2705                                  
  2706                                  PRN$GENIOCTL:
  2707                                  
  2708 00000A42 C43E[B000]              	les	di,[PTRSAV]
  2709 00000A46 26807D0D05              	cmp	byte [es:di+IOCTL_REQ.MAJORFUNCTION],IOC_PC
  2710 00000A4B 7403                    	je	short PrnFunc_OK
  2711                                  PrnFuncErr:
  2712 00000A4D E900FE                  	jmp	CMDERR
  2713                                  PrnFunc_OK:
  2714 00000A50 268A450E                	mov	al,[es:di+IOCTL_REQ.MINORFUNCTION]
  2715 00000A54 26C47D13                	les	di,[es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
  2716 00000A58 31DB                    	xor	bx,bx
  2717 00000A5A 8A1E[6805]              	mov	bl,[PRINTDEV]		; get index into retry counts
  2718 00000A5E D1E3                    	shl	bx,1
  2719 00000A60 8B8F[6A05]              	mov	CX,[BX+WAIT_COUNT]	; pull out retry count for device
  2720 00000A64 3C65                    	cmp	al,GET_RETRY_COUNT
  2721 00000A66 7407                    	jz	short PrnGetCount
  2722 00000A68 3C45                    	cmp	al,SET_RETRY_COUNT
  2723 00000A6A 75E1                    	jnz	short PrnFuncErr
  2724 00000A6C 268B0D                  	mov	cx,[es:di+A_RETRYCOUNT.RC_COUNT]  ; A_RETRYCOUNT.RC_COUNT = 0 
  2725                                  PrnGetCount:
  2726 00000A6F 898F[6A05]              	mov	[BX+WAIT_COUNT],CX	; place "new" retry count
  2727 00000A73 26890D                  	mov	[es:di+A_RETRYCOUNT.RC_COUNT],cx ; return current retry count
  2728 00000A76 E9EEFD                  	jmp	EXIT
  2729                                  
  2730                                  ;-----------------------------------------------------------------------------
  2731                                  ; MSCLOCK.ASM - MSDOS 3.3 - 24/07/1987
  2732                                  ;-----------------------------------------------------------------------------
  2733                                  ; 23/03/2018 - Retro DOS v2.0
  2734                                  
  2735                                  ;----------------------------------------				  
  2736                                  ;	CMOS EQUATES FOR THIS SYSTEM	:  ; 26/03/2018 - CMOSEQU.INC, 1987
  2737                                  ;-----------------------------------------------------------------------------
  2738                                  CMOS_PORT	EQU	070H		; I/O ADDRESS OF CMOS ADDRESS PORT	 
  2739                                  CMOS_DATA	EQU	071H		; I/O ADDRESS OF CMOS DATA PORT 	 
  2740                                  NMI		EQU	10000000B	; DISABLE NMI INTERRUPTS MASK - 	 
  2741                                  					;  HIGH BIT OF CMOS LOCATION ADDRESS
  2742                                  ;---------- CMOS TABLE LOCATION ADDRESS'S ## --------------------------------- 
  2743                                  CMOS_SECONDS	EQU	000H		; SECONDS				 
  2744                                  CMOS_SEC_ALARM	EQU	001H		; SECONDS ALARM  ## NOTE:  ALL LOCATIONS 
  2745                                  CMOS_MINUTES	EQU	002H		; MINUTES	      | IN THE CMOS AREA 
  2746                                  CMOS_MIN_ALARM	EQU	003H		; MINUTES ALARM       | ARE IBM USE ONLY 
  2747                                  CMOS_HOURS	EQU	004H		; HOURS 	      | AND  SUBJECT  TO 
  2748                                  CMOS_HR_ALARM	EQU	005H		; HOURS ALARM	      | CHANGE. ONLY THE 
  2749                                  CMOS_DAY_WEEK	EQU	006H		; DAY OF THE WEEK     | POST & BIOS CODE 
  2750                                  CMOS_DAY_MONTH	EQU	007H		; DAY OF THE MONTH    | SHOULD	DIRECTLY 
  2751                                  CMOS_MONTH	EQU	008H		; MONTH 	      | ACCESS LOCATIONS 
  2752                                  CMOS_YEAR	EQU	009H		; YEAR (TWO DIGITS)   | IN CMOS STORAGE. 
  2753                                  CMOS_REG_A	EQU	00AH		; STATUS REGISTER A   '----------------- 
  2754                                  CMOS_REG_B	EQU	00BH		; STATUS REGISTER B  ALARM		 
  2755                                  CMOS_REG_C	EQU	00CH		; STATUS REGISTER C  FLAGS		 
  2756                                  CMOS_REG_D	EQU	00DH		; STATUS REGISTER D  BATTERY		 
  2757                                  CMOS_DIAG	EQU	00EH		; POST DIAGNOSTIC STATUS RESULTS BYTE	 
  2758                                  CMOS_SHUT_DOWN	EQU	00FH		; SHUTDOWN STATUS COMMAND BYTE		 
  2759                                  CMOS_DISKETTE	EQU	010H		; DISKETTE DRIVE TYPE BYTE	      ;  
  2760                                  ;		EQU	011H		; - RESERVED			      ;C 
  2761                                  CMOS_DISK	EQU	012H		; FIXED DISK TYPE BYTE		      ;H 
  2762                                  ;		EQU	013H		; - RESERVED			      ;E 
  2763                                  CMOS_EQUIP	EQU	014H		; EQUIPMENT WORD LOW BYTE	      ;C 
  2764                                  CMOS_B_M_S_LO	EQU	015H		; BASE MEMORY SIZE - LOW BYTE (X1024) ;K 
  2765                                  CMOS_B_M_S_HI	EQU	016H		; BASE MEMORY SIZE - HIGH BYTE	      ;S 
  2766                                  CMOS_E_M_S_LO	EQU	017H		; EXPANSION MEMORY SIZE - LOW BYTE    ;U 
  2767                                  CMOS_E_M_S_HI	EQU	018H		; EXPANSION MEMORY SIZE - HIGH BYTE   ;M 
  2768                                  CMOS_DISK_1	EQU	019H		; FIXED DISK TYPE - DRIVE C EXTENSION ;E 
  2769                                  CMOS_DISK_2	EQU	01AH		; FIXED DISK TYPE - DRIVE D EXTENSION ;D 
  2770                                  ;		EQU	01BH		; - 1BH THROUGH 2DH - RESERVED	      ;  
  2771                                  CMOS_CKSUM_HI	EQU	02EH		; CMOS CHECKSUM - HIGH BYTE	      ;* 
  2772                                  CMOS_CKSUM_LO	EQU	02FH		; CMOS CHECKSUM - LOW BYTE	      ;* 
  2773                                  CMOS_U_M_S_LO	EQU	030H		; USABLE MEMORY ABOVE 1 MEG - LOW BYTE	 
  2774                                  CMOS_U_M_S_HI	EQU	031H		; USABLE MEMORY ABOVE 1 MEG - HIGH BYTE  
  2775                                  CMOS_CENTURY	EQU	032H		; DATE CENTURY BYTE (BCD)		 
  2776                                  CMOS_INFO128	EQU	033H		; 128KB INFORMATION STATUS FLAG BYTE	 
  2777                                  ;		EQU	034H		; - 34H THROUGH 3FH - RESERVED
  2778                                  
  2779                                  ;----------------------------------------------------------------
  2780                                  ;								:
  2781                                  ;		    CLOCK DEVICE DRIVER 			:
  2782                                  ;								:
  2783                                  ;								:
  2784                                  ;   This file contains the Clock Device Driver. 		:
  2785                                  ;								:
  2786                                  ;   The routines in this files are:				:
  2787                                  ;								:
  2788                                  ;	routine 		function			:
  2789                                  ;	------- 		--------			:
  2790                                  ;	TIM$WRIT		Set the current time		:
  2791                                  ;	TIM$READ		Read the current time		:
  2792                                  ;	Time_To_Ticks		Convert time to corresponding	:
  2793                                  ;				  number of clock ticks 	:
  2794                                  ;								:
  2795                                  ; The clock ticks at the rate of:				:
  2796                                  ;								:
  2797                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  2798                                  ; See each routine for information on the use.			:
  2799                                  ;								:
  2800                                  ;----------------------------------------------------------------
  2801                                  
  2802                                  ; 19/07/2019
  2803                                  
  2804                                  ;********************************************************************
  2805                                  ; Indirect call address of TIME_TO_TICKS procedure.
  2806                                  ;This will be used by the relocatable portable suspend/resume code.
  2807                                  
  2808                                  TimeToTicks:
  2809 00000A79 [7B0A]                  		dw	TIME_TO_TICKS
  2810                                  
  2811                                  ;--------------------------------------------------------------------
  2812                                  ;
  2813                                  ; convert time to ticks
  2814                                  ; input : time in CX and DX
  2815                                  ; ticks returned in CX:DX
  2816                                  ;
  2817                                  
  2818                                  TIME_TO_TICKS:
  2819                                  		; first convert from Hour,min,sec,hund. to
  2820                                  		; total number of 100th of seconds
  2821 00000A7B B03C                    		mov	AL,60
  2822 00000A7D F6E5                    		mul	CH		;Hours to minutes
  2823 00000A7F B500                    		mov	CH,0
  2824 00000A81 01C8                    		add	AX,CX		;Total minutes
  2825 00000A83 B97017                  		mov	CX,6000 	;60*100
  2826 00000A86 89D3                    		mov	BX,DX		;Get out of the way of the multiply
  2827 00000A88 F7E1                    		mul	CX		;Convert to 1/100 sec
  2828 00000A8A 89C1                    		mov	CX,AX
  2829 00000A8C B064                    		mov	AL,100
  2830 00000A8E F6E7                    		mul	BH		;Convert seconds to 1/100 sec
  2831 00000A90 01C1                    		add	CX,AX		;Combine seconds with hours and min.
  2832 00000A92 83D200                  		adc	DX,0		;Ripple carry
  2833 00000A95 B700                    		mov	BH,0
  2834 00000A97 01D9                    		add	CX,BX		;Combine 1/100 sec
  2835 00000A99 83D200                  		adc	DX,0
  2836                                  
  2837                                  		;;Rev 3.30 Modification
  2838                                  		;DX:CX IS TIME IN 1/100 SEC
  2839 00000A9C 92                      		XCHG	AX,DX
  2840 00000A9D 91                      		XCHG	AX,CX		;NOW TIME IS IN CX:AX
  2841 00000A9E BB0BE9                  		MOV	BX,59659
  2842 00000AA1 F7E3                    		MUL	BX		;MULTIPLY LOW HALF
  2843 00000AA3 87D1                    		XCHG	DX,CX
  2844 00000AA5 92                      		XCHG	AX,DX		;CX->AX, AX->DX, DX->CX
  2845 00000AA6 F7E3                    		MUL	BX		;MULTIPLY HIGH HALF
  2846 00000AA8 01C8                    		ADD	AX,CX		;COMBINE OVERLAPPING PRODUCTS
  2847 00000AAA 83D200                  		ADC	DX,0
  2848 00000AAD 92                      		XCHG	AX,DX		;AX:DX=TIME*59659
  2849 00000AAE BB0500                  		MOV	BX,5
  2850 00000AB1 F6F3                    		DIV	BL		;DIVIDE HIGH HALF BY 5
  2851 00000AB3 88C1                    		MOV	CL,AL
  2852 00000AB5 B500                    		MOV	CH,0
  2853 00000AB7 88E0                    		MOV	AL,AH		;REMAINDER OF DIVIDE-BY-5
  2854 00000AB9 98                      		CBW
  2855 00000ABA 92                      		XCHG	AX,DX		;USE IT TO EXTEND LOW HALF
  2856 00000ABB F7F3                    		DIV	BX		;DIVIDE LOW HALF BY 5
  2857 00000ABD 89C2                    		MOV	DX,AX
  2858                                  			; CX:DX is now number of ticks in time
  2859 00000ABF C3                      		retn
  2860                                  
  2861                                  ;--------------------------------------------------------------------
  2862                                  ;
  2863                                  ; Settime sets the current time
  2864                                  ;
  2865                                  ; On entry ES:[DI] has the current time:
  2866                                  ;
  2867                                  ;	number of days since 1-1-80	(WORD)
  2868                                  ;	minutes (0-59)			(BYTE)
  2869                                  ;	hours (0-23)			(BYTE)
  2870                                  ;	hundredths of seconds (0-99)	(BYTE)
  2871                                  ;	seconds (0-59)			(BYTE)
  2872                                  ;
  2873                                  ; Each number has been checked for the correct range.
  2874                                  ;
  2875                                  
  2876                                  TIM$WRIT:
  2877 00000AC0 268B05                  		mov	AX,[ES:DI]
  2878 00000AC3 50                      		push	AX		;DAYCNT. We need to set this at the very
  2879                                  					;  end to avoid tick windows.
  2880                                  		;11/06/2018
  2881                                  		;26/05/2018
  2882                                  
  2883                                  		;;Rev 3.30 Modification
  2884 00000AC4 803E[7405]00            		cmp	byte [HaveCMOSClock], 0
  2885 00000AC9 7426                    		je	short No_CMOS_1
  2886 00000ACB 268A4503                		mov	al,[es:di+3]		;get binary hours
  2887 00000ACF FF16[8305]              		call	word [BinToBCD]		;convert to BCD
  2888 00000AD3 88C5                    		mov	ch,al			;CH = BCD hours
  2889 00000AD5 268A4502                		mov	al,[es:di+2]		;get binary minutes
  2890 00000AD9 FF16[8305]              		call	word [BinToBCD]		;convert to BCD
  2891 00000ADD 88C1                    		mov	cl,al			;CL = BCD minutes
  2892 00000ADF 268A4505                		mov	al,[es:di+5]		;get binary seconds
  2893 00000AE3 FF16[8305]              		call	word [BinToBCD]		;convert to BCD
  2894 00000AE7 88C6                    		mov	dh,al			;DH = BCD seconds
  2895 00000AE9 B200                    		mov	dl,0			;DL = 0 (ST) or 1 (DST)
  2896 00000AEB FA                      		cli				;turn off timer
  2897 00000AEC B403                    		mov	ah,03h			;set RTC time
  2898 00000AEE CD1A                    		int	1Ah			;call rom bios clock routine
  2899 00000AF0 FB                      		sti
  2900                                  		;;End of Modification
  2901                                  No_CMOS_1:
  2902 00000AF1 268B4D02                		mov	CX,[ES:DI+2]
  2903 00000AF5 268B5504                		mov	DX,[ES:DI+4]
  2904                                  		;;Rev 3.30 Modification
  2905 00000AF9 E87FFF                  		call	TIME_TO_TICKS		; convert time to ticks
  2906                                  						;CX:DX now has time in ticks
  2907 00000AFC FA                      		cli				; Turn off timer
  2908 00000AFD B401                    		mov	AH, 1			; command is set time in clock
  2909 00000AFF CD1A                    		int	1Ah			; call rom-bios clock routines
  2910 00000B01 8F06[7205]              		pop	word [DAYCNT]
  2911 00000B05 FB                      		sti
  2912                                  		;CMOS clock -------------------------------------
  2913 00000B06 803E[7405]00            		cmp	byte [HaveCMOSClock], 0
  2914 00000B0B 740A                    		je	short No_CMOS_2
  2915                                  		; 13/06/2018
  2916 00000B0D FF16[8505]              		call	word [DaycntToDay]	; convert to BCD format
  2917 00000B11 FA                      		cli				; Turn off timer
  2918 00000B12 B405                    		mov	AH,05h			; set RTC date
  2919 00000B14 CD1A                    		int	1Ah			; call rom-bios clock routines
  2920 00000B16 FB                      		sti
  2921                                  		;------------------------------------------------
  2922                                  No_CMOS_2:
  2923 00000B17 E94DFD                  		jmp	EXIT
  2924                                  		;;End of Modification
  2925                                  
  2926                                  ;--------------------------------------------------------------------
  2927                                  ;
  2928                                  ; Gettime reads date and time
  2929                                  ; and returns the following information:
  2930                                  ;
  2931                                  ;	ES:[DI]  =count of days since 1-1-80
  2932                                  ;	ES:[DI+2]=hours
  2933                                  ;	ES:[DI+3]=minutes
  2934                                  ;	ES:[DI+4]=seconds
  2935                                  ;	ES:[DI+5]=hundredths of seconds
  2936                                  ;
  2937                                  
  2938                                  TIM$READ:				; read the clock
  2939 00000B1A 30E4                    		xor	AH,AH		; set command to read clock
  2940 00000B1C CD1A                    		int	1Ah		; call rom-bios to get time
  2941                                  
  2942 00000B1E 08C0                    		or	al,al		; check for a new day
  2943 00000B20 7404                    		jz	short noroll1 	; if al=0 then don't reset day count
  2944 00000B22 FF06[7205]              		INC	word [DAYCNT]	; CATCH ROLLOVE
  2945                                  noroll1:
  2946 00000B26 8B36[7205]              		MOV	SI,[DAYCNT]
  2947                                  
  2948                                  ;
  2949                                  ; we now need to convert the time in tick to the time in 100th of
  2950                                  ; seconds.  The relation between tick and seconds is:
  2951                                  ;
  2952                                  ;		 65536 seconds
  2953                                  ;	       ----------------
  2954                                  ;		1,193,180 tick
  2955                                  ;
  2956                                  ; To get to 100th of second we need to multiply by 100. The equation is:
  2957                                  ;
  2958                                  ;	Ticks from clock  * 65536 * 100
  2959                                  ;      ---------------------------------  = time in 100th of seconds
  2960                                  ;		1,193,180
  2961                                  ;
  2962                                  ; Fortunately this formula simplifies to:
  2963                                  ;
  2964                                  ;	Ticks from clock * 5 * 65,536
  2965                                  ;      --------------------------------- = time in 100th of seconds
  2966                                  ;		59,659
  2967                                  ;
  2968                                  ; The calculation is done by first multipling tick by 5. Next we divide by
  2969                                  ; 59,659.  In this division we multiply by 65,536 by shifting the dividend
  2970                                  ; my 16 bits to the left.
  2971                                  ;
  2972                                  ; start with ticks in CX:DX
  2973                                  ; multiply by 5
  2974 00000B2A 89C8                    		MOV	AX,CX
  2975 00000B2C 89D3                    		MOV	BX,DX
  2976 00000B2E D1E2                    		SHL	DX,1
  2977 00000B30 D1D1                    		RCL	CX,1		;TIMES 2
  2978 00000B32 D1E2                    		SHL	DX,1
  2979 00000B34 D1D1                    		RCL	CX,1		;TIMES 4
  2980 00000B36 01DA                    		ADD	DX,BX
  2981 00000B38 11C8                    		ADC	AX,CX		;TIMES 5
  2982 00000B3A 92                      		XCHG	AX,DX		
  2983                                  	
  2984                                  
  2985                                  ; now have ticks * 5 in DX:AX
  2986                                  ; we now need to multiply by 65,536 and divide by 59659 d.
  2987                                  
  2988 00000B3B B90BE9                  		mov	CX,59659	; get divisor
  2989 00000B3E F7F1                    		div	CX
  2990                                  					; DX now has remainder
  2991                                  					; AX has high word of final quotient
  2992 00000B40 89C3                    		mov	BX,AX		; put high work if safe place
  2993 00000B42 31C0                    		xor	AX,AX		; this is the multiply by 65536
  2994 00000B44 F7F1                    		div	CX		; BX:AX now has time in 100th of seconds
  2995                                  
  2996                                  ;
  2997                                  ;Rounding based on the remainder may be added here
  2998                                  ;The result in BX:AX is time in 1/100 second.
  2999 00000B46 89DA                    		mov	DX,BX
  3000 00000B48 B9C800                  		mov	CX,200		;Extract 1/100's
  3001                                  ;Division by 200 is necessary to ensure no overflow--max result
  3002                                  ;is number of seconds in a day/2 = 43200.
  3003 00000B4B F7F1                    		div	CX
  3004 00000B4D 80FA64                  		cmp	DL,100		;Remainder over 100?
  3005 00000B50 7203                    		jb	short NOADJ
  3006 00000B52 80EA64                  		sub	DL,100		;Keep 1/100's less than 100
  3007                                  NOADJ:
  3008 00000B55 F5                      		cmc			;If we subtracted 100, carry is now set
  3009 00000B56 88D3                    		mov	BL,DL		;Save 1/100's
  3010                                  ;To compensate for dividing by 200 instead of 100, we now multiply
  3011                                  ;by two, shifting a one in if the remainder had exceeded 100.
  3012 00000B58 D1D0                    		rcl	AX,1
  3013 00000B5A B200                    		mov	DL,0
  3014 00000B5C D1D2                    		rcl	DX,1
  3015 00000B5E B93C00                  		mov	CX,60		;Divide out seconds
  3016 00000B61 F7F1                    		div	CX
  3017 00000B63 88D7                    		mov	BH,DL		;Save the seconds
  3018 00000B65 F6F1                    		div	CL		;Break into hours and minutes
  3019 00000B67 86C4                    		xchg	AL,AH
  3020                                  
  3021                                  ;Time is now in AX:BX (hours, minutes, seconds, 1/100 sec)
  3022                                  
  3023 00000B69 50                      		push	AX
  3024 00000B6A 89F0                    		MOV	AX,SI		; DAYCNT
  3025 00000B6C AB                      		stosw
  3026 00000B6D 58                      		pop	AX
  3027 00000B6E AB                      		stosw
  3028 00000B6F 89D8                    		mov	AX,BX
  3029 00000B71 AB                      		stosw
  3030 00000B72 E9F2FC                  		jmp	EXIT
  3031                                  
  3032                                  ;-----------------------------------------------------------------------------
  3033                                  ; MSDISK.ASM (1) - MSDOS 3.3 - 02/02/1988
  3034                                  ;-----------------------------------------------------------------------------
  3035                                  ; 26/05/2018 - Retro DOS v3.0
  3036                                  ; 23/03/2018 - Retro DOS v2.0
  3037                                  
  3038                                  ;------------------------------------------------------------------------
  3039                                  ;									:
  3040                                  ;	       DISK INTERFACE ROUTINES					:
  3041                                  ;									:
  3042                                  ;									:
  3043                                  ;   This file contains the Disk Device Driver.				:
  3044                                  ;									:
  3045                                  ;   The routines in this files are:					:
  3046                                  ;									:
  3047                                  ;	routine 		function				:
  3048                                  ;	------- 		--------				:
  3049                                  ;									:
  3050                                  ;	MEDIA$CHK		Determine if media in drive has changed :
  3051                                  ;									:
  3052                                  ;	GET$BPB 		Build a valid BPB for drive		:
  3053                                  ;									:
  3054                                  ;	DSK$REM 		Determine if disk has removable media	:
  3055                                  ;									:
  3056                                  ;	DSK$WRTV		Disk write with verify			:
  3057                                  ;									:
  3058                                  ;	DSK$WRT 		Disk write				:
  3059                                  ;									:
  3060                                  ;	DSK$READ		Read disk				:
  3061                                  ;									:
  3062                                  ;									:
  3063                                  ;  These routines are not called directly. Call are made via		:
  3064                                  ; the strategy and interrupt entry point (see Device Header).		:
  3065                                  ;									:
  3066                                  ;  Data structures:							:
  3067                                  ;	There are two main types of data structures associated with	:
  3068                                  ;  the disk drives. The first is the BDS. BDS is the Bios Data		:
  3069                                  ;  structure. There is one BDS for each logical drive in the system.	:
  3070                                  ;  All the BDS's are linked together in a list with the pointer to the  :
  3071                                  ;  first BDS being found in START_BDS. The BDS hold various values	:
  3072                                  ;  important to the disk drive. For example there is a field for last	:
  3073                                  ;  time accesses. As actions take place in the system the BDS are	:
  3074                                  ;  update to reflect the actions. For example if there is a read to	:
  3075                                  ;  a disk the last access field for the BDS for that drive is updated	:
  3076                                  ;  to the current time. 						:
  3077                                  ;	 The second data structure associated with disk drives is the	:
  3078                                  ;  BPB. A BPB is a Bios Parameter Block. The BPB contains information   :
  3079                                  ;  about the media inside a disk drive. Some on the fields in the BPB	:
  3080                                  ;  are Sectors per track, number of FATs, and number of tracks. This	:
  3081                                  ;  information is used to tell where sectors are on the disk. For	:
  3082                                  ;  example, if we need to read logical sector 52:			:
  3083                                  ;									:
  3084                                  ;	Diskette			Track	Sector	Side		:
  3085                                  ;    single density							:
  3086                                  ;    eight sectors per track		  6	   5	  0		:
  3087                                  ;									:
  3088                                  ;    double density							:
  3089                                  ;    nine sectors per track		  2	   7	  1		:
  3090                                  ;									:
  3091                                  ;  The BPB for the media in the drive is stored in the BDS for the	:
  3092                                  ;  drive. If the user changes the floppy in the drive a call is		:
  3093                                  ;  made to GET$BPB to build a new BPB in the BDS. See this routine	:
  3094                                  ;  for the algorithm.							:
  3095                                  ;									:
  3096                                  ;									:
  3097                                  ;------------------------------------------------------------------------
  3098                                  
  3099                                  ;
  3100                                  ; Maximum number of retries in case of error
  3101                                  ;
  3102                                  
  3103                                  MAXERR	EQU 5
  3104                                  MAX_HD_FMT_ERR	equ 2 ; 21/07/2019
  3105                                  
  3106                                  LSTDRV	EQU 0504h
  3107                                  
  3108                                  ;
  3109                                  ; Some floppy drives do not have changeline support. The result is a
  3110                                  ; large amount of inefficiency in the code. A media-check always returns
  3111                                  ; "I don`t know". This cause DOS to reread the FAT on every access and
  3112                                  ; always discard any cached data.
  3113                                  ;   We get around this inefficiency by implementing a "Logical Door Latch".
  3114                                  ; The following three items are used to do this. The logical door latch is
  3115                                  ; based on the premise that it is not physically possible to change floppy
  3116                                  ; disks in a drive in under two seconds (most people take about 10). The
  3117                                  ; logical door latch is implemented by saving the time of the last successful
  3118                                  ; disk operation (in the value TIM_DRV). When a new request is made the
  3119                                  ; current time is compared to the saved time. If less than two seconds have
  3120                                  ; passed then the value "No Change" is returned. If more than two seconds
  3121                                  ; have passed the value "Don't Know" is returned.
  3122                                  ;   There is one complecation to this algorithm. Some programs change the
  3123                                  ; value of the timer. In this unfortunate case we have an invalid timer.
  3124                                  ; This possiblity is detected by counting the number of disk operations
  3125                                  ; which occur without any time passing. If this count exceeds the value of
  3126                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  3127                                  ; Know". The variable "AccessCount" is used to keep track of the number
  3128                                  ; of disk operation which occur without the time changing.
  3129                                  ;
  3130                                  
  3131                                  AccessMax EQU 5
  3132                                  
  3133                                  ;
  3134                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  3135                                  ; have to be made to read the diskette. Consequently a large head settle
  3136                                  ; time was always used in the I/O operations. To get around this problem
  3137                                  ; we need to continually adjust the head settle time. The following
  3138                                  ; algorithm is used:
  3139                                  ;
  3140                                  ;   Get the current head settle value.
  3141                                  ;   If it is 1, then
  3142                                  ;	set slow = 15
  3143                                  ;   else
  3144                                  ;	set slow = value
  3145                                  ;   ...
  3146                                  ;   if we are seeking and writing then
  3147                                  ;	use slow
  3148                                  ;   else
  3149                                  ;	use fast
  3150                                  ;   ...
  3151                                  ;   restore current head settle value
  3152                                  ;
  3153                                  
  3154                                  ;
  3155                                  ; flags for size of FAT
  3156                                  ;
  3157                                  
  3158                                  fTOOBIG	EQU 80h
  3159                                  fBIG	EQU 40h
  3160                                  
  3161                                  error_unknown_media equ	7	; for use in BUILD BPB call
  3162                                  
  3163                                  struc BPB_TYPE
  3164 00000000 ????                    .SECSIZE:	resw 1
  3165 00000002 ??                      .SECALL:	resb 1
  3166 00000003 ????                    .RESNUM:	resw 1
  3167 00000005 ??                      .FATNUM:	resb 1
  3168 00000006 ????                    .DIRNUM:	resw 1
  3169 00000008 ????                    .SECNUM:	resw 1
  3170 0000000A ??                      .FATID:		resb 1
  3171 0000000B ????                    .FATSIZE:	resw 1
  3172 0000000D ????                    .SLIM:		resw 1
  3173 0000000F ????                    .HLIM:		resw 1
  3174 00000011 ????                    .HIDDEN:	resw 1
  3175                                  .size:
  3176                                  endstruc
  3177                                  
  3178                                  ; 29/06/2019 - Retro DOS v3.1
  3179                                  
  3180                                  ;-------------------------------------------------------------------------
  3181                                  ;
  3182                                  ; SetDrive scans through the data structure of BDSs and returns a
  3183                                  ; pointer to the BDS that belongs to the drive specified in AL.
  3184                                  ; Carry is set if no BDS has a logical drive number which matches the
  3185                                  ; value in AL.
  3186                                  ;	Input:
  3187                                  ;	  AL contains the logical drive number
  3188                                  ;	Output:
  3189                                  ;	  DS:DI points to correct BDS if Carry is clear.
  3190                                  ;
  3191                                  ;	 All register except DS and DI are preserved
  3192                                  ;
  3193                                  ;-------------------------------------------------------------------------
  3194                                  
  3195                                  SETDRIVE:
  3196                                  		; 27/05/2018 - Retro DOS v3.0
  3197                                  		; (MSDOS v3.3, 'MSDISK.ASM')
  3198                                  		
  3199                                  ;		push	bx
  3200                                  ;
  3201                                  ;		push	cs
  3202                                  ;		pop	ds
  3203                                  ;
  3204                                  ;		mov	di,[START_BDS] 
  3205                                  ;Scan_Loop:
  3206                                  ;;;Rev 3.30 Modification -----------------------------------------
  3207                                  ;		CMP	BYTE [CS:PHYS_DRV],1 ; DOES AL HAVE PHYS DRV?
  3208                                  ;		JB	short USE_LOGICAL_DRV
  3209                                  ;		CMP	BYTE [DI+BDS.drivenum],AL
  3210                                  ;		JE	short SetDrv
  3211                                  ;		JMP	SHORT GET_NXT_BDS
  3212                                  ;USE_LOGICAL_DRV:
  3213                                  ;		CMP	[DI+BDS.drivelet],AL
  3214                                  ;		JE	short SetDrv
  3215                                  ;GET_NXT_BDS:
  3216                                  ;		MOV	BX,[DI+BDS.link+2] ; GO TO NEXT BDS
  3217                                  ;		;MOV	DI,[DI+BDS.link]
  3218                                  ;		mov	di,[di] ; 05/07/2019
  3219                                  ;		mov	ds,bx
  3220                                  ;;;End of Modification -----------------------------------------
  3221                                  ;
  3222                                  ;		cmp	di,-1		; at end of list?
  3223                                  ;		jnz	short Scan_Loop	; no, keep looking
  3224                                  ;		stc			; yes, indicate error set carry
  3225                                  ;SetDrv:
  3226                                  ;		pop	bx		; restore bx
  3227                                  ;		retn
  3228                                  
  3229                                  		; 17/07/2019 - Retro DOS v3.2
  3230                                  
  3231 00000B75 0E                      		push	cs
  3232 00000B76 1F                      		pop	ds
  3233                                  
  3234 00000B77 8B3E[9A01]              		mov	di,[START_BDS]
  3235                                  Scan_Loop:
  3236 00000B7B 384505                  		cmp	[di+BDS.drivelet],al
  3237 00000B7E 7408                    		je	short SetDrv
  3238                                  		;lds	si,[di+BDS.link]
  3239 00000B80 C53D                    		lds	di,[di]
  3240 00000B82 83FFFF                  		cmp	di,-1
  3241 00000B85 75F4                    		jne	short Scan_Loop
  3242 00000B87 F9                      		stc	
  3243                                  SetDrv:
  3244 00000B88 C3                      		retn 
  3245                                  
  3246                                  ; 17/07/2019 - Retro DOS v3.2
  3247                                  
  3248                                  ;-------------------------------------------------------------------------
  3249                                  ;
  3250                                  ;  this is a special version of the bds lookup code which is
  3251                                  ;  based on physical drives rather than the usual logical drives
  3252                                  ;  carry is set if the physical drive in dl is found, ds:di -> its bds
  3253                                  ;  otherwise carry is clear
  3254                                  ;
  3255                                  ;  guaranteed to trash no registers except ds:di
  3256                                  ;
  3257                                  ;-------------------------------------------------------------------------
  3258                                  
  3259                                  find_bds:
  3260 00000B89 0E                      		push	cs
  3261 00000B8A 1F                      		pop	ds
  3262                                  
  3263 00000B8B 8B3E[9A01]              		mov	di,[START_BDS]	; point ds:di to first bds
  3264                                  fbds_1:
  3265 00000B8F 385504                  		cmp	[di+BDS.drivenum],dl
  3266 00000B92 7408                    		je	short fbds_2
  3267                                  
  3268                                  		;lds	di,[di+BDS.link]	; go to next bds
  3269 00000B94 C53D                    		lds	di,[di]
  3270 00000B96 83FFFF                  		cmp	di,-1
  3271 00000B99 75F4                    		jne	short fbds_1
  3272 00000B9B F9                      		stc
  3273                                  fbds_2:
  3274 00000B9C C3                      		retn
  3275                                  
  3276                                  ;------------------------------------------------------------------------
  3277                                  ;									:
  3278                                  ; The next 100 or so lines of code do the Media Check. Media Check	:
  3279                                  ; determines if the diskette (media) in the drive has been changed.	:
  3280                                  ;									:
  3281                                  ;	SI is used to hold media check code:				:
  3282                                  ;			-1	media changed				:
  3283                                  ;			 0	Don't know                              :
  3284                                  ;			 1	media has not been changed		:
  3285                                  ;									:
  3286                                  ; The algorithm used is a follows:					:
  3287                                  ;	if (hard disk)							:
  3288                                  ;	    if (changed by format)					:
  3289                                  ;		   return (not changed) 				:
  3290                                  ;	    if	not (changed by format) 				:
  3291                                  ;		   return (changed)					:
  3292                                  ;	else we have a floppy						:
  3293                                  ;	    if floppy has change line support go ask the floppy 	:
  3294                                  ;	    if floppy does not have change line do the following	:
  3295                                  ;		read the time						:
  3296                                  ;		if more than two second have passed return don't know   :
  3297                                  ;		if no time has passed then might be unreliable		:
  3298                                  ;		  counter (some program fool with the counter when	:
  3299                                  ;		  they should not).  See note below for procedure with	:
  3300                                  ;		  unreliable counter					:
  3301                                  ;		if sometime has passed but not two second return	:
  3302                                  ;		  media has not changed. This is based on the		:
  3303                                  ;		  assumption that it is not physically possible to	:
  3304                                  ;		  change a disk in less the two seconds (most people	:
  3305                                  ;		  take about 10 seconds).				:
  3306                                  ;									:
  3307                                  ;------------------------------------------------------------------------
  3308                                  
  3309                                  MEDIA$CHK:
  3310                                  		; 13/06/2018
  3311                                  		; 26/05/2018 - Retro DOS v3.0
  3312                                  		; (Volume Serial Number Check)
  3313                                  
  3314                                  		; 08/04/2018
  3315                                  		; Retro DOS v2.0
  3316                                  		; (Media check code here is mix of MSDOS 2.0, MSDOS 3.3
  3317                                  		; and Retro DOS v2.0 special media -disk change- check code..)
  3318                                  		; (..it is not compatible with MSDOS 3.3 mediacheck)
  3319                                  		; (Excluded methods: Volume Serial Number Check,
  3320                                  		; "fChanged_By_Format" check -via int 13h hook-)
  3321                                  
  3322                                  		; 26/05/2018
  3323                                  
  3324 00000B9D E8D5FF                  		call	SETDRIVE ; point DS:DI to BDS for specified drive	
  3325                                  
  3326                                  		; 17/07/2019 - Retro DOS v3.2
  3327                                  		;cmp	word [CS:Secrete_Code], 'kj' ; Secrete code for
  3328                                  		;jne	short Media$Done	; DOS 3.3 MSBIO.
  3329                                  		
  3330                                  		;cmp	AL, 1	; Retro DOS v2.0 method
  3331                                  				; We will not check disk change status
  3332                                  				; if disk/unit number > 1.
  3333                                  				; (hard disk or diskette 3 ! or diskette 4 !)
  3334                                  		;ja	short Media$Done
  3335                                  ;
  3336                                  ; For non-removable disks only return changed if changed by format,
  3337                                  ; otherwise return 'not changed'.
  3338                                  ;
  3339 00000BA0 BE0100                  		mov	si,1		; assume no change
  3340 00000BA3 F745230001              		test	word [DI+BDS.flags],fChanged_By_Format
  3341 00000BA8 7417                    		jz	short WeAreNotFakingIt
  3342                                  					; reset flag
  3343 00000BAA 816523FFFE              		and	word [DI+BDS.flags],~fChanged_By_Format
  3344                                  ;
  3345                                  ; If media has been changed by format, must use the ROM.
  3346                                  ; Cannot rely on the 2 second time check.
  3347                                  ;
  3348 00000BAF 2EC606[9F01]FF          		mov	byte [CS:TIM_DRV],-1  ; Ensure that we ask the ROM if
  3349                                  					      ; media has changed
  3350 00000BB5 F745230100              		test	word [DI+BDS.flags],fNon_Removable
  3351 00000BBA 740C                    		jz	short WeHaveAFloppy
  3352 00000BBC BEFFFF                  		mov	SI,-1			; Indicate media changed
  3353 00000BBF EB2D                    		jmp	short Media$Done
  3354                                  ;
  3355                                  ; return 'not changed' if disk is a hard file.
  3356                                  ;
  3357                                  
  3358                                  WeAreNotFakingIt:
  3359 00000BC1 F745230100              		test	word [DI+BDS.flags],fNon_Removable
  3360 00000BC6 7526                    		jnz	short Media$Done
  3361                                  
  3362                                  		;
  3363                                  		; return 'not changed' if disk is a hard file.
  3364                                  		;
  3365                                  
  3366                                  		;mov	si,1    ; not changed
  3367                                  
  3368                                  		;cmp	al, [CS:HARDNUM]
  3369                                  		;jnb	short Media$Done ; fixed/hard disk !
  3370                                  ;
  3371                                  ; If this code is reached disk is a diskette drive
  3372                                  ;
  3373                                  
  3374                                  WeHaveAFloppy:
  3375 00000BC8 31F6                    		xor	si,si	; Presume "I don't know"
  3376                                  
  3377                                  		; 11/04/2018
  3378                                  		;mov	[CS:MEDIACHK_DRV], al ; Retro DOS v2.0 method 
  3379                                  		; 13/04/2018
  3380                                  		;mov	[MEDIACHK_DRV], al
  3381                                  ;
  3382                                  ; If drive is a floppy with changeline support the rom is called to
  3383                                  ; determine if the media has changed. It is not necessary to do the 2
  3384                                  ; second check on these drives.
  3385                                  ;
  3386                                  		;CALL	MediaCheck
  3387                                  
  3388                                  		; DL = drive number (0..3) ; 13/04/2018
  3389                                  
  3390                                  		;and	si, si
  3391                                  		;jnz	short Media$Done
  3392                                  
  3393                                  		; SI = 0, "I don't know" (if media has been changed or not!?)
  3394                                  
  3395                                  		;inc	si	; 1 = no change
  3396                                  
  3397                                  		; 17/07/2019 - Retro DOS v3.2
  3398                                  		; (MSDOS 3.3)
  3399                                  		 
  3400                                  ;		; 26/05/2018 - Retro DOS v3.0
  3401                                  ;		;----------------------------------------|
  3402                                  ;		; Warning: Do not change the following. ;|
  3403                                  ;		;	   It gets patched in MSINIT	;|
  3404                                  ;Media_Patch:						;|
  3405                                  ;		CALL	MediaCheck			;|
  3406                                  ;		jc	short ERR$EXITJ			;|
  3407                                  ;		call	HasChange			;|
  3408                                  ;		jnz	short Media$Done		;|
  3409                                  ;		;----------------------------------------|
  3410                                  
  3411                                  		; 17/07/2019 - Retro DOS v3.2
  3412                                  		; (MSDOS 6.0)
  3413                                  
  3414                                  ; If we have a floppy with changeline support, we ask the ROM
  3415                                  ; to determine if media has changed. We do not perform the
  3416                                  ; 2 second check for these drives.
  3417                                  
  3418 00000BCA 2E803E[1201]00          		cmp	byte [cs:fHave96],0	; Do we have changeline support?
  3419 00000BD0 740A                    		jz	short mChk_NoChangeLine	; Brif not
  3420                                  	
  3421 00000BD2 E8750F                  		call	MediaCheck
  3422 00000BD5 723B                    		jc	short ERR$EXITJ	
  3423                                  
  3424 00000BD7 E8CF10                  		call	HasChange
  3425 00000BDA 7512                    		jnz	short Media$Done
  3426                                  	
  3427                                  mChk_NoChangeLine:
  3428                                  	
  3429                                  ; If we come here, we have a floppy with no changeline support
  3430                                  
  3431 00000BDC BE0100                  		MOV	SI,1			; PRESUME NO CHANGE
  3432 00000BDF 2EA0[9F01]              		mov	al,[CS:TIM_DRV] 	; last drive accessed
  3433                                  						;is drive of last access the same?
  3434                                  		;mov	al,[TIM_DRV]
  3435                                  		;;CMP	AL,[CS:MEDIACHK_DRV]
  3436                                  		;;cmp	al,[MEDIACHK_DRV]  ; 11/04/2018
  3437                                  		;CMP	AL,DL ; 13/04/2018
  3438                                  
  3439 00000BE3 3A4504                  		cmp	al,[DI+BDS.drivenum] ; 26/05/2018
  3440 00000BE6 7505                    		JNE	short Media$Unk		; no, then return don't know
  3441                                  ;
  3442                                  ; CHECK TO SEE IF THIS DRIVE HAS BEEN ACCESSED IN THE LAST 2 SECONDS.
  3443                                  ;
  3444 00000BE8 E82D00                  		call	CHECK_TIME_OF_ACCESS
  3445 00000BEB EB01                    		jmp	short Media$Done
  3446                                  
  3447                                  Media$Unk:
  3448 00000BED 4E                      		DEC	SI			; RETURN "I DON'T KNOW"
  3449                                  ;
  3450                                  ; SI now contains the correct value for media change. Clean up the left overs
  3451                                  ;
  3452                                  Media$Done:
  3453 00000BEE 2EC41E[B000]            		les	bx,[CS:PTRSAV]		; get original packet
  3454                                  		;les	bx,[PTRSAV] ; 11/04/2018
  3455 00000BF3 2689770E                		mov	[ES:BX+TRANS],SI
  3456 00000BF7 09F6                    		or	SI,SI
  3457                                  		;jns	EXIT
  3458                                  		;js	short INIT_PATCH
  3459                                  		; 19/07/2019
  3460                                  		;jns	short VOLIDOK
  3461 00000BF9 7803                    		js	short mchk_msvid ; 17/07/2019
  3462 00000BFB E969FC                  		jmp	EXIT
  3463                                  
  3464                                  		;; make sure we ask ROM for media check
  3465                                  		;mov	byte [CS:TIM_DRV],-1
  3466                                  		;;mov	byte [TIM_DRV],-1 ; 11/04/2018
  3467                                  		;jmp	EXIT
  3468                                  
  3469                                  		; 17/07/2019 - Retro DOS v3.2
  3470                                  		; (MSDOS 3.3)
  3471                                  
  3472                                  ;		; 26/05/2018 - Retro DOS v3.0
  3473                                  ;		;----------------------------------------|
  3474                                  ;		; Warning: Do not change the following. ;|
  3475                                  ;		;	   It gets patched in msinit	;|
  3476                                  ;INIT_PATCH:						;|
  3477                                  ;		CALL	MEDIA_SET_VID			;|
  3478                                  ;		;----------------------------------------|
  3479                                  
  3480                                  		; 17/07/2019 - Retro DOS v3.2
  3481                                  		; (MSDOS 6.0)
  3482                                  mchk_msvid:
  3483 00000BFE 2E803E[1201]00          		cmp	byte [cs:fHave96],0
  3484 00000C04 7403                    		jz	short mChk1_NoChangeLine ; Brif no changeline support
  3485                                  
  3486 00000C06 E83610                  		call	MEDIA_SET_VID		; We no longer care about bds pointer
  3487                                  
  3488                                  mChk1_NoChangeLine:
  3489 00000C09 2EC606[9F01]FF          		mov	byte [cs:TIM_DRV],-1 ; make sure we ask ROM for media check
  3490                                  VOLIDOK:
  3491 00000C0F E955FC                  		jmp	EXIT
  3492                                  
  3493                                  ERR$EXITJ:
  3494 00000C12 E82006                  		CALL	MAPERROR
  3495 00000C15 E942FC                  		JMP	ERR$EXIT
  3496                                  
  3497                                  ;
  3498                                  ; PERFORM A CHECK ON THE TIME PASSED SINCE THE LAST ACCESS FOR THIS
  3499                                  ; PHYSICAL DRIVE.
  3500                                  ; WE ARE ACCESSING THE SAME DRIVE. IF THE TIME OF LAST SUCCESSFUL ACCESS
  3501                                  ; WAS LESS THAN 2 SECONDS AGO, THEN WE MAY PRESUME THAT THE DISK WAS NOT
  3502                                  ; CHANGED
  3503                                  ; RETURNS IN SI:
  3504                                  ;	0 - IF TIME OF LAST ACCESS WAS >= 2 SECONDS
  3505                                  ;	1 - IF TIME WAS < 2 SECONDS (I.E NO MEDIA CHANGE ASSUMED)
  3506                                  ; REGISTERS AFFECTED AX,CX,DX, FLAGS.
  3507                                  ;
  3508                                  
  3509                                  CHECK_TIME_OF_ACCESS:
  3510                                  		; 27/05/2018 - Retro DOS v3.0
  3511 00000C18 BE0100                  		mov	si,1			; Presume no change
  3512                                  		;;Rev 3.30 Modification
  3513 00000C1B 30E4                    		xor	AH,AH			; set command to read time
  3514 00000C1D CD1A                    		int	1Ah			; call rom-bios clock routine
  3515                                  ;
  3516                                  ; Once time is read, must make sure the date wrap is not lost. The ROM will
  3517                                  ; return the value only once, it must check for day wrap on each call.
  3518                                  ;
  3519 00000C1F D0E8                    		SHR	AL,1
  3520 00000C21 2E8316[7205]00          		ADC	word [CS:DAYCNT],0	; ADD IT TO OUR SAVED DAY COUNT
  3521                                  		;ADC	word [DAYCNT],0 ; 11/04/2018
  3522                                  ;
  3523                                  ; Compute elapsed time1
  3524                                  ;
  3525                                  		; 27/05/2018
  3526                                  		; Retro DOS v3.0
  3527 00000C27 8B4547                  		MOV	AX,[DI+BDS.tim_lo]	; GET STORED TIME
  3528 00000C2A 29C2                    		SUB	DX,AX
  3529 00000C2C 8B4549                  		MOV	AX,[DI+BDS.tim_hi]
  3530 00000C2F 19C1                    		SBB	CX,AX
  3531                                  ;
  3532                                  ; CX:DX is the elapsed time
  3533                                  ;
  3534 00000C31 751D                    		JNZ	short TimeCheck_Unk	; CX <> 0 => > 1 hour
  3535 00000C33 09D2                    		OR	DX,DX			; did some time pass?
  3536 00000C35 7514                    		JNZ	short TimePassed	; yes, examine max value
  3537                                  ;
  3538                                  ; No noticeable time has passed. There are two possibilities. First there
  3539                                  ; could be two driver calls with in one clock tick (55 milliseconds). The
  3540                                  ; second possibility is the program has reprogramed the counter -- this is
  3541                                  ; the unreliable counter case. To distinguish between the case a count is
  3542                                  ; kept of the number of calls that happen without a clock tick (the variable
  3543                                  ; is AccessCount). If this count exceeds a set limit (MaxAccess) it is
  3544                                  ; assumed the counter is unreliable and the value don't know is returned.
  3545                                  ; If AccessCount is less than MaxAccess we assume the time is valid and
  3546                                  ; therefore the media has not changed.
  3547                                  ;
  3548 00000C37 2EFE06[9E01]            		inc	byte [cs:AccessCount]
  3549                                  						; Exceeded threshold for count?
  3550 00000C3C 2E803E[9E01]05          		cmp	byte [cs:AccessCount],AccessMax
  3551 00000C42 720D                    		jb	short TimeCheck_Ret	; no, return media unchanged
  3552 00000C44 2EFE0E[9E01]            		dec	byte [cs:AccessCount]	; don't let the count wrap
  3553 00000C49 EB05                    		jmp	short TimeCheck_Unk	; "I don't know" if media changed
  3554                                  ;
  3555                                  ; If this code is reached some time has passed. Need to determine if
  3556                                  ; 2 seconds have passed. Note: 18.2 ticks per second.
  3557                                  ;
  3558                                  TimePassed:
  3559 00000C4B 83FA24                  		CMP	DX,18*2			; IF ( Time_passed <= 2secs )
  3560 00000C4E 7601                    		JBE	short TimeCheck_Ret	;      presume no change
  3561                                  
  3562                                  
  3563                                  ; Everything indicates that we do not know what has happened.
  3564                                  ;
  3565                                  TimeCheck_Unk:
  3566 00000C50 4E                      		DEC	SI			; Presume I don't know
  3567                                  TimeCheck_Ret:
  3568 00000C51 C3                      		RETN
  3569                                  
  3570                                  ERR$EXITJ2:
  3571 00000C52 E905FC                  		JMP 	ERR$EXIT
  3572                                  
  3573                                  ;------------------------------------------------------------------------
  3574                                  ;									:
  3575                                  ;		Get Bios Parameter Block				:
  3576                                  ;									:
  3577                                  ; GET$BPB is called to build a valid BPB for the media in the disk	:
  3578                                  ; drive. A BPB (Bios Parameter Block) contains information about	:
  3579                                  ; the media which is currently in the drive. The values stored is	:
  3580                                  ; information like number of fat sectors, size of drive, 8 or 9 sectors,:
  3581                                  ; etc.									:
  3582                                  ;									:
  3583                                  ;	This routine is called by the device drive code.		:
  3584                                  ;									:
  3585                                  ;	On entry AL contains the logical drive number which needs	:
  3586                                  ;	  the BPB built.						:
  3587                                  ;	ES:[DI] points to a buffer; the first byte of the buffer is a	:
  3588                                  ;	   media decriptor byte.					:
  3589                                  ;									:
  3590                                  ;------------------------------------------------------------------------
  3591                                  ;
  3592                                  ; Build a valid BPB for the disk in the drive.
  3593                                  ;
  3594                                  
  3595                                  GET$BPB:
  3596 00000C55 268A25                  		mov	AH,[ES:DI]		; get FAT ID byte read by DOS
  3597 00000C58 E81AFF                  		call	SETDRIVE		; get the correct BDS for the drv
  3598                                  		; 27/05/2018
  3599                                  		;;Rev 3.30 Modification
  3600 00000C5B F745230100              		TEST	word [DI+BDS.flags],fNon_Removable
  3601 00000C60 7527                    		JNZ	short ALREADY_GOTBPB	; NO NEED TO BUILD FOR FIXED DISKS
  3602                                  		;End of Modification
  3603                                  		
  3604                                  		; 19/07/2019 - Retro DOS v3.2
  3605                                  		; (MSDOS 6.0 code)
  3606                                  		; ----------------
  3607                                  
  3608                                  		; let's set the default value for volid,vol_serial,
  3609                                  		; filesys_id in bds table
  3610                                  
  3611 00000C62 E87E00                  		call	clear_ids
  3612 00000C65 2EC606[8705]01          		mov	byte [cs:set_id_flag],1 ; indicate to set system id in bds
  3613                                  
  3614                                  		; ----------------				
  3615                                  
  3616 00000C6B E8A400                  		call	GETBP			; build a BPB if necessary.
  3617 00000C6E 72E2                    		jc	short ERR$EXITJ2	; if error exit
  3618                                  
  3619                                  		; 19/07/2019 - Retro DOS v3.2
  3620                                  		; (MSDOS 6.0 code)
  3621                                  		
  3622 00000C70 2E803E[8705]02          		cmp	byte [cs:set_id_flag],2 ; already, volume_label set from boot
  3623 00000C76 2EC606[8705]00          		mov	byte [cs:set_id_flag],0 ; record to bds table?
  3624 00000C7C 740B                    		je	short ALREADY_GOTBPB ; do not set it again from root dir.
  3625                                  					; otherwise, conventional boot record.
  3626                                  
  3627                                  		; 17/07/2019 - Retro DOS v3.2
  3628                                  		; (MSDOS 3.3)
  3629                                  
  3630                                  ;		;----------------------------------------|
  3631                                  ;		; Warning: Do not change the following. ;|
  3632                                  ;		;	   It gets patched in msinit	;|
  3633                                  ;SET_PATCH:						;|
  3634                                  ;		CALL	Set_Volume_ID			;|
  3635                                  ;		;----------------------------------------|
  3636                                  
  3637                                  		; 17/07/2019 - Retro DOS v3.2
  3638                                  		; (MSDOS 6.0)
  3639                                  
  3640 00000C7E 2E803E[1201]00          		cmp	byte [cs:fHave96],0	; do we have changeline support?
  3641 00000C84 7403                    		jz	short ALREADY_GOTBPB	; brif not
  3642                                  
  3643 00000C86 E83E10                  		call	Set_Volume_ID
  3644                                  
  3645                                  ALREADY_GOTBPB:
  3646 00000C89 83C706                  		add	di,BDS.bytespersec	; return the BPB that is in the current BDS
  3647                                  
  3648                                  SetPTRSAV:					; return point for DSK$INIT
  3649 00000C8C 2EC41E[B000]            		les	BX,[CS:PTRSAV]
  3650 00000C91 2688670D                		mov	[ES:BX+MEDIA],AH
  3651 00000C95 26897F12                		mov	[ES:BX+COUNT],DI
  3652 00000C99 268C5F14                		mov	[ES:BX+COUNT+2],DS
  3653 00000C9D E9C7FB                  		jmp	EXIT
  3654                                  
  3655                                  ; 12/07/2019 - Retro DOS v3.2
  3656                                  
  3657                                  ; --------------------------------------------------------------------------
  3658                                  
  3659                                  size_of_EXT_BOOT_VOL_LABEL equ 11
  3660                                  size_of_EXT_SYSTEM_ID equ 8	
  3661                                  
  3662                                  ; 19/07/2019 - Retro DOS v3.2
  3663                                  
  3664                                  ; --------------------------------------------------------------------------
  3665                                  ;
  3666                                  ;copy the boot_serial number, volume id, and filesystem id from the
  3667                                  ;***extended boot record*** in ds:disksector to the bds table pointed
  3668                                  ;by es:di.
  3669                                  
  3670                                  ;in.) es:di -> bds
  3671                                  ;     ds:disksector = valid extended boot record.
  3672                                  ;out.) vol_serial, bds_volid and bds_system_id in bds are set according to
  3673                                  ;      the boot record information.
  3674                                  ;     carry flag set if not an extended bpb.
  3675                                  ;     all registers saved except the flag.
  3676                                  ;
  3677                                  ; --------------------------------------------------------------------------
  3678                                  
  3679                                  mov_media_ids:
  3680                                  		; ds:di -> BDS
  3681                                  
  3682 00000CA0 2E803E[F601]29          		cmp	byte [cs:DiskSector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE ; = 41
  3683 00000CA6 7539                    		jne	short mmi_not_ext
  3684                                  
  3685 00000CA8 06                      		push	es
  3686 00000CA9 1E                      		push	ds
  3687 00000CAA 51                      		push	cx
  3688                                  
  3689 00000CAB 8CD9                    		mov	cx,ds
  3690 00000CAD 8EC1                    		mov	es,cx
  3691 00000CAF 8CC9                    		mov	cx,cs
  3692 00000CB1 8ED9                    		mov	ds,cx		
  3693                                  
  3694 00000CB3 8B0E[F701]              		mov	cx,[DiskSector+EXT_BOOT.SERIAL]
  3695 00000CB7 26894D57                		mov	[es:di+BDS.vol_serial],cx
  3696 00000CBB 8B0E[F901]              		mov	cx,[DiskSector+EXT_BOOT.SERIAL+2]
  3697 00000CBF 26894D59                		mov	[es:di+BDS.vol_serial+2],cx
  3698                                  
  3699 00000CC3 57                      		push	di
  3700 00000CC4 56                      		push	si
  3701                                  
  3702 00000CC5 B90B00                  		mov	cx,size_of_EXT_BOOT_VOL_LABEL	; 11
  3703 00000CC8 BE[FB01]                		mov	si,DiskSector+EXT_BOOT.VOL_LABEL
  3704 00000CCB 83C74B                  		add	di,BDS.volid
  3705 00000CCE F3A4                    		rep	movsb
  3706 00000CD0 B90800                  		mov	cx,size_of_EXT_SYSTEM_ID	; 8
  3707 00000CD3 BE[0602]                		mov	si,DiskSector+EXT_BOOT.SYSTEM_ID
  3708                                  		;add	di,5
  3709 00000CD6 83C705                  		add	di,(BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
  3710 00000CD9 F3A4                    		rep	movsb
  3711                                  
  3712 00000CDB 5E                      		pop	si
  3713 00000CDC 5F                      		pop	di
  3714                                  
  3715 00000CDD 59                      		pop	cx
  3716 00000CDE 1F                      		pop	ds
  3717 00000CDF 07                      		pop	es
  3718                                  
  3719                                  		;clc	; this clc is not required (16/06/2019 - Erdogan Tan) 
  3720 00000CE0 C3                      		retn
  3721                                  mmi_not_ext:
  3722 00000CE1 F9                      		stc
  3723 00000CE2 C3                      		retn
  3724                                  
  3725                                  ; --------------------------------------------------------------------------
  3726                                  ;
  3727                                  ; clear ids in bds table. only applied for floppies.
  3728                                  ;input:  es:di -> bds table
  3729                                  ;	assumes ds: -> Bios_Data
  3730                                  ;output: volid set to "NO NAME    "
  3731                                  ;	 vol_serial set to 0.
  3732                                  ;	 filesys_id set to "FAT12   " or "FAT16   "
  3733                                  ;	   depending on the flag fatsize in bds.
  3734                                  ;
  3735                                  ;	trashes si,cx
  3736                                  ;
  3737                                  ; --------------------------------------------------------------------------
  3738                                  
  3739                                  clear_ids:
  3740                                  		; 19/07/2019
  3741                                  		; push	es
  3742 00000CE3 1E                      		push	ds
  3743 00000CE4 57                      		push	di
  3744                                  
  3745 00000CE5 31C9                    		xor	cx,cx ; 0			; no serial number
  3746                                  		; 16/07/2019
  3747                                  		;mov	[es:di+BDS.vol_serial],cx
  3748                                  		;mov	[es:di+BDS.vol_serial+2],cx
  3749 00000CE7 894D57                  		mov	[di+BDS.vol_serial],cx
  3750 00000CEA 894D59                  		mov	[di+BDS.vol_serial+2],cx
  3751                                  
  3752                                  		; 19/07/2019
  3753 00000CED 1E                      		push	ds
  3754 00000CEE 07                      		pop	es
  3755                                  
  3756 00000CEF 0E                      		push	cs
  3757 00000CF0 1F                      		pop	ds
  3758                                  
  3759                                  		; BUGBUG - there's a lot in common here and with
  3760                                  		; mov_media_ids.. see if we can save some space by
  3761                                  		; merging them... jgl
  3762                                  
  3763                                  		;mov	cx,size_of_EXT_BOOT_VOL_LABEL ; = 11
  3764 00000CF1 B10B                    		mov	cl,size_of_EXT_BOOT_VOL_LABEL ; 19/07/2019
  3765 00000CF3 BE[9A05]                		mov	si,vol_no_name 
  3766 00000CF6 83C74B                  		add	di,BDS.volid  ; add di,75 ; points to volid field
  3767 00000CF9 F3A4                    		rep	movsb
  3768                                  
  3769 00000CFB BE[9105]                		mov	si,fat_16_id		; big fat
  3770 00000CFE 26F6451F40              		test	byte [es:di+BDS.fatsiz],fBIG
  3771 00000D03 7503                    		jnz	short ci_bigfat		; small fat
  3772 00000D05 BE[8805]                		mov	si,fat_12_id
  3773                                  ci_bigfat:
  3774                                  		;mov	cx,size_of_EXT_SYSTEM_ID ; = 8
  3775 00000D08 B108                    		mov	cl,size_of_EXT_SYSTEM_ID
  3776                                  		;add	di,5
  3777 00000D0A 83C705                  		add	di,(BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
  3778                                  					; filesys_id field
  3779 00000D0D F3A4                    		rep	movsb
  3780 00000D0F 5F                      		pop	di		; restore bds pointer
  3781                                  		
  3782                                  		; 19/07/2019
  3783 00000D10 1F                      		pop	ds
  3784                                  		;pop	es
  3785                                  GETRET_exit:
  3786 00000D11 C3                      		retn
  3787                                  
  3788                                  ; 19/07/2019 - Retro DOS v3.2
  3789                                  ; ----------------------------------------------------------------------------
  3790                                  ; 13/06/2018
  3791                                  ; 27/05/2018 - Retro DOS v3.0
  3792                                  
  3793                                  ; ----------------------------------------------------------------------------
  3794                                  ;
  3795                                  ;      GETBP fills the BDS with the BPB for the media currently in the drive.
  3796                                  ; The following steps are followed:
  3797                                  ;	If the Return_Fake_BPB flag is set then the GETBP just returns.
  3798                                  ;	If the BDS is for a hard disk (non-removable) then GETBP returns since
  3799                                  ;   the BPB cannot change on a hard disk drive.
  3800                                  ;	For all other cases GETBP reads the boot sector and looks for a BPB
  3801                                  ;   in the boot sector. (All DOS 2.X and about disks should have a valid
  3802                                  ;   BPB in the boot sector.)
  3803                                  ;	If no valid BPB is found (DOS 1.X disk) then GETBP reads the FAT
  3804                                  ;   sector and gets the FAT ID byte. With this byte a valid BPB is build.
  3805                                  ;
  3806                                  ;	Inputs:
  3807                                  ;		DS:DI points to correct BDS
  3808                                  ;
  3809                                  ;	Outputs:
  3810                                  ;		Fills in BPB in current BDS if valid BPB or FAT ID on disk.
  3811                                  ;		Carry set, and AL=7 if invalid disk.
  3812                                  ;		Carry set and error code in AL if other error.
  3813                                  ;
  3814                                  ; ----------------------------------------------------------------------------
  3815                                  ; 19/07/2019
  3816                                  ;		if failed to recognize the boot record, then will set the
  3817                                  ;		set_id_flag to 0.
  3818                                  ;		this routine will only work for a floppy diskette.
  3819                                  ;		     for a fixed disk, it will just return.
  3820                                  
  3821                                  GETBP:
  3822                                  					; if non-removable or returning
  3823                                  					; fake BPB then return BPB as is.
  3824                                  		;test	byte [di+23h],5
  3825                                  		;TEST	WORD [DI+BDS.flags],RETURN_FAKE_BPB|fNon_Removable
  3826 00000D12 F6452305                		test	byte [di+BDS.flags],RETURN_FAKE_BPB|fNon_Removable
  3827                                  		;jz	short GETBP1
  3828                                  		;JMP	GETRET_Exit
  3829                                  		; 19/07/2019
  3830 00000D16 75F9                    		jnz	short GETRET_exit
  3831                                  GETBP1:
  3832 00000D18 51                      		push	cx
  3833 00000D19 52                      		push	dx
  3834 00000D1A 06                      		push	es
  3835 00000D1B 53                      		push	bx
  3836                                  ;
  3837                                  ; Attempt to read in boot sector and determine BPB.
  3838                                  ; We assume that the 2.x and greater DOS disks all have a valid boot sector.
  3839                                  ;
  3840                                  Rdboot:
  3841 00000D1C E8A300                  		call	READBOOTSEC
  3842 00000D1F 723A                    		jc	short GetBP_Err_Ret
  3843                                  		;jnc	short NoRdErr
  3844                                  		;jmp	GetBP_Err_Ret	; Carry set if there was error.
  3845                                  NoRdErr:
  3846                                  		;cmp	bx,0		; BX is 0 if boot sector is valid.
  3847 00000D21 09DB                    		or	bx,bx
  3848 00000D23 7505                    		jnz	short DoFatBPB	; if not go read FAT
  3849                                  
  3850 00000D25 E8F400                  		call	MOVBPB		; Move BPB into registers.
  3851 00000D28 EB65                    		jmp	short HAS1
  3852                                  
  3853                                  ; At this point the drive contains a 1.X diskette. We read the FAT byte
  3854                                  ; and fill in the BPB from there.
  3855                                  
  3856                                  DoFatBPB:
  3857 00000D2A E83001                          	call    READFAT		; puts media descriptor byte in AH
  3858 00000D2D 722C                            	jc	short GetBP_Err_Ret ; if carry set, there was error, get out
  3859                                  
  3860                                  		; 17/07/2019 - Retro DOS v3.2
  3861                                  		; (MSDOS 3.3)
  3862                                  
  3863                                  ;		;----------------------------------------|
  3864                                  ;		; Warning: Do not change the following. ;|
  3865                                  ;		;          It gets patched in msinit    ;|
  3866                                  ;GETBP1_PATCH:   		                        ;|
  3867                                  ;		call    hidensity               	;|
  3868                                  ;		;----------------------------------------|
  3869                                  
  3870                                  		; 17/07/2019 - Retro DOS v3.2
  3871                                  		; (MSDOS 6.0)
  3872                                  
  3873 00000D2F 2E803E[1201]00          		cmp	byte [cs:fHave96],0	; changeline support available?
  3874 00000D35 7403                    		jz	short bpb_nochangeline	; brif not
  3875                                  
  3876 00000D37 E8140F                  		call	hidensity		; may not return!  May add sp,2 and
  3877                                  						; jump to has1!!!!!! or has720K
  3878                                  bpb_nochangeline:		
  3879                                  		; Test for a valid 3.5" medium
  3880 00000D3A 807D2202                        	cmp     byte [DI+BDS.formfactor],ffSmall
  3881 00000D3E 7526                            	jnz	short Is_Floppy
  3882                                          
  3883 00000D40 80FCF9                  		cmp     ah,0F9H		; is it a valid fat ID byte for 3.5" ?
  3884 00000D43 7572                    		jnz     short Got_Unknown_Medium
  3885                                  Has720K:			; 19/07/2019	
  3886 00000D45 BB[6005]                        	mov     bx,SM92		; pointer to correct BPB
  3887 00000D48 0E                              	push    cs
  3888 00000D49 07                              	pop     es
  3889                                  
  3890                                  		; es points to segment of bds. the following should be modified
  3891                                  		; to get spf,csec,spau,spt correctly. it had been wrong if
  3892                                  		; driver.sys is loaded since the bds is inside the driver.sys.
  3893                                  
  3894                                  ;--------------------------------------------------------------bug330a08
  3895                                  		;mov	al,[es:bx+bpbType.spf]
  3896 00000D4A 268A07                  		mov	al,[es:bx]  ; 05/07/2019 - Retro DOS v3.1
  3897 00000D4D 268B4F03                        	mov     cx,[es:bx+bpbType.csec]
  3898 00000D51 268B5705                        	mov     dx,[es:bx+bpbType.spa]
  3899 00000D55 268B5F01                        	mov     bx,[es:bx+bpbType.spt]
  3900                                  ;--------------------------------------------------------------bug330a08
  3901 00000D59 EB37                    		jmp	short HAS1_res	; Need to load reserved sectors
  3902                                  
  3903                                  		; 13/06/2018
  3904                                  GetBP_Err_Ret:
  3905                                  		; 19/07/2019 - Retro DOS v3.2
  3906                                  		; before doing anything else, set set_id_flag to 0.
  3907 00000D5B 2EC606[8705]00          		mov	byte [cs:set_id_flag],0
  3908 00000D61 E8D104                  		CALL	MAPERROR
  3909 00000D64 EB4C                    		JMP	SHORT GETRET
  3910                                  ;
  3911                                  ; must be a 5.25" floppy if we come here
  3912                                  ;
  3913                                  Is_Floppy:
  3914                                  		;mov	CL,AH		; save media
  3915                                  		;and	CL,0F8H		; normalize
  3916                                  		;cmp	CL,0F8H		; compare with good media byte
  3917                                          	;jnz	short Got_Unknown_Medium
  3918                                  		; 19/07/2019
  3919                                  					; must be a 5.25" floppy if we come here
  3920 00000D66 80FCF8                  		cmp	ah,0F8h		; valid media?? (0f8h-0ffh)
  3921 00000D69 724C                    		jb	short Got_Unknown_Medium
  3922                                  GOODID: 	
  3923 00000D6B B001                    		mov     AL,1		; set number of FAT sectors
  3924 00000D6D BB0840                          	mov     BX,64*256+8	; set dir entries and sector max
  3925 00000D70 B94001                          	mov     CX,40*8		; set size of drive
  3926 00000D73 BA0101                          	mov     DX,01*256+1	; set head limit and sec/all unit
  3927 00000D76 F6C402                         		test    AH,00000010b	; test for 8 or 9 sectors
  3928 00000D79 7507                            	jnz	short HAS8	; NZ = has 8 sectors
  3929 00000D7B FEC0                            	inc     AL		; inc number of FAT sectors
  3930 00000D7D FEC3                            	inc     BL		; inc sector max
  3931 00000D7F 83C128                          	add     CX,40		; increase size
  3932                                  HAS8:   	
  3933 00000D82 F6C401                  		test    AH,00000001b	; test for 1 or 2 heads
  3934 00000D85 740B                    		jz	short HAS1_res	; Z = 1 head
  3935 00000D87 01C9                    		add     CX,CX		; double size of disk
  3936 00000D89 B770                    		mov     BH,112		; increase number of directory entries
  3937 00000D8B FEC6                    		inc     DH		; inc sec/all unit
  3938 00000D8D FEC2                    		inc     DL		; inc head limit
  3939                                  		; 19/07/2019
  3940                                  ;HAS1_res:
  3941                                  ;		mov	si,[DI+BDS.resectors]
  3942                                  					; save values in BDS
  3943                                  HAS1:		
  3944 00000D8F 897509                  		mov	[DI+BDS.resectors],si ; 19/07/2019
  3945                                  HAS1_res:
  3946 00000D92 887508                  		mov     [DI+BDS.secperclus],DH
  3947 00000D95 887D0C                          	mov     [DI+BDS.direntries],BH
  3948 00000D98 894D0E                          	mov     [DI+BDS.totalsecs16],CX
  3949 00000D9B 886510                          	mov     [DI+BDS.media],AH
  3950 00000D9E 884511                          	mov     [DI+BDS.fatsecs],AL
  3951 00000DA1 885D13                          	mov     [DI+BDS.secpertrack],BL
  3952 00000DA4 885515                          	mov     [DI+BDS.heads],DL
  3953                                          	;mov	[DI+BDS.resectors],SI
  3954                                  
  3955                                  		; 19/07/2019
  3956                                  	
  3957                                  		; the BDS_BPB.BPB_HIDDENSECTORS+2 field and the
  3958                                  		; BDS_BPB.BPB_BIGTOTALSECTORS field need to be set
  3959                                  		; to 0 since this code is for floppies
  3960                                  
  3961 00000DA7 31C9                    		xor	cx,cx  ; 0
  3962 00000DA9 894D19                  		mov	[di+BDS.hiddensecs+2],cx  ; 0
  3963 00000DAC 894D17                  		mov	[di+BDS.hiddensecs],cx	  ; 0
  3964 00000DAF 894D1D                  		mov	[di+BDS.totalsecs32+2],cx ; 0
  3965                                  		;mov	[di+BDS.totalsecs32],cx	  ; 0
  3966                                  GETRET: 
  3967 00000DB2 5B                      		pop     bx
  3968 00000DB3 07                      		pop	es
  3969 00000DB4 5A                      		pop	dx
  3970 00000DB5 59                      		pop	cx	
  3971                                  ;GETRET_Exit:
  3972 00000DB6 C3                      		retn
  3973                                  
  3974                                  ; We have a 3.5" diskette for which we cannot build a BPB. We do not assume any
  3975                                  ; type of BPB for this medium.
  3976                                  
  3977                                  Got_Unknown_Medium:
  3978                                  		; 19/07/2019
  3979 00000DB7 2EC606[8705]00          		mov	byte [cs:set_id_flag],0
  3980 00000DBD B007                    		mov	al,error_unknown_media
  3981 00000DBF F9                      		stc
  3982 00000DC0 EBF0                    		jmp	short GETRET
  3983                                  
  3984                                  ;
  3985                                  ; Read in the boot sector. Set carry if error in reading sector.
  3986                                  ; BX is set to 1 if the boot sector is invalid, otherwise it is 0.
  3987                                  ;
  3988                                  READBOOTSEC:
  3989 00000DC2 B90100                  		mov	CX,0001h	; set track and sector number
  3990 00000DC5 30F6                    		xor     DH,DH		; set head number for read_sector
  3991 00000DC7 E8A100                  		call	READ_SECTOR
  3992 00000DCA 724F                    		jc	short Err_ret	; error - get out
  3993 00000DCC 31DB                    		xor	bx,bx		; assume valid boot sector.
  3994                                  
  3995                                  				; at this point the boot sector has been
  3996                                  				; read in from the disk.  We now need to
  3997                                  				; determine if the boot sector contains
  3998                                  				; a valid BPB.	Currently there are only
  3999                                  				; a few simple checks.	Expanding the
  4000                                  				; number or types of checks would not be
  4001                                  				; a bad idea.
  4002                                  
  4003                                  ;*******************************************************************************
  4004                                  ; Put a sanity check for the boot sector in here to detect boot sectors that
  4005                                  ; do not have valid BPBs.
  4006                                  ; We examine the first two bytes - they must contain a long jump or a short
  4007                                  ; jump followed by a NOP.
  4008                                  ; If this test is passed, we further check by examining the signature at
  4009                                  ; the end of the boot sector for the word AA55H.
  4010                                  ; If the signature is not present, we examine the media descriptor byte to
  4011                                  ; see if it is valid.
  4012                                  ;******************************************************************************
  4013 00000DCE 2E803E[D001]69          		cmp	byte [cs:DiskSector],069h    ; Is it a direct jump?
  4014 00000DD4 7418                    		JE	short Check_bpb_MediaByte    ; DON'T NEED TO FIND A NOP
  4015 00000DD6 2E803E[D001]E9          		cmp	byte [cs:DiskSector],0E9h    ; DOS 2.0 jump?
  4016 00000DDC 7410                    		JE	short Check_bpb_MediaByte    ; NO NEED FOR NOP
  4017 00000DDE 2E803E[D001]EB          		cmp	byte [cs:DiskSector],0EBh    ; How about a short jump.
  4018 00000DE4 7533                    		JNE	short INVALIDBOOTSEC
  4019 00000DE6 2E803E[D201]90          		cmp	byte [cs:DiskSector+2],090h  ; Is next one a NOP?
  4020 00000DEC 752B                    		JNE	short INVALIDBOOTSEC
  4021                                  
  4022                                  ; Don't have to perform the following signature check since
  4023                                  ; we need to check the media byte even with the good signatured diskette.
  4024                                  ;CHECK_SIGNATURE:
  4025                                  ;		CMP	word [cs:DiskSector+1FEh],0AA55h ; SEE IF NON-IBM
  4026                                  ;							 ; DISK OR 1.X MEDIA.
  4027                                  ;		JZ	short CHECKSINGLESIDED ; GO SEE IF SINGLE SIDED MEDIUM.
  4028                                  ;					       ; MAY NEED SOME SPECIAL HANDLING
  4029                                  ;
  4030                                  ; CHECK FOR NON-IBM DISKS WHICH DO NOT HAVE THE SIGNATURE AA55 AT THE
  4031                                  ; END OF THE BOOT SECTOR, BUT STILL HAVE A VALID BOOT SECTOR. THIS IS DONE
  4032                                  ; BY EXAMINING THE MEDIA DESCRIPTOR IN THE BOOT SECTOR.
  4033                                  ;
  4034                                  
  4035                                  ;;Rev 3.30 Modification
  4036                                  
  4037                                  ; check for non-ibm disks which do not have the signature AA55h at the
  4038                                  ; end of the boot sector, but still have a valid boot sector. this is done
  4039                                  ; by examining the media descriptor in the boot sector.
  4040                                  
  4041                                  Check_bpb_MediaByte:
  4042                                  		;MOV	AL,[CS:MediaByte]
  4043                                  		; 16/07/2019 - Retro DOS v3.2
  4044 00000DEE 2EA0[E501]              		mov	al,[cs:DiskSector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR] ; 15h
  4045 00000DF2 24F0                    		AND	AL,0F0H
  4046 00000DF4 3CF0                    		CMP	AL,0F0H		; ALLOW FOR STRANGE MEDIA
  4047 00000DF6 7521                    		JNZ	short INVALIDBOOTSEC 
  4048                                  ;
  4049                                  ; THERE WERE SOME (APPARENTLY A BUNCH) DISKETTES THAT HAD BEEN FORMATTED
  4050                                  ; UNDER DOS 3.1 AND EARLIER VERSIONS WHICH HAVE INVALID BPBS IN THEIR BOOT
  4051                                  ; SECTORS. THESE ARE SPECIFICALLY DISKETTES THAT WERE FORMATTED IN DRIVES
  4052                                  ; WITH ONE HEAD, OR WHOSE SIDE 0 WAS BAD. THESE CONTAIN BPBS IN THE BOOT
  4053                                  ; SECT THAT HAVE THE SEC/CLUS FIELD SET TO 2 INSTEAD OF 1, AS IS STANDARD
  4054                                  ; IN DOS. TO SUPPORT THEM, WE HAVE TO INTRODUCE A "HACK" THAT WILL
  4055                                  ; HELP OUR BUILD BPB ROUTINE TO RECOGNISE THESE SPECIFIC CASES, AND TO
  4056                                  ; SET UP OUT COPY OF THE BPB ACCORDINGLY.
  4057                                  ; WE DO THIS BY CHECKING TO SEE IF THE BOOT SECTOR IS OFF A DISKETTE THAT
  4058                                  ; IS SINGLE-SIDED AND IS A PRE-DOS 3.20 DISKETTE. IF IT IS, WE SET THE
  4059                                  ; SEC/CLUS FIELD TO 1. IF NOT, WE CARRY ON AS NORMAL.
  4060                                  
  4061                                  CHECKSINGLESIDED:
  4062                                  		;MOV	AL,[CS:MediaByte]
  4063                                  		; 16/07/2019 - Retro DOS v3.2
  4064 00000DF8 2EA0[E501]              		mov	al,[cs:DiskSector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR] ; 15h
  4065 00000DFC A801                    		TEST	AL,1	; IS LOW BIT SET? - INDICATES DOUBLE SIDED
  4066 00000DFE 751A                    		JNZ	short GoodDsk
  4067 00000E00 2E813E[D801]332E        		CMP	word [CS:DiskSector+8],"3."
  4068 00000E07 7508                    		JNZ	short MUSTBEEARLIER
  4069 00000E09 2E803E[DA01]32          		CMP	byte [CS:DiskSector+10],"2"
  4070 00000E0F 7309                    		JAE	short GoodDsk
  4071                                  
  4072                                  ; WE MUST HAVE A PRE-3.20 DISKETTE. SET THE SEC/CLUS FIELD TO 1
  4073                                  MUSTBEEARLIER:
  4074                                  		;MOV	BYTE [CS:SECPERCLUSINSECTOR],1
  4075                                  		; 16/07/2019 - Retro DOS v3.2
  4076 00000E11 2EC606[DD01]01          		mov	byte [cs:DiskSector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER],1 ; 0Dh
  4077 00000E17 EB01                    		JMP	short GoodDsk
  4078                                  
  4079                                  INVALIDBOOTSEC:
  4080 00000E19 43                      		INC	BX		; SET THAT BOOT SECTOR INVALID
  4081                                  ;;End of Modification
  4082                                  
  4083                                  GoodDsk:				; carry already reset
  4084 00000E1A F8                      		clc
  4085                                  Err_ret:
  4086                                  movbpb_ret:		; 19/07/2019
  4087 00000E1B C3                      		retn
  4088                                  
  4089                                  ;Err_Ret:				; carry is already set on entry here
  4090                                  ;		retn
  4091                                  
  4092                                  ; --------------------------------------------------------------------------
  4093                                  ;
  4094                                  ; MovBPB moves the BPB read from the Boot sector into registers for use by
  4095                                  ; GETBP routine at Has1
  4096                                  
  4097                                  ; if the set_id_flag is 1, and if an extended boot record, then set volume
  4098                                  ; serial number, volume label, file system id in bds according to
  4099                                  ; the boot record. after that, this routine will set the set_id_flag to 2
  4100                                  ; to signal that volume label is set already from the extended boot record
  4101                                  ; (so, don't set it again by calling "set_volume_id" routine which uses
  4102                                  ; the volume label in the root directory.)
  4103                                  ;
  4104                                  ; --------------------------------------------------------------------------
  4105                                  
  4106                                  MOVBPB:
  4107                                  		; 16/07/2019 - Retro DOS v3.2
  4108 00000E1C 1E                      		push	ds  ; DS:DI = BDS address
  4109 00000E1D 0E                      		push	cs
  4110 00000E1E 1F                      		pop	ds
  4111 00000E1F 8A36[DD01]              		mov	dh,[DiskSector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER] 
  4112                                  						;sectors per unit
  4113 00000E23 8A3E[E101]              		mov	bh,[DiskSector+EXT_BOOT.BPB+EBPB.ROOTENTRIES] 
  4114                                  						;number of directory entries
  4115 00000E27 8B0E[E301]              		mov	cx,[DiskSector+EXT_BOOT.BPB+EBPB.TOTALSECTORS] 
  4116                                  						;size of drive
  4117 00000E2B 8A26[E501]              		mov	ah,[DiskSector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR] 
  4118                                  						;media descriptor
  4119 00000E2F A0[E601]                		mov	al,[DiskSector+EXT_BOOT.BPB+EBPB.SECTORSPERFAT] 
  4120                                  						;number of fat sectors
  4121 00000E32 8A1E[E801]              		mov	bl,[DiskSector+EXT_BOOT.BPB+EBPB.SECTORSPERTRACK] 
  4122                                  						;sectors per track
  4123 00000E36 8A16[EA01]              		mov	dl,[DiskSector+EXT_BOOT.BPB+EBPB.HEADS] 
  4124                                  						;number of heads
  4125                                  		; 16/07/2019
  4126 00000E3A 8B36[DE01]              		mov	si,[DiskSector+EXT_BOOT.BPB+EBPB.RESERVEDSECTORS]
  4127                                  						;reserved sectors
  4128                                  		; 19/07/2019
  4129 00000E3E 1F                      		pop	ds  ; DS:DI = BDS address
  4130                                  
  4131 00000E3F 2E803E[8705]01          		cmp	byte [cs:set_id_flag],1	; called by get_bpb?
  4132 00000E45 75D4                    		jne	short movbpb_ret
  4133                                  
  4134 00000E47 E856FE                  		call	mov_media_ids
  4135 00000E4A 7206                    		jc	short movbpb_conv	; conventional boot record?
  4136 00000E4C 2EC606[8705]02          		mov	byte [cs:set_id_flag],2	; signals that volume id is set.
  4137                                  movbpb_conv:
  4138 00000E52 2E803E[1201]01          		cmp	byte [cs:fHave96],1
  4139 00000E58 75C1                    		jne	short movbpb_ret
  4140                                  		;call	ResetChanged		; reset flags in bds to not fchanged.
  4141                                  		;retn
  4142 00000E5A E9470E                  		jmp	ResetChanged
  4143                                  		; 19/07/2019
  4144                                  ;movbpb_ret:
  4145                                  ;		;clc
  4146                                  ;		retn
  4147                                  
  4148                                  ; --------------------------------------------------------------------
  4149                                  ;
  4150                                  ; Read in the FAT sector and get the Media Byte from it.
  4151                                  ; Input : AL contains logical drive.
  4152                                  ; Output:
  4153                                  ;	  Carry set if an error occurs, AX contains error code.
  4154                                  ;	  Otherwise, AH contains media byte on exit. AL is preserved.
  4155                                  ;
  4156                                  ; --------------------------------------------------------------------
  4157                                  
  4158                                  READFAT:
  4159                                  		; 19/07/2019 - Retro DOS v3.2
  4160                                  		;push	ax		   ; preserve logical drive in AL
  4161 00000E5D B600                    		MOV	DH,0		   ; HEAD 0
  4162 00000E5F B90200                  		mov	CX,2		   ; set track and sector number
  4163 00000E62 E80600                  		call	READ_SECTOR	   ; CS:BX points to fat sector
  4164 00000E65 7203                    		jc	short Bad_FAT_Ret  ; error, get out
  4165                                  		;pop	ax		   ; reset logical drive
  4166 00000E67 2E8A27                  		mov	ah,[CS:BX]	   ; media byte
  4167                                  Bad_FAT_Ret:
  4168 00000E6A C3                      		retn
  4169                                  ;Bad_FAT_Ret:				   ; carry set on entry
  4170                                  		;pop	cx	           ; clear stack
  4171                                  		;retn
  4172                                  
  4173                                  ; --------------------------------------------------------------------------
  4174                                  ;
  4175                                  ; Read_sector reads a single sector into the tempory buffer 'DiskSector'.
  4176                                  ; Up to three retries are done in case of error.
  4177                                  ;
  4178                                  ;    Inputs:
  4179                                  ;	DS:DI	points to BDS for drive
  4180                                  ;	CH - track number
  4181                                  ;	CL - sector number
  4182                                  ;	DH - head number
  4183                                  ;
  4184                                  ;    Outputs:
  4185                                  ;	If carry is clear -- successful read
  4186                                  ;	   CS:BX points to buffer holding sector
  4187                                  ;	   AX, BX are not preserved, CX, DX, BP, and ES are preserved
  4188                                  ;
  4189                                  ;	If carry is set -- error on read
  4190                                  ;	   AX, BX, and DX are not preserved; CX, BP, and ES are preserved
  4191                                  ;
  4192                                  ; --------------------------------------------------------------------------
  4193                                  
  4194                                  READ_SECTOR:
  4195 00000E6B 55                      		push	BP		; preserve BP register
  4196 00000E6C BD0300                  		mov	BP,3		; BP is retry count, set to 3
  4197 00000E6F 06                      		push	ES		; preserve ES also
  4198 00000E70 8A5504                  		mov	DL,[DI+BDS.drivenum]
  4199 00000E73 BB[D001]                		mov	BX,DiskSector	; Get ES:BX to point to buffer
  4200 00000E76 0E                      		push	CS		;    get the segment right
  4201 00000E77 07                      		pop	ES		; now ES:BX is correct
  4202                                  RD_RET:
  4203                                  					; set command to read (AH=2) and
  4204 00000E78 B80102                  		mov	AX,0201h	; number of sectors to 1 (AL=1)
  4205 00000E7B CD13                    		int	13h		; call rom-bios disk routines
  4206 00000E7D 7336                    		jnc	short OKRET2	; if no carry then no error - done
  4207                                  Rd_rty:
  4208 00000E7F E8A609                  		call	AGAIN		; reset disk and decrement BP
  4209 00000E82 7446                    		jz	short ERR_RD_RET
  4210                                  		;test	word [DI+BDS.flags],fNon_Removable ; 1
  4211 00000E84 F6452301                		test	byte [DI+BDS.flags],fNon_Removable ; 19/07/219
  4212 00000E88 75EE                    		JNZ	short RD_RET
  4213                                  
  4214                                  ;;Rev 3.30 Modification -----------------------------------------
  4215 00000E8A 1E                      		push	ds		; For retry, set head settle
  4216 00000E8B 50                      		push	ax		; time to 0Fh.
  4217 00000E8C 2EC536[AE01]            		lds	si,[CS:DPT]
  4218 00000E91 8A4409                  		mov	al,[SI+DISK_PARMS.DISK_HEAD_STTL]
  4219 00000E94 2EA2[AB01]              		mov	[CS:Save_head_sttl],al
  4220 00000E98 C644090F                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],NORMSETTLE
  4221 00000E9C 58                      		pop	ax
  4222 00000E9D 1F                      		pop	ds
  4223                                  					; SET CMD TO READ (AH=2) AND
  4224 00000E9E B80102                  		MOV	AX,0201h	; NUM OF SECTORS TO 1 (AL=1)
  4225 00000EA1 CD13                    		INT	13h		; CALL ROM-BIOS DISK ROUTINES
  4226 00000EA3 1E                      		push	ds
  4227 00000EA4 50                      		push	ax
  4228 00000EA5 2EC536[AE01]            		lds	si,[CS:DPT]
  4229 00000EAA 2EA0[AB01]              		mov	al,[CS:Save_head_sttl]
  4230 00000EAE 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],al
  4231 00000EB1 58                      		pop	ax
  4232 00000EB2 1F                      		pop	ds
  4233                                  		; 19/07/2019
  4234                                  		;jnc	short OKRET2
  4235                                  		;jmp	short Rd_rty
  4236 00000EB3 72CA                    		jc	short Rd_rty
  4237                                  ;ERR_RD_RET:
  4238                                  ;		MOV	DL,-1	; MAKE SURE WE ASK ROM IF MEDIA  CHANGED
  4239                                  ;		STC		; RETURN ERROR
  4240                                  ;;End of Modification -----------------------------------------
  4241                                  
  4242                                  			; Update information pertaining to last drive
  4243                                  			; accessed, time of access, last track accessed
  4244                                  			; in that drive.
  4245                                  OKRET2:
  4246                                  				; set up for head settle logic in DISK
  4247 00000EB5 2E8816[1101]            		mov	[CS:STEP_DRV],DL ; save last drive accessed
  4248 00000EBA 2E8816[9F01]            		mov	[CS:TIM_DRV],DL	; save the values
  4249 00000EBF 886D46                  		mov	[DI+BDS.track],CH ;
  4250 00000EC2 9C                      		pushf			; save the flags
  4251 00000EC3 E88703                  		call	SET_TIM
  4252 00000EC6 9D                      		popf			; restore flags
  4253 00000EC7 07                      		pop	ES		; restore registers
  4254 00000EC8 5D                      		pop	BP
  4255 00000EC9 C3                      		retn
  4256                                  ERR_RD_RET:
  4257                                  		; 19/07/2019
  4258 00000ECA B2FF                    		MOV	DL,-1	; MAKE SURE WE ASK ROM IF MEDIA  CHANGED
  4259 00000ECC F9                      		STC		; RETURN ERROR
  4260 00000ECD EBE6                    		jmp	short OKRET2
  4261                                  
  4262                                  ;27/05/2018 - Retro DOS v3.0
  4263                                  
  4264                                  ;------------------------------------------------------------------------
  4265                                  ;									:
  4266                                  ;		Disk Removable Routine					:
  4267                                  ;									:
  4268                                  ;  This routine determines if a particular logical drive has		:
  4269                                  ;  removable media.							:
  4270                                  ;									:
  4271                                  ;  Input								:
  4272                                  ;     AL contains the logical drive number which the check is being	:
  4273                                  ;  done.								:
  4274                                  ;------------------------------------------------------------------------
  4275                                  
  4276                                  DSK$REM:				;ARR 2.41
  4277 00000ECF E8A3FC                  		call	SETDRIVE	; get BDS for this drive
  4278 00000ED2 F745230100              		test	word [DI+BDS.flags],fNon_Removable
  4279 00000ED7 7503                    		jnz	short NON_REM
  4280 00000ED9 E98BF9                  		jmp	EXIT
  4281                                  
  4282                                  NON_REM:				; if non removable set busy bit
  4283 00000EDC E96DF9                  		jmp	BUS$EXIT
  4284                                  
  4285                                  ;------------------------------------------------------------------------
  4286                                  ;									:
  4287                                  ;		DISK I/O ROUTINES					:
  4288                                  ;									:
  4289                                  ;  On entry the register contain the following values:			:
  4290                                  ;									:
  4291                                  ;	AH - Media Descriptor byte					:
  4292                                  ;	AL - logical drive number					:
  4293                                  ;	CX - count of sectors to be read or written			:
  4294                                  ;	DX - start sector						:
  4295                                  ;	DI - offset of destination buffer				:
  4296                                  ;									:
  4297                                  ;------------------------------------------------------------------------
  4298                                  
  4299                                  ;------------------------------------------------------------------------
  4300                                  ;									:
  4301                                  ;		Disk Write with Verify					:
  4302                                  ;									:
  4303                                  ;  Input								:
  4304                                  ;	See about header for register contents on entry.		:
  4305                                  ;									:
  4306                                  ;------------------------------------------------------------------------
  4307                                  
  4308                                  
  4309                                  DSK$WRITV:
  4310 00000EDF 2EC706[A201]0301        		MOV	WORD [CS:WRTVERIFY],103H
  4311 00000EE6 EB07                    		JMP	SHORT DSK$CL
  4312                                  
  4313                                  ;------------------------------------------------------------------------
  4314                                  ;									:
  4315                                  ;		       Disk Write					:
  4316                                  ;									:
  4317                                  ;  Input								:
  4318                                  ;	See about header for register contents on entry.		:
  4319                                  ;									:
  4320                                  ;------------------------------------------------------------------------
  4321                                  
  4322                                  DSK$WRIT:
  4323 00000EE8 2EC706[A201]0300        		MOV	WORD [CS:WRTVERIFY],ROMWrite
  4324                                  
  4325                                  DSK$CL:
  4326 00000EEF E87D00                  		CALL	DISKIO
  4327                                  DSK$IO:
  4328 00000EF2 7203                    		JC	short DSKBad
  4329 00000EF4 E970F9                  		JMP	EXIT
  4330                                  DSKBad:
  4331 00000EF7 E958F9                  		JMP	ERR$CNT
  4332                                  
  4333                                  ;------------------------------------------------------------------------
  4334                                  ;									:
  4335                                  ;			Disk Read					:
  4336                                  ;									:
  4337                                  ;  Input								:
  4338                                  ;	See about header for register contents on entry.		:
  4339                                  ;									:
  4340                                  ;------------------------------------------------------------------------
  4341                                  
  4342                                  DSK$READ:
  4343 00000EFA E86D00                  		CALL	DISKRD
  4344 00000EFD EBF3                    		JMP	short DSK$IO
  4345                                  
  4346                                  ; -----------------------------------------------------------------------
  4347                                  ; Miscellaneous odd jump routines. Moved out of mainline for speed.
  4348                                  ; -----------------------------------------------------------------------
  4349                                  
  4350                                  ; CheckSingle determines if the drive specified is a virtual drive (more
  4351                                  ; than one logical drive associated with one physical drive). If this
  4352                                  ; is the case we need to prompt the user to place the correct disk in
  4353                                  ; the drive.
  4354                                  ;
  4355                                  ;	Input:
  4356                                  ;	   DS:DI pints to the BDS for the drive being checked.
  4357                                  ;
  4358                                  ;	If there is a error the carry flag is set on return
  4359                                  ;
  4360                                  ;  All registers are preserved.
  4361                                  
  4362                                  
  4363                                  CHECKSINGLE:
  4364                                  		; 27/05/2018 - Retro DOS v3.0
  4365 00000EFF 50                      		push	AX		; save affected registers
  4366 00000F00 53                      		push	BX
  4367                                  
  4368 00000F01 8B5D23                  		mov	BX,[DI+BDS.flags]
  4369                                  					;Can't change disk
  4370 00000F04 F6C321                  		TEST	BL,fNon_Removable | fI_Own_Physical
  4371 00000F07 755A                    		jnz	short SingleRet	; on hard drive so return
  4372                                  					; is there a drive sharing this
  4373 00000F09 F6C310                  		TEST	BL,fI_Am_Mult	;   physical drive?
  4374 00000F0C 7455                    		jz	short SingleRet	; if not, then return
  4375                                  
  4376                                  			; At this point there is more than one
  4377                                  			; logical drive mapped to this physical drive.
  4378                                  			; But the drive being accessed is not the
  4379                                  			; owner of the physical drive. What needs to
  4380                                  			; be done is find the current owner BDS and
  4381                                  			; turn off the owner flag and then make current
  4382                                  			; BDS the owner of the drive. Then prompt the
  4383                                  			; user to change disks.
  4384                                  	
  4385 00000F0E 8A4504                  		mov	al,[DI+BDS.drivenum] ; get physical drive number
  4386 00000F11 1E                      		push	ds		; preserve pointer to current BDS
  4387 00000F12 57                      		push	di
  4388 00000F13 0E                      		push	cs
  4389 00000F14 1F                      		pop	ds		; Point to start of BDS linked list
  4390                                  
  4391                                  		; 19/07/2019 - Retro DOS v3.2
  4392                                  
  4393                                  		;mov	di,START_BDS
  4394                                  ;Scan_List:
  4395                                  		;mov	bx,[DI+BDS.link+2] ; go to next BDS
  4396                                  		;;mov	di,[DI+BDS.link]
  4397                                  		;mov	di,[di] ; 05/07/2019
  4398                                  		;mov	ds,bx
  4399                                  		
  4400                                  		;cmp	di,-1		; end of list?
  4401                                  		;jz	short Single_Err_Ret ; if so there must be an error
  4402                                  
  4403                                  		; 19/07/2019
  4404 00000F15 C53E[9A01]              		lds	di,[START_BDS]
  4405                                  Scan_List:
  4406 00000F19 384504                  		cmp	[DI+BDS.drivenum],al ; same physical drive?
  4407                                  		;jnz	short Scan_List	; no, keep looking
  4408 00000F1C 753B                    		jnz	short scan_skip
  4409                                  Check_Own:				; yes, check to see if owner
  4410                                  		;mov	bx,[DI+BDS.flags]
  4411                                  		;mov	bl,[di+BDS.flags]
  4412                                  		;test	bl,fI_Own_Physical
  4413 00000F1E B320                    		mov	bl,fI_Own_Physical
  4414 00000F20 845D23                  		test	bl,[di+BDS.flags] ; 21/07/2019
  4415                                  		;jz	short Scan_List	; not owner, keep looking
  4416 00000F23 7434                    		jz	short scan_skip
  4417                                  
  4418                                  		;xor	bl,fI_Own_Physical ; yes owner, reset ownership flag
  4419                                  		;mov	[DI+BDS.flags],bx
  4420 00000F25 305D23                  		xor	[di+BDS.flags],bl  ; reset ownership flag
  4421                                  
  4422 00000F28 5F                      		pop	di		; restore pointer to current BDS
  4423 00000F29 1F                      		pop	ds
  4424                                  		
  4425                                  		;xor	bx,bx
  4426                                  		;or	bl,fI_Own_Physical ; establish current BDS as owner
  4427                                  		;or	[DI+BDS.flags],bx
  4428 00000F2A 085D23                  		or	byte [di+BDS.flags],bl ; set ownership flag
  4429                                  		
  4430                                  			; We examine the fSetOwner flag. If it is
  4431                                  			; set, then we are using the code in
  4432                                  			; CheckSingle to just set the owner of
  4433                                  			; a drive. We must not issue the prompt
  4434                                  			; in this case.
  4435                                  
  4436 00000F2D 2E803E[1501]01          		cmp	byte [cs:fSetOwner],1
  4437 00000F33 742E                    		jz	short SingleRet
  4438                                  
  4439                                  ;		; 19/07/2019
  4440                                  ;
  4441                                  ;		cmp	byte [cs:fSetOwner],1
  4442                                  ;		jne	short not_fsetowner
  4443                                  ;
  4444                                  ;		cmp	byte [di+BDS.drivenum],0 ; are we handling drive
  4445                                  ;						;  number 0 ?
  4446                                  ;		jne	short SingleRet
  4447                                  ;
  4448                                  ;		push	es
  4449                                  ;		xor	ax,ax
  4450                                  ;		mov	es,ax
  4451                                  ;		mov	al,[di+BDS.drivelet] ; get the DOS drive letter		
  4452                                  ;		mov	[es:LSTDRV],al 		; & set up sdsb
  4453                                  ;		pop	es			; restore bds pointer
  4454                                  ;		jmp	short SingleRet
  4455                                  ;	
  4456                                  			; To support "backward" compatibility with
  4457                                  			; IBM's "single drive status byte" we now
  4458                                  			; check to see if we are in a single drive
  4459                                  			; system and the Application has "cleverly"
  4460                                  			; diddled the SDSB (Single Drive Status Byte)
  4461                                  ;not_fsetowner:
  4462 00000F35 2E803E[1401]02          		cmp	byte [cs:Single],2 ; single drive system?
  4463 00000F3B 7517                    		jne	short Ignore_SDSB  ; no, jump down
  4464                                  
  4465 00000F3D 1E                      		push	ds		   ; yes...		
  4466 00000F3E 57                      		push	di
  4467 00000F3F 50                      		push	ax
  4468                                  
  4469 00000F40 8A4505                  		mov	al,[DI+BDS.drivelet] ; IF (Curr_drv == Req_drv)
  4470 00000F43 88C4                    		mov	ah,al
  4471 00000F45 31FF                    		xor	di,di
  4472 00000F47 8EDF                    		mov	ds,di
  4473 00000F49 86060405                		xchg	al,[LSTDRV]	    ; THEN swap(Curr_drv,Req_drv)
  4474 00000F4D 38C4                    		cmp	ah,al		    ; ELSE
  4475 00000F4F 58                      		pop	ax		    ;     swap(Curr_drv,Req_drv)	
  4476 00000F50 5F                      		pop	di		    ;	  Issue Swap_dsk_msg	
  4477 00000F51 1F                      		pop	ds
  4478 00000F52 740F                    		je	short SingleRet	
  4479                                  Ignore_SDSB:
  4480 00000F54 E8380B                  		call	SWPDSK		; ask user for correct disk
  4481                                  		; 19/07/2019
  4482 00000F57 EB0A                    		jmp	short SingleRet
  4483                                  scan_skip:
  4484                                  		;lds	di,[di+BDS.link] ; go to next bds
  4485 00000F59 C53D                    		lds	di,[di]
  4486 00000F5B 83FFFF                  		cmp	di,-1		; end of list?
  4487 00000F5E 75B9                    		jnz	short Scan_List	; continue until hit end of list
  4488                                  
  4489                                  ;SingleRet:
  4490                                  ;		pop	BX		; restore registers
  4491                                  ;		pop	AX
  4492                                  ;		retn			; return
  4493                                  
  4494                                  Single_Err_Ret:
  4495 00000F60 F9                      		stc			; set carry flage to indicate error
  4496 00000F61 5F                      		pop	di		; restore current BDS
  4497 00000F62 1F                      		pop	ds
  4498                                  		;jmp	short SingleRet
  4499                                  SingleRet:
  4500 00000F63 5B                      		pop	BX		; restore registers
  4501 00000F64 58                      		pop	AX
  4502 00000F65 C3                      		retn			; return
  4503                                  
  4504                                  ;
  4505                                  ; BadDrive is called when sector specified is greater than last
  4506                                  ; sector on disk.
  4507                                  ; or when BDS is not found for drive
  4508                                  ;
  4509                                  
  4510                                  BadDrive:
  4511 00000F66 B008                    		mov	AL,8		; error code 'sector not found'
  4512 00000F68 F9                      		stc			; indicate error
  4513                                  IORET:	
  4514 00000F69 C3                      		retn			; return
  4515                                  		
  4516                                  		; 19/07/2019
  4517                                  ;BogusSettle:
  4518                                  ;		MOV	AL,NORMSETTLE	; someone has diddled the settle
  4519                                  ;		JMP	GotSlowSettle
  4520                                  
  4521                                  ; -----------------------------------------------------------------------
  4522                                  ;
  4523                                  ;	DISK I/O HANDLER
  4524                                  ;
  4525                                  ;   On entry:
  4526                                  ;	AL = Drive Number (0-6)
  4527                                  ;	AH = Media Descriptor
  4528                                  ;	CX = sector count
  4529                                  ;	DX = first sector
  4530                                  ;	DS = CS
  4531                                  ;	ES:DI = transfer address
  4532                                  ;	[RFLAG] = operation (2 for read, 3 for write)
  4533                                  ;	[VERIFY] = 1 for verity after write
  4534                                  ;
  4535                                  ;   On exit:
  4536                                  ;	if successful carry flag = 0
  4537                                  ;	  else CF=1 and AL contains error code
  4538                                  ;
  4539                                  ; -----------------------------------------------------------------------
  4540                                  
  4541                                  DISKRD:		; 27/05/2018 - Retro DOS v3.0
  4542                                  		;mov	byte [CS:RFLAG],ROMRead	; set command to read
  4543 00000F6A C606[A201]02            		mov	byte [RFLAG],ROMRead	 ; 11/04/2018
  4544                                  DISKIO:
  4545                                  		; 21/07/2019 - Retro DOS v3.2
  4546                                  		; 13/04/2018
  4547                                  		; 08/04/2018
  4548                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  4549                                  
  4550                                  		;clc
  4551                                  		;jcxz	IORET
  4552                                  		
  4553                                  		;;mov	[CS:SPSAV],SP		; save the sp value
  4554                                  		;mov	[SPSAV],sp
  4555                                  
  4556 00000F6F 89FB                    		mov	BX,DI			; ES:BX is transfer address
  4557 00000F71 E801FC                  		call	SETDRIVE		; map logical and physical
  4558 00000F74 72F0                    		jc	short BadDrive		; carry means BDS not found
  4559 00000F76 8A4510                  		mov	al,[DI+BDS.media]
  4560 00000F79 2EA2[A001]              		mov	[CS:MedByt],al		; Preserve media byte for drive for use
  4561                                  						; in determining media change.
  4562 00000F7D E3EA                    		jcxz	IORET
  4563 00000F7F 2E8926[B601]            		mov	[CS:SPSAV],SP		; save the sp value
  4564                                  		; 21/07/2019
  4565 00000F84 2E890E[A401]            		mov	[cs:SECCNT],cx		; save sector count
  4566                                  
  4567                                  		; DX = Sector address (offset)
  4568                                  		; BX = Buffer address (offset)
  4569                                  
  4570                                  		; 21/07/2019 - Retro DOS v3.2
  4571                                  
  4572                                  		; [start_sec_h] = high word of 32 bit sector address
  4573                                  		
  4574                                  ; Ensure that we are trying to access valid sectors on the drive
  4575                                  
  4576                                  		;mov	SI,DX			; start with first sector
  4577                                  		;add	SI,CX			; add in sector count
  4578                                  		;add	DX,[DI+BDS.hiddensecs]	; add in the hidden sectors
  4579                                  		;cmp	SI,[DI+BDS.totalsecs16]	; compare against max (volume size)
  4580                                  		;ja	short BadDrive		; if greater than max, error
  4581                                  		;mov	[CS:SECCNT],CX		; save sector count
  4582                                  
  4583                                  		; 21/07/2019
  4584 00000F89 89D0                    		mov	ax,dx		; save dx to ax
  4585 00000F8B 31F6                    		xor	si,si
  4586 00000F8D 01CA                    		add	dx,cx
  4587 00000F8F 83D600                  		adc	si,0
  4588 00000F92 837D0E00                		cmp	word [di+BDS.totalsecs16],0 ; > 32 bit sector ?
  4589 00000F96 740B                    		je	short sanity32
  4590                                  
  4591                                  		;cmp	si,0
  4592                                  		;jne	short BadDrive
  4593 00000F98 09F6                    		or	si,si
  4594 00000F9A 75CA                    		jnz	short BadDrive
  4595 00000F9C 3B550E                  		cmp	dx,[di+BDS.totalsecs16]
  4596 00000F9F 77C5                    		ja	short BadDrive
  4597 00000FA1 EB11                    		jmp	short sanityok
  4598                                  sanity32:
  4599 00000FA3 2E0336[A805]            		add	si,[cs:start_sec_h]
  4600 00000FA8 3B751D                  		cmp	si,[di+BDS.totalsecs32+2]
  4601 00000FAB 7207                    		jb	short sanityok
  4602 00000FAD 77B7                    		ja	short BadDrive
  4603 00000FAF 3B551B                  		cmp	dx,[di+BDS.totalsecs32]
  4604 00000FB2 77B2                    		ja	short BadDrive
  4605                                  sanityok:
  4606 00000FB4 2E8B16[A805]            		mov	dx,[cs:start_sec_h]
  4607 00000FB9 034517                  		add	ax,[di+BDS.hiddensecs]
  4608 00000FBC 135519                  		adc	dx,[di+BDS.hiddensecs+2]
  4609                                  
  4610                                  ; now dx;ax have the physical first sector.
  4611                                  ;since the following procedures is going to destroy ax, let's
  4612                                  ;save it temporarily to saved_word.
  4613                                  
  4614 00000FBF 2EA3[AA05]              		mov	[cs:saved_word],ax	; save the sector number (low)
  4615                                  
  4616                                  ;;Rev 3.30 Modification -----------------------------------------
  4617                                  ; SET UP POINTER TO DISK BASE TABLE IN [DPT]. WE CANNOT ASSUME THAT IOSETUP
  4618                                  ; WILL DO IT BECAUSE WE WILL SKIP THE SET UP STUFF WITH HARD DISKS.
  4619 00000FC3 1E                      		PUSH	DS
  4620 00000FC4 31C0                    		XOR	AX,AX
  4621 00000FC6 8ED8                    		MOV	DS,AX
  4622 00000FC8 C5367800                		LDS	SI,[DSKADR]		; CURRENT DISK PARM TABLE
  4623 00000FCC 2E8936[AE01]            		MOV	[CS:DPT],SI
  4624 00000FD1 2E8C1E[B001]            		MOV	[CS:DPT+2],DS
  4625 00000FD6 1F                      		POP	DS
  4626                                  ;;End of Modification -----------------------------------------
  4627                                  
  4628                                  ; For hard drives do not do media check or set DPT.
  4629                                  
  4630 00000FD7 F745230100              		test	word [DI+BDS.flags],fNon_Removable
  4631 00000FDC 7511                    		jnz	short Skip_Setup
  4632                                  	
  4633 00000FDE E81EFF                  		CALL	CHECKSINGLE
  4634                                  
  4635                                  ; Check to see if we have previously noted a change line. The routine
  4636                                  ; returns if everything is OK. Otherwise, it pops off the stack and returns
  4637                                  ; the proper error code.
  4638                                  
  4639                                  		; 17/07/2019 - Retro DOS v3.2
  4640                                  		; (MSDOS 3.3)
  4641                                  
  4642                                  ;		;----------------------------------------|
  4643                                  ;		; Warning: Do not change the following. ;|
  4644                                  ;		;	   It gets patched in msinit	;|
  4645                                  ;DiskIO_PATCH:						;|
  4646                                  ;		CALL	CheckLatchIO			;|
  4647                                  ;		;----------------------------------------|
  4648                                  
  4649                                  		; 17/07/2019 - Retro DOS v3.2
  4650                                  		; (MSDOS 6.0)
  4651                                  
  4652 00000FE1 2E803E[1201]00          		cmp	byte [cs:fHave96],0 ; do we have changeline support?
  4653 00000FE7 7403                    		jz	short diskio_nochangeline ; brif not
  4654 00000FE9 E8A40B                  		call	CheckLatchIO	; will do a sneaky pop stack return
  4655                                  					;  if a disk error occurs
  4656                                  diskio_nochangeline:
  4657                                  
  4658                                  ; Set up tables and variables for I/O
  4659                                  
  4660 00000FEC E84E00                  		call	IOSETUP
  4661                                  ;
  4662                                  ; Now the settle values are correct for the following code
  4663                                  ;
  4664                                  Skip_Setup:
  4665                                  		;mov	AX,DX		; setup locical sector for divide
  4666                                  		;xor	DX,DX
  4667                                  		;div	word [DI+BDS.secpertrack] ; divide by sectors per track
  4668                                  		;inc	DL
  4669                                  		;mov	[CS:CURSEC],DL	; save current sector
  4670                                  		;mov	CX,[DI+BDS.heads]  ; get number of heads
  4671                                  		;xor	DX,DX		; divide tracks by heads per cylinder
  4672                                  		;div	CX
  4673                                  
  4674                                  ; 32 bit sector calculation.
  4675                                  ; dx:[saved_word] = starting sector number.
  4676                                  
  4677                                  		; 21/07/2019 - Retro DOS v3.2
  4678 00000FEF 89D0                    		mov	ax,dx
  4679 00000FF1 31D2                    		xor	dx,dx
  4680 00000FF3 F77513                  		div	word [di+BDS.secpertrack] ; divide by sec per track
  4681 00000FF6 2EA3[A605]              		mov	[cs:temp_h],ax
  4682 00000FFA 2EA1[AA05]              		mov	ax,[cs:saved_word] ; restore the lower word
  4683 00000FFE F77513                  		div	word [di+BDS.secpertrack]
  4684                                  
  4685                                  		;now, [temp_h],ax = track #, dx = sector
  4686                                  
  4687 00001001 FEC2                    		inc	dl		;sector number is 1 based.
  4688 00001003 2E8816[B201]            		mov	[cs:CURSEC],dl	;save current sector
  4689 00001008 8B4D15                  		mov	cx,[di+BDS.heads] ;get number of heads
  4690                                  
  4691 0000100B 50                      		push	ax
  4692 0000100C 31D2                    		xor	dx,dx		;divide tracks by heads per cylinder
  4693 0000100E 2EA1[A605]              		mov	ax,[cs:temp_h]
  4694 00001012 F7F1                    		div	cx
  4695 00001014 2EA3[A605]              		mov	[cs:temp_h],ax
  4696 00001018 58                      		pop	ax
  4697 00001019 F7F1                    		div	cx
  4698                                  
  4699                                  		;now, [temp_h],ax = cylinder #, dx = head
  4700                                  
  4701 0000101B 2E833E[A605]00          		cmp	word [cs:temp_h],0
  4702 00001021 7717                    		ja	short baddrive_brdg
  4703 00001023 3D0004                  		cmp	ax,1024 	; 2**10 currently maximum for track #.
  4704                                  		;ja	short baddrive_brdg
  4705                                  		; 30/07/2019
  4706 00001026 7312                    		jnb	short baddrive_brdg ; cylinder number must be <= 1023
  4707                                  
  4708 00001028 2E8816[B301]            		mov	[CS:CURHD],DL	; save current head
  4709 0000102D 2EA3[B401]              		mov	[CS:CURTRK],AX	; save current track
  4710                                  
  4711                                  ; We are now set up for the I/O. Normally, we consider the DMA boundary
  4712                                  ; violations here. Not true. We perform the operation as if everything is
  4713                                  ; symmetric; let the DISK INT handler worry about the DMA violations.
  4714                                  
  4715 00001031 2EA1[A401]              		mov	AX,[CS:SECCNT]
  4716 00001035 E87200                  		call	BLOCK
  4717                                  		;call	DONE
  4718                                  		;retn
  4719                                  		; 21/07/2019
  4720 00001038 EB43                    		jmp	DONE
  4721                                  
  4722                                  		; 21/07/2019
  4723                                  baddrive_brdg: 
  4724 0000103A E929FF                  		jmp	BadDrive
  4725                                  
  4726                                  ; 27/05/2018 - Retro DOS v3.0
  4727                                  
  4728                                  ; IOSetUp:
  4729                                  ;
  4730                                  ; IOSetUp does the following functions:
  4731                                  ;   *	Set the drive-last-accessed flag (for diskette only).  No need to
  4732                                  ;	update these flags for hard disks becuase we know a hard disk will
  4733                                  ;	not be removed.
  4734                                  ;   *	Set the proper last sector number in the Disk Parameter Table (DPT)
  4735                                  ;   *	Set the proper motor start up time in DPT
  4736                                  ;   *	Set the proper head settle time in the DPT
  4737                                  ;
  4738                                  ; Input:
  4739                                  ;	DS:DI -> current BDS.
  4740                                  ; Output:
  4741                                  ;	AX,CX,SI are destroyed.
  4742                                  ;
  4743                                  
  4744                                  IOSETUP:
  4745 0000103D 8A4504                  		MOV	AL,[DI+BDS.drivenum]
  4746 00001040 2EA2[9F01]              		MOV	[CS:TIM_DRV],AL	; SAVE DRIVE LETTER
  4747                                  
  4748                                  ; determine proper head settle values
  4749                                  
  4750 00001044 8CD9                    		mov	CX,DS
  4751 00001046 2EC536[AE01]            		LDS	SI,[CS:DPT]	; GET POINTER TO DISK BASE TABLE
  4752 0000104B 2EA0[AC01]              		MOV	AL,[CS:EOT]
  4753 0000104F 884404                  		mov	[SI+DISK_PARMS.DISK_EOT],AL	; bump for us
  4754 00001052 8A440A                  		mov	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT] 
  4755                                  					; preserve old motor start time
  4756 00001055 2EA2[A701]              		mov	[CS:MotorStartup],AL
  4757                                  
  4758                                  ; For 3.5" drives, both external as well as on the K09, we need to set the
  4759                                  ; Motor Start Time to 4. This checking for every I/O is going to affect
  4760                                  ; performance across the board, but is necessary!!
  4761                                  
  4762 00001059 06                      		push	es
  4763 0000105A 8EC1                    		mov	es,cx		; ES:DI -> to current BDS
  4764 0000105C 26807D2202              		cmp	byte [es:di+BDS.formfactor],ffSmall
  4765 00001061 7505                    		jnz	short Motor_Start_OK
  4766 00001063 B004                    		mov	AL,4
  4767 00001065 86440A                  		xchg	AL,[SI+DISK_PARMS.DISK_MOTOR_STRT]
  4768                                  Motor_Start_OK:
  4769 00001068 07                      		pop	ES
  4770                                  
  4771                                  ; DS:SI now points to disk parameter table. Get current settle and set fast
  4772                                  ; settle
  4773 00001069 30C0                    		XOR	AL,AL
  4774 0000106B FEC0                    		INC	AL		; IBM WANTS FAST SETTLE = 1 - RS
  4775 0000106D 864409                  		xchg	AL,[SI+DISK_PARMS.DISK_HEAD_STTL]
  4776                                  					; get settle and set up for fast
  4777 00001070 2EA2[A801]              		mov	[CS:SettleCurrent],AL
  4778 00001074 B00F                    		MOV	AL,NORMSETTLE	; SOMEONE HAS DIDDLED THE SETTLE
  4779                                  GotSlowSettle:
  4780 00001076 8ED9                    		mov	DS,CX
  4781 00001078 2EA2[A901]              		mov	[CS:SettleSlow],AL
  4782 0000107C C3                      		retn
  4783                                  
  4784                                  ; Set time of last access, and reset default values in the DPT.
  4785                                  
  4786                                  DONE:
  4787 0000107D F745230100              		test	word [DI+BDS.flags],fNon_Removable
  4788 00001082 7525                    		jnz	short RETZ	; Do not set for non-removable Media
  4789 00001084 E8C601                  		call	SET_TIM		; set time of last access for drive
  4790                                  
  4791                                  ; Restore head settle and EOT values
  4792                                  
  4793                                  DiddleBack:
  4794 00001087 50                      		push	ax			; preserve AX
  4795 00001088 8CDA                    		mov	DX,DS			; save DS in DX
  4796 0000108A 2EA0[A801]              		mov	AL,[cs:SettleCurrent]	; get value in registers
  4797 0000108E 2E8A26[A701]            		mov	AH,[cs:MotorStartup]
  4798 00001093 2EC536[AE01]            		lds	SI,[CS:DPT]		; get pointer to DPT
  4799 00001098 C6440409                		mov	byte [SI+DISK_PARMS.DISK_EOT],9 ; save values in DPT
  4800 0000109C 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  4801 0000109F C6440302                		mov	byte [SI+DISK_PARMS.DISK_SECTOR_SIZ],2
  4802 000010A3 88640A                  		mov	[SI+DISK_PARMS.DISK_MOTOR_STRT],AH
  4803 000010A6 8EDA                    		mov	DS,DX			; restore DS
  4804 000010A8 58                      		pop	ax			; restore AX
  4805                                  RETZ:
  4806 000010A9 C3                      		retn
  4807                                  
  4808                                  ;
  4809                                  ; Block reads or writes the number of sectors specified in AX
  4810                                  ; handling track boundaries. For example, on an 8 sector per track
  4811                                  ; disk there might be a request to read 6 sectors starting at the 5th
  4812                                  ; sector. Block breaks this request into a read of sectors 5-8 on
  4813                                  ; the first track and a read of sectors 1-2 on the next track. Disk is
  4814                                  ; called to do the actual read.
  4815                                  ;
  4816                                  ;   Inputs:
  4817                                  ;	AX - number of sectors to be read
  4818                                  ;	DS:DI points to BDS for disk drive
  4819                                  ;	cs:CurSec - sector on track where read should start
  4820                                  ;	cs:CurTrk - track where read should start
  4821                                  ;	cs:CurHd - head for read
  4822                                  ;	ES:BX - transfer address
  4823                                  ; AX, CX, and BL are not preserved
  4824                                  ;
  4825                                  
  4826                                  BLOCK:
  4827 000010AA 09C0                    		or	AX,AX		; see if any sectors to read
  4828 000010AC 74FB                    		jz	short RETZ	; if not, return
  4829                                  ;;Rev 3.30 Modification -----------------------------------------
  4830                                  ; Fixed disk will not be restricted to the trk-by-trk basis.
  4831 000010AE F745230100              		test	word [DI+BDS.flags],fNon_Removable
  4832 000010B3 7406                    		jz	short BLOCK_FLOPPY
  4833 000010B5 E82600                  		call	DISK
  4834 000010B8 31C0                    		xor	ax,ax
  4835 000010BA C3                      		RETN
  4836                                  BLOCK_FLOPPY:
  4837                                  ;;End of Modification -----------------------------------------
  4838                                  ;
  4839                                  ; READ AT MOST 1 TRACK WORTH.  PERFORM MINIMIZATION AT SECTOR / TRACK
  4840                                  ;
  4841 000010BB 8A4D13                  		mov	CL,[DI+BDS.secpertrack] ; get sectors per track
  4842 000010BE FEC1                    		inc	CL
  4843 000010C0 2E2A0E[B201]            		sub	CL,[CS:CURSEC]	; set CX to number of sector after current
  4844 000010C5 30ED                    		xor	CH,CH		;    sector on the current track
  4845 000010C7 39C8                    		cmp	AX,CX		; is all of request on current track?
  4846 000010C9 7302                    		jae	short GotMin	; no, jump down
  4847 000010CB 89C1                    		mov	CX,AX	; yes, set number of sector on this track to AX
  4848                                  GotMin:
  4849                                  				; now
  4850                                  				; AX is the requested number of sectors to read
  4851                                  				; CX is the number that we can do on this track
  4852 000010CD 50                      		push	AX
  4853 000010CE 51                      		push	CX
  4854 000010CF 89C8                    		mov	AX,CX	; AL is number of sectors to read
  4855 000010D1 E80A00                  		call	DISK
  4856 000010D4 59                      		pop	CX
  4857 000010D5 58                      		pop	AX
  4858                                  
  4859                                  				; CX is the number of sectors just transferred
  4860 000010D6 29C8                    		sub	AX,CX	; reduce sectors-remaining by last I/O
  4861 000010D8 D0E1                    		shl	CL,1
  4862 000010DA 00CF                    		add	BH,CL	; adjust transfer address
  4863 000010DC EBCC                    		jmp	short BLOCK ; jump to do any remaining sectors
  4864                                  
  4865                                  ; 27/05/2018 - Retro DOS v3.0
  4866                                  ;
  4867                                  ;  DISK:
  4868                                  ; Disk is called to read or write one or more sectors on a track.
  4869                                  ; Retries are make if an error occurs.
  4870                                  ;
  4871                                  ;    Input:
  4872                                  ;	AL - number of sector to be read/written (they must all be on one track)
  4873                                  ;	DS:DI points to BDS for the drive
  4874                                  ;	ES:BX is transfer address (must not cross 64k physical boundry)
  4875                                  ;	[RFLAG] is 2 for read and 3 for write
  4876                                  ;	[VERIFY] is 0 for normal, 1 for verify after write
  4877                                  ;	[CurTrk] is track (cylinder) to be read/written.
  4878                                  ;	[CurHd] is head to be used in operation.
  4879                                  ;	[CurSec] is sector to start read on.
  4880                                  ;
  4881                                  ; The following are overwritten: BP,
  4882                                  ;   Output:
  4883                                  ;	[SECCNT] is decrement by the number of sectors read or written
  4884                                  
  4885                                  DISK:
  4886 000010DE BD0500                  		mov	BP,MAXERR	; set up retry count
  4887                                  		; 21/07/2019 - Retro DOS v3.2
  4888 000010E1 F6452301                		test	byte [di+BDS.flags],fNon_Removable ; Is this a fixed disk?
  4889 000010E5 7408                    		jz	short GetRdWrInd
  4890 000010E7 80FC04                  		cmp	ah,ROMVerify	; Is this a track verify?
  4891 000010EA 7403                    		je	short GetRdWrInd
  4892 000010EC BD0200                  		mov	bp,MAX_HD_FMT_ERR ; 2 ; This is verify so only 1 retry
  4893                                  GetRdWrInd:
  4894 000010EF 2E892E[AC05]            		mov	[cs:vretry_cnt],bp ;verify op. retry cnt for write-verify.
  4895 000010F4 2E892E[AE05]            		mov	[cs:soft_ecc_cnt],bp ;soft ecc error retry count.
  4896                                  
  4897 000010F9 2E8A26[A201]            		MOV	AH,[CS:RFLAG]	;GET READ/WRITE INDICATOR
  4898                                  RETRY:
  4899                                  				; AX is overwritten in int 13 call, so
  4900                                  				; to do a retry we need to save the
  4901                                  				; value by pushing on the stack
  4902 000010FE 50                      		push	AX
  4903                                  				; the next five lines of code put the
  4904                                  				; sector number in bit 5-0 of CL and the
  4905                                  				; cylinder number in CH and bits 7-6 of
  4906                                  				; CL. The register must be set up in this
  4907                                  				; way for the bios.
  4908                                  		; 28/07/2019
  4909                                  		;mov	DX,[CS:CURTRK] ;Load current cylinder
  4910 000010FF 2E8B0E[B401]            		mov	cx,[cs:CURTRK]
  4911                                  		; 15/07/2019
  4912                                  ;;Rev 3.30 Modification -----------------------------------------
  4913 00001104 F745230100              		test	word [DI+BDS.flags],fNon_Removable ;Fixed disk
  4914 00001109 7409                    		jz	short DISK_NOT_MINI 	;no, skip this.
  4915 0000110B 807D4701                		cmp	byte [DI+BDS.bdsm_ismini],1
  4916                                  		;cmp	word [DI+BDS.bdsm_ismini],1 ;Is this a mini disk?
  4917 0000110F 7503                    		jnz	short DISK_NOT_MINI	;No. continue to next.
  4918                                  		;add	dx,[DI+BDS.bdsm_hidden_trks] ;else add hidden trks.
  4919                                  		; 28/07/2019
  4920 00001111 034D49                  		add	cx,[DI+BDS.bdsm_hidden_trks]
  4921                                  DISK_NOT_MINI:
  4922                                  ;;End of Modification -----------------------------------------
  4923                                  		;ror	DH,1 ; get high two bits of cylinder in correct place
  4924                                  		;ror	DH,1
  4925 00001114 D0CD                    		ror	ch,1
  4926 00001116 D0CD                    		ror	ch,1
  4927                                  
  4928                                  		;or	DH,[cs:CURSEC] ; get sector value
  4929                                  		;mov	CX,DX ; put cylinder/sector values in correct register
  4930                                  				; get head value
  4931 00001118 2E0A2E[B201]            		or	ch,[cs:CURSEC]
  4932                                  
  4933 0000111D 86E9                    		xchg	CH,CL	; put bytes in correct place
  4934 0000111F 2E8A36[B301]            		mov	DH,[CS:CURHD]
  4935                                  				; get drive number
  4936 00001124 8A5504                  		mov	DL,[DI+BDS.drivenum]
  4937                                  
  4938 00001127 807D2205                		CMP	BYTE [DI+BDS.formfactor],ffHardFile
  4939 0000112B 7414                    		JZ	short DO_Fast ; HARD FILES USE FAST SPEED
  4940                                  ;
  4941                                  ; The registers are now all set up for call on rom-bios.
  4942                                  ; The next dozen or so line determines whether we call Do_Fast or Do_Norm
  4943                                  ; for the actual I/O read. Do_Fast calls FastSpeed for the actual I/O.
  4944                                  ; Do_Norm calls NormSpeed. NormSpeed changes the value for the head settle
  4945                                  ; time in the disk parameter table to a larger value and then calls FastSpeed
  4946                                  ; to do the I/O.  So Do_Fast just has a shorter head settle time.
  4947                                  ;
  4948 0000112D 2E803E[1101]FF          		CMP	byte [CS:STEP_DRV],-1
  4949                                  		;jz	short Do_Writej
  4950 00001133 7459                    		jz	short DO_WRITE ; 14/06/2018
  4951                                  
  4952 00001135 80FC02                  		cmp	AH,ROMRead	; For read...
  4953 00001138 7407                    		je	short DO_Fast	;   ... alway use fast
  4954                                  
  4955 0000113A 80FC04                  		cmp	AH,ROMVerify	; For verify...
  4956 0000113D 7402                    		je	short DO_Fast	;   ... alway use fast
  4957                                  Do_Writej:
  4958 0000113F EB4D                    		jmp	short DO_WRITE	; Jump down for write...
  4959                                  DO_Fast:
  4960 00001141 E8E400                  		CALL	FASTSPEED	; do I/O carry set if error
  4961                                  TestErr:
  4962 00001144 727D                    		jc	short DSKERR	; error -- get out
  4963                                  ; SET DRIVE AND TRACK OF LAST ACCESS
  4964 00001146 2E8816[1101]            		mov	[CS:STEP_DRV],DL ; save the last drive accessed
  4965 0000114B 886D46                  		mov	[DI+BDS.track],CH ; save in BDS
  4966                                  NO_SET:
  4967 0000114E 2E813E[A201]0301        		cmp	word [CS:WRTVERIFY],103H ; Check for write and verify
  4968 00001155 7448                    		jz	short DOVERIFY	; yes -- go do verify
  4969                                  NOVERIFY:
  4970 00001157 58                      		pop	AX		; pop command and num sec. from stack
  4971                                  
  4972 00001158 80E13F                  		and	CL,03Fh		; Eliminate cylinder bits from sector
  4973 0000115B 30E4                    		xor	AH,AH
  4974 0000115D 2E2906[A401]            		sub	[CS:SECCNT],AX	; Reduce count of sectors to go
  4975 00001162 00C1                    		add	CL,AL		; Next sector
  4976 00001164 2E880E[B201]            		mov	[CS:CURSEC],CL
  4977                                  					 ; See if sector/track limit reached
  4978 00001169 3A4D13                  		cmp	CL,[DI+BDS.secpertrack]
  4979 0000116C 761E                    		jbe	short Disk_Ret	; yes, return
  4980                                  NextTrack:
  4981 0000116E 2EC606[B201]01          		mov	byte [CS:CURSEC],1 ; Start with first sector of next track
  4982 00001174 2E8A36[B301]            		mov	DH,[CS:CURHD]
  4983 00001179 FEC6                    		inc	DH		; go to next head
  4984 0000117B 3A7515                  		cmp	DH,[DI+BDS.heads] ; at head limit?
  4985 0000117E 7207                    		jb	short NOXOR	; no, jump down
  4986 00001180 30F6                    		xor	DH,DH		; at head limit, reset to head zero ...
  4987 00001182 2EFF06[B401]            		inc	word [CS:CURTRK] ; 	and go to next head
  4988                                  NOXOR:
  4989 00001187 2E8836[B301]            		mov	[CS:CURHD],DH	; save new head number
  4990                                  Disk_Ret:
  4991 0000118C F8                      		clc			; successful return so clear error flag
  4992 0000118D C3                      		retn			; all done
  4993                                  ;
  4994                                  ; The request is for write. Determine if we are talking about the same
  4995                                  ; track and drive. If so, use the fast speed.
  4996                                  ;
  4997                                  DO_WRITE:
  4998 0000118E 2E3A16[1101]            		cmp	DL,[CS:STEP_DRV] ; same drive?
  4999 00001193 7505                    		jnz	short DO_Norm 	 ; no, do normal speed
  5000 00001195 3A6D46                  		cmp	CH,[DI+BDS.track] ; same track on drive
  5001 00001198 74A7                    		jz	short DO_Fast	; yes, do fast speed
  5002                                  DO_Norm:
  5003 0000119A E86C00                  		call	NORMSPEED	; use larger head settle time
  5004 0000119D EBA5                    		jmp	SHORT TestErr	; test for error
  5005                                  ;
  5006                                  ; we have a verify request also. Get state info and go verify
  5007                                  ;
  5008                                  DOVERIFY:
  5009 0000119F 58                      		pop	AX		; get number of sectors from stack
  5010 000011A0 50                      		push	AX		;    in non-detructive fashion
  5011 000011A1 B404                    		MOV	AH,ROMVerify	; REQUEST VERIFY
  5012 000011A3 E88200                  		CALL	FASTSPEED	; MZ  2.21 change settle mode
  5013 000011A6 73AF                    		JNC	short NOVERIFY
  5014                                  
  5015                                  		; 21/07/2019
  5016                                  
  5017                                  ; check the error returned in ah to see if it is a soft ecc error.
  5018                                  ; if it is not we needn't do anything special. if it is a soft
  5019                                  ; ecc error then decrement the soft_ecc_cnt error retry count. if
  5020                                  ; this retry count becomes 0 then we just ignore the error and go to
  5021                                  ; no_verify but if we can still try then we call the routine to reset
  5022                                  ; the disk and go to dskerr1 to retry the operation.
  5023                                  
  5024 000011A8 80FC11                  		cmp	ah,11h		;soft ecc error ?
  5025 000011AB 750C                    		jne	short not_softecc_err
  5026 000011AD 2EFF0E[AE05]            		dec	word [cs:soft_ecc_cnt]
  5027 000011B2 74A3                    		jz	short NOVERIFY	;no more retry
  5028                                  
  5029 000011B4 E87606                  		call	ResetDisk	;reset disk
  5030 000011B7 EB31                    		jmp	short DSKERR1	;retry
  5031                                  
  5032                                  not_softecc_err:			;other error.
  5033 000011B9 E87106                  		call	ResetDisk
  5034 000011BC 2EFF0E[AC05]            		dec	word [cs:vretry_cnt]
  5035 000011C1 EB0E                    		jmp	short dskerr0
  5036                                  
  5037                                  ; Need to special case the change-line error AH=06h. If we get this, we
  5038                                  ; need to return it.
  5039                                  
  5040                                  		; 17/07/2019 - Retro DOS v3.2
  5041                                  		; (MSDOS 3.3)		
  5042                                  
  5043                                  ;	;----------------------------------------|
  5044                                  ;	; Warning: Do not change the following. ;|
  5045                                  ;	;	   It gets patched in msinit	;|
  5046                                  ;DSKERR:					;|
  5047                                  ;		CALL	CheckIO 		;|
  5048                                  ;	;---------------------------------------;|
  5049                                  
  5050                                  		; 17/07/2019 - Retro DOS v3.2
  5051                                  		; (MSDOS 6.0)
  5052                                  DSKERR:
  5053 000011C3 2E803E[1201]00          		cmp	byte [cs:fHave96],0 ; do we have changeline support?
  5054 000011C9 7403                    		je	short dskerr_nochangeline ; brif not
  5055                                  		
  5056 000011CB E8350A                  		call	CheckIO
  5057                                  dskerr_nochangeline:
  5058 000011CE E85706                  		Call	AGAIN	; reset the disk and decrement retry cnt
  5059                                  dskerr0:
  5060 000011D1 7420                    		jz	short HARDERR ; if z flag set, did all retries-give up
  5061                                  
  5062                                  		; 21/07/2019
  5063 000011D3 F6452301                		test	byte [di+BDS.flags],fNon_Removable
  5064 000011D7 7505                    		jnz	short skip_timeout_chk
  5065                                  
  5066 000011D9 80FC80                  		cmp	AH,80H		; timeout?
  5067 000011DC 7415                    		je	short HARDERR ; yes, jump to hard error
  5068                                  skip_timeout_chk:
  5069 000011DE 80FCCC                  		cmp	ah,0CCh 	;write fault error?
  5070 000011E1 740B                    		je	short write_fault_err ; then, don't retry.
  5071 000011E3 2EC706[AE05]0500        		mov	word [cs:soft_ecc_cnt],MAXERR ; 5
  5072                                  					;set soft_ecc_cnt back to maxerr
  5073                                  DSKERR1:
  5074 000011EA 58                      		pop	AX		; Restore sector count
  5075 000011EB E910FF                  		jmp	RETRY		;  and try again
  5076                                  
  5077                                  		; 21/07/2019
  5078                                  write_fault_err:
  5079 000011EE BD0100                  		mov	bp,1		;just retry only once for write fault error.
  5080 000011F1 EBF7                    		jmp	short DSKERR1
  5081                                  HARDERR:
  5082 000011F3 E83F00                  		CALL	MAPERROR
  5083                                  HARDERR2:			; for routines that call MapError themselves
  5084 000011F6 2EC606[9F01]FF          		mov	byte [CS:TIM_DRV],-1 ;Force a media check through ROM
  5085 000011FC 2E8B0E[A401]            		mov	CX,[CS:SECCNT]	;Get count of sectors to go
  5086 00001201 2E8B26[B601]            		mov	SP,[CS:SPSAV]	;Recover entry stack pointer
  5087                                  ;
  5088                                  ; Since we are performing a non-local goto, restore the disk parameters
  5089                                  ;
  5090                                  MedByt_OK:
  5091                                  		;call	DiddleBack
  5092                                  		;retn			;and return
  5093                                  		; 21/07/2019
  5094 00001206 E97EFE                  		jmp	DiddleBack
  5095                                  ;
  5096                                  ; change settle value from SettleCurrent to whatever is appropriate
  5097                                  ;
  5098                                  NORMSPEED:
  5099 00001209 1E                      		push	DS		; save two registers
  5100 0000120A 50                      		push	AX
  5101                                  				; change value in current disk parm tbl
  5102 0000120B 2EA0[A901]              		mov	AL,[CS:SettleSlow] 
  5103 0000120F 2EC536[AE01]            		lds	SI,[CS:DPT]	; current disk parm table
  5104 00001214 884409                  		mov	[SI+DISK_PARMS.DISK_HEAD_STTL],AL
  5105 00001217 58                      		pop	AX		; restore command and sector count
  5106 00001218 1F                      		pop	DS
  5107 00001219 E80C00                  		call	FASTSPEED	; do I/0
  5108 0000121C 1E                      		push	DS	; restore the value in disk parm table
  5109 0000121D 2EC536[AE01]            		lds	SI,[CS:DPT]
  5110 00001222 C6440901                		mov	byte [SI+DISK_PARMS.DISK_HEAD_STTL],1 ; 1 is fast settle
  5111 00001226 1F                      		pop	DS
  5112 00001227 C3                      		retn
  5113                                  
  5114                                  FASTSPEED:
  5115                                  ;
  5116                                  ; If the drive has been marked as too big (i.e. starting sector of the
  5117                                  ; partition is > 16 bits, then ALWAYS return drive not ready.
  5118                                  ;
  5119 00001228 F6451F80                		TEST	BYTE [DI+BDS.fatsiz],fTOOBIG
  5120 0000122C 7503                    		JNZ	short NotReady
  5121                                  
  5122 0000122E CD13                    		int	13h		; call rom-bios disk routines
  5123                                  ;Death:
  5124 00001230 C3                      		retn
  5125                                  NotReady:
  5126 00001231 F9                      		stc			; set carry to indicate error
  5127 00001232 B480                    		mov	AH,80h		; put error code in AH
  5128                                  		;jmp	short Death	; jump to ret
  5129                                  		; 21/07/2019
  5130 00001234 C3                      		retn
  5131                                  
  5132                                  ;
  5133                                  ; Map error returned by ROM into corresponding code to be returned to
  5134                                  ; DOS in AL.
  5135                                  ;
  5136                                  MAPERROR:
  5137 00001235 51                      		push	CX		; save cx
  5138                                  		;push	es ; 21/07/2019
  5139 00001236 0E                      		push	CS
  5140 00001237 07                      		pop	ES		; make ES the local segment
  5141 00001238 88E0                    		mov	AL,AH		; move error code into AL
  5142 0000123A 2EA2[C501]              		mov	[CS:LSTERR],AL	; terminate list with error code
  5143 0000123E B90900                  		mov	CX,NUMERR	; number of possible error conditions
  5144 00001241 BF[BD01]                		mov	DI,ERRIN	; point to error conditions
  5145 00001244 F2AE                    		repne	SCASB
  5146 00001246 2E8A4508                		mov	AL,[CS:DI+NUMERR-1] ; get translation
  5147                                  		;pop	es ; 21/07/2019
  5148 0000124A 59                      		pop	cx		; restore cx
  5149 0000124B F9                      		stc			; flag error condition
  5150 0000124C C3                      		retn
  5151                                  
  5152                                  ;
  5153                                  ; Set the time of last access for this drive. This is done only for removable
  5154                                  ; media.
  5155                                  ;
  5156                                  SET_TIM:
  5157 0000124D 50                      		push	ax
  5158 0000124E 30E4                    		xor	AH,AH		; set command to get time
  5159 00001250 CD1A                    		int	1Ah		; call rom-bios timer function
  5160 00001252 08C0                    		or	AL,AL		; is there 24 hour rollover?
  5161 00001254 7405                    		jz	short NOROLL3 	; no, skip down
  5162 00001256 2EFF06[7205]            		inc	word [CS:DAYCNT] ; yes, then increment DayCnt
  5163                                  NOROLL3:
  5164                                  ; We have the new time. If we see that the time has passed, then we reset
  5165                                  ; the threshold counter...
  5166 0000125B 3B5547                  		cmp	DX,[DI+BDS.tim_lo] ; Did any time pass?
  5167 0000125E 7505                    		jnz	short SetAccess	; yes, update access time
  5168 00001260 3B4D49                  		cmp	CX,[DI+BDS.tim_hi] ; now look at the high bits
  5169 00001263 740C                    		jz	short Done_Set	; if equal then no time passed
  5170                                  SetAccess:				; we get here if some time has passed
  5171                                  					; zero AccessCount to show time passage
  5172 00001265 2EC606[9E01]00          		mov	byte [CS:AccessCount],0
  5173 0000126B 895547                  		MOV	[DI+BDS.tim_lo],DX ; save low time bits
  5174 0000126E 894D49                  		MOV	[DI+BDS.tim_hi],CX ; save high time bit
  5175                                  Done_Set:
  5176 00001271 F8                      		clc			; indicate no error
  5177 00001272 58                      		pop	ax		; restore AX register
  5178 00001273 C3                      		retn
  5179                                  
  5180                                  ; 19/07/2019 - Retro DOS v3.2
  5181                                  ;-----------------------------------------------------------------------------
  5182                                  ; 29/06/52019 - Retro DOS v3.1
  5183                                  
  5184                                  ;************************************************************************
  5185                                  ;*									*
  5186                                  ;*	block13 - our int13 hooker					*
  5187                                  ;*									*
  5188                                  ;************************************************************************
  5189                                  
  5190                                  ; 28/05/2018 - Retro DOS v3.0
  5191                                  
  5192                                  ; This is the true DISK INT handler. We parse the request to see if there is
  5193                                  ; a DMA violation. If so, depending on the function, we:
  5194                                  ;   READ/WRITE	Break the request into three pieces and move the middle one
  5195                                  ;	into our internal buffer.
  5196                                  ;   FORMAT	Copy the format table into the buffer
  5197                                  ;   VERIFY	Point the transfer address into the buffer
  5198                                  ;
  5199                                  ; This is the biggest bogosity of all. The IBM controller does NOT handle
  5200                                  ; operations that cross physical 64K boundaries. In these cases, we copy
  5201                                  ; the offending sector into the buffer below and do the I/O from there.
  5202                                  
  5203                                  ; 17/07/2019
  5204                                  
  5205                                  ;;Rev 3.30 Modification -----------------------------------------
  5206                                  ;To handle the INT 13h, AH = 8 Problem.
  5207                                  ;Save Registers here.
  5208                                  ;Save_AX:   DW  0
  5209                                  ;Save_BX:   DW  0
  5210                                  ;Save_CX:   DW  0
  5211                                  ;Save_DX:   DW  0
  5212                                  ;Save_DI:   DW  0
  5213                                  ;Save_SI:   DW  0
  5214                                  ;Save_BP:   DW  0
  5215                                  ;Save_DS:   DW  0
  5216                                  ;Save_ES:   DW  0
  5217                                  ;Prev_DX:   DW  0
  5218                                  ;Save_Flag: DW  0
  5219                                  ;;End of Modification -----------------------------------------
  5220                                  
  5221                                  ;
  5222                                  ; Block13:
  5223                                  ;
  5224                                  ;   Entry conditions:
  5225                                  ;	AH = function
  5226                                  ;	AL = number of sectors
  5227                                  ;	ES:BX = DMA address
  5228                                  ;	CX = packed track and sector
  5229                                  ;	DX = head and drive
  5230                                  ;   Output conditions:
  5231                                  ;	NO DMA violation.
  5232                                  ;
  5233                                  
  5234                                  Block13:
  5235                                  ;
  5236                                  ; Let the operation proceed. If there is a DMA violation, then we do things.
  5237                                  ;
  5238 00001274 2EA3[B800]              		mov	[cs:PrevOper],AX	; save request
  5239 00001278 9C                      		pushf				; preserve the flags
  5240 00001279 80FC05                  		cmp	AH,ROMFormat		; format request?
  5241 0000127C 7510                    		jnz	short Not_Format	;   no, skip down
  5242                                  
  5243                                  		; 17/07/2019 - Retro DOS v3.2
  5244                                  		; (MSDOS 3.3)
  5245                                  
  5246                                  ;	; Set changed by format bit for all logical drives using this physical drive
  5247                                  ;		;---------------------------------------------------------|
  5248                                  ;		; Warning: Do Not Change the following. 		  |
  5249                                  ;		; It gets patched in at INIT time			  |
  5250                                  ;Changed_Patch:								  |
  5251                                  ;		mov	word [cs:FlagBits],fChanged_By_Format+fChanged	  |
  5252                                  ;		call	Set_Changed_DL	; Indicate that media changed by format
  5253                                  ;		;							  |
  5254                                  ;		;---------------------------------------------------------|
  5255                                  
  5256                                  		; 17/07/2019 - Retro DOS v3.2
  5257                                  		; (MSDOS 6.0)
  5258                                  
  5259                                  ;	we know we're doing a format command. if we have changeline
  5260                                  ;	  support, then flag some special changed stuff and set changed
  5261                                  ;	  by format bit for all logical drives using this physical drive
  5262                                  
  5263                                  format_special_stuff:
  5264 0000127E 2E803E[1201]00          		cmp	byte [cs:fHave96],0 ; do we have changeline support?
  5265 00001284 7408                    		jz	short format_special_stuff_done ; brif not
  5266                                  		
  5267                                  		;mov	word [cs:FlagBits],fChanged_By_Format+fChanged
  5268 00001286 53                      		push	bx
  5269 00001287 BB4001                  		mov	bx,fChanged_By_Format+fChanged	; mov bx,140h
  5270 0000128A E8F609                  		call	Set_Changed_DL	; Indicate that media changed by format
  5271 0000128D 5B                      		pop	bx
  5272                                  
  5273                                  format_special_stuff_done:
  5274                                  
  5275                                  Not_Format:
  5276                                  		; 17/07/2019 - Retro DOS v3.2
  5277                                  		; (MSDOS 3.3)
  5278                                  
  5279                                  ;;Rev 3.30 Modification -----------------------------------------
  5280                                  ;		cmp	ah,8			; Read Driver Parm ?
  5281                                  ;		je	short Bus_Problem
  5282                                  ;		cmp	ah,15h
  5283                                  ;		je	short Bus_Problem
  5284                                  ;		CALL	far [CS:ORIG13]		; SIMULATE INT 13
  5285                                  ;		;JC	short GOTERR13_br	; ERROR?
  5286                                  ;chk_ah_8_err:		
  5287                                  ;		jc	short GotErr13 ; 17/07/2019
  5288                                  ;		;14/06/2018
  5289                                  ;		RETF	2			; NO, RETURN AND CLEAR FLAGS
  5290                                  
  5291                                  ;GOTERR13_br: 
  5292                                  ;		jmp	GotErr13
  5293                                  
  5294                                  ;;Some machines have a problem with Int 13h function=8
  5295                                  ;;This function does not reset the common buses after the execution.
  5296                                  ;;To solve this problem, when we detect AH=8h, then we will save the result
  5297                                  ;;and will issue AH=1 (Read Status) call to reset the buses.
  5298                                  ;
  5299                                  ;Bus_Problem:
  5300                                  ;		mov	[cs:Prev_DX],DX		;save original drive number
  5301                                  ;		call	far [CS:ORIG13]		;Do "Read drive parm"
  5302                                  ;
  5303                                  ;		mov	[cs:Save_AX],AX		;Save registers,flag
  5304                                  ;		mov	[cs:Save_BX],BX
  5305                                  ;		mov	[cs:Save_CX],CX
  5306                                  ;		mov	[cs:Save_DX],DX
  5307                                  ;		mov	[cs:Save_DI],DI
  5308                                  ;		mov	[cs:Save_SI],SI
  5309                                  ;		mov	[cs:Save_BP],BP
  5310                                  ;		mov	[cs:Save_DS],DS
  5311                                  ;		mov	[cs:Save_ES],ES
  5312                                  ;		pushf
  5313                                  ;		pop	word [cs:Save_Flag]
  5314                                  ;
  5315                                  ;		mov	dx,[cs:Prev_DX]		;restore original drive
  5316                                  ;		pushf
  5317                                  ;		mov	ah,1			;Read Status.
  5318                                  ;		call	far [CS:ORIG13]		;Reset the bus as a side effect
  5319                                  ;
  5320                                  ;		mov	AX,[cs:Save_AX]		;restore registers,flag
  5321                                  ;		mov	BX,[cs:Save_BX]
  5322                                  ;		mov	CX,[cs:Save_CX]
  5323                                  ;		mov	DX,[cs:Save_DX]
  5324                                  ;		mov	DI,[cs:Save_DI]
  5325                                  ;		mov	SI,[cs:Save_SI]
  5326                                  ;		mov	BP,[cs:Save_BP]
  5327                                  ;		mov	DS,[cs:Save_DS]
  5328                                  ;		mov	ES,[cs:Save_ES]
  5329                                  ;		push	word [cs:Save_Flag]
  5330                                  ;		popf
  5331                                  ;		;jc	short GotErr13		;AH=8 had been an error?
  5332                                  ;		;14/06/2018
  5333                                  ;		;retf	2
  5334                                  ;		; 17/07/2019
  5335                                  ;		jmp	short chk_ah_8_err	
  5336                                  
  5337                                  		; 17/07/2019 - Retro DOS v3.2
  5338                                  		; (MSDOS 6.0)
  5339                                  
  5340 0000128E 2EFF1E[B806]            		call	far [CS:ORIG13]
  5341                                  
  5342 00001293 9C                      		pushf	; *			; save result flags
  5343 00001294 2E803E[B506]FA          		cmp	byte [cs:MODEL_BYTE],0FAh ; mdl_ps2_30
  5344                                  						; is this a ps2/30?
  5345 0000129A 7406                    		je	short ps2_special_stuff	;  exit mainline to address special
  5346                                  ps2_special_stuff_done:			;   ps2/30 problem if so
  5347 0000129C 9D                      		popf	; *
  5348                                  
  5349 0000129D 721F                    		jc	short GotErr13	; error on original orig13 call-thru?
  5350                                  ret_from_i13:
  5351 0000129F CA0200                  		retf	2		; restore ds & iret w/flags		
  5352                                  		
  5353                                  
  5354                                  ; ps2_30 machine has some problem with ah=8h (read drive parm), int 13h.
  5355                                  ;this function does not reset the common buses after the execution.
  5356                                  ;to solve this problem, when we detect ah=8h, then we will save the result and
  5357                                  ;will issue ah=1 (read status) call to reset the buses.
  5358                                  
  5359                                  ps2_special_stuff:
  5360 000012A2 2E803E[B800]08          		cmp	byte [cs:PrevOper],8 ; read driver parm ?
  5361 000012A8 7408                    		jz	short ps2_30_problem
  5362 000012AA 2E803E[B800]15          		cmp	byte [cs:PrevOper],15h ; apparently function 15h fails, too
  5363 000012B0 75EA                    		jnz	short ps2_special_stuff_done
  5364                                  					; it isn't one of the problem functions
  5365                                  ps2_30_problem: 			; ps2_30 = ps2 model 30.
  5366 000012B2 50                      		push	ax		; preserve ax result from int13
  5367                                  		;21/07/2019	
  5368 000012B3 9C                      		pushf ; ** ; (this one is needed for iret from original INT 13h)
  5369 000012B4 B401                    		mov	ah,1		; read status call resets the bus
  5370 000012B6 2EFF1E[B806]            		call	far [CS:ORIG13]	; (Reset the bus as a side effect)
  5371 000012BB 58                      		pop	ax		; restore results of initial int13
  5372 000012BC EBDE                    		jmp	short ps2_special_stuff_done
  5373                                  		
  5374                                  ;
  5375                                  ; Some kind of error occurred. See if it is DMA violation
  5376                                  ;
  5377                                  GotErr13:
  5378 000012BE 9C                      		pushf
  5379 000012BF 80FC09                  		cmp	AH,09h			; is error DMA error code?
  5380                                  		;JNZ	short CHECK_ECC
  5381                                  		;JMP	short GotDMAErr
  5382 000012C2 7458                    		jz	short GotDMAErr ; 17/07/2019
  5383                                  CHECK_ECC:
  5384 000012C4 80FC11                  		CMP	AH,11h
  5385 000012C7 7404                    		JZ	short OK11
  5386 000012C9 9D                      		POPF
  5387                                  		;14/06/2018
  5388 000012CA CA0200                  		RETF	2
  5389                                  ;
  5390                                  ; We have an error status 11h. This indicates an ECC-corrected error. Note
  5391                                  ; that this indicates that the data is PROBABLY correct but not CERTAINLY
  5392                                  ; correct. The ROMs on PC-1s and PC_XTs have a 'bug' in that if an ECC error
  5393                                  ; occurs for a multi-sector read, only the sectors up to the one where the
  5394                                  ; error occurred are read in. We have no way of knowing how many were read in
  5395                                  ; this case, so we redo the operation, reading one sector at a time. If we
  5396                                  ; get an ECC error on reading one sector, we ignore the error because the
  5397                                  ; sector has been read in.
  5398                                  ;
  5399                                  
  5400                                  OK11:
  5401                                  ;		popf			; restore flags
  5402                                  ;;Rev 3.30 Modification -----------------------------------------
  5403                                  ; Here, it is better reset the system. So, we are going to
  5404                                  ; call Orig13 again
  5405 000012CD B400                    		mov	ah,0
  5406 000012CF 2EFF1E[B806]            		call	far [CS:ORIG13]	;reset. Don't care about result
  5407                                  ;;End of Modification -----------------------------------------
  5408                                  
  5409 000012D4 2EA1[B800]              		mov	ax,[cs:PrevOper] ; Retrieve request
  5410                                  ;
  5411                                  ; This will provide a termination point.
  5412                                  ;
  5413 000012D8 3C01                    		cmp	AL,1		; If request for one sector, assume OK
  5414 000012DA 7505                    		jnz	short ECC_Err_Handle ; more than one sector -- jump down
  5415 000012DC 30E4                    		xor	AH,AH		; clear carry too!
  5416                                  		;14/06/2018
  5417 000012DE CA0200                  		retf	2
  5418                                  
  5419                                  ECC_Err_Handle:
  5420 000012E1 53                      		push	bx
  5421 000012E2 51                      		push	cx
  5422 000012E3 52                      		push	dx
  5423 000012E4 2EA2[BA00]              		mov	[cs:Number_Of_Sec],AL
  5424                                  Loop_ECC:
  5425 000012E8 2EA1[B800]              		mov	AX,[CS:PrevOper] ; set command to previous command
  5426 000012EC B001                    		mov	AL,1		 ;     but request only one sector
  5427                                  ;
  5428                                  ; we do reads one sector at a time. this ensures that we will eventually
  5429                                  ; finish the request since ecc errors on 1 sector do read in that sector.
  5430                                  ;
  5431                                  ; we need  some "intelligence" in the ecc handler to handle reads
  5432                                  ; that attempt to read more sectors than are available on a particular
  5433                                  ; track.
  5434                                  ; we call check_wrap to set up the sector #, head # and cylinder # for
  5435                                  ; this request.
  5436                                  ; at this point, all registers are set up for the call to orig13, except
  5437                                  ; that there maybe a starting sector number that is bigger than the number
  5438                                  ; of sectors on a track.
  5439                                  ;
  5440 000012EE E83206                  		CALL	Check_Wrap	; see if wrapping around cylinder
  5441                                  
  5442 000012F1 9C                      		pushf			; save flags
  5443 000012F2 2EFF1E[B806]            		call	far [CS:ORIG13]	; call original rom-bios code
  5444                                  ;;Rev 3.30 Modification ------------------------------------------------------
  5445 000012F7 730D                    		JNC	short OK11_Op
  5446 000012F9 80FC11                  		CMP	AH,11h		; ONLY ALLOW ECC ERRORS
  5447 000012FC 7517                    		JNZ	short OK11_EXIT_err ; Other error?
  5448 000012FE B400                    		mov	ah,0		; ECC error. Reset it again.
  5449 00001300 9C                      		pushf
  5450 00001301 2EFF1E[B806]            		call	far [CS:ORIG13]
  5451                                  OK11_Op:
  5452                                  					; adjust number of sectors for one read
  5453 00001306 2EFE0E[BA00]            		dec	byte [CS:Number_Of_Sec]	
  5454 0000130B 7409                    		jz	short OK11_Exit	; all done?
  5455 0000130D FEC1                    		inc	CL		; advance sector number
  5456 0000130F FEC7                    		inc	BH		; add 200H to address
  5457 00001311 FEC7                    		inc	BH
  5458 00001313 EBD3                    		jmp	short Loop_ECC	; and around for reading another sector
  5459                                  
  5460                                  OK11_EXIT_err:
  5461 00001315 F9                      		stc			; Set carry bit again.
  5462                                  ;;End of Modification ------------------------------------------------------
  5463                                  
  5464                                  OK11_Exit:
  5465 00001316 5A                      		pop	dx
  5466 00001317 59                      		pop	cx
  5467 00001318 5B                      		pop	bx
  5468                                  		;14/06/2018
  5469 00001319 CA0200                  		retf	2
  5470                                  
  5471                                  ;
  5472                                  ; we truly have a DMA violation. Restore register AX and retry the
  5473                                  ; operation as best we can.
  5474                                  ;
  5475                                  GotDMAErr:
  5476 0000131C 58                      		pop	AX		; clean up stack
  5477 0000131D 2EA1[B800]              		mov	AX,[cs:PrevOper] ; restore command
  5478 00001321 FB                      		sti			; restore interrupts
  5479 00001322 80FC02                  		cmp	AH,ROMRead	; determine the command
  5480 00001325 7266                    		jb	short IntDone
  5481 00001327 80FC04                  		cmp	AH,ROMVerify
  5482 0000132A 7439                    		jz	short IntVerify
  5483 0000132C 80FC05                  		cmp	AH,ROMFormat
  5484 0000132F 7446                    		jz	short IntFormat
  5485 00001331 775A                    		ja	short IntDone
  5486                                  ;
  5487                                  ; We are doing a read/write call. Check for DMA problems
  5488                                  ;
  5489 00001333 52                      		push	dx		; save registers we overwrite
  5490 00001334 51                      		push	cx
  5491 00001335 53                      		push	bx
  5492 00001336 50                      		push	ax
  5493                                  
  5494 00001337 55                      		push	BP
  5495 00001338 89E5                    		mov	BP,SP
  5496 0000133A 8CC2                    		mov	DX,ES		; Check for 64k boundary error
  5497                                  
  5498 0000133C D1E2                    		shl	DX,1
  5499 0000133E D1E2                    		shl	DX,1
  5500 00001340 D1E2                    		shl	DX,1
  5501 00001342 D1E2                    		shl	DX,1		; Segment converted to absolute address
  5502                                  
  5503 00001344 01DA                    		add	DX,BX		; Combine with offset
  5504 00001346 81C2FF01                		add	DX,511		; simulate a transfer
  5505                                  ;
  5506                                  ; If carry is set, then we are within 512 bytes of the end of the segment.
  5507                                  ; We skip the first transfer and perform the remaining buffering and transfer
  5508                                  ;
  5509 0000134A 7306                    		JNC	short NO_SKIP_FIRST
  5510 0000134C 8A7609                  		mov	DH,[bp+INT13FRAME.olddx+1] ; set correct head number
  5511 0000134F E98A00                  		jmp	Buffer
  5512                                  		; 17/07/2019
  5513                                  		;jmp	Bufferx
  5514                                  
  5515                                  NO_SKIP_FIRST:
  5516                                  ;
  5517                                  ; DX is the physical 16 bits of start of transfer. Compute remaining
  5518                                  ; sectors in segment.
  5519                                  ;
  5520 00001352 D0EE                    		shr	DH,1		; DH = number of sectors before address
  5521 00001354 B480                    		mov	AH,128		; AH = max number of sectors in segment
  5522 00001356 28F4                    		sub	AH,DH
  5523                                  ;
  5524                                  ; AH is now the number of sectors that we can successfully write in this
  5525                                  ; segment. If this number is above or equal to the requested number, then we
  5526                                  ; continue the operation as normal. Otherwise, we break it into pieces.
  5527                                  ;
  5528 00001358 38C4                    		cmp	AH,AL		; can we fit it in?
  5529 0000135A 7236                    		jb	short DoBlock	; no, perform blocking.
  5530                                  ;
  5531                                  ; Yes, the request fits. Let it happen
  5532                                  ;
  5533 0000135C 8A7609                  		MOV	DH,[BP+INT13FRAME.olddx+1] ; SET UP HEAD NUMBER
  5534 0000135F E87406                  		call	DoINT
  5535 00001362 E9E100                  		jmp	Bad13
  5536                                  ;
  5537                                  ; Verify the given sectors. Place the buffer pointer into our space.
  5538                                  ;
  5539                                  IntVerify:
  5540 00001365 06                      		push	es
  5541 00001366 53                      		push	bx
  5542                                  
  5543 00001367 0E                      		push	CS
  5544 00001368 07                      		pop	ES
  5545                                  DoSimple:
  5546 00001369 BB[D001]                		mov	BX,DiskSector
  5547 0000136C 9C                      		pushf
  5548 0000136D 2EFF1E[B806]            		call	far [CS:ORIG13]
  5549 00001372 5B                      		pop	bx
  5550 00001373 07                      		pop	es
  5551                                  		;14/06/2018
  5552 00001374 CA0200                  		retf	2
  5553                                  
  5554                                  ;
  5555                                  ; Format operation. Copy the parameter table into memory
  5556                                  ;
  5557                                  IntFormat:
  5558 00001377 06                      		push	es
  5559 00001378 53                      		push	bx
  5560 00001379 56                      		push	si
  5561 0000137A 57                      		push	di
  5562 0000137B 1E                      		push	ds
  5563 0000137C 06                      		push	ES
  5564 0000137D 0E                      		push	CS
  5565 0000137E 07                      		pop	ES
  5566 0000137F 1F                      		pop	DS
  5567 00001380 89DE                    		mov	SI,BX
  5568 00001382 BF[D001]                		mov	DI,DiskSector
  5569 00001385 E84506                  		call	Move
  5570 00001388 1F                      		pop	ds
  5571 00001389 5F                      		pop	di
  5572 0000138A 5E                      		pop	si
  5573 0000138B EBDC                    		jmp	short DoSimple
  5574                                  ;
  5575                                  ; Inline continuation of operation
  5576                                  ;
  5577                                  IntDone:
  5578 0000138D 2EFF2E[B806]            		jmp	far [CS:ORIG13]
  5579                                  ;
  5580                                  ; We can't fit the request into the entire block. Perform the operation on
  5581                                  ; the first block.
  5582                                  ;
  5583                                  ;
  5584                                  ; DoBlock is modified to correctly handle multi-sector disk I/O. 
  5585                                  ; Old DoBlock had added the number of sectors I/Oed (AH in Old DoBlock) after
  5586                                  ; the DoInt call to CL. Observing only the lower 6 bits of CL(=max. 64) can
  5587                                  ; represent a starting sector, if AH was big, then CL would be clobbered.
  5588                                  ; By the way, we still are going to use CL for this purpose since Checkwrap
  5589                                  ; routine will use it as an input. To prevent CL from being clobbered, a 
  5590                                  ; safe number of sectors should be calculated like "63 - # of sectors/track".
  5591                                  ; DoBlock will handle the first block of requested sectors within the
  5592                                  ; boundary of this safe value.
  5593                                  
  5594                                  ;Try to get the # of sectors/track from BDS via Rom drive number.
  5595                                  ;For any mini disks installed, here we have to pray that they have the
  5596                                  ;same # of sector/track as the main DOS partition disk drive.
  5597                                  
  5598                                  DoBlock:
  5599                                  ;;Rev 3.30 Modification ------------------------------------------------------
  5600 00001392 8B5608                  		mov	dx,[bp+INT13FRAME.olddx] ;set head # ; 17/07/2019
  5601                                  		
  5602 00001395 57                      		push	di					
  5603 00001396 1E                      		push	ds					
  5604                                  
  5605                                  		; 17/07/2019 - Retro DOS v3.2
  5606                                  		;push	ax		;AH=# of sectors before DMA err
  5607                                  					;AL - User requested # of sectors
  5608                                  		;mov	byte [CS:PHYS_DRV],1				
  5609                                  		;mov	al,dl							
  5610                                  		;call	SETDRIVE	;get BDS pointer for this DISK. 
  5611                                  		;pop	ax
  5612                                  		;mov	byte [CS:PHYS_DRV],0
  5613                                  
  5614 00001397 E8EFF7                  		call	find_bds ; 17/07/2019
  5615                                  				
  5616 0000139A F745230100              		test	word [DI+BDS.flags],fNon_Removable ;don't have to worry
  5617 0000139F 7504                    		jnz	short DoBlockHard ;about floppies. They are track by
  5618                                  					;track operations	
  5619 000013A1 88E0                    		mov	al,ah		;set al = ah for floppies
  5620 000013A3 EB0F                    		jmp	short DoBlockCont			
  5621                                  DoBlockHard:					
  5622 000013A5 51                      		push	cx				
  5623 000013A6 31C9                    		xor	cx,cx				
  5624 000013A8 8B4D13                  		mov	cx,[DI+BDS.secpertrack] ;# of sectors/track
  5625 000013AB B53F                    		mov	ch,63						
  5626 000013AD 28CD                    		sub	ch,cl						
  5627 000013AF 88E8                    		mov	al,ch						
  5628 000013B1 86E0                    		xchg	ah,al		;now ah - safe # of sectors
  5629                                  					;al - # of sectors before DMA err
  5630 000013B3 59                      		pop	cx							
  5631                                  DoBlockCont:								
  5632 000013B4 1F                      		pop	ds							
  5633 000013B5 5F                      		pop	di							
  5634                                  DoBlockContinue:							
  5635 000013B6 38C4                    		cmp	ah,al		;if safe_# >= #_of_sectors_to_go_before DMA,
  5636 000013B8 7305                    		jae	short DoBlocklast ;then #_of_sectors_to_go as it is for DoInt.
  5637 000013BA 50                      		push	ax		;save AH, AL				
  5638 000013BB 88E0                    		mov	al,ah		;Otherwise, set al to ah to operate.
  5639                                  			;DoInt will set AH to a proper function in [BP.Oldax]	
  5640 000013BD EB03                    		jmp	short DoBlockDoInt 
  5641                                  DoBlocklast:						
  5642 000013BF 88C4                    		mov	ah,al					
  5643 000013C1 50                      		push	ax		;save AH	
  5644                                  DoBlockDoInt:				;let AH=AL=# of sectors this shot
  5645 000013C2 E81106                  		CALL	DoINT							 
  5646 000013C5 727F                    		JC	short Bad13	;something happened, bye!	 
  5647 000013C7 58                      		pop	ax
  5648                                  					;decrement by the successful operation							 
  5649 000013C8 286602                  		SUB	BYTE [BP+INT13FRAME.oldax],AH 	
  5650 000013CB 00E1                    		ADD	CL,AH		;advance sector number. Safety guaranteed.	
  5651 000013CD 00E7                    		ADD	BH,AH		;advance DMA address			
  5652 000013CF 00E7                    		ADD	BH,AH		;twice for 512 byte sectors.	
  5653 000013D1 38C4                    		cmp	ah,al		;check the previous value	
  5654 000013D3 7407                    		je	short Buffer	;if #_of_sectors_to_go < safe_#, 
  5655                                  					; then we are done already. 
  5656 000013D5 28E0                    		sub	al,ah		;otherwise, 
  5657                                  					; #_sector_to_go = #_of_sector_to_go - safe_#  
  5658 000013D7 E84905                  		call	Check_Wrap	;get new CX, DH for the next operation. 		  
  5659 000013DA EBDA                    		jmp	short DoBlockContinue ;handles next sectors left.			
  5660                                  ;;End of Modification ------------------------------------------------------
  5661                                  
  5662                                  ;Bufferx:
  5663                                  ;		; 17/07/2019
  5664                                  ;		mov	DH,[bp+INT13FRAME.olddx+1] ; set correct head number
  5665                                  Buffer:
  5666 000013DC 53                      		push	BX ; *
  5667 000013DD 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1]
  5668 000013E0 80FC03                  		cmp	AH,ROMWrite
  5669 000013E3 7525                    		jnz	short DoRead
  5670                                  ;
  5671                                  ; Copy the offending sector into local buffer
  5672                                  ;
  5673 000013E5 1E                      		push	ds
  5674 000013E6 06                      		push	es
  5675 000013E7 56                      		push	si
  5676 000013E8 57                      		push	di
  5677 000013E9 0E                      		push	CS		; exchange segment registers
  5678 000013EA 06                      		push	ES
  5679 000013EB 1F                      		pop	DS
  5680 000013EC 07                      		pop	ES
  5681 000013ED BF[D001]                		mov	DI,DiskSector	; where to move
  5682 000013F0 57                      		push	DI		; save it
  5683 000013F1 89DE                    		mov	SI,BX		; source
  5684 000013F3 E8D705                  		call	Move
  5685 000013F6 5B                      		pop	BX		; new transfer address
  5686 000013F7 5F                      		pop	di
  5687 000013F8 5E                      		pop	si
  5688 000013F9 B001                    		mov	AL,1
  5689 000013FB 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  5690 000013FE E82205                  		call	Check_Wrap	; check for head or cylinder wrap
  5691                                  ;
  5692                                  ;   AH is function
  5693                                  ;   AL is 1 for single sector transfer
  5694                                  ;   ES:BX is local transfer addres
  5695                                  ;   CX is track/sector number
  5696                                  ;   DX is head/drive number
  5697                                  ;   SI,DI unchanged
  5698                                  ;
  5699 00001401 E8D205                  		CALL	DoINT
  5700 00001404 07                      		pop	es
  5701 00001405 1F                      		pop	ds
  5702 00001406 723E                    		jc	short Bad13	; go clean up
  5703 00001408 EB26                    		jmp	SHORT DoTail
  5704                                  ;
  5705                                  ; Reading a sector. Do INT first, then move things around
  5706                                  ;
  5707                                  DoRead:
  5708 0000140A 06                      		push	es
  5709 0000140B 53                      		push	bx
  5710 0000140C 0E                      		push	CS
  5711 0000140D 07                      		pop	ES
  5712 0000140E BB[D001]                		mov	BX,DiskSector
  5713 00001411 B001                    		mov	AL,1
  5714 00001413 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  5715 00001416 E80A05                  		call	Check_Wrap	; check for head or cylinder wrap
  5716                                  ;
  5717                                  ;   AH = function
  5718                                  ;   AL = 1 for single sector
  5719                                  ;   ES:BX points to local buffer
  5720                                  ;   CX, DX are track/sector, head/drive
  5721                                  ;
  5722 00001419 E8BA05                  		CALL	DoINT
  5723 0000141C 5B                      		pop	bx
  5724 0000141D 07                      		pop	es
  5725 0000141E 7226                    		jc	short Bad13	; error => clean up
  5726 00001420 1E                      		push	ds
  5727 00001421 56                      		push	si
  5728 00001422 57                      		push	di
  5729 00001423 0E                      		push	CS
  5730 00001424 1F                      		pop	DS
  5731 00001425 89DF                    		mov	DI,BX
  5732 00001427 BE[D001]                		mov	SI,DiskSector
  5733 0000142A E8A005                  		call	Move
  5734 0000142D 5F                      		pop	di
  5735 0000142E 5E                      		pop	si
  5736 0000142F 1F                      		pop	ds
  5737                                  ;
  5738                                  ; Note the fact that we've done 1 more sector
  5739                                  ;
  5740                                  DoTail:
  5741 00001430 5B                      		pop	BX ; *		; retrieve new DMA area
  5742 00001431 80C702                  		add	BH,2		; advance over sector
  5743 00001434 41                      		inc	CX
  5744 00001435 8A4602                  		mov	AL,[BP+INT13FRAME.oldax]
  5745 00001438 F8                      		clc
  5746 00001439 FEC8                    		dec	AL
  5747 0000143B 7409                    		jz	short Bad13	; no more I/O
  5748 0000143D 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; set drive number
  5749 00001440 E8E004                  		call	Check_Wrap	; check for head or cylinder wrap
  5750 00001443 E89005                  		call	DoINT
  5751                                  ;
  5752                                  ; We are done. AX has the final code; we throw away what we got before
  5753                                  ;
  5754                                  Bad13:
  5755 00001446 89EC                    		mov	SP,BP
  5756 00001448 5D                      		pop	bp
  5757 00001449 5B                      		pop	bx
  5758 0000144A 5B                      		pop	bx
  5759 0000144B 59                      		pop	cx
  5760 0000144C 5A                      		pop	dx
  5761                                  		; 06/07/2018
  5762 0000144D CA0200                  		retf	2
  5763                                  
  5764                                  
  5765                                  
  5766                                  ; include msioctl.inc
  5767                                  
  5768                                  ;-----------------------------------------------------------------------------
  5769                                  ; include msioctl.inc - MSDOS 3.3 - MSDISK.ASM - 02/02/1988
  5770                                  ;-----------------------------------------------------------------------------
  5771                                  ; 24/03/2018 - Retro DOS v2.0
  5772                                  
  5773                                  		; include ioctl.inc
  5774                                  
  5775                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  5776                                  ; ............................................................................
  5777                                  
  5778                                  ;*** J.K.
  5779                                  ;General Guide -
  5780                                  ;Category Code:
  5781                                  ; 0... .... DOS Defined
  5782                                  ; 1... .... User defined
  5783                                  ; .xxx xxxx Code
  5784                                  
  5785                                  ;Function Code:
  5786                                  ; 0... .... Return error if unsupported
  5787                                  ; 1... .... Ignore if unsupported
  5788                                  ; .0.. .... Intercepted by DOS
  5789                                  ; .1.. .... Passed to driver
  5790                                  ; ..0. .... Sends data/commands to device
  5791                                  ; ..1. .... Quries data/info from device
  5792                                  ; ...x .... Subfunction
  5793                                  ;
  5794                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  5795                                  ; function set.  It plays no critical role; some functions may contain both
  5796                                  ; command and query elements. The convention is that such commands are
  5797                                  ; defined as "sends data".
  5798                                  
  5799                                  ;*****************************;*
  5800                                  ; BLOCK DRIVERS 	      ;*
  5801                                  ;*****************************;*
  5802                                  
  5803                                  ; IOCTL SUB-FUNCTIONS
  5804                                  IOCTL_GET_DEVICE_INFO	EQU	0
  5805                                  IOCTL_SET_DEVICE_INFO	EQU	1
  5806                                  IOCTL_READ_HANDLE	EQU	2
  5807                                  IOCTL_WRITE_HANDLE	EQU	3
  5808                                  IOCTL_READ_DRIVE	EQU	4
  5809                                  IOCTL_WRITE_DRIVE	EQU	5
  5810                                  IOCTL_GET_INPUT_STATUS	EQU	6
  5811                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  5812                                  IOCTL_CHANGEABLE?	EQU	8
  5813                                  IOCTL_DeviceLocOrRem?	EQU	9
  5814                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  5815                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  5816                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  5817                                  GENERIC_IOCTL		EQU	0Dh   ;13
  5818                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  5819                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  5820                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  5821                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  5822                                  
  5823                                  ; GENERIC IOCTL SUB-FUNCTIONS
  5824                                  RAWIO			EQU	8
  5825                                  
  5826                                  ; RAWIO SUB-FUNCTIONS
  5827                                  GET_DEVICE_PARAMETERS	EQU	60H
  5828                                  SET_DEVICE_PARAMETERS	EQU	40H
  5829                                  READ_TRACK		EQU	61H
  5830                                  WRITE_TRACK		EQU	41H
  5831                                  VERIFY_TRACK		EQU	62H
  5832                                  FORMAT_TRACK		EQU	42H
  5833                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  5834                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  5835                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  5836                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  5837                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  5838                                  
  5839                                  
  5840                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  5841                                  BUILD_DEVICE_BPB	EQU	000000001B
  5842                                  
  5843                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  5844                                  INSTALL_FAKE_BPB	EQU	000000001B
  5845                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  5846                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  5847                                  
  5848                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  5849                                  STATUS_FOR_FORMAT	EQU	000000001B
  5850                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  5851                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  5852                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  5853                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  5854                                  
  5855                                  ; DEVICETYPE VALUES
  5856                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  5857                                  DEV_5INCH		EQU	0
  5858                                  DEV_5INCH96TPI		EQU	1
  5859                                  DEV_3INCH720KB		EQU	2
  5860                                  DEV_8INCHSS		EQU	3
  5861                                  DEV_8INCHDS		EQU	4
  5862                                  DEV_HARDDISK		EQU	5
  5863                                  DEV_OTHER		EQU	7
  5864                                  ;DEV_3INCH1440KB	EQU	7
  5865                                  DEV_3INCH2880KB		EQU	9
  5866                                  ; Retro DOS v2.0 - 26/03/2018
  5867                                  ;;DEV_TAPE		EQU	6
  5868                                  ;;DEV_ERIMO		EQU	8
  5869                                  ;DEV_3INCH2880KB	EQU	9
  5870                                  DEV_3INCH1440KB		EQU	10
  5871                                  
  5872                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
  5873                                  					; CURRENTLY SUPPORT.
  5874                                  MAX_DEV_TYPE		EQU	10
  5875                                  
  5876                                  struc A_SECTORTABLE
  5877 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  5878 00000002 ????                    .ST_SECTORSIZE:		resw	1
  5879                                  .size:
  5880                                  endstruc
  5881                                  
  5882                                  ; MSDOS 6.0 - BPB.INC - 1991
  5883                                  ; ####
  5884                                  ;**	BIOS PARAMETER BLOCK DEFINITION
  5885                                  ;
  5886                                  ;	The BPB contains information about the disk structure. It dates
  5887                                  ;	back to the earliest FAT systems and so FAT information is
  5888                                  ;	intermingled with physical driver information.
  5889                                  ;
  5890                                  ;	A boot sector contains a BPB for its device; for other disks
  5891                                  ;	the driver creates a BPB. DOS keeps copies of some of this
  5892                                  ;	information in the DPB.
  5893                                  ;
  5894                                  ;	The BDS structure contains a BPB within it.
  5895                                  ;
  5896                                  
  5897                                  struc A_BPB
  5898 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
  5899 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
  5900 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
  5901 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
  5902 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
  5903 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
  5904 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
  5905 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
  5906 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
  5907 0000000F ????                    .BPB_HEADS:		resw	1
  5908 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
  5909 00000013 ????                    			resw	1
  5910 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
  5911 00000017 ????                    			resw	1
  5912 00000019 ????????????            			resb	6	; NOTE:  many times these
  5913                                  ;					; 	 6 bytes are omitted
  5914                                  ;					;	 when BPB manipulations
  5915                                  ;					;	 are performed!
  5916                                  .size:
  5917                                  endstruc
  5918                                  ; ####
  5919                                  
  5920                                  struc A_DEVICEPARAMETERS
  5921 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
  5922 00000001 ??                      .DP_DEVICETYPE:		resb	1
  5923 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
  5924 00000004 ????                    .DP_CYLINDERS:		resw	1
  5925 00000006 ??                      .DP_MEDIATYPE:		resb	1
  5926 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
  5927 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
  5928 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  5929                                  endstruc
  5930                                  
  5931                                  struc A_TRACKREADWRITEPACKET
  5932 00000000 ??                      .TRWP_SPECIALFUNCTIONS:	resb	1
  5933 00000001 ????                    .TRWP_HEAD:		resw	1
  5934 00000003 ????                    .TRWP_CYLINDER:		resw	1
  5935 00000005 ????                    .TRWP_FIRSTSECTOR:	resw	1
  5936 00000007 ????                    .TRWP_SECTORSTOREADWRITE: resw	1
  5937 00000009 ????????                .TRWP_TRANSFERADDRESS:	resd	1
  5938                                  endstruc
  5939                                  
  5940                                  ;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
  5941                                  struc A_FORMATPACKET
  5942 00000000 ??                      .FP_SPECIALFUNCTIONS:	resb	1  ; db ?
  5943 00000001 ????                    .FP_HEAD: 		resw	1  ; dw ? 
  5944 00000003 ????                    .FP_CYLINDER:		resw	1  ; dw ?
  5945 00000005 ????                    .FP_TRACKCOUNT:		resw	1  ; dw 1 ; !
  5946                                  endstruc
  5947                                  
  5948                                  struc A_VERIFYPACKET
  5949 00000000 ??                      .VP_SPECIALFUNCTIONS:	resb	1
  5950 00000001 ????                    .VP_HEAD: 		resw	1
  5951 00000003 ????                    .VP_CYLINDER:		resw	1
  5952                                  endstruc
  5953                                  
  5954                                  struc A_MEDIA_ID_INFO
  5955 00000000 ????                    .MI_LEVEL:		resw	1  ; dw 0 ; !		;J.K. 87 Info. level
  5956 00000002 ????????                .MI_SERIAL:		resd	1  ; dd ?		;J.K. 87 Serial #
  5957 00000006 <res Bh>                .MI_LABEL:		resb	11 ; db 11 DUP (' ') ;!	;J.K. 87 volume label
  5958 00000011 ????????????????        .MI_SYSTEM:		resb 	8  ; db 8 DUP (' ')  ;!	;J.K. 87 File system type
  5959                                  endstruc
  5960                                  
  5961                                  struc A_DISKACCESS_CONTROL	   ;AN002; Unpublished function. Only for Hard file.
  5962 00000000 ??                      .DAC_SPECIALFUNCTIONS:	resb 	1  ; db 0 ; ! ;AN002; Always 0
  5963 00000001 ??                      .DAC_ACCESS_FLAG: 	resb 	1  ; db 0 ; ! 
  5964                                  				   ; Non Zero - allow disk I/O to unformatted hard file
  5965                                  endstruc			   ; 0 - Disallow disk I/O to unformatted hard file
  5966                                  
  5967                                  
  5968                                  struc A_MEDIA_SENSE			; Media sense structure added 5.00
  5969 00000000 ??                      .MS_ISDEFAULT:		resb	1	; If 1 type returned is drv default
  5970 00000001 ??                      .MS_DEVICETYPE:		resb	1	; Drive type 
  5971 00000002 ??                      .MS_RESERVED1:		resb	1	; RESERVED
  5972 00000003 ??                      .MS_RESERVED2:		resb 	1	; RESERVED 
  5973                                  endstruc
  5974                                  
  5975                                  ;********************************;*
  5976                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  5977                                  ;********************************;*
  5978                                  
  5979                                  ;RAWIO SUB-FUNCTIONS
  5980                                  GET_RETRY_COUNT 	EQU	65H
  5981                                  SET_RETRY_COUNT 	EQU	45H
  5982                                  
  5983                                  struc A_RETRYCOUNT
  5984 00000000 ????                    .RC_COUNT:		resw 1
  5985                                  endstruc
  5986                                  
  5987                                  ;********************************;*		;J.K. 4/29/86
  5988                                  ; CHARACTER DEVICES (SCREEN)	 ;*
  5989                                  ;********************************;*		;J.K. 4/29/86
  5990                                  ;
  5991                                  ;SC_MODE_INFO	 struc
  5992                                  ;SC_INFO_LENGTH 	 DW	 9
  5993                                  ;SC_MODE		 DB	 0
  5994                                  ;SC_COLORS		 DW	 0
  5995                                  ;SC_WIDTH		 DW	 0
  5996                                  ;SC_LENGTH		 DW	 0
  5997                                  ;SC_MODE_INFO	 ends
  5998                                  ;
  5999                                  ;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.
  6000                                  
  6001                                  ;SUBFUNCTIONS FOR CON$GENIOCTL
  6002                                  ;GET_SC_MODE		 EQU	 60h
  6003                                  ;SET_SC_MODE		 EQU	 40h
  6004                                  ;The following subfunctions are reserved for installable CODE PAGE switch
  6005                                  ;console devices. - J.K. 4/29/86
  6006                                  ;Get_active_codepage	 equ	 6Ah
  6007                                  ;Invoke_active_codepage  equ	 4Ah
  6008                                  ;Start_designate_codepage equ	 4Ch
  6009                                  ;End_designate_codepage  equ	 4Dh
  6010                                  ;Get_list_of_designated_codepage equ 6Bh
  6011                                  ;J.K. 4/29/86 *** End of Con$genioctl equates & structures
  6012                                  
  6013                                  ; 28/05/2018 - Retro DOS v3.0
  6014                                  
  6015                                  ; 29/06/2019 - Retro DOS v3.1
  6016                                  
  6017                                  ; -----------------------------------------------------------------
  6018                                  ;
  6019                                  ; Generic IOCTL dispatch tables
  6020                                  ;
  6021                                  ; -----------------------------------------------------------------
  6022                                  
  6023                                  IOReadJumpTable: 
  6024 00001450 02                      		db	2		;maximum number (zero based)
  6025 00001451 [9A14]                  		dw	GetDeviceParameters
  6026 00001453 [0917]                  		dw	ReadTrack
  6027 00001455 [E416]                  		dw	VerifyTrack
  6028                                  
  6029                                  IOWriteJumpTable:
  6030 00001457 02                      		db	2		;maximum number (zero based)
  6031 00001458 [D614]                  		dw	SetDeviceParameters
  6032 0000145A [1117]                  		dw	WriteTrack
  6033 0000145C [9715]                  		dw	FormatTrack
  6034                                  ; -----------------------------------------------------------------
  6035                                  ;
  6036                                  ; Generic$IOCTL:
  6037                                  ;    Perform Generic IOCTL request
  6038                                  ;    Input:
  6039                                  ;	al	- unit number
  6040                                  ;    Output:
  6041                                  ;	if carry set then al contains error code
  6042                                  ;
  6043                                  ; -----------------------------------------------------------------
  6044                                  
  6045                                  GENERIC$IOCTL:
  6046 0000145E 2EC41E[B000]            		les	bx,[cs:PTRSAV]		; es:bx points to request header.
  6047 00001463 E80FF7                  		call	SETDRIVE		; ds:di points to BDS for drive.
  6048                                  ;
  6049                                  ; At this point:
  6050                                  ;    es:bx - points to the Request Header
  6051                                  ;    ds:di points to the BDS for the drive
  6052                                  ;
  6053 00001466 26807F0D08              		cmp	byte [es:bx+IOCTL_REQ.MAJORFUNCTION],RAWIO
  6054 0000146B 752A                    		jne	IOCTL_Func_Err
  6055 0000146D 268A470E                		mov	al,[es:bx+IOCTL_REQ.MINORFUNCTION]
  6056 00001471 BE[5014]                		mov	si,IOReadJumpTable
  6057 00001474 A820                    		test	al,GEN_IOCTL_FN_TST	; Test of req. function
  6058 00001476 7503                    		jnz	short NotGenericIoctlWrite	;   function is a Read.
  6059 00001478 BE[5714]                		mov	si,IOWriteJumpTable
  6060                                  NotGenericIoctlWrite:
  6061 0000147B 240F                    		and	al,0FH
  6062 0000147D 2E3A04                  		cmp	al,[cs:si]
  6063 00001480 7715                    		ja	short IOCTL_Func_Err
  6064 00001482 98                      		cbw
  6065 00001483 D1E0                    		shl	ax, 1
  6066 00001485 46                      		inc	si
  6067 00001486 01C6                    		add	si,ax
  6068 00001488 26C45F13                		les	bx,[es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
  6069 0000148C 2EFF14                  		call	[cs:si]
  6070 0000148F 7203                    		jc	short FailGeneric$IOCTL
  6071 00001491 E9D3F3                  		jmp	EXIT
  6072                                  
  6073                                  FailGeneric$IOCTL:
  6074 00001494 E9C3F3                  		jmp	ERR$EXIT
  6075                                  
  6076                                  IOCTL_Func_Err:
  6077 00001497 E9B6F3                  		jmp	CMDERR
  6078                                  
  6079                                  ; -----------------------------------------------------------------
  6080                                  ;
  6081                                  ; GetDeviceParameters:
  6082                                  ;
  6083                                  ; Input: DS:DI points to BDS for drive
  6084                                  ;	 ES:BX points to device parameter packet
  6085                                  ;
  6086                                  ; -----------------------------------------------------------------
  6087                                  
  6088                                  GetDeviceParameters:
  6089                                  ; Copy info from BDS to the device parameters packet
  6090 0000149A 8A4522                  		mov	al,[DI+BDS.formfactor]
  6091 0000149D 26884701                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE], al
  6092 000014A1 8B4523                  		mov	ax,[DI+BDS.flags]
  6093 000014A4 83E003                  		and	ax,fNon_Removable+fChangeline	; mask off other bits
  6094 000014A7 26894702                		mov	[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES], ax
  6095 000014AB 8B4525                  		mov	ax,[DI+BDS.cylinders]
  6096 000014AE 26894704                		mov	[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS], ax
  6097                                  
  6098                                  ; Set media type to default
  6099 000014B2 30C0                    		xor	al, al
  6100 000014B4 26884706                		mov	[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE],al
  6101                                  
  6102                                  ; Copy recommended BPB
  6103 000014B8 8D7527                  		lea	si, [DI+BDS.rbytespersec]
  6104                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],BUILD_DEVICE_BPB
  6105 000014BB 26F60701                		test	byte [es:bx],BUILD_DEVICE_BPB ; 05/07/2019
  6106 000014BF 740B                    		jz	short use_BPB_present
  6107                                  ; Get the correct disk in the drive
  6108 000014C1 E83BFA                  		call	CHECKSINGLE
  6109                                  ; Build the BPB from scratch
  6110 000014C4 E84BF8                  		call	GETBP
  6111 000014C7 720C                    		jc	short Get_Parm_Ret
  6112 000014C9 8D7506                  		lea	si,[DI+BDS.bytespersec]
  6113                                  use_BPB_present:
  6114 000014CC 8D7F07                  		lea	di,[bx+A_DEVICEPARAMETERS.DP_BPB]
  6115 000014CF B91300                  		mov	cx,BPB_TYPE.size	; for now use 'small' BPB
  6116 000014D2 F3A4                    		rep	movsb
  6117 000014D4 F8                      		clc
  6118                                  Get_Parm_Ret:
  6119 000014D5 C3                      		retn
  6120                                  
  6121                                  ; -----------------------------------------------------------------
  6122                                  ;
  6123                                  ; SetDeviceParameters:
  6124                                  ;
  6125                                  ; Input: DS:DI points to BDS for drive
  6126                                  ;	 ES:BX points to device parameter packet
  6127                                  ;
  6128                                  ; -----------------------------------------------------------------
  6129                                  
  6130                                  SetDeviceParameters:
  6131                                  
  6132                                  ; Make sure the fChanged_By_Format flag gets set to kick DOS into looking at
  6133                                  ; the BPB
  6134 000014D6 814D234001              		or	word [DI+BDS.flags],fChanged_By_Format | fChanged
  6135                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],ONLY_SET_TRACKLAYOUT
  6136 000014DB 26F60702                		test	byte [es:bx],ONLY_SET_TRACKLAYOUT ; 05/07/2019
  6137                                  		;jz	short SetDevParm_1
  6138                                  		;jmp	short SetTrackTable		; Originally TrackLayout
  6139 000014DF 756D                    		jnz	short SetTrackTable ; 05/07/2019 - Retro DOS v3.1
  6140                                  SetDevParm_1:
  6141                                  ; Copy info from the device parameters packet to BDS
  6142 000014E1 268A4701                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  6143 000014E5 884522                  		mov	[DI+BDS.formfactor], al
  6144                                  
  6145 000014E8 268B4704                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
  6146 000014EC 894525                  		mov	[DI+BDS.cylinders],ax
  6147                                  
  6148                                  ; If change line is not loaded then ignore changeling flag
  6149 000014EF 268B4702                		mov	ax,[es:bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
  6150 000014F3 2E803E[1201]00          		cmp	byte [cs:fHave96],0
  6151 000014F9 7503                    		jnz	short Have_Change
  6152 000014FB 83E0FD                  		and	ax,~fChangeline
  6153                                  Have_Change:
  6154                                  ; ignore all bits except Non_removable and Changeline
  6155 000014FE 83E003                  		and	ax,fNon_Removable | fChangeline
  6156 00001501 8B4D23                  		mov	cx,[DI+BDS.flags]
  6157 00001504 83E1F4                  		and	cx,~(fNon_Removable | fChangeline | GOOD_TRACKLAYOUT)
  6158 00001507 09C8                    		or	ax,cx
  6159 00001509 894523                  		mov	[DI+BDS.flags],ax
  6160                                  
  6161                                  ; Set media type
  6162 0000150C 268A4706                		mov	al,[es:bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
  6163 00001510 2EA2[AE06]              		mov	[cs:mediaType],al
  6164                                  ; the media changed (maybe) so we will have to do a SetDASD the next time
  6165                                  ; we format a track
  6166 00001514 814D238000              		or	word [DI+BDS.flags],SET_DASD_true
  6167                                  
  6168 00001519 1E                      		push	ds
  6169 0000151A 57                      		push	di
  6170 0000151B 06                      		push	es
  6171 0000151C 53                      		push	bx
  6172                                  ; Figure out what we are supposed to do with the BPB
  6173                                  
  6174                                  ; Were we asked to install a fake BPB?
  6175                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],INSTALL_FAKE_BPB
  6176 0000151D 26F60701                		test	byte [es:bx],INSTALL_FAKE_BPB ; 05/07/2019
  6177 00001521 7515                    		jnz	short InstallFakeBPB
  6178                                  
  6179                                  ; Were we returning a fake BPB when asked to build a BPB?
  6180 00001523 F745230400              		test	word [DI+BDS.flags],RETURN_FAKE_BPB
  6181 00001528 7406                    		jz	short InstallRecommendedBPB
  6182                                  
  6183                                  ; We were returning a fake BPB but we can stop now
  6184 0000152A 836523FB                		and	word[DI+BDS.flags],~RETURN_FAKE_BPB
  6185 0000152E EB17                    		jmp	short DoneWithBPBstuff
  6186                                  
  6187                                  InstallRecommendedBPB:
  6188 00001530 B91F00                  		mov	cx,A_BPB.size
  6189 00001533 8D7D27                  		lea	di,[DI+BDS.rbytespersec]
  6190 00001536 EB06                    		jmp	short CopyTheBPB
  6191                                  
  6192                                  InstallFakeBPB:
  6193 00001538 B91300                  		mov	cx,BPB_TYPE.size    ; move 'smaller' BPB
  6194 0000153B 8D7D06                  		lea	di,[DI+BDS.bytespersec]
  6195                                  CopyTheBPB:
  6196 0000153E 8D7707                  		lea	si,[bx+A_DEVICEPARAMETERS.DP_BPB]
  6197                                  ; exchange es and ds
  6198 00001541 06                      		push	es
  6199 00001542 1E                      		push	ds
  6200 00001543 07                      		pop	es
  6201 00001544 1F                      		pop	ds
  6202                                  
  6203 00001545 F3A4                    		rep	movsb
  6204                                  
  6205                                  DoneWithBPBstuff:
  6206 00001547 E8AD03                  		call	RestoreOldDPT
  6207 0000154A 5B                      		pop	bx
  6208 0000154B 07                      		pop	es
  6209 0000154C 5F                      		pop	di
  6210 0000154D 1F                      		pop	ds
  6211                                  
  6212                                  ; Set up track table (if neccessary)
  6213                                  SetTrackTable:
  6214 0000154E 268B4F26                		mov	cx,[es:bx+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES]
  6215 00001552 2E890E[AC06]            		mov	[cs:SectorsPerTrack],cx
  6216 00001557 836523F7                		and	word [DI+BDS.flags],~GOOD_TRACKLAYOUT
  6217                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],TRACKLAYOUT_IS_GOOD
  6218 0000155B 26F60704                		test	byte [es:bx],TRACKLAYOUT_IS_GOOD ; 05/07/2019
  6219 0000155F 7404                    		jz	short UglyTrackLayout
  6220 00001561 834D2308                		or	word [DI+BDS.flags],GOOD_TRACKLAYOUT
  6221                                  
  6222                                  UglyTrackLayout:
  6223 00001565 83F93F                  		cmp	cx,MAX_SECTORS_IN_TRACK
  6224 00001568 7729                    		ja	short TooManySectorsPerTrack
  6225 0000156A E325                    		jcxz	SectorInfoSaved		; if no value don't copy table
  6226                                  						; save information in the track table
  6227                                  
  6228 0000156C 53                      		push    BX			; get ES:BX to point to sector
  6229 0000156D 83C328                  		add     BX,A_DEVICEPARAMETERS.DP_SECTORTABLE ;  table in Device param. struct
  6230                                  	
  6231 00001570 57                      		push    DI
  6232 00001571 BF[B205]                		mov     DI,TrackTable + 2	; CS:DI now points to sector id
  6233                                                                                  ; of the first track table entry
  6234 00001574 50                      		push    AX			; preserve AX value
  6235                                  
  6236                                                                                  ; For MAX_SECTORS_IN_TRACK
  6237                                  TrackLoop:                                      ;   DO:
  6238 00001575 268B07                  		mov     AX,[ES:BX]		;   get sector number
  6239 00001578 2E8805                  		mov	[CS:DI],AL		;   save in track table
  6240                                  
  6241 0000157B 268B4702                	        mov     AX,[ES:BX+2]		;   get sector size
  6242 0000157F E83602                  	        call    SectorSizeToSectorIndex ;   convert size to index number
  6243 00001582 2E884501                		mov     [CS:DI+1],AL		;   save size in track table
  6244                                  
  6245 00001586 83C304                  		add     BX,A_SECTORTABLE.size	;   advance pointers to next
  6246 00001589 83C704                  		add     DI,A_SECTORTABLE.size	;   entries
  6247 0000158C E0E7                    		loopnz  TrackLoop		; End FOR
  6248                                  
  6249 0000158E 58                      		pop     AX 			; restore the saved values
  6250 0000158F 5F                      		pop     DI
  6251 00001590 5B                      		pop     BX
  6252                                  
  6253                                  SectorInfoSaved:
  6254 00001591 F8                      		clc
  6255 00001592 C3                      		retn
  6256                                  
  6257                                  TooManySectorsPerTrack:
  6258 00001593 B00C                    		mov	al, 0Ch
  6259 00001595 F9                      		stc
  6260 00001596 C3                      		retn
  6261                                  
  6262                                  ; ---------------------------------------------------------------------------
  6263                                  ;
  6264                                  ; FormatTrack:
  6265                                  ; If SpecialFunction byte is 1, then this is a status call to see if there is
  6266                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  6267                                  ; combination is legal. If SpecialFunction byte is 0, then format the track.
  6268                                  ;
  6269                                  ; Input: DS:DI points to BDS for drive
  6270                                  ;        ES:BX points to format packet
  6271                                  ;
  6272                                  ; Output:
  6273                                  ;       For status call:
  6274                                  ;       SpecialFunction byte set to:
  6275                                  ;               0 - ROM support + legal combination
  6276                                  ;               1 - No ROM support
  6277                                  ;               2 - Illegal Combination
  6278                                  ;		3 - no media present			;Rev 3.30
  6279                                  ;       Carry cleared.
  6280                                  ;
  6281                                  ;       For format track:
  6282                                  ;               Carry set if error
  6283                                  ;
  6284                                  ;
  6285                                  ;  Flags also may be altered. All other registers preserved.
  6286                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  6287                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  6288                                  ;  to the one returned. The original pointer to the disk base table is stored
  6289                                  ;  in TempDPT, until it is restored.
  6290                                  ;
  6291                                  ;  This proc was changed to force a status for format call if we are on the
  6292                                  ;  new ROM.
  6293                                  ;
  6294                                  ; ---------------------------------------------------------------------------
  6295                                  
  6296                                  FormatTrack:
  6297                                  		;test	byte [es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],STATUS_FOR_FORMAT
  6298 00001597 26F60701                		test	byte [es:bx],STATUS_FOR_FORMAT ; 05/07/2019
  6299 0000159B 7408                    		jz	short SkipStatusOnly
  6300                                  
  6301                                  Do_Status_Only:
  6302 0000159D E89900                  		call	FormatStatus
  6303                                  		;mov	[es:bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS],al
  6304 000015A0 268807                  		mov	[es:bx],al ; 05/07/2019
  6305                                  		;clc
  6306 000015A3 F8                      		clc	; 05/07/2019 - Retro DOS v3.1 (CF=1 is possible from 'FormatStatus')
  6307 000015A4 C3                      		retn
  6308                                  	
  6309                                  SkipStatusOnly:                       ; for a hard disk only do the verify
  6310 000015A5 807D2205                        	cmp     byte [DI+BDS.formfactor],DEV_HARDDISK
  6311 000015A9 7503                    		jnz	short SkipVerify
  6312 000015AB E98700                  		jmp	DoVerifyTrack
  6313                                  SkipVerify:
  6314 000015AE 1E                      		push	ds			; Format a Track
  6315 000015AF 57                      		push	di
  6316 000015B0 06                      		push	es
  6317 000015B1 53                      		push	bx
  6318 000015B2 E88400                  		call	FormatStatus		; SetDASD checks media_set_for_format
  6319                                  		;;14/06/2018 (IBMDOS 3.3,IBMBIO.COM)
  6320                                  		;cmp	al,1
  6321                                  		;je	short NeedToSetDasd
  6322 000015B5 3C03                    		cmp	al,3			; Check for time out
  6323                                  		;jne	short NoSetDasd
  6324 000015B7 745D                    		je	short Format_Failed	; Fail if time out
  6325                                  		;jmp	short Format_Failed
  6326                                  NeedToSetDasd:
  6327 000015B9 E81202                          	call    SetDASD
  6328                                  ;
  6329                                  ; Store Cylinder,Head in track table
  6330                                  ;                       ***** ASSUMPTION *******
  6331                                  ;       Since format requests on Fixed Media are converted to Verifies, we
  6332                                  ;       assume that we are formatting a floppy and hence have 255 or less
  6333                                  ;       tracks and heads. We therefore must change the Cylinder, Head data
  6334                                  ;       from the Request Packet Size to that of the TrackTable (see Int 13
  6335                                  ;       interface in IBM's Tech Ref.).
  6336                                  
  6337                                  ; Check to ensure correct disk is in drive
  6338                                  NoSetDasd:
  6339 000015BC E840F9                  		call    CHECKSINGLE
  6340                                  
  6341 000015BF 268B4703                		mov     ax,[es:bx+A_FORMATPACKET.FP_CYLINDER]
  6342 000015C3 2EA3[BA01]              		mov     [cs:TRKNUM],ax
  6343 000015C7 268B4F01                		mov     cx,[es:bx+A_FORMATPACKET.FP_HEAD]
  6344 000015CB 2E880E[B901]            		mov     [cs:HDNUM],cl
  6345 000015D0 88CC                    		mov     ah,cl
  6346                                                          ; this next piece of code copies the correct head
  6347                                                          ; and cylinder numbers to the tracktable
  6348 000015D2 57                      		push    di			; preserve DI
  6349 000015D3 BF[B005]                		mov     di,TrackTable
  6350 000015D6 2E8B0E[AC06]            		mov     CX,[cs:SectorsPerTrack] ; get number of sectors
  6351 000015DB E308                            	jcxz    EndSetUpTrackTable	; if nothing to do skip down
  6352                                  SetUpLoop:
  6353 000015DD 2E8905                  		mov     [cs:di],AX		; set head and track value
  6354 000015E0 83C704                  		add     di,4			; move to next entry
  6355 000015E3 E0F8                    		loopnz  SetUpLoop		; loop if not done yet
  6356                                  EndSetUpTrackTable:
  6357 000015E5 5F                              	pop     di			; restore DI (BDS pointer)
  6358 000015E6 B90500                          	mov     cx,MAXERR		; Set up retry count
  6359                                  FormatRetry:
  6360 000015E9 51                      		push    cx
  6361                                                                  		; set up registers for format call to TO_ROM
  6362 000015EA 2EA1[AC06]              		mov     AX,[CS:SectorsPerTrack]	; set number of sectors
  6363 000015EE B405                    		mov     AH,ROMFormat
  6364 000015F0 0E                      		push    cs			; set ES:BX to point to
  6365 000015F1 07                      		pop     es			;    the track table
  6366 000015F2 BB[B005]                		mov     BX,TrackTable
  6367                                                                                  ; don't need to set CL on format
  6368 000015F5 E84202                  		call    To_ROM
  6369 000015F8 59                      		pop	cx
  6370 000015F9 7330                    		jnc	short FormatOk
  6371                                  		;pop     cx
  6372 000015FB 2EC606[B006]01          		mov	byte [cs:Had_Format_Error],1	; Mark the error
  6373 00001601 50                      		push	ax		
  6374 00001602 51                      		push	cx			
  6375 00001603 52                      		push	dx
  6376 00001604 E82602                  		call    ResetDisk
  6377 00001607 E82F00                  		call	FormatStatus
  6378 0000160A 3C01                    		cmp	al,1
  6379 0000160C 7503                    		jnz	short While_Err
  6380 0000160E E8BD01                  		call	SetDASD 
  6381                                  While_Err:
  6382 00001611 5A                      		pop	dx
  6383 00001612 59                      		pop	cx
  6384 00001613 58                      		pop	ax
  6385 00001614 E2D3                    		loop    FormatRetry
  6386                                  
  6387                                  ; Format failed
  6388                                  Format_Failed:
  6389 00001616 2EC606[B006]01          		mov	byte [cs:Had_Format_Error],1	; Indicate a format error
  6390 0000161C 80FC06                  		cmp	ah,Dsk_change_line_Err		; Convert change line to
  6391 0000161F 7502                    		jne	short Map_Err			;   to time out.
  6392 00001621 B480                    		mov	ah,Dsk_time_out_Err
  6393                                  Map_Err:
  6394 00001623 E80FFC                          	call    MAPERROR
  6395 00001626 5B                      		pop	bx
  6396 00001627 07                      		pop	es
  6397 00001628 5F                      		pop	di
  6398 00001629 1F                      		pop	ds
  6399 0000162A C3                      		retn
  6400                                  
  6401                                  FormatOk:
  6402 0000162B 2EC606[B006]00          		mov	byte [cs:Had_Format_Error],0 ; Reset format error flag
  6403                                  		;pop     cx			; clean up stack after bailing out
  6404                                  						; of FormatRetry loop early
  6405 00001631 5B                      		pop	bx
  6406 00001632 07                      		pop	es
  6407 00001633 5F                      		pop	di
  6408 00001634 1F                      		pop	ds
  6409                                  DoVerifyTrack:
  6410 00001635 E8AC00                  	        call    VerifyTrack             ; Will reset DPT entries.
  6411 00001638 C3                      		retn
  6412                                  
  6413                                  ;
  6414                                  ; FormatStatus:
  6415                                  ; If SpecialFunction byte is 1, then this routine is called to see if there is
  6416                                  ; ROM support for the combination of sec/trk and # of cyln, and if the
  6417                                  ; combination is legal.
  6418                                  ;
  6419                                  ; Input: DS:DI points to BDS for drive
  6420                                  ;	 ES:BX points to format packet
  6421                                  ;
  6422                                  ; Output:
  6423                                  ;	SpecialFunction byte set to:
  6424                                  ;		0 - ROM support + legal combination
  6425                                  ;		1 - No ROM support
  6426                                  ;		2 - Illegal Combination
  6427                                  ;		3 - No media present, ROM support exists but can't determine
  6428                                  ;		    media
  6429                                  ;	Carry cleared.
  6430                                  ;
  6431                                  ;	For format track:
  6432                                  ;		Carry set if error
  6433                                  ;
  6434                                  ;
  6435                                  ;  Flags also may be altered. All other registers preserved.
  6436                                  ;  If the call to ROM returns no error, then the current DPT is "replaced" by
  6437                                  ;  the one returned by the ROM. This is done by changing the pointer in [DPT]
  6438                                  ;  to the one returned. The original pointer to the disk base table is stored
  6439                                  ;  in TempDPT, until it is restored.
  6440                                  ;
  6441                                  ;
  6442                                  FormatStatus:
  6443 00001639 51                      		push	cx
  6444 0000163A 52                      		push	dx
  6445                                  			; Are we here because of a format err
  6446 0000163B 2E803E[B006]01          		cmp	byte [cs:Had_Format_Error],1
  6447 00001641 7411                    		je	short Fstat01
  6448 00001643 2E803E[AF06]01          		cmp	byte [cs:Media_Set_For_Format],1
  6449 00001649 7503                    		jnz	short FStat03
  6450 0000164B E99200                  		jmp	Stat_Ret
  6451                                  FStat03:
  6452 0000164E 2EC606[AF06]00          		mov	byte [cs:Media_Set_For_Format],0
  6453                                  ;
  6454                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6455                                  ;			modification - sp001
  6456                                  ;	
  6457                                  ;	remove check for new rom from here. we shall just assume the
  6458                                  ;	prescence of the new rom and go ahead and issue the int13 call
  6459                                  ;	anyway. later on if there is an error we shall check this to
  6460                                  ;	see if it is there because of lack of rom support, in which
  6461                                  ;	case the appropriate error will be indicated by setting al to 1
  6462                                  ;
  6463                                  ;	I would ideally like to see the new rom testing code shifted to
  6464                                  ;	msinit and this code reintroduced. however for this version we
  6465                                  ;	are aiming to stick close to the IBM variety. 
  6466                                  ;
  6467                                  ;	More changes to support this commenting out will follow. All
  6468                                  ;	will be marked as modification sp001
  6469                                  ;
  6470                                  ;	mov	al,1			; No ROM support available error code
  6471                                  ;	test	byte ptr cs:[NEW_ROM],1
  6472                                  ;	jnz	short FStat01
  6473                                  ;	jmp	Stat_Ret
  6474                                  Fstat01:
  6475 00001654 1E                      		push	ds
  6476 00001655 56                      		push	si
  6477                                  
  6478 00001656 31C0                    		xor	ax,ax
  6479 00001658 8ED8                    		mov	ds,ax
  6480 0000165A C5367800                		lds	si,[DSKADR]		; DS:SI := pDPT
  6481                                  
  6482 0000165E 2E8936[AE01]            		mov	word [cs:DPT],si	; cs:[DPT] := pDPT
  6483 00001663 2E8C1E[B001]            		mov	word [cs:DPT+2],ds
  6484                                  
  6485 00001668 5E                      		pop	si
  6486 00001669 1F                      		pop	ds
  6487                                  
  6488                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6489                                  ;			modification sp001
  6490                                  ;	
  6491                                  ;	the following instruction introduced for the new rom modification
  6492                                  ;
  6493 0000166A 2EC606[1601]01          		mov	byte [cs:NEW_ROM],1		; assume new rom
  6494                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6495 00001670 8B4525                  		mov	ax,[DI+BDS.cylinders]
  6496 00001673 8B4D13                  		mov	cx,[DI+BDS.secpertrack]
  6497                                  					; set up registers for format status call
  6498 00001676 80E403                  		and	AH,03h		; 'and' out unneeded track bits
  6499 00001679 D0CC                    		ror	AH,1		; get track and sector values correct
  6500 0000167B D0CC                    		ror	AH,1
  6501 0000167D 08CC                    		or	AH,CL		; set sector number
  6502 0000167F 86E0                    		xchg	AH,AL
  6503 00001681 89C1                    		mov	CX,AX
  6504 00001683 FECD                    		dec	CH
  6505 00001685 8A5504                  		mov	DL,[DI+BDS.drivenum] ; get drive number
  6506 00001688 B418                    		mov	AH,18h	; set command to "sec/trk supported?"
  6507                                  
  6508 0000168A 06                      		push	es
  6509 0000168B 57                      		push	di
  6510 0000168C 1E                      		push	ds
  6511 0000168D 56                      		push	si
  6512                                  
  6513 0000168E CD13                    		int	13h		; call rom bios to see if supported
  6514 00001690 7234                    		jc	short Format_Stat_Err ; if carry, combination is not supported
  6515                                  
  6516                                  				; ES:DI points to new Disk Base Table
  6517                                  				; combination for this drive replace
  6518                                  				; current (DskAdr) pointer with new one,
  6519                                  				; saving the old one in TempDPT.
  6520                                  
  6521                                  		; Are we here because of a format err
  6522 00001692 2E803E[B006]01          		cmp	byte [cs:Had_Format_Error],1
  6523 00001698 7508                    		jnz	short Fstat02	; Then skip the disk base setup
  6524                                  	
  6525 0000169A 30C0                    		xor	al,al			; Supported and OK
  6526 0000169C 2EA2[B006]              		mov	[cs:Had_Format_Error],al ; Clear format error
  6527 000016A0 EB3A                    		jmp	short Pop_Stat_Ret	; Back to work
  6528                                  Fstat02:
  6529 000016A2 31C0                    		xor	ax,ax
  6530 000016A4 8ED8                    		mov	ds,ax
  6531 000016A6 C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  6532                                  
  6533 000016AA 2E8936[B106]            		mov	[cs:TempDPT],si
  6534 000016AF 2E8C1E[B306]            		mov	[cs:TempDPT+2],ds ; Save pDPT
  6535                                  
  6536 000016B4 893E7800                		mov	[DSKADR],DI 	; Setup New DPT returned by
  6537 000016B8 8C067A00                		mov	[DSKADR+2],ES	; ROM
  6538                                  
  6539 000016BC 2EC606[AF06]01          		mov	byte [cs:Media_Set_For_Format],1 ; set flag
  6540 000016C2 30C0                    		xor	al,al		; Legal combination + ROM support code
  6541 000016C4 EB16                    		jmp	short Pop_Stat_Ret
  6542                                  
  6543                                  Format_Stat_Err:
  6544 000016C6 B003                    		mov	al,3			; Assume a time out
  6545 000016C8 80FC80                  		cmp	ah,Dsk_time_out_Err	; Was it a time out???
  6546 000016CB 740F                    		jz	short Pop_Stat_Ret	;  Yes - then done
  6547 000016CD FEC8                    		dec	al			; Assume an illegal comb.
  6548 000016CF 80FC0C                  		cmp	ah,Dsk_illegal_combination ; Was it an illegal comb???
  6549 000016D2 7408                    		jz	short Pop_Stat_Ret	; Yes - then done
  6550 000016D4 FEC8                    		dec	al			; Assume No ROM Support	
  6551                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6552                                  ;			modification sp001
  6553                                  ;
  6554                                  ;	the following instruction was introduced for the new_rom modification
  6555                                  ;
  6556 000016D6 2EC606[1601]00          		mov	byte [cs:NEW_ROM],0	; the old rom
  6557                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  6558                                  
  6559                                  ; Return result of status call
  6560                                  Pop_Stat_Ret:
  6561 000016DC 5E                      		pop	si
  6562 000016DD 1F                      		pop	ds
  6563 000016DE 5F                      		pop	di
  6564 000016DF 07                      		pop	es
  6565                                  Stat_Ret:
  6566 000016E0 F8                      		clc
  6567 000016E1 5A                      		pop	dx
  6568 000016E2 59                      		pop	cx
  6569 000016E3 C3                      		retn
  6570                                  
  6571                                  ; ---------------------------------------------------------------------------
  6572                                  ;
  6573                                  ; VerifyTrack:
  6574                                  ;
  6575                                  ; Input: DS:DI points to BDS for drive
  6576                                  ;	 ES:BX points to verify packet
  6577                                  ;
  6578                                  ; ---------------------------------------------------------------------------
  6579                                  
  6580                                  VerifyTrack:
  6581 000016E4 2EC606[A201]04          		mov	byte [cs:RFLAG],ROMVerify
  6582 000016EA 268B4703                		mov	ax,[es:bx+A_VERIFYPACKET.VP_CYLINDER]
  6583 000016EE 2EA3[B401]              		mov	[cs:CURTRK], ax
  6584 000016F2 268B4701                		mov	ax,[es:bx+A_VERIFYPACKET.VP_HEAD]
  6585                                  
  6586                                  ;	****** ASSUMPTION ******
  6587                                  ;	we assume that we have less than 256 heads, and that the Request
  6588                                  ;	Header Data Structure is unneccessarily big
  6589 000016F6 2EA2[B301]              		mov	[cs:CURHD],al
  6590 000016FA 31C0                    		xor	ax,ax
  6591 000016FC 2E8B0E[AC06]            		mov	cx,[cs:SectorsPerTrack]
  6592                                  ; Use 0:0 as the transfer address for verify
  6593 00001701 31DB                    		xor	bx, bx
  6594 00001703 8EC3                    		mov	es, bx
  6595 00001705 E83100                  		call	TrackIO
  6596 00001708 C3                      		retn
  6597                                  
  6598                                  ; ---------------------------------------------------------------------------
  6599                                  ;
  6600                                  ; ReadTrack:
  6601                                  ;
  6602                                  ; Input: DS:DI points to BDS for drive
  6603                                  ;	 ES:BX points to read packet
  6604                                  ;
  6605                                  ; ---------------------------------------------------------------------------
  6606                                  
  6607                                  ReadTrack:
  6608 00001709 2EC606[A201]02          		mov	byte [cs:RFLAG],ROMRead
  6609 0000170F EB08                    		jmp	short ReadWriteTrack
  6610                                  
  6611                                  ; ---------------------------------------------------------------------------
  6612                                  ;
  6613                                  ; WriteTrack:
  6614                                  ;
  6615                                  ; Input: DS:DI points to BDS for drive
  6616                                  ;	 ES:BX points to write packet
  6617                                  ;
  6618                                  ; ---------------------------------------------------------------------------
  6619                                  
  6620                                  WriteTrack:
  6621 00001711 2EC606[A201]03          		mov	byte [cs:RFLAG],ROMWrite
  6622 00001717 EB00                    		jmp	short ReadWriteTrack
  6623                                  
  6624                                  ; ---------------------------------------------------------------------------
  6625                                  ;
  6626                                  ; ReadWriteTrack:
  6627                                  ;
  6628                                  ; Input:
  6629                                  ;    DS:DI points to BDS for drive
  6630                                  ;    ES:BX points to write packet
  6631                                  ;    RFLAG - 2 for read, 3 for write
  6632                                  ;
  6633                                  ; ---------------------------------------------------------------------------
  6634                                  
  6635                                  ReadWriteTrack:
  6636 00001719 268B4703                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
  6637 0000171D 2EA3[B401]              		mov	[cs:CURTRK],ax
  6638 00001721 268B4701                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
  6639                                  
  6640                                  ;	****** ASSUMPTION ******
  6641                                  ;	we assume that we have less than 256 heads, and that the Request
  6642                                  ;	Header Data Structure is unneccessarily big
  6643 00001725 2EA2[B301]              		mov	[cs:CURHD],al
  6644 00001729 268B4705                		mov	ax,[es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
  6645 0000172D 268B4F07                		mov	cx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
  6646 00001731 26C45F09                		les	bx,[es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
  6647 00001735 E80100                  		call	TrackIO
  6648 00001738 C3                      		retn
  6649                                  ; ---------------------------------------------------------------------------
  6650                                  ;
  6651                                  ; TrackIO:
  6652                                  ;    Performs Track Read/Write/Verify
  6653                                  ;
  6654                                  ;   Input:
  6655                                  ;      RFLAG	- 2 = Read
  6656                                  ;		  3 = Write
  6657                                  ;		  4 = Verify
  6658                                  ;      ax	- Index into track table of first sector to IO
  6659                                  ;      cx	- number of sectors to IO
  6660                                  ;      es:bx	- Transfer address
  6661                                  ;      ds:di	- pointer to BDS
  6662                                  ;      curtrk	- current cylinder
  6663                                  ;      curhd	- current head
  6664                                  ;
  6665                                  ; ---------------------------------------------------------------------------
  6666                                  
  6667                                  TrackIO:
  6668                                  ; procedure `disk' will pop stack to SPsav and return if error
  6669 00001739 2E8926[B601]            		mov	[cs:SPSAV], sp
  6670                                  ; Ensure correct disk is in drive
  6671 0000173E E8BEF7                  		call	CHECKSINGLE
  6672                                  ;
  6673                                  ; Set up tables and variables for I/O
  6674                                  ;
  6675 00001741 2E803E[AF06]01          		cmp	byte [cs:Media_Set_For_Format],1
  6676 00001747 7407                    		jz	short DPTAlreadySet
  6677                                  ;
  6678                                  ; SET UP TABLES AND VARIABLES FOR I/O
  6679                                  ;
  6680 00001749 50                      		push	ax
  6681 0000174A 51                      		push	cx
  6682 0000174B E8EFF8                  		call	IOSETUP
  6683 0000174E 59                      		pop	cx
  6684 0000174F 58                      		pop	ax
  6685                                  ;
  6686                                  ; point si at the table entry of the first sector to be IO'd
  6687                                  ;
  6688                                  DPTAlreadySet:
  6689 00001750 BE[B005]                		mov	si,TrackTable
  6690 00001753 D1E0                    		shl	ax,1
  6691 00001755 D1E0                    		shl	ax,1
  6692 00001757 01C6                    		add	si,ax
  6693                                  ;
  6694                                  ; we want:
  6695                                  ;    cx to be the number of times we have to loop
  6696                                  ;    dx to be the number of sectors we read on each iteration
  6697 00001759 BA0100                  		mov	dx,1
  6698 0000175C F745230800              		test	word [DI+BDS.flags],GOOD_TRACKLAYOUT
  6699 00001761 7402                    		jz	short IOnextSector
  6700                                  
  6701                                  ; Hey! we can read all the sectors in one blow
  6702 00001763 87D1                    		xchg	dx, cx
  6703                                  
  6704                                  IOnextSector:
  6705 00001765 51                      		push	cx
  6706 00001766 52                      		push	dx
  6707                                  ; skip over the cylinder and head in the track table
  6708 00001767 46                      		inc	si
  6709 00001768 46                      		inc	si
  6710                                  
  6711                                  ; Get sector id from track table
  6712 00001769 2E8A04                  		mov     AL,[cs:si]	; get current sector value
  6713 0000176C 2EA2[B201]              		mov     [cs:CURSEC], AL	; save cursec value
  6714                                          
  6715                                  ;*** For a Fixed disk multi-track disk I/O -  4/14/86
  6716                                  ;Assumptions: 1). In the input CX (# of sectors to go) to TRACKIO, only CL is
  6717                                  ;valid.  2). Sector size should be set to 512 bytes. 3). GOODTRACKLAYOUT.
  6718                                  ;
  6719 00001770 F745230100              		test	word [DI+BDS.flags],fNon_Removable ;Fixed disk? - J.K
  6720 00001775 740E                    		jz	short IOREMOVABLE		;no -
  6721 00001777 2E8916[A401]            		mov	[cs:SECCNT], dx 		;# of sectors to I/O -
  6722 0000177C 89D0                    		mov	ax, dx				;		 
  6723 0000177E E85DF9                  		call	DISK				;		
  6724 00001781 5A                      		pop	dx				;		 
  6725 00001782 59                      		pop	cx				;		
  6726 00001783 F8                      		clc					;		
  6727 00001784 C3                      		retn					;		
  6728                                  
  6729                                  IOREMOVABLE:		 
  6730 00001785 2E8A4401                        	mov     AL,[cs:si+1]	; get sector size index
  6731                                  
  6732                                  		; The next eight lines put sector size index in DPT
  6733 00001789 06                      		push    ES                      ; save value while getting pointer
  6734 0000178A 56                      		push    SI                      ;    to DPT
  6735 0000178B 50                      		push	AX
  6736                                  
  6737 0000178C 2EC436[AE01]            		les     SI,[cs:DPT]		; ES:SI points to DPT
  6738                                                                                  ; put size in DPT
  6739 00001791 26884403                		mov     [ES:SI+DISK_PARMS.DISK_SECTOR_SIZ], AL
  6740 00001795 8B4513                  		mov     AX,[DI+BDS.secpertrack]        ; get number of sector/track
  6741 00001798 26884404                		mov     [ES:SI+DISK_PARMS.DISK_EOT],AL ; patch in DPT
  6742                                  
  6743 0000179C 58                      		pop	AX			; restore register values
  6744 0000179D 5E                      		pop     SI     
  6745 0000179E 07                      		pop     ES
  6746                                                                          ; convert index to byte value
  6747 0000179F E82200                  		call    SectorSizeIndexToSectorSize
  6748 000017A2 50                      		push    AX                      ; save number of bytes in sector
  6749 000017A3 89D0                    		mov     AX, DX                  ; get number of sector for I/0
  6750                                  
  6751                                  DoTheIO:
  6752 000017A5 2EA3[A401]              		mov	[cs:SECCNT],ax	; set up the count of sectors to I/O
  6753 000017A9 E832F9                  		call	DISK		
  6754                                  					; advance buffer pointer by adding
  6755                                  					;   sector size
  6756 000017AC 58                      		pop	ax
  6757 000017AD 01C3                    		add	bx, ax
  6758 000017AF 5A                      		pop	dx
  6759 000017B0 59                      		pop	cx
  6760 000017B1 E2B2                    		loop	IOnextSector
  6761 000017B3 E8C7F8                  		call	DONE		; Set time of last access, and reset
  6762 000017B6 F8                      		clc			; entries in DPT.
  6763 000017B7 C3                      		retn
  6764                                  
  6765                                  ; ---------------------------------------------------------------------------
  6766                                  ;
  6767                                  ; The sector size in bytes needs to be converted to an index value for the IBM
  6768                                  ; ROM. (0=>128, 1=>256,2=>512,3=>1024). It is assumed that only these values
  6769                                  ; are permissible.
  6770                                  ; On Input   AX contains sector size in bytes
  6771                                  ; On Output  AL contains index
  6772                                  ;
  6773                                  ; ---------------------------------------------------------------------------
  6774                                  
  6775                                  SectorSizeToSectorIndex:
  6776 000017B8 80E407                  		and     AH, 07h 	; very simple error correction
  6777 000017BB 88E0                    		mov     AL, AH          ; shift left 8 bits
  6778 000017BD 3C04                    		cmp     AL, 4           ; size 1024?
  6779 000017BF 7502                    		jnz	short SecToIndexRet ; no, then we are done
  6780 000017C1 2C01                    		sub     AL, 1           ; if 1024, adjust index to 3
  6781                                  SecToIndexRet:
  6782 000017C3 C3                      		retn
  6783                                  
  6784                                  SectorSizeIndexToSectorSize:
  6785                                  ; value in AH on entry is not important
  6786 000017C4 51                      		push    CX              ; save CX value
  6787 000017C5 88C1                    		mov     CL, AL          ; use index number as shift size
  6788 000017C7 B88000                  		mov     AX, 0080h       ; set AX to 128
  6789 000017CA D3E0                    		shl     AX, CL          ; shift by index to get proper value
  6790 000017CC 59                      		pop     CX              ; restore CX value
  6791 000017CD C3                      		retn
  6792                                  
  6793                                  ; ---------------------------------------------------------------------------
  6794                                  ;
  6795                                  ; Set up the ROM for formatting.
  6796                                  ; we have to tell the ROM BIOS what type of disk is in the drive.
  6797                                  ; On Input   - DS:DI - points to BDS
  6798                                  ;
  6799                                  ; ---------------------------------------------------------------------------
  6800                                  
  6801                                  SetDASD:
  6802                                  ; See if we have new ROM and have issues Set Media Type For Format call
  6803 000017CE 2EF606[AF06]01                  	test    byte [cs:Media_Set_For_Format],1
  6804 000017D4 7549                    		jnz	short DasdHasBeenSet
  6805                                  ; See if we have previously set DASD type
  6806 000017D6 2E803E[B006]01          		cmp	byte [cs:Had_Format_Error],1
  6807 000017DC 740C                    		je	short DoSetDasd
  6808 000017DE F745238000              		test    word [DI+BDS.flags],SET_DASD_true
  6809 000017E3 743A                    		jz	short DasdHasBeenSet
  6810 000017E5 8165237FFF              		and     word [DI+BDS.flags],~SET_DASD_true
  6811                                                  ; the next nine lines determine and put the DASD type in AL
  6812                                  DoSetDasd:
  6813 000017EA 2EC606[B006]00          		mov	byte [cs:Had_Format_Error],0
  6814 000017F0 2EC606[BC01]50                  	mov	byte [cs:GAP_PATCH],50h	; assume 48tpi or 3.5" drive
  6815 000017F6 807D2202                        	cmp     byte [DI+BDS.formfactor],ffSmall ; is 3.5" drive?
  6816 000017FA 7504                            	jnz	short Not35Drive	; no, skip down
  6817 000017FC B004                            	mov     AL,04h			; yes set proper DASD value
  6818 000017FE EB18                    		jmp     short Do_Set            ; jump down
  6819                                  
  6820                                  Not35Drive:
  6821 00001800 B001                    		mov     AL,01h			;
  6822 00001802 807D2201                		cmp     byte [DI+BDS.formfactor],ff96tpi; 96tpi disk drive?
  6823 00001806 7510                    		jnz	short Do_Set		; no skip down to rom call
  6824 00001808 FEC0                    		inc     AL                      ; reflect 96tpi drive in DASD type
  6825 0000180A 807D130F                		cmp     byte [DI+BDS.secpertrack],15 ; 96tpi media in drive?
  6826 0000180E 7508                    		jnz	short Do_Set		; no, skip down to rom call
  6827 00001810 FEC0                    		inc     AL                      ; reflect 96tpi media in DASD type
  6828 00001812 2EC606[BC01]54          		mov	byte [cs:GAP_PATCH],54h ;  and in the GAP_PATCH
  6829                                  Do_Set:
  6830 00001818 B417                    		mov     AH,17h			; set command to Set DASD type
  6831 0000181A 8A5504                  		mov     DL,[DI+BDS.drivenum]	; set drive number
  6832 0000181D CD13                    		int     13h                     ; call rom-bios
  6833                                  DasdHasBeenSet:
  6834 0000181F 8A6513                  		mov     ah,[DI+BDS.secpertrack]
  6835 00001822 2E8826[B801]            		mov	[cs:FORMT_EOT],ah
  6836 00001827 C3                      		retn
  6837                                  
  6838                                  ; ---------------------------------------------------------------------------
  6839                                  ;
  6840                                  ; This routine is called if an error occurs while formatting or verifying.
  6841                                  ; It resets the drive, and decrements the retry count.
  6842                                  ; On Entry - DS:DI - points to BDS for the drive
  6843                                  ;	     BP    - contains retry count
  6844                                  ; On Exit    Flags indicate result of decrementing retry count
  6845                                  ;
  6846                                  ;
  6847                                  ;  There are some drives that "lose" the changeline indication if another
  6848                                  ;  floppy drive is accessed before the changeline is recorded by the device
  6849                                  ;  driver. In this situation, it is possible for the ROM to also not detect
  6850                                  ;  that the medium has changed. So, the end result is that we could have a
  6851                                  ;  diskette in the drive for which we can not even read the boot sector.
  6852                                  ;  We "fix" this by setting the byte at location DISK_STATE_MACHINE_DRV_0 (hex)
  6853                                  ;  for physical drive 0 (or DISK_STATE_MACHINE_DRV_1 for drive 1) to 0 (See
  6854                                  ;  IBM PC/AT "blessed" addresses Document for explanation). This tells the ROM
  6855                                  ;  that the medium is 'unknown'. The ROM actually uses these locations for
  6856                                  ;  itself.  Note that we do this only for internal drives; we do not do this for
  6857                                  ;  fixed disks or for physical drives > 1. We may end up corrupting some
  6858                                  ;  other bytes in memory that may be used for something else.
  6859                                  ;  NOTE: We do not stuff this byte if the last operation was a FORMAT because
  6860                                  ;  the ROM loses track of what it is trying to format!!
  6861                                  ;
  6862                                  ;  This routine was changed to only stuff 61H when the drive indicated it
  6863                                  ;  supported changeline. The Phoenix ROM was taking a very long time
  6864                                  ;  to figure out what the media was which caused disk time outs to take
  6865                                  ;  forever
  6866                                  ;
  6867                                  ;  We assume that DS:DI points to the current BDS for this drive.
  6868                                  ;	no registers should be touched
  6869                                  ;
  6870                                  ; ---------------------------------------------------------------------------
  6871                                  
  6872                                  AGAIN:
  6873 00001828 E80200                  		call	ResetDisk
  6874 0000182B 4D                      		dec	bp		; decrement retry count
  6875 0000182C C3                      		RETN
  6876                                  
  6877                                  ResetDisk:
  6878 0000182D 50                      		push	ax
  6879 0000182E 30E4                    		xor	AH, AH			; set command to reset disk
  6880 00001830 CD13                    		int	13h			; call the rom-bios
  6881 00001832 58                      		pop	ax
  6882 00001833 2EC606[1101]FF          		mov	byte [cs:STEP_DRV],-1	; zap up the speed
  6883 00001839 C3                      		retn
  6884                                  
  6885                                  ; ---------------------------------------------------------------------------
  6886                                  ;
  6887                                  ; This routine sets up the Drive Parameter Table with the values needed for
  6888                                  ; Format, does an Int 13. Values in DPT are restored after a VERIFY is done.
  6889                                  ;
  6890                                  ; On Entry  -	DS:DI - points to BDS for the drive
  6891                                  ;		ES:BX - points to TRKBUF
  6892                                  ;		AL    - number of sectors
  6893                                  ;		AH    - Int 13 function code
  6894                                  ;		CL    - Sector number for verify
  6895                                  ; On Exit   -	DS,DI,ES,BX remain unchanged.
  6896                                  ;		ax and flags are the results of the int 13
  6897                                  ;
  6898                                  ; ---------------------------------------------------------------------------
  6899                                  
  6900                                  To_ROM:
  6901 0000183A 1E                      		push	ds
  6902 0000183B 57                      		push	di
  6903 0000183C 06                      		push	es
  6904 0000183D 53                      		push	bx
  6905 0000183E 56                      		push	si
  6906                                  
  6907                                  ; The below line was replaced because saving the DPT is predicated upon
  6908                                  ; whether the functionality of the new ROM was used, not if it exists.
  6909                                  ;		test	byte ptr cs:[NEW_ROM],1
  6910                                  
  6911 0000183F 2EF606[AF06]01          		test	byte [cs:Media_Set_For_Format],1
  6912 00001845 753D                    		jnz	short Got_Valid_DPT
  6913                                  
  6914                                  ; Set up values in the DPT
  6915                                  ; Set up motor start correctly for 3.5" drives.
  6916 00001847 50                      		push	ax
  6917 00001848 1E                      		push	ds
  6918                                  
  6919 00001849 31C0                    		xor	ax,ax
  6920 0000184B 8ED8                    		mov	ds,ax
  6921 0000184D C5367800                		lds	si,[DSKADR]	; DS:SI := pDPT
  6922                                  
  6923 00001851 2E8936[AE01]            		mov	[cs:DPT],si
  6924 00001856 2E8C1E[B001]            		mov	[cs:DPT+2],ds	; Save pDPT
  6925                                  
  6926 0000185B 1F                      		pop     ds
  6927 0000185C 06                      		push    ES		; save value in ES
  6928 0000185D 2EC436[AE01]            		LES     SI,[CS:DPT]
  6929                                  
  6930 00001862 8B5513                  		mov     DX,[DI+BDS.secpertrack] ; set the sector per track in
  6931 00001865 26885404                		mov     [es:si+DISK_PARMS.DISK_EOT],DL	; the Disk Parameter Table
  6932 00001869 83FA0F                  		cmp     DX, 15                  ; 96tip media?
  6933 0000186C 7409                    		jz	short To_ROM1		; yes, skip down
  6934                                                                  ; no - set Format Gap to 320/360 media value
  6935 0000186E 2E8A0E[BC01]            		mov     CL,[cs:GAP_PATCH]
  6936 00001873 26884C07                		mov     [ES:SI+DISK_PARMS.DISK_FORMT_GAP],CL
  6937                                  To_ROM1:                                ; 3.5" floppy drive?
  6938 00001877 807D2202                		cmp     byte [DI+BDS.formfactor],ffSmall
  6939 0000187B 7505                    		jnz	short To_ROM2	; no, skip down
  6940                                                                  ; yes - reset disk motor start value
  6941 0000187D 26C6440A04              		mov     byte [ES:SI+DISK_PARMS.DISK_MOTOR_STRT],4
  6942                                  To_ROM2:
  6943 00001882 07                      		pop     ES		; restore ES value
  6944 00001883 58                      		pop     ax
  6945                                  
  6946                                  Got_Valid_DPT:
  6947                                   					; now set up the registers
  6948 00001884 8A5504                          	mov     DL,[DI+BDS.drivenum] ; set drive number
  6949 00001887 2E8A36[B901]                    	mov     DH,[CS:HDNUM]	; set head number
  6950 0000188C 2E8B0E[BA01]            		mov     CX,[CS:TRKNUM]	; set track number
  6951 00001891 D0CD                    		ror     CH,1
  6952 00001893 D0CD                    		ror     CH,1
  6953 00001895 86E9                    		xchg    CH,CL
  6954 00001897 CD13                    		int     13h		; call the rom-bios disk routines
  6955 00001899 5E                      		pop	si
  6956 0000189A 5B                      		pop	bx
  6957 0000189B 07                      		pop	es
  6958 0000189C 5F                      		pop	di
  6959 0000189D 1F                      		pop	ds
  6960 0000189E C3                      		retn
  6961                                  
  6962                                  ; ---------------------------------------------------------------------------
  6963                                  ;
  6964                                  ; Get the owner of the physical drive represented by the logical drive in BL.
  6965                                  ; The assumption is that we **ALWAYS** keep track of the owner of a drive!!
  6966                                  ; If this is not the case, the system may hang, just following the linked list.
  6967                                  ;
  6968                                  ; ---------------------------------------------------------------------------
  6969                                  
  6970                                  IOCTL$GETOWN:
  6971 0000189F E8D3F2                  		call	SETDRIVE
  6972 000018A2 8A4504                  		mov	al,[DI+BDS.drivenum]	; Get physical drive number
  6973 000018A5 0E                      		push	cs
  6974 000018A6 1F                      		pop	ds
  6975 000018A7 BF[9A01]                		mov	di,START_BDS
  6976                                  Own_Loop:
  6977 000018AA 384504                  		cmp	[DI+BDS.drivenum],al
  6978 000018AD 7507                    		jne	short GetNextBDS
  6979 000018AF F745232000              		test	word [DI+BDS.flags],fI_Own_Physical
  6980 000018B4 7509                    		jnz	short Done_GetOwn
  6981                                  GetNextBDS:
  6982 000018B6 8B5D02                  		mov	bx,[DI+BDS.link+2]
  6983                                  		;mov	di,[DI+BDS.link]
  6984 000018B9 8B3D                    		mov	di,[di] ; 05/07/2019
  6985 000018BB 8EDB                    		mov	ds,bx
  6986 000018BD EBEB                    		jmp	short Own_Loop
  6987                                  Done_GetOwn:
  6988 000018BF EB1D                    		JMP	SHORT EXIT_OWN
  6989                                  
  6990                                  ; ---------------------------------------------------------------------------
  6991                                  ;
  6992                                  ; Set the ownership of the physical drive represented by the logical drive in
  6993                                  ; BL.
  6994                                  ;
  6995                                  ; ---------------------------------------------------------------------------
  6996                                  
  6997                                  IOCTL$SETOWN:
  6998 000018C1 E8B1F2                  		call	SETDRIVE
  6999 000018C4 2EC606[1501]01          		mov	byte [cs:fSetOwner],1	; set flag for CheckSingle to
  7000                                  						; look at.
  7001 000018CA E832F6                  		call	CHECKSINGLE		; Set ownership of drive
  7002 000018CD 2EC606[1501]00          		mov	byte [cs:fSetOwner],0	; reset flag
  7003 000018D3 31DB                    		xor	bx,bx
  7004 000018D5 8EC3                    		mov	es,bx
  7005 000018D7 B1FF                    		mov	cl,-1
  7006 000018D9 26880E0405              		mov	byte [es:LSTDRV],cl 	; Set up SDSB as well
  7007                                  
  7008                                  EXIT_OWN:
  7009                                  ; If there is only one logical drive assigned to this physical drive, return
  7010                                  ; 0 to user to indicate this.
  7011 000018DE 30C9                    		xor	cl,cl
  7012 000018E0 F745231000              		test	word [DI+BDS.flags],fI_Am_Mult
  7013 000018E5 7405                    		jz	short EXIT_NO_MULT
  7014 000018E7 8A4D05                  		mov	cl,[DI+BDS.drivelet]	; Get logical drive number
  7015 000018EA FEC1                    		inc	cl			; get it 1-based
  7016                                  EXIT_NO_MULT:
  7017 000018EC 2EC51E[B000]            		LDS	BX,[CS:PTRSAV]
  7018 000018F1 884F01                  		mov	[BX+UNIT],CL
  7019 000018F4 E970EF                  		jmp	EXIT
  7020                                  
  7021                                  ;
  7022                                  ; Moves the old DPT that had been saved in TempDPT back to DPT. This is done
  7023                                  ; only if the first byte of TempDPT is not -1.
  7024                                  ; All registers (including flags) are preserved.
  7025                                  ;
  7026                                  
  7027                                  RestoreOldDPT:
  7028                                  ; If we have already restored the disk base table earlier, do not do it
  7029                                  ; again.
  7030 000018F7 50                      		push	ax
  7031 000018F8 30C0                    		xor	al,al
  7032                                  ; Reset flag and get current flag setting
  7033 000018FA 2EA2[B006]              		mov	[cs:Had_Format_Error],al
  7034 000018FE 2E8606[AF06]            		xchg	[cs:Media_Set_For_Format],al
  7035 00001903 08C0                    		or	al,al
  7036 00001905 7419                    		jz	short DontRestore
  7037 00001907 56                      		push	si
  7038 00001908 1E                      		push	ds
  7039 00001909 06                      		push	es
  7040 0000190A 2EC536[B106]            		LDS	SI,[CS:TempDPT]
  7041 0000190F 31C0                    		xor	ax,ax
  7042 00001911 8EC0                    		mov	es,ax			; have ES -> segment 0
  7043 00001913 2689367800              		MOV	[ES:DSKADR],SI
  7044 00001918 268C1E7A00              		MOV	[ES:DSKADR+2],DS
  7045                                  GotCurrentDPT:
  7046 0000191D 07                      		pop	es
  7047 0000191E 1F                      		pop	ds
  7048 0000191F 5E                      		pop	si
  7049                                  DontRestore:
  7050 00001920 58                      		pop	ax
  7051 00001921 F8                      		clc				; clear carry
  7052 00001922 C3                      		retn				; (7/31/86)
  7053                                  
  7054                                  ;end of file msioctl.asm
  7055                                  
  7056                                  ; ............................................................................
  7057                                  
  7058                                  ;-----------------------------------------------------------------------------
  7059                                  ; MSDISK.ASM (2) - MSDOS 3.3 - 02/02/1988
  7060                                  ;-----------------------------------------------------------------------------
  7061                                  ; 28/05/2018 - Retro DOS v3.0
  7062                                  ; 24/03/2018 - Retro DOS v2.0 
  7063                                  
  7064                                  ;
  7065                                  ; Check_Wrap is a routine that adjusts the starting sector, starting head
  7066                                  ; and starting cylinder for an Int 13 request that requests I/O of a lot
  7067                                  ; of sectors. It only does this for fixed disks. It is used in the sections
  7068                                  ; of code that handle ECC errors and DMA errors. It is necessary, because
  7069                                  ; ordinarily the ROM would take care of wraps around heads and cylinders,
  7070                                  ; but we break down a request when we get an ECC or DMA error into several
  7071                                  ; I/O of one or more sectors. In this case, we may already be beyond the
  7072                                  ; number of sectors on a track on the medium, and the request would fail.
  7073                                  ;
  7074                                  ; Input conditions:
  7075                                  ;	ALL registers set up for an Int 13 request.
  7076                                  ;
  7077                                  ; Output:
  7078                                  ;	 - contains starting head number for request
  7079                                  ;	 - contains starting sector and cylinder numbers
  7080                                  ;	(The above may or may not have been changed, and are 0-based)
  7081                                  ;	All other registers preserved.
  7082                                  ;
  7083                                  
  7084                                  Check_Wrap:
  7085 00001923 50                      		push	ax
  7086 00001924 53                      		push	bx
  7087 00001925 1E                      		push	ds
  7088 00001926 57                      		push	di
  7089                                  		
  7090                                  		; 17/07/2019 - Retro DOS v3.2
  7091                                  		;mov	byte [cs:PHYS_DRV],1;Use phys. drive in AL to get BDS
  7092                                  		;mov	al,dl		; put drive number in AL for get BDS
  7093                                  		;call	SETDRIVE	; Get pointer to BDS for drive.
  7094                                  		;mov	byte [cs:PHYS_DRV],0; Restore flag to use Logical Drive
  7095                                  		;jc	short No_Wrap	; Do nothing if wrong phys. drive
  7096                                  
  7097 00001927 E85FF2                  		call	find_bds ; 17/07/2019
  7098 0000192A 725E                    		jc	short No_Wrap
  7099                                  
  7100 0000192C F745230100              		test	word [DI+BDS.flags],fNon_Removable
  7101 00001931 7457                    		jz	short No_Wrap	; No wrapping for removable media
  7102                                  
  7103 00001933 8B5D13                  		MOV	BX,[DI+BDS.secpertrack]
  7104 00001936 89C8                    		MOV	AX,CX
  7105 00001938 83E03F                  		AND	AX,3Fh		; EXTRACT SECTOR NUMBER
  7106 0000193B 39D8                    		cmp	ax,bx		; If Wrap
  7107 0000193D 764B                    		jbe	short No_Wrap
  7108                                  
  7109 0000193F F6F3                    		div	bl		; AH=new sector#, AL = # of head wraps
  7110                                  
  7111                                  ; We need to be careful here.  If the new sector number == 0, then we are
  7112                                  ; on the last sector on that track
  7113                                  
  7114 00001941 08E4                    		or	ah,ah
  7115 00001943 7504                    		jnz	short Not_on_Bound
  7116                                  
  7117 00001945 88DC                    		mov	ah,bl	; set sector = SECLIM (BDS.secpertrack) if on Bndry
  7118 00001947 FEC8                    		dec	al		; and decrement Num. head wraps
  7119                                  Not_on_Bound:
  7120 00001949 80E1C0                  		and	CL,0C0h		; zero out sector #
  7121 0000194C 08E1                    		or	CL,AH		; OR in new sector #
  7122 0000194E 30E4                    		xor	ah,ah		; AX = # of head wraps
  7123 00001950 40                      		inc	ax
  7124 00001951 00F0                    		add	al,DH		; add in starting head #
  7125 00001953 80D400                  		adc	ah,0		; catch any carry
  7126 00001956 3B4515                  		CMP	AX,[DI+BDS.heads] ; are we going to wrap around a head?
  7127 00001959 7635                    		jbe	short No_Wrap_Head ; Do not lose new head number!!
  7128                                  
  7129 0000195B 52                      		push	DX		; preserve drive number and head number
  7130 0000195C 31D2                    		xor	dx,dx
  7131 0000195E 8B5D15                  		mov	bx,[DI+BDS.heads]
  7132 00001961 F7F3                    		div	bx		; DX=new head #, AX=# of cylinder wraps
  7133                                  
  7134                                  ; Careful here! If new head # is 0, then we are on the last head.
  7135                                  
  7136 00001963 09D2                    		or	dx,dx
  7137 00001965 7507                    		jnz	short No_Head_Bound
  7138                                  
  7139 00001967 89DA                    		mov	dx,bx		; On boundary. Set to HDLIM (BDS.heads)
  7140                                  
  7141                                  ; If we had some cylinder wraps, we need to reduce them by one!!
  7142                                  
  7143 00001969 09C0                    		or	ax,ax
  7144 0000196B 7401                    		jz	short No_Head_Bound
  7145                                  
  7146 0000196D 48                      		dec	ax		; Reduce number of cylinder wraps
  7147                                  No_Head_Bound:
  7148 0000196E 88D7                    		mov	bh,dl		; bh has new head number
  7149 00001970 5A                      		POP	DX		; restore drive number and head number
  7150                                  
  7151 00001971 FECF                    		dec	bh		; get it 0-based
  7152 00001973 88FE                    		mov	DH,bh		; set up new head number in DH
  7153                                  
  7154 00001975 88CF                    		mov	bh,CL
  7155 00001977 80E73F                  		and	bh,3FH		; preserve sector number
  7156 0000197A B306                    		mov	bl,6
  7157 0000197C 86CB                    		xchg	cl,bl
  7158 0000197E D2EB                    		shr	bl,cl		; get ms cylinder bits to ls end
  7159                                  
  7160 00001980 00C5                    		ADD	CH,AL		; ADD IN CYLINDER WRAP
  7161 00001982 10E3                    		adc	bl,ah		; add in high byte
  7162 00001984 D2E3                    		shl	bl,cl		; move up to ms end
  7163 00001986 86D9                    		xchg	bl,cl		; restore cylinder bits into CL
  7164 00001988 08F9                    		or	CL,bh		; OR in sector number
  7165                                  No_Wrap:
  7166 0000198A F8                      		clc			; reset carry
  7167 0000198B 5F                      		pop	di
  7168 0000198C 1F                      		pop	ds
  7169 0000198D 5B                      		pop	bx
  7170 0000198E 58                      		pop	ax
  7171 0000198F C3                      		retn
  7172                                  
  7173                                  No_Wrap_Head:
  7174 00001990 88C6                    		mov	DH,al		; Do not lose new head number
  7175 00001992 FECE                    		dec	DH		; get it 0-based
  7176 00001994 EBF4                    		jmp	short No_Wrap
  7177                                  
  7178                                  ; INT_2F_13:
  7179                                  ;		This code is chained into the INT_2F interrupt during bios
  7180                                  ;	initialization. It allows the user to change the ORIG13 int_13 vector
  7181                                  ;	after booting. This allows testing and implementation of custom int_13
  7182                                  ;	handlers, without giving up MS-DOS error recovery
  7183                                  ;
  7184                                  ;	Entry Conditions
  7185                                  ;		AH	== RESET_Int_13  (13h)
  7186                                  ;		DS:DX	== Address of New INT_13 Handler
  7187                                  ;		ES:BX	== Address of New INT_13 vector used by WARM BOOT
  7188                                  ;								(INT 19)
  7189                                  ;
  7190                                  ;	Exit Conditions
  7191                                  ;		Orig13	== Address of new Int_13 Handler
  7192                                  ;		DS:DX	== Old ORIG13 value
  7193                                  ;		ES:BX	== Old OLD13  value
  7194                                  
  7195                                  INT_2F_13:
  7196 00001996 80FC13                  		cmp	AH,13h			; IF (interrupt_value != Reset_Int_13)
  7197 00001999 7405                    		je	short Chg_Orig13
  7198 0000199B 2EFF2E[9601]            		jmp	far [CS:NEXT2F_13]	;    THEN Continue on Int_2F chain
  7199                                  
  7200                                  Chg_Orig13:					;    ELSE
  7201 000019A0 2EFF36[B806]            		push	word [CS:ORIG13]	;	 Save Old value of OLD13 and
  7202 000019A5 2EFF36[BA06]            		push	word [CS:ORIG13+2]	;	 ORIG13 so that we can
  7203                                  
  7204 000019AA 2EFF36[C206]            		push	word [CS:OLD13]		;	 Return them to caller
  7205 000019AF 2EFF36[C406]            		push	word [CS:OLD13+2]
  7206                                  
  7207 000019B4 2E8916[B806]            		mov	word [CS:ORIG13],DX	;	 Orig13 := Addr. Of New INT_13
  7208                                  						;	             		Vector
  7209 000019B9 2E8C1E[BA06]            		mov	word [CS:ORIG13+2],DS
  7210                                  
  7211 000019BE 2E891E[C206]            		mov	word [CS:OLD13],BX	;	 Old13 := Addr. Of New
  7212                                  						;			  Boot_13 vector
  7213 000019C3 2E8C06[C406]            		mov	word [CS:OLD13+2],ES
  7214                                  
  7215 000019C8 07                      		pop	ES			;	 ES:BX := Old OLD13 vector
  7216 000019C9 5B                      		pop	BX
  7217                                  
  7218 000019CA 1F                      		pop	DS			;	 DS:DX := Old ORIG13 vector
  7219 000019CB 5A                      		pop	DX
  7220                                  
  7221 000019CC CF                      		iret				;    END else
  7222                                  
  7223                                  ;--------------------------------------------------------------------------
  7224                                  
  7225                                  ;	move a 512 byte sector from ds:si to es:di, do not trash cx
  7226                                  ;	  but go ahead and update direction flag, si, & di
  7227                                  
  7228                                  ;move_sector:
  7229                                  
  7230                                  Move:
  7231                                  		; 17/07/2019 - MSDOS 3.3
  7232                                  
  7233 000019CD 51                      		push	CX
  7234 000019CE B90001                  		mov	CX,512/2
  7235 000019D1 FC                      		cld
  7236 000019D2 F3A5                    		rep	MOVSW
  7237 000019D4 59                      		pop	CX
  7238 000019D5 C3                      		retn
  7239                                  
  7240                                  		; 17/07/2019 - MSDOS 6.0
  7241                                  
  7242                                  ;	The 80386 microprocessor considers an access to WORD 0FFFFH in
  7243                                  ;	  any segment to be a fault. Theoretically, this could be handled
  7244                                  ;	  by the fault handler and the behavior of an 8086 could be emulated
  7245                                  ;	  by wrapping the high byte to offset 0000h. This would be a lot
  7246                                  ;	  of work and was, indeed, blown off by the Win386 guys. COMPAQ
  7247                                  ;	  also handles the fault incorrectly in their ROM BIOS for real
  7248                                  ;	  mode. Their fault handler was only designed to deal with one
  7249                                  ;	  special case which occurred in a magazine benchmark, but didn't
  7250                                  ;	  handle the general case worth beans.
  7251                                  ;
  7252                                  ;	Simply changing this code to do a byte loop would work okay but
  7253                                  ;	  would involve a general case performance hit. Therefore, we'll
  7254                                  ;	  check for either source or destination offsets being within one
  7255                                  ;	  sector of the end of their segments and only in that case fall
  7256                                  ;	  back to a byte move.
  7257                                  
  7258                                  ;		cld
  7259                                  ;		push	cx
  7260                                  ;		mov	cx,512/2	; number of words in a sector
  7261                                  ;
  7262                                  ;		cmp	si,0FE00h
  7263                                  ;		ja	short movsec_bytes
  7264                                  ;		cmp	di,0FE00h
  7265                                  ;		ja	short movsec_bytes
  7266                                  ;
  7267                                  ;		rep	movsw
  7268                                  ;		pop	cx
  7269                                  ;		retn
  7270                                  ;movsec_bytes:
  7271                                  ;		shl	cx,1		; get number of bytes
  7272                                  ;		rep	movsb
  7273                                  ;		pop	cx
  7274                                  ;		retn
  7275                                  
  7276                                  ;--------------------------------------------------------------------------
  7277                                  
  7278                                  DoINT:
  7279 000019D6 8A5608                  		mov	DL,[BP+INT13FRAME.olddx] ; get physical drive number
  7280 000019D9 30E4                    		xor	AH,AH
  7281 000019DB 08C0                    		or	AL,AL
  7282 000019DD 740F                    		jz	short DoIntDone		; if zero sectors, return ax=0
  7283 000019DF 8A6603                  		mov	AH,[BP+INT13FRAME.oldax+1] ; get request code
  7284 000019E2 FF760E                  		push	word [BP+INT13FRAME.oldf]
  7285 000019E5 2EFF1E[B806]            		call	far [CS:ORIG13]
  7286 000019EA 9C                      		pushf
  7287 000019EB 8F460E                  		pop	word [BP+INT13FRAME.oldf]
  7288                                  DoIntDone:
  7289 000019EE C3                      		retn
  7290                                  
  7291                                  ;
  7292                                  ; Int 2f handler for external block drivers to communicate with the internal
  7293                                  ; block driver in msdisk. The multiplex number chosen is 8. The handler
  7294                                  ; sets up the pointer to the request packet in [PTRSAV] and then jumps to
  7295                                  ; DSK$IN, the entry point for all disk requests.
  7296                                  ; On exit from this driver (at EXIT), we will return to the external driver
  7297                                  ; that issued this Int 2F, and can then remove the flags from the stack.
  7298                                  ; This scheme allows us to have a small external device driver, and makes
  7299                                  ; the maintainance of the various drivers (DRIVER and msBIO) much easier,
  7300                                  ; since we only need to make changes in one place (most of the time).
  7301                                  ;
  7302                                  ; AL contains the Int2F function:
  7303                                  ;   0 - Check for installed handler - RESERVED
  7304                                  ;   1 - Install the BDS into the linked list
  7305                                  ;   2 - DOS request
  7306                                  ;
  7307                                  
  7308                                  MYNUM		EQU	8
  7309                                  
  7310                                  INT2F_DISK:
  7311 000019EF 80FC08                  		cmp	ah,MYNUM
  7312 000019F2 7405                    		je	short Mine
  7313 000019F4 2EFF2E[5007]            		jmp	far [cs:INT_2F_NEXT]	; chain to next Int 2F handler
  7314                                  Mine:
  7315 000019F9 3CF8                    		cmp	al,0F8H 		; IRET on reserved functions
  7316 000019FB 7201                    		jb	short Do_Func
  7317 000019FD CF                      		IRET
  7318                                  Do_Func:
  7319 000019FE 08C0                    		or	al,al			; A GET INSTALLED STATE request?
  7320 00001A00 7503                    		jne	short Disp_Func
  7321 00001A02 B0FF                    		mov	al,0FFH
  7322 00001A04 CF                      		IRET
  7323                                  Disp_Func:
  7324 00001A05 3C01                    		cmp	al,1			; Request for installing BDS?
  7325 00001A07 7504                    		jne	short Do_DOS_Req
  7326 00001A09 E81A00                  		call	INSTALL_BDS
  7327 00001A0C CF                      		IRET
  7328                                  Do_DOS_Req:
  7329                                  ; Set up pointer to request packet
  7330 00001A0D 2E891E[B000]            		MOV	[CS:PTRSAV],BX
  7331 00001A12 2E8C06[B200]            		MOV	[CS:PTRSAV+2],ES
  7332 00001A17 E9DCED                  		jmp	DSK$IN
  7333                                  
  7334                                  ; 29/06/2019 - Retro DOS v3.1
  7335                                  
  7336                                  ;*************************************************************************
  7337                                  
  7338                                  DSK$INIT:	; 29/05/2018 - Retro DOS v3.0
  7339 00001A1A 0E                      		PUSH	CS
  7340 00001A1B 1F                      		POP	DS
  7341                                  
  7342 00001A1C 8A26[1001]              		MOV	AH,[DRVMAX]
  7343 00001A20 BF[1C07]                		MOV	DI,DSKDRVS
  7344 00001A23 E966F2                  		JMP	SetPTRSAV
  7345                                  
  7346                                  ; ---------------------------------------------------------------------------
  7347                                  ;
  7348                                  ; Install_BDS installs a BDS a location DS:DI into the current linked list of
  7349                                  ; BDS maintained by this device driver. It places the BDS at the END of the
  7350                                  ; list.
  7351                                  ;
  7352                                  ; ---------------------------------------------------------------------------
  7353                                  
  7354                                  INSTALL_BDS:
  7355                                  		; 17/07/2019 - Retro DOS v3.2
  7356                                  
  7357 00001A26 1E                      		push	ds		; save Bios_Data segment
  7358 00001A27 BE[9A01]                		mov	si,START_BDS	; beginning of chain
  7359                                  
  7360                                  ;	ds:si now points to link to first bds
  7361                                  ;	  assume bds list is non-empty
  7362                                  
  7363                                  loop_next_bds:
  7364                                  		;lds	si,[si+BDS.link]	; fetch next bds
  7365 00001A2A C534                    		lds	si,[si]
  7366 00001A2C 268A4504                		mov	al,[es:di+BDS.drivenum]	; does this one share a physical
  7367 00001A30 384404                  		cmp	[si+BDS.drivenum],al	;  drive with new one?
  7368 00001A33 7518                    		jne	short next_bds
  7369                                  
  7370 00001A35 B310                    		mov	bl,fI_Am_Mult ; 10h	; set both of them to i_am_mult if so
  7371 00001A37 26085D23                		or	[es:di+BDS.flags],bl
  7372 00001A3B 085C23                  		or	[si+BDS.flags],bl
  7373                                  		; 01/06/2019
  7374                                  		;and 	byte [es:di+BDS.flags],0DFh
  7375 00001A3E 26806523DF              		and	byte [es:di+BDS.flags],~fI_Own_Physical ; we don't own it
  7376                                  
  7377 00001A43 8A5C23                  		mov	bl,[si+BDS.flags]	; determine if changeline available
  7378 00001A46 80E302                  		and	bl,fChangeline  ; 2
  7379 00001A49 26085D23                		or	[es:di+BDS.flags],bl
  7380                                  next_bds:
  7381                                  		;cmp	word [si+BDS.link],-1	; are we at end of list?
  7382 00001A4D 833CFF                  		cmp	word [si],-1
  7383 00001A50 75D8                    		jne	short loop_next_bds
  7384                                  
  7385 00001A52 8C4402                  		mov	[si+BDS.link+2],es	; install bds
  7386                                  		;mov	[si+BDS.link],di
  7387 00001A55 893C                    		mov	[si],di
  7388                                  		;mov	word [es:di+BDS.link],-1 ; set next pointer to null
  7389 00001A57 26C705FFFF              		mov	word [es:di],-1
  7390 00001A5C 1F                      		pop	ds			; restore Bios_Data
  7391                                  
  7392                                  ;	**** If the new drive has a higher EOT value, we must alter the
  7393                                  ;	     'EOT' variable appropriately.
  7394                                  
  7395                                  		; 01/06/2019
  7396                                  		;mov	al,[es:di+52]
  7397 00001A5D 268A4534                		mov	al,[es:di+BDS.rsecpertrack]
  7398                                  
  7399 00001A61 3A06[AC01]              		cmp	al,[EOT]
  7400 00001A65 7603                    		jbe	short _eot_ok
  7401 00001A67 A2[AC01]                		mov	[EOT],al
  7402                                  _eot_ok:
  7403 00001A6A C3                      		retn
  7404                                  ; ---------------------------------------------------------------------------
  7405                                  ;
  7406                                  ; RE_INIT installs the Int 2F vector that will handle communication between
  7407                                  ; external block drivers and the internal driver. It also installs the
  7408                                  ; Reset_Int_13 interface. It is called by SYSYINIT
  7409                                  ;
  7410                                  ; ---------------------------------------------------------------------------
  7411                                  
  7412                                  RE_INIT:
  7413 00001A6B 50                      		PUSH	AX
  7414 00001A6C 1E                      		PUSH	DS
  7415 00001A6D 57                      		PUSH	DI
  7416 00001A6E 31FF                    		XOR	DI,DI
  7417 00001A70 8EDF                    		MOV	DS,DI
  7418 00001A72 BFBC00                  		MOV	DI,2FH*4		; point it to Int 2F Vector
  7419 00001A75 8B05                    		MOV	AX,[DI]
  7420 00001A77 2EA3[5007]              		MOV	[CS:INT_2F_NEXT],AX
  7421 00001A7B 8B4502                  		MOV	AX,[DI+2]		; preserve old Int 2F vector
  7422 00001A7E 2EA3[5207]              		MOV	[CS:INT_2F_NEXT+2],AX
  7423                                  
  7424                                  ; INSTALL the Reset_Int_13
  7425                                  ; interface
  7426 00001A82 FA                      		CLI
  7427 00001A83 C705[9619]              		MOV	word [DI],INT_2F_13	; install new vectors
  7428 00001A87 8C4D02                  		MOV	[DI+2],CS
  7429 00001A8A FB                      		STI
  7430 00001A8B 5F                      		POP	DI
  7431 00001A8C 1F                      		POP	DS
  7432 00001A8D 58                      		POP	AX
  7433 00001A8E CB                      		RETF
  7434                                  
  7435                                  ;---------------------------------------------------------------------------
  7436                                  ;
  7437                                  ;  Ask to swap the disk in drive A:
  7438                                  ; Using a different drive in a one drive system so
  7439                                  ; request the user to change disks
  7440                                  ;
  7441                                  ;---------------------------------------------------------------------------
  7442                                  
  7443                                  SWPDSK:		; 29/05/2018 - Retro DOS v3.0
  7444                                  
  7445                                  		; 13/04/2018
  7446                                  		; 09/04/2018
  7447                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  7448                                  
  7449 00001A8F 8A4505                  		mov	al,[DI+BDS.drivelet]	; get the drive letter
  7450 00001A92 0441                    		add	al,"A"
  7451 00001A94 2EA2[D41A]              		mov	[cs:DRVLET],AL
  7452                                  
  7453 00001A98 1E                      		push	ds			; preserve segment register
  7454 00001A99 0E                      		push	cs
  7455 00001A9A 1F                      		pop	ds
  7456 00001A9B BE[B81A]                		mov	SI,SNGMSG		; ds:si -> message
  7457 00001A9E 53                      		push	BX
  7458                                  
  7459 00001A9F E80A00                  		call	WRMSG			;Print disk change message
  7460 00001AA2 E862EE                  		call	FLUSH
  7461                                  						; wait for a keyboard character
  7462 00001AA5 30E4                    		xor	AH,AH			; set command to read character
  7463 00001AA7 CD16                    		int	16h			; call rom-bios
  7464 00001AA9 5B                      		POP	BX
  7465 00001AAA 1F                      		pop	ds			; restore segment register
  7466                                  WRMRET:
  7467 00001AAB C3                      		retn
  7468                                  
  7469                                  ;----------------------------------------------
  7470                                  ;
  7471                                  ;  WrMsg writes out message pointed to by [SI]
  7472                                  ;
  7473                                  ;----------------------------------------------
  7474                                  
  7475                                  WRMSG:
  7476 00001AAC AC                      		lodsb				; get the next character of the message
  7477 00001AAD 08C0                    		or	AL,AL			; see if end of message
  7478 00001AAF 74FA                    		jz	short WRMRET
  7479 00001AB1 9C                      		pushf
  7480 00001AB2 0E                      		push	CS
  7481 00001AB3 E8C5ED                  		call	OUTCHR
  7482 00001AB6 EBF4                    		jmp	SHORT WRMSG
  7483                                  
  7484                                  
  7485                                  ;	INCLUDE BIOMES.INC
  7486                                  
  7487                                  ; BIOMES.INC - 24/07/1987
  7488                                  ;----------------------------------------------------------------------------
  7489                                  ;
  7490                                  ; Single drive message for msbio.com. Nul terminated.
  7491                                  ;
  7492                                  
  7493 00001AB8 0D0A496E7365727420-     SNGMSG:	DB	0Dh,0Ah,"Insert diskette for drive "
  7493 00001AC1 6469736B6574746520-
  7493 00001ACA 666F72206472697665-
  7493 00001AD3 20                 
  7494 00001AD4 413A20616E64207374-     DRVLET:	DB	"A: and strike",0Dh,0Ah,"any key when ready",0Dh,0Ah,0Ah,0
  7494 00001ADD 72696B650D0A616E79-
  7494 00001AE6 206B6579207768656E-
  7494 00001AEF 2072656164790D0A0A-
  7494 00001AF8 00                 
  7495                                  
  7496                                  ; 19/07/2019 - Retro DOS v3.2
  7497                                  ;----------------------------------------------------------------------------
  7498                                  
  7499                                  ; 01/06/2018 - Retro DOS v3.0
  7500                                  
  7501                                  ; End of support for multiple floppies with no logical drives
  7502                                  ; This is not 'special' any more because we now have the capability of
  7503                                  ; defining logical drives in CONFIG.SYS. We therefore keep the code for
  7504                                  ; swapping resident ALL the time.
  7505                                  
  7506                                  ;;Rev 3.30 modification ----------------------------
  7507                                  ;Variables for Dynamic Relocatable modules
  7508                                  ;These should be stay resident.
  7509                                  
  7510 00001AF9 00000000                INT6C_RET_ADDR:	DD	0	; ret add from INT 6C for P12 mach
  7511                                  
  7512                                  ;
  7513                                  ;   DATA STRUCTURES FOR REAL-TIME DATE AND TIME
  7514                                  ;
  7515                                  
  7516                                  BIN_DATE_TIME:
  7517 00001AFD 00                      	DB	0		; CENTURY (19 OR 20) OR HOURS (0-23)
  7518 00001AFE 00                      	DB	0		; YEAR IN CENTURY (0-99) OR MINUTES (0-59)
  7519 00001AFF 00                      	DB	0		; MONTH IN YEAR (1-12) OR SECONDS (0-59)
  7520 00001B00 00                      	DB	0		; DAY IN MONTH (1-31)
  7521                                  MONTH_TABLE:
  7522 00001B01 0000                    	DW	0		;MJB002 JANUARY
  7523 00001B03 1F00                    	DW	31		;MJB002 FEBRUARY
  7524 00001B05 3B00                    	DW	59		;MJB002
  7525 00001B07 5A00                    	DW	90		;MJB002
  7526 00001B09 7800                    	DW	120		;MJB002
  7527 00001B0B 9700                    	DW	151		;MJB002
  7528 00001B0D B500                    	DW	181		;MJB002
  7529 00001B0F D400                    	DW	212		;MJB002
  7530 00001B11 F300                    	DW	243		;MJB002
  7531 00001B13 1101                    	DW	273		;MJB002
  7532 00001B15 3001                    	DW	304		;MJB002
  7533 00001B17 4E01                    	DW	334		;MJB002
  7534                                  DAYCNT2:
  7535 00001B19 0000                    	DW	0		;MJB002 TEMP FOR CNT OF DAYS SINCE 1-1-80
  7536                                  FEB29:
  7537 00001B1B 00                      	DB	0		;MJB002 FEBRUARY 29 IN A LEAP YEAR FLAG
  7538                                  
  7539                                  ;;End of modification ------------------------------
  7540                                  
  7541                                  ;----------------------------------------------------------------------------
  7542                                  
  7543                                  EndFloppy:
  7544                                  
  7545                                  ;
  7546                                  ; End of code for virtual floppy drives
  7547                                  ;
  7548                                  
  7549                                  EndSwap:
  7550                                  
  7551                                  HNUM:	
  7552 00001B1C 00                      	DB	0			; number of hardfile (hard drives)
  7553                                  HARDDRV:
  7554 00001B1D 80                      	DB	80H			;Physical drive number of first hardfile
  7555                                  
  7556                                  ; 16/07/2019
  7557                                  
  7558                                  ; include ms96tpi.inc
  7559                                  
  7560                                  ; MS96TPI.INC - 24/07/1987
  7561                                  ;----------------------------------------------------------------------------
  7562                                  ; 01/06/2018 - Retro DOS v3.0
  7563                                  ; 25/03/2018 - Retro DOS v2.0
  7564                                  
  7565                                  ;------------------------------------------------------------------------
  7566                                  ;									:
  7567                                  ; File: ms96tpi.asm							:
  7568                                  ;									:
  7569                                  ; This file contains code to support the 96 tpi drives. The code	:
  7570                                  ; is included in the bio if the machine has at least one drive with	:
  7571                                  ; changeline support. If the machine has no changeline drives then	:
  7572                                  ; the code is not kept in the bio at system initialization time.	:
  7573                                  ;									:
  7574                                  ;------------------------------------------------------------------------
  7575                                  
  7576                                  ;------------------------------------------------------------------------
  7577                                  ;									:
  7578                                  ;		DISK OPEN/CLOSE ROUTINES				:
  7579                                  ;									:
  7580                                  ;------------------------------------------------------------------------
  7581                                  
  7582                                  		; 19/07/2019
  7583                                  DSK$OPEN:					; AL is logical drive
  7584 00001B1E 2E803E[1201]00          		cmp	byte [cs:fHave96],0
  7585 00001B24 7406                    		jz	short dsk_open_exit ; done if no changeline support
  7586                                  
  7587 00001B26 E84CF0                  		call	SETDRIVE		; Get BDS for drive
  7588 00001B29 FF4520                  		inc	WORD [DI+BDS.opcnt]
  7589                                  dsk_open_exit:
  7590 00001B2C E938ED                  		jmp	EXIT
  7591                                  
  7592                                  DSK$CLOSE:					; AL is logical drive
  7593 00001B2F 2E803E[1201]00          		cmp	byte [cs:fHave96],0 ; done if no changeline support
  7594 00001B35 740B                    		jz	short EXITJX
  7595                                  
  7596 00001B37 E83BF0                  		call	SETDRIVE		; Get BDS for drive
  7597                                  		; 19/07/2019
  7598                                  		;cmp	WORD [DI+BDS.opcnt],0
  7599 00001B3A E80800                  		call	ChkOpCnt
  7600 00001B3D 7403                    		jz	short EXITJX		; Watch out for wrap
  7601 00001B3F FF4D20                  		dec	WORD [DI+BDS.opcnt]
  7602                                  EXITJX:
  7603 00001B42 E922ED                  		jmp	EXIT
  7604                                  
  7605                                  ;
  7606                                  ; ChkOpCnt checks the number of open files on drive.
  7607                                  ;
  7608                                  ; Input : DS:DI points to current BDS for drive.
  7609                                  ;
  7610                                  ; Return : zero set if no open files
  7611                                  ;	   zero reset if open files
  7612                                  ;
  7613                                  
  7614                                  ChkOpCnt:
  7615 00001B45 837D2000                		cmp	WORD [DI+BDS.opcnt],0
  7616 00001B49 C3                      		retn
  7617                                  
  7618                                  ;
  7619                                  ; At media check time, we need to really get down and check what the change is.
  7620                                  ; This is GUARANTEED to be expensive.
  7621                                  ;
  7622                                  ; On entry AL contains logical drive number
  7623                                  ;
  7624                                  
  7625                                  MediaCheck:
  7626                                  		; 01/06/2018 - Retro DOS v3.0
  7627                                  
  7628                                  		; 13/04/2018
  7629                                  		; 08/04/2018
  7630                                  		; Retro DOS v2.0
  7631                                  
  7632 00001B4A E8B2F3                  		call	CHECKSINGLE	; make sure correct disk is in place
  7633 00001B4D 31F6                    		xor	SI,SI
  7634 00001B4F E85701                  		call	HasChange
  7635 00001B52 742E                    		jz	short MediaRet
  7636 00001B54 E84701                  		call	CheckROMChange
  7637 00001B57 752A                    		jnz	short MediaDoVolId
  7638 00001B59 50                      		push	AX
  7639 00001B5A 52                      		push	DX
  7640                                  					; see if changeline has been triggered
  7641                                  ;;Rev 3.30 Modification
  7642 00001B5B 8A5504                  		mov	DL,[DI+BDS.drivenum] ; set logical drive number	  
  7643 00001B5E B416                    		mov	AH,16h		; get changeline status	  
  7644 00001B60 CD13                    		int	13h		; call rom diskette routine	  
  7645                                  ;;End of Modification
  7646 00001B62 5A                      		pop	DX
  7647 00001B63 58                      		pop	AX
  7648 00001B64 721D                    		jc	short MediaDoVolId ; if changeline was triggered jmp
  7649 00001B66 BE0100                  		mov	SI,1		; else signal no change
  7650                                  
  7651                                  ; There are some drives with changeline that "lose" the changeline indication
  7652                                  ; if a different drive is accessed after the current one. In order to avoid
  7653                                  ; missing a media change, we return an "I don't know" to DOS if the changeline
  7654                                  ; is not active AND we are accessing a different drive from the last one.
  7655                                  ; If we are accessing the same drive, then we can safely rely on the changeline
  7656                                  ; status.
  7657                                  
  7658 00001B69 2E8A1E[9F01]            		mov	bl,[cs:TIM_DRV] ; get last drive accessed
  7659 00001B6E 385D04                  		cmp	byte [DI+BDS.drivenum],bl
  7660 00001B71 740F                    		jz	short MediaRet
  7661                                  
  7662                                  ; Do the 2 second twiddle. If time >= 2 seconds, do a volid check.
  7663                                  ; Otherwise return "I don't know" (Strictly speaking, we should return a
  7664                                  ; "Not Changed" here since the 2 second test said no change.) - RS.
  7665                                  
  7666 00001B73 50                      		push	ax
  7667 00001B74 51                      		push	cx
  7668 00001B75 52                      		push	dx
  7669 00001B76 E89FF0                  		call	CHECK_TIME_OF_ACCESS
  7670 00001B79 5A                      		pop	dx
  7671 00001B7A 59                      		pop	cx
  7672 00001B7B 58                      		pop	ax
  7673 00001B7C 09F6                    		or	si,si
  7674 00001B7E 7403                    		jz	short MediaDoVolId ; Check_Time says ">= 2 secs passed"
  7675 00001B80 31F6                    		xor	si,si		; return "I don't know"
  7676                                  MediaRet:
  7677 00001B82 C3                      		retn
  7678                                  
  7679                                  ; 01/06/2018 - Retro DOS v3.0
  7680                                  
  7681                                  ;
  7682                                  ; MediaDoVolid: if this is called somehow the media was changed. Look at
  7683                                  ; VID to see. We do not look at FAT because this may be different since we
  7684                                  ; only set MedByt when doing a READ or WRITE.
  7685                                  ;
  7686                                  
  7687                                  MediaDoVolId:
  7688 00001B83 E88CF1                  		call	GETBP		; build a new BPB in current BDS
  7689 00001B86 72FA                    		jc	short MediaRet
  7690 00001B88 E82C00                  		call	Check_VID
  7691 00001B8B 73F5                    		jnc	short MediaRet
  7692                                  		;call	MAPERROR	; fix up AL for return to DOS
  7693                                  		;retn
  7694                                  		; 19/07/2019
  7695 00001B8D E9A5F6                  		jmp	MAPERROR	
  7696                                  
  7697                                  ;
  7698                                  ; Checklatchio:
  7699                                  ;
  7700                                  ; Simple, quick check of latched change. If no indication, then return
  7701                                  ; otherwise do expensive check. If the expensive test fails, POP off the
  7702                                  ; return and set AL = 15 (for invalid media change) which will be returned to
  7703                                  ; DOS.
  7704                                  ;
  7705                                  
  7706                                  CheckLatchIO:
  7707                                  ; If returning fake BPB then assume the disk has not changed
  7708                                  ;		test	word [DI+BDS.flags],RETURN_FAKE_BPB
  7709                                  ;		jnz	short CheckRet
  7710                                  ;;Rev 3.30 Modification
  7711                                  		; 19/07/2019 - Retro DOS v3.2
  7712                                  		;call	HasChange		;change line supported?
  7713                                  		;jz	short CheckRet		;No. Just return
  7714                                  ;;End of Modification
  7715 00001B90 E8B2FF                  		call	ChkOpCnt
  7716                                  		; 19/07/2019
  7717                                  		;jnz	short CheckROM
  7718                                  ;CheckRet:
  7719                                  ;		retn
  7720 00001B93 741A                    		jz	short CheckRet
  7721                                  ;
  7722                                  ; Check for past ROM indications. If no ROM change indicated, then return OK.
  7723                                  ;
  7724                                  
  7725                                  CheckROM:
  7726 00001B95 E80601                  		call	CheckROMChange
  7727 00001B98 7415                    		jz	short CheckRet		; no change
  7728                                  ;
  7729                                  ; We now see that a change line has been seen in the past.  Let's do the
  7730                                  ; expensive verification.
  7731                                  ;
  7732 00001B9A E875F1                  		call	GETBP			; build BPB in current BDS
  7733 00001B9D 720F                    		jc	short Ret_No_Error_Map	; GETBP has already called MapError
  7734 00001B9F E81500                  		call	Check_VID
  7735 00001BA2 7207                    		jc	short CheckLatchRet	; disk error trying to read in.
  7736 00001BA4 09F6                    		or	SI,SI			; Is changed for sure?
  7737 00001BA6 7907                    		jns	short CheckRet
  7738 00001BA8 E87C00                  		call	ReturnVID
  7739                                  CheckLatchRet:
  7740 00001BAB E887F6                  		call	MAPERROR		; fix up AL for return to DOS
  7741                                  		; cf = 1  ; 19/07/2019
  7742                                  Ret_No_Error_Map:
  7743                                  		;stc				; indicate an error
  7744 00001BAE 5E                      		pop	si			; pop off return address
  7745                                  		; 19/07/2019
  7746                                  CheckRet:
  7747 00001BAF C3                      		retn
  7748                                  
  7749                                  ;
  7750                                  ;  CheckFatVID:
  7751                                  ;
  7752                                  ; Check the FAT and the VID. Return in DI -1 or 0. Return with carry set
  7753                                  ; ONLY if there was a disk error. Return that error code in AX.
  7754                                  ;
  7755                                  
  7756                                  CheckFATVID:
  7757 00001BB0 E8F301                  		call	FAT_CHECK
  7758 00001BB3 09F6                    		or	SI,SI
  7759 00001BB5 7826                    		js	short Changed_Drv
  7760                                  ;
  7761                                  ; The the fat was the same. Fall into check_vid and check volume id.
  7762                                  ;
  7763                                  
  7764                                  		; 19/07/2019 - Retro DOS v3.2
  7765                                  
  7766                                  ; (MSDOS 6.0)
  7767                                  ;now with the extended boot record, the logic should be enhanced.
  7768                                  ;
  7769                                  ;if it is the extended boot record, then we check the volume serial
  7770                                  ;number instead of volume id. if it is different, then set si to -1.
  7771                                  ;
  7772                                  ;if it is same, then si= 1 (no change).
  7773                                  ;
  7774                                  ;if it is not the extended boot record, then just follows the old
  7775                                  ;logic. dos 4.00 will check if the # of fat in the boot record bpb
  7776                                  ;is not 0.  if it is 0 then it must be non_fat based system and
  7777                                  ;should have already covered by extended boot structure checking.
  7778                                  ;so, we will return "i don't know" by setting si to 0.
  7779                                  ;
  7780                                  ;this routine assume the newest valid boot record is in cs:[disksector].
  7781                                  ;(this will be gauranteed by a successful getbp call right before this
  7782                                  ;routine.)
  7783                                  ;
  7784                                  ;	called with ds:di -> bds ; 19/07/2019
  7785                                  
  7786                                  Check_VID:
  7787                                  		; 19/07/2019 - Retro DOS v3.2
  7788                                  		; (MSDOS 6.0)
  7789                                  
  7790                                  ;	check the disksector.EXT_BOOT_SIG variable for the extended
  7791                                  ;	   boot signature. if it is set then go to do the extended
  7792                                  ;	   id check otherwise continue with code below
  7793                                  
  7794 00001BB7 2E803E[F601]29          		cmp	byte [cs:DiskSector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
  7795 00001BBD 7425                    		je	short do_ext_check_id
  7796                                  
  7797 00001BBF E8E700                  		call	HasChange
  7798 00001BC2 74EB                    		jz	short CheckRet
  7799                                  
  7800 00001BC4 31F6                    		xor	si,si			; assume i don't know.
  7801 00001BC6 2E803E[E001]00          		cmp	byte [cs:DiskSector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS],0 
  7802                                  						; don't read vol id
  7803 00001BCC 7415                    		je	short CheckFatRet	; from the directory if not
  7804                                  						; fat system
  7805                                  		
  7806                                  		; (MSDOS 3.3)
  7807                                  
  7808 00001BCE E81201                  		call	Read_Volume_ID
  7809 00001BD1 7210                    		jc	short CheckFatRet
  7810 00001BD3 E8B901                  		call	Check_Volume_ID
  7811                                  
  7812 00001BD6 09F6                    		or	SI,SI
  7813 00001BD8 7503                    		jnz	short Changed_Drv ; si = -1
  7814                                  ;vid_no_changed:
  7815                                  		; 19/07/2019
  7816                                  		;call	ResetChanged
  7817 00001BDA E9C700                  		jmp	ResetChanged
  7818                                  ;CheckFatRet:
  7819                                  ;		retn
  7820                                  Changed_Drv:
  7821 00001BDD 2EC606[9F01]FF          		mov	byte [cs:TIM_DRV],-1 	; Ensure that we ask ROM for media
  7822                                  CheckFatRet:					; check next time round
  7823 00001BE3 C3                      		retn
  7824                                  
  7825                                  ;---------------------------------------------------------------------------
  7826                                  
  7827                                  ; 19/07/2019 - Retro DOS v3.2
  7828                                  
  7829                                  ; extended id check
  7830                                  
  7831                                  ;***************************************************************************
  7832                                  ;	the code to check extended id is basically a check to see if the
  7833                                  ;	volume serial number is still the same. the volume serial number
  7834                                  ;	previously read is in cs:disksector.EXT_BOOT_SERIAL
  7835                                  ;	ds:di points to the bds of the
  7836                                  ;	drive under consideration. the bds has fields containing the
  7837                                  ;	high and low words of the volume serial number of the media in the
  7838                                  ;	drive. compare these fields to the fields mentioned above. if these
  7839                                  ;	fields do not match the media has changed and so we should jump
  7840                                  ;	to the code starting at ext_changed else return "i don't know" status
  7841                                  ;	in the register used for the changeline status and continue executing
  7842                                  ;	the code given below. for temporary storage use the register which
  7843                                  ;	has been saved and restored around this block.
  7844                                  ;
  7845                                  ;	bds fields in inc\msbds.inc
  7846                                  
  7847                                  do_ext_check_id:
  7848                                  		; 19/07/2019
  7849 00001BE4 2E8B36[F701]            		mov	si,[cs:DiskSector+EXT_BOOT.SERIAL]
  7850 00001BE9 3B7557                  		cmp	si,[di+BDS.vol_serial]
  7851 00001BEC 750F                    		jne	short ext_changed
  7852 00001BEE 2E8B36[F901]            		mov	si,[cs:DiskSector+EXT_BOOT.SERIAL+2]
  7853 00001BF3 3B7559                  		cmp	si,[di+BDS.vol_serial+2]
  7854 00001BF6 7505                    		jne	short ext_changed
  7855 00001BF8 31F6                    		xor	si,si ; si = 0		; don't know
  7856                                  		;jmp	short vid_no_changed	; reset the flag
  7857 00001BFA E9A700                  		jmp	ResetChanged ; 19/07/2019
  7858                                  ext_changed:					; serial number is different!
  7859 00001BFD BEFFFF                  		mov	si,-1			; disk changed!
  7860 00001C00 F8                      		clc			; clear carry. only si is meaningful here.
  7861 00001C01 EBDA                    		jmp	short Changed_Drv
  7862                                  
  7863                                  ;
  7864                                  ; CheckIO: At I/O time the rom-bios returned an error. We need to
  7865                                  ; determine if the error is due to a media change. If error code is not
  7866                                  ; change-line error (06h) we just return. We pop off the call and jmp to
  7867                                  ; harderr if we see an error.
  7868                                  ;
  7869                                  ;   On entry: AH contains error code returned from rom-bios.
  7870                                  ;
  7871                                  
  7872                                  CheckIO:
  7873 00001C03 80FC06                  		cmp	AH,6			; change line error?
  7874 00001C06 75DB                    		jnz	short CheckFatRet	; no - just return
  7875 00001C08 E83AFF                  		call	ChkOpCnt
  7876 00001C0B 74D6                    		jz	short CheckFatRet	; no open files
  7877                                  
  7878                                  ; If returning fake BPB then ignore disk changes
  7879                                  ;		test	word [DI+BDS.flags],RETURN_FAKE_BPB
  7880                                  ;		jnz	short IgnoreChange
  7881                                  
  7882 00001C0D E802F1                  		call	GETBP			; build up a new BPB in current BDS
  7883 00001C10 7212                    		jc	short No_Error_Map	; GETBP has already called MapError
  7884 00001C12 E89BFF                  		call	CheckFATVID
  7885 00001C15 7209                    		jc	short CheckIORet	; disk error trying to read in.
  7886 00001C17 09F6                    		or	SI,SI			; Is changed for sure?
  7887 00001C19 7802                    		js	short CheckIOErr	; yes changed
  7888                                  IgnoreChange:
  7889 00001C1B 45                      		inc	BP			; allow a retry
  7890 00001C1C C3                      		retn
  7891                                  CheckIOErr:
  7892 00001C1D E80700                  		call	ReturnVID
  7893                                  CheckIORet:
  7894 00001C20 F9                      		stc				; make sure carry gets passed through
  7895 00001C21 E9CFF5                  		jmp	HARDERR
  7896                                  No_Error_Map:
  7897 00001C24 E9CFF5                  		jmp	HARDERR2
  7898                                  
  7899                                  ;
  7900                                  ; Return VID sets up the VID for a return to DOS.
  7901                                  ;
  7902                                  
  7903                                  ReturnVID:
  7904 00001C27 1E                      		push	DS			; save pointer to current BDS
  7905 00001C28 57                      		push	di
  7906 00001C29 51                      		push	cx
  7907 00001C2A E88901                  		call	init_vid_loop		; Sets ES:DI -> vid
  7908 00001C2D 2EC51E[B000]            		lds	BX,[cs:PTRSAV]
  7909 00001C32 897F16                  		mov	[BX+EXTRA],DI
  7910 00001C35 8C4718                  		mov	[BX+EXTRA+2],ES
  7911 00001C38 59                      		pop	cx
  7912 00001C39 5F                      		pop	di			; restore current BDS
  7913 00001C3A 1F                      		pop	DS
  7914                                  ;;		MOV	AH,6			; INVALID MEDIA CHANGE
  7915 00001C3B B40F                    		mov	AH,0Fh			; set error as 'invalid media change'
  7916 00001C3D F9                      		stc				; indicate error by setting carry flag
  7917 00001C3E C3                      		retn
  7918                                  
  7919                                  ;
  7920                                  ; Media_Set_VID:
  7921                                  ;
  7922                                  ; Moves the pointer to the volid for the drive into the original request packet
  7923                                  ; On entry, DS:BX points to the original packet.
  7924                                  ; No attempt is made to preserve registers.
  7925                                  ;
  7926                                  
  7927                                  MEDIA_SET_VID:
  7928 00001C3F E87401                  		call	init_vid_loop		; Sets ES:DI -> vid
  7929 00001C42 2EC51E[B000]            		lds	bx,[cs:PTRSAV]		; get pointer to packet
  7930 00001C47 897F0F                  		mov	[BX+TRANS+1],DI
  7931 00001C4A 8C4711                  		mov	[BX+TRANS+3],ES
  7932                                  DoFloppy:		; 19/07/2019
  7933 00001C4D C3                      		retn
  7934                                  
  7935                                  ;
  7936                                  ;   HiDensity - examine a drive/media descriptor to set the media type. If
  7937                                  ;   the media descriptor is NOT F9 (not 96tpi or 3 1/2), we return and let the
  7938                                  ;   caller do the rest. Otherwise, we pop off the return and jump to the tail
  7939                                  ;   of GETBP. For 3.5" media, we just return.
  7940                                  ;
  7941                                  ;   Inputs:	DS:DI point to correct BDS for this drive
  7942                                  ;		AH has media byte
  7943                                  ;
  7944                                  ;   Outputs:	Carry clear
  7945                                  ;		    No registers modified
  7946                                  ;		Carry set
  7947                                  ;		    AL = sectors/fat
  7948                                  ;		    BH = number of root directory entries
  7949                                  ;		    BL = sectors per track
  7950                                  ;		    CX = number of sectors
  7951                                  ;		    DH = sectors per allocation unit
  7952                                  ;		    DL = number of heads
  7953                                  ;
  7954                                  
  7955                                  hidensity:
  7956                                  ; Check for correct drive
  7957                                  ;
  7958 00001C4E F745230200              		test	word [DI+BDS.flags],fChangeline	; is it special?
  7959 00001C53 74F8                    		jz	short DoFloppy		; no, do normal floppy test
  7960                                  ;
  7961                                  ; We have a media byte that is pretty complex. Examine drive information
  7962                                  ; table to see what kind it is.
  7963                                  ;
  7964 00001C55 807D2202                		cmp	byte [DI+BDS.formfactor],ffSmall ; Is it single-media?
  7965 00001C59 74F2                    		jz	short DoFloppy		; yes, use fatid...
  7966                                  ;
  7967                                  ; 96 tpi drive
  7968                                  ;
  7969 00001C5B 80FCF9                  		cmp	AH,0F9h
  7970 00001C5E 75ED                    		jnz	short DoFloppy
  7971                                  
  7972                                  		; 20/07/2019 - Retro DOS v3.2
  7973                                  		; (MSDOS 6.0)
  7974                                  
  7975                                  	;------ If formfactor of drive = ffother or ff288 it has to be
  7976                                  	;------ a 720K diskette
  7977                                  
  7978 00001C60 807D2207                		cmp	byte [di+BDS.formfactor],ffOther
  7979 00001C64 7417                    		je	short Is720K
  7980                                  
  7981 00001C66 807D2209                		cmp	byte [di+BDS.formfactor],ff288
  7982 00001C6A 7411                    		je	short Is720K
  7983                                  
  7984                                  		; (MSDOS 3.3 & MSDOS 6.0)
  7985                                  		
  7986 00001C6C B007                    		mov	al,7			; seven sectors / fat
  7987 00001C6E BB0FE0                  		mov	bx,224*256+0Fh		; 224 root dir entries & 0f sector max
  7988 00001C71 B96009                  		mov	cx,80*15*2		; 80 tracks, 15 sectors/track, 2 sides
  7989 00001C74 BA0201                  		mov	dx,1*256+2		; sectors/allocation unit & head max
  7990                                  popr:
  7991 00001C77 83C402                  		add	SP,2			; pop off return address
  7992 00001C7A E915F1                  		jmp	HAS1_res		; return to tail of GETBP
  7993                                  
  7994                                  		; 19/07/2019
  7995                                  Is720K:
  7996 00001C7D 83C402                  		add	sp,2			; pop off return address
  7997 00001C80 E9C2F0                  		jmp	Has720K			; return to 720K code
  7998                                  		; 19/07/2019
  7999                                  ;DoFloppy:
  8000                                  ;		retn
  8001                                  
  8002                                  ; 18/07/2019 - Retro DOS v3.2
  8003                                  ;;
  8004                                  ;; Certain poorly designed programs avoid DOS altogether and use INT 13 directly.
  8005                                  ;; These programs even retry operations and, thus, will ignore the disk change
  8006                                  ;; logic.
  8007                                  ;;
  8008                                  ;; We hook INT 13 and note all errors.
  8009                                  ;;
  8010                                  ;
  8011                                  ;REAL13:		dd	0
  8012                                  ;OLDINT:		dd	0
  8013                                  ;DMY:		dw	0
  8014                                  ;
  8015                                  ;INT13:
  8016                                  ;		; 16/06/2018
  8017                                  ;		pop	word [cs:OLDINT]
  8018                                  ;		pop	word [cs:OLDINT+2]
  8019                                  ;		pop	word [cs:DMY]
  8020                                  ;		pushf
  8021                                  ;		call	far [cs:REAL13]	; simulate another INT 13
  8022                                  ;		jc	short Err13	; did an error occur?
  8023                                  ;		jmp	far [cs:OLDINT]	; no, return and pop off flags
  8024                                  ;Err13:
  8025                                  ;		pushf			; save state
  8026                                  ;		cmp	AH,06h		; is error a 'change' error?
  8027                                  ;		jz	short GotErr	; yes, jump down
  8028                                  ;_B:		
  8029                                  ;		popf			; no, some other error, ignore it ;;End of Modification
  8030                                  ;		jmp	far [cs:OLDINT]	; return and pop off flags
  8031                                  ;
  8032                                  ;GotErr: 	
  8033                                  ;		or	DL,DL		; is this for the hard disk?
  8034                                  ;		js	short _B	; yes, ignore
  8035                                  ;		
  8036                                  ;		; 17/07/2019 - Retro DOS v3.2
  8037                                  ;		;mov	word [cs:FlagBits],fChanged
  8038                                  ;		push	bx
  8039                                  ;		mov	bx,fChanged
  8040                                  ;		call	Set_Changed_DL
  8041                                  ;		pop	bx
  8042                                  ;		jmp	short _B
  8043                                  
  8044                                  ;
  8045                                  ; Set_Changed_DL - Sets flag bits according to bits set in [FlagBits].
  8046                                  ;		   Essentially used to indicate Changeline, or Format.
  8047                                  ;
  8048                                  ;   Inputs:	DL contains physical drive number
  8049                                  ;		[FlagBits] contains bits to set in the flag field in the BDSs
  8050                                  ;   Outputs:	None
  8051                                  ;   Registers modified: Flags
  8052                                  ;
  8053                                  		; 17/07/2019 - Retro DOS v3.2
  8054                                  Set_Changed_DL:
  8055                                  		; bx = flag bits ; *
  8056                                  
  8057                                  		;push	BX
  8058                                  		;push	DX
  8059                                  		;mov	BL,DL
  8060                                  ALL_SET:
  8061                                  		;mov	dx,[cs:FlagBits] ; get bits to set in flag field
  8062                                  		;xor	BH,BH
  8063                                  		
  8064                                  		;mov	bx,[cs:FlagBits] ; * ; 17/07/2019
  8065                                  ;
  8066                                  ; In the virtual drive system we *must* flag the other drives as being changed
  8067                                  ;
  8068                                  ; assume first BDS is in this segment
  8069                                  		;push	ax
  8070 00001C83 1E                      		push	ds		; save current BDS
  8071 00001C84 57                      		push	di
  8072 00001C85 2EC53E[9A01]            		lds	di,[cs:START_BDS]
  8073                                  Scan_BDS:
  8074 00001C8A 83FFFF                  		cmp	di,-1
  8075 00001C8D 740C                    		jz	short SkipSet
  8076                                  		;cmp	byte [DI+BDS.drivenum],bl
  8077 00001C8F 385504                  		cmp	byte [DI+BDS.drivenum],dl ; 17/07/2019
  8078 00001C92 7503                    		jnz	short Get_Next_BDS
  8079                                  ;
  8080                                  ; Someone may complain, but this *always* must be done when a disk change is
  8081                                  ; noted.  There are *no* other compromising circumstances.
  8082                                  ;
  8083                                  SetChanged:
  8084                                  		;or	[DI+BDS.flags],dx ; signal change on other drive
  8085 00001C94 095D23                  		or	[DI+BDS.flags],bx ; 17/07/2019
  8086                                  Get_Next_BDS:
  8087                                  		;mov	ax,[DI+BDS.link+2]  ; go to next BDS
  8088                                  		;;mov	di,[DI+BDS.link]
  8089                                  		;mov	di,[di] ; 05/07/2019
  8090                                  		;mov	ds,ax
  8091                                  		
  8092                                  		; 17/07/2019
  8093                                  		;lds	di,[di+BDS.link]
  8094 00001C97 C53D                    		lds	di,[di]
  8095                                  
  8096 00001C99 EBEF                    		jmp	short Scan_BDS
  8097                                  SkipSet:
  8098 00001C9B 5F                      		pop	di		    ; restore current BDS
  8099 00001C9C 1F                      		pop	ds
  8100                                  		;pop	ax
  8101                                  		;pop	DX
  8102                                  		;pop	BX
  8103 00001C9D C3                      		retn
  8104                                  
  8105                                  ;
  8106                                  ; CheckROMChange - see if external program has diddled ROM change line.
  8107                                  ;
  8108                                  ;   Inputs:	DS:DI points to current BDS.
  8109                                  ;   Outputs:	Zero set - no change
  8110                                  ;		Zero reset - change
  8111                                  ;   Registers modified: none
  8112                                  
  8113                                  CheckROMChange:
  8114 00001C9E F745234000              		test	word [DI+BDS.flags],fChanged
  8115 00001CA3 C3                      		retn
  8116                                  
  8117                                  ;
  8118                                  ; ResetChanged - restore value of change line
  8119                                  ;
  8120                                  ;   Inputs:	DS:DI points to current BDS
  8121                                  ;   Outputs:	none
  8122                                  ;   Registers modified: none
  8123                                  
  8124                                  ResetChanged:
  8125 00001CA4 836523BF                		and	word [DI+BDS.flags],~fChanged
  8126 00001CA8 C3                      		retn
  8127                                  
  8128                                  ;
  8129                                  ; HasChange - see if drive can supply change line
  8130                                  ;
  8131                                  ;   Inputs:	DS:DI points to current BDS
  8132                                  ;   Outputs:	Zero set - no change line available
  8133                                  ;		Zero reset - change line available
  8134                                  ;   Registers modified: none
  8135                                  
  8136                                  HasChange:
  8137 00001CA9 F745230200              		test	word [DI+BDS.flags],fChangeline
  8138 00001CAE C3                      		retn
  8139                                  
  8140                                  ; 01/06/2018 - Retro DOS v3.0
  8141                                  
  8142                                  ; include msvolid.inc
  8143                                  
  8144                                  ;-------------------------------------------------------------------------
  8145                                  ;
  8146                                  ;  File: msvolid.asm
  8147                                  ;	This file contains the volume_id subroutines and data structures.
  8148                                  ;
  8149                                  ;	Routines in this file are:
  8150                                  ;	   Set_Volume_ID       -	main routine, calls other routines.
  8151                                  ;	   read_volume_id      -	read the volume ID and tells if it has
  8152                                  ;					   been changed.
  8153                                  ;	   Transfer_volume_id  -	copy the volume ID from TMP to special
  8154                                  ;					   drive.
  8155                                  ;	   Check_Volume_ID     -	compare volume ID in TMP area with one
  8156                                  ;					   expected for drive.
  8157                                  ;	   Fat_Check	       -	see of the fatID has changed in the
  8158                                  ;					   specified drive.
  8159                                  ;	   Init_Vid_loop       -	set up for VID scan or move
  8160                                  ;
  8161                                  ;
  8162                                  ;-------------------------------------------------------------------------
  8163                                  
  8164                                  ; length of the volume id
  8165                                  
  8166                                  vid_size equ 12
  8167                                  
  8168                                  ; null volume id
  8169                                  
  8170                                  nul_vid:
  8171 00001CAF 4E4F204E414D452020-     	db  "NO NAME    ",0
  8171 00001CB8 202000             
  8172                                  
  8173                                  ; data scratch area used to hold volume ids
  8174                                  
  8175                                  tmp_vid:
  8176 00001CBB 4E4F204E414D452020-     	db  "NO NAME    ",0
  8176 00001CC4 202000             
  8177                                  
  8178                                  ;
  8179                                  ; Set_Volume_ID
  8180                                  ;   If drive has changeline support, read in and set the volume_ID
  8181                                  ; and the last FAT_ID byte.  If no change line support then do nothing.
  8182                                  ;
  8183                                  ;   On entry:
  8184                                  ;	DS:DI points to the BDS for this disk.
  8185                                  ;	AH contains media byte
  8186                                  ;
  8187                                  ;   On Exit:
  8188                                  ;	Carry clear:
  8189                                  ;	   Successful call
  8190                                  ;	Carry set
  8191                                  ;	   Error and AX has error code
  8192                                  ;
  8193                                  
  8194                                  Set_Volume_ID:
  8195 00001CC7 52                      		push	dx		; save registers
  8196 00001CC8 50                      		push	ax
  8197 00001CC9 E8DDFF                  		CALL	HasChange	; does drive have changeline support?
  8198 00001CCC 740D                    		jz	short setvret	; no, get out
  8199 00001CCE 57                      		push	di
  8200 00001CCF E81100                  		call	Read_Volume_ID	; read the volume ID
  8201 00001CD2 5F                      		pop	di
  8202 00001CD3 7209                    		jc	short SetErr	; if error go to error routine
  8203 00001CD5 E8A600                  		call	transfer_volume_ID ; copy the volume id to special drive
  8204 00001CD8 E8C9FF                  		call	ResetChanged	; restore value of change line
  8205                                  setvret:				; SET Volume RETurn
  8206                                  		;clc	; 19/07/2019	; no error, clear carry flag
  8207 00001CDB 58                      		pop	ax		; restore registers
  8208 00001CDC 5A                      		pop	dx
  8209 00001CDD C3                      		retn
  8210                                  SetErr:
  8211 00001CDE 5A                      		pop	dx		; pop stack but don't overwrite AX
  8212 00001CDF 5A                      		pop	dx		; restore DX
  8213 00001CE0 C3                      		retn
  8214                                  
  8215                                  root_sec:
  8216 00001CE1 0000                    		DW	0		; Root sector #
  8217                                  
  8218                                  ;
  8219                                  ; read_volume_id read the volume ID and tells if it has been changed.
  8220                                  ;
  8221                                  ;   On entry:
  8222                                  ;	DS:DI points to current BDS for drive.
  8223                                  ;   On Exit:
  8224                                  ;	Carry Clear
  8225                                  ;	    SI = 1  No change
  8226                                  ;	    SI = 0  ?
  8227                                  ;	    SI = -1 Change
  8228                                  ;
  8229                                  ;	Carry Set:
  8230                                  ;	    Error and AX has error code.
  8231                                  ;
  8232                                  
  8233                                  Read_Volume_ID:
  8234 00001CE3 06                      		push	ES		; preserve registers
  8235 00001CE4 52                      		push	DX
  8236 00001CE5 51                      		push	CX
  8237 00001CE6 53                      		push	BX
  8238 00001CE7 50                      		push	AX
  8239 00001CE8 1E                      		push	DS		; Preserve Current BDS
  8240 00001CE9 57                      		push	DI
  8241 00001CEA 0E                      		push	cs		; get ES segment correct
  8242 00001CEB 07                      		pop	es
  8243 00001CEC 0E                      		push	cs		; get DS segment correct
  8244 00001CED 1F                      		pop	ds
  8245 00001CEE BF[BB1C]                		mov	di,tmp_vid
  8246 00001CF1 BE[AF1C]                		mov	si,nul_vid
  8247 00001CF4 B90C00                  		mov	cx,vid_size
  8248 00001CF7 F3A4                    		rep	movsb		; initialize tmp_vid to null vi_id
  8249                                  
  8250 00001CF9 5F                      		pop	DI		; Restore Current BDS
  8251 00001CFA 1F                      		pop	DS
  8252 00001CFB 8A450B                  		mov	al,[DI+BDS.fats] ; # of fats
  8253 00001CFE 8B4D11                  		mov	cx,[DI+BDS.fatsecs] ; sectors / fat
  8254 00001D01 F6E1                    		mul	cl			    ; size taken by fats
  8255 00001D03 034509                  		add	ax,[DI+BDS.resectors] ; add on reserved sectors
  8256                                  					; AX is now sector # (0 based)
  8257 00001D06 2EA3[E11C]              		mov	[cs:root_sec],ax ; set initial value
  8258 00001D0A 8B450C                  		mov	ax,[DI+BDS.direntries] ; # root dir entries
  8259 00001D0D B104                    		mov	cl,4		; 16 entries/sector
  8260 00001D0F D3E8                    		shr	ax,cl		; divide by 16
  8261 00001D11 89C1                    		mov	cx,ax		; cx is # of sectors to scan
  8262                                  next_sec:
  8263 00001D13 51                      		push	cx		; save outer loop counter
  8264 00001D14 2EA1[E11C]              		mov	ax,[cs:root_sec] ; get sector #
  8265 00001D18 8B4D13                  		mov	cx,[DI+BDS.secpertrack] ; sectors / track
  8266 00001D1B 31D2                    		xor	DX,DX
  8267 00001D1D F7F1                    		div	cx
  8268                                  				; set up registers for call to read_sector
  8269 00001D1F 42                      		inc	DX	; dx= sectors into track, ax= track count from 0
  8270 00001D20 88D1                    		mov	cl,dl	; sector to read
  8271 00001D22 31D2                    		xor	DX,DX
  8272 00001D24 F77515                  		div	word [DI+BDS.heads] ; # heads on this disc
  8273 00001D27 88D6                    		mov	dh,dl	; Head number
  8274 00001D29 88C5                    		mov	ch,al	; Track #
  8275 00001D2B E83DF1                  		call	READ_SECTOR ; get first sector of the root directory,
  8276                                  				; ES:BX -> BOOT
  8277 00001D2E 724A                    		jc	short ReadVIDErr ; error on read
  8278 00001D30 B91000                  		mov	cx,16		; # of dir entries in a block of root
  8279 00001D33 B008                    		mov	al,08h		; volume label bit
  8280                                  fvid_loop:
  8281 00001D35 26803F00                		cmp	byte [es:bx],0	; End of dir?
  8282 00001D39 743C                    		jz	short no_vid	; yes, no vol id
  8283 00001D3B 26803FE5                		cmp	byte [es:bx],0E5h ; empty entry?
  8284 00001D3F 7406                    		jz	short ent_loop	; yes, skip
  8285 00001D41 2684470B                		test	[es:bx+11],al	; is volume label bit set in fcb?
  8286 00001D45 7511                    		jnz	short found_vid	; jmp yes
  8287                                  ent_loop:
  8288 00001D47 83C320                  		ADD	BX,32		;ADD LENGTH OF DIRECTORY ENTRY
  8289 00001D4A E2E9                    		loop	fvid_loop
  8290 00001D4C 59                      		pop	cx		; outer loop
  8291 00001D4D 2EFF06[E11C]            		inc	word [cs:root_sec] ; next sector
  8292 00001D52 E2BF                    		loop	next_sec	; continue
  8293                                  NotFound:
  8294 00001D54 31F6                    		XOR	SI,SI
  8295 00001D56 EB18                    		jmp	short fvid_ret
  8296                                  
  8297                                  found_vid:
  8298 00001D58 59                      		pop	cx		; clean stack of outer loop counter
  8299 00001D59 89DE                    		mov	si,bx		; point to volume_id
  8300 00001D5B 1E                      		push	ds		; preserve currnet BDS
  8301 00001D5C 57                      		push	di
  8302 00001D5D 06                      		push	es		; es:si points to volume id.
  8303 00001D5E 1F                      		pop	ds		; source segment
  8304 00001D5F 0E                      		push	cs
  8305 00001D60 07                      		pop	es		; destination segment
  8306 00001D61 BF[BB1C]                		mov	di,tmp_vid	; dest of volume_id
  8307 00001D64 B90B00                  		mov	cx,vid_size-1	; length of string minus NUL
  8308 00001D67 F3A4                    		rep	movsb		; mov volume label to tmp_vid
  8309 00001D69 30C0                    		xor	al,al
  8310 00001D6B AA                      		stosb			; Null terminate
  8311 00001D6C 31F6                    		XOR	SI,SI
  8312 00001D6E 5F                      		pop	DI		; restore current BDS
  8313 00001D6F 1F                      		pop	DS
  8314                                  fvid_ret:
  8315 00001D70 58                      		pop	ax
  8316 00001D71 F8                      		clc
  8317                                  RVIDRet:
  8318 00001D72 5B                      		pop	BX		; restore register
  8319 00001D73 59                      		pop	CX
  8320 00001D74 5A                      		pop	DX
  8321 00001D75 07                      		pop	ES
  8322 00001D76 C3                      		retn
  8323                                  no_vid:
  8324 00001D77 59                      		pop	cx		; clean stack of outer loop counter
  8325 00001D78 EBDA                    		jmp	short NotFound	; not found
  8326                                  ReadVIDErr:
  8327 00001D7A 5E                      		pop	SI
  8328 00001D7B 5E                      		pop	SI
  8329 00001D7C EBF4                    		jmp	short RVIDRet
  8330                                  
  8331                                  ;
  8332                                  ;   Transfer_volume_id - copy the volume ID from TMP to special drive
  8333                                  ;
  8334                                  ;   Inputs:	DS:DI nas current BDS
  8335                                  ;   Outputs:	BDS for drive has volume ID from TMP
  8336                                  ;
  8337                                  
  8338                                  transfer_volume_ID:
  8339 00001D7E 1E                      		push	DS		; preserve current BDS
  8340 00001D7F 57                      		push	DI
  8341 00001D80 06                      		push	ES
  8342 00001D81 56                      		push	SI
  8343 00001D82 51                      		push	CX
  8344 00001D83 E83000                  		call	init_vid_loop
  8345 00001D86 FC                      		cld
  8346 00001D87 F3A4                    		rep	MOVSB		; transfer
  8347 00001D89 59                      		pop	CX
  8348 00001D8A 5E                      		pop	SI
  8349 00001D8B 07                      		pop	ES
  8350 00001D8C 5F                      		pop	DI		; restore current BDS
  8351 00001D8D 1F                      		pop	DS
  8352 00001D8E C3                      		retn
  8353                                  
  8354                                  ;
  8355                                  ;   Check_Volume_ID - compare volume ID in TMP area with one expected for
  8356                                  ;	drive
  8357                                  ;
  8358                                  ;   Inputs:	DS:DI has current BDS for drive
  8359                                  ;   Outputs:	SI = 0 if compare succeeds
  8360                                  ;		SI = -1 if compare fails.
  8361                                  ;
  8362                                  
  8363                                  Check_Volume_ID:
  8364 00001D8F 1E                      		push	DS		; preserve current BDS for drive
  8365 00001D90 57                      		push	DI
  8366 00001D91 06                      		push	ES
  8367 00001D92 51                      		push	CX
  8368 00001D93 E82000                  		call	init_vid_loop
  8369 00001D96 FC                      		cld
  8370 00001D97 F3A6                    		repz	cmpsb		; are the 2 volume_ids the same?
  8371 00001D99 BE0000                  		mov	si,0		; assume unknown
  8372 00001D9C 7403                    		jz	short check_vid_ret ; carry clear if jump taken
  8373 00001D9E BEFFFF                  		mov	si,-1		; failure
  8374                                  check_vid_ret:
  8375 00001DA1 59                      		pop	CX
  8376 00001DA2 07                      		pop	ES
  8377 00001DA3 5F                      		pop	DI		; restore current BDS
  8378 00001DA4 1F                      		pop	DS
  8379 00001DA5 C3                      		retn
  8380                                  
  8381                                  ;
  8382                                  ;   Fat_Check - see of the fatID has changed in the specified drive.
  8383                                  ;	      - uses the FAT ID obtained from the boot sector.
  8384                                  ;
  8385                                  ;   Inputs:	MedByt is expected FAT ID
  8386                                  ;		DS:DI points to current BDS
  8387                                  ;   Output:	Carry Clear
  8388                                  ;		    SI = -1 if fat ID different,
  8389                                  ;		    SI = 0 otherwise
  8390                                  ;   No other registers changed.
  8391                                  
  8392                                  FAT_CHECK:
  8393 00001DA6 50                      		push	AX
  8394 00001DA7 31F6                    		xor	SI,SI		; say FAT ID's are same.
  8395 00001DA9 2EA0[A001]              		mov	AL,[cs:MedByt]
  8396                                  					 ; compare it with the BDS medbyte
  8397 00001DAD 3A4510                  		cmp	AL,[DI+BDS.media]
  8398 00001DB0 7402                    		jz	short OkRet1	; carry clear
  8399 00001DB2 4E                      		dec	SI
  8400 00001DB3 F8                      		clc ; 19/07/2019
  8401                                  OkRet1:		
  8402                                  		;clc	; cf = 0 ; 19/07/2019
  8403 00001DB4 58                      		pop	AX
  8404 00001DB5 C3                      		retn
  8405                                  
  8406                                  ;
  8407                                  ;   Init_Vid_loop - set up for VID scan or move
  8408                                  ;
  8409                                  ;   Inputs:	DS:DI pionts to BDS for the drive
  8410                                  ;   Outputs:	DS:SI points to tmp_vid
  8411                                  ;		ES:DI points to vid for drive
  8412                                  ;		CX has size for VID compare
  8413                                  ;
  8414                                  
  8415                                  init_vid_loop:
  8416 00001DB6 50                      		push	ax
  8417 00001DB7 1E                      		push	ds
  8418 00001DB8 07                      		pop	es
  8419 00001DB9 0E                      		push	cs
  8420 00001DBA 1F                      		pop	ds
  8421 00001DBB BE[BB1C]                		mov	si,tmp_vid	; source
  8422 00001DBE 83C74B                  		add	di,BDS.volid
  8423 00001DC1 B90C00                  		mov	cx,vid_size
  8424 00001DC4 58                      		pop	ax
  8425 00001DC5 C3                      		retn
  8426                                  
  8427                                  ;-----------------------------------------------------------------------------
  8428                                  
  8429                                  End96tpi:
  8430                                  
  8431                                  ;Rev 3.30 modification ----------------------------
  8432                                  ;Memory allocation for BDSM table.
  8433                                  
  8434                                  ; 16/07/2019 (Retro DOS v3.2 - BDS structure fixups)
  8435                                  
  8436                                  ;  "HDRIVE" is a hard disk with 512 byte sectors
  8437                                  
  8438                                  	;EVENB
  8439                                  
  8440                                  align 2
  8441                                  
  8442                                  bdss: ; 18/07/2019
  8443                                  
  8444                                  BDSH:
  8445 00001DC6 FFFF                    	DW	-1			; Link to next structure
  8446 00001DC8 7000                    	DW	KERNEL_SEGMENT
  8447 00001DCA 80                      	DB	80h			; physical drive number
  8448 00001DCB 43                      	DB	"C"                     ; Logical Drive Letter
  8449                                  HDRIVE:
  8450 00001DCC 0002                    	DW	512
  8451 00001DCE 01                      	DB	1			; Sectors/allocation unit
  8452 00001DCF 0100                    	DW	1			; Reserved sectors for DOS
  8453 00001DD1 02                      	DB	2			; No. of allocation tables
  8454 00001DD2 1000                    	DW	16			; Number of directory entries
  8455 00001DD4 0000                    	DW	0			; Number of sectors (at 512 bytes each)
  8456 00001DD6 F8                      	DB	11111000b ; 0F8h	; Media descriptor
  8457 00001DD7 0100                    	DW	1			; Number of FAT sectors
  8458 00001DD9 0000                    	DW	0			; Sector limit
  8459 00001DDB 0000                    	DW	0			; Head limit
  8460 00001DDD 0000                    	DW	0			; Hidden sector count
  8461 00001DDF 0000                    	dw	0 ; 16/07/2019 - high word of hidden sector count
  8462 00001DE1 00000000                	dd	0 ; 16/07/2019 - big totalsectors
  8463 00001DE5 00                      	DB	0			; TRUE => bigfat
  8464 00001DE6 0000                    OPCNTH:	DW	0			; Open Ref. Count
  8465                                  ;VOLIDH: DB	"NO NAME    ",0         ; Volume ID for this disk
  8466 00001DE8 03                      	DB	3			; Form Factor
  8467 00001DE9 2000                    FLAGSH:	DW	20h			; Various Flags
  8468 00001DEB 2800                    	DW	40			; number of cylinders
  8469                                  RecBPBH:
  8470 00001DED 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  8471                                  TRACKH:	
  8472 00001E0C FF                      	DB	-1			; Last track accessed on this drive
  8473                                  TIM_LOH:
  8474 00001E0D FFFF                    	DW	-1			; Keep these two contiguous (?)
  8475                                  TIM_HIH:
  8476 00001E0F FFFF                    	DW	-1
  8477                                  		; 16/07/2019	
  8478                                  VOLIDH: 
  8479 00001E11 4E4F204E414D452020-     	db	"NO NAME    ",0	; Volume ID for this disk
  8479 00001E1A 202000             
  8480 00001E1D 00000000                	dd	0 		; Volume serial number from boot record	
  8481 00001E21 464154313220202000      	db	"FAT12   ",0	; File system id from boot record
  8482                                  
  8483                                  ; End of single hard disk section
  8484                                  
  8485                                  EndOneHard:
  8486                                  
  8487                                  ;"DRIVEX" is an extra type of drive usually reserved for an
  8488                                  ; additional hard file
  8489                                  
  8490                                  	;EVENB
  8491                                  
  8492                                  ;align 2
  8493                                  
  8494                                  BDSX:
  8495 00001E2A FFFF                    	DW	-1			; Link to next structure
  8496 00001E2C 7000                    	DW	KERNEL_SEGMENT
  8497 00001E2E 81                      	DB	81h			; physical drive number
  8498 00001E2F 44                      	DB	"D"                     ; Logical Drive Letter
  8499                                  DRIVEX:
  8500 00001E30 0002                    	DW	512
  8501                                  	;DB	0
  8502 00001E32 01                      	db	1  ; 01/08/2019		; Sectors/allocation unit
  8503 00001E33 0100                    	DW	1			; Reserved sectors for DOS
  8504 00001E35 02                      	DB	2			; No. of allocation tables
  8505                                  	;DW	0			; Number of directory entries
  8506 00001E36 1000                    	dw	16 ; 01/08/2019
  8507 00001E38 0000                    	DW	0			; Number of sectors (at 512 bytes each)
  8508 00001E3A F8                      	DB	11111000b ; 0F8h	; Media descriptor
  8509                                  	;DW	0			; Number of FAT sectors
  8510 00001E3B 0100                    	dw	1  ; 01/08/2019	
  8511 00001E3D 0000                    	DW	0			; Sector limit
  8512 00001E3F 0000                    	DW	0			; Head limit
  8513 00001E41 0000                    	DW	0			; Hidden sector count
  8514 00001E43 0000                    	dw	0 ; 16/07/2019 - high word of hidden sector count
  8515 00001E45 00000000                	dd	0 ; 16/07/2019 - big totalsectors
  8516 00001E49 00                      	DB	0			; TRUE => bigfat
  8517 00001E4A 0000                    OPCNTD:	DW	0			; Open Ref. Count
  8518                                  ;VOLIDD: DB	"NO NAME    ",0         ; Volume ID for this disk
  8519 00001E4C 03                      	DB	3			; Form Factor
  8520 00001E4D 2000                    FLAGSD:	DW	20h			; Various Flags
  8521 00001E4F 2800                    	DW	40			; number of cylinders
  8522                                  RecBPBD:
  8523 00001E51 00<rep 1Fh>             	times	31 db 0			; Recommended BPB for drive
  8524                                  TRACKD:
  8525 00001E70 FF                      	DB	-1			; Last track accessed on this drive
  8526                                  TIM_LOD:
  8527 00001E71 FFFF                    	DW	-1			; Keep these two contiguous
  8528                                  TIM_HID:
  8529 00001E73 FFFF                    	DW	-1
  8530                                  		; 16/07/2019	
  8531                                  VOLIDD: 
  8532 00001E75 4E4F204E414D452020-     	db	"NO NAME    ",0	; Volume ID for this disk
  8532 00001E7E 202000             
  8533 00001E81 00000000                	dd	0 		; Volume serial number from boot record	
  8534 00001E85 464154313220202000      	db	"FAT12   ",0	; File system id from boot record
  8535                                  
  8536                                  ; End of section for two hard disks
  8537                                  
  8538                                  EndTwoHard:
  8539                                  
  8540                                  ; 15/07/2019
  8541                                  BDSMs:
  8542                                  	;times BDS.size*max_mini_dsk_num db 0	;currently max. 23
  8543                                  
  8544                                  ; 01/08/2019 - Retro DOS v3.2
  8545                                  	%rep	max_mini_dsk_num ; 23 
  8546                                  ;BDSM:
  8547                                  	DW	-1			; Link to next structure
  8548                                  	DW	0
  8549                                  	DB	50h			; physical drive number
  8550                                  	DB	3                    	; Logical Drive Letter
  8551                                  ;DRIVEM:
  8552                                  	DW	512
  8553                                  	;DB	0
  8554                                  	db	1	; Sectors/allocation unit
  8555                                  	DW	1			; Reserved sectors for DOS
  8556                                  	DB	2			; No. of allocation tables
  8557                                  	DW	16			; Number of directory entries
  8558                                  	DW	0			; Number of sectors (at 512 bytes each)
  8559                                  	DB	11111000b  ; 0F8h	; Media descriptor
  8560                                  	DW	1			; Number of FAT sectors
  8561                                  	DW	0			; Sector limit
  8562                                  	DW	0			; Head limit
  8563                                  	DW	0			; Hidden sector count
  8564                                  	dw	0 			; High word of hidden sector count
  8565                                  	dd	0 			; Big totalsectors
  8566                                  	DB	0			; TRUE => bigfat
  8567                                  ;OPCNTM:
  8568                                  	DW	0			; Open Ref. Count
  8569                                  	DB	3			; Form Factor
  8570                                  ;FLAGSM:	
  8571                                  	DW	20h			; Various Flags
  8572                                  	DW	40			; number of cylinders
  8573                                  ;RecBPBM:
  8574                                  	times	31 db 0			; Recommended BPB for drive
  8575                                  ;TRACKM:
  8576                                  	DB	-1			; Last track accessed on this drive
  8577                                  ;BDSM_ISMINI:
  8578                                  	DW	1			; Keep these two contiguous
  8579                                  ;BDSM_HIDDEN_TRKS:
  8580                                  	DW	0
  8581                                  ;VOLIDM: 
  8582                                  	db	"NO NAME    ",0	; Volume ID for this disk
  8583                                  	dd	0 		; Volume serial number from boot record	
  8584                                  	db	"FAT12   ",0	; File system id from boot record
  8585                                  	
  8586                                  	%endrep
  8546                              <1> 
  8547 00001E8E FFFF                <1>  DW -1
  8548 00001E90 0000                <1>  DW 0
  8549 00001E92 50                  <1>  DB 50h
  8550 00001E93 03                  <1>  DB 3
  8551                              <1> 
  8552 00001E94 0002                <1>  DW 512
  8553                              <1> 
  8554 00001E96 01                  <1>  db 1
  8555 00001E97 0100                <1>  DW 1
  8556 00001E99 02                  <1>  DB 2
  8557 00001E9A 1000                <1>  DW 16
  8558 00001E9C 0000                <1>  DW 0
  8559 00001E9E F8                  <1>  DB 11111000b
  8560 00001E9F 0100                <1>  DW 1
  8561 00001EA1 0000                <1>  DW 0
  8562 00001EA3 0000                <1>  DW 0
  8563 00001EA5 0000                <1>  DW 0
  8564 00001EA7 0000                <1>  dw 0
  8565 00001EA9 00000000            <1>  dd 0
  8566 00001EAD 00                  <1>  DB 0
  8567                              <1> 
  8568 00001EAE 0000                <1>  DW 0
  8569 00001EB0 03                  <1>  DB 3
  8570                              <1> 
  8571 00001EB1 2000                <1>  DW 20h
  8572 00001EB3 2800                <1>  DW 40
  8573                              <1> 
  8574 00001EB5 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00001ED4 FF                  <1>  DB -1
  8577                              <1> 
  8578 00001ED5 0100                <1>  DW 1
  8579                              <1> 
  8580 00001ED7 0000                <1>  DW 0
  8581                              <1> 
  8582 00001ED9 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00001EE2 202000              <1>
  8583 00001EE5 00000000            <1>  dd 0
  8584 00001EE9 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00001EF2 FFFF                <1>  DW -1
  8548 00001EF4 0000                <1>  DW 0
  8549 00001EF6 50                  <1>  DB 50h
  8550 00001EF7 03                  <1>  DB 3
  8551                              <1> 
  8552 00001EF8 0002                <1>  DW 512
  8553                              <1> 
  8554 00001EFA 01                  <1>  db 1
  8555 00001EFB 0100                <1>  DW 1
  8556 00001EFD 02                  <1>  DB 2
  8557 00001EFE 1000                <1>  DW 16
  8558 00001F00 0000                <1>  DW 0
  8559 00001F02 F8                  <1>  DB 11111000b
  8560 00001F03 0100                <1>  DW 1
  8561 00001F05 0000                <1>  DW 0
  8562 00001F07 0000                <1>  DW 0
  8563 00001F09 0000                <1>  DW 0
  8564 00001F0B 0000                <1>  dw 0
  8565 00001F0D 00000000            <1>  dd 0
  8566 00001F11 00                  <1>  DB 0
  8567                              <1> 
  8568 00001F12 0000                <1>  DW 0
  8569 00001F14 03                  <1>  DB 3
  8570                              <1> 
  8571 00001F15 2000                <1>  DW 20h
  8572 00001F17 2800                <1>  DW 40
  8573                              <1> 
  8574 00001F19 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00001F38 FF                  <1>  DB -1
  8577                              <1> 
  8578 00001F39 0100                <1>  DW 1
  8579                              <1> 
  8580 00001F3B 0000                <1>  DW 0
  8581                              <1> 
  8582 00001F3D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00001F46 202000              <1>
  8583 00001F49 00000000            <1>  dd 0
  8584 00001F4D 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00001F56 FFFF                <1>  DW -1
  8548 00001F58 0000                <1>  DW 0
  8549 00001F5A 50                  <1>  DB 50h
  8550 00001F5B 03                  <1>  DB 3
  8551                              <1> 
  8552 00001F5C 0002                <1>  DW 512
  8553                              <1> 
  8554 00001F5E 01                  <1>  db 1
  8555 00001F5F 0100                <1>  DW 1
  8556 00001F61 02                  <1>  DB 2
  8557 00001F62 1000                <1>  DW 16
  8558 00001F64 0000                <1>  DW 0
  8559 00001F66 F8                  <1>  DB 11111000b
  8560 00001F67 0100                <1>  DW 1
  8561 00001F69 0000                <1>  DW 0
  8562 00001F6B 0000                <1>  DW 0
  8563 00001F6D 0000                <1>  DW 0
  8564 00001F6F 0000                <1>  dw 0
  8565 00001F71 00000000            <1>  dd 0
  8566 00001F75 00                  <1>  DB 0
  8567                              <1> 
  8568 00001F76 0000                <1>  DW 0
  8569 00001F78 03                  <1>  DB 3
  8570                              <1> 
  8571 00001F79 2000                <1>  DW 20h
  8572 00001F7B 2800                <1>  DW 40
  8573                              <1> 
  8574 00001F7D 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00001F9C FF                  <1>  DB -1
  8577                              <1> 
  8578 00001F9D 0100                <1>  DW 1
  8579                              <1> 
  8580 00001F9F 0000                <1>  DW 0
  8581                              <1> 
  8582 00001FA1 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00001FAA 202000              <1>
  8583 00001FAD 00000000            <1>  dd 0
  8584 00001FB1 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00001FBA FFFF                <1>  DW -1
  8548 00001FBC 0000                <1>  DW 0
  8549 00001FBE 50                  <1>  DB 50h
  8550 00001FBF 03                  <1>  DB 3
  8551                              <1> 
  8552 00001FC0 0002                <1>  DW 512
  8553                              <1> 
  8554 00001FC2 01                  <1>  db 1
  8555 00001FC3 0100                <1>  DW 1
  8556 00001FC5 02                  <1>  DB 2
  8557 00001FC6 1000                <1>  DW 16
  8558 00001FC8 0000                <1>  DW 0
  8559 00001FCA F8                  <1>  DB 11111000b
  8560 00001FCB 0100                <1>  DW 1
  8561 00001FCD 0000                <1>  DW 0
  8562 00001FCF 0000                <1>  DW 0
  8563 00001FD1 0000                <1>  DW 0
  8564 00001FD3 0000                <1>  dw 0
  8565 00001FD5 00000000            <1>  dd 0
  8566 00001FD9 00                  <1>  DB 0
  8567                              <1> 
  8568 00001FDA 0000                <1>  DW 0
  8569 00001FDC 03                  <1>  DB 3
  8570                              <1> 
  8571 00001FDD 2000                <1>  DW 20h
  8572 00001FDF 2800                <1>  DW 40
  8573                              <1> 
  8574 00001FE1 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002000 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002001 0100                <1>  DW 1
  8579                              <1> 
  8580 00002003 0000                <1>  DW 0
  8581                              <1> 
  8582 00002005 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000200E 202000              <1>
  8583 00002011 00000000            <1>  dd 0
  8584 00002015 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 0000201E FFFF                <1>  DW -1
  8548 00002020 0000                <1>  DW 0
  8549 00002022 50                  <1>  DB 50h
  8550 00002023 03                  <1>  DB 3
  8551                              <1> 
  8552 00002024 0002                <1>  DW 512
  8553                              <1> 
  8554 00002026 01                  <1>  db 1
  8555 00002027 0100                <1>  DW 1
  8556 00002029 02                  <1>  DB 2
  8557 0000202A 1000                <1>  DW 16
  8558 0000202C 0000                <1>  DW 0
  8559 0000202E F8                  <1>  DB 11111000b
  8560 0000202F 0100                <1>  DW 1
  8561 00002031 0000                <1>  DW 0
  8562 00002033 0000                <1>  DW 0
  8563 00002035 0000                <1>  DW 0
  8564 00002037 0000                <1>  dw 0
  8565 00002039 00000000            <1>  dd 0
  8566 0000203D 00                  <1>  DB 0
  8567                              <1> 
  8568 0000203E 0000                <1>  DW 0
  8569 00002040 03                  <1>  DB 3
  8570                              <1> 
  8571 00002041 2000                <1>  DW 20h
  8572 00002043 2800                <1>  DW 40
  8573                              <1> 
  8574 00002045 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002064 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002065 0100                <1>  DW 1
  8579                              <1> 
  8580 00002067 0000                <1>  DW 0
  8581                              <1> 
  8582 00002069 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002072 202000              <1>
  8583 00002075 00000000            <1>  dd 0
  8584 00002079 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002082 FFFF                <1>  DW -1
  8548 00002084 0000                <1>  DW 0
  8549 00002086 50                  <1>  DB 50h
  8550 00002087 03                  <1>  DB 3
  8551                              <1> 
  8552 00002088 0002                <1>  DW 512
  8553                              <1> 
  8554 0000208A 01                  <1>  db 1
  8555 0000208B 0100                <1>  DW 1
  8556 0000208D 02                  <1>  DB 2
  8557 0000208E 1000                <1>  DW 16
  8558 00002090 0000                <1>  DW 0
  8559 00002092 F8                  <1>  DB 11111000b
  8560 00002093 0100                <1>  DW 1
  8561 00002095 0000                <1>  DW 0
  8562 00002097 0000                <1>  DW 0
  8563 00002099 0000                <1>  DW 0
  8564 0000209B 0000                <1>  dw 0
  8565 0000209D 00000000            <1>  dd 0
  8566 000020A1 00                  <1>  DB 0
  8567                              <1> 
  8568 000020A2 0000                <1>  DW 0
  8569 000020A4 03                  <1>  DB 3
  8570                              <1> 
  8571 000020A5 2000                <1>  DW 20h
  8572 000020A7 2800                <1>  DW 40
  8573                              <1> 
  8574 000020A9 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000020C8 FF                  <1>  DB -1
  8577                              <1> 
  8578 000020C9 0100                <1>  DW 1
  8579                              <1> 
  8580 000020CB 0000                <1>  DW 0
  8581                              <1> 
  8582 000020CD 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000020D6 202000              <1>
  8583 000020D9 00000000            <1>  dd 0
  8584 000020DD 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000020E6 FFFF                <1>  DW -1
  8548 000020E8 0000                <1>  DW 0
  8549 000020EA 50                  <1>  DB 50h
  8550 000020EB 03                  <1>  DB 3
  8551                              <1> 
  8552 000020EC 0002                <1>  DW 512
  8553                              <1> 
  8554 000020EE 01                  <1>  db 1
  8555 000020EF 0100                <1>  DW 1
  8556 000020F1 02                  <1>  DB 2
  8557 000020F2 1000                <1>  DW 16
  8558 000020F4 0000                <1>  DW 0
  8559 000020F6 F8                  <1>  DB 11111000b
  8560 000020F7 0100                <1>  DW 1
  8561 000020F9 0000                <1>  DW 0
  8562 000020FB 0000                <1>  DW 0
  8563 000020FD 0000                <1>  DW 0
  8564 000020FF 0000                <1>  dw 0
  8565 00002101 00000000            <1>  dd 0
  8566 00002105 00                  <1>  DB 0
  8567                              <1> 
  8568 00002106 0000                <1>  DW 0
  8569 00002108 03                  <1>  DB 3
  8570                              <1> 
  8571 00002109 2000                <1>  DW 20h
  8572 0000210B 2800                <1>  DW 40
  8573                              <1> 
  8574 0000210D 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 0000212C FF                  <1>  DB -1
  8577                              <1> 
  8578 0000212D 0100                <1>  DW 1
  8579                              <1> 
  8580 0000212F 0000                <1>  DW 0
  8581                              <1> 
  8582 00002131 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000213A 202000              <1>
  8583 0000213D 00000000            <1>  dd 0
  8584 00002141 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 0000214A FFFF                <1>  DW -1
  8548 0000214C 0000                <1>  DW 0
  8549 0000214E 50                  <1>  DB 50h
  8550 0000214F 03                  <1>  DB 3
  8551                              <1> 
  8552 00002150 0002                <1>  DW 512
  8553                              <1> 
  8554 00002152 01                  <1>  db 1
  8555 00002153 0100                <1>  DW 1
  8556 00002155 02                  <1>  DB 2
  8557 00002156 1000                <1>  DW 16
  8558 00002158 0000                <1>  DW 0
  8559 0000215A F8                  <1>  DB 11111000b
  8560 0000215B 0100                <1>  DW 1
  8561 0000215D 0000                <1>  DW 0
  8562 0000215F 0000                <1>  DW 0
  8563 00002161 0000                <1>  DW 0
  8564 00002163 0000                <1>  dw 0
  8565 00002165 00000000            <1>  dd 0
  8566 00002169 00                  <1>  DB 0
  8567                              <1> 
  8568 0000216A 0000                <1>  DW 0
  8569 0000216C 03                  <1>  DB 3
  8570                              <1> 
  8571 0000216D 2000                <1>  DW 20h
  8572 0000216F 2800                <1>  DW 40
  8573                              <1> 
  8574 00002171 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002190 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002191 0100                <1>  DW 1
  8579                              <1> 
  8580 00002193 0000                <1>  DW 0
  8581                              <1> 
  8582 00002195 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000219E 202000              <1>
  8583 000021A1 00000000            <1>  dd 0
  8584 000021A5 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000021AE FFFF                <1>  DW -1
  8548 000021B0 0000                <1>  DW 0
  8549 000021B2 50                  <1>  DB 50h
  8550 000021B3 03                  <1>  DB 3
  8551                              <1> 
  8552 000021B4 0002                <1>  DW 512
  8553                              <1> 
  8554 000021B6 01                  <1>  db 1
  8555 000021B7 0100                <1>  DW 1
  8556 000021B9 02                  <1>  DB 2
  8557 000021BA 1000                <1>  DW 16
  8558 000021BC 0000                <1>  DW 0
  8559 000021BE F8                  <1>  DB 11111000b
  8560 000021BF 0100                <1>  DW 1
  8561 000021C1 0000                <1>  DW 0
  8562 000021C3 0000                <1>  DW 0
  8563 000021C5 0000                <1>  DW 0
  8564 000021C7 0000                <1>  dw 0
  8565 000021C9 00000000            <1>  dd 0
  8566 000021CD 00                  <1>  DB 0
  8567                              <1> 
  8568 000021CE 0000                <1>  DW 0
  8569 000021D0 03                  <1>  DB 3
  8570                              <1> 
  8571 000021D1 2000                <1>  DW 20h
  8572 000021D3 2800                <1>  DW 40
  8573                              <1> 
  8574 000021D5 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000021F4 FF                  <1>  DB -1
  8577                              <1> 
  8578 000021F5 0100                <1>  DW 1
  8579                              <1> 
  8580 000021F7 0000                <1>  DW 0
  8581                              <1> 
  8582 000021F9 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002202 202000              <1>
  8583 00002205 00000000            <1>  dd 0
  8584 00002209 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002212 FFFF                <1>  DW -1
  8548 00002214 0000                <1>  DW 0
  8549 00002216 50                  <1>  DB 50h
  8550 00002217 03                  <1>  DB 3
  8551                              <1> 
  8552 00002218 0002                <1>  DW 512
  8553                              <1> 
  8554 0000221A 01                  <1>  db 1
  8555 0000221B 0100                <1>  DW 1
  8556 0000221D 02                  <1>  DB 2
  8557 0000221E 1000                <1>  DW 16
  8558 00002220 0000                <1>  DW 0
  8559 00002222 F8                  <1>  DB 11111000b
  8560 00002223 0100                <1>  DW 1
  8561 00002225 0000                <1>  DW 0
  8562 00002227 0000                <1>  DW 0
  8563 00002229 0000                <1>  DW 0
  8564 0000222B 0000                <1>  dw 0
  8565 0000222D 00000000            <1>  dd 0
  8566 00002231 00                  <1>  DB 0
  8567                              <1> 
  8568 00002232 0000                <1>  DW 0
  8569 00002234 03                  <1>  DB 3
  8570                              <1> 
  8571 00002235 2000                <1>  DW 20h
  8572 00002237 2800                <1>  DW 40
  8573                              <1> 
  8574 00002239 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002258 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002259 0100                <1>  DW 1
  8579                              <1> 
  8580 0000225B 0000                <1>  DW 0
  8581                              <1> 
  8582 0000225D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002266 202000              <1>
  8583 00002269 00000000            <1>  dd 0
  8584 0000226D 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002276 FFFF                <1>  DW -1
  8548 00002278 0000                <1>  DW 0
  8549 0000227A 50                  <1>  DB 50h
  8550 0000227B 03                  <1>  DB 3
  8551                              <1> 
  8552 0000227C 0002                <1>  DW 512
  8553                              <1> 
  8554 0000227E 01                  <1>  db 1
  8555 0000227F 0100                <1>  DW 1
  8556 00002281 02                  <1>  DB 2
  8557 00002282 1000                <1>  DW 16
  8558 00002284 0000                <1>  DW 0
  8559 00002286 F8                  <1>  DB 11111000b
  8560 00002287 0100                <1>  DW 1
  8561 00002289 0000                <1>  DW 0
  8562 0000228B 0000                <1>  DW 0
  8563 0000228D 0000                <1>  DW 0
  8564 0000228F 0000                <1>  dw 0
  8565 00002291 00000000            <1>  dd 0
  8566 00002295 00                  <1>  DB 0
  8567                              <1> 
  8568 00002296 0000                <1>  DW 0
  8569 00002298 03                  <1>  DB 3
  8570                              <1> 
  8571 00002299 2000                <1>  DW 20h
  8572 0000229B 2800                <1>  DW 40
  8573                              <1> 
  8574 0000229D 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000022BC FF                  <1>  DB -1
  8577                              <1> 
  8578 000022BD 0100                <1>  DW 1
  8579                              <1> 
  8580 000022BF 0000                <1>  DW 0
  8581                              <1> 
  8582 000022C1 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000022CA 202000              <1>
  8583 000022CD 00000000            <1>  dd 0
  8584 000022D1 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000022DA FFFF                <1>  DW -1
  8548 000022DC 0000                <1>  DW 0
  8549 000022DE 50                  <1>  DB 50h
  8550 000022DF 03                  <1>  DB 3
  8551                              <1> 
  8552 000022E0 0002                <1>  DW 512
  8553                              <1> 
  8554 000022E2 01                  <1>  db 1
  8555 000022E3 0100                <1>  DW 1
  8556 000022E5 02                  <1>  DB 2
  8557 000022E6 1000                <1>  DW 16
  8558 000022E8 0000                <1>  DW 0
  8559 000022EA F8                  <1>  DB 11111000b
  8560 000022EB 0100                <1>  DW 1
  8561 000022ED 0000                <1>  DW 0
  8562 000022EF 0000                <1>  DW 0
  8563 000022F1 0000                <1>  DW 0
  8564 000022F3 0000                <1>  dw 0
  8565 000022F5 00000000            <1>  dd 0
  8566 000022F9 00                  <1>  DB 0
  8567                              <1> 
  8568 000022FA 0000                <1>  DW 0
  8569 000022FC 03                  <1>  DB 3
  8570                              <1> 
  8571 000022FD 2000                <1>  DW 20h
  8572 000022FF 2800                <1>  DW 40
  8573                              <1> 
  8574 00002301 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002320 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002321 0100                <1>  DW 1
  8579                              <1> 
  8580 00002323 0000                <1>  DW 0
  8581                              <1> 
  8582 00002325 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000232E 202000              <1>
  8583 00002331 00000000            <1>  dd 0
  8584 00002335 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 0000233E FFFF                <1>  DW -1
  8548 00002340 0000                <1>  DW 0
  8549 00002342 50                  <1>  DB 50h
  8550 00002343 03                  <1>  DB 3
  8551                              <1> 
  8552 00002344 0002                <1>  DW 512
  8553                              <1> 
  8554 00002346 01                  <1>  db 1
  8555 00002347 0100                <1>  DW 1
  8556 00002349 02                  <1>  DB 2
  8557 0000234A 1000                <1>  DW 16
  8558 0000234C 0000                <1>  DW 0
  8559 0000234E F8                  <1>  DB 11111000b
  8560 0000234F 0100                <1>  DW 1
  8561 00002351 0000                <1>  DW 0
  8562 00002353 0000                <1>  DW 0
  8563 00002355 0000                <1>  DW 0
  8564 00002357 0000                <1>  dw 0
  8565 00002359 00000000            <1>  dd 0
  8566 0000235D 00                  <1>  DB 0
  8567                              <1> 
  8568 0000235E 0000                <1>  DW 0
  8569 00002360 03                  <1>  DB 3
  8570                              <1> 
  8571 00002361 2000                <1>  DW 20h
  8572 00002363 2800                <1>  DW 40
  8573                              <1> 
  8574 00002365 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002384 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002385 0100                <1>  DW 1
  8579                              <1> 
  8580 00002387 0000                <1>  DW 0
  8581                              <1> 
  8582 00002389 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002392 202000              <1>
  8583 00002395 00000000            <1>  dd 0
  8584 00002399 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000023A2 FFFF                <1>  DW -1
  8548 000023A4 0000                <1>  DW 0
  8549 000023A6 50                  <1>  DB 50h
  8550 000023A7 03                  <1>  DB 3
  8551                              <1> 
  8552 000023A8 0002                <1>  DW 512
  8553                              <1> 
  8554 000023AA 01                  <1>  db 1
  8555 000023AB 0100                <1>  DW 1
  8556 000023AD 02                  <1>  DB 2
  8557 000023AE 1000                <1>  DW 16
  8558 000023B0 0000                <1>  DW 0
  8559 000023B2 F8                  <1>  DB 11111000b
  8560 000023B3 0100                <1>  DW 1
  8561 000023B5 0000                <1>  DW 0
  8562 000023B7 0000                <1>  DW 0
  8563 000023B9 0000                <1>  DW 0
  8564 000023BB 0000                <1>  dw 0
  8565 000023BD 00000000            <1>  dd 0
  8566 000023C1 00                  <1>  DB 0
  8567                              <1> 
  8568 000023C2 0000                <1>  DW 0
  8569 000023C4 03                  <1>  DB 3
  8570                              <1> 
  8571 000023C5 2000                <1>  DW 20h
  8572 000023C7 2800                <1>  DW 40
  8573                              <1> 
  8574 000023C9 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000023E8 FF                  <1>  DB -1
  8577                              <1> 
  8578 000023E9 0100                <1>  DW 1
  8579                              <1> 
  8580 000023EB 0000                <1>  DW 0
  8581                              <1> 
  8582 000023ED 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000023F6 202000              <1>
  8583 000023F9 00000000            <1>  dd 0
  8584 000023FD 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002406 FFFF                <1>  DW -1
  8548 00002408 0000                <1>  DW 0
  8549 0000240A 50                  <1>  DB 50h
  8550 0000240B 03                  <1>  DB 3
  8551                              <1> 
  8552 0000240C 0002                <1>  DW 512
  8553                              <1> 
  8554 0000240E 01                  <1>  db 1
  8555 0000240F 0100                <1>  DW 1
  8556 00002411 02                  <1>  DB 2
  8557 00002412 1000                <1>  DW 16
  8558 00002414 0000                <1>  DW 0
  8559 00002416 F8                  <1>  DB 11111000b
  8560 00002417 0100                <1>  DW 1
  8561 00002419 0000                <1>  DW 0
  8562 0000241B 0000                <1>  DW 0
  8563 0000241D 0000                <1>  DW 0
  8564 0000241F 0000                <1>  dw 0
  8565 00002421 00000000            <1>  dd 0
  8566 00002425 00                  <1>  DB 0
  8567                              <1> 
  8568 00002426 0000                <1>  DW 0
  8569 00002428 03                  <1>  DB 3
  8570                              <1> 
  8571 00002429 2000                <1>  DW 20h
  8572 0000242B 2800                <1>  DW 40
  8573                              <1> 
  8574 0000242D 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 0000244C FF                  <1>  DB -1
  8577                              <1> 
  8578 0000244D 0100                <1>  DW 1
  8579                              <1> 
  8580 0000244F 0000                <1>  DW 0
  8581                              <1> 
  8582 00002451 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000245A 202000              <1>
  8583 0000245D 00000000            <1>  dd 0
  8584 00002461 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 0000246A FFFF                <1>  DW -1
  8548 0000246C 0000                <1>  DW 0
  8549 0000246E 50                  <1>  DB 50h
  8550 0000246F 03                  <1>  DB 3
  8551                              <1> 
  8552 00002470 0002                <1>  DW 512
  8553                              <1> 
  8554 00002472 01                  <1>  db 1
  8555 00002473 0100                <1>  DW 1
  8556 00002475 02                  <1>  DB 2
  8557 00002476 1000                <1>  DW 16
  8558 00002478 0000                <1>  DW 0
  8559 0000247A F8                  <1>  DB 11111000b
  8560 0000247B 0100                <1>  DW 1
  8561 0000247D 0000                <1>  DW 0
  8562 0000247F 0000                <1>  DW 0
  8563 00002481 0000                <1>  DW 0
  8564 00002483 0000                <1>  dw 0
  8565 00002485 00000000            <1>  dd 0
  8566 00002489 00                  <1>  DB 0
  8567                              <1> 
  8568 0000248A 0000                <1>  DW 0
  8569 0000248C 03                  <1>  DB 3
  8570                              <1> 
  8571 0000248D 2000                <1>  DW 20h
  8572 0000248F 2800                <1>  DW 40
  8573                              <1> 
  8574 00002491 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000024B0 FF                  <1>  DB -1
  8577                              <1> 
  8578 000024B1 0100                <1>  DW 1
  8579                              <1> 
  8580 000024B3 0000                <1>  DW 0
  8581                              <1> 
  8582 000024B5 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000024BE 202000              <1>
  8583 000024C1 00000000            <1>  dd 0
  8584 000024C5 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000024CE FFFF                <1>  DW -1
  8548 000024D0 0000                <1>  DW 0
  8549 000024D2 50                  <1>  DB 50h
  8550 000024D3 03                  <1>  DB 3
  8551                              <1> 
  8552 000024D4 0002                <1>  DW 512
  8553                              <1> 
  8554 000024D6 01                  <1>  db 1
  8555 000024D7 0100                <1>  DW 1
  8556 000024D9 02                  <1>  DB 2
  8557 000024DA 1000                <1>  DW 16
  8558 000024DC 0000                <1>  DW 0
  8559 000024DE F8                  <1>  DB 11111000b
  8560 000024DF 0100                <1>  DW 1
  8561 000024E1 0000                <1>  DW 0
  8562 000024E3 0000                <1>  DW 0
  8563 000024E5 0000                <1>  DW 0
  8564 000024E7 0000                <1>  dw 0
  8565 000024E9 00000000            <1>  dd 0
  8566 000024ED 00                  <1>  DB 0
  8567                              <1> 
  8568 000024EE 0000                <1>  DW 0
  8569 000024F0 03                  <1>  DB 3
  8570                              <1> 
  8571 000024F1 2000                <1>  DW 20h
  8572 000024F3 2800                <1>  DW 40
  8573                              <1> 
  8574 000024F5 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002514 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002515 0100                <1>  DW 1
  8579                              <1> 
  8580 00002517 0000                <1>  DW 0
  8581                              <1> 
  8582 00002519 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002522 202000              <1>
  8583 00002525 00000000            <1>  dd 0
  8584 00002529 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002532 FFFF                <1>  DW -1
  8548 00002534 0000                <1>  DW 0
  8549 00002536 50                  <1>  DB 50h
  8550 00002537 03                  <1>  DB 3
  8551                              <1> 
  8552 00002538 0002                <1>  DW 512
  8553                              <1> 
  8554 0000253A 01                  <1>  db 1
  8555 0000253B 0100                <1>  DW 1
  8556 0000253D 02                  <1>  DB 2
  8557 0000253E 1000                <1>  DW 16
  8558 00002540 0000                <1>  DW 0
  8559 00002542 F8                  <1>  DB 11111000b
  8560 00002543 0100                <1>  DW 1
  8561 00002545 0000                <1>  DW 0
  8562 00002547 0000                <1>  DW 0
  8563 00002549 0000                <1>  DW 0
  8564 0000254B 0000                <1>  dw 0
  8565 0000254D 00000000            <1>  dd 0
  8566 00002551 00                  <1>  DB 0
  8567                              <1> 
  8568 00002552 0000                <1>  DW 0
  8569 00002554 03                  <1>  DB 3
  8570                              <1> 
  8571 00002555 2000                <1>  DW 20h
  8572 00002557 2800                <1>  DW 40
  8573                              <1> 
  8574 00002559 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002578 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002579 0100                <1>  DW 1
  8579                              <1> 
  8580 0000257B 0000                <1>  DW 0
  8581                              <1> 
  8582 0000257D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002586 202000              <1>
  8583 00002589 00000000            <1>  dd 0
  8584 0000258D 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002596 FFFF                <1>  DW -1
  8548 00002598 0000                <1>  DW 0
  8549 0000259A 50                  <1>  DB 50h
  8550 0000259B 03                  <1>  DB 3
  8551                              <1> 
  8552 0000259C 0002                <1>  DW 512
  8553                              <1> 
  8554 0000259E 01                  <1>  db 1
  8555 0000259F 0100                <1>  DW 1
  8556 000025A1 02                  <1>  DB 2
  8557 000025A2 1000                <1>  DW 16
  8558 000025A4 0000                <1>  DW 0
  8559 000025A6 F8                  <1>  DB 11111000b
  8560 000025A7 0100                <1>  DW 1
  8561 000025A9 0000                <1>  DW 0
  8562 000025AB 0000                <1>  DW 0
  8563 000025AD 0000                <1>  DW 0
  8564 000025AF 0000                <1>  dw 0
  8565 000025B1 00000000            <1>  dd 0
  8566 000025B5 00                  <1>  DB 0
  8567                              <1> 
  8568 000025B6 0000                <1>  DW 0
  8569 000025B8 03                  <1>  DB 3
  8570                              <1> 
  8571 000025B9 2000                <1>  DW 20h
  8572 000025BB 2800                <1>  DW 40
  8573                              <1> 
  8574 000025BD 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000025DC FF                  <1>  DB -1
  8577                              <1> 
  8578 000025DD 0100                <1>  DW 1
  8579                              <1> 
  8580 000025DF 0000                <1>  DW 0
  8581                              <1> 
  8582 000025E1 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000025EA 202000              <1>
  8583 000025ED 00000000            <1>  dd 0
  8584 000025F1 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000025FA FFFF                <1>  DW -1
  8548 000025FC 0000                <1>  DW 0
  8549 000025FE 50                  <1>  DB 50h
  8550 000025FF 03                  <1>  DB 3
  8551                              <1> 
  8552 00002600 0002                <1>  DW 512
  8553                              <1> 
  8554 00002602 01                  <1>  db 1
  8555 00002603 0100                <1>  DW 1
  8556 00002605 02                  <1>  DB 2
  8557 00002606 1000                <1>  DW 16
  8558 00002608 0000                <1>  DW 0
  8559 0000260A F8                  <1>  DB 11111000b
  8560 0000260B 0100                <1>  DW 1
  8561 0000260D 0000                <1>  DW 0
  8562 0000260F 0000                <1>  DW 0
  8563 00002611 0000                <1>  DW 0
  8564 00002613 0000                <1>  dw 0
  8565 00002615 00000000            <1>  dd 0
  8566 00002619 00                  <1>  DB 0
  8567                              <1> 
  8568 0000261A 0000                <1>  DW 0
  8569 0000261C 03                  <1>  DB 3
  8570                              <1> 
  8571 0000261D 2000                <1>  DW 20h
  8572 0000261F 2800                <1>  DW 40
  8573                              <1> 
  8574 00002621 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002640 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002641 0100                <1>  DW 1
  8579                              <1> 
  8580 00002643 0000                <1>  DW 0
  8581                              <1> 
  8582 00002645 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000264E 202000              <1>
  8583 00002651 00000000            <1>  dd 0
  8584 00002655 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 0000265E FFFF                <1>  DW -1
  8548 00002660 0000                <1>  DW 0
  8549 00002662 50                  <1>  DB 50h
  8550 00002663 03                  <1>  DB 3
  8551                              <1> 
  8552 00002664 0002                <1>  DW 512
  8553                              <1> 
  8554 00002666 01                  <1>  db 1
  8555 00002667 0100                <1>  DW 1
  8556 00002669 02                  <1>  DB 2
  8557 0000266A 1000                <1>  DW 16
  8558 0000266C 0000                <1>  DW 0
  8559 0000266E F8                  <1>  DB 11111000b
  8560 0000266F 0100                <1>  DW 1
  8561 00002671 0000                <1>  DW 0
  8562 00002673 0000                <1>  DW 0
  8563 00002675 0000                <1>  DW 0
  8564 00002677 0000                <1>  dw 0
  8565 00002679 00000000            <1>  dd 0
  8566 0000267D 00                  <1>  DB 0
  8567                              <1> 
  8568 0000267E 0000                <1>  DW 0
  8569 00002680 03                  <1>  DB 3
  8570                              <1> 
  8571 00002681 2000                <1>  DW 20h
  8572 00002683 2800                <1>  DW 40
  8573                              <1> 
  8574 00002685 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 000026A4 FF                  <1>  DB -1
  8577                              <1> 
  8578 000026A5 0100                <1>  DW 1
  8579                              <1> 
  8580 000026A7 0000                <1>  DW 0
  8581                              <1> 
  8582 000026A9 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 000026B2 202000              <1>
  8583 000026B5 00000000            <1>  dd 0
  8584 000026B9 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 000026C2 FFFF                <1>  DW -1
  8548 000026C4 0000                <1>  DW 0
  8549 000026C6 50                  <1>  DB 50h
  8550 000026C7 03                  <1>  DB 3
  8551                              <1> 
  8552 000026C8 0002                <1>  DW 512
  8553                              <1> 
  8554 000026CA 01                  <1>  db 1
  8555 000026CB 0100                <1>  DW 1
  8556 000026CD 02                  <1>  DB 2
  8557 000026CE 1000                <1>  DW 16
  8558 000026D0 0000                <1>  DW 0
  8559 000026D2 F8                  <1>  DB 11111000b
  8560 000026D3 0100                <1>  DW 1
  8561 000026D5 0000                <1>  DW 0
  8562 000026D7 0000                <1>  DW 0
  8563 000026D9 0000                <1>  DW 0
  8564 000026DB 0000                <1>  dw 0
  8565 000026DD 00000000            <1>  dd 0
  8566 000026E1 00                  <1>  DB 0
  8567                              <1> 
  8568 000026E2 0000                <1>  DW 0
  8569 000026E4 03                  <1>  DB 3
  8570                              <1> 
  8571 000026E5 2000                <1>  DW 20h
  8572 000026E7 2800                <1>  DW 40
  8573                              <1> 
  8574 000026E9 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 00002708 FF                  <1>  DB -1
  8577                              <1> 
  8578 00002709 0100                <1>  DW 1
  8579                              <1> 
  8580 0000270B 0000                <1>  DW 0
  8581                              <1> 
  8582 0000270D 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 00002716 202000              <1>
  8583 00002719 00000000            <1>  dd 0
  8584 0000271D 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8546                              <1> 
  8547 00002726 FFFF                <1>  DW -1
  8548 00002728 0000                <1>  DW 0
  8549 0000272A 50                  <1>  DB 50h
  8550 0000272B 03                  <1>  DB 3
  8551                              <1> 
  8552 0000272C 0002                <1>  DW 512
  8553                              <1> 
  8554 0000272E 01                  <1>  db 1
  8555 0000272F 0100                <1>  DW 1
  8556 00002731 02                  <1>  DB 2
  8557 00002732 1000                <1>  DW 16
  8558 00002734 0000                <1>  DW 0
  8559 00002736 F8                  <1>  DB 11111000b
  8560 00002737 0100                <1>  DW 1
  8561 00002739 0000                <1>  DW 0
  8562 0000273B 0000                <1>  DW 0
  8563 0000273D 0000                <1>  DW 0
  8564 0000273F 0000                <1>  dw 0
  8565 00002741 00000000            <1>  dd 0
  8566 00002745 00                  <1>  DB 0
  8567                              <1> 
  8568 00002746 0000                <1>  DW 0
  8569 00002748 03                  <1>  DB 3
  8570                              <1> 
  8571 00002749 2000                <1>  DW 20h
  8572 0000274B 2800                <1>  DW 40
  8573                              <1> 
  8574 0000274D 00<rep 1Fh>         <1>  times 31 db 0
  8575                              <1> 
  8576 0000276C FF                  <1>  DB -1
  8577                              <1> 
  8578 0000276D 0100                <1>  DW 1
  8579                              <1> 
  8580 0000276F 0000                <1>  DW 0
  8581                              <1> 
  8582 00002771 4E4F204E414D452020- <1>  db "NO NAME    ",0
  8582 0000277A 202000              <1>
  8583 0000277D 00000000            <1>  dd 0
  8584 00002781 464154313220202000  <1>  db "FAT12   ",0
  8585                              <1> 
  8587                                  
  8588                                  ;** End_of_BDSM defined in MSINIT.ASM will be used to set the appropriate
  8589                                  ;** ending address of BDSM table.
  8590                                  ;;End of modification ----------------------------
  8591                                  
  8592                                  ;
  8593                                  ;;3.3 BUG FIX -SP ------------------------------
  8594                                  ;Paragraph buffer between the BDSMs and MSHARD
  8595                                  ;
  8596                                  ;The relocation code for MSHARD needs this. this cannot be used for 
  8597                                  ;anything. nothing can come before this or after this.....IMPORTANT!!!!
  8598                                  ;don't get too smart and using this buffer for anything!!!!!!
  8599                                  ;
  8600 0000278A 00<rep 10h>             		times 16 db 0
  8601                                  ;
  8602                                  ;end of bug fix buffer
  8603                                  ;;
  8604                                  ;;3.3 BUG FIX -SP------------------------------
  8605                                  
  8606                                  ;-----------------------------------------------------------------------------
  8607                                  ; MSHARD.ASM - MSDOS 3.3 - 24/07/1987
  8608                                  ;-----------------------------------------------------------------------------
  8609                                  ; 02/06/2018 - Retro DOS v3.0
  8610                                  
  8611                                  ;***
  8612                                  ;	Title:	Disk
  8613                                  ;	By:	Michael Hanson
  8614                                  ;	C:	Copyright (C) 1985-1987 by Microsoft corp.
  8615                                  ;	Date:	1/11/85
  8616                                  ;
  8617                                  ;		There is a bug in some versions of IBM's AT ROM BIOS
  8618                                  ;		interupts are not disabled during read operations.
  8619                                  ;
  8620                                  ;	Use:	This program should be chained in line with the disk
  8621                                  ;		interrupt 13h, it intercepts read calls to the hard disk
  8622                                  ;		and handles them appropriately.  For other functions it
  8623                                  ;		passes controll to OLD13, which should contain the
  8624                                  ;		address of the AT ROM disk routine. The entry point for
  8625                                  ;		this program is IBM_DISK_IO.
  8626                                  ;
  8627                                  
  8628                                  	; .286c		;Use 80286 non-protected mode
  8629                                  
  8630                                  BIOSEG	equ	040h	;Segment for ROM BIOS Data
  8631                                  ROMSEG	equ	0F000h	;Segment of ROM
  8632                                  
  8633                                  BAD_DISK equ	01
  8634                                  
  8635                                  HF_PORT	equ	01F0h
  8636                                  HF_REG_PORT equ	03F6h
  8637                                  
  8638                                  ;*	Offsets into Fixed disk parameter table
  8639                                  FDP_PRECOMP	equ 5
  8640                                  FDP_CONTROL	equ 8
  8641                                  
  8642                                  ;DATA	SEGMENT AT BIOSEG	;ROM BIOS data segment
  8643                                  
  8644                                  	;ORG 42h
  8645                                  ;CMD_BLOCK	DB 6 DUP (?)
  8646                                  
  8647                                  CMD_BLOCK equ 42h ; 6 bytes, hard disk controller command bytes	
  8648                                  
  8649                                  ;*	Offsets into CMD_BLOCK for registers
  8650                                  PRE_COMP equ 0	;Write Pre-compensation
  8651                                  SEC_CNT	 equ 1	;Sector count
  8652                                  SEC_NUM	 equ 2	;Sector number
  8653                                  CYL_LOW	 equ 3	;Cylinder number, low part
  8654                                  CYL_HIGH equ 4	;Cylinder number, high part
  8655                                  DRV_HEAD equ 5	;Drive/Head (Bit 7 = ECC mode, Bit 5 = 512 byte sectors, 
  8656                                  		;            Bit 4 = drive number, Bits 3-0 have head number)
  8657                                  CMD_REG  equ 6	;Command register
  8658                                  
  8659                                  	;ORG 074h
  8660                                  
  8661                                  ;DISK_STATUS1 	DB ?
  8662                                  ;HF_NUM		DB ?
  8663                                  ;CONTROL_BYTE	DB ?
  8664                                  
  8665                                  DISK_STATUS1 equ 74h ; 1 byte
  8666                                  HF_NUM	     equ 75h ; 1 byte
  8667                                  CONTROL_BYTE equ 76h ; 1 byte 	  	
  8668                                  
  8669                                  ;DATA	ENDS
  8670                                  
  8671                                  ;***	Define where the ROM routines are actually located
  8672                                  ;ROM	SEGMENT AT ROMSEG
  8673                                  
  8674                                  	;ORG 02E1Eh
  8675                                  ;ROMCOMMAND PROC FAR
  8676                                  ;ROMCOMMAND ENDP
  8677                                  
  8678                                  ROMCOMMAND equ 02E1Eh
  8679                                  
  8680                                  	;ORG 02E7Fh
  8681                                  ;ROMWAIT PROC FAR
  8682                                  ;ROMWAIT ENDP
  8683                                  
  8684                                  ROMWAIT	equ 02E7Fh
  8685                                  
  8686                                  	;ORG 02EE2h
  8687                                  ;ROMWAIT_DRQ PROC FAR
  8688                                  ;ROMWAIT_DRQ ENDP
  8689                                  
  8690                                  ROMWAIT_DRQ equ 02EE2h
  8691                                  
  8692                                  	;ORG 02EF8h
  8693                                  ;ROMCHECK_STATUS PROC FAR
  8694                                  ;ROMCHECK_STATUS ENDP
  8695                                  
  8696                                  ROMCHECK_STATUS equ 02EF8h
  8697                                  
  8698                                  ;	ORG 02F69h
  8699                                  ;ROMCHECK_DMA PROC FAR
  8700                                  ;ROMCHECK_DMA ENDP
  8701                                   
  8702                                  ROMCHECK_DMA equ 02F69h
  8703                                  
  8704                                  ;	ORG 02F8Eh
  8705                                  ;ROMGET_VEC PROC FAR
  8706                                  ;ROMGET_VEC ENDP
  8707                                  
  8708                                  ROMGET_VEC equ 2F8Eh	
  8709                                  
  8710                                  ;	ORG 0FF65h
  8711                                  ;ROMFRET PROC FAR	;Far return at F000:FF65 in AT ROM.
  8712                                  ;ROMFRET ENDP
  8713                                  
  8714                                  ROMFRET	equ 0FF65h
  8715                                  
  8716                                  ;ROM	ENDS
  8717                                  
  8718                                  
  8719                                  ;CODE	SEGMENT BYTE PUBLIC 'code'
  8720                                  
  8721                                  ;EXTRN	OLD13:DWORD		;Link to AT bios int 13h
  8722                                  
  8723                                  ;PUBLIC	IBM_DISK_IO	
  8724                                  
  8725                                  ;	ASSUME CS:CODE
  8726                                  ;	ASSUME DS:DATA
  8727                                  
  8728                                  
  8729                                  ;***	IBM_DISK_IO - main routine, fixes AT ROM bug
  8730                                  ;
  8731                                  ;	ENTRY:	(AH) = function, 02 or 0A for read.
  8732                                  ;		(DL) = drive number (80h or 81h).
  8733                                  ;		(DH) = head number.
  8734                                  ;		(CH) = cylinder number.
  8735                                  ;		(CL) = Sector number (high 2 bits has cylinder number).
  8736                                  ;		(AL) = number of sectors.
  8737                                  ;		(ES:BX) = address of read buffer.
  8738                                  ;		For more on register contents see ROM BIOS listing.
  8739                                  ;		Stack set up for return by an IRET.
  8740                                  ;
  8741                                  ;	EXIT:	(AH) = status of current operation.
  8742                                  ;		(CY) = 1 IF failed, 0 if successful.
  8743                                  ;		For other register contents see ROM BIOS listing.
  8744                                  ;
  8745                                  ;	USES:	
  8746                                  ;
  8747                                  ;
  8748                                  ;	WARNING: Uses OLD13 vector for non-read calls.
  8749                                  ;		Does direct calls to the AT ROM.
  8750                                  ;		Does segment arithmatic.
  8751                                  ;
  8752                                  ;	EFFECTS: Performs DISK I/O operation.
  8753                                  ;
  8754                                  ;IBM_DISK_IO PROC FAR
  8755                                  
  8756                                  IBM_DISK_IO:
  8757 0000279A 80FA80                  		CMP	DL,80h
  8758 0000279D 720A                    		JB	short ATD1	;Pass through floppy disk calls.
  8759 0000279F 80FC02                  		CMP	AH,02h
  8760 000027A2 740A                    		JE	short ATD2	;Intercept call 02 (read sectors).
  8761 000027A4 80FC0A                  		CMP	AH,0Ah
  8762 000027A7 7405                    		JE	short ATD2	;and call 0Ah (read long).
  8763                                  ATD1:
  8764                                  		; 16/06/2018
  8765 000027A9 2EFF2E[C206]            		JMP	far [cs:OLD13]	;Use ROM INT 13h handler.
  8766                                  ATD2:
  8767 000027AE 53                      		PUSH	BX
  8768 000027AF 51                      		PUSH	CX
  8769 000027B0 52                      		PUSH	DX
  8770 000027B1 57                      		PUSH	DI
  8771 000027B2 1E                      		PUSH	DS
  8772 000027B3 06                      		PUSH	ES
  8773 000027B4 50                      		PUSH	AX
  8774 000027B5 B84000                  		MOV	AX,BIOSEG	;Establish BIOS segment addressing.
  8775 000027B8 8ED8                    		MOV	DS,AX
  8776 000027BA C606740000              		MOV	byte [DISK_STATUS1],0 ;Initially no error code.
  8777 000027BF 80E27F                  		AND	DL,07Fh		;Mask to hard disk number
  8778 000027C2 3A167500                		CMP	DL,[HF_NUM]
  8779 000027C6 7207                    		JB	short ATD3	;Disk number in range
  8780 000027C8 C606740001              		MOV	byte [DISK_STATUS1],BAD_DISK
  8781 000027CD EB20                    		JMP	SHORT ATD4	;Disk number out of range error, return
  8782                                  
  8783                                  ATD3:
  8784 000027CF 53                      		PUSH	BX
  8785 000027D0 8CC0                    		MOV	AX,ES		;Make ES:BX to Seg:000x form.
  8786 000027D2 C1EB04                  		SHR	BX,4
  8787 000027D5 01D8                    		ADD	AX,BX
  8788 000027D7 8EC0                    		MOV	ES,AX
  8789 000027D9 5B                      		POP	BX
  8790 000027DA 83E30F                  		AND	BX,000Fh
  8791 000027DD 0E                      		PUSH	CS
  8792 000027DE E8DD00                  		CALL	CHECK_DMA
  8793 000027E1 720C                    		JC	short ATD4	;Abort if DMA across segment boundary
  8794                                  
  8795 000027E3 58                      		POP	AX		;Restore AX register for SETCMD
  8796 000027E4 50                      		PUSH	AX
  8797 000027E5 E81900                  		CALL	SETCMD		;Set up command block for disk op
  8798 000027E8 BAF603                  		MOV	DX,HF_REG_PORT
  8799 000027EB EE                      		OUT	DX,AL		;Write out command modifier
  8800 000027EC E86A00                  		CALL	DOCMD		;Carry out command
  8801                                  ATD4:
  8802 000027EF 58                      		POP	AX
  8803 000027F0 8A267400                		MOV	AH,[DISK_STATUS1] ;On return AH has error code
  8804                                  		; 16/06/2018
  8805                                  		;STC
  8806                                  		;OR	AH,AH
  8807                                  		;JNZ	short ATD5	;Carry set if error
  8808                                  		;CLC
  8809                                  ;ATD5:
  8810 000027F4 80FC01                  		cmp	ah,1
  8811 000027F7 F5                      		cmc	
  8812                                  
  8813 000027F8 07                      		POP	ES
  8814 000027F9 1F                      		POP	DS
  8815 000027FA 5F                      		POP	DI
  8816 000027FB 5A                      		POP	DX
  8817 000027FC 59                      		POP	CX
  8818 000027FD 5B                      		POP	BX
  8819                                  		; 16/06/2018
  8820 000027FE CA0200                  		RETF	2		;Far return, dropping flags
  8821                                  
  8822                                  ;IBM_DISK_IO ENDP
  8823                                  
  8824                                  ;***	SETCMD - Set up CMD_BLOCK for the disk operation
  8825                                  ;
  8826                                  ;	ENTRY:	(DS) = BIOS Data segment.
  8827                                  ;		(ES:BX) in seg:000x form.
  8828                                  ;		Other registers as in INT 13h call
  8829                                  ;	
  8830                                  ;	EXIT:	CMD_BLOCK set up for disk read call.
  8831                                  ;		CONTROL_BYTE set up for disk operation.
  8832                                  ;		(AL) = Control byte modifier
  8833                                  ;
  8834                                  ;
  8835                                  ;	Sets the fields of CMD_BLOCK using the register contents
  8836                                  ;	and the contents of the disk parameter block for the given drive.
  8837                                  ;
  8838                                  ;	WARNING: (AX) destroyed.
  8839                                  ;		Does direct calls to the AT ROM.
  8840                                  ;
  8841                                  
  8842                                  ;SETCMD	PROC NEAR
  8843                                  
  8844                                  SETCMD:
  8845 00002801 A24300                  		MOV	[CMD_BLOCK+SEC_CNT],AL
  8846 00002804 C606480020              		MOV	byte [CMD_BLOCK+CMD_REG],020h ;Assume function 02
  8847 00002809 80FC02                  		CMP	AH, 2
  8848 0000280C 7405                    		JE	short SETC1	;CMD_REG = 20h if function 02 (read)
  8849                                     					;CMD_REG = 22h if function 0A (" long)
  8850 0000280E C606480022              		MOV	byte [CMD_BLOCK+CMD_REG],022h
  8851                                  SETC1:					;No longer need value in AX
  8852 00002813 88C8                    		MOV	AL,CL
  8853 00002815 243F                    		AND	AL,03Fh		;Mask to sector number
  8854 00002817 A24400                  		MOV 	[CMD_BLOCK+SEC_NUM],AL
  8855 0000281A 882E4500                		MOV	[CMD_BLOCK+CYL_LOW],CH
  8856 0000281E 88C8                    		MOV	AL,CL
  8857 00002820 C0E806                  		SHR	AL,6		;Get two high bits of cylinder number
  8858 00002823 A24600                  		MOV	[CMD_BLOCK+CYL_HIGH],AL
  8859 00002826 89D0                    		MOV	AX,DX
  8860 00002828 C0E004                  		SHL	AL,4		;Drive number
  8861 0000282B 80E40F                  		AND	AH,0Fh
  8862 0000282E 08E0                    		OR	AL,AH		;Head number
  8863 00002830 0CA0                    		OR	AL,0A0h		;Set ECC and 512 bytes per sector
  8864 00002832 A24700                  		MOV	[CMD_BLOCK+DRV_HEAD],AL
  8865 00002835 06                      		PUSH	ES		;GET_VEC destroys ES:BX
  8866 00002836 53                      		PUSH	BX
  8867 00002837 0E                      		PUSH	CS
  8868 00002838 E85B00                  		CALL	GET_VEC
  8869                                  					;Write pre-comp from disk parameters
  8870 0000283B 268B4705                		MOV	AX,[ES:BX+FDP_PRECOMP]
  8871 0000283F C1E802                  		SHR	AX,2
  8872 00002842 A24200                  		MOV	[CMD_BLOCK+PRE_COMP],AL	;Only use low part
  8873 00002845 268A4708                		MOV	AL,[ES:BX+FDP_CONTROL]	;Control byte modifier
  8874 00002849 5B                      		POP	BX
  8875 0000284A 07                      		POP	ES
  8876 0000284B 8A267600                		MOV	AH,[CONTROL_BYTE]
  8877 0000284F 80E4C0                  		AND	AH,0C0h		;Keep disable retry bits
  8878 00002852 08C4                    		OR	AH,AL
  8879 00002854 88267600                		MOV	[CONTROL_BYTE],AH
  8880 00002858 C3                      		RETN
  8881                                  
  8882                                  ;SETCMD	ENDP	
  8883                                  
  8884                                  ;***	DOCMD - Carry out READ operation to AT hard disk
  8885                                  ;
  8886                                  ;	ENTRY:	(ES:BX) = address for read in data.
  8887                                  ;		CMD_BLOCK set up for disk read.
  8888                                  ;
  8889                                  ;	EXIT:	Buffer at (ES:BX) contains data read.
  8890                                  ;		DISK_STATUS1 set to error code (0 if success).
  8891                                  ;
  8892                                  ;	
  8893                                  ;
  8894                                  ;	WARNING: (AX), (BL), (CX), (DX), (DI) destroyed.
  8895                                  ;		No check is made for DMA boundary overrun.
  8896                                  ;
  8897                                  ;	EFFECTS: Programs disk controller.
  8898                                  ;		Performs disk input.
  8899                                  ;
  8900                                  
  8901                                  ;DOCMD	PROC NEAR
  8902                                  DOCMD:
  8903 00002859 89DF                    		MOV	DI,BX	;(ES:DI) = data buffer addr.
  8904 0000285B 0E                      		PUSH	CS
  8905 0000285C E83F00                  		CALL	COMMAND
  8906 0000285F 7534                    		JNZ	short DOC3
  8907                                  DOC1:
  8908 00002861 0E                      		PUSH	CS
  8909 00002862 E84100                  		CALL	_WAIT	;Wait for controller to complete read
  8910 00002865 752E                    		JNZ	short DOC3
  8911 00002867 B90001                  		MOV	CX,100h	;256 words per sector
  8912 0000286A BAF001                  		MOV	DX,HF_PORT
  8913 0000286D FC                      		CLD		;String op goes up
  8914 0000286E FA                      		CLI		;Disable interrupts (BUG WAS FORGETTING THIS)
  8915 0000286F F36D                    		REPZ	INSW	;Read in sector
  8916 00002871 FB                      		STI
  8917 00002872 F606480002              		TEST	byte [CMD_BLOCK+CMD_REG],02h
  8918 00002877 7410                    		JZ	short DOC2 ;No ECC bytes to read.
  8919 00002879 0E                      		PUSH	CS
  8920 0000287A E83100                  		CALL	WAIT_DRQ
  8921 0000287D 7216                    		JC	short DOC3
  8922 0000287F B90400                  		MOV	CX,4	;4 bytes of ECC
  8923 00002882 BAF001                  		MOV	DX,HF_PORT
  8924 00002885 FA                      		CLI
  8925 00002886 F36C                    		REPZ	INSB	;Read in ECC
  8926 00002888 FB                      		STI
  8927                                  DOC2:
  8928 00002889 0E                      		PUSH	CS
  8929 0000288A E82900                  		CALL	CHECK_STATUS
  8930 0000288D 7506                    		JNZ	short DOC3 ;Operation failed
  8931 0000288F FE0E4300                		DEC	byte  [CMD_BLOCK+SEC_CNT]	
  8932 00002893 75CC                    		JNZ	short DOC1 ;Loop while more sectors to read
  8933                                  DOC3:
  8934 00002895 C3                      		RETN
  8935                                  
  8936                                  ;DOCMD	ENDP
  8937                                  
  8938                                  ;***	GET_VEC - Get pointer to hard disk parameters.
  8939                                  ;
  8940                                  ;	ENTRY:	(DL) = Low bit has hard disk number (0 or 1).
  8941                                  ;
  8942                                  ;	EXIT:	(ES:BX) = address of disk parameters table.
  8943                                  ;
  8944                                  ;	USES:	AX for segment computation.
  8945                                  ;
  8946                                  ;	Loads ES:BX from interrupt table in low memory, vector 46h (disk 0)
  8947                                  ;	or 70h (disk 1).
  8948                                  ;	
  8949                                  ;	WARNING: (AX) destroyed.
  8950                                  ;		This does a direct call to the AT ROM.
  8951                                  ;
  8952                                  
  8953                                  ;GET_VEC PROC NEAR
  8954                                  GET_VEC:
  8955                                  		;PUSH	OFFSET ROMFRET
  8956 00002896 6865FF                  		push	ROMFRET
  8957                                  		;JMP	ROMGET_VEC
  8958 00002899 EA8E2F00F0              		jmp	ROMSEG:ROMGET_VEC
  8959                                  ;GET_VEC ENDP
  8960                                  
  8961                                  ;***	COMMAND - Send contents of CMD_BLOCK to disk controller.
  8962                                  ;
  8963                                  ;	ENTRY:	Control_byte 
  8964                                  ;		CMD_BLOCK - set up with values for hard disk controller.
  8965                                  ;
  8966                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8967                                  ;		NZ if error, ZR for no error.
  8968                                  ;
  8969                                  ;
  8970                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  8971                                  ;		Does a direct call to the AT ROM.
  8972                                  ;
  8973                                  ;	EFFECTS: Programs disk controller.
  8974                                  ;
  8975                                  
  8976                                  ;COMMAND PROC NEAR
  8977                                  COMMAND:
  8978                                  		;PUSH	OFFSET ROMFRET
  8979 0000289E 6865FF                  		push	ROMFRET	
  8980                                  		;JMP	ROMCOMMAND
  8981 000028A1 EA1E2E00F0              		jmp	ROMSEG:ROMCOMMAND
  8982                                  ;COMMAND ENDP
  8983                                  
  8984                                  ;***	WAIT - Wait for disk interrupt
  8985                                  ;
  8986                                  ;	ENTRY:	Nothing.
  8987                                  ;
  8988                                  ;	EXIT:	DISK_STATUS1 = Error code.
  8989                                  ;		NZ if error, ZR if no error.
  8990                                  ;
  8991                                  ;
  8992                                  ;	WARNING: (AX), (BL), (CX) destroyed.
  8993                                  ;		Does a direct call to the AT ROM.
  8994                                  ;		
  8995                                  ;	EFFECTS: Calls int 15h, function 9000h.
  8996                                  ;
  8997                                  
  8998                                  ;WAIT	PROC NEAR
  8999                                  _WAIT:
  9000                                  		;PUSH	OFFSET ROMFRET 
  9001 000028A6 6865FF                  		push	ROMFRET
  9002                                  		;JMP	ROMWAIT
  9003 000028A9 EA7F2E00F0              		jmp	ROMSEG:ROMWAIT
  9004                                  ;WAIT	ENDP
  9005                                  
  9006                                  ;***	WAIT_DRQ - Wait for data request.
  9007                                  ;
  9008                                  ;	ENTRY:	Nothing.
  9009                                  ;
  9010                                  ;	EXIT:	DISK_STATUS1 = Error code.
  9011                                  ;		CY if error, NC if no error.
  9012                                  ;
  9013                                  ;
  9014                                  ;	WARNING: (AL), (CX), (DX) destroyed.
  9015                                  ;		Does a direct call to the AT ROM.
  9016                                  ;
  9017                                  
  9018                                  ;WAIT_DRQ PROC NEAR
  9019                                  WAIT_DRQ:
  9020                                  		;PUSH	OFFSET ROMFRET 
  9021 000028AE 6865FF                  		push	ROMFRET
  9022                                  		;JMP	ROMWAIT_DRQ
  9023 000028B1 EAE22E00F0              		jmp	ROMSEG:ROMWAIT_DRQ
  9024                                  ;WAIT_DRQ ENDP
  9025                                  
  9026                                  ;***	CHECK_STATUS - Check hard disk status.
  9027                                  ;
  9028                                  ;	ENTRY:	Nothing.
  9029                                  ;
  9030                                  ;	EXIT:	DISK_STATUS1 = Error code.
  9031                                  ;		NZ if error, ZR if no error.
  9032                                  ;
  9033                                  ;
  9034                                  ;	WARNING: (AX), (CX), (DX) destroyed.
  9035                                  ;		Does a direct call to the AT ROM.
  9036                                  ;
  9037                                  
  9038                                  ;CHECK_STATUS PROC NEAR
  9039                                  CHECK_STATUS:
  9040                                  		;PUSH	OFFSET ROMFRET 
  9041 000028B6 6865FF                  		push	ROMFRET
  9042                                  		;JMP	ROMCHECK_STATUS
  9043 000028B9 EAF82E00F0              		jmp	ROMSEG:ROMCHECK_STATUS
  9044                                  ;CHECK_STATUS ENDP
  9045                                  
  9046                                  ;***	CHECK_DMA - check for DMA overrun 64k segment.
  9047                                  ;
  9048                                  ;	ENTRY:	(ES:BX) = addr. of memory buffer in seg:000x form.
  9049                                  ;		CMD_BLOCK set up for operation.
  9050                                  ;
  9051                                  ;	EXIT:	DISK_STATUS1 - Error code.
  9052                                  ;		CY if error, NC if no error.
  9053                                  ;
  9054                                  ;
  9055                                  ;	WARNING: Does a direct call to the AT ROM.
  9056                                  ;
  9057                                  
  9058                                  ;CHECK_DMA PROC NEAR
  9059                                  CHECK_DMA:
  9060                                  		;PUSH	OFFSET ROMFRET 
  9061 000028BE 6865FF                  		push	ROMFRET
  9062                                  		;JMP	ROMCHECK_DMA
  9063 000028C1 EA692F00F0              		jmp	ROMSEG:ROMCHECK_DMA	
  9064                                  ;CHECK_DMA ENDP
  9065                                  
  9066                                  
  9067                                  ;CODE	ENDS
  9068                                  ;	END
  9069                                  
  9070                                  ;-----------------------------------------------------------------------------
  9071                                  ; MSINIT.ASM - MSDOS 3.3 - 02/02/1988
  9072                                  ;-----------------------------------------------------------------------------
  9073                                  ; 02/06/2018 - Retro DOS v3.0
  9074                                  ; 19/03/2018 - Retro DOS v2.0
  9075                                  
  9076                                  ENDATROM:
  9077                                  
  9078                                  ;CMOS Clock setting support routines used by MSCLOCK.		
  9079                                  ;Warning!!! This code will be dynamically relocated by MSINIT.
  9080                                  
  9081                                  Daycnt_To_Day:
  9082                                  ;Entry: [DAYCNT] = number of days since 1-1-80
  9083                                  ;Return: CH=centry in BCD, CL=year in BCD, DH=month in BCD, DL=day in BCD
  9084                                  									 
  9085 000028C6 2EFF36[7205]            		push	word [cs:DAYCNT]	;save daycnt			 
  9086 000028CB 2E813E[7205]891C        		cmp	word [cs:DAYCNT], (365*20+(20/4)) 
  9087                                  						;# days from 1-1-1980 to 1-1-2000
  9088 000028D2 730E                    		jae	short century20						 
  9089 000028D4 2EC606[7505]13          		mov	byte [cs:base_century], 19					 
  9090 000028DA 2EC606[7605]50          		mov	byte [cs:base_year], 80						 
  9091 000028E0 EB13                    		jmp	short years							 
  9092                                  century20:				;20th century			 
  9093 000028E2 2EC606[7505]14          		mov	byte [cs:base_century], 20					 
  9094 000028E8 2EC606[7605]00          		mov	byte [cs:base_year], 0						 
  9095 000028EE 2E812E[7205]891C        		sub	word [cs:DAYCNT], (365*20+(20/4)) ;adjust daycnt			 
  9096                                  years:									 
  9097 000028F5 31D2                    		xor	dx, dx							 
  9098 000028F7 2EA1[7205]              		mov	ax, [cs:DAYCNT]						 
  9099 000028FB BBB505                  		mov	bx, (366+365*3) 	;# of days in a Leap year block  
  9100 000028FE F7F3                    		div	bx			;AX = # of leap block, DX=daycnt 
  9101 00002900 2E8916[7205]            		mov	[cs:DAYCNT], dx		;save daycnt left		 
  9102                                  ;	or	ah, ah				;ax should be less than 256	 
  9103                                  ;	jz	short OK1							 
  9104                                  ;	jmp	Erroroccur						 
  9105                                  ;OK1:									 
  9106 00002905 B304                    		mov	bl, 4							 
  9107 00002907 F6E3                    		mul	bl			;AX=# of years. Less than 100	 
  9108 00002909 2E0006[7605]            		add	[cs:base_year], al	;So, ah = 0. Adjust year	 
  9109 0000290E 2EFF06[7205]            		inc	word [cs:DAYCNT]	;set daycnt to 1 base		 
  9110 00002913 2E813E[7205]6E01        		cmp	word [cs:DAYCNT], 366	;daycnt=remainder of leap year bk
  9111 0000291A 7626                    		jbe	short Leapyear		;within 366+355+355+355 days.	 
  9112 0000291C 2EFE06[7605]            		inc	byte [cs:base_year]	;if daycnt <= 366, then leap year
  9113 00002921 2E812E[7205]6E01        		sub	word [cs:DAYCNT], 366	;else daycnt--, base_year++;	 
  9114                                  					;And next three years are normal 
  9115 00002928 B90300                  		mov	cx, 3							 
  9116                                  Regularyear:								 
  9117 0000292B 2E813E[7205]6D01        		cmp	word [cs:DAYCNT], 365	;for(i=1; i>3 or daycnt <=365;i++)
  9118 00002932 7614                    		jbe	short Yeardone		;{if (daycnt > 365)		
  9119 00002934 2EFE06[7605]            		inc	byte [cs:base_year]	;  { daycnt -= 365		
  9120 00002939 2E812E[7205]6D01        		sub	word [cs:DAYCNT], 365	;  }				
  9121 00002940 E2E9                    		loop	Regularyear		;}				
  9122                                  ;	jmp	Erroroccur		 ;cannot come to here		
  9123                                  Leapyear:								
  9124 00002942 2EC606[7805]1D          		mov	byte [cs:month_tab+1],29 ;leap year. change month table. 
  9125                                  Yeardone:								
  9126 00002948 31DB                    		xor	bx, bx							
  9127 0000294A 31D2                    		xor	dx, dx							
  9128 0000294C 2EA1[7205]              		mov	ax, [cs:DAYCNT]						
  9129 00002950 BE[7705]                		mov	si, month_tab					
  9130 00002953 B90C00                  		mov	cx, 12							
  9131                                  Months: 								
  9132 00002956 FEC3                    		inc	bl			;				
  9133                                  		;mov	dl, [si] ; 28/03/2018
  9134 00002958 2E8A14                  		mov	dl, [cs:si]		;cmp daycnt for each month til fit
  9135 0000295B 39D0                    		cmp	ax, dx			;dh=0.				 
  9136 0000295D 7605                    		jbe	short Month_done						 
  9137 0000295F 46                      		inc	si			;next month			 
  9138 00002960 29D0                    		sub	ax, dx			;adjust daycnt			 
  9139 00002962 E2F2                    		loop	Months							 
  9140                                  ;	jmp	Erroroccur						 
  9141                                  Month_done:								 
  9142 00002964 2EC606[7805]1C          		mov	byte [cs:month_tab+1], 28 ;restore month table value	 
  9143 0000296A 88DA                    		mov	dl, bl							 
  9144 0000296C 2E8A36[7605]            		mov	dh, [cs:base_year]						 
  9145 00002971 2E8A0E[7505]            		mov	cl, [cs:base_century]	;al=day,dl=month,dh=year,cl=cntry
  9146                                  
  9147                                  ;	call Bin_To_BCD	
  9148 00002976 2EFF16[8305]            		call	word [cs:BinToBCD]	;To save 15 bytes, Bin_To_BCD proc
  9149                                  						;was rel from Daycnt_to_Day proc. 
  9150                                  ;	call Bin_To_BCD 			;convert "day" to bcd             
  9151 0000297B 86D0                    		xchg	dl, al			;dl = bcd day, al = month	  
  9152 0000297D 2EFF16[8305]            		call	word [cs:BinToBCD]					  
  9153                                  ;	call Bin_To_BCD 						  
  9154 00002982 86F0                    		xchg	dh, al			;dh = bcd month, al = year	  
  9155 00002984 2EFF16[8305]            		call	word [cs:BinToBCD]					  
  9156                                  ;	call Bin_To_BCD 						  
  9157 00002989 86C8                    		xchg	cl, al			;cl = bcd year, al = century	 
  9158 0000298B 2EFF16[8305]            		call	word [cs:BinToBCD]					 
  9159                                  					 
  9160 00002990 88C5                    		mov	ch, al			;ch = bcd century		 
  9161 00002992 2E8F06[7205]            		pop	word [cs:DAYCNT]	;restore original value 	 
  9162 00002997 C3                      		retn								 
  9163                                  						 
  9164                                  	;public	EndDaycntToDay						 
  9165                                  EndDaycntToDay:						 
  9166                                  									 
  9167                                  	;public	Bin_To_BCD						 
  9168                                  Bin_To_BCD:			; real time clock sup
  9169                                  ;Convert a binary input in AL (less than 63h or 99 decimal)
  9170                                  ;into a bcd value in AL.  AH destroyed. 			
  9171 00002998 51                      		push	cx						
  9172 00002999 30E4                    		xor	ah, ah						
  9173 0000299B B10A                    		mov	cl, 10						
  9174 0000299D F6F1                    		div	cl			;al=high digit bcd, ah=low digit bcd
  9175 0000299F B104                    		mov	cl, 4						
  9176 000029A1 D2E0                    		shl	al, cl			;mov the high digit to high nibble
  9177 000029A3 08E0                    		or	al, ah							
  9178 000029A5 59                      		pop	cx							
  9179 000029A6 C3                      		retn								
  9180                                  					
  9181                                  	;Public	EndCMOSClockset 	;End of routines for CMOS clock 
  9182                                  EndCMOSClockSet:
  9183                                  
  9184                                  		;evenb
  9185 000029A7 90                      align 2
  9186                                  
  9187                                  ; 02/06/2018 - Retro DOS v3.0
  9188                                  
  9189                                  ;									
  9190                                  ; THE K09 REQUIRES ROUTINES FOR READING THE CLOCK BECAUSE OF THE SUSPEND/
  9191                                  ; RESUME FACILITY. THE SYSTEM CLOCK NEEDS TO BE RESET AFTER RESUME.	 
  9192                                  ;
  9193                                  
  9194                                  ;	ASSUME	ES:NOTHING									 
  9195                                  									 
  9196                                  ; THE FOLLOWING ROUTINE IS EXECUTED AT RESUME TIME WHEN THE SYSTEM	 
  9197                                  ; POWERED ON AFTER SUSPENSION. IT READS THE REAL TIME CLOCK AND 	 
  9198                                  ; RESETS THE SYSTEM TIME AND DATE, AND THEN IRETS.			 
  9199                                  ; Warning!!! This code will be dynamically relocated by MSINIT.
  9200                                  
  9201                                  ;INT6C	PROC	FAR							 
  9202                                  
  9203                                  INT6C:
  9204 000029A8 0E                      		PUSH	CS							 
  9205 000029A9 1F                      		POP	DS							 
  9206                                  									 
  9207                                  	;ASSUME DS:CODE							 
  9208                                  									 
  9209 000029AA 8F06[F91A]              		POP	WORD [INT6C_RET_ADDR] ; POP OFF RETURN ADDRESS	 
  9210 000029AE 8F06[FB1A]              		POP	WORD [INT6C_RET_ADDR+2]				 
  9211 000029B2 9D                      		POPF								 
  9212 000029B3 E81300                  		CALL	READ_REAL_DATE		; GET THE DATE FROM THE CLOCK	 
  9213 000029B6 FA                      		CLI								 
  9214 000029B7 8936[7205]              		MOV	[DAYCNT],SI		; UPDATE DOS COPY OF DATE 	 
  9215 000029BB FB                      		STI								 
  9216 000029BC E8BF00                  		CALL	READ_REAL_TIME		; GET THE TIME FROM THE RTC	 
  9217 000029BF FA                      		CLI								 
  9218 000029C0 B401                    		MOV	AH,01h			; COMMAND TO SET THE TIME
  9219 000029C2 CD1A                    		INT	1Ah			; CALL ROM-BIOS TIME ROUTINE 
  9220 000029C4 FB                      		STI								
  9221 000029C5 FF2E[F91A]              		JMP	far [INT6C_RET_ADDR]	; LONG JUMP			
  9222                                  									
  9223                                  ;INT6C	ENDP
  9224                                  
  9225                                  	;INCLUDE READCLOCK.INC						
  9226                                  	;INCLUDE CLOCKSUB.INC								
  9227                                  
  9228                                  ; 26/03/2018 - READCLOCK.INC, MSDOS 3.3, 24/07/1987
  9229                                  
  9230                                  ;************************************************************************
  9231                                  ;
  9232                                  ;   read_real_date reads real-time clock for date and returns the number
  9233                                  ;   of days elapsed since 1-1-80 in si
  9234                                  ;
  9235                                  READ_REAL_DATE: 			;MJB002
  9236 000029C9 50                      		PUSH	AX
  9237 000029CA 51                      		PUSH	CX
  9238 000029CB 52                      		PUSH	DX
  9239 000029CC 30E4                    		XOR	AH,AH		; throw away clock roll over
  9240 000029CE CD1A                    		INT	1AH					
  9241 000029D0 5A                      		POP	DX
  9242 000029D1 59                      		POP	CX
  9243 000029D2 58                      		POP	AX
  9244                                  
  9245 000029D3 50                      		PUSH	AX
  9246 000029D4 53                      		PUSH	BX
  9247 000029D5 51                      		PUSH	CX
  9248 000029D6 52                      		PUSH	DX
  9249                                  		;mov	word [CS:DAYCNT2],1 ; REAL TIME CLOCK ERROR FLAG (+1 DAY)
  9250 000029D7 C706[191B]0100          		mov	word [DAYCNT2],1
  9251 000029DD B404                    		mov	AH,4		; read date function code       
  9252 000029DF CD1A                    		int	1Ah		; read real-time clock	     
  9253                                  		;jnc	short read_ok 	; jmp success
  9254                                  		;jmp	r_d_ret 	; jmp error
  9255 000029E1 0F828B00                		jc	r_d_ret
  9256                                  read_ok:				; ******* get bcd values in binary *****
  9257 000029E5 882E[FD1A]              		mov	[BIN_DATE_TIME+0],ch  ; store as hex value
  9258 000029E9 880E[FE1A]              		mov	[BIN_DATE_TIME+1],cl  ; ...
  9259 000029ED 8836[FF1A]              		mov	[BIN_DATE_TIME+2],dh  ; ...
  9260 000029F1 8816[001B]              		mov	[BIN_DATE_TIME+3],dl  ; ...
  9261                                  		;mov	word [CS:DAYCNT2],2  ; READ OF R-T CLOCK SUCCESSFUL
  9262 000029F5 C706[191B]0200          		mov	word [DAYCNT2],2
  9263 000029FB E84B01                  		call	bcd_verify	; verify bcd values in range
  9264 000029FE 7270                    		jc	short r_d_ret 	; jmp some value out of range
  9265                                  		;mov	word [CS:DAYCNT2],3  ; READ OF R-T CLOCK SUCCESSFUL
  9266 00002A00 C706[191B]0300          		mov	word [DAYCNT2],3
  9267 00002A06 E8E900                  		call	date_verify	; verify date values in range
  9268 00002A09 7265                    		jc	short r_d_ret 	; jmp some value out of range
  9269                                  		;mov	word [CS:DAYCNT2],0  ; VERIFY SUCCESSFUL		  
  9270 00002A0B C706[191B]0000          		mov	word [DAYCNT2],0
  9271 00002A11 E8A300                  		call	in_bin		; convert date to binary
  9272                                  					; ******* years since 1-1-80 *********
  9273 00002A14 A0[FE1A]                		mov	al,[BIN_DATE_TIME+1]  ; get years into century
  9274 00002A17 98                      		cbw				     ;
  9275 00002A18 803E[FD1A]14            		cmp	byte [BIN_DATE_TIME+0],20  ; 20th century?
  9276 00002A1D 7503                    		jnz	short century_19 ; jmp no
  9277 00002A1F 83C064                  		add	ax,100		; add in a century
  9278                                  century_19:			;
  9279 00002A22 83E850                  		sub	ax,80		; subtract off 1-1-80
  9280 00002A25 B104                    		mov	cl,4		; leap year every 4
  9281 00002A27 F6F1                    		div	cl		; al= # leap year blocks, ah= remainder
  9282 00002A29 88E3                    		mov	bl,ah		; save odd years
  9283 00002A2B 98                      		cbw			; zero ah
  9284 00002A2C B9B505                  		mov	cx,366+3*365	; # of days in leap year blocks
  9285 00002A2F F7E1                    		mul	cx		; dx:ax is result
  9286                                  		;mov	[CS:DAYCNT2],AX	; SAVE COUNT OF DAYS
  9287 00002A31 A3[191B]                		mov	[DAYCNT2],AX
  9288 00002A34 88D8                    		mov	al,bl		; get odd years count
  9289 00002A36 98                      		cbw			;
  9290 00002A37 09C0                    		or	ax,ax		; is ax= 0?
  9291 00002A39 740B                    		jz	short leap_year	; jmp if none
  9292 00002A3B B96D01                  		mov	cx,365		; days in year
  9293 00002A3E F7E1                    		mul	cx		; dx:ax is result
  9294                                  		;add	[CS:DAYCNT2],AX ; ADD ON DAYS IN ODD YEARS
  9295 00002A40 0106[191B]              		add	[DAYCNT2],AX
  9296 00002A44 EB07                    		jmp	short leap_adjustment ; account for leap year
  9297                                  leap_year:			; possibly account for a leap day
  9298 00002A46 803E[FF1A]02            		cmp	byte [BIN_DATE_TIME+2],2 ; is month february
  9299 00002A4B 7604                    		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
  9300                                  leap_adjustment:			; account for leap day
  9301                                  		;INC	word [CS:DAYCNT2] ; ...
  9302 00002A4D FF06[191B]              		INC	word [DAYCNT2]
  9303                                  no_leap_adjustment:			; ******* get days of month *******
  9304 00002A51 8A0E[001B]              		mov	cl,[BIN_DATE_TIME+3] ; ...
  9305 00002A55 30ED                    		xor	ch,ch		;
  9306 00002A57 49                      		dec	cx		; because of offset from day 1, not day 0
  9307                                  		;add	[CS:DAYCNT2],CX	; ******* GET DAYS IN MONTHS PRECEEDING *****
  9308 00002A58 010E[191B]              		add	[DAYCNT2],CX
  9309 00002A5C 8A0E[FF1A]              		mov	cl,[BIN_DATE_TIME+2] ; get month
  9310 00002A60 30ED                    		xor	ch,ch		;
  9311 00002A62 49                      		dec	cx		; january starts at offset 0
  9312 00002A63 D1E1                    		shl	cx,1		; word offset
  9313 00002A65 BE[011B]                		mov	si,MONTH_TABLE	; beginning of month_table
  9314 00002A68 01CE                    		add	si,cx		; point into month table
  9315 00002A6A 8B04                    		mov	ax,[si]		; get # days in previous months
  9316                                  		;add	[CS:DAYCNT2],AX ; ...
  9317 00002A6C 0106[191B]              		add	[DAYCNT2],AX
  9318                                  r_d_ret:			;
  9319                                  		;MOV	SI,[CS:DAYCNT2] ; RESULT IN SI
  9320 00002A70 8B36[191B]              		MOV	SI,[DAYCNT2]
  9321 00002A74 5A                      		POP	DX
  9322 00002A75 59                      		POP	CX
  9323 00002A76 5B                      		POP	BX
  9324 00002A77 58                      		POP	AX
  9325 00002A78 C3                      		retn			;
  9326                                  
  9327                                  r_t_retj:
  9328 00002A79 31C9                    		xor	cx,cx
  9329 00002A7B 31D2                    		xor	dx,dx
  9330                                  		;jmp	short r_t_ret
  9331 00002A7D C3                      		retn 	; 19/07/2019
  9332                                  ;
  9333                                  ; Read_Real_Time reads the time from the RTC. on exit, it has the number of
  9334                                  ; ticks (at 18.2 ticks per sec.) in CX:DX.
  9335                                  ;
  9336                                  READ_REAL_TIME:
  9337 00002A7E B402                    		mov	ah,2
  9338 00002A80 CD1A                    		int	1AH
  9339 00002A82 72F5                    		jc	short r_t_retj
  9340                                  oktime:
  9341 00002A84 882E[FD1A]              		mov	[BIN_DATE_TIME],ch		; hours
  9342 00002A88 880E[FE1A]              		mov	[BIN_DATE_TIME+1],cl		; minutes
  9343 00002A8C 8836[FF1A]              		mov	[BIN_DATE_TIME+2],dh		; seconds
  9344 00002A90 C606[001B]00            		mov	byte [BIN_DATE_TIME+3],0	; unused for time
  9345 00002A95 E8B100                  		call	bcd_verify
  9346 00002A98 72DF                    		jc	short r_t_retj
  9347 00002A9A E89300                  		call	time_verify
  9348 00002A9D 72DA                    		jc	short r_t_retj
  9349 00002A9F E81500                  		call	in_bin
  9350 00002AA2 8A2E[FD1A]              		mov	ch,[BIN_DATE_TIME]
  9351 00002AA6 8A0E[FE1A]              		mov	cl,[BIN_DATE_TIME+1]
  9352 00002AAA 8A36[FF1A]              		mov	dh,[BIN_DATE_TIME+2]
  9353 00002AAE 8A16[001B]              		mov	dl,[BIN_DATE_TIME+3]
  9354                                  ; get time in ticks in CX:DX
  9355                                  		;CALL	near [cs:TimeToTicks]
  9356 00002AB2 FF16[790A]              		call	word [TimeToTicks] ; 19/07/2019
  9357                                  ;r_t_ret:
  9358 00002AB6 C3                      		retn
  9359                                  
  9360                                  ;
  9361                                  ;   in_bin converts bin_date_time values from bcd to bin
  9362                                  ;
  9363                                  in_bin: 			      ;
  9364 00002AB7 A0[FD1A]                		mov	al,[BIN_DATE_TIME+0]  ; century or hours
  9365 00002ABA E81F00                  		call	bcd_to_bin	      ; ...
  9366 00002ABD A2[FD1A]                		mov	[BIN_DATE_TIME+0],al  ;
  9367 00002AC0 A0[FE1A]                		mov	al,[BIN_DATE_TIME+1]  ; years or minutes
  9368 00002AC3 E81600                  		call	bcd_to_bin	      ; ...
  9369 00002AC6 A2[FE1A]                		mov	[BIN_DATE_TIME+1],al  ;
  9370 00002AC9 A0[FF1A]                		mov	al,[BIN_DATE_TIME+2]  ; months or seconds
  9371 00002ACC E80D00                  		call	bcd_to_bin	      ; ...
  9372 00002ACF A2[FF1A]                		mov	[BIN_DATE_TIME+2],al  ;
  9373 00002AD2 A0[001B]                		mov	al,[BIN_DATE_TIME+3]  ; days (not used for time)
  9374 00002AD5 E80400                  		call	bcd_to_bin	      ; ...
  9375 00002AD8 A2[001B]                		mov	[BIN_DATE_TIME+3],al  ;
  9376 00002ADB C3                      		retn			      ;
  9377                                  ;
  9378                                  ;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
  9379                                  ;   a binary representation in al
  9380                                  ;   ah is destroyed
  9381                                  ;
  9382                                  bcd_to_bin:				;
  9383 00002ADC 88C4                    		mov	ah,al		; copy bcd number to ah
  9384 00002ADE 250FF0                  		and	ax,0F00Fh	; clear unwanted nibbles
  9385 00002AE1 88C3                    		mov	bl,al		; save units place
  9386 00002AE3 86E0                    		xchg	ah,al		; 10's place to al
  9387 00002AE5 30E4                    		xor	ah,ah		; ah not wanted
  9388 00002AE7 B104                    		mov	cl,4		; shift count
  9389 00002AE9 D3E8                    		shr	ax,cl		;mjb004 swap nibbles
  9390 00002AEB B10A                    		mov	cl,10		; convert al to ...
  9391 00002AED F6E1                    		mul	cl		; ... its binary value
  9392 00002AEF 00D8                    		add	al,bl		; add in units
  9393 00002AF1 C3                      		retn
  9394                                  
  9395                                  ; 26/03/2018 - CLOCKSUB.INC, MSDOS 3.3, 24/07/1987					
  9396                                  
  9397                                  ;
  9398                                  ;   date_verify loosely checks bcd date values to be in range in bin_date_time
  9399                                  ;
  9400                                  date_verify:				    	    ;
  9401 00002AF2 803E[FD1A]20            		cmp	byte [BIN_DATE_TIME+0],20h  ; century check
  9402 00002AF7 7735                    		ja	short date_error	    ; jmp error
  9403 00002AF9 740E                    		jz	short century_20	    ; jmp in 20th century
  9404 00002AFB 803E[FD1A]19            		cmp	byte [BIN_DATE_TIME+0],19h  ; century check
  9405 00002B00 722C                    		jb	short date_error	    ; jmp error
  9406 00002B02 803E[FE1A]80            		cmp	byte [BIN_DATE_TIME+1],80h  ; year check
  9407 00002B07 7225                    		jb	short date_error	    ; jmp error
  9408                                  century_20:				    	    ;
  9409 00002B09 803E[FE1A]99            		cmp	byte [BIN_DATE_TIME+1],99h  ; year check
  9410 00002B0E 771E                    		ja	short date_error	    ; jmp error
  9411 00002B10 803E[FF1A]12            		cmp	byte [BIN_DATE_TIME+2],12h  ; month check
  9412 00002B15 7717                    		ja	short date_error	    ; jmp error
  9413 00002B17 803E[FF1A]00            		cmp	byte [BIN_DATE_TIME+2],00h  ; month check
  9414 00002B1C 7610                    		jbe	short date_error	    ; jmp error
  9415 00002B1E 803E[001B]31            		cmp	byte [BIN_DATE_TIME+3],31h  ; day check
  9416 00002B23 7709                    		ja	short date_error	    ; jmp error
  9417 00002B25 803E[001B]00            		cmp	byte [BIN_DATE_TIME+3],00h  ; day check
  9418 00002B2A 7602                    		jbe	short date_error	    ; jmp error
  9419 00002B2C F8                      		clc				    ; set success flag
  9420 00002B2D C3                      		ret				    ;
  9421                                  date_error:				   	    ;
  9422 00002B2E F9                      		stc				    ; set error flag
  9423 00002B2F C3                      		retn				    ;
  9424                                  
  9425                                  ;
  9426                                  ; time_verify very loosely checks bcd date values to be in range in bin_date_time
  9427                                  ;
  9428                                  time_verify:
  9429 00002B30 803E[FD1A]24            		cmp	byte [BIN_DATE_TIME+0],24h
  9430 00002B35 7710                    		ja	short time_error
  9431 00002B37 803E[FE1A]59            		cmp	byte [BIN_DATE_TIME+1],59h
  9432 00002B3C 7709                    		ja	short time_error
  9433 00002B3E 803E[FF1A]59            		cmp	byte [BIN_DATE_TIME+2],59h
  9434 00002B43 7702                    		ja	short time_error
  9435 00002B45 F8                      		clc
  9436 00002B46 C3                      		retn
  9437                                  time_error:
  9438 00002B47 F9                      		stc
  9439 00002B48 C3                      		retn
  9440                                  
  9441                                  ;
  9442                                  ;   bcd_verify checks values in bin_date_time to be valid
  9443                                  ;   bcd numerals.  carry set if any nibble out of range
  9444                                  ;
  9445                                  bcd_verify:				  ;
  9446 00002B49 B90400                  		mov	cx,4		  ; 4 bytes to check
  9447 00002B4C BB[FD1A]                		mov	bx,BIN_DATE_TIME  ;
  9448                                  bv_loop:				  ;
  9449 00002B4F 8A07                    		mov	al,[bx]		  ; get a bcd number (0..99)
  9450 00002B51 88C4                    		mov	ah,al		  ;
  9451 00002B53 250FF0                  		and	ax,0F00Fh	  ; 10's place in high ah, 1's in al
  9452 00002B56 3C0A                    		cmp	al,10		  ; is 1's place in range?
  9453 00002B58 7716                    		ja	short bv_error	  ; jmp out of range
  9454 00002B5A D0EC                    		shr	ah,1		  ; swap nibbles
  9455 00002B5C D0EC                    		shr	ah,1		  ; ...
  9456 00002B5E D0EC                    		shr	ah,1		  ; ...
  9457 00002B60 D0EC                    		shr	ah,1		  ; ...
  9458 00002B62 80E40F                  		and	ah,0fh		  ; get rid of any erroneous bits
  9459 00002B65 80FC0A                  		cmp	ah,10		  ; is 10's place in range
  9460 00002B68 7706                    		ja	short bv_error	  ; jmp out of range
  9461 00002B6A 43                      		inc	bx		  ; next byte
  9462 00002B6B 49                      		dec	cx		  ;
  9463 00002B6C 75E1                    		jnz	short bv_loop 	  ;
  9464 00002B6E F8                      		clc			  ; set success flag
  9465 00002B6F C3                      		retn			  ;
  9466                                  bv_error:				  ;
  9467 00002B70 F9                      		stc			  ; set error flag
  9468 00002B71 C3                      		retn			  ;
  9469                                  
  9470                                  ; 02/06/2018 - Retro DOS v3.0
  9471                                  
  9472                                  ENDK09:
  9473                                  
  9474                                  ;------------------------------------------------------------------------
  9475                                  ;									:
  9476                                  ;	System initialization						:
  9477                                  ;									:
  9478                                  ;	The entry conditions are established by the bootstrap		:
  9479                                  ;	loader and are considered unknown. The following jobs		:
  9480                                  ;	will be performed by this module:				:
  9481                                  ;									:
  9482                                  ;	1.	All device initialization is performed			:
  9483                                  ;	2.	A local stack is set up and DS:SI are set		:
  9484                                  ;		to point to an initialization table. Then		:
  9485                                  ;		an inter-segment call is made to the first		:
  9486                                  ;		byte of the dos 					:
  9487                                  ;	3.	Once the dos returns from this call the ds		:
  9488                                  ;		register has been set up to point to the start		:
  9489                                  ;		of free memory. The initialization will then		:
  9490                                  ;		load the command program into this area 		:
  9491                                  ;		beginning at 100 hex and transfer control to		:
  9492                                  ;		this program.						:
  9493                                  ;									:
  9494                                  ;------------------------------------------------------------------------
  9495                                  
  9496                                  ; DRVFAT must be the first location of freeable space!
  9497                                  	;EVENB
  9498                                  
  9499                                  align 2
  9500                                  
  9501 00002B72 0000                    DRVFAT:	DW	0			; Drive and FAT ID of DOS
  9502                                  ; 03/07/2018
  9503                                  ;BIOS$:	DW	0			; First sector of data
  9504                                  ;DOSCNT:DW	0			; How many sectors to read
  9505 00002B74 00                      fBigFAT: DB	0			; Flags for drive
  9506                                  ; 01/07/2018
  9507                                  ;FatLen:	DW	0		; number of sectors in FAT.
  9508                                  ;FatLoc:	DW	0		; seg addr of fat sector
  9509                                  ; 12/07/2019
  9510 00002B75 80                      rom_drv_num:	db 	80h
  9511                                  
  9512                                  ;;Rev 3.30 Modification -----------------------------------------------
  9513                                  ; THE FOLLOWING TWO BYTES ARE USED TO SAVE INFO RETURNED BY INT 13, AH=8
  9514                                  ; CALL TO DETERMINE DRIVE PARAMETERS.					
  9515 00002B76 02                      NUM_HEADS: DB	2			; NUMBER OF HEADS RETURNED BY ROM
  9516 00002B77 09                      SEC_TRK:   DB	9			; SEC/TRK RETURNED BY ROM	 
  9517 00002B78 28                      NUM_CYLN:  DB	40			; NUMBER OF CYLINDERS RET BY ROM 
  9518                                  									 
  9519                                  ;;End of Modification -------------------------------------------------
  9520                                  
  9521                                  ; 16/07/2019
  9522                                  
  9523 00002B79 00                      fakefloppydrv:	db	0 	; if 1, then no diskette drives in the system. 
  9524                                  
  9525                                  ;BOOTBIAS equ	200H							 
  9526                                  
  9527                                  	;EVENB
  9528                                  align 2
  9529                                  					 
  9530 00002B7A 0002000140000000        DiskTable:  DW	512,	0100h,	64,	0
  9531 00002B82 0008010270000000        	    DW	2048,	0201h,	112,	0
  9532 00002B8A 0020020400010000        	    DW	8192,	0402h,	256,	0
  9533 00002B92 A87F030800020000        	    DW	32680,	0803h,	512,	0
  9534 00002B9A FFFF041000040000        	    DW	65535,	1004h,	1024,	0
  9535                                  
  9536                                  ; MSDOS 3.3
  9537                                  
  9538                                  ;DiskTable2:
  9539                                  ;	    DW	32680,	0803h,	512,	0
  9540                                  ;	    DW	65535,	0402h,	512,	fBIG
  9541                                  
  9542                                  ; 16/07/2019 - Retro DOS v3.2
  9543                                  
  9544                                  ; MSDOS 6.0
  9545                                  
  9546                                  ; default disktable under the assumption of total fat size <= 128 kb, and
  9547                                  ;	the maximum size of fat entry = 16 bit.
  9548                                  
  9549 00002BA2 0000A87F0308000200-     DiskTable2: 	dw   0, 32680, 0803h, 512, 0    ;for compatibility.
  9549 00002BAB 00                 
  9550 00002BAC 040000000204000240-     		dw  4h, 0000h, 0402h, 512, fBIG ;covers upto 134 mb media.
  9550 00002BB5 00                 
  9551 00002BB6 080000000308000240-     		dw  8h, 0000h, 0803h, 512, fBIG ;	upto 268 mb
  9551 00002BBF 00                 
  9552 00002BC0 100000000410000240-     		dw 10h, 0000h, 1004h, 512, fBIG	;	upto 536 mb
  9552 00002BC9 00                 
  9553 00002BCA 200000000520000240-     		dw 20h, 0000h, 2005h, 512, fBIG	;	upto 1072 mb
  9553 00002BD3 00                 
  9554 00002BD4 400000000640000240-     		dw 40h, 0000h, 4006h, 512, fBIG	;	upto 2144 mb
  9554 00002BDD 00                 
  9555 00002BDE 800000000780000240-     		dw 80h, 0000h, 8007h, 512, fBIG	;	upto 4288 mb...
  9555 00002BE7 00                 
  9556                                  
  9557                                  ;;Rev 3.30 Modification -----------------------------------------------
  9558                                  
  9559                                  ;*************************************************************************
  9560                                  ;Variables for Mini disk initialization
  9561                                  ;*************************************************************************
  9562                                  ; 16/07/2019 - Retro DOS v3.2
  9563                                  end_of_bdss:	
  9564                                  End_Of_BDSM:	;dw	0		;offset value of the ending add
  9565 00002BE8 [C61D]                  		dw	BDSH		;of BDSM table. Needed to figure
  9566                                  					;the Final_DOS_Location.
  9567 00002BEA 00                      numh:		db	0		;number of hard files
  9568 00002BEB 00                      mininum: 	db	0		;logical drive num for mini disk 
  9569 00002BEC 00                      num_mini_dsk:	db	0		;# of mini disk installed	 
  9570 00002BED 80                      rom_minidisk_num: db	80h		;physical mini disk number	 
  9571 00002BEE 0000                    mini_hdlim:	dw	0						 
  9572 00002BF0 0000                    mini_seclim:	dw	0						 
  9573                                  
  9574                                  ; 16/07/2019
  9575                                  last_dskdrv_table:
  9576 00002BF2 [1C07]                  		dw	DSKDRVS		; index into dskdrv table
  9577                                  ;Mini_BPB_ptr:	dw	0		;temporary variable used to save 
  9578                                  					;Mini Disk BPB pt add in DskDrvs.
  9579                                  ;;End of Modification -----------------------------------------------
  9580                                  
  9581 00002BF4 30312F31302F383400      Bios_Date:   DB	'01/10/84',0
  9582                                  
  9583                                  ; 17/07/2019 - Retro DOS v3.2
  9584                                  ; 02/06/2018 - Retro DOS v3.0
  9585                                  ;
  9586                                  ;PatchTable:
  9587                                  ;		DW	10,Media_Patch
  9588                                  ;		DW	3,GETBP1_PATCH
  9589                                  ;		DW	3,SET_PATCH
  9590                                  ;		DW	3,DiskIO_PATCH
  9591                                  ;		DW	3,DSKERR
  9592                                  ;		DW	10,Changed_Patch
  9593                                  ;		DW	3,INIT_PATCH
  9594                                  ;		DW	0
  9595                                  
  9596                                  ;-----------------------------------------------------------------------------
  9597                                  
  9598                                  ; 28/03/2018
  9599                                  ; MSDOS 6.0 - MSINIT.ASM, 1991
  9600 00002BFD 0000                    init_bootseg:	dw	0	; seg addr of buffer for reading boot record
  9601                                  
  9602                                  BootBias equ 200h ; 19/03/2018
  9603                                  
  9604                                  ;-----------------------------------------------------------------------------
  9605                                  
  9606 00002BFF 90                      align 16
  9607                                  
  9608                                  ;-----------------------------------------------------------------------------
  9609                                  ; entry point from boot sector
  9610                                  ;-----------------------------------------------------------------------------
  9611                                  ; 02/06/2018 - Retro DOS v3.0
  9612                                  
  9613                                  ;-----------------------------------------------------------------------------
  9614                                  
  9615                                  ; ----------------------------------------------------------------------------
  9616                                  ; SYSINIT PARAMETER ADDRESS EQUALITIES - 25/02/2018 (MSDOS 2.0 'SYSINIT.ASM')
  9617                                  ; ----------------------------------------------------------------------------
  9618                                  ; ('sysinit.s', 'SYSINIT.BIN')
  9619                                  
  9620                                  ; 12/07/2019 - Retro DOS v3.2 (SYSINIT21.ASM)
  9621                                  
  9622                                  ; IN SYSINIT SEGMENT (SYSINITSEG):
  9623                                  
  9624                                  CURRENT_DOS_LOCATION EQU 6   ; dw (segment)
  9625                                  FINAL_DOS_LOCATION   EQU 10  ; dw (segment)
  9626                                  DEVICE_LIST	     EQU 12  ; dd (segment:offset)	
  9627                                  DOSSIZE		     EQU 16  ; dw ; Retro DOS 2.0 - 'MSDOS.BIN' size in words
  9628                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  9629                                  ;MEMORY_SIZE	     EQU 18  ; dw (paragraphs)	
  9630                                  ;DEFAULT_DRIVE	     EQU 20  ; db
  9631                                  SYSI_COUNTRY	     EQU 18  ; dd (segment:offset) - country table pointer	
  9632                                  STACK_COUNT	     EQU 22  ; dw 	
  9633                                  STACK_SIZE	     EQU 24  ; dw
  9634                                  STACK_ADDR	     EQU 26  ; dd (segment:offset)  
  9635                                  MEMORY_SIZE	     EQU 30  ; dw (paragraphs)
  9636                                  DEFAULT_DRIVE	     EQU 32  ; db
  9637                                  
  9638                                  ; 17/07/2019 - Retro DOS v3.2
  9639                                  ;-----------------------------------------------------------------------------
  9640                                  ; ADDITIONAL SYSINIT PARAMETER ADDRESSES FOR RETRO DOS v4.0
  9641                                  ; 18/03/2019 - Retro DOS v4.0 (MSDOS 6.21) 		
  9642                                  ;-----------------------------------------------------------------------------
  9643                                  toomanydrivesflag   equ 87h ; 2E7h-260h	; 17/07/2019
  9644                                  
  9645                                  ; 09/07/2019 - Retro DOS v3.2
  9646                                  	 						
  9647                                  ;-----------------------------------------------------------------------------
  9648                                  ; initialization - stage 1
  9649                                  ;-----------------------------------------------------------------------------
  9650                                  ; 02/06/2018 - Retro DOS v3.0
  9651                                  
  9652                                  		; Retro DOS 3.0 Modification on MSDOS 3.3 IBMBIO.COM code
  9653                                  		; (Because of Retro DOS 2.0, MSDOS 3.3 boot sector difference)
  9654                                  
  9655                                  INIT:
  9656                                  		; 07/04/2018
  9657                                  		;=============================================================
  9658                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  9659                                                  ; DL = [bsDriveNumber]
  9660                                  		; DH = [bsMedia]
  9661                                  		; AX = [bsSectors] ; Total sectors
  9662                                  		; DS = 0, SS = 0
  9663                                  		; BP = 7C00h
  9664                                  
  9665                                  		; Move Retro DOS v2.0 boot sector parameters to 0060h:0
  9666 00002C00 BB6000                  		mov	bx,60h
  9667 00002C03 8EC3                    		mov	es,bx
  9668 00002C05 89EE                    		mov	si,bp
  9669 00002C07 29FF                    		sub	di,di
  9670 00002C09 B92300                  		mov	cx,35 ; 70 bytes, 35 words
  9671                                  		;mov	cl,35
  9672 00002C0C F3A5                    		rep	movsw
  9673                                  
  9674 00002C0E 0E                      		push	cs
  9675 00002C0F 1F                      		pop	ds
  9676                                  
  9677                                  		; 27/03/2018
  9678 00002C10 B97064                  		mov	cx,KERNEL_SIZE	; words !
  9679                                  		; 07/04/2018
  9680                                  		;mov	bx,KERNEL_SEGMENT ; 0070h
  9681 00002C13 B370                    		mov	bl,KERNEL_SEGMENT
  9682 00002C15 8EC3                    		mov	es,bx
  9683 00002C17 31FF                    		xor	di,di
  9684 00002C19 89FE                    		mov	si,di
  9685                                  		
  9686                                  		; Move KERNEL file from 1000h:0 to 0070h:0
  9687                                  		; (Retro DOS v2 BS loads 'MSDOS.SYS' at 1000h:0000h)
  9688 00002C1B F3A5                    		rep	movsw
  9689                                  		; 17/06/2018 
  9690                                  		;mov	ds,bx
  9691                                  INIT0:
  9692 00002C1D 06                      		push	es
  9693 00002C1E 68[222C]                		push	INIT1 ; 07/04/2018
  9694 00002C21 CB                      		retf	; jump to 0070h:INIT1
  9695                                  
  9696                                  ;INIT:
  9697                                  INIT1:
  9698                                  ; 02/06/2018 - Retro DOS v3.0
  9699                                  
  9700                                  		; 19/03/2018
  9701                                  		; Retro DOS v2.0 (24/02/2018)
  9702                                  		; [REF: MSDOS 3.3, MSBIO, "MSINIT.ASM"  (24/07/1987)]
  9703                                  
  9704                                  ;------------------------------------------------------------------------
  9705                                  ;									:
  9706                                  ;	System initialization						:
  9707                                  ;									:
  9708                                  ;	The entry conditions are established by the bootstrap		:
  9709                                  ;	loader and are considered unknown. The following jobs		:
  9710                                  ;	will be performed by this module:				:
  9711                                  ;									:
  9712                                  ;	1.	All device initialization is performed			:
  9713                                  ;	2.	A local stack is set up and DS:SI are set		:
  9714                                  ;		to point to an initialization table. Then		:
  9715                                  ;		an inter-segment call is made to the first		:
  9716                                  ;		byte of the dos 					:
  9717                                  ;	3.	Once the dos returns from this call the ds		:
  9718                                  ;		register has been set up to point to the start		:
  9719                                  ;		of free memory. The initialization will then		:
  9720                                  ;		load the command program into this area 		:
  9721                                  ;		beginning at 100 hex and transfer control to		:
  9722                                  ;		this program.						:
  9723                                  ;									:
  9724                                  ;------------------------------------------------------------------------
  9725                                  
  9726                                  		; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  9727                                  		EOI	EQU	20H
  9728                                  		AKPORT	EQU	20H
  9729                                  		INITSPOT EQU	534H	; IBM wants 4 zeros here
  9730                                  		BRKADR	EQU	1BH * 4	; 6CH, 1BH break vector address
  9731                                  		TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  9732                                  		DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  9733                                  		SEC9	EQU	522H	; address of disk parameters
  9734                                  		;CHROUT	EQU	29H
  9735                                  		;LSTDRV	EQU     504H
  9736                                  		;;SYSIZE	EQU 200H ;NUMBER OF PARAGRAPHS IN SYSINIT MODULE
  9737                                  		 ; 26/03/2018
  9738                                  		RSINIT	EQU	0A3H
  9739                                  		NORMSETTLE EQU  15
  9740                                  
  9741                                  		; Retro DOS v1.0 (10/02/2018)
  9742                                  		; (Register values from Retro DOS v1.0 Boot Sector)
  9743                                  		; CS = 60h  ; BIO_SEGMENT
  9744                                  		; DS = 0
  9745                                  		; ES = 0
  9746                                  		; SS = 0
  9747                                  		; SP = 0FFFEh
  9748                                   		; BP = 7C00h
  9749                                  		; DL = Physical drive number = 0
  9750                                  		;push	cs
  9751                                  		;pop	ds
  9752                                  
  9753                                  		; Retro DOS v1.0 boot sector (fd0) dos parameters
  9754                                  		; (17 bytes)
  9755                                  		bsBytesPerSec	equ 11
  9756                                  		bsSecPerClust	equ 13
  9757                                  		bsResSectors	equ 14	
  9758                                  		bsFATs		equ 16
  9759                                  		bsRootDirEnts	equ 17
  9760                                  		bsSectors	equ 19	
  9761                                  		bsMedia		equ 21
  9762                                  		bsFATsecs	equ 22
  9763                                  		bsSecPerTrack	equ 24
  9764                                  		bsHeads		equ 26
  9765                                  
  9766                                  		; Retro DOS 1.0 extensions (to boot sector parameters) 
  9767                                  		bsDataStart	equ 64
  9768                                  
  9769                                  		;push	ds
  9770                                  		;pop	es
  9771                                  
  9772                                  		; 14/02/2018
  9773                                  		; Set video mode to 3 (Clear screen)
  9774 00002C22 B80300                  		mov	ax,3
  9775 00002C25 CD10                    		int	10h
  9776                                  
  9777                                  		; 06/04/2018 - Retro DOS v2.0
  9778                                  		; (IBMDOS 2.1, IBMBIO.COM, 20/10/1983)
  9779                                  		; (by IDA Pro Free Dissassembler)
  9780                                  		; 19/03/2018
  9781                                  		; (Source Code Ref: MSDOS 3.3, MSINIT.ASM, 1991)
  9782                                  		
  9783                                  		; "MSINIT.ASM"
  9784                                  		;---------------------------------------------------------------
  9785                                  		; At this point the registers contain these values:
  9786                                  		;   AX = 0-based drive we booted from
  9787                                  		;   BX = the logical number of the first data sector on the disk
  9788                                  		;   CX = number of floppies including logical one
  9789                                  
  9790                                  		;
  9791                                  		; set up local stack
  9792                                  		;
  9793                                  
  9794                                  		;XOR	BX,BX
  9795                                  		;CLI		; turn interrupts off while manupulating stack
  9796                                  		;MOV	SS,BX	; set stack segment register
  9797                                  		;MOV	SP,700h	; set stack pointer
  9798                                  		;STI		; turn interrupts on
  9799                                  
  9800                                  ;; 02/06/2018 - Retro DOS v3.0
  9801                                  ;
  9802                                  ;;
  9803                                  ;; Entry from boot sector. The register contents are:
  9804                                  ;;   DL = INT 13 drive number we booted from
  9805                                  ;;   CH = media byte
  9806                                  ;;   BX = First data sector on disk (0-based)
  9807                                  ;;
  9808                                  ;		CLI
  9809                                  ;		XOR	AX,AX
  9810                                  ;		MOV	DS,AX
  9811                                  ;;
  9812                                  ;; Preserve original int 13 vector
  9813                                  ;;   We need to save INT13 in two places in case we are running on an AT.
  9814                                  ;; On ATs we install the IBM supplied ROM_BIOS patch DISK.OBJ which hooks
  9815                                  ;; INT13 ahead of ORIG13. Since INT19 must unhook INT13 to point to the
  9816                                  ;; ROM INT13 routine, we must have that ROM address also stored away.
  9817                                  ;;
  9818                                  ;		; 16/06/2018
  9819                                  ;		MOV	AX,[13h*4]
  9820                                  ;		MOV	[CS:Old13],AX
  9821                                  ;		MOV	[CS:orig13],AX
  9822                                  ;		MOV	AX,[13h*4+2]
  9823                                  ;		MOV	[CS:Old13+2],AX
  9824                                  ;		MOV	[CS:orig13+2],AX
  9825                                  ;
  9826                                  ;;
  9827                                  ;; Set up INT 13 for new action
  9828                                  ;;
  9829                                  ;		MOV	WORD [13h*4],Block13
  9830                                  ;		MOV	[13h*4+2],CS
  9831                                  ;;
  9832                                  ;; Preserve original int 19 vector
  9833                                  ;;
  9834                                  ;		MOV	AX,[19h*4]
  9835                                  ;		MOV	[CS:ORIG19],AX	
  9836                                  ;		MOV	AX,[19h*4+2]
  9837                                  ;		MOV	[CS:ORIG19+2],AX
  9838                                  ;;
  9839                                  ;; Set up INT 19 for new action
  9840                                  ;;
  9841                                  ;		MOV	WORD[19h*4],INT19
  9842                                  ;		MOV	[19h*4+2],CS
  9843                                  ;		STI
  9844                                  
  9845                                  		; 18/07/2019 - Retro DOS v3.2
  9846                                  
  9847                                  		; 27/12/2018 - Retro DOS v4.0
  9848                                  		; (MSDOS 6.0, MSINIT.ASM)
  9849                                  
  9850                                  		;mov	cx,5		; no. of rom vectors to be saved
  9851 00002C27 B105                    		mov	cl,NUMROMVECTORS ; 5
  9852 00002C29 BE[BC06]                		mov	si,RomVectors	; point to list of int vectors
  9853                                  
  9854 00002C2C 31C0                    		xor	ax,ax ; 0
  9855 00002C2E 8ED8                    		mov	ds,ax
  9856                                  
  9857 00002C30 FA                      		cli	; 06/05/2019
  9858                                  _next_int:	
  9859 00002C31 2E                      		cs			
  9860 00002C32 AC                      		lodsb			; get int number
  9861                                  
  9862                                  		; 18/07/2019		
  9863 00002C33 98                      		cbw			; assume < 128
  9864 00002C34 D1E0                    		shl	ax,1
  9865 00002C36 D1E0                    		shl	ax,1		; int no * 4
  9866                                  		
  9867 00002C38 89C7                    		mov	di,ax
  9868 00002C3A 87F7                    		xchg	si,di
  9869                                  		;lodsw
  9870                                  		;stosw
  9871                                  		;lodsw
  9872                                  		;stosw			; save the vector
  9873                                  		; 20/03/2019
  9874 00002C3C A5                      		movsw
  9875 00002C3D A5                      		movsw
  9876 00002C3E 87F7                    		xchg	si,di
  9877 00002C40 E2EF                    		loop	_next_int
  9878                                  		
  9879                                  ; set up int 13 for new action
  9880                                  
  9881 00002C42 C7064C00[7412]          		mov	word [13h*4],Block13
  9882 00002C48 8C0E4E00                		mov	[13h*4+2],cs
  9883                                  
  9884                                  ;; set up int 15 for new action
  9885                                  ;
  9886                                  ;		mov	word [15h*4],Int15
  9887                                  ;		mov	[15h*4+2],cs
  9888                                  
  9889                                  ; set up int 19 for new action
  9890                                  
  9891 00002C4C C7066400[5407]          		mov	word [19h*4],INT19
  9892 00002C52 8C0E6600                		mov	[19h*4+2],cs
  9893                                  
  9894 00002C56 0E                      		push	cs
  9895 00002C57 1F                      		pop	ds
  9896                                  
  9897                                  ; we need to save int13 in two places in case we are running on an at.
  9898                                  ; on ats we install the ibm supplied rom_bios patch which hooks
  9899                                  ; int13 ahead of orig13. since int19 must unhook int13 to point to the
  9900                                  ; rom int13 routine, we must have that rom address also stored away.
  9901                                  
  9902 00002C58 A1[C206]                		mov	ax,[OLD13]	; save old13 in orig13 also
  9903 00002C5B A3[B806]                		mov	[ORIG13],ax
  9904 00002C5E A1[C406]                		mov	ax,[OLD13+2]
  9905 00002C61 A3[BA06]                		mov	[ORIG13+2],ax
  9906                                  
  9907                                  		; 18/07/2019 - Retro DOS v3.2
  9908                                  
  9909 00002C64 FB                      		STI
  9910                                  
  9911                                  		;; 07/04/2018
  9912                                  		;; Retro DOS v2.0
  9913                                  		;INT	11h		; rom-bios equipment determination
  9914                                  		;; 10/04/2018
  9915                                  		;TEST	AL,1
  9916                                  		;JNZ	SHORT CHECKSINGLEFD
  9917                                  		;XOR	AX,AX
  9918                                  		;JMP	SHORT NOFD
  9919                                  ;CHECKSINGLEFD:
  9920                                  		;MOV	CL, 6
  9921                                  		;SHR	AL, CL
  9922                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  9923                                  		;INC	byte [Single]	;REMEMBER THIS
  9924                                  ;NOTSINGLE:
  9925                                  		;XOR	AH,AH
  9926                                  		;INC	AL ; 10/04/2018
  9927                                  
  9928                                  		;; 02/06/2018
  9929                                  		;; Retro DOS v3.0  (MSDOS 3.3, MSINIT.ASM, 02/02/1988)
  9930                                  
  9931                                  		; 16/07/2019 - Retro DOS v3.2
  9932                                  
  9933                                  		;INT	11h		; rom-bios equipment determination
  9934                                  		;ROL	AL,1		;PUT BITS 6 & 7 INTO BITS 0 & 1
  9935                                  		;ROL	AL,1
  9936                                  		;AND	AX,3		;ONLY LOOK AT BITS 0 & 1
  9937                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  9938                                  		;INC	AX		;PRETEND IT'S A TWO DRIVE SYSTEM
  9939                                  		;INC	byte [CS:Single] ;REMEMBER THIS
  9940                                  ;NOTSINGLE:
  9941                                  		;INC	AX		;AX HAS NUMBER OF DRIVES, 2-4
  9942                                  					;IS ALSO 0 INDEXED BOOT DRIVE IF WE
  9943                                  					;  BOOTED OFF HARD FILE
  9944                                  		;mov	CL,AL		; save number of diskette drives in CL
  9945                                  		;test	DL,80h		; booted from hard disk ?
  9946                                  		;jnz	short GotHrd	; yes, jump down
  9947                                  		;xor	AX,AX		; no - indicate boot from drive A
  9948                                  ;GotHrd:		
  9949                                  		; At this point the registers contain these values:
  9950                                  		;   AX = 0-based drive we booted from
  9951                                  		;   BX = the logical number of the first data sector on the disk
  9952                                  		;   CL = number of floppies including logical one
  9953                                  		;   CH = media byte
  9954                                  
  9955                                  
  9956                                  		; 16/07/2019- Retro DOS v3.2
  9957                                  		
  9958                                  		;sti
  9959                                  	
  9960 00002C65 CD11                    		int	11h
  9961                                  
  9962                                  ;we have to support a system that does not have any diskette
  9963                                  ;drives but only hardfiles. this system will ipl from the hardfile.
  9964                                  ;if the equipment flag bit 0 is 1, then the system has diskette drive(s).
  9965                                  ;otherwise, the system has only hardfiles.
  9966                                  ;
  9967                                  ;important thing is that still, for compatibility reason, the drive letter
  9968                                  ;for the hardfiles start from "c". so, we still need to allocate dummy bds
  9969                                  ;drive a and drive b. at sysinit time, we are going to set cds table entry
  9970                                  ;of dpb pointer for these drives to 0, so any user attempt to access this
  9971                                  ;drives will get "invalid drive letter ..." message. we are going to
  9972                                  ;establish "fakefloppydrv" flag. ***sysinit module should call int 11h to
  9973                                  ;determine whether there are any diskette drivers in the system or not.!!!***
  9974                                  
  9975                                  ;	check the register returned by the equipment determination interrupt
  9976                                  ;	we have to handle the case of no diskettes in the system by faking
  9977                                  ;	two dummy drives.
  9978                                  ;
  9979                                  ;	if the register indicates that we do have floppy drives we don't need
  9980                                  ;	to do anything special.
  9981                                  ;
  9982                                  ;	if the register indicates that we don't have any floppy drives then
  9983                                  ;	what we need to do is set the fakefloppydrv variable, change the
  9984                                  ;	register to say that we do have floppy drives and then go to execute
  9985                                  ;	the code which starts at notsingle. this is because we can skip the
  9986                                  ;	code given below which tries to find if there are one or two drives
  9987                                  ;	since we already know about this.
  9988                                  
  9989                                  		; 06/05/2019 - Retro DOS v4.0
  9990 00002C67 88C1                    		mov	cl,al
  9991                                  
  9992                                  		;test	ax,1		; floppy drives present ?
  9993 00002C69 A801                    		test	al,1
  9994 00002C6B 7520                    		jnz	short normalfloppydrv ; yes.
  9995                                  
  9996                                  ; Some ROM BIOSs lie that there are no floppy drives. Lets find out
  9997                                  ; whether it is an old ROM BIOS or a new one
  9998                                  ;
  9999                                  ; WARNING !!!
 10000                                  ;
 10001                                  ; This sequence of code is present in SYSINIT1.ASM also. Any modification
 10002                                  ; here will require an equivalent modification in SYSINIT1.ASM also
 10003                                  
 10004 00002C6D 52                      		push	dx
 10005 00002C6E 06                      		push	es
 10006                                  
 10007 00002C6F B408                    		mov	ah,8		; get disk parameters
 10008 00002C71 B200                    		mov	dl,0		; of drive 0.
 10009 00002C73 CD13                    		int	13h
 10010 00002C75 7202                    		jc	short _gdskp_error
 10011                                  
 10012                                  		;mov	byte [flp_drvs],dl
 10013 00002C77 88D1                    		mov	cl,dl
 10014                                  _gdskp_error:
 10015 00002C79 07                      		pop	es
 10016 00002C7A 5A                      		pop	dx
 10017                                  
 10018 00002C7B 7210                    		jc	short normalfloppydrv ; if error it is an old ROM BIOS
 10019                                  					;  so, lets assume that ROM BIOS lied
 10020                                  
 10021                                  		;cmp	byte [flp_drvs],0 ; number of drvs == 0?
 10022                                  		;je	short _set_fake_flpdrv
 10023 00002C7D 08C9                    		or	cl,cl
 10024 00002C7F 7404                    		jz	short _set_fake_flpdrv
 10025                                  		;mov	al,[flp_drvs]
 10026                                  		;dec	al		; make it zero based
 10027 00002C81 FEC9                    		dec	cl
 10028 00002C83 EB0C                    		jmp	short got_num_flp_drvs
 10029                                  _set_fake_flpdrv:
 10030 00002C85 FEC1                    		inc	cl ; 1
 10031                                  		;mov	byte [fakefloppydrv],1 ;we don't have any floppy drives.
 10032 00002C87 880E[792B]              		mov	[fakefloppydrv],cl ; 1
 10033                                  		;mov	ax, 1		;after setting fakefloppydrv flag, we
 10034 00002C8B EB0B                    		jmp	short settwodrive ; well then set it for two drives!
 10035                                  
 10036                                  normalfloppydrv:			;yes, bit 0 is 1. there exist floppy drives.
 10037                                  		;rol	al, 1		;put bits 6 & 7 into bits 0 & 1
 10038                                  		;rol	al, 1
 10039 00002C8D D0C1                    		rol	cl, 1
 10040 00002C8F D0C1                    		rol	cl, 1
 10041                                  got_num_flp_drvs:
 10042                                  		;and	ax,3		;only look at bits 0 & 1
 10043 00002C91 80E103                  		and	cl,3
 10044 00002C94 7506                    		jnz	short notsingle	;zero means single drive system
 10045                                  		;inc	ax		;pretend it's a two drive system
 10046 00002C96 FEC1                    		inc	cl
 10047                                  settwodrive:				; set this to two fakedrives
 10048 00002C98 FE06[1401]              		inc	byte [Single]	;remember this
 10049                                  notsingle:
 10050                                  		;inc	ax		;ax has number of drives, 2-4
 10051                                  		;			;is also 0 indexed boot drive if we
 10052                                  		;			;  booted off hard file
 10053                                  		;mov	cl,al		;ch is fat id, cl # floppies
 10054                                  
 10055 00002C9C FEC1                    		inc	cl 	; cl >= 2
 10056                                  
 10057                                  ; determine whether we booted from floppy or hard disk...
 10058                                  
 10059 00002C9E 88C8                    		mov	al,cl	; 26/05/2019
 10060                                  
 10061 00002CA0 F6C280                  		test	dl,80h		;boot from floppy ?
 10062 00002CA3 7502                    		jnz	short gothrd	;no.
 10063                                  
 10064                                  		;xor	ax,ax		;indicate boot from drive a
 10065 00002CA5 30C0                    		xor	al,al	; 20/03/2019
 10066                                  gothrd:
 10067                                  
 10068                                  ; MSDOS 6.0
 10069                                  ;   ax = 0-based drive we booted from
 10070                                  ;   bios_l, bios_h set.
 10071                                  ;   cl = number of floppies including fake one
 10072                                  ;   ch = media byte
 10073                                  
 10074                                  ; 16/07/2019 - Retro DOS v3.2
 10075                                  
 10076                                  ; Retro DOS 4.0 - 27/12/2018 
 10077                                  ;  (from Retro DOS v2.0 boot sector)
 10078                                  ;   dl = int 13 drive number we booted from
 10079                                  ;   dh = media byte
 10080                                  
 10081                                  	;
 10082                                  	; set up local stack
 10083                                  	;
 10084                                  		
 10085 00002CA7 88F5                    		mov	ch,dh	; 01/07/2018
 10086                                  
 10087 00002CA9 31D2                    		xor	DX,DX
 10088 00002CAB FA                      		cli			; turn interrupts off while manupulating stack
 10089 00002CAC 8ED2                    		mov	SS,DX		; set stack segment register
 10090 00002CAE BC0007                  		mov	SP,700h 	; set stack pointer
 10091 00002CB1 FB                      		sti			; turn interrupts on
 10092                                  	
 10093                                  					; preserve some of the values in registers
 10094 00002CB2 51                      		push	CX ; (***)	; save number of floppies and media byte
 10095                                  		; 03/07/2018
 10096                                  		; 16/06/2018
 10097                                  		;mov	[CS:BIOS$],BX	; save first data sector
 10098 00002CB3 88EC                    		mov	AH,CH		; FAT ID to AH too
 10099 00002CB5 50                      		push	AX ; (**)	; save boot drive number and media byte
 10100                                  
 10101                                  ;;Rev 3.30 Modification -----------------------------------------------
 10102                                  ; Let Model_byte, Secondary_Model_Byte be set here!!!	
 10103 00002CB6 B4C0                    		mov	ah,0C0h 	; return system environment 
 10104 00002CB8 CD15                    		int	15h		; call ROM-Bios routine     
 10105 00002CBA 7215                    		jc	short No_Rom_System_Conf ; just use Model_Byte	
 10106 00002CBC 80FC00                  		cmp	ah,0		; double check		
 10107 00002CBF 7510                    		jne	short No_Rom_System_Conf
 10108                                  			 		;get the model byte				
 10109 00002CC1 268A4702                		mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
 10110                                  		; 16/07/2019
 10111                                  		;mov	[CS:MODEL_BYTE],al
 10112                                  					 ;secondary model byte
 10113 00002CC5 A2[B506]                		mov	[MODEL_BYTE],al					
 10114 00002CC8 268A4703                		mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
 10115                                  		;mov	[CS:Secondary_Model_Byte],al
 10116 00002CCC A2[B606]                		mov	[Secondary_Model_Byte],al				
 10117 00002CCF EB0C                    		jmp	short Turn_Timer_On					
 10118                                  No_Rom_System_Conf:							
 10119 00002CD1 BEFFFF                  		MOV	SI,0FFFFh	;MJB001 			
 10120 00002CD4 8EC6                    		MOV	ES,SI		;MJB001 			
 10121 00002CD6 26A00E00                		MOV	AL,[ES:0Eh]	; GET MODEL BYTE ARR 2.41	
 10122                                  		;MOV	[CS:MODEL_BYTE],AL ; SAVE MODEL BYTE ARR 2.41	
 10123 00002CDA A2[B506]                		MOV	[MODEL_BYTE],AL
 10124                                  ;;End of Modification -----------------------------------------------
 10125                                  	
 10126                                  Turn_Timer_On:								
 10127 00002CDD B020                    		mov	AL,EOI
 10128 00002CDF E620                    		out	AKPORT,AL	; turn on the timer
 10129                                  
 10130                                  		; 02/06/2018
 10131                                  
 10132                                  ;;Rev 3.30 Modification -----------------------------------------------
 10133 00002CE1 BE[8401]                		mov	si,COM4DEV 
 10134 00002CE4 E8FB07                  		call	AUX_INIT
 10135 00002CE7 BE[7201]                		mov	si,COM3DEV
 10136 00002CEA E8F507                  		call	AUX_INIT
 10137                                  ;;End of Modification -----------------------------------------------
 10138 00002CED BE[6001]                		mov	SI,COM2DEV
 10139 00002CF0 E8EF07                  		call	AUX_INIT		;INIT COM2
 10140 00002CF3 BE[1801]                		mov	SI,COM1DEV
 10141 00002CF6 E8E907                  		call	AUX_INIT		;INIT COM1
 10142                                  
 10143 00002CF9 BE[4E01]                		mov	SI,LPT3DEV
 10144 00002CFC E8DB07                  		call	PRINT_INIT		;INIT LPT3
 10145 00002CFF BE[3C01]                		mov	SI,LPT2DEV
 10146 00002D02 E8D507                  		call	PRINT_INIT		;INIT LPT2
 10147 00002D05 BE[2A01]                		mov	SI,LPT1DEV
 10148 00002D08 E8CF07                  		call	PRINT_INIT		;INIT LPT1
 10149                                  
 10150 00002D0B 31D2                    		xor	DX,DX
 10151 00002D0D 8EDA                    		mov	DS,DX			;TO INITIALIZE PRINT SCREEN VECTOR
 10152 00002D0F 8EC2                    		mov	ES,DX
 10153                                  
 10154 00002D11 31C0                    		xor	AX,AX
 10155 00002D13 BF3405                  		mov	DI,INITSPOT
 10156 00002D16 AB                      		stosw				;INIT four bytes to 0
 10157 00002D17 AB                      		stosw
 10158                                  
 10159 00002D18 8CC8                    		mov	AX,CS			;FETCH SEGMENT
 10160                                  
 10161 00002D1A C7066C00[9707]          		mov	word [BRKADR],CBREAK	;BREAK ENTRY POINT
 10162 00002D20 A36E00                  		mov	[BRKADR+2],AX		;VECTOR FOR BREAK
 10163                                  
 10164 00002D23 C706A400[7B08]          		mov	word [CHROUT*4],OUTCHR
 10165 00002D29 A3A600                  		mov	[CHROUT*4+2],AX
 10166                                  
 10167 00002D2C BF0400                  		mov	DI,4
 10168 00002D2F BB[9D07]                		mov	BX,INTRET		;WILL INITIALIZE REST OF INTERRUPTS
 10169 00002D32 93                      		xchg	AX,BX
 10170 00002D33 AB                      		stosw				;Location 4
 10171 00002D34 93                      		xchg	AX,BX
 10172 00002D35 AB                      		stosw				;INT 1		;Location 6
 10173 00002D36 83C704                  		add	DI,4
 10174 00002D39 93                      		xchg	AX,BX
 10175 00002D3A AB                      		stosw				;Location 12
 10176 00002D3B 93                      		xchg	AX,BX
 10177 00002D3C AB                      		stosw				;INT 3		;Location 14
 10178 00002D3D 93                      		xchg	AX,BX
 10179 00002D3E AB                      		stosw				;Location 16
 10180 00002D3F 93                      		xchg	AX,BX
 10181 00002D40 AB                      		stosw				;INT 4		;Location 18
 10182                                  
 10183 00002D41 89160005                		mov	[500H],DX		;SET PRINT SCREEN & BREAK =0
 10184 00002D45 89160405                		mov	[LSTDRV],DX		;clean out last drive spec
 10185                                  
 10186 00002D49 8B367800                		mov	SI,[DSKADR]
 10187 00002D4D 8E1E7A00                		mov	DS,[DSKADR+2]		; DS:SI -> current table
 10188                                  
 10189 00002D51 BF2205                  		mov	DI,SEC9 		; ES:DI -> New Table
 10190 00002D54 B90B00                  		mov	CX,DISK_PARMS.size ; 11
 10191 00002D57 F3A4                    		rep	MOVSB			; Copy Table
 10192 00002D59 06                      		push	ES			;
 10193 00002D5A 1F                      		pop	DS			; DS = 0
 10194                                  							
 10195 00002D5B C70678002205            		mov	word [DSKADR],SEC9 	; Point disk parm vector to new table	
 10196 00002D61 8C1E7A00                		mov	[DSKADR+2],DS 
 10197                                  
 10198                                  ;-----------------------------------------------
 10199                                  ;
 10200                                  ; THE FOLLOWING DEPEND ON THE TYPE OF MACHINE.
 10201                                  ;
 10202                                  		; 16/06/2018
 10203 00002D65 2E803E[B506]FD          		CMP	byte [CS:MODEL_BYTE],0FDH ; IS THIS AN OLD ROM?
 10204 00002D6B 720B                    		JB	short NO_DIDDLE		; NO
 10205 00002D6D C7062B050F02            		MOV	WORD [SEC9+DISK_PARMS.DISK_HEAD_STTL],0200H+NORMSETTLE
 10206                                  						; SET HEAD SETTLE AND MOTOR START
 10207                                  						; ON PC-1 PC-2 PC-XT HAL0
 10208 00002D73 C6062205DF              		MOV	byte [SEC9+DISK_PARMS.DISK_SPECIFY_1],0DFH 
 10209                                  						; SET 1ST SPECIFY BYTE
 10210                                  						; ON PC-1 PC-2 PC-XT HAL0
 10211                                  NO_DIDDLE:
 10212 00002D78 CD12                    		int	12h			; call rom-bios for memory size
 10213 00002D7A B106                    		mov	CL,6			; get ready for shift
 10214 00002D7C D3E0                    		shl	AX,CL			; change from K to 16 byte blocks
 10215 00002D7E 59                      		pop	CX ; (**)		; restore CX
 10216                                  		; 03/07/2018
 10217 00002D7F 0E                      		push	cs
 10218 00002D80 1F                      		pop	ds
 10219 00002D81 890E[722B]              		mov	[DRVFAT],cx
 10220                                  		; 16/06/2018
 10221                                  		;mov	[CS:DRVFAT],CX
 10222                                  		;push	AX ; (*)
 10223                                  		; 03/07/2018
 10224 00002D85 89C2                    		mov	dx,ax ; (*)		
 10225                                  
 10226                                  		; 02/06/2018
 10227                                  		;mov	dx,[7C00h+16h]		; number of sectors/fat from boot sec
 10228                                  		
 10229                                  		;01/07/2018
 10230                                  		;mov	dx,[600h+16h]		; ((Retro DOS v2.0/v3.0 modification))
 10231                                  		
 10232                                  		;xor	dh,dh
 10233                                  		; 17/06/2018
 10234                                  		;push	cs
 10235                                  		;pop	ds
 10236                                  		; 01/07/2018
 10237                                  		;mov	[FatLen],dx
 10238                                  		; 16/06/2018
 10239                                  		;mov	[CS:FatLen],DX
 10240                                  ;
 10241                                  ; Convert sector count to paragraph count:512 bytes / sec / 16 bytes / para
 10242                                  ; = 32 para /sector
 10243                                  ;
 10244                                  ;;Rev 3.30 Modification -----------------------------------------------
 10245                                  		; 01/07/2018
 10246                                  		;SHL	DX,1
 10247                                  		;SHL	DX,1
 10248                                  		;SHL	DX,1
 10249                                  		;SHL	DX,1
 10250                                  		;SHL	DX,1
 10251                                  ;;End of Modification -----------------------------------------------
 10252                                  		;SUB	AX,DX			; room for FAT
 10253                                  		; 16/06/2018
 10254                                  		;MOV	[CS:FatLoc],AX		; location to read fat
 10255                                  		; 01/07/2018
 10256                                  		;; 17/06/2018
 10257                                  		;mov	[FatLoc],ax
 10258                                  
 10259                                  		; 01/07/2018
 10260                                  
 10261                                  		; 08/04/2018
 10262                                  		; 28/03/2018
 10263                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
 10264 00002D87 83E840                  		sub	ax,64		;room for boot record buffer segment (1 kb)
 10265 00002D8A A3[FD2B]                		mov	[init_bootseg],ax
 10266                                  
 10267                                  		;POP	AX ; (*)
 10268                                  		; 03/07/2018
 10269                                  		;pop	dx ; (*)
 10270                                  
 10271                                  		;; 02/06/2018
 10272                                  		;MOV	word [SYSINIT_START+DEVICE_LIST],CONHeader
 10273                                  		;MOV	[SYSINIT_START+DEVICE_LIST+2],CS
 10274                                  		; 05/07/2018
 10275 00002D8D C706[3C39][BE00]        		MOV	word [SYSINIT+DEVICE_LIST],CONHeader
 10276 00002D93 8C0E[3E39]              		MOV	[SYSINIT+DEVICE_LIST+2],CS
 10277                                  
 10278                                  		;; 06/04/2018
 10279                                  		;;MOV	[SYSINIT_START+MEMORY_SIZE],AX ; Top of memory (in paragraphs)
 10280                                  		;mov	[SYSINIT_START+MEMORY_SIZE],dx ; 01/07/2018
 10281                                  		;INC	CL
 10282                                  		;MOV	[SYSINIT_START+DEFAULT_DRIVE],CL ; SAVE DEFAULT DRIVE SPEC
 10283                                  
 10284                                  		; 05/07/2018
 10285                                  		;MOV	[SYSINIT+MEMORY_SIZE],AX
 10286 00002D97 8916[4E39]              		mov	[SYSINIT+MEMORY_SIZE],dx
 10287 00002D9B FEC1                    		INC	CL
 10288 00002D9D 880E[5039]              		MOV	[SYSINIT+DEFAULT_DRIVE],CL
 10289                                  		
 10290                                  		; 02/06/2018
 10291                                  		;mov	dx,ax
 10292                                  
 10293                                  		; 08/04/2018
 10294                                  		; 28/03/2018
 10295                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
 10296                                  		;sub	ax,64		;room for boot record buffer segment (1 kb)
 10297                                  		;mov	[init_bootseg],ax
 10298                                  
 10299                                  		;mov	ax,MSDOS_BIN_SEGMENT  ; MSDOS_BIN_OFFSET >> 4
 10300                                  		;add	ax,KERNEL_SEGMENT ; 26/03/2018
 10301                                  		;;MOV	[SYSINIT_START+CURRENT_DOS_LOCATION],AX
 10302                                  		;05/07/2018
 10303                                  		;MOV	[SYSINIT+CURRENT_DOS_LOCATION],AX
 10304                                  
 10305                                  		; 29/06/2019 - Retro DOS v3.1
 10306 00002DA1 C706[3639]6005          		mov	word [SYSINIT+CURRENT_DOS_LOCATION], MSDOS_BIN_SEGMENT
 10307                                  
 10308                                  ; 02/06/2018
 10309                                  ;
 10310                                  ; IMPORTANT: Some old IBM hardware generates spurious INT F's due to bogus
 10311                                  ; printer cards. We initialize this value to point to an IRET ONLY IF
 10312                                  ;
 10313                                  ; 1) The original segment points to storage inside valid RAM.
 10314                                  ;
 10315                                  ; 2) The original segment is 0F000:xxxx
 10316                                  ;
 10317                                  ; Theses are capricious requests from our OEM for reasons behind them, read
 10318                                  ; the DCR's for the IBM DOS 3.2 project.
 10319                                  ;
 10320                                  		; 03/07/2018
 10321                                  		;push	ax
 10322                                  		
 10323                                  		; 02/06/2018 - Retro DOS v3.0
 10324                                  		;push	ds
 10325                                  		;pop	es
 10326                                  
 10327 00002DA7 31C0                    		xor	ax,ax
 10328 00002DA9 8ED8                    		mov	ds,ax
 10329                                  
 10330 00002DAB A13E00                  		mov	ax,[0Fh*4+2]		; segment for Int 15
 10331                                  
 10332                                  		;;cmp	ax,[es:SYSINIT_START+MEMORY_SIZE] ; Condition 1
 10333                                  		; 05/07/2018
 10334                                  		;cmp	ax,[es:SYSINIT+MEMORY_SIZE]
 10335 00002DAE 39D0                    		cmp	ax,dx
 10336 00002DB0 7605                    		jna	short ResetIntF
 10337                                  
 10338 00002DB2 3D00F0                  		cmp	ax,0F000h		; Condition 2
 10339 00002DB5 750A                    		jne	short KeepIntF
 10340                                  ResetIntF:
 10341 00002DB7 C7063C00[9D07]          		mov	word [0Fh*4],INTRET
 10342 00002DBD 8C0E3E00                		mov	[0Fh*4+2],cs
 10343                                  KeepIntF:
 10344                                  		;pop	ax
 10345                                  ;
 10346                                  ; END IMPORTANT
 10347                                  ;
 10348                                  
 10349                                  ; 02/06/2018 - Retro DOS v3.0
 10350                                  
 10351                                  ;**************************************************************
 10352                                  ;	WILL INITIALIZE THE NUMBER OF DRIVES		
 10353                                  ;	AFTER THE EQUIPMENT CALL (INT 11H) BITS 6&7 WILL TELL	
 10354                                  ;	THE INDICATIONS ARE AS FOLLOWS: 		
 10355                                  ;							
 10356                                  ;	BITS	7	6	DRIVES			
 10357                                  ;		0	0	1			
 10358                                  ;		0	1	2			
 10359                                  ;		1	0	3			
 10360                                  ;		1	1	4			
 10361                                  ;************************************************************** 
 10362 00002DC1 0E                      		PUSH	CS
 10363 00002DC2 1F                      		POP	DS
 10364 00002DC3 0E                      		PUSH	CS
 10365 00002DC4 07                      		POP	ES
 10366                                  
 10367 00002DC5 E83808                  		call	CMOS_CLOCK_READ  ;Before doing anything if CMOS clock,
 10368                                  				 ;then set the system time accordingly.
 10369                                  				 ;Also, reset the cmos clock rate.
 10370                                  		; 16/07/2019
 10371                                  		;XOR	SI,SI
 10372                                  		;MOV	WORD [SI],HARDDRV ;set up pointer to hdrive
 10373 00002DC8 C706[0000][1D1B]        		mov	word [hdrv_pat],HARDDRV
 10374                                  
 10375 00002DCE 58                      		POP	AX ; (***) ;number of floppies and FAT ID
 10376 00002DCF 30E4                    		XOR	AH,AH	; Chuck FAT ID byte
 10377                                  		;MOV	[HARDNUM],AL ;Remember which drive is hard disk
 10378 00002DD1 A2[1001]                		MOV	[DRVMAX],AL  ;And set initial number of drives
 10379                                  
 10380                                  		; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21)
 10381 00002DD4 A2[A601]                		mov	[dsktnum],al 
 10382                                  
 10383                                  		;SHL	AX,1	;Two bytes per address
 10384 00002DD7 D0E0                    		shl	al,1
 10385                                  
 10386 00002DD9 0106[F22B]              		add	[last_dskdrv_table],ax ; 28/12/2018
 10387                                  
 10388                                  		; 17/07/2019
 10389                                  		;MOV	DI,DSKDRVS
 10390                                  		;ADD	DI,AX	;Point to hardfile location
 10391                                  		;MOV	SI,HDSKTAB
 10392                                  		;MOVSW		;Two addresses to move
 10393                                  		;MOVSW
 10394                                  
 10395 00002DDD B280                    		mov	DL,80h	; tell rom bios to look at hard drives
 10396 00002DDF B408                    		mov	AH,08h	; set command to get drive parameter
 10397 00002DE1 CD13                    		int	13h	; call ROM-BIOS to get number of drives
 10398 00002DE3 7204                    		jc	short ENDDRV ; old, rom therefore no hard disks
 10399                                  
 10400 00002DE5 8816[1C1B]              		mov	[HNUM],DL ; save number of hard drives in HNUM
 10401                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))
 10402                                  ENDDRV:
 10403                                  ;
 10404                                  ; Scan the list of drives to determine their type. We have three flavors of
 10405                                  ; diskette drives:
 10406                                  ;
 10407                                  ;   48tpi drives    We do nothing special for them
 10408                                  ;   96tpi drives    Mark the fact that they have changeline support.
 10409                                  ;   3 1/2 drives    Mark changeline support and small.
 10410                                  ;
 10411                                  ; The following code uses registers for certain values:
 10412                                  ;   DL - Physical Drive
 10413                                  ;   DS:DI - points to current BDS
 10414                                  ;   CX - Flag bits for BDS
 10415                                  ;   DH - Form Factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
 10416                                  ;
 10417 00002DE9 30D2                    		XOR	DL,DL	; start out with drive 0.
 10418                                  		; 17/06/2018
 10419                                  		;push	cs
 10420                                  		;pop	ds
 10421 00002DEB C606[AC01]09            		MOV	byte [EOT],9
 10422 00002DF0 BF[9A01]                		mov	di,START_BDS
 10423                                  
 10424                                  ; 16/07/2019 - Retro DOS v3.2
 10425                                  
 10426                                  ; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.0, MSINIT.ASM)
 10427                                  
 10428                                  ; check if the system has no physical diskette drives.
 10429                                  ; if it is, then we don't have to set bds tables. but since we
 10430                                  ; pretend that we have 2 floppies, we are going to reserve two
 10431                                  ; bds tables for the fake drive a, and b. and set the end of link
 10432                                  ; pointer.
 10433                                  
 10434                                  ;*********************************************************
 10435                                  ;	check to see if we are faking floppy drives. if not we don't
 10436                                  ;	do anything special. if we are faking floppy drives we need
 10437                                  ;	to set aside two bdss for the two fake floppy drives. we
 10438                                  ;	don't need to initalise any fields though. so starting at start_bds
 10439                                  ;	use the link field in the bds structure to go to the second bds
 10440                                  ;	in the list and initalise it's link field to -1 to set the end of
 10441                                  ;	the list.  then jump to the routine at dohard to allocate/initialise
 10442                                  ;	the bds for harddrives.
 10443                                  
 10444 00002DF3 803E[792B]01            		cmp	byte [fakefloppydrv],1
 10445 00002DF8 750B                    		jne	short LOOP_DRIVE	 
 10446                                  
 10447                                  		; 18/03/2019
 10448                                  		;mov	di,[di+BDS.link]	; di <- first bds link
 10449 00002DFA 8B3D                    		mov	di,[di]
 10450                                  		;mov	di,[di+BDS.link]	; di <- second bds link
 10451 00002DFC 8B3D                    		mov	di,[di]
 10452                                  		;mov	word [di+BDS.link],-1	; set end of link
 10453 00002DFE C705FFFF                		mov	word [di],-1
 10454 00002E02 E90F01                  		jmp	DoHard ; 16/07/2019	; allocate/initialise bds fo
 10455                                  
 10456                                  LOOP_DRIVE:
 10457 00002E05 3A16[1001]              		cmp	dl,[DRVMAX]
 10458 00002E09 7203                    		jb	short GOT_MORE
 10459 00002E0B E90201                  		jmp	DONE_DRIVES
 10460                                  GOT_MORE:
 10461 00002E0E 31C9                    		xor	cx,cx		; zero all flags
 10462                                  		;mov	di,[DI+BDS.link] ; get next BDS
 10463 00002E10 8B3D                    		mov	di,[di] ; 05/07/2019
 10464 00002E12 B600                    		mov	dh,ff48tpi	; Set Form Factor to 48 tpi
 10465 00002E14 C606[782B]28            		MOV	byte [NUM_CYLN],40 ; 40 TRACKS PER SIDE
 10466                                  								
 10467                                  		;PUSH	DS						
 10468 00002E19 57                      		PUSH	DI						
 10469 00002E1A 52                      		PUSH	DX						
 10470 00002E1B 51                      		PUSH	CX
 10471                                  		; 17/06/2018						
 10472                                  		;PUSH	ES						
 10473 00002E1C 0E                      		push	cs ; ((*))		
 10474                                  						
 10475 00002E1D B408                    		MOV	AH,08h		;GET DRIVE PARAMETERS
 10476 00002E1F CD13                    		INT	13h		;CALL ROM-BIOS		
 10477                                  		;JNC	short PARMSFROMROM					
 10478                                  		;JMP	short NOPARMSFROMROM ; GOT AN OLD ROM
 10479 00002E21 7275                    		jc	short NOPARMSFROMROM ; 03/06/2018
 10480                                  		; ES:DI = Address of Harddisk Parameter Table ; ((*))	
 10481                                  PARMSFROMROM:							
 10482                                  ;If CMOS is bad, it gives ES,AX,BX,CX,DH,DI=0. CY=0.	 
 10483                                  ;In this case, we are going to put bogus informations to BDS table.
 10484                                  ;We are going to set CH=39,CL=9,DH=1 to avoid divide overflow when	
 10485                                  ;they are calculated at the later time. This is just for the Diagnostic
 10486                                  ;Diskette which need IO.SYS,MSDOS to boot up before it sets CMOS.	
 10487                                  ;This should only happen with drive B.	
 10488                                  
 10489                                  ;;Rev 3.30 Modification -----------------------------------------------
 10490                                  		;CMP	CH,0	; if ch=0, then cl,dh=0 too.	 
 10491                                  		;JNE	short PFR_OK							 
 10492                                  		;MOV	CH,39	; ROM gave wrong info.		 
 10493                                  		;MOV	CL,9	; Let's default to 360K.         
 10494                                  		;MOV	DH,1
 10495                                  	
 10496 00002E23 08ED                    		or	ch,ch
 10497 00002E25 7505                    		jnz	short PFR_OK
 10498                                  
 10499                                  		;mov	ch,39		; rom gave wrong info.
 10500                                  		;mov	cl,9		; let's default to 360k.
 10501 00002E27 B90927                  		mov	cx,2709h		
 10502                                  
 10503 00002E2A B601                    		mov	dh,1
 10504                                  PFR_OK: 								 
 10505 00002E2C FEC6                    		INC	DH	; MAKE NUMBER OF HEADS 1-BASED	 
 10506 00002E2E FEC5                    		INC	CH	; MAKE NUMBER OF CYLINDERS 1-BASED
 10507 00002E30 8836[762B]              		MOV	[NUM_HEADS],DH	; SAVE PARMS RETURNED BY ROM	 
 10508 00002E34 80E13F                  		AND	CL,00111111b	; EXTRACT SECTORS/TRACK 	 
 10509 00002E37 880E[772B]              		MOV	[SEC_TRK],CL						 
 10510 00002E3B 882E[782B]              		MOV	[NUM_CYLN],CH	; ASSUME LESS THAN 256 CYLINDERS!! 
 10511                                  ; MAKE SURE THAT EOT CONTAINS THE MAX NUM OF SEC/TRK IN SYSTEM OF FLOPPIES
 10512 00002E3F 3A0E[AC01]              		CMP	CL,[EOT]	; MAY SET CARRY 		 
 10513 00002E43 7604                    		JBE	short EOT_OK							
 10514 00002E45 880E[AC01]              		MOV	[EOT],CL						
 10515                                  EOT_OK: 							
 10516 00002E49 07                      		POP	ES ; ((*)) es = cs = ds						
 10517 00002E4A 59                      		POP	CX						
 10518 00002E4B 5A                      		POP	DX						
 10519 00002E4C 5F                      		POP	DI						
 10520                                  		;POP	DS						
 10521                                  ;
 10522                                  ; Check for presence of changeline
 10523                                  ;
 10524 00002E4D B415                    		mov	AH,15h      	; set command to get DASD type
 10525 00002E4F CD13                    		int	13h	     	; call ROM-BIOS
 10526 00002E51 720D                    		JC	short CHANGELINE_DONE 	
 10527 00002E53 80FC02                  		CMP	AH,2		; CHECK FOR PRESENCE OF CHANGELINE
 10528 00002E56 7508                    		JNE	short CHANGELINE_DONE 					 
 10529                                  ;;End of Modification -----------------------------------------------
 10530                                  
 10531                                  ; We have a drive with change line support.
 10532                                  
 10533                                  		;or	cl,2
 10534 00002E58 80C902                  		or	CL,fChangeline	; signal type
 10535 00002E5B C606[1201]01            		mov	byte [fHave96],1 ; Remember that we have 96tpi disks
 10536                                  ;									  
 10537                                  ; WE NOW TRY TO SET UP THE FORM FACTOR FOR THE TYPES OF MEDIA THAT WE KNOW
 10538                                  ; AND CAN RECOGNISE. FOR THE REST, WE SET THE FORM FACTOR AS "OTHER".     
 10539                                  ;									  
 10540                                  CHANGELINE_DONE:							  
 10541                                  ; 40 CYLINDERS AND 9 OR LESS SEC/TRK, TREAT AS 48 TPI MEDIUM.		  
 10542 00002E60 803E[782B]28            		CMP	byte [NUM_CYLN],40						  
 10543 00002E65 750B                    		JNZ	short TRY_80							  
 10544 00002E67 803E[772B]09            		CMP	byte [SEC_TRK],9						  
 10545                                  		;JBE	short GOT_FF
 10546 00002E6C 7653                    		jbe	short NEXTDRIVE ; 03/06/2018							  
 10547                                  GOTOTHER:								  
 10548 00002E6E B607                    		MOV	DH,ffOther ; 7	; WE HAVE A "STRANGE" MEDIUM     
 10549                                  		;JMP	SHORT GOT_FF
 10550 00002E70 EB4F                    		jmp	short NEXTDRIVE	; 03/06/2018				  
 10551                                  
 10552                                  ;									  
 10553                                  ; 80 CYLINDERS AND 9 SECTORS/TRACK => 720 KB DEVICE			  
 10554                                  ; 80 CYLINDERS AND 15 SEC/TRK => 96 TPI MEDIUM				  
 10555                                  ;									  
 10556                                  TRY_80: 
 10557                                  	; 03/06/2018 - Retro DOS v3.0 - MSDOS 6.0 (MSINIT.ASM, 1991) modifications
 10558                                  	
 10559 00002E72 803E[782B]50            		CMP	byte [NUM_CYLN],80						
 10560 00002E77 75F5                    		JNZ	short GOTOTHER
 10561                                  
 10562                                  		; 03/06/2018 (MSDOS 6.0, MSINIT.ASM, 1991)
 10563 00002E79 B609                    		mov	dh,ff288 ; 9	   ; assume 2.88 MB drive m037
 10564 00002E7B 803E[772B]24            		cmp	byte [SEC_TRK],36  ; is it ?		  m037
 10565 00002E80 743F                    		je	short NEXTDRIVE	   ; yeah, go update	  m037
 10566                                  
 10567 00002E82 803E[772B]0F            		CMP	byte [SEC_TRK],15						
 10568 00002E87 740B                    		JZ	short GOT96							
 10569 00002E89 803E[772B]09            		CMP	byte [SEC_TRK],9						
 10570 00002E8E 75DE                    		JNZ	short GOTOTHER	 ; (1.44MB, 3.5" diskette drive)
 10571 00002E90 B602                    		MOV	DH,ffSmall ; 2
 10572                                  		;JMP	SHORT GOT_FF
 10573 00002E92 EB2D                    		jmp	short NEXTDRIVE
 10574                                  GOT96:	
 10575 00002E94 B601                    		MOV	DH,ff96tpi ; 1
 10576                                  ;GOT_FF: 
 10577 00002E96 EB29                    		JMP	SHORT NEXTDRIVE 
 10578                                  
 10579                                  ; WE HAVE AN OLD ROM, SO WE EITHER HAVE A 48TPI OR 96TPI DRIVE. IF THE DRIVE
 10580                                  ; HAS CHANGELINE, WE ASSUME IT IS A 96TPI, OTHERWISE IT IS A 48TPI.
 10581                                  
 10582                                  NOPARMSFROMROM:
 10583 00002E98 07                      		POP	ES ; ; ((*))
 10584 00002E99 59                      		POP	CX
 10585 00002E9A 5A                      		POP	DX
 10586 00002E9B 5F                      		POP	DI
 10587                                  		;POP	DS
 10588                                  
 10589 00002E9C B415                    		MOV	AH,15h		; SET COMMAND TO GET DASD TYPE
 10590 00002E9E CD13                    		INT	13h		; CALL ROM-BIOS
 10591 00002EA0 721F                    		JC	short NEXTDRIVE
 10592 00002EA2 80FC02                  		CMP	AH,2		; IS THERE CHANGELINE?
 10593 00002EA5 751A                    		JNZ	short NEXTDRIVE
 10594 00002EA7 80C902                  		OR	CL,fChangeline ; 2
 10595 00002EAA C606[1201]01            		MOV	byte [fHave96],1 ; REMEMBER WE HAVE 96TPI DRIVES
 10596 00002EAF C606[782B]50            		MOV	byte [NUM_CYLN],80
 10597 00002EB4 B601                    		MOV	DH,ff96tpi ; 1
 10598 00002EB6 B00F                    		MOV	AL,15		; SET EOT IF NECESSARY
 10599 00002EB8 3A06[AC01]              		CMP	AL,[EOT]
 10600 00002EBC 7603                    		JBE	short EOT_OK2
 10601 00002EBE A2[AC01]                		MOV	[EOT],AL
 10602                                  EOT_OK2:
 10603                                  NEXTDRIVE:
 10604 00002EC1 80C920                  		or	cl,fI_Own_Physical ; set this true for all drives
 10605 00002EC4 88D7                    		mov	bh,dl	 	;save Int13 drive number
 10606                                  
 10607                                  ; we need to do special things if we have a single drive system and are setting
 10608                                  ; up a logical drive. it needs to have the same int13 drive number as its
 10609                                  ; counterpart, but the next drive letter. also reset ownership flag.
 10610                                  ; we detect the presence of this situation by examining the flag single for the
 10611                                  ; value 2.
 10612                                  
 10613 00002EC6 803E[1401]02            		cmp	byte [Single],2
 10614 00002ECB 7505                    		jnz	short NOT_SPECIAL
 10615 00002ECD FECF                    		dec	bh	; int13 drive number same for logical drive
 10616                                  	 			; reset ownership flag for logical drive
 10617 00002ECF 80F120                  		xor	cl,fI_Own_Physical
 10618                                  NOT_SPECIAL:
 10619                                  ; The values that we put in for RHdlim and RSeclim will only remain if the
 10620                                  ; form factor is of type "ffOther".
 10621                                  		
 10622 00002ED2 31C0                    		xor	ax,ax			; fill BDS for drive
 10623 00002ED4 A0[762B]                		mov	al,[NUM_HEADS]
 10624 00002ED7 894536                  		mov	[di+BDS.rheads],ax
 10625 00002EDA A0[772B]                		mov	al,[SEC_TRK]
 10626 00002EDD 894534                  		mov	[di+BDS.rsecpertrack],ax
 10627 00002EE0 894D23                  		mov	[di+BDS.flags],cx
 10628 00002EE3 887522                  		mov	[di+BDS.formfactor],dh
 10629 00002EE6 885505                  		mov	[di+BDS.drivelet],dl
 10630 00002EE9 887D04                  		mov	[di+BDS.drivenum],bh
 10631 00002EEC 8A1E[782B]              		mov	bl,[NUM_CYLN]
 10632 00002EF0 885D25                  		mov	[di+BDS.cylinders],bl	; only the l.s. byte is set here
 10633                                  		
 10634 00002EF3 803E[1401]01            		cmp	byte [Single],1		; Special case for single drive system
 10635 00002EF8 7511                    		jnz	short NO_SINGLE
 10636                                  						; Don't forget we have
 10637 00002EFA C606[1401]02            		mov	byte [Single],2		;   single drive system
 10638 00002EFF 83C910                  		or	cx,fI_Am_Mult		; set that this is one of
 10639                                  						;   several drives
 10640 00002F02 094D23                  		or	[di+BDS.flags],cx	; save flags
 10641                                  		;mov	di,[di+BDS.link]	; move to next BDS in list
 10642 00002F05 8B3D                    		mov	di,[di] ; 05/07/2019
 10643 00002F07 FEC2                    		inc	dl			; add a number
 10644 00002F09 EBB6                    		jmp	short NEXTDRIVE		; Use same info for BDS as previous
 10645                                  NO_SINGLE:
 10646 00002F0B FEC2                    		inc	dl
 10647 00002F0D E9F5FE                  		jmp	LOOP_DRIVE	
 10648                                  
 10649                                  DONE_DRIVES:
 10650                                  		;mov	ax,-1			; Signify end of list by
 10651                                  		;mov	[di+BDS.link],ax	;    setting pointer to -1
 10652                                  		;mov	word [di+BDS.link],-1 ; 03/07/2018
 10653 00002F10 C705FFFF                		mov	word [di],-1 ; 05/07/2019
 10654                                  
 10655                                  ; Set up all the hard drives in the system
 10656                                  
 10657                                  		; 03/06/2018	
 10658                                  DoHard:
 10659                                  		; 16/07/2019 - Retro DOS v3.2
 10660 00002F14 8A36[1C1B]              		mov	dh,[HNUM]
 10661 00002F18 08F6                    		or	dh,dh			; done if no hardfiles
 10662 00002F1A 745B                    		jz	short STATIC_CONFIGURE
 10663                                  
 10664 00002F1C B280                    		mov	dl,80h
 10665                                  dohard1:
 10666 00002F1E 52                      		push	dx
 10667                                  
 10668 00002F1F 8B3E[E82B]              		mov	di,[end_of_bdss]
 10669 00002F23 8A1E[1001]              		mov	bl,[DRVMAX]
 10670                                  		; 15/07/2019
 10671 00002F27 B700                    		mov	bh,0		; first primary partition (or active)
 10672                                  
 10673 00002F29 E8B201                  		call	SETHARD
 10674 00002F2C 7208                    		jc	short hardfile_err
 10675                                  
 10676 00002F2E E88D06                  		call	dmax_check	; error if already 26 drives
 10677 00002F31 7303                    		jnc	short hardfile_err
 10678                                  
 10679 00002F33 E89506                  		call	xinstall_bds	; insert new bds into linked list
 10680                                  hardfile_err:
 10681 00002F36 5A                      		pop	dx
 10682                                  
 10683 00002F37 FEC2                    		inc	dl		; next hard drive
 10684 00002F39 FECE                    		dec	dh
 10685 00002F3B 75E1                    		jnz	short dohard1
 10686                                  
 10687                                  ; End of physical drive initialization.	
 10688                                  ; *** Do not change the position of the following statement.
 10689                                  ; *** DoMini routine will use [DRVMAX] value for the start of the logical
 10690                                  ; *** drive number of Mini disk(s).
 10691                                  
 10692 00002F3D E8B605                  		call    DoMini		;For setting up mini disks, if found
 10693                                  
 10694                                  ; 17/07/2019 - Retro DOS v3.2 
 10695                                  
 10696                                  ; -- begin added section
 10697                                  
 10698 00002F40 8A36[1C1B]              		mov	dh,[HNUM]	; we already know this is >0
 10699                                  
 10700 00002F44 B280                    		mov	dl,80h
 10701                                  dohardx1:
 10702 00002F46 B701                    		mov	bh,1		; do all subsequent primary partitions
 10703                                  dohardx2:
 10704 00002F48 52                      		push	dx
 10705 00002F49 53                      		push	bx
 10706 00002F4A 8B3E[E82B]              		mov	di,[end_of_bdss]
 10707 00002F4E 8A1E[1001]              		mov	bl,[DRVMAX]
 10708 00002F52 E88901                  		call	SETHARD
 10709 00002F55 720E                    		jc	short dohardx4	; move to next hardfile if error
 10710                                  
 10711 00002F57 E86406                  		call	dmax_check	; -- make sure <=26 drives
 10712 00002F5A 7309                    		jnc	short dohardx4	; -- skip if error
 10713                                  
 10714 00002F5C E86C06                  		call	xinstall_bds	; insert new bds into linked list
 10715                                  
 10716 00002F5F 5B                      		pop	bx		; get partition number
 10717 00002F60 5A                      		pop	dx		; restore physical drive counts
 10718 00002F61 FEC7                    		inc	bh
 10719 00002F63 EBE3                    		jmp	short dohardx2	; keep looping until we fail
 10720                                  dohardx4:
 10721 00002F65 5B                      		pop	bx		; unjunk partition number from stack
 10722 00002F66 5A                      		pop	dx		; restore physical drive counts
 10723                                  
 10724 00002F67 FEC2                    		inc	dl		; next hard drive
 10725 00002F69 FECE                    		dec	dh
 10726 00002F6B 75D9                    		jnz	short dohardx1
 10727                                  
 10728                                  ; -- end changed section
 10729                                  
 10730                                  ;******************************************************************************
 10731                                  ; if more than 2 diskette drives on the system, then it is necessary to remap
 10732                                  ; the bds chain to adjust the logical drive num (driver letter) with greater
 10733                                  ; than two diskette drives
 10734                                  ;
 10735                                  ; new scheme:	if more than 2 diskette drives, first map the bds structure
 10736                                  ;		as usual and then rescan the bds chain to adjust the  drive
 10737                                  ;		letters. to do this, scan for disk drives and assign logical
 10738                                  ;		drive number starting from 2 and then rescan diskette drives
 10739                                  ;		and assign next to the last logical drive number of last disk
 10740                                  ;		drive to the 3rd and 4th diskette drives.
 10741                                  ;******************************************************************************
 10742                                  
 10743 00002F6D 803E[A601]02            		cmp	byte [dsktnum],2 ; >2 diskette drives
 10744 00002F72 7603                    		jbe	short no_remap	; no - no need for remapping
 10745                                  
 10746 00002F74 E8F100                  		call	remap		; remap bds chain to adjust driver letters
 10747                                  no_remap:
 10748                                  
 10749                                  ; End of drive initialization.
 10750                                  
 10751                                  ; 03/06/2018 - Retro DOS v3.0
 10752                                  
 10753                                  ;9/24/86 We now decide, based on the configurations available so far,
 10754                                  ;what code or data we need to keep as a stay resident code. The following
 10755                                  ;table shows the configurations under consideration. They are listed in  
 10756                                  ;the order of their current position memory.				  
 10757                                  ;Configuration will be done in two ways:				  
 10758                                  ;First, we are going to set "Static configuration". Static configuration 
 10759                                  ;will consider from basic configuration to ENDOF96TPI configuration.	  
 10760                                  ;The result of static configuration will be the address the Dynamic	  
 10761                                  ;configuration will use to start with.					  
 10762                                  ;Secondly, "Dynamic cofiguration" will be performed. Dynamic configuration
 10763                                  ;involves possible relocation of CODE/DATA. Dynamic configuration routine 
 10764                                  ;will take care of BDSM tables and AT ROM Fix module thru K09 suspend/res 
 10765                                  ;code individually. After these operation, FINAL_DOS_LOCATION will be set.
 10766                                  ;This will be the place SYSINIT routine will relocate MSDOS module.	  
 10767                                  ;									  
 10768                                  ;   1.	 BASIC CONFIGURATION FOR MSBIO (EndFloppy, EndSwap)		  
 10769                                  ;   2.	 ENDONEHARD							  
 10770                                  ;   3.	 ENDTWOHARD							  
 10771                                  ;   4.	 END96TPI	;a system that supports "Change Line Error"       
 10772                                  ;   5.	 End of BDSM	;BDSM tables for mini disks.			  
 10773                                  ;   6.	 ENDATROM	;Some of AT ROM fix module.			  
 10774                                  ;   7.	 ENDCMOSCLOCKSET;Supporting program for CMOS clock write.	  
 10775                                  ;   8.	 ENDK09 	;K09 CMOS Clock module to handle SUSPEND/RESUME   
 10776                                  ;									  
 10777                                  ;9/24/86.								  
 10778                                  									  
 10779                                  ; *** For mini disk configuration. 4/7/86	 			  
 10780                                  ; *** END_OF_BDSM will contain the ending address(off) of BDSM table for  
 10781                                  ; *** mini disks which is located right after the label END96TPI.	  
 10782                                  ; *** The variable NUM_MINI_DSK will indicate the existance. 4/7/86	
 10783                                  
 10784                                  
 10785                                  ; 18/07/2019 - Retro DOS v3.2
 10786                                  ; (MSDOS 6.0)  
 10787                                  
 10788                                  ; -- begin changed section
 10789                                  ;
 10790                                  ;   1.	 basic configuration for msbio (endfloppy)
 10791                                  ;   2.   end96tpi	; a system that supports "change line error"
 10792                                  ;   3.	 end of bdss	; end of bdss for hard disks
 10793                                  ;   4.	 endatrom	;some of at rom fix module.
 10794                                  ;   5.	 endcmosclockset;supporting program for cmos clock write.
 10795                                  ;   6.	 endk09 	;k09 cmos clock module to handle suspend/resume operation.
 10796                                  ;
 10797                                  									  
 10798                                  STATIC_CONFIGURE:
 10799                                  		; 18/07/2019 - Retro DOS v3.2
 10800                                  		; (Modified MSDOS 3.3 code)
 10801                                  	
 10802                                  ;		; 05/07/2019						  
 10803                                  ;		;PUSH	AX ; !@							  
 10804                                  ;
 10805                                  ;		mov	ax,End96tpi		;let's start with the biggest one.
 10806                                  ;		cmp	byte [fHave96],0	;Is change line support there?	  
 10807                                  ;		jnz	short Config96		;Yes.				 
 10808                                  ;									  
 10809                                  ;		mov	ax,EndTwoHard					
 10810                                  ;		cmp	byte [HNUM],1 		;1 hard file?			
 10811                                  ;		ja	short ConfigTwoHard						
 10812                                  ;No_Two_HRD:								
 10813                                  ;		mov	ax,EndOneHard					
 10814                                  ;		je	short ConfigOneHard ; 29/06/2019						
 10815                                  ;Basic_Floppy:								
 10816                                  ;		mov	ax,EndFloppy					 
 10817                                  ;		jmp	short DYNAMIC_CONFIGURE	;static configuration is done!	
 10818                                  ;;
 10819                                  ;; Keep the 96tpi code
 10820                                  ;;
 10821                                  ;Config96:
 10822                                  ;;
 10823                                  ;; Save old INT 13 vector
 10824                                  ;;
 10825                                  ;		PUSH	AX
 10826                                  ;		PUSH	DS
 10827                                  ;		XOR	AX,AX
 10828                                  ;		MOV	DS,AX
 10829                                  ;		MOV	AX,[4*13h]
 10830                                  ;		MOV	[CS:REAL13],AX
 10831                                  ;		MOV	AX,[4*13h+2]
 10832                                  ;		MOV	[CS:REAL13+2],AX
 10833                                  ;;
 10834                                  ;; Insert new vector
 10835                                  ;;
 10836                                  ;		MOV	word [4*13h],INT13
 10837                                  ;		MOV	[4*13h+2],CS
 10838                                  ;		POP	DS
 10839                                  ;		POP	AX
 10840                                  ;
 10841                                  ;; Keep two hard disk BPBs
 10842                                  ;
 10843                                  ;ConfigTwoHard:
 10844                                  ;
 10845                                  ;; Keep one hard disk BPB
 10846                                  ;
 10847                                  ;ConfigOneHard:
 10848                                  ;
 10849                                  ;; Adjust the number of drives to include the hard disks.
 10850                                  ;
 10851                                  ;		; 16/07/2019
 10852                                  ;
 10853                                  ;		;PUSH	AX
 10854                                  ;		;MOV	AL,[HARDNUM]
 10855                                  ;		;ADD	AL,[HNUM]
 10856                                  ;		;add	al,[num_mini_dsk] ;4/7/86 for mini disks installed	
 10857                                  ;		;		;if not installed, then num_mini_dsk = 0.
 10858                                  ;		;MOV	[DRVMAX],AL
 10859                                  ;		;POP	AX
 10860                                  
 10861                                  		; 18/07/2019 - Retro DOS v3.2
 10862                                  		; (Modified MSDOS 6.0 code)
 10863                                  
 10864 00002F77 A1[E82B]                		mov	ax,[end_of_bdss]
 10865                                  		;cmp	ax,bdss	; did we allocate any hard drive bdss?
 10866 00002F7A 3D[C61D]                		cmp	ax,BDSH
 10867 00002F7D 750D                    		jne	short DYNAMIC_CONFIGURE	; that's the end, then
 10868                                  
 10869 00002F7F B8[C61D]                		mov	ax,End96tpi	; keep everything up to end96tpi
 10870 00002F82 803E[1201]00            		cmp	byte [fHave96],0 ; is change line support there?
 10871 00002F87 7503                    		jne	short DYNAMIC_CONFIGURE ;yes.
 10872                                  
 10873 00002F89 B8[1C1B]                		mov	ax,EndFloppy
 10874                                  
 10875                                  DYNAMIC_CONFIGURE:
 10876                                  		;call	Get_Para_Offset ;For dynamic allocation, we are
 10877                                  					;going to use offset address that
 10878                                  					;is in paragraph boundary.
 10879                                  		; 17/06/2018 (es=cs=ds)
 10880                                  		;push	cs
 10881                                  		;pop	es		;es -> code
 10882                                  		
 10883 00002F8C FC                      		cld			;clear direction
 10884                                  
 10885                                  		; 18/07/2019
 10886                                  		;; 16/07/2019
 10887                                  		;mov	cx,[end_of_bdss]
 10888                                  		;cmp	cx,BDSMs	;Mini disk(s) installed ?
 10889                                  		;jna	short CheckATROM ;No.
 10890                                  		;mov	ax,cx
 10891                                  CheckATROM:	
 10892                                  		; 16/07/2019
 10893 00002F8D E8C400                  		call	Get_Para_Offset ;For dynamic allocation, we are
 10894                                  					;going to use offset address that
 10895                                  					;is in paragraph boundary.
 10896                                  				
 10897 00002F90 803E[B506]FC            		cmp	byte [MODEL_BYTE],0FCh	;AT ?
 10898 00002F95 7535                    		jnz	short CheckCMOSClock				
 10899 00002F97 803E[1C1B]00            		cmp	byte [HNUM],0 		;No hard file?	
 10900 00002F9C 742E                    		jz	short CheckCMOSClock			
 10901 00002F9E BE00F0                  		mov	si,0F000h					
 10902 00002FA1 8EC6                    		mov	es,si			;ES -> BIOS segment
 10903 00002FA3 BE[F42B]                		mov	si,Bios_Date			
 10904 00002FA6 BFF5FF                  		mov	di,0FFF5h	;ROM BIOS string is at F000:FFF5
 10905                                  Cmpbyte:				;Only patch ROM for bios 01/10/84
 10906 00002FA9 A6                      		cmpsb							
 10907 00002FAA 7520                    		jnz	short CheckCMOSClock					
 10908 00002FAC 807CFF00                		cmp	byte [si-1],0				
 10909 00002FB0 75F7                    		jnz	short Cmpbyte 					
 10910                                  SetRomCode:				;Now we have to install ROM fix
 10911                                  					;AX is the address to move.
 10912 00002FB2 0E                      		push	cs						
 10913 00002FB3 07                      		pop	es		;set ES to CODE seg	
 10914 00002FB4 A3[B806]                		mov	[ORIG13],ax				
 10915 00002FB7 8C0E[BA06]              		mov	[ORIG13+2],cs	;set new ROM bios int 13 vector
 10916 00002FBB B9[C628]                		mov	cx,ENDATROM				
 10917 00002FBE BE[9A27]                		mov	si,IBM_DISK_IO				
 10918 00002FC1 29F1                    		sub	cx,si		;size of AT ROM FIX module
 10919 00002FC3 89C7                    		mov	di,ax		;destination	
 10920 00002FC5 F3A4                    		rep	movsb		;relocate it
 10921 00002FC7 89F8                    		mov	ax,di		;new ending address
 10922 00002FC9 E88800                  		call	Get_Para_Offset ;in AX			
 10923                                  CheckCMOSClock: 						
 10924 00002FCC 0E                      		push	cs						
 10925 00002FCD 07                      		pop	es		 ;set ES to CODE seg	
 10926 00002FCE 803E[7405]01            		cmp	byte [HaveCMOSClock],1 ;CMOS Clock exists?	
 10927 00002FD3 7528                    		jne	short CheckK09	
 10928                                  		
 10929 00002FD5 A3[8505]                		mov	[DaycntToDay],ax ;set the address for MSCLOCK
 10930 00002FD8 B9[9829]                		mov	cx,EndDaycntToDay			
 10931 00002FDB BE[C628]                		mov	si,Daycnt_To_Day				 
 10932 00002FDE 29F1                    		sub	cx,si		;size of CMOS clock sub routine 
 10933 00002FE0 89C7                    		mov	di,ax							  
 10934 00002FE2 F3A4                    		rep	movsb							
 10935 00002FE4 89F8                    		mov	ax,di						
 10936 00002FE6 E86B00                  		call	Get_Para_Offset 					 
 10937 00002FE9 A3[8305]                		mov	[BinToBCD],ax	;set the address for MSCLOCK
 10938 00002FEC B9[A729]                		mov	cx,EndCMOSClockSet				
 10939 00002FEF BE[9829]                		mov	si,Bin_To_BCD				
 10940 00002FF2 29F1                    		sub	cx,si							
 10941 00002FF4 89C7                    		mov	di,ax							
 10942 00002FF6 F3A4                    		rep	movsb							
 10943 00002FF8 89F8                    		mov	ax,di							
 10944 00002FFA E85700                  		call	Get_Para_Offset 					
 10945                                  CheckK09:	
 10946 00002FFD 50                      		push	ax		;save ax	     		
 10947 00002FFE B80041                  		mov	ax,4100h	;Q: is it a K09 	     
 10948 00003001 B300                    		mov	bl,0		;
 10949                                  		;xor	bl,bl			  
 10950 00003003 CD15                    		int	15h		;			   
 10951 00003005 58                      		pop	ax						
 10952 00003006 722C                    		jc	short ConfigDone
 10953                                  								
 10954 00003008 BE[A829]                		mov	si,INT6C				
 10955 0000300B B9[722B]                		mov	cx,ENDK09					
 10956 0000300E 29F1                    		sub	cx,si		;size of K09 routine
 10957 00003010 89C7                    		mov	di,ax							
 10958 00003012 57                      		push	di		;save destination		
 10959 00003013 F3A4                    		rep	movsb							
 10960 00003015 89F8                    		mov	ax,di					
 10961 00003017 E83A00                  		call	Get_Para_Offset ;AX = new ending address	
 10962 0000301A 5F                      		pop	di							
 10963                                  		
 10964 0000301B 50                      		push	ax							 
 10965 0000301C 1E                      		push	ds							
 10966 0000301D C606[1301]01            		mov	byte [fHaveK09],1 ;remember we have a K09 type	
 10967 00003022 31C0                    		xor	ax,ax							
 10968 00003024 8ED8                    		mov	ds,ax
 10969 00003026 31C9                    		xor	cx,cx
 10970 00003028 8ED9                    		mov	ds,cx							
 10971 0000302A 893EB001                		mov	[4*6Ch],di	;new INT 6Ch handler	
 10972 0000302E 8C0EB201                		mov	[4*6Ch+2],cs					
 10973 00003032 1F                      		pop	ds							
 10974 00003033 58                      		pop	ax		;restore the ending address	
 10975                                  ;
 10976                                  ; Set up config stuff for SYSINIT
 10977                                  ;
 10978                                  ConfigDone:
 10979                                  		; 03/06/2018 - Retro DOS v3.0	
 10980                                  		;; 07/04/2018
 10981                                  		;MOV	AX,END_OF_HD2P_TBL
 10982                                  		; 06/04/2018
 10983                                  		;MOV	AX,INIT
 10984 00003034 83C00F                  		ADD	AX,15
 10985                                  		;SHR	AX,1
 10986 00003037 D1D8                    		RCR	AX,1
 10987 00003039 D1E8                    		SHR	AX,1
 10988 0000303B D1E8                    		SHR	AX,1
 10989 0000303D D1E8                    		SHR	AX,1
 10990 0000303F 83C070                  		ADD	AX,KERNEL_SEGMENT
 10991                                  		;MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
 10992                                  		; 05/07/2018
 10993 00003042 A3[3A39]                		MOV	[SYSINIT+FINAL_DOS_LOCATION],AX
 10994                                  
 10995                                  		; 05/07/2019
 10996                                  		;POP	AX ; !@
 10997                                  
 10998                                  		; 03/06/2018
 10999                                  		; 19/03/2018
 11000 00003045 B9E079                  		mov	cx,msdos_bin_size+1
 11001 00003048 D1E9                    		shr	cx,1
 11002                                  		;mov	[SYSINIT_START+DOSSIZE],cx ; DOS size in words
 11003                                  		; 05/07/2018
 11004 0000304A 890E[4039]              		mov	[SYSINIT+DOSSIZE],cx
 11005                                  
 11006                                  		; 19/07/2019 - Retro DOS v3.2
 11007                                  
 11008                                  		; 03/06/2018
 11009                                  		;CMP	BYTE [fHave96],0
 11010                                  		;JNZ	SHORT ReadDos
 11011                                  
 11012                                  		; 17/07/2019
 11013                                  		;;call	PURGE_96TPI	;mjb001 eliminate calls to 96tpi hoohah
 11014                                  
 11015                                  		; 17/07/2019 - Retro DOS v3.2
 11016                                  		; Eliminate calls to 96tpi
 11017                                  		; (es=ds=cs)
 11018                                  		;mov	di,TABLE_PATCH
 11019                                  		;MOV	AX,EXIT
 11020                                  		;STOSW
 11021                                  		;STOSW
 11022                                  ;ReadDos:
 11023                                  		; 06/07/2019
 11024                                  
 11025                                  		; 19/03/2018 (*) No need to read remain clusters of
 11026                                  		; MSDOS kernel because of Retro DOS v2.0 boot sector
 11027                                  		; has loaded all of the kernel file before.
 11028                                  		; ;("MSINIT.ASM" contains kernel file reading code here...)  
 11029                                  
 11030                                  		; 30/03/2018
 11031                                  		;mov	ax,[DRVFAT]
 11032                                  		;call	SETDRIVE
 11033                                  		;call	GETBP
 11034                                  		
 11035                                  		; 24/02/2018 - Retro DOS 2.0 - MSDOS 3.3 ("MSINIT.ASM")
 11036                                  
 11037 0000304E E8E403                  		CALL	SETDRVPARMS
 11038                                  		
 11039                                  		; 06/07/2018
 11040                                  		
 11041                                  		; 03/06/2018 - Retro DOS v3.0
 11042                                  		;JMP	SYSINIT
 11043                                  		; 05/07/2018
 11044 00003051 E95306                  		jmp	_SYSINIT ; GOINIT
 11045                                  
 11046                                  ;-----------------------------------------------------------------------------
 11047                                  ; 03/06/2018 - Retro DOS v3.0
 11048                                  
 11049                                  Get_Para_Offset:
 11050                                  ;in:  AX - offset value
 11051                                  ;out: AX - offset value adjusted for the next paragraph boundary.
 11052 00003054 83C00F                  		add	ax, 15		;make a paragraph
 11053 00003057 D1D8                    		rcr	ax, 1	
 11054 00003059 D1E8                    		shr	ax, 1	
 11055 0000305B D1E8                    		shr	ax, 1
 11056 0000305D D1E8                    		shr	ax, 1
 11057 0000305F D1E0                    		shl	ax, 1		;now, make it back to offset value
 11058 00003061 D1E0                    		shl	ax, 1
 11059 00003063 D1E0                    		shl	ax, 1
 11060 00003065 D1E0                    		shl	ax, 1
 11061 00003067 C3                      		retn
 11062                                  
 11063                                  ; 01/07/2018
 11064                                  ;;
 11065                                  ;;	READ A FAT SECTOR INTO fat location
 11066                                  ;;
 11067                                  ;GETFAT:
 11068                                  ;		XOR	DI,DI			; offset
 11069                                  ;		MOV	DX,1			; relative sector (1st sector of fat)
 11070                                  ;		MOV	CX,[FatLen]		; read entire fat.
 11071                                  ;		MOV	AX,[FatLoc]		;
 11072                                  ;		MOV	ES,AX			; location to read
 11073                                  ;		MOV	AX,[DRVFAT]		; AH FAT ID byte, AL drive
 11074                                  ;		JMP	DISKRD
 11075                                  
 11076                                  ; 17/07/2019 - Retro DOS v3.2
 11077                                  
 11078                                  ;******************************************************************************
 11079                                  ; module name: remap
 11080                                  ;
 11081                                  ; descriptive name: all the code for himem that could be separated from msbio
 11082                                  ;
 11083                                  ; function:  remap the bds chain to adjusted logical drive numbers (drive
 11084                                  ;	     letters if more than two diskette drives on the system.
 11085                                  ;
 11086                                  ;     scheme:  if more than 2 disktte drives, first map the bds structure
 11087                                  ;	       as usual and then rescan the bds chain to adjust the drive
 11088                                  ;	       letters. to do this, scan for disk drives and assign logical
 11089                                  ;	       drive number starting from 2 and then rescan diskette drives
 11090                                  ;	       and assign next to the last logical drive number of last disk
 11091                                  ;	       drive to the 3rd and 4th diskette drives.
 11092                                  ;
 11093                                  ; input:       none
 11094                                  ; exit:	drive letters have been remapped in bds chain
 11095                                  ; exit error:	none
 11096                                  ; called from: msinit
 11097                                  ;
 11098                                  ; notes:  this function  will be called only if more than 2 diskettes are
 11099                                  ;	  found in the system
 11100                                  ;	  this function assumes that there are no more than 26 drives assigned
 11101                                  ;	    this is guaranteed by the code that creates bdss for partitions
 11102                                  ;	  this function assumes that the first entries in the chain are
 11103                                  ;	   floppy drives, and all the rest are hard drives
 11104                                  ;	  will alter the boot drive if necessary to reflect remapping
 11105                                  ;
 11106                                  ;******************************************************************************
 11107                                  
 11108                                  remap:
 11109                                  		;mov	di,[cs:START_BDS]
 11110 00003068 8B3E[9A01]              		mov	di,[START_BDS]	; get first bds
 11111                                  
 11112                                  ; search for 1st fixed disk physical drive num
 11113                                  
 11114                                  drive_loop:
 11115 0000306C 807D0480                		cmp	byte [di+BDS.drivenum],80h  ; first hard disk??
 11116 00003070 7409                    		je	short fdrv_found       ; yes, continue
 11117                                  
 11118                                  		;mov	di,[di+BDS.link] ; get next bds, assume segment
 11119 00003072 8B3D                    		mov	di,[di]
 11120 00003074 83FFFF                  		cmp	di,-1		; last bds?
 11121 00003077 75F3                    		jne	short drive_loop ; loop if not
 11122                                  
 11123 00003079 EB43                    		jmp	short rmap_exit	; yes, no hard drive on system
 11124                                  
 11125                                  ;------------------------------------------------------------------------------
 11126                                  ;first disk drive bds, now change the logical drive num to 2 and the subsequent
 11127                                  ;logical drive nums to 3, 4, 5 etc.
 11128                                  ;------------------------------------------------------------------------------
 11129                                  
 11130                                  fdrv_found:
 11131 0000307B B002                    		mov	al,2		; start with logical drv num=2
 11132                                  fdrv_loop:
 11133 0000307D 884505                  		mov	[di+BDS.drivelet],al ; found ??
 11134                                  		;mov	di,[di+BDS.link] ; ds:di--> next bds
 11135 00003080 8B3D                    		mov	di,[di]
 11136 00003082 FEC0                    		inc	al		; set num for next drive
 11137                                  
 11138 00003084 83FFFF                  		cmp	di,-1		; last hard drive ??
 11139 00003087 75F4                    		jne	short fdrv_loop	; no - assign more disk drives
 11140                                  
 11141                                  ;------------------------------------------------------------------------------
 11142                                  ; now, rescan and find bds of 3rd floppy drive and assign next drive letter
 11143                                  ; in al to 3rd. if the current drive letter is past z, then do not allocate
 11144                                  ; any more.
 11145                                  ;------------------------------------------------------------------------------
 11146                                  
 11147                                  		;mov	di,[cs:START_BDS]
 11148 00003089 8B3E[9A01]              		mov   	di,[START_BDS]	; get first bds
 11149                                  		;mov   	di,[di+BDS.link] ; ds:di-->bds2
 11150 0000308D 8B3D                    		mov	di,[di]
 11151                                  		;mov	ah,[cs:dsktnum]
 11152 0000308F 8A26[A601]              		mov   	ah,[dsktnum]	; get number of floppies to remap
 11153                                  		; ah > 2
 11154 00003093 80EC02                  		sub   	ah,2		; adjust for a: & b:
 11155                                  remap_loop1:
 11156                                  		;mov	di,[di+BDS.link] ; ds:di -> bds to change
 11157 00003096 8B3D                    		mov	di,[di]
 11158 00003098 884505                  		mov	[di+BDS.drivelet],al ; set new num to next floppy
 11159 0000309B FEC0                    		inc	al		; new number for next floppy
 11160 0000309D FECC                    		dec	ah		; count down extra floppies
 11161 0000309F 75F5                    		jnz	short remap_loop1 ; and loop until we got 'em all
 11162                                  
 11163                                  ;	now we've got to adjust the boot drive if we reassigned it
 11164                                  
 11165                                  		;mov	al,[cs:DRVFAT]
 11166 000030A1 A0[722B]                		mov	al,[DRVFAT]
 11167 000030A4 3C02                    		cmp	al,2		; is it a: or b:
 11168 000030A6 7216                    		jb	short rmap_exit
 11169                                  
 11170                                  		;sub	al,[c:dsktnum]
 11171 000030A8 2A06[A601]              		sub	al,[dsktnum]	; is it one of the other floppies?
 11172 000030AC 7204                    		jb	short remap_boot_flop ; brif so
 11173                                  
 11174                                  ;	we've got to remap the boot hard drive
 11175                                  ;	  subtract the number of EXTRA floppies from it
 11176                                  
 11177 000030AE 0402                    		add	al,2		; bootdrv -= (dsktnum-2)
 11178 000030B0 EB04                    		jmp	short remap_change_boot_drv
 11179                                  
 11180                                  ;	we've got to remap the boot floppy.
 11181                                  ;	  add the number of hard drive partitions to it
 11182                                  
 11183                                  remap_boot_flop:
 11184                                  		;add	al,[cs:DRVMAX]
 11185 000030B2 0206[1001]              		add	al,[DRVMAX]	; bootdrv += (drvmax-dsktnum)
 11186                                  remap_change_boot_drv:
 11187                                  		;mov	[cs:DRVFAT],al
 11188 000030B6 A2[722B]                		mov	[DRVFAT],al	; alter msdos.sys load drive
 11189 000030B9 FEC0                    		inc	al
 11190                                  
 11191                                  		;push	ds
 11192                                  		;mov	di,SYSINIT_SEG ; 11/05/2019
 11193                                  		;mov	ds,di
 11194                                  		;mov	[DEFAULT_DRIVE],al
 11195 000030BB A2[5039]                		mov	[SYSINIT+DEFAULT_DRIVE],al ; pass it to sysinit as well
 11196                                  		;pop	ds
 11197                                  rmap_exit:
 11198 000030BE C3                      		retn
 11199                                  
 11200                                  ; 02/06/2018 - Retro DOS v3.0	
 11201                                  ; 19/03/2018 - Retro DOS v2.0
 11202                                  
 11203                                  ;	READ A BOOT RECORD INTO 7C0h:BootBias
 11204                                  ;  GetBoot reads the boot record into 7C0h:BootBias
 11205                                  ;  On Entry:
 11206                                  ;	DL contains ROM drive number (80h or 81h)
 11207                                  ;  On Exit:
 11208                                  ;	if carry set error
 11209                                  ;	if carry clear:
 11210                                  ;	   ES:BX piont to boot sector
 11211                                  ;	AX and CX are not preserved
 11212                                  ;	BX and ES are used to return values
 11213                                  ;
 11214                                  GETBOOT:
 11215                                  		; 08/04/2018
 11216                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
 11217                                  
 11218                                  		;mov	AX,07C0h     ; prepare to load ES
 11219                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991	
 11220                                  		;mov	ax,[cs:init_bootseg]
 11221 000030BF A1[FD2B]                		mov	ax,[init_bootseg]
 11222 000030C2 8EC0                    		mov	ES,AX	     ; load ES segment register
 11223 000030C4 BB0002                  		mov	BX,BootBias  ; load BX, ES:BX is where sector goes
 11224 000030C7 B80102                  		mov	AX,0201h     ; command to read & num sec. to 1
 11225 000030CA 30F6                    		xor	DH,DH	     ; head number zero
 11226 000030CC B90100                  		mov	CX,0001h     ; cylinder zero and sector one
 11227 000030CF CD13                    		int	13h	     ; call rom bios
 11228 000030D1 720A                    		jc	short ERRET
 11229 000030D3 26813EFE0355AA          		cmp	word [ES:BootBias+1FEh],0AA55h ; DAVE LITTON MAGIC WORD?
 11230 000030DA 7401                    		je	short Norm_Ret
 11231 000030DC F9                      		stc
 11232                                  ERRET:
 11233                                  Norm_Ret:
 11234 000030DD C3                      		RETN
 11235                                  
 11236                                  ;***************************************************************************
 11237                                  ;   sethard - generate bpb for a variable sized hard file. ibm has a
 11238                                  ;   partitioned hard file; we must read physical sector 0 to determine where
 11239                                  ;   our own logical sectors start. we also read in our boot sector to
 11240                                  ;   determine version number
 11241                                  ;
 11242                                  ;   inputs:	dl is rom drive number (80...)
 11243                                  ;		bh is partition number (0....) 
 11244                                  ;		ds:di points to bds
 11245                                  ;   outputs:	carry clear -> bpb is filled in
 11246                                  ;		carry set   -> bpb is left uninitialized due to error
 11247                                  ;	trashes (at least) si, cx
 11248                                  ;	MUST PRESERVE ES:!!!!
 11249                                  ;***************************************************************************
 11250                                  
 11251                                  SETHARD:
 11252                                  		; 15/07/2019 - Retro DOS v3.2
 11253                                  		; 28/12/2018 - Retro DOS v4.0
 11254                                  		; 03/06/2018 - Retro DOS v3.0
 11255                                  		; (20/03/2018 - Retro DOS v2.0)
 11256                                  
 11257 000030DE 57                      		push	di
 11258 000030DF 53                      		push	bx
 11259 000030E0 1E                      		push	ds
 11260 000030E1 06                      		push	es ;*
 11261                                  
 11262 000030E2 885D05                  		mov	[di+BDS.drivelet],bl
 11263 000030E5 885504                  		mov	[di+BDS.drivenum],dl
 11264 000030E8 804D2301                		or	byte [di+BDS.flags],fNon_Removable
 11265 000030EC C6452205                		mov	byte [di+BDS.formfactor],ffHardFile
 11266 000030F0 C606[742B]00            		mov	byte [fBigFAT],0 ; assume 12 bit FAT
 11267 000030F5 88FE                    		mov	dh,bh		; partition number
 11268 000030F7 52                      		push	dx
 11269 000030F8 B408                    		mov	ah,8		; set command to get drive parameters
 11270 000030FA CD13                    		int	13h		; call rom-bios disk routine
 11271                                  
 11272                                  		; dh is number of heads-1
 11273                                  		; dl is number of hard disks attached
 11274                                  		; low 6 bits of cl is sectors/track
 11275                                  		; high 2 bits of cl with ch are max # of cylinders
 11276                                  
 11277 000030FC FEC6                    		inc	dh		; get number of heads
 11278 000030FE 887515                  		mov	[di+BDS.heads],dh
 11279 00003101 5A                      		pop	dx
 11280 00003102 7263                    		jc	short setret	; error if no hard disk
 11281 00003104 80E13F                  		and	cl,3Fh		; extract number of sectors/track
 11282 00003107 884D13                  		mov	[di+BDS.secpertrack],cl
 11283 0000310A 52                      		push	dx		; save partition number
 11284 0000310B E8B1FF                  		call	GETBOOT		;   if (getBoot ())
 11285 0000310E 5A                      		pop	dx		; restore partition number
 11286 0000310F 7256                    		jc	short setret	;	return -1;
 11287                                  	
 11288                                  		; es = [init_bootseg] ; 16/07/2019
 11289                                  
 11290 00003111 BBC203                  		mov	bx,1C2h+BootBias ; p = &boot[0x1C2];
 11291                                  
 11292                                  ; The first 'active' partition is 00, the second is 01....
 11293                                  ;   then the remainder of the 'primary' but non-active partitions
 11294                                  
 11295                                  act_part:
 11296 00003114 26F647FC80              		test	byte [es:bx-4],80h  ;AN016;is the partition active?
 11297 00003119 7418                    		jz	short not_act
 11298                                  
 11299 0000311B 26803F01                		cmp	byte [es:bx],1	; reject if partitiontype != 1, 4 or 6
 11300 0000311F 740C                    		je	short got_good_act
 11301 00003121 26803F04                		cmp	byte [es:bx],4
 11302 00003125 7406                    		je	short got_good_act
 11303 00003127 26803F06                		cmp	byte [es:bx],6
 11304 0000312B 7506                    		jne	short not_act	; reject!
 11305                                  got_good_act:
 11306 0000312D 08F6                    		or	dh,dh		; is this our target partition #?
 11307 0000312F 745D                    		jz	short set2	; WE GOT THE ONE WANTED!!
 11308 00003131 FECE                    		dec	dh		; count down
 11309                                  not_act:
 11310 00003133 83C310                  		add	bx,16		; next entry
 11311 00003136 81FB0204                		cmp	bx,202h + BootBias ; last entry done?
 11312 0000313A 75D8                    		jne	short act_part	; no,process next entry
 11313                                  
 11314                                  ; Now scan the non-active partitions
 11315                                  
 11316 0000313C BBC203                  		mov	bx,1C2h+BootBias ; restore original value of bx
 11317                                  get_primary:
 11318 0000313F 26F647FC80              		test	byte [es:bx-4],80h ; we've already scanned
 11319 00003144 7518                    		jnz	short not_prim	; the ACTIVE ones
 11320                                  		
 11321 00003146 26803F01                		cmp	byte [es:bx],1	; see if partitiontype == 1, 4 or 6
 11322 0000314A 740C                    		je	short got_prim
 11323 0000314C 26803F04                		cmp	byte [es:bx],4
 11324 00003150 7406                    		je	short got_prim
 11325 00003152 26803F06                		cmp	byte [es:bx],6
 11326 00003156 7506                    		jne	short not_prim
 11327                                  got_prim:
 11328 00003158 08F6                    		or	dh,dh		; is this our target partition?
 11329 0000315A 7432                    		jz	short set2
 11330 0000315C FECE                    		dec	dh
 11331                                  not_prim:
 11332 0000315E 83C310                  		add	bx,16
 11333 00003161 81FB0204                		cmp	bx,202h+BootBias
 11334 00003165 75D8                    		jne	short get_primary ; loop till we've gone through table
 11335                                  setret:
 11336                                  		;stc			; error return
 11337                                  		;jmp	ret_hard
 11338                                  		; 15/07/2019
 11339 00003167 EB1F                    		jmp	short ret_hard_err
 11340                                  
 11341                                  ; 10/07/2019 - Retro DOS v3.2
 11342                                  ;--------------------------------------------------------------------
 11343                                  ; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21)
 11344                                  
 11345                                  SetMini:	; 'setmini' is called from 'find_mini_partition' procedure
 11346                                  
 11347 00003169 57                      		push	di
 11348 0000316A 53                      		push	bx
 11349 0000316B 1E                      		push	ds
 11350 0000316C 06                      		push	es ;*		; match stack for standard exit
 11351                                  setmini_1:
 11352 0000316D 26803F01                		cmp	byte [es:bx],1	; FAT12 partition
 11353 00003171 741B                    		je	short setmini_2
 11354                                  
 11355 00003173 26803F04                		cmp	byte [es:bx],4	; FAT16 partition
 11356 00003177 7415                    		je	short setmini_2
 11357                                  
 11358 00003179 26803F06                		cmp	byte [es:bx],6	; FAT16 BIG partition
 11359 0000317D 740F                    		je	short setmini_2
 11360                                  
 11361 0000317F 83C310                  		add	bx,16
 11362 00003182 81FB0204                		cmp	bx,202h+BootBias
 11363 00003186 75E5                    		jne	short setmini_1
 11364                                  ret_hard_err:
 11365 00003188 F9                      		stc
 11366                                  ret_hard: 	; 15/07/2019
 11367 00003189 07                      		pop	es ;*
 11368 0000318A 1F                      		pop	ds
 11369 0000318B 5B                      		pop	bx
 11370 0000318C 5F                      		pop	di	
 11371 0000318D C3                      		retn
 11372                                  
 11373                                  setmini_2:
 11374                                  		;jmp	short set2	; branch into middle of sethard
 11375                                  ;--------------------------------------------------------------------
 11376                                  
 11377                                  ;  until we get the real logical boot record and get the bpb,
 11378                                  ;  BDS_BPB.BPB_BIGTOTALSECTORS will be used instead of BDS_BPB.BPB_TOTALSECTORS for the
 11379                                  ;  convenience of the computation.
 11380                                  ;
 11381                                  ;  at the end of this procedure, if a bpb information is gotten from
 11382                                  ;  the valid boot record, then we are going to use those bpb information
 11383                                  ;  without change.
 11384                                  ;
 11385                                  ;  otherwise, if (hidden sectors + total sectors) <= a word, then
 11386                                  ;  we will move BDS_BPB.BPB_BIGTOTALSECTORS (low) to BDS_BPB.BPB_TOTALSECTORS and zero out
 11387                                  ;  BDS_BPB.BPB_BIGTOTALSECTORS entry to make
 11388                                  ;  it a conventional bpb format.
 11389                                  
 11390                                  set2:
 11391                                  		;mov	[cs:rom_drv_num],dl
 11392                                  			; save the rom bios drive number we are handling now.
 11393 0000318E 8816[752B]              		mov	[rom_drv_num],dl
 11394                                  
 11395 00003192 268B4704                		mov	ax,[es:bx+4]	; hidden sectors
 11396 00003196 268B5706                		mov	dx,[es:bx+6]
 11397                                  
 11398                                  ;  decrement the sector count by 1 to make it zero based. exactly 64k
 11399                                  ;   sectors should be allowed	 
 11400                                  				 
 11401 0000319A 83E801                  		sub	ax,1
 11402 0000319D 83DA00                  		sbb	dx,0
 11403                                  
 11404 000031A0 26034708                		add	ax,[es:bx+8]	; sectors in partition
 11405 000031A4 2613570A                		adc	dx,[es:bx+10]
 11406 000031A8 7305                    		jnc	short okdrive
 11407 000031AA 800E[742B]80            		or	byte [fBigFAT],fTOOBIG  ; 80h
 11408                                  okdrive:
 11409 000031AF 268B4704                		mov	ax,[es:bx+4]
 11410 000031B3 894517                  		mov	[di+BDS.hiddensecs],ax	; BPB_HIDDENSECTORS = p->partitionbegin;
 11411 000031B6 268B4706                		mov	ax,[es:bx+6]
 11412 000031BA 894519                  		mov	[di+BDS.hiddensecs+2],ax
 11413                                  
 11414 000031BD 268B570A                		mov	dx,[es:bx+10]	; # of sectors (high)
 11415 000031C1 268B4708                		mov	ax,[es:bx+8]	; # of sectors (low)
 11416 000031C5 89551D                  		mov	[di+BDS.totalsecs32+2],dx
 11417 000031C8 89451B                  		mov	[di+BDS.totalsecs32],ax ;   bpb->maxsec = p->partitionlength;
 11418                                  	
 11419                                  		;cmp	dx,0
 11420                                  		;ja	short okdrive_1
 11421                                  
 11422 000031CB 21D2                    		and	dx,dx
 11423 000031CD 7505                    		jnz	short okdrive_1
 11424                                  
 11425 000031CF 83F840                  		cmp	ax,64		; if (p->partitionlength < 64)
 11426                                  		;jb	short setret	;	return -1;
 11427                                  		; 16/07/2019
 11428                                  		;;jb	short ret_hard_err
 11429                                  		;jnb	short okdrive_1
 11430                                  ;setret_brdg:
 11431                                  ;		jmp	short ret_hard_err
 11432                                  		; 28/07/2019
 11433 000031D2 72B5                    		jb	short ret_hard ; ret_hard_err
 11434                                  okdrive_1:
 11435 000031D4 8B5519                  		mov	dx,[di+BDS.hiddensecs+2] ; mov dx,[di+25]
 11436 000031D7 8B4517                  		mov	ax,[di+BDS.hiddensecs]	; boot sector number - for mini disk,;j.k.
 11437 000031DA 31DB                    		xor	bx,bx			; usually equal to the # of sec/trk.  ;j.k.
 11438 000031DC 8A5D13                  		mov	bl,[di+BDS.secpertrack]
 11439 000031DF 50                      		push	ax
 11440 000031E0 89D0                    		mov	ax,dx
 11441 000031E2 31D2                    		xor	dx,dx
 11442 000031E4 F7F3                    		div	bx
 11443                                  		;mov	[cs:temp_h],ax
 11444 000031E6 A3[A605]                		mov	[temp_h],ax
 11445 000031E9 58                      		pop	ax
 11446 000031EA F7F3                    		div	bx	;(sectors)dx;ax / (BDS_BPB.BPB_SECTORSPERTRACK)bx =(track) temp_h;ax + (sector)dx
 11447 000031EC 88D1                    		mov	cl,dl	; cl is sector number;j.k.assume sector number < 255.
 11448 000031EE FEC1                    		inc	cl	; sectors are 1 based
 11449 000031F0 31DB                    		xor	bx,bx
 11450 000031F2 8A5D15                  		mov	bl,[di+BDS.heads]
 11451 000031F5 50                      		push	ax
 11452 000031F6 31D2                    		xor	dx,dx
 11453                                  		;mov	ax,[cs:temp_h]
 11454 000031F8 A1[A605]                		mov	ax,[temp_h]
 11455 000031FB F7F3                    		div	bx
 11456                                  		;mov	cs:[temp_h],ax
 11457 000031FD A3[A605]                		mov	[temp_h],ax
 11458 00003200 58                      		pop	ax
 11459 00003201 F7F3                    		div	bx		; dl is head, ax is cylinder
 11460                                  		;cmp	word [cs:temp_h],0
 11461 00003203 833E[A605]00            		cmp	word [temp_h],0
 11462                                  		;ja	setret_brdg ; exceeds the limit of int 13h
 11463 00003208 7705                    		ja	short setret_brdg ; 11/05/2019
 11464 0000320A 3D0004                  		cmp	ax,1024
 11465                                  		;ja	setret_brdg ; exceeds the limit of int 13h
 11466                                  		; 28/07/2019
 11467                                  		;jna	short okdrive_2  ; !? wrong! (10 bit cylinder number problem!)
 11468                                  			; Retro DOS v3.2 note by Erdogan Tan - 28/07/2019
 11469                                  			; **MSDOS code accepts if ax = 1024 but it is nonsense here!**
 11470 0000320D 7203                    		jb	short okdrive_2 ; cylinder number must be <= 1023 (10 bits)
 11471                                  setret_brdg:	
 11472 0000320F E976FF                  		jmp	ret_hard_err
 11473                                  okdrive_2:
 11474                                  		; 28/07/2019
 11475                                  ; dl is head.
 11476                                  ; ax is cylinder
 11477                                  ; cl is sector number (assume less than 2**6 = 64 for int 13h)
 11478                                  
 11479                                  ;*** for mini disks ***
 11480                                  		;cmp	word [di+BDS.bdsm_ismini],1 ;check for mini disk
 11481 00003212 807D4701                		cmp	byte [di+BDS.bdsm_ismini],1 ; 28/07/2019
 11482 00003216 7503                    		jne	short oknotmini		;not mini disk.
 11483 00003218 034549                  		add	ax,[di+BDS.bdsm_hidden_trks] ;set the physical track number
 11484                                  oknotmini:
 11485                                  ;*** end of added logic for mini disk
 11486                                  
 11487 0000321B D0CC                    		ror	ah,1		; move high two bits of cyl to high
 11488 0000321D D0CC                    		ror	ah,1		; two bits of upper byte
 11489 0000321F 80E4C0                  		and	ah,0C0h 	; turn off remainder of bits
 11490 00003222 08E1                    		or	cl,ah		; move two bits to correct spot
 11491 00003224 88C5                    		mov	ch,al		; ch is cylinder
 11492                                  
 11493                                  ; cl is sector + 2 high bits of cylinder
 11494                                  ; ch is low 8 bits of cylinder
 11495                                  ; dl is head
 11496                                  ; rom_drv_num is drive
 11497                                  
 11498 00003226 88D6                    		mov	dh,dl		; dh is head
 11499                                  		;mov	dl,[cs:rom_drv_num] ; set the drive number
 11500 00003228 8A16[752B]              		mov	dl,[rom_drv_num]
 11501                                  
 11502                                  ; cl is sector + 2 high bits of cylinder
 11503                                  ; ch is low 8 bits of cylinder
 11504                                  ; dh is head
 11505                                  ; dl is drive
 11506                                  
 11507                                  ; for convenience, we are going to read the logical boot sector
 11508                                  ;   into cs:disksector area.
 11509                                  
 11510                                  ;  read in boot sector using bios disk interrupt. the buffer where it
 11511                                  ;  is to be read in is cs:disksector.
 11512                                  
 11513                                  		; es = [init_bootseg] ; 16/07/2019
 11514                                  
 11515                                  		;push	cs
 11516 0000322C 1E                      		push	ds ; 29/12/2018 (ds = cs)
 11517 0000322D 07                      		pop	es
 11518                                  
 11519 0000322E BB[D001]                		mov	bx,DiskSector
 11520                                  
 11521 00003231 B80102                  		mov	ax,201h		; read, one sector
 11522 00003234 CD13                    		int	13h
 11523                                  
 11524                                  ; cs:disksec contains the boot sector. in theory, (ha ha) the bpb in this thing
 11525                                  ; is correct. we can, therefore, suck out all the relevant statistics on the
 11526                                  ; media if we recognize the version number.
 11527                                  
 11528                                  		; 16/07/2019
 11529                                  		;mov	bx,DiskSector
 11530                                  
 11531                                  		; bx = DiskSector
 11532                                  
 11533                                  		; 16/07/2019 - Retro DOS v3.2
 11534                                  		;push	bx		; save changed regs
 11535                                  		;push	ax
 11536                                  
 11537                                  	; 29/12/2018 - Retro DOS v4.0
 11538                                  	; es = ds = cs
 11539                                  
 11540 00003236 803FE9                  		cmp	byte [bx],0E9h	; is it a near jump?
 11541 00003239 740B                    		je	short check_1_ok ; no,
 11542                                  
 11543 0000323B 803FEB                  		cmp	byte [bx],0EBh	; is it a short jump?
 11544 0000323E 7523                    		jne	short invalid_boot_record ; no, invalid boot record
 11545 00003240 807F0290                		cmp	byte [bx+2],90h	; yes, is the next one a nop?
 11546 00003244 751D                    		jne	short invalid_boot_record ; no, invalid boot record
 11547                                  check_1_ok:				; yes, jump instruction ok.
 11548                                  					; now check some fields in
 11549                                  					;  the boot record bpb
 11550                                  		;;mov	bx,DiskSector+11 ; 0Bh
 11551                                  		;mov	bx,DiskSector+EXT_BOOT.BPB ; point to the bpb
 11552                                  					;  in the boot record
 11553                                  
 11554                                  					; get the mediadescriptor byte
 11555 00003246 8A4715                  		mov	al,[bx+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
 11556                                  
 11557 00003249 24F0                    		and	al,0F0h 	; mask off low nibble
 11558 0000324B 3CF0                    		cmp	al,0F0h 	; is high nibble = 0Fh?
 11559 0000324D 7514                    		jne	short invalid_boot_record ; no, invalid boot record
 11560                                  
 11561 0000324F 817F0B0002              		cmp	word [bx+EXT_BOOT.BPB+EBPB.BYTESPERSECTOR],512
 11562 00003254 750D                    		jne	short invalid_boot_record ; invalidate non 512 byte sectors
 11563                                  
 11564                                  check_2_ok:				; yes, mediadescriptor ok.
 11565                                  					; now make sure that
 11566                                  					; the sectorspercluster
 11567                                  					; is a power of 2
 11568                                  
 11569                                  					; get the sectorspercluster
 11570                                  
 11571 00003256 8A470D                  		mov	al,[bx+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
 11572                                  
 11573 00003259 08C0                    		or	al,al		; is it zero?
 11574 0000325B 7406                    		jz	short invalid_boot_record ;  yes, invalid boot record
 11575                                  
 11576                                  ck_power_of_two:
 11577 0000325D D0E8                    		shr	al,1		; shift until first bit emerges
 11578 0000325F 73FC                    		jnc	short ck_power_of_two
 11579                                  
 11580 00003261 7403                    		jz	short valid_boot_record	; if no bits left, then proceed ok
 11581                                  
 11582                                  invalid_boot_record:			; for invalid boot record
 11583                                  		;pop	ax		; restore registers
 11584                                  		;pop	bx	;
 11585 00003263 E9F500                  		jmp	unknown 	; jump to invalid boot record
 11586                                  					; unformatted or illegal media.
 11587                                  		; 11/05/2019
 11588                                  ;setret_brdg:
 11589                                  ;		;jmp	setret
 11590                                  ;		; 16/07/2019
 11591                                  ;		jmp	ret_hard_err
 11592                                  
 11593                                  valid_boot_record:			; for valid boot record
 11594                                  		;pop	ax		; restore registers
 11595                                  		;pop	bx	;
 11596                                  
 11597                                  		; bx = DiskSector
 11598                                  
 11599                                  		; 28/07/2019 - Retro DOS v3.2
 11600 00003266 BE[DB01]                		mov	si,DiskSector+EXT_BOOT.BPB
 11601                                  
 11602                                  ; signature found. Now check version.
 11603                                  
 11604                                  	; 29/12/2018 - 	Retro DOS v4.0 modification
 11605                                  	; (If extended boot signature = 29h, skip version check)
 11606                                  
 11607                                  		;cmp	byte [DiskSector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
 11608                                  					 ; disksector+38
 11609                                  		; 16/07/2019
 11610 00003269 807F2629                		cmp	byte [bx+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
 11611 0000326D 7435                    		je	short check_num_of_fats	
 11612                                  					; 29/12/2018 (Retro DOS v4.0 modification)
 11613                                  		; bx = DiskSector
 11614 0000326F 817F08322E              		cmp	word [bx+8],"2."
 11615 00003274 7506                    		jne	short try5
 11616 00003276 807F0A30                		cmp	byte [bx+10],"0"
 11617                                  		;jne	short try5
 11618                                  		;jmp	short copybpb
 11619 0000327A 7428                    		je	short copybpb
 11620                                  ;setret_brdg:
 11621                                  ;		jmp	short setret
 11622                                  ;unknown3_0_j:				; legally formatted media,
 11623                                  ;		jmp	short unknown3_0 ; although, content might be bad.
 11624                                  try5:
 11625 0000327C E88A01                  		call	cover_fdisk_bug
 11626                                  
 11627                                  ; see if it is an os2 signature
 11628                                  
 11629 0000327F 817F08302E              		cmp	word [bx+8],'0.'
 11630 00003284 750F                    		jne	short no_os2
 11631 00003286 8A4707                  		mov	al,[bx+7]
 11632 00003289 2C31                    		sub	al,'1'
 11633 0000328B 24FE                    		and	al,0FEh
 11634 0000328D 7415                    		jz	short copybpb	; accept either '1' or '2'
 11635 0000328F E9C900                  		jmp	unknown
 11636                                  ;setret_brdg:
 11637                                  ;		jmp	setret
 11638                                  unknown3_0_j:				; legally formatted media,
 11639 00003292 E9CA00                  		jmp	unknown3_0	; although, content might be bad.
 11640                                  
 11641                                  ; no os2 signature, this is to check for real dos versions
 11642                                  
 11643                                  no_os2:
 11644 00003295 817F08332E              		cmp	word [bx+8],"3."
 11645 0000329A 72F6                    		jb	short unknown3_0_j 
 11646                                  			; must be 2.1 boot record. do not trust it, but still legal.
 11647                                  		;jne	short copybpb 	; honor os2 boot record, or dos 4.0 version
 11648 0000329C 7706                    		ja	short copybpb
 11649 0000329E 807F0A31                		cmp	byte [bx+10],"1" ; do not trust 3.0 boot record. but still legal
 11650 000032A2 72EE                    		jb	short unknown3_0_j ; if version >= 3.1, then o.k.
 11651                                  copybpb:
 11652                                  
 11653                                  ; we have a valid boot sector. use the bpb in it to build the
 11654                                  ; bpb in bios. it is assumed that only
 11655                                  ;	BDS_BPB.BPB_SECTORSPERCLUSTER
 11656                                  ;	BDS_BPB.BPB_ROOTENTRIES, and
 11657                                  ;	BDS_BPB.BPB_SECTORSPERFAT
 11658                                  ; need to be set (all other values in already). fbigfat
 11659                                  ; is also set.
 11660                                  
 11661                                  ;if it is non fat based system, then just copy the bpb from the boot sector
 11662                                  ;into the bpb in bds table, and also set the boot serial number, volume id,
 11663                                  ;and system id according to the boot record.
 11664                                  ;for the non_fat system, don't need to set the other value. so just
 11665                                  ;do goodret.
 11666                                  
 11667                                  		;cmp	byte [DiskSector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
 11668                                  					; disksector+38
 11669                                  		;jne	short copybpb_fat
 11670                                  					; conventional fat system
 11671                                  
 11672                                  check_num_of_fats: ; 29/12/2018
 11673                                  
 11674                                  		; 16/07/2019
 11675                                  		;mov	si,DiskSector+EXT_BOOT.BPB ; 28/07/2019
 11676                                  
 11677                                  		;cmp	byte [DiskSector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS],0
 11678                                  					; disksector+16
 11679                                  					  ; if (# of fat <> 0) then
 11680                                  		;jne	short copybpb_fat ;  a fat system.
 11681                                  	
 11682                                  		; 29/12/2018 - Retro DOS v4.0 modification note:
 11683                                  		; Regarding 'fat_big_small' part of this (MSDOS 6.0) code
 11684                                  		;	     number of FATs must be 2 ; =*?=
 11685                                  		; (Otherwise, '# of data sectors' would be calculated as wrong!!!)
 11686                                  		
 11687                                  		;cmp	byte [DiskSector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS],2 ; =*?=
 11688                                  		; 16/07/2019
 11689                                  		;cmp	byte [bx+EXT_BOOT.BPB+EBPB.NUMBEROFFATS],2 ; =*?=
 11690 000032A4 807C0502                		cmp	byte [si+EBPB.NUMBEROFFATS],2 ; =*?=
 11691 000032A8 7433                    		je	short copybpb_fat ;  a fat system.
 11692                                  
 11693                                  ; non fat based media.
 11694                                  
 11695 000032AA 57                      		push	di		; save registers
 11696                                  		;push	ds
 11697                                  
 11698                                  		;push	ds
 11699                                  		;pop	es		; now es:di -> bds
 11700                                  		;push	cs
 11701                                  		;pop	ds		; ds = cs
 11702                                  
 11703                                  		; 16/07/2019
 11704                                  		;mov	si,DiskSector+EXT_BOOT.BPB ; ds:si -> bpb in boot
 11705                                  
 11706                                  		;add	di,BDS.BPB		; es:di -> bpb in bds
 11707                                  
 11708                                  ; just for completeness, we'll make sure that total_sectors and
 11709                                  ; big_total_sectors aren't both zero. I've seen examples of
 11710                                  ; this on DOS 3.30 boot records. I don't know exactly how it
 11711                                  ; got that way. If it occurs, then use the values from the
 11712                                  ; partition table.
 11713                                  
 11714 000032AB 31C0                    		xor	ax,ax ; 11/05/2019
 11715                                  		;cmp	word [si+EBPB.TOTALSECTORS],0 ; is total_sectors nonzero?
 11716 000032AD 394408                  		cmp	[si+EBPB.TOTALSECTORS],ax ; 11/05/2019  
 11717 000032B0 751C                    		jne	short already_nonz	; done if so, use it
 11718                                  		;cmp	word [si+EBPB.BIGTOTALSECTORS],0 ; how 'bout big_total?
 11719 000032B2 394415                  		cmp	[si+EBPB.BIGTOTALSECTORS],ax ; 11/05/2019
 11720 000032B5 7517                    		jne	short already_nonz	; we're okay if any are != 0
 11721                                  		;cmp	word [si+EBPB.BIGTOTALSECTORS+2],0
 11722 000032B7 394417                  		cmp	[si+EBPB.BIGTOTALSECTORS+2],ax ; 11/05/2019
 11723 000032BA 7512                    		jne	short already_nonz
 11724                                  
 11725                                  ; now let's copy the values from the partition table (now in the BDS)
 11726                                  ; into the BPB in the boot sector buffer, before they get copied back.
 11727                                  
 11728 000032BC 8B450E                  		mov     ax,[di+BDS.totalsecs16]	; get value from part table
 11729 000032BF 894408                  		mov     [si+EBPB.TOTALSECTORS],ax ; store it into bpb buffer
 11730 000032C2 8B451B                  		mov     ax,[di+BDS.totalsecs32]	; get value from part table
 11731 000032C5 894415                  		mov     [si+EBPB.BIGTOTALSECTORS],ax ; store it into bpb buffer
 11732 000032C8 8B451D                  		mov     ax,[di+BDS.totalsecs32+2] ; get value from part table
 11733 000032CB 894417                  		mov     [si+EBPB.BIGTOTALSECTORS+2],ax ; store it into bpb buffer
 11734                                  already_nonz:
 11735 000032CE 83C706                  		add	di,BDS.BPB ; 29/12/2018
 11736                                  		
 11737 000032D1 B91900                  		mov	cx,A_BPB.size - 6 ; 25	; ****** Use SMALL version!
 11738 000032D4 F3A4                    		rep	movsb
 11739                                  
 11740                                  		;pop	ds		; restore registers
 11741 000032D6 5F                      		pop	di
 11742                                  
 11743                                  		;;mapnew
 11744                                  		;push	es
 11745                                  		;push	ds
 11746                                  		;pop	es
 11747                                  		;push	cs
 11748                                  		;pop	ds	
 11749                                  	
 11750                                  		; 31/05/2019 - Retro DOS v4.0
 11751                                  
 11752                                  		;mov	bp,mov_media_ids ; set volume id, systemid, serial.
 11753                                  		;push	cs		; simulate far call
 11754                                  		;call	call_bios_code
 11755                                  
 11756 000032D7 E8C6D9                  		call	mov_media_ids ; 31/05/2019	
 11757                                  	
 11758                                  		;;unmapnew
 11759                                  		;push	es
 11760                                  		;pop	ds
 11761                                  		;pop	es	
 11762                                  	
 11763 000032DA E92101                  		jmp	goodret   
 11764                                  
 11765                                  copybpb_fat:				;  fat system
 11766                                  
 11767                                  ; ****** cas ---
 11768                                  ; IBM DOS 3.30 doesn't seem to mind that the TOTAL_SECTORS and
 11769                                  ; BIG_TOTAL_SECTORS field in the boot sector are 0000. This
 11770                                  ; happens with some frequency -- perhaps through some OS/2 setup
 11771                                  ; program. We haven't actually been COPYING the TOTAL_SECTORS
 11772                                  ; from the boot sector into the DPB anyway, we've just been using
 11773                                  ; it for calculating the fat size. Pretty scary, huh? For now,
 11774                                  ; we'll go ahead and copy it into the DPB, except in the case
 11775                                  ; that it equals zero, in which case we just use the values in
 11776                                  ; the DPB from the partition table.
 11777                                  
 11778                                  		; 29/12/2018 - Retro DOS v4.0
 11779                                  		; es  = ds = cs
 11780                                  
 11781                                  		;16/07/2019
 11782                                  		;mov	si,DiskSector+EXT_BOOT.BPB ; cs:si -> bpb in boot
 11783 000032DD 31D2                    		xor	dx,dx
 11784 000032DF 8B4408                          	mov     ax,[si+EBPB.TOTALSECTORS] ; get totsec from boot sec
 11785 000032E2 09C0                            	or      ax,ax
 11786 000032E4 7514                            	jnz     short copy_totsec	; if non zero, use that
 11787                                  
 11788 000032E6 8B4415                  		mov     ax,[si+EBPB.BIGTOTALSECTORS] ; get the big version
 11789 000032E9 8B5417                  		mov     dx,[si+EBPB.BIGTOTALSECTORS+2]
 11790 000032EC 89D1                    		mov     cx,dx
 11791 000032EE 09C1                    		or      cx,ax			; see if it is a big zero
 11792                                  		;jz	short totsec_already_set ; screw it. it was bogus.
 11793                                  		; 29/12/2018
 11794 000032F0 7508                    		jnz	short copy_totsec
 11795                                  ;totsec_already_set:
 11796 000032F2 8B451B                  		mov	ax,[di+BDS.totalsecs32]
 11797 000032F5 8B551D                  		mov	dx,[di+BDS.totalsecs32+2]
 11798                                  
 11799 000032F8 EB06                    		jmp	short fat_big_small
 11800                                  copy_totsec:
 11801 000032FA 89451B                  		mov	[di+BDS.totalsecs32],ax	  ; make DPB match
 11802 000032FD 89551D                  		mov	[di+BDS.totalsecs32+2],dx ; boot sec
 11803                                  
 11804                                  		;jmp	short fat_big_small ; 29/12/2018
 11805                                  
 11806                                  ;totsec_already_set:
 11807                                  		;mov	ax,[di+BDS.totalsecs32]
 11808                                  		;mov	dx,[di+BDS.totalsecs32+2]
 11809                                  
 11810                                  fat_big_small:				 ; determine fat entry size.
 11811                                  
 11812                                  ;at this moment dx;ax = total sector number
 11813                                  
 11814                                  ;Do not assume 1 reserved sector. Update the reserved sector field in BDS 
 11815                                  ;from the BPB on the disk
 11816                                  
 11817 00003300 8B5C03                  		mov	bx,[SI+EBPB.RESERVEDSECTORS] ; get #reserved_sectors from BPB
 11818 00003303 895D09                  		mov	[di+BDS.resectors],bx ; update BDS field
 11819 00003306 29D8                    		sub	ax,bx			
 11820 00003308 83DA00                  		sbb	dx,0		; update the count
 11821 0000330B 8B5C0B                  		mov	bx,[si+EBPB.SECTORSPERFAT] ;  bx = sectors/fat
 11822 0000330E 895D11                  		mov	[di+BDS.fatsecs],bx ;  set in bds bpb
 11823 00003311 D1E3                    		shl	bx,1 ; =*?=	; always 2 fats
 11824 00003313 29D8                    		sub	ax,bx		; sub # fat sectors
 11825 00003315 83DA00                  		sbb	dx,0
 11826 00003318 8B5C06                  		mov	bx,[si+EBPB.ROOTENTRIES] ;  # root entries
 11827 0000331B 895D0C                  		mov	[di+BDS.direntries],bx ;  set in bds bpb
 11828                                  
 11829 0000331E B104                    		mov	cl,4
 11830 00003320 D3EB                    		shr	bx,cl		;  div by 16 ents/sector
 11831 00003322 29D8                    		sub	ax,bx		;  sub # dir sectors
 11832 00003324 83DA00                  		sbb	dx,0
 11833                                  					; dx:ax now contains the # of data sectors
 11834 00003327 31C9                    		xor	cx,cx
 11835 00003329 8A4C02                  		mov	cl,[si+EBPB.SECTORSPERCLUSTER]	; sectors per cluster
 11836 0000332C 884D08                  		mov	[di+BDS.secperclus],cl	; set in bios bpb
 11837 0000332F 50                      		push	ax
 11838 00003330 89D0                    		mov	ax,dx
 11839 00003332 31D2                    		xor	dx,dx
 11840 00003334 F7F1                    		div	cx		; cx = sectors per cluster
 11841 00003336 A3[A605]                		mov	[temp_h],ax
 11842 00003339 58                      		pop	ax
 11843 0000333A F7F1                    		div	cx		;  [temp_h]:ax now contains the # clusters.
 11844 0000333C 833E[A605]00            		cmp	word [temp_h],0
 11845 00003341 7710                    		ja	short toobig_ret ;  too big cluster number
 11846                                  
 11847 00003343 3DF60F                  		cmp	ax,4096-10  ; 0FF6h ; is this 16-bit fat?
 11848 00003346 7205                    		jb	short copymediaid   ; no, small fat
 11849 00003348 800E[742B]40            		or	byte [fBigFAT],fBIG ; 40h ; 16 bit fat
 11850                                  copymediaid:
 11851                                  		;;mapnew
 11852                                  		;push	es
 11853                                  		;push	ds
 11854                                  		;pop	es
 11855                                  		;push	cs
 11856                                  		;pop	ds	
 11857                                  
 11858                                  		; 31/05/2019 - Retro DOS v4.0
 11859                                  
 11860                                  		;mov	bp,mov_media_ids ; copy filesys_id, volume label,
 11861                                  		;push	cs		 ; simulate far call
 11862                                  		;call	call_bios_code
 11863                                  		
 11864 0000334D E850D9                  		call	mov_media_ids ; 31/05/2019 
 11865                                  
 11866                                  		;;unmapnew
 11867                                  		;push	es
 11868                                  		;pop	ds
 11869                                  		;pop	es
 11870                                  					;and volume serial to bds table, if extended
 11871                                  					;boot record.
 11872                                  		;jmp	massage_bpb	; now final check for bpb info. and return.
 11873 00003350 E98E00                  		jmp	massage_bpb_1 ; 16/07/2019
 11874                                  
 11875                                  toobig_ret:
 11876 00003353 800E[742B]80            		or	byte [fBigFAT],fTOOBIG ; 80h
 11877 00003358 E9A300                  		jmp	goodret 	; still drive letter is assigned
 11878                                  					; but useless. to big for
 11879                                  					; current pc dos fat file system
 11880                                  unknown:
 11881 0000335B 804D2402                		or	byte [di+BDS.flags+1],2
 11882                                  		;or	word [di+BDS.flags],unformatted_media ; 200h
 11883                                  					; Set unformatted media flag.
 11884                                  
 11885                                  ;  the boot signature may not be recognizable,
 11886                                  ;     but we should try and read it anyway.
 11887                                  
 11888                                  unknown3_0:				;skip setting unformatted_media bit
 11889 0000335F 8B551D                  		mov	dx,[di+BDS.totalsecs32+2]
 11890 00003362 8B451B                  		mov	ax,[di+BDS.totalsecs32]
 11891 00003365 BE[A22B]                		mov	si,DiskTable2
 11892                                  scan:
 11893 00003368 3B14                    		cmp	dx,[si]
 11894 0000336A 720C                    		jb	short gotparm
 11895 0000336C 7705                    		ja	short scan_next
 11896 0000336E 3B4402                  		cmp	ax,[si+2]
 11897 00003371 7605                    		jbe	short gotparm
 11898                                  scan_next:
 11899 00003373 83C60A                  		add	si,5*2
 11900 00003376 EBF0                    		jmp	short scan	; covers upto 512 mb media
 11901                                  gotparm:
 11902 00003378 8A4C08                  		mov	cl,[si+8]	; fat size for fbigfat flag
 11903 0000337B 080E[742B]              		or	[fBigFAT],cl
 11904 0000337F 8B4C04                  		mov	cx,[si+4]
 11905                                  		;mov	dx,[si+6]
 11906 00003382 8B5C06                  		mov	bx,[si+6] ; 16/07/2019
 11907                                  
 11908                                  ; dx = number of dir entries,
 11909                                  ; ch = number of sectors per cluster
 11910                                  ; cl = log base 2 of ch
 11911                                  
 11912                                  ; now calculate size of fat table
 11913                                  
 11914                                  		;mov	[di+BDS.direntries],dx	;save number of dir entries
 11915 00003385 895D0C                  		mov	[di+BDS.direntries],bx	; 16/07/2019
 11916                                  
 11917                                  ;now, cx = BDS_BPB.BPB_SECTORSPERCLUSTER|clusshift
 11918                                  ;    ds:[di].BDS_BPB.BPB_ROOTENTRIES = number of directory entries.
 11919                                  		
 11920                                  		; 16/07/2019
 11921                                  		;mov	dx,[di+BDS.totalsecs32+2]
 11922                                  		;mov	ax,[di+BDS.totalsecs32]
 11923                                  
 11924 00003388 886D08                  		mov	[di+BDS.secperclus],ch	;save sectors per cluster
 11925 0000338B F606[742B]40            		test	byte [fBigFAT],fBIG ; 40h ;if (fbigfat)
 11926 00003390 751E                    		jnz	short dobig		  ; goto dobig;
 11927                                  
 11928                                  ; we don't need to change "small fat" logic since it is gauranteed
 11929                                  ; that double word total sector will not use 12 bit fat (unless
 11930                                  ; it's sectors/cluster >= 16 which will never be in this case.)
 11931                                  ; so in this case we assume dx = 0 !!!.
 11932                                  
 11933 00003392 31DB                    		xor	bx,bx
 11934 00003394 88EB                    		mov	bl,ch
 11935 00003396 4B                      		dec	bx
 11936 00003397 01C3                    		add	bx,ax	; dx=0
 11937 00003399 D3EB                    		shr	bx,cl	; bx = 1+(bpb->maxsec+BDS_BPB.BPB_SECTORSPERCLUSTER-1)/
 11938 0000339B 43                      		inc	bx	; BDS_BPB.BPB_SECTORSPERCLUSTER
 11939 0000339C 80E3FE                  		and	bl,11111110b ; 0FEh ; bx &= ~1; (=number of clusters)
 11940 0000339F 89DE                    		mov	si,bx
 11941 000033A1 D1EB                    		shr	bx,1
 11942 000033A3 01F3                    		add	bx,si
 11943 000033A5 81C3FF01                		add	bx,511		; bx += 511 + bx/2
 11944 000033A9 D0EF                    		shr	bh,1		; bh >>= 1; (=bx/512)
 11945 000033AB 887D11                  		mov	[di+BDS.fatsecs],bh ;save number of fat sectors
 11946                                  		;jmp	short massage_bpb 
 11947 000033AE EB37                    		jmp	short massage_bpb_2 ; 6/07/2019
 11948                                  dobig:
 11949                                  ; for bigfat we do need to extend this logic to 32 bit sector calculation.
 11950                                  
 11951 000033B0 B104                    		mov	cl,4		; 16 (2^4) directory entries per sector
 11952                                  		; 16/07/2019
 11953                                  		;push	dx		; save total sectors (high)
 11954                                  		;mov	dx,[di+BDS.direntries]
 11955                                  		;shr	dx,cl	; cseBDS_BPB.BPB_ROOTENTRIES = BDS_BPB.BPB_ROOTENTRIES / 16;
 11956                                  		;sub	ax,dx	; dx:ax -= cseBDS_BPB.BPB_ROOTENTRIES; dx:ax -= csecreserved;
 11957                                  		;pop	dx
 11958 000033B2 8B5D0C                  		mov	bx,[di+BDS.direntries]
 11959 000033B5 D3EB                    		shr	bx,cl	; cseBDS_BPB.BPB_ROOTENTRIES = BDS_BPB.BPB_ROOTENTRIES / 16;
 11960 000033B7 29D8                    		sub	ax,bx	; dx:ax -= cseBDS_BPB.BPB_ROOTENTRIES; dx:ax -= csecr
 11961                                  		
 11962 000033B9 83DA00                  		sbb	dx,0
 11963 000033BC 83E801                  		sub	ax,1		; dx:ax = t - r - d
 11964 000033BF 83DA00                  		sbb	dx,0		;
 11965 000033C2 B302                    		mov	bl,2
 11966 000033C4 8A7D08                  		mov	bh,[di+BDS.secperclus]
 11967                                  					; bx = 256 * BDS_BPB.BPB_SECTORSPERCLUSTER + 2
 11968                                  ; I don't understand why to add bx here!!!
 11969                                  
 11970                                  		; 29/12/2018 - Retro DOS v4.0
 11971                                  		; (Microsoft FAT32 File System Specification, December 2000, Page 21)
 11972                                  		; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)		
 11973                                  		; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
 11974                                  		; FATsz = (TmpVal1+(TmpVal2-1))/TmpVal2
 11975                                  		; (If FATType == FAT16, BPB_FATSz16 = LOWORD(FATSz)) 
 11976                                  
 11977 000033C7 01D8                    		add	ax,bx		; ax = t-r-d+256*spc+2
 11978 000033C9 83D200                  		adc	dx,0
 11979 000033CC 83E801                  		sub	ax,1		; ax = t-r-d+256*spc+1
 11980 000033CF 83DA00                  		sbb	dx,0
 11981                                  
 11982                                  ; assuming dx in the table will never be bigger than bx.
 11983                                  
 11984 000033D2 F7F3                    		div	bx		; BDS_BPB.BPB_SECTORSPERFAT = ceil((total-dir-res)/
 11985                                  					; (256*BDS_BPB.BPB_SECTORSPERCLUSTER+2));
 11986 000033D4 894511                  		mov	[di+BDS.fatsecs],ax ; number of fat sectors
 11987                                  
 11988                                  ; now, set the default filesys_id, volume label, serial number
 11989                                  
 11990 000033D7 8A1E[742B]              		mov	bl,[fBigFAT]
 11991 000033DB 885D1F                  		mov	[di+BDS.fatsiz],bl ; fat size flag ; set size of fat on media
 11992                                  
 11993                                  		;push	ds		; save bds pointer
 11994                                  		;push	ds
 11995                                  		;pop	es		; pass to subroutine in es
 11996                                  		;push	cs		; set ds to datagrp
 11997                                  		;pop	ds
 11998                                  		
 11999                                  		; 31/05/2019 - Retro DOS v4.0
 12000                                  
 12001                                  		;mov	bp,clear_ids
 12002                                  		;push	cs		; simulate far call
 12003                                  		;call	call_bios_code
 12004                                  
 12005 000033DE E802D9                  		call	clear_ids  ; 31/05/2019	
 12006                                  		
 12007                                  		;pop	ds		; restore bds pointer
 12008                                  
 12009                                  massage_bpb_1:
 12010                                  		; 16/07/2019 - Retro DOS v3.2
 12011 000033E1 8B551D                  		mov	dx,[di+BDS.totalsecs32+2]
 12012 000033E4 8B451B                  		mov	ax,[di+BDS.totalsecs32]
 12013                                  
 12014                                  ; at this point, in bpb of bds table, BDS_BPB.BPB_BIGTOTALSECTORS which is
 12015                                  ; set according to the partition information. we are going to
 12016                                  ; see if (hidden sectors + total sectors) > a word. if it is true,
 12017                                  ; then no change. otherwise, BDS_BPB.BPB_BIGTOTALSECTORS will be moved
 12018                                  ; to BDS_BPB.BPB_TOTALSECTORS and BDS_BPB.BPB_BIGTOTALSECTORS will be set to 0.
 12019                                  ; we don't do this for the bpb information from the boot record. we
 12020                                  ; are not going to change the bpb information from the boot record.
 12021                                  
 12022                                  massage_bpb:
 12023                                  massage_bpb_2:	; 16/07/2019
 12024                                  		;mov	dx,[di+BDS.totalsecs32+2]
 12025                                  		;mov	ax,[di+BDS.totalsecs32]
 12026                                  
 12027                                  		;cmp	dx,0		; double word total sector?
 12028                                  		;ja	short goodret 	; don't have to change it.
 12029                                  
 12030 000033E7 09D2                    		or	dx,dx
 12031 000033E9 7513                    		jnz	short goodret
 12032                                  
 12033 000033EB 395519                  		cmp	[di+BDS.hiddensecs+2],dx ; 0 ; 11/05/2019
 12034                                  		;cmp	word [di+BDS.hiddensecs+2],0
 12035 000033EE 770E                    		ja	short goodret 	; don't have to change it.
 12036 000033F0 034517                  		add	ax,[di+BDS.hiddensecs]
 12037 000033F3 7209                    		jc	short goodret 	; bigger than a word boundary
 12038                                  
 12039 000033F5 8B451B                  		mov	ax,[di+BDS.totalsecs32]
 12040 000033F8 89450E                  		mov	[di+BDS.totalsecs16],ax
 12041                                  		;mov	word [di+BDS.totalsecs32],0
 12042 000033FB 89551B                  		mov	[di+BDS.totalsecs32],dx ; 0
 12043                                  goodret:
 12044 000033FE 8A1E[742B]              		mov	bl,[fBigFAT]
 12045 00003402 885D1F                  		mov	[di+BDS.fatsiz],bl ; set size of fat on media
 12046 00003405 F8                      		clc
 12047 00003406 E980FD                  		jmp	ret_hard ; 15/07/2019
 12048                                  ;ret_hard:
 12049                                  ;		pop	es
 12050                                  ;		pop	ds
 12051                                  ;		pop	bx
 12052                                  ;		pop	di
 12053                                  ;		retn
 12054                                  
 12055                                  ; 30/12/2018 - Retro DOS v4.0
 12056                                  
 12057                                  ; --------------------------------------------------------------------------
 12058                                  ;
 12059                                  ;fdisk of pc dos 3.3 and below, os2 1.0 has a bug. the maximum number of
 12060                                  ;sector that can be handled by pc dos 3.3 ibmbio should be 0ffffh.
 12061                                  ;instead, sometimes fdisk use 10000h to calculate the maximum number.
 12062                                  ;so, we are going to check that if BPB_TOTALSECTORS + hidden sector = 10000h
 12063                                  ;then subtract 1 from BPB_TOTALSECTORS.
 12064                                  ;
 12065                                  ; --------------------------------------------------------------------------
 12066                                  
 12067                                  cover_fdisk_bug:
 12068                                  		; 16/07/2019 - Retro DOS v3.2
 12069                                  		;push	ax
 12070                                  		;push	dx
 12071                                  		;push	si
 12072                                  
 12073                                  		; 28/07/2019
 12074                                  		; si = DiskSector+EXT_BOOT.BPB
 12075                                  		
 12076                                  		; 29/05/2019
 12077                                  		;cmp	byte [DiskSector+EXT_BOOT.SIG],EXT_BOOT_SIGNATURE
 12078                                  		;je	short cfb_retit	;if extended bpb, then >= pc dos 4.00
 12079                                  
 12080 00003409 817F073130              		cmp	word [bx+7],"10" ; os2 1.0 ? = ibm 10.0
 12081 0000340E 7506                    		jne	short cfb_chk_BPB_TOTALSECTORS
 12082 00003410 807F0A30                		cmp	byte [bx+10],"0"
 12083 00003414 7518                    		jne	short cfb_retit
 12084                                  
 12085                                  cfb_chk_BPB_TOTALSECTORS:
 12086                                  		;mov	si,DiskSector+EXT_BOOT.BPB
 12087                                  
 12088                                  		;cmp	word [si+EBPB.TOTALSECTORS],0	;just to make sure.
 12089                                  		;je	short cfb_retit
 12090                                  
 12091 00003416 8B4408                  		mov	ax,[si+EBPB.TOTALSECTORS]
 12092                                  
 12093 00003419 09C0                    		or	ax,ax
 12094 0000341B 7411                    		jz	short cfb_retit 
 12095                                  
 12096 0000341D 034411                  		add	ax,[si+EBPB.HIDDENSECTORS]
 12097 00003420 730C                    		jnc	short cfb_retit ; 29/05/2019
 12098                                  			;if carry set and ax=0?
 12099 00003422 750A                    		jnz	short cfb_retit	; -- zero reflects ax from add
 12100                                  				
 12101                                  ; -- result of add was 10000h
 12102                                  
 12103 00003424 FF4C08                  		dec	word [si+EBPB.TOTALSECTORS] 
 12104                                  				; then decrease BPB_TOTALSECTORS by 1.
 12105                                  
 12106                                  		; ax = 0
 12107 00003427 836D1B01                		sub	word [di+BDS.totalsecs32],1
 12108                                  		;sbb	word [di+BDS.totalsecs32+2],0
 12109 0000342B 19451D                  		sbb	[di+BDS.totalsecs32+2],ax ; 0
 12110                                  cfb_retit:
 12111                                  		;pop	si
 12112                                  		;pop	dx
 12113                                  		;pop	ax
 12114 0000342E C3                      		retn	
 12115                                  
 12116                                  ; 03/08/2019 - Retro DOS v3.2
 12117                                  ; --------------------------------------------------------------------------
 12118                                  ; 06/07/2019 - Retro DOS v3.1
 12119                                  ; (Note: Following offset may change when SYSINIT code will be changed.)
 12120                                  ;BPB_Table equ SYSINIT_START + 16A0h  ; (BPBTable offset in sysinit2.asm)
 12121                                  ;;BPB_Table equ SYSINIT_START + 1C34h
 12122                                  ;BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 12123                                  
 12124                                  ; 22/11/2022
 12125                                  BPB_Table equ SYSINIT_START + 1698h  ; (BPBTable offset in sysinit21.asm)
 12126                                  BPBSIZ	  equ 25  ; Retro DOS v3.0 (02/06/2018)	
 12127                                  
 12128                                  ; 30/12/2018 - Retro DOS v4.0
 12129                                  ; 28/07/2019 - Retro DOS v3.2
 12130                                  
 12131 0000342F 0200                    word2:		dw 2
 12132 00003431 0300                    word3:		dw 3
 12133 00003433 0002                    word512:	dw 512		
 12134                                  
 12135                                  ; --------------------------------------------------------------------------
 12136                                  ;
 12137                                  ; SetDrvParms sets up the recommended BPB in each BDS in the system based on
 12138                                  ; the form factor. It is assumed that the BPBs for the various form factors
 12139                                  ; are present in the BPBTable. For hard files, the Recommended BPB is the
 12140                                  ; same as the BPB on the drive.
 12141                                  ; No attempt is made to preserve registers since we are going to jump to
 12142                                  ; SYSINIT straight after this routine.
 12143                                  ;
 12144                                  ; --------------------------------------------------------------------------
 12145                                  
 12146                                  		; 30/12/2018 - Retro DOS v4.0
 12147                                  		; 28/07/2019 - Retro DOS v3.2		
 12148                                  SETDRVPARMS:
 12149                                  		; es = ds = cs  ; Retro DOS v3.2
 12150 00003435 31DB                    		xor	bx,bx
 12151                                  		;;les	di,[cs:START_BDS]	; get first BDS in list
 12152                                  		;les	di,[START_BDS]
 12153                                  		;lds	di,[START_BDS]
 12154 00003437 8B3E[9A01]              		mov	di,[START_BDS]
 12155                                  NextBDS:
 12156                                  		;push	es ; ****
 12157 0000343B 57                      		push	di ; *** 		; preserve pointer to BDS
 12158                                  		
 12159                                  		;mov	bl,[es:di+34]
 12160                                  		;mov	bl,[es:di+BDS.formfactor]
 12161 0000343C 8A5D22                  		mov	bl,[di+BDS.formfactor]
 12162 0000343F 80FB05                  		cmp	bl,ffHardFile
 12163 00003442 7533                    		jne	short NotHardFF
 12164                                  
 12165 00003444 31D2                    		xor	dx,dx
 12166                                  		;mov	ax,[es:di+14]
 12167                                  		;mov	ax,[es:di+BDS.totalsecs16]
 12168 00003446 8B450E                  		mov	ax,[di+BDS.totalsecs16]	
 12169                                  
 12170 00003449 09C0                    		or	ax,ax
 12171 0000344B 7506                    		jnz	short get_ccyl
 12172                                  
 12173                                  		;mov	dx,[es:di+29]
 12174                                  		;mov	dx,[es:di+BDS.totalsecs32+2] ; use double word sector number
 12175 0000344D 8B551D                  		mov	dx,[di+BDS.totalsecs32+2] 
 12176                                  		;mov	ax,[es:di+27]
 12177                                  		;mov	ax,[es:di+BDS.totalsecs32]
 12178 00003450 8B451B                  		mov	ax,[di+BDS.totalsecs32]
 12179                                  get_ccyl:
 12180 00003453 50                      		push	ax ; **
 12181 00003454 52                      		push	dx ; *
 12182                                  
 12183                                  		;mov	ax,[es:di+21]
 12184                                  		;mov	ax,[es:di+BDS.heads]
 12185 00003455 8B4515                  		mov	ax,[di+BDS.heads]
 12186                                  		;mul	word [es:di+19]
 12187                                  		;mul	word [es:di+BDS.secpertrack] ; assume sectors per cyl. < 64k.
 12188 00003458 F76513                  		mul	word [di+BDS.secpertrack]
 12189 0000345B 89C1                    		mov	cx,ax			; cx has # sectors per cylinder
 12190                                  
 12191 0000345D 5A                      		pop	dx ; *
 12192                                  		;pop	ax ; **		; restore BDS_BPB.BPB_TOTALSECTORS.
 12193                                  
 12194                                  		;push	ax ; **
 12195 0000345E 89D0                    		mov	ax,dx
 12196 00003460 31D2                    		xor	dx,dx
 12197 00003462 F7F1                    		div	cx
 12198                                  		;mov	[cs:temp_h],ax
 12199 00003464 A3[A605]                		mov	[temp_h],ax	; ax be 0 here.
 12200 00003467 58                      		pop	ax ; **
 12201                                  
 12202 00003468 F7F1                    		div	cx		; div #sec by sec/cyl to get # cyl.
 12203 0000346A 09D2                    		or	dx,dx
 12204 0000346C 7401                    		jz	short No_Cyl_Rnd ; came out even
 12205 0000346E 40                      		inc	ax		; round up
 12206                                  No_Cyl_Rnd:
 12207                                  		;mov	[es:di+37],ax
 12208                                  		;mov	[es:di+BDS.cylinders],ax
 12209 0000346F 894525                  		mov	[di+BDS.cylinders],ax
 12210                                  		;push	es
 12211                                  		;pop	ds
 12212                                  		;lea	si,[di+6]
 12213 00003472 8D7506                  		lea	si,[di+BDS.bytespersec] ; ds:si -> BPB for hard file
 12214                                  
 12215 00003475 EB4F                    		jmp	short Set_RecBPB
 12216                                  NotHardFF:
 12217                                  		;push	cs
 12218                                  		;pop	ds
 12219                                  
 12220                                  ; if fake floppy drive variable is set then we don't have to handle this bds.
 12221                                  ; we can just go and deal with the next bds at label go_to_next_bds.
 12222                                  
 12223 00003477 803E[792B]01            		cmp	byte [fakefloppydrv],1
 12224 0000347C 7450                    		je	short Go_To_Next_BDS
 12225                                  
 12226 0000347E 80FB07                  		cmp	bl,ffOther		; Special case "other" type of medium
 12227 00003481 753D                    		JNZ	short NOT_PROCESS_OTHER
 12228                                  Process_Other:
 12229 00003483 31D2                    		xor	dx,dx
 12230                                  		;mov	ax,[di+37]
 12231 00003485 8B4525                  		mov	ax,[di+BDS.cylinders]
 12232                                  		;mul	word [di+54]
 12233 00003488 F76536                  		mul	word [di+BDS.rheads]
 12234                                  		;mul	word [di+52]
 12235 0000348B F76534                  		mul	word [di+BDS.rsecpertrack]
 12236                                  		;mov	[di+47],ax
 12237 0000348E 89452F                  		mov	[di+BDS.rtotalsecs16],ax ; have the total number of sectors
 12238 00003491 48                      		dec	ax
 12239                                  
 12240 00003492 B201                    		mov	dl,1
 12241                                  _again:
 12242 00003494 3DF60F                  		cmp	ax,4096-10  ; 0FF6h
 12243 00003497 7206                    		jb	short _@@
 12244 00003499 D1E8                    		shr	ax,1
 12245 0000349B D0E2                    		shl	dl,1
 12246 0000349D EBF5                    		jmp	short _again
 12247                                  _@@:
 12248 0000349F 80FA01                  		cmp	dl,1		; is it a small disk
 12249 000034A2 7405                    		je	short __@@	; yes, 224 root entries is enuf
 12250                                  		
 12251                                  		;mov	word [di+45],240
 12252 000034A4 C7452DF000              		mov	word [di+BDS.rdirentries],240
 12253                                  __@@:
 12254                                  		;mov	[di+41],dl
 12255 000034A9 885529                  		mov	[di+BDS.rsecperclus],dl
 12256                                  
 12257                                  ;	logic to get the sectors/fat area.
 12258                                  ;	fat entry is assumed to be 1.5 bytes!!!
 12259                                  
 12260                                  		; ds = cs
 12261 000034AC F726[3134]              		mul	word [word3]
 12262 000034B0 F736[2F34]              		div	word [word2]
 12263 000034B4 31D2                    		xor	dx,dx
 12264 000034B6 F736[3334]              		div	word [word512]
 12265 000034BA 40                      		inc	ax
 12266                                  No_Round_Up:
 12267                                  		;mov	[di+50],ax
 12268 000034BB 894532                  		mov	[di+BDS.rfatsecs],ax
 12269 000034BE EB0E                    		jmp	short Go_To_Next_BDS
 12270                                  
 12271                                  NOT_PROCESS_OTHER:
 12272                                  		;shl	bx,1		; bx is word index into table of bpbs
 12273 000034C0 D0E3                    		shl	bl,1
 12274                                  		;mov	si,offset BPBTable
 12275                                  		; 06/07/2018
 12276                                  		;mov	si,BPB_Table  ; Retro DOS v3.0 modification (06/07/2018)
 12277                                  				      ; (FD BPB Tables are in SYINIT section)
 12278                                  		;mov	si,[si+bx]	; get address of bpb
 12279 000034C2 8BB7[684D]              		mov	si,[BPB_Table+bx]
 12280                                  Set_RecBPB:
 12281                                  		;lea	di,[di+39]
 12282 000034C6 8D7D27                  		lea	di,[di+BDS.rbytespersec] ; es:di -> RecBPB
 12283                                  		; es = ds
 12284 000034C9 B91900                  		mov	cx,BPBSIZ ; 25
 12285 000034CC F3A4                    		REP	MOVSB			; MOVE BPBSIZ BYTES
 12286                                  Go_To_Next_BDS:
 12287 000034CE 5F                      		pop	di ; ***
 12288                                  		;pop	es ; ****		; restore pointer to BDS
 12289                                  
 12290                                  		;mov	bx,[es:di+BDS.link+2]
 12291                                  		;;mov	di,[es:di+BDS.link]
 12292                                  		;mov	di,[es:di] ; 05/07/2019
 12293                                  		;mov	es,bx
 12294                                  		; 28/07/2019
 12295                                  		;push	cs
 12296                                  		;pop	ds	
 12297                                  		;les	di,[es:di]
 12298 000034CF 8B3D                    		mov	di,[di]
 12299 000034D1 83FFFF                  		cmp	di,-1
 12300 000034D4 740B                    		je	short Done_SetParms
 12301 000034D6 E962FF                  		jmp	NextBDS
 12302                                  ;Done_SetParms:
 12303 000034D9 C3                      		retn
 12304                                  
 12305                                  ; ----------------------------------------------------------------------------
 12306                                  ; 03/06/2018 - Retro DOS v3.0
 12307                                  
 12308                                  
 12309                                  ; SI POINTS TO DEVICE HEADER
 12310                                  ;
 12311                                  ;  4/22/86 - print_init, aux_init is modified to eliminate the
 12312                                  ;  self-modifying code.
 12313                                  
 12314                                  PRINT_INIT:
 12315 000034DA E80F00                  		call	GET_DEVICE_NUMBER
 12316 000034DD B401                    		mov	ah,1		;initalize printer port
 12317 000034DF CD17                    		int	17h		;call ROM-Bios routine
 12318                                  Done_SetParms:	; 28/07/2019
 12319 000034E1 C3                      		retn
 12320                                  
 12321                                  AUX_INIT:
 12322 000034E2 E80700                  		call	GET_DEVICE_NUMBER
 12323 000034E5 B0A3                    		mov	al,RSINIT	;2400,N,1,8 (MSEQU.INC)
 12324 000034E7 B400                    		mov	ah,0		;initalize AUX port
 12325 000034E9 CD14                    		int	14h		;call ROM-Bios routine
 12326 000034EB C3                      		retn
 12327                                  
 12328                                  GET_DEVICE_NUMBER:
 12329                                  ;SI -> device header
 12330                                  		; 16/06/2018
 12331 000034EC 2E8A440D                		MOV	AL,[CS:SI+13]	;GET DEVICE NUMBER FROM THE NAME
 12332                                  		;MOV	AL,[SI+13]
 12333 000034F0 2C31                    		SUB	AL,"1"
 12334 000034F2 98                      		CBW
 12335 000034F3 89C2                    		MOV	DX,AX
 12336 000034F5 C3                      		RETN
 12337                                  
 12338                                  ; ----------------------------------------------------------------------------
 12339                                  
 12340                                  ; 17/07/2019 - Retro DOS v3.2
 12341                                  ;
 12342                                  ;;   purge_96tpi NOP's calls to 96tpi support.
 12343                                  ;
 12344                                  ;PURGE_96TPI:
 12345                                  ;		PUSH	DS
 12346                                  ;		PUSH	ES
 12347                                  ;
 12348                                  ;		push	cs			;mjb001
 12349                                  ;		pop	es			;mjb001
 12350                                  ;		push	cs			;mjb001
 12351                                  ;		pop	ds			;mjb001
 12352                                  ;		
 12353                                  ;		MOV	SI,PatchTable
 12354                                  ;PatchLoop:
 12355                                  ;		LODSW
 12356                                  ;		MOV	CX,AX
 12357                                  ;		JCXZ	PatchDone
 12358                                  ;		LODSW
 12359                                  ;		MOV	DI,AX
 12360                                  ;		MOV	AL,90h
 12361                                  ;		REP	STOSB
 12362                                  ;		JMP	short PatchLoop
 12363                                  ;PatchDone:
 12364                                  ;		mov	di,TABLE_PATCH		;ARR 2.42
 12365                                  ;		MOV	AX,EXIT
 12366                                  ;		STOSW
 12367                                  ;		STOSW
 12368                                  ;
 12369                                  ;		POP	ES
 12370                                  ;		POP	DS
 12371                                  ;		retn				;mjb001
 12372                                  
 12373                                  ; ----------------------------------------------------------------------------
 12374                                  ; 16/07/2019 - Retro DOS v3.2
 12375                                  ; 30/12/2018 - Retro DOS v4.0
 12376                                  ; 03/06/2018 - Retro DOS v3.0
 12377                                  ; (19/03/2018 - Retro DOS v2.0)
 12378                                  
 12379                                  ; domini **********************************************************************
 12380                                  ;
 12381                                  ;mini disk initialization routine. called right after dohard
 12382                                  ;modified for >2 hardfile support
 12383                                  ;
 12384                                  ; **cs=ds=es=datagrp
 12385                                  ;
 12386                                  ; **domini will search for every extended partition in the system, and
 12387                                  ;   initialize it.
 12388                                  ;
 12389                                  ; **bdsm stands for bds table for mini disk and located right after the label
 12390                                  ;   end96tpi. end_of_bdsm will have the offset value of the ending
 12391                                  ;   address of bdsm table.
 12392                                  ;
 12393                                  ; **bdsm is the same as usual bds structure except that tim_lo, tim_hi entries
 12394                                  ;   are overlapped and used to identify mini disk and the number of hidden_trks.
 12395                                  ;   right now, they are called as ismini, hidden_trks respectively.
 12396                                  ;
 12397                                  ; **domini will use the same routine in sethard routine after label set2 to
 12398                                  ;   save coding.
 12399                                  ;
 12400                                  ; **drvmax determined in dohard routine will be used for the next
 12401                                  ;   available logical mini disk drive number.
 12402                                  ;
 12403                                  ; input: drvmax, dskdrvs
 12404                                  ;
 12405                                  ; output: minidisk installed. bdsm table established and installed to bds.
 12406                                  ;	  end_of_bdsm - ending offset address of bdsm.
 12407                                  ;
 12408                                  ; called modules:
 12409                                  ;		  getboot
 12410                                  ;		  find_mini_partition (new), xinstall_bds (new), M038
 12411                                  ;
 12412                                  ;		  setmini (new, it will use set2 routine)
 12413                                  ;
 12414                                  ; variables used: end_of_bdsm
 12415                                  ;		  rom_minidisk_num
 12416                                  ;		  mini_hdlim, mini_seclim
 12417                                  ;		  BDS_STRUC, start_bds
 12418                                  ;
 12419                                  ;******************************************************************************
 12420                                  
 12421                                  DoMini:
 12422                                  		; 16/07/2019 - Retro DOS v3.2
 12423                                  	
 12424 000034F6 8A36[1C1B]              		mov	dh,[HNUM]		; get number of hardfiles
 12425                                  
 12426                                  		;cmp	dh,0
 12427                                  		;je	short dominiret		;no hard file? then exit.
 12428                                  
 12429 000034FA 20F6                    		and	dh,dh
 12430 000034FC 7431                    		jz	short dominiret
 12431                                  
 12432 000034FE B280                    		mov	dl,80h			; start with hardfile 80h
 12433                                  domini_loop:
 12434 00003500 52                      		push	dx			; save hard drive number, count
 12435 00003501 8816[ED2B]              		mov	[rom_minidisk_num],dl
 12436                                  
 12437 00003505 B408                    		mov	ah,08h			;get drive parameters
 12438 00003507 CD13                    		int	13h			;call rom-bios
 12439                                  		
 12440 00003509 FEC6                    		inc	dh			;get # of heads (convert it to 1 based)
 12441                                  		
 12442 0000350B 31C0                    		xor	ax,ax
 12443 0000350D 88F0                    		mov	al,dh
 12444 0000350F A3[EE2B]                		mov	[mini_hdlim],ax		;save it.
 12445 00003512 80E13F                  		and	cl,3Fh			;get # of sectors/track
 12446 00003515 88C8                    		mov	al,cl
 12447 00003517 A3[F02B]                		mov	[mini_seclim],ax	;and save it.
 12448                                  
 12449 0000351A 06                      		push	es			; preserve es
 12450 0000351B 8A16[ED2B]              		mov	dl,[rom_minidisk_num]
 12451 0000351F E89DFB                  		call	GETBOOT 		;read master boot record into 7c0:bootbias
 12452 00003522 7203                    		jc	short domininext
 12453 00003524 E80900                  		call	FIND_MINI_PARTITION
 12454                                  domininext:
 12455 00003527 07                      		pop	es
 12456 00003528 5A                      		pop	dx
 12457 00003529 FEC2                    		inc	dl			; next hard file
 12458 0000352B FECE                    		dec	dh
 12459 0000352D 75D1                    		jnz	short domini_loop
 12460                                  dominiret:
 12461                                  ;fmpret:	; 20/06/2019
 12462 0000352F C3                      		retn
 12463                                  
 12464                                  ;--------------------------------------------------------------------
 12465                                  ; 30/12/2018 - Retro DOS v4.0
 12466                                  
 12467                                  ;find_mini_partition tries to find every extended partition on a disk.
 12468                                  ;at entry:	di -> bdsm entry
 12469                                  ;		es:bx -> 07c0:bootbias - master boot record
 12470                                  ;		rom_minidisk_num - rom drive number
 12471                                  ;		drvmax - logical drive number
 12472                                  ;		mini_hdlim, mini_seclim
 12473                                  ;
 12474                                  ;called routine: setmini which uses set2 (in sethard routine)
 12475                                  ;variables & equates used from original bios - flags, fnon_removable, fbigfat
 12476                                  
 12477                                  FIND_MINI_PARTITION:
 12478 00003530 81C3C201                		add	bx,1C2h		;bx -> system id.
 12479                                  fmpnext:
 12480 00003534 26803F05                		cmp	byte [es:bx],5	; 5 = extended partition id.
 12481 00003538 740A                    		je	short fmpgot
 12482 0000353A 83C310                  		add	bx,16		; for next entry
 12483 0000353D 81FB0204                		cmp	bx,202h+BootBias
 12484                                  		;jne	short fmpnext
 12485                                  		;jmp	short fmpret	; extended partition not found
 12486                                  		; 30/07/2019 - Retro DOS v3.2
 12487 00003541 72F1                    		jb	short fmpnext
 12488                                  fmpret:
 12489 00003543 C3                      		retn	; 29/05/2019
 12490                                  fmpgot: 				
 12491                                  					; found my partition.
 12492 00003544 E87700                  		call	dmax_check	; -- check for drvmax already 26
 12493 00003547 73FA                    		jnc	short fmpret	; -- done if too many
 12494                                  
 12495 00003549 8B3E[E82B]              		mov	di,[end_of_bdss] ; get next free bds
 12496 0000354D C745470100              		mov	word [di+BDS.bdsm_ismini],1
 12497                                  		;or	word [di+BDS.flags],fNon_Removable ; 1
 12498                                  		; 30/07/2019
 12499 00003552 804D2301                		or	byte [di+BDS.flags],fNon_Removable ; 1
 12500 00003556 C6452205                		mov	byte [di+BDS.formfactor],ffHardFile  ; 5
 12501 0000355A C606[742B]00            		mov	byte [fBigFAT],0 ; assume 12 bit fat.
 12502                                  
 12503 0000355F A1[EE2B]                		mov	ax,[mini_hdlim]
 12504 00003562 894515                  		mov	[di+BDS.heads],ax
 12505 00003565 A1[F02B]                		mov	ax,[mini_seclim]
 12506 00003568 894513                  		mov	[di+BDS.secpertrack],ax
 12507 0000356B A0[ED2B]                		mov	al,[rom_minidisk_num]
 12508 0000356E 884504                  		mov	[di+BDS.drivenum],al ;set physical number
 12509 00003571 A0[1001]                		mov	al,[DRVMAX]
 12510 00003574 884505                  		mov	[di+BDS.drivelet],al ;set logical number
 12511                                  
 12512 00003577 26837F0A00              		cmp	word [es:bx+10],0
 12513 0000357C 7707                    		ja	short fmpgot_cont
 12514 0000357E 26837F0840              		cmp	word [es:bx+8],64 ;**with current bpb, only lower word
 12515                                  					; is meaningful.
 12516 00003583 72BE                    		jb	short fmpret	;should be bigger than 64 sectors at least
 12517                                  fmpgot_cont:
 12518 00003585 83EB04                  		sub	bx,4		;let bx point to the start of the entry
 12519 00003588 268A7702                		mov	dh,[es:bx+2]
 12520 0000358C 80E6C0                  		and	dh,11000000b ; 0C0h ;get higher bits of cyl
 12521 0000358F D0C6                    		rol	dh,1
 12522 00003591 D0C6                    		rol	dh,1
 12523 00003593 268A5703                		mov	dl,[es:bx+3]	;cyl byte
 12524 00003597 895549                  		mov	[di+BDS.bdsm_hidden_trks],dx ;set hidden trks
 12525                                  
 12526                                  ;** now, read the volume boot record into bootbias.
 12527                                  
 12528 0000359A 268B4F02                		mov	cx,[es:bx+2]	;cylinder,cylinder/sector
 12529 0000359E 268A7701                		mov	dh,[es:bx+1]	;head
 12530 000035A2 8A16[ED2B]              		mov	dl,[rom_minidisk_num] ;drive
 12531 000035A6 BB0002                  		mov	bx,BootBias	;buffer offset
 12532 000035A9 B80102                  		mov	ax,201h 	;read, 1 sector
 12533 000035AC CD13                    		int	13h		;call rom-bios routine
 12534                                  		;;jc	fmpret		;cannot continue.
 12535                                  		;jc	short _fmpret ; 11/05/2019
 12536 000035AE 7293                    		jc	short fmpret ; 29/05/2019
 12537                                  
 12538 000035B0 BBC203                  		mov	bx,1C2h+BootBias
 12539                                  		; 16/07/2019
 12540                                  		;push	es		; addressability to next minidisk
 12541 000035B3 E8B3FB                  		call	SetMini 	; install a mini disk. bx value saved.
 12542                                  		;pop	es
 12543                                  		;jc	short fmpnextchain
 12544                                  		; 30/07/2019
 12545 000035B6 728B                    		jc	short fmpret
 12546                                  
 12547 000035B8 E81000                  		call	xinstall_bds	; -- install the bdsm into table
 12548                                  ;fmpnextchain: 
 12549 000035BB E976FF                  		jmp	fmpnext		;let's find out if we have any chained partition
 12550                                  ;fmpret:
 12551                                  ;		retn
 12552                                  
 12553                                  ;--------------------------------------------------------------------
 12554                                  
 12555                                  ; 16/07/2019 - Retro DOS v3.2
 12556                                  
 12557                                  ; 28/12/2018 - Retro DOS v4.0
 12558                                  ;
 12559                                  ; dmax_check --- call this when we want to install a new drive.
 12560                                  ;		it checks for drvmax < 26 to see if there is
 12561                                  ;		a drive letter left.
 12562                                  ;
 12563                                  ;	drvmax < 26 : carry SET!
 12564                                  ;	drvmax >=26 : carry RESET!, error flag set for message later
 12565                                  ;			trash ax
 12566                                  
 12567                                  dmax_check:
 12568 000035BE 803E[1001]1A            		cmp	byte [DRVMAX],26	; already have max?
 12569 000035C3 7205                    		jb	short dmax_ok		; return with carry if okay
 12570                                  
 12571                                  		;push	es
 12572                                  		;mov	ax,SYSINIT_SEG
 12573                                  		;mov	es,ax
 12574                                  		;mov	byte ptr es:[toomanydrivesflag],1 ; set message flag
 12575                                  		;pop	es
 12576                                  
 12577                                  		; 17/07/2019
 12578 000035C5 C606[B739]01            		mov	byte [SYSINIT+toomanydrivesflag],1
 12579                                  
 12580                                  		; note:  carry still clear!!!
 12581                                  _fmpret: ; 11/05/2019
 12582                                  dmax_ok:
 12583 000035CA C3                      		retn
 12584                                  
 12585                                  ; 28/12/2018 - Retro DOS v4.0						
 12586                                  ;								 
 12587                                  ;	link next bds (at ds:di) into the chain. assume that the
 12588                                  ;	  chain is entirely within ds == datagrp. also update drvmax,
 12589                                  ;	  dskdrv_table, and end_of_bdss.						 
 12590                                  									 
 12591                                  xinstall_bds:
 12592 000035CB 56                      		push	si							 
 12593 000035CC 53                      		push	bx							 
 12594                                  									 
 12595 000035CD 8B36[9A01]              		mov	si,[START_BDS]		; get first bds
 12596                                  xinstall_bds_1:	
 12597                                  		;cmp	word [si+BDS.link],-1							 
 12598 000035D1 833CFF                  		cmp	word [si],-1		; is this the last one?
 12599 000035D4 7404                    		je	short xinstall_bds_2	; skip ahead if so						 
 12600                                  		;mov	si,[si+BDS.link]				 
 12601 000035D6 8B34                    		mov	si,[si]			; chain through list
 12602 000035D8 EBF7                    		jmp	short xinstall_bds_1					 
 12603                                  xinstall_bds_2:								 
 12604                                  		;mov	[si+BDS.link],di
 12605 000035DA 893C                    		mov	[si],di
 12606 000035DC 8C5C02                  		mov	[si+BDS.link+2],ds
 12607                                  		;mov	word [di+BDS.link],-1	; make sure it is a null ptr.
 12608 000035DF C705FFFF                		mov	word [di],-1
 12609 000035E3 8C5D02                  		mov	[di+BDS.link+2],ds	; might as well plug segment
 12610                                  
 12611                                  		; 20/03/2019 - Retro DOS v4.0
 12612 000035E6 8D5D06                  		lea	bx,[di+BDS.BPB]
 12613                                  
 12614 000035E9 8B36[F22B]              		mov	si,[last_dskdrv_table]
 12615 000035ED 891C                    		mov	[si],bx
 12616 000035EF 8306[F22B]02            		add	word [last_dskdrv_table],2
 12617                                  									 
 12618 000035F4 FE06[1001]              		inc	byte [DRVMAX]
 12619                                  							 
 12620 000035F8 8306[E82B]64            		add	word [end_of_bdss],BDS.size ; 100	
 12621                                  						 
 12622 000035FD 5B                      		pop	bx							 
 12623 000035FE 5E                      		pop	si							 
 12624 000035FF C3                      		retn
 12625                                  			 
 12626                                  ;**end of mini disk initialization**
 12627                                  
 12628                                  ; ----------------------------------------------------------------------------
 12629                                  ; 03/06/2018 - Retro DOS v3.0
 12630                                  
 12631                                  CMOS_CLOCK_READ:
 12632                                  
 12633                                  ; IN ORDER TO DETERMINE IF THERE IS A CLOCK PRESENT IN THE SYSTEM, THE FOLLOWING 
 12634                                  ; NEEDS TO BE DONE.							 
 12635 00003600 50                      		PUSH	AX							 
 12636 00003601 51                      		PUSH	CX							 
 12637 00003602 52                      		PUSH	DX							 
 12638 00003603 55                      		PUSH	BP							 
 12639                                  									 
 12640 00003604 31ED                    		XOR	BP,BP							 
 12641                                  LOOP_CLOCK:								 
 12642 00003606 31C9                    		XOR	CX,CX							 
 12643 00003608 31D2                    		XOR	DX,DX							 
 12644 0000360A B402                    		MOV	AH,2			;READ REAL TIME CLOCK
 12645 0000360C CD1A                    		INT	1Ah			;CALL ROM-BIOS ROUTINE
 12646 0000360E 83F900                  		CMP	CX,0							 
 12647 00003611 7512                    		JNZ	short CLOCK_PRESENT						 
 12648                                  									 
 12649 00003613 83FA00                  		CMP	DX,0							 
 12650 00003616 750D                    		JNZ	short CLOCK_PRESENT						 
 12651                                  									 
 12652 00003618 83FD01                  		CMP	BP,1			; READ AGAIN AFTER A SLIGHT DELAY, IN CASE CLOCK
 12653 0000361B 741B                    		JZ	short NO_READDATE	; WAS AT ZERO SETTING.		 
 12654                                  									 
 12655 0000361D 45                      		INC	BP			; ONLY PERFORM DELAY ONCE.	 
 12656 0000361E B90040                  		MOV	CX,4000H						 
 12657                                  DELAY:									 
 12658 00003621 E2FE                    		LOOP	DELAY							 
 12659 00003623 EBE1                    		JMP	LOOP_CLOCK						 
 12660                                  									 
 12661                                  CLOCK_PRESENT:								 
 12662                                  		;mov	byte [cs:HaveCMOSClock], 1 ; Set the flag for cmos clock 
 12663 00003625 C606[7405]01            		mov	byte [HaveCMOSClock], 1
 12664                                  									 
 12665 0000362A E81000                  		call	CMOSCK			; Reset CMOS clock rate that may be  
 12666                                  						; possibly destroyed by CP DOS and 
 12667                                  						; POST routine did not restore that.			 
 12668 0000362D 56                       		PUSH	SI							 
 12669 0000362E E898F3                  		CALL	READ_REAL_DATE		;READ REAL-TIME CLOCK FOR DATE 
 12670                                  									 
 12671 00003631 FA                      		CLI			 
 12672 00003632 8936[7205]              		MOV	[DAYCNT],SI		;SET SYSTEM DATE		 
 12673 00003636 FB                      		STI			 
 12674 00003637 5E                      		POP	SI			 
 12675                                  NO_READDATE:								 
 12676 00003638 5D                      		POP	BP							 
 12677 00003639 5A                      		POP	DX							 
 12678 0000363A 59                      		POP	CX							 
 12679 0000363B 58                      		POP	AX							 
 12680 0000363C C3                      		RETN								 
 12681                                  				 
 12682                                  ;									 
 12683                                  ; 10/28/86								 
 12684                                  ; THE FOLLOWING CODE IS WRITTEN BY JACK GULLEY IN ENGINEERING GROUP. 
 12685                                  ; CP DOS IS CHANGING CMOS CLOCK RATE FOR ITS OWN PURPOSES AND IF THE 
 12686                                  ; USE COLD BOOT THE SYSTEM TO USE PC DOS WHILE RUNNING CP DOS, THE CMOS 
 12687                                  ; CLOCK RATE ARE STILL SLOW WHICH SLOW DOWN DISK OPERATIONS OF PC DOS 
 12688                                  ; WHICH USES CMOS CLOCK. PC DOS IS PUT THIS CODE IN MSINIT TO FIX THIS 
 12689                                  ; PROBLEM AT THE REQUEST OF CP DOS. 				 
 12690                                  ; THE PROGRAM IS MODIFIED TO BE RUN ON MSINIT. Equates are defined in CMOSEQU.INC. 
 12691                                  ; This program will be called by CMOS_Clock_Read procedure. 	 
 12692                                  ;									 
 12693                                  ;  The following code CMOSCK is used to insure that the CMOS has not	 
 12694                                  ;	had its rate controls left in an invalid state on older AT's.
 12695                                  ;									 
 12696                                  ;	It checks for an AT model byte "FC" with a submodel type of
 12697                                  ;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate	 
 12698                                  ;	bits incase POST has not done it. This initilization routine	 
 12699                                  ;	is only needed once when DOS loads. It should be ran as soon	 
 12700                                  ;	as possible to prevent slow diskette access.			 
 12701                                  ;									 
 12702                                  ;	This code exposes one to DOS clearing CMOS setup done by a	 
 12703                                  ;	resident program that hides and re-boots the system.		 
 12704                                  ;									 
 12705                                  CMOSCK:					; CHECK AND RESET RTC RATE BITS 
 12706                                  									 
 12707                                  ;Model byte and Submodel byte were already determined in MSINIT.	 
 12708 0000363D 50                      		push	ax
 12709                                  
 12710                                  	; 16/06/2018 - Retro DOS v3.0
 12711                                  
 12712                                  	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)							 
 12713                                  
 12714                                  	;cmp	cs:Model_byte, 0FCh ;check for PC-AT model byte	 
 12715 0000363E 803E[B506]FC            		cmp	byte [MODEL_BYTE],0FCh	
 12716                                  	;			 	; EXIT IF NOT "FC" FOR A PC-AT
 12717 00003643 7523                    		JNE	short CMOSCK9	; Exit if not an AT model	 
 12718                                  									 
 12719                                  	;CMP	cs:Secondary_Model_Byte,06H  ; Is it 06 for the industral AT 
 12720 00003645 803E[B606]06            		CMP	byte [Secondary_Model_Byte],06h
 12721 0000364A 7407                    		JE	short CMOSCK4 	; Go reset CMOS periodic rate if 06 
 12722                                  	;CMP	cs:Secondary_Model_Byte,04H  ; Is it 00, 01, 02, or 03	 
 12723 0000364C 803E[B606]04            		cmp	byte [Secondary_Model_Byte],04h
 12724 00003651 7315                    		JNB	short CMOSCK9 	; EXIT if problem fixed by POST  
 12725                                  					; Also,Secondary_model_byte = 0 
 12726                                  					;   when AH=0c0h, int 15h failed.
 12727                                  CMOSCK4:				;	RESET THE CMOS PERIODIC RATE 
 12728                                  					;  Model=FC submodel=00,01,02,03 or 06 
 12729                                  
 12730                                  		;mov	al,CMOS_REG_A or NMI	;NMI disabled on return
 12731 00003653 B08A                    		mov	al,CMOS_REG_A + NMI	
 12732 00003655 B426                    		mov	ah,00100110b		;Set divider & rate selection
 12733 00003657 E83000                  		call	CMOS_WRITE
 12734                                  
 12735                                  		;mov	al,CMOS_REG_B or NMI	;NMI disabled on return
 12736 0000365A B08B                    		mov	al,CMOS_REG_B + NMI	
 12737 0000365C E80B00                  		call	CMOS_READ
 12738 0000365F 2407                    		and	al,00000111b		;clear SET,PIE,AIE,UIE,SQWE
 12739 00003661 88C4                    		mov	ah,al
 12740 00003663 B00B                    		mov	al,CMOS_REG_B		;NMI enabled on return
 12741 00003665 E82200                  		call	CMOS_WRITE
 12742                                  
 12743                                  CMOSCK9:					; EXIT ROUTINE		 
 12744 00003668 58                      		pop	ax							 
 12745 00003669 C3                      		RETN				; RETurn to caller		 
 12746                                  						;  Flags modifyied		 
 12747                                  							 
 12748                                  ;--- CMOS_READ ----------------------------------------------------------------- 
 12749                                  ;		READ BYTE FROM CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 12750                                  ;									       :
 12751                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE READ				       :
 12752                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 12753                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO READ		       :
 12754                                  ;									       :
 12755                                  ; OUTPUT: (AL)	VALUE AT LOCATION (AL) MOVED INTO (AL).  IF BIT 7 OF (AL) WAS  :
 12756                                  ;		ON THEN NMI LEFT DISABLED.  DURING THE CMOS READ BOTH NMI AND  :
 12757                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 12758                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 12759                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 12760                                  ;		ONLY THE (AL) REGISTER AND THE NMI STATE IS CHANGED.	       :
 12761                                  ;------------------------------------------------------------------------------- 
 12762                                  									 
 12763                                  CMOS_READ:				; READ LOCATION (AL) INTO (AL) 
 12764 0000366A 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 12765                                  
 12766 0000366B FA                      		cli
 12767 0000366C 53                      		push	bx
 12768 0000366D 50                      		push	ax		;save user NMI state
 12769 0000366E 0C80                    		or	al,NMI		;disable NMI for us
 12770 00003670 E670                    		out	CMOS_PORT,al
 12771 00003672 90                      		nop			;undocumented delay needed
 12772 00003673 E471                    		in	al,CMOS_DATA	;get data value
 12773                                  
 12774                                  		 ;set NMI state to user specified 
 12775 00003675 89C3                    		mov	bx,ax		;save data value
 12776 00003677 58                      		pop	ax		;get user NMI
 12777 00003678 2480                    		and	al,NMI
 12778 0000367A 0C0F                    		or	al,CMOS_SHUT_DOWN
 12779 0000367C E670                    		out	CMOS_PORT,al
 12780 0000367E 90                      		nop
 12781 0000367F E471                    		in	al,CMOS_DATA
 12782                                  
 12783 00003681 89D8                    		mov	ax,bx		;data value
 12784 00003683 5B                      		pop	bx
 12785                                  
 12786 00003684 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 12787 00003685 E80100                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 12788 00003688 C3                      		RETN			; RETURN WITH FLAGS RESTORED	 
 12789                                  									 
 12790                                  CMOS_POPF:				; POPF FOR LEVEL B- PARTS  
 12791 00003689 CF                      		IRET			; RETURN FAR AND RESTORE FLAGS	 
 12792                                  									 
 12793                                  							 
 12794                                  ;--- CMOS_WRITE ----------------------------------------------------------------
 12795                                  ;		WRITE BYTE TO CMOS SYSTEM CLOCK CONFIGURATION TABLE	       :
 12796                                  ;									       :
 12797                                  ; INPUT: (AL)=	CMOS TABLE ADDRESS TO BE WRITTEN TO			       :
 12798                                  ;		BIT    7 = 0 FOR NMI ENABLED AND 1 FOR NMI DISABLED ON EXIT    :
 12799                                  ;		BITS 6-0 = ADDRESS OF TABLE LOCATION TO WRITE		       :
 12800                                  ;	 (AH)=	NEW VALUE TO BE PLACED IN THE ADDRESSED TABLE LOCATION	       :
 12801                                  ;									       :
 12802                                  ; OUTPUT:	VALUE IN (AH) PLACED IN LOCATION (AL) WITH NMI LEFT DISABLED   :
 12803                                  ;		IF BIT 7 OF (AL) IS ON.  DURING THE CMOS UPDATE BOTH NMI AND   :
 12804                                  ;		NORMAL INTERRUPTS ARE DISABLED TO PROTECT CMOS DATA INTEGRITY. :
 12805                                  ;		THE CMOS ADDRESS REGISTER IS POINTED TO A DEFAULT VALUE AND    :
 12806                                  ;		THE INTERRUPT FLAG RESTORED TO THE ENTRY STATE ON RETURN.      :
 12807                                  ;		ONLY THE CMOS LOCATION AND THE NMI STATE IS CHANGED.	       :
 12808                                  ;-------------------------------------------------------------------------------
 12809                                  									 
 12810                                  CMOS_WRITE:				; WRITE (AH) TO LOCATION (AL) 
 12811 0000368A 9C                      		PUSHF			; SAVE INTERRUPT ENABLE STATUS AND FLAGS 
 12812 0000368B 50                      		PUSH	AX		; SAVE WORK REGISTER VALUES	 
 12813                                  
 12814 0000368C FA                      		cli
 12815 0000368D 50                      		push	ax		;save user NMI state
 12816 0000368E 0C80                    		or	al,NMI		;disable NMI for us
 12817 00003690 E670                    		out	CMOS_PORT,al
 12818 00003692 90                      		nop
 12819 00003693 88E0                    		mov	al,ah
 12820 00003695 E671                    		out	CMOS_DATA,al	;write data
 12821                                  
 12822                                  		 ;set NMI state to user specified 
 12823 00003697 58                      		pop	ax 		;get user NMI
 12824 00003698 2480                    		and	al,NMI
 12825 0000369A 0C0F                    		or	al,CMOS_SHUT_DOWN
 12826 0000369C E670                    		out	CMOS_PORT,al
 12827 0000369E 90                      		nop
 12828 0000369F E471                    		in	al,CMOS_DATA
 12829                                  
 12830 000036A1 58                      		POP	AX		; RESTORE WORK REGISTERS	 
 12831 000036A2 0E                      		PUSH	CS		; *PLACE CODE SEGMENT IN STACK AND 
 12832 000036A3 E8E3FF                  		CALL	CMOS_POPF	; *HANDLE POPF FOR B- LEVEL 80286 
 12833 000036A6 C3                      		RETN
 12834                                  
 12835                                  ;-----------------------------------------------------------------------------
 12836                                  ; 03/06/2018 - Retro DOS v3.0 
 12837                                  	
 12838                                  		; 07/04/2018 - Retro DOS v2.0
 12839                                  
 12840                                  ; *** SYSINIT1.ASM ***
 12841                                  ; ----------------------------------------------------------------------------
 12842                                  ; START OF MSDOS 3.3 SYSINIT CODE - SYSINIT1.ASM - 24/07/1987
 12843                                  ; ----------------------------------------------------------------------------
 12844                                  ; 02/06/2018 - Retro DOS v3.0	
 12845                                  ; 25/03/2018 - Retro DOS v2.0
 12846                                  
 12847                                  _SYSINIT: 	; 05/07/2018
 12848                                  		;JMP	GOINIT
 12849                                  
 12850                                  ; ..SYSINIT DATA .............................................................
 12851                                  
 12852                                  GOINIT:
 12853                                  		; 03/07/2018
 12854                                  Move_Myself:
 12855                                  		; 03/05/2018
 12856                                  		; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
 12857                                  		; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
 12858                                  
 12859                                  		SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
 12860                                  
 12861                                  		; 28/03/2018
 12862                                          	;CLD
 12863 000036A7 BE[D036]                        	MOV     SI,SYSINIT_START   ; MSSTACK (05/07/2018)
 12864 000036AA 31FF                            	XOR     DI,DI
 12865                                  		; 19/03/2018
 12866                                  	       	;mov	CX,[SYSINIT_START+MEMORY_SIZE]
 12867                                  		; 05/07/2018
 12868 000036AC 8B0E[4E39]              	       	mov	CX,[SYSINIT+MEMORY_SIZE]
 12869                                  
 12870 000036B0 B83C18                  		MOV	AX,SYSINITSIZE + 15 ; 03/05/2018
 12871 000036B3 D1E8                    		SHR     AX,1                    ; Divide by 16 for paras
 12872 000036B5 D1E8                    		SHR     AX,1
 12873 000036B7 D1E8                    		SHR     AX,1
 12874 000036B9 D1E8                    		SHR     AX,1
 12875 000036BB 29C1                    		SUB     CX,AX
 12876 000036BD 8EC1                    		MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
 12877 000036BF B92E18                  		MOV     CX,SYSINITSIZE + 1
 12878 000036C2 D1E9                    		SHR     CX,1                    ; Divide by 2 to get words
 12879 000036C4 F3A5                    		REP     MOVSW                   ; RELOCATE SYSINIT
 12880                                  
 12881 000036C6 06                      		PUSH    ES
 12882                                  		;XOR	AX,AX ; 0
 12883                                  		;PUSH	AX
 12884                                  
 12885                                  		; 03/07/2018
 12886                                  		;PUSH	CX ; 0
 12887                                  		; 07/07/2019
 12888                                  		; 29/06/2019 - Retro DOS v3.1
 12889 000036C7 B86002                  		mov	ax,0260h ; ((**)) ; 'sysinit:' offset in SYSINIT2.ASM
 12890                                  		;mov	ax,07F0h ; 01/07/2019
 12891 000036CA 50                      		push	ax
 12892                                  
 12893 000036CB CB                      		RETF	; far jump to final location of SYSINIT code
 12894 000036CC 90<rep 4h>              align 16
 12895                                  
 12896                                  ; ----------------------------------------------------------------------------
 12897                                  ; MSDOS 3.3 -IBMBIO.COM- SYSINIT CODE -will be relocated-
 12898                                  ; ----------------------------------------------------------------------------
 12899                                  ; 11/06/2018 - Retro DOS v3.0 
 12900                                  
 12901                                  SYSINIT_START equ $
 12902                                  
 12903                                  ; 07/07/2019
 12904                                  ; 29/06/2019 - Retro DOS v3.1
 12905                                  ; (NOTE: Following address is sysinit code start address after msstack code
 12906                                  ;  in 'sysinit2.asm', it is 0252h for current SYSINIT, 29/06/2019)	
 12907                                  SYSINIT equ SYSINIT_START + 0260h ; ((**))
 12908                                  ;SYSINIT equ SYSINIT_START + 07F0h ; ((**)) ; 01/07/2019
 12909                                  
 12910                                  sysinit_code_start:
 12911                                  		; 22/11/2022
 12912                                  		; 03/08/2019 ('sysinit22.asm' last modification)
 12913 000036D0 <bin 182Dh>             		incbin	'SYSINIT21.BIN' ; Retro DOS 3.1 - MSDOS 3.3 'SYSINIT'
 12914                                  sysinit_code_end:
 12915 00004EFD 90                      		db 90h
 12916                                  
 12917 00004EFE 90<rep 2h>              align 16 ; Paragraph alignment is necessary here for MSDOS kernel relocation
 12918                                  
 12919                                  ; ----------------------------------------------------------------------------
 12920                                  ; START OF MSDOS 3.3 -IBMDOS.COM- KERNEL CODE (MSDOS.SYS) -will be relocated-
 12921                                  ; ----------------------------------------------------------------------------
 12922                                  ; 11/06/2018 - Retro DOS v3.0 
 12923                                  
 12924                                  MSDOS_BIN_OFFSET:  ; this offset must be paragraph aligned
 12925                                  		; 16/12/2022 (BugFix)
 12926                                  		; 22/11/2022 (BugFix)
 12927                                  		; 01/08/2019 ('msdos33.asm' last modification)
 12928                                  		; 29/06/2019 - Retro DOS 3.1 (msdos3.asm)
 12929 00004F00 <bin 79DFh>             		incbin	'MSDOS33.BIN'
 12930                                  msdos_bin_size	equ $ - MSDOS_BIN_OFFSET
 12931                                  
 12932                                  		;db 90h
 12933 0000C8DF 90                      align 2
 12934                                  END_OF_KERNEL equ $
