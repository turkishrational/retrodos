     1                                  ; ****************************************************************************
     2                                  ; MSDOS3.BIN (MSDOS 3.3 Kernel) - RETRO DOS v3.2 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 16/12/2022 (BugFix) - (Previous: 22/11/2022)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 07/07/2019 (Retro DOS 3.0), 29/06/2019 (Retro DOS 3.1)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.14  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm msdos3.asm -l msdos3.txt -o MSDOS3.BIN)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'msdos2.s' file of Retro DOS 2.0 source code (04/05/2018)
    13                                  ; ----------------------------------------------------------------------------
    14                                  ; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    15                                  ; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
    16                                  ; ****************************************************************************
    17                                  ; main file: 'retrodos3.s'
    18                                  ; incbin 'MSDOS3.BIN' ; (DOSGROUP CODE SEGMENT)
    19                                  ; ----------------------------------------------------------------------------
    20                                  ; 07/07/2018 - Erdogan Tan
    21                                  ; (Note: I have not got MSDOS 3.3 kernel source files; so, I need to continue
    22                                  ; by using disassembled MSDOS.SYS -v3.3- and MSDOS 6.0 kernel source files.)
    23                                  ; ----------------------------------------------------------------------------
    24                                  ; MSDOS 6.0 Kernel source files:
    25                                  ;	MSDATA.ASM, 
    26                                  ; 		(MSHEAD.ASM, MSCONST.ASM,CONST2.ASM, MS_DATA.ASM,
    27                                  ;		DOSTAB.ASM, LMSTUB.ASM, WPATCH.INC)
    28                                  ;	MSTABLE.ASM, MSCODE.ASM, MSDOSME.ASM (DOSMES.INC), TIME.ASM,
    29                                  ;	GETSET.ASM, PARSE.ASM, MISC.ASM, MISC2.ASM, CRIT.ASM, CPMIO.ASM,
    30                                  ;	CPMIO2.ASM, FCBIO.ASM, FCBIO2.ASM, SEARCH.ASM, PATH.ASM, IOCTL.ASM,
    31                                  ;	DELETE.ASM, RENAME.ASM, FINFO.ASM, DUP.ASM, CREATE.ASM, OPEN.ASM,
    32                                  ;	DINFO.ASM, ISEARCH.ASM, BUF.ASM, ABORT.ASM,CLOSE.ASM, DIRCALL.ASM,
    33                                  ;	DISK.ASM, DISK2.ASM, DISK3.ASM, DIR.ASM, DIR2.ASM, DEV.ASM,
    34                                  ;	MKNODE.ASM, ROM.ASM, FCB.ASM, MSCTRLC.ASM, FAT.ASM, MSPROC.ASM
    35                                  ;	ALLOC.ASM, SRVCALL.ASM, UTIL.ASM, MACRO.ASM, MACRO2.ASM, HANDLE.ASM
    36                                  ;	FILE.ASM, LOCK.ASM, ROMFIND.ASM, SHARE.ASM, MSINIT.ASM, ORIGIN.ASM
    37                                  ;
    38                                  ; MSDOS 2.0 Kernel source files:
    39                                  ; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
    40                                  ;	MSCODE.ASM
    41                                  ;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM
    42                                  
    43                                  ; -----------------------------------------
    44                                  ; 20/05/2019 - MSDOS3.S - Retro DOS v3.0
    45                                  ; 29/06/2019 - MSDOS3.ASM - Retro DOS v3.1
    46                                  ; 17/07/2019 - MSDOS33.ASM - Retro DOS v3.2
    47                                  ; -----------------------------------------
    48                                  
    49                                  ;============================================================================
    50                                  ; DOSLINK
    51                                  ;============================================================================
    52                                  ;msdos mscode dosmes misc getset dircall alloc dev dir +
    53                                  ;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
    54                                  ;stdio time xenix xenix2
    55                                  
    56                                  ;============================================================================
    57                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    58                                  ; output in TASM syntax (July 2018 -> NASM syntax) [ IBMDOS.COM, 17/03/1987 ]
    59                                  ;============================================================================
    60                                  ;
    61                                  ; ###########################################################################
    62                                  ; #	This file is generated by The Interactive Disassembler (IDA)	    #
    63                                  ; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
    64                                  ; #			 Licensed to: Freeware version			    #
    65                                  ; ###########################################################################
    66                                  ;
    67                                  ; Input	MD5   :	EF2ADCA1CB3882118FD247DD4C672C81
    68                                  
    69                                  ; ---------------------------------------------------------------------------
    70                                  ; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\MSDOS33.BIN
    71                                  ; Format      :	Binary file
    72                                  ; Base Address:	0000h Range: 0000h - 75CFh Loaded length: 75CFh
    73                                  ;============================================================================
    74                                  ; MSDOS33.BIN = IBMDOS.COM, 17/03/1987, 30159 bytes (IBM PC DOS 3.30 kernel)
    75                                  
    76                                  ;============================================================================
    77                                  ; MSDOS.ASM
    78                                  ;============================================================================
    79                                  
    80                                  ;TITLE   Standard MSDOS
    81                                  ;NAME    MSDOS_2
    82                                  
    83                                  ; Number of disk I/O buffers
    84                                  
    85                                  ;	INCLUDE STDSW.ASM
    86                                  ;       INCLUDE MSHEAD.ASM
    87                                  ;       INCLUDE MSDATA.ASM
    88                                  
    89                                  ;	END
    90                                  
    91                                  ;============================================================================
    92                                  ; STDSW.ASM
    93                                  ;============================================================================
    94                                  
    95                                  TRUE    EQU     0FFFFH
    96                                  FALSE   EQU     ~TRUE ; NOT TRUE
    97                                  
    98                                  ; Use the switches below to produce the standard Microsoft version or the IBM
    99                                  ; version of the operating system
   100                                  ;MSVER   EQU     false
   101                                  ;IBM     EQU     true
   102                                  ;WANG    EQU     FALSE
   103                                  ;ALTVECT EQU     FALSE
   104                                  
   105                                  ; Set this switch to cause DOS to move itself to the end of memory
   106                                  ;HIGHMEM EQU     FALSE
   107                                  
   108                                  ;	IF      IBM
   109                                  ESCCH   EQU     0			; character to begin escape seq.
   110                                  CANCEL  EQU     27			;Cancel with escape
   111                                  TOGLINS EQU     TRUE			;One key toggles insert mode
   112                                  TOGLPRN EQU     TRUE			;One key toggles printer echo
   113                                  ZEROEXT EQU     TRUE
   114                                  ;       ELSE
   115                                  ;       IF      WANG			;Are we assembling for WANG?
   116                                  ;ESCCH   EQU     1FH			;Yes. Use 1FH for escape character
   117                                  ;       ELSE
   118                                  ;ESCCH   EQU     1BH
   119                                  ;       ENDIF
   120                                  ;CANCEL  EQU     "X"-"@"		;Cancel with Ctrl-X
   121                                  ;TOGLINS EQU     WANG			;Separate keys for insert mode on
   122                                  					;and off if not WANG
   123                                  ;TOGLPRN EQU     FALSE			;Separate keys for printer echo on
   124                                  					;and off
   125                                  ;ZEROEXT EQU     TRUE
   126                                  ;        ENDIF
   127                                  
   128                                  ;============================================================================
   129                                  ; MSHEAD.ASM
   130                                  ;============================================================================
   131                                  
   132                                  ;--------------------------------------------------------------
   133                                  ; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
   134                                  ;--------------------------------------------------------------
   135                                  
   136                                  ; MS-DOS High-performance operating system for the 8086  version 1.28
   137                                  ;        by Microsoft MSDOS development group:
   138                                  ;           Tim Paterson (Ret.)
   139                                  ;           Aaron Reynolds
   140                                  ;           Nancy Panners (Parenting)
   141                                  ;           Mark Zbikowski
   142                                  ;           Chris Peters (BIOS) (ret.)
   143                                  
   144                                  ; ****************** Revision History *************************
   145                                  ;          >> EVERY change must noted below!! <<
   146                                  ;
   147                                  ; 0.34 12/29/80 General release, updating all past customers
   148                                  ; 0.42 02/25/81 32-byte directory entries added
   149                                  ; 0.56 03/23/81 Variable record and sector sizes
   150                                  ; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
   151                                  ; 0.74 04/15/81 Recognize I/O devices with file names
   152                                  ; 0.75 04/17/81 Improve and correct buffer handling
   153                                  ; 0.76 04/23/81 Correct directory size when not 2^N entries
   154                                  ; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
   155                                  ; 1.00 04/28/81 Renumber for general release
   156                                  ; 1.01 05/12/81 Fix bug in `STORE'
   157                                  ; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
   158                                  ;               RENAME fix, general cleanup
   159                                  ; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
   160                                  ; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
   161                                  ; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
   162                                  ; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
   163                                  ;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
   164                                  ;               of smaller improvements
   165                                  ; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
   166                                  ; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
   167                                  ; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
   168                                  ;               zero extent field in IBM version (back to 1.01!)
   169                                  ; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
   170                                  ; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
   171                                  ; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
   172                                  ;               is searched first when possible to minimize I/O
   173                                  ;      03/03/82 STORE routine optimized to tack on partial sector tail as
   174                                  ;               full sector write when file is growing
   175                                  ;      03/09/82 Multiple I/O buffers
   176                                  ;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
   177                                  ;               of directory (infinite loop possible otherwise), DSKRESET
   178                                  ;               must invalidate all buffers (disk and directory).
   179                                  ; 1.27 03/31/82 Installable device drivers
   180                                  ;                 Function call 47 - Get pointer to device table list
   181                                  ;                 Function call 48 - Assign CON AUX LIST
   182                                  ;      04/01/82 Spooler interrupt (INT 28) added.
   183                                  ; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
   184                                  ;               call entries.  Most CS relative references changed to SS
   185                                  ;               relative with an eye toward putting a portion of the DOS in
   186                                  ;               ROM.  DOS source also broken into header, data and code pieces
   187                                  ;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
   188                                  ;               return the current values.
   189                                  ;      04/15/82 INDOS flag implemented for interrupt processing along with
   190                                  ;               call to return flag location (call 29)
   191                                  ;      04/15/82 Volume ID attribute added
   192                                  ;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
   193                                  ;               avoid a CS relative reference.
   194                                  ;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
   195                                  ;      04/20/82 Added INT int_upooler into loop ^S wait
   196                                  ;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
   197                                  ;               call 49.
   198                                  ;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
   199                                  ;               address of DPB
   200                                  ;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
   201                                  ;               writting to console device via file I/O.  Added a console
   202                                  ;               output attribute to devices.
   203                                  ;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
   204                                  ;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
   205                                  ;               as devices....  pipes, redirection now possible
   206                                  ;      04/30/82 Expanded GETLIST call to 2.0 standard
   207                                  ;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
   208                                  ;               (data segment) stashed in ES, INT int_fatal_abort routines must
   209                                  ;               preserve ES.  This mod so HARDERR can be ROMed.
   210                                  ; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
   211                                  ;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
   212                                  ;               out back about 1.27 or so (oops).  ARR
   213                                  ; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
   214                                  ; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
   215                                  ;               RMDIR Xenix calls
   216                                  ; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
   217                                  ; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
   218                                  ;               Frees up lots of memory.
   219                                  ; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
   220                                  ;               system buffers
   221                                  ; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
   222                                  ; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
   223                                  ; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
   224                                  ;               changed to set file handle environment.
   225                                  ; 2.00 08/01/82 Number for IBM release
   226                                  ;      01/19/83 No environ bug in EXEC
   227                                  ;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
   228                                  ;      01/19/83 Performance bug fix in cooked write to NUL
   229                                  ;      01/27/83 Growcnt fixed for 32-bits
   230                                  ;      01/27/83 Find-first problem after create
   231                                  ; 2.01 02/17/83 International DOS
   232                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   233                                  ;               an IBM PC
   234                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
   235                                  ; (MSHEAD.ASM, MSDOS 6.0, 1991) - mshead.asm 1.1 85/04/10 -
   236                                  ; 2.10 03/09/83 Start of NETWORK support
   237                                  ;		New Buffer structure
   238                                  ;		New Sytem file table structure
   239                                  ;		FCB moved to internal representation
   240                                  ;		DOS re-organized
   241                                  ; 2.11 04/21/83 Continuation of 2.10, preliminary Network
   242                                  ;		device interface.
   243                                  ; 2.11 08/12/83 Dos split into several more modules for assembly on
   244                                  ;               an IBM PC
   245                                  ; 2.50 09/12/83 More network stuff
   246                                  ;
   247                                  ; *************************************************************
   248                                  
   249                                  ; ----------------------------------------------------------------------------
   250                                  ; EQUATES
   251                                  
   252                                  ; Interrupt Entry Points:
   253                                  
   254                                  ; INTBASE:      ABORT
   255                                  ; INTBASE+4:    COMMAND
   256                                  ; INTBASE+8:    BASE EXIT ADDRESS
   257                                  ; INTBASE+C:    CONTROL-C ABORT
   258                                  ; INTBASE+10H:  FATAL ERROR ABORT
   259                                  ; INTBASE+14H:  BIOS DISK READ
   260                                  ; INTBASE+18H:  BIOS DISK WRITE
   261                                  ; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
   262                                  ; INTBASE+20H:  SPOOLER INTERRUPT
   263                                  ; INTBASE+40H:  Long jump to CALL entry point
   264                                  
   265                                  ENTRYPOINTSEG   EQU     0CH
   266                                  MAXDIF          EQU     0FFFH
   267                                  SAVEXIT         EQU     10
   268                                  ;08/07/2018 - Retro DOS v3.0
   269                                  ;WRAPOFFSET	EQU	0FEF0h  ; (MISC.ASM, MSDOS 6.0, 1991)
   270                                  
   271                                         ; INCLUDE DOSSYM.ASM
   272                                         ; INCLUDE DEVSYM.ASM
   273                                  
   274                                  ; SUBTTL ^C, terminate/abort/exit and Hard error actions
   275                                  ; PAGE
   276                                  ; There are three kinds of context resets that can occur during normal DOS
   277                                  ; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
   278                                  ; be handles in a clean fashion that allows nested executions along with the
   279                                  ; ability to trap one's own errors.
   280                                  ;
   281                                  ; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
   282                                  ;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
   283                                  ;           follows:
   284                                  ;
   285                                  ;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
   286                                  ;           Save it in static memory.
   287                                  ;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
   288                                  ;
   289                                  ;           The interrupt service routine must preserve all registers and
   290                                  ;           return carry set iff the operation is to be aborted (via abort
   291                                  ;           system call), otherwise, carry is reset and the operation is
   292                                  ;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
   293                                  ;           RESULTS.
   294                                  ;
   295                                  ;           To restore original ^C processing (done on terminate/abort/exit),
   296                                  ;           restore INT int_ctrl_c from the saved vector.
   297                                  ;
   298                                  ; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
   299                                  ;           also preserve registers and return one of three values in AL: 0 and
   300                                  ;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
   301                                  ;           himself is not to issue the abort, rather, the dos will do it for
   302                                  ;           him by simulating a normal abort/exit system call.  ANY DEVIATION
   303                                  ;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   304                                  ;
   305                                  ; terminate/abort/exit -- The user may not, under any circumstances trap an
   306                                  ;           abort call.  This is reserved for knowledgeable system programs.
   307                                  ;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
   308                                  
   309                                  ;SUBTTL SEGMENT DECLARATIONS
   310                                  
   311                                  ; The following are all of the segments used.  They are declared in the order
   312                                  ; that they should be placed in the executable
   313                                  
   314                                  ;
   315                                  ; segment ordering for MSDOS
   316                                  ;
   317                                  
   318                                  ;START           SEGMENT BYTE PUBLIC 'START'
   319                                  ;START           ENDS
   320                                  
   321                                  ;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
   322                                  ;CONSTANTS       ENDS
   323                                  
   324                                  ;DATA            SEGMENT WORD PUBLIC 'DATA'
   325                                  ;DATA            ENDS
   326                                  
   327                                  ;CODE            SEGMENT BYTE PUBLIC 'CODE'
   328                                  ;CODE            ENDS
   329                                  
   330                                  ;LAST            SEGMENT BYTE PUBLIC 'LAST'
   331                                  ;LAST            ENDS
   332                                  
   333                                  ;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST
   334                                  
   335                                  ; The following segment is defined such that the data/const classes appear
   336                                  ; before the code class for ROMification
   337                                  
   338                                  ;START		SEGMENT BYTE PUBLIC 'START'
   339                                  ;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
   340                                  ;		JMP     DOSINIT
   341                                  ;START		ENDS
   342                                  
   343                                  ;============================================================================
   344                                  ; DOSSYM.ASM
   345                                  ;============================================================================
   346                                  
   347                                  ;<Control character definitions>
   348                                  
   349                                  c_DEL       EQU     7Fh         ;    ASCII rubout or delete previous char
   350                                  c_BS        EQU     08h         ; ^H ASCII backspace
   351                                  c_CR        EQU     0Dh         ; ^M ASCII carriage return
   352                                  c_LF        EQU     0Ah         ; ^J ASCII linefeed
   353                                  c_ETB       EQU     17h         ; ^W ASCII end of transmission
   354                                  c_NAK       EQU     15h         ; ^U ASCII negative acknowledge
   355                                  c_ETX       EQU     03h         ; ^C ASCII end of text
   356                                  c_HT        EQU     09h         ; ^I ASCII tab
   357                                  
   358                                  ;============================================================================
   359                                  ; BPB.INC, MSDOS 3.3, 1987
   360                                  ;============================================================================
   361                                  ; 09/07/2018 - Retro DOS v3.0
   362                                  
   363                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   364                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   365                                  ;									   ;
   366                                  
   367                                  ; BIOS PARAMETER BLOCK DEFINITION
   368                                  ; THIS STRUCTURE IS USED TO BUILD A FULL DPB
   369                                  
   370                                  struc BPBLOCK
   371 00000000 ????                    .SECSZ: resw 1		; Size in bytes of physical sector
   372 00000002 ??                      .CLUS:  resb 1		; Sectors/Alloc unit
   373 00000003 ????                    .RES:   resw 1		; Number of reserved sectors
   374 00000005 ??                      .FTCNT: resb 1		; Number of FATs
   375 00000006 ????                    .DRCNT: resw 1		; Number of directory entries
   376 00000008 ????                    .SCCNT: resw 1		; Total number of sectors
   377 0000000A ??                      .MEDIA: resb 1		; Media descriptor byte
   378 0000000B ????                    .FTSEC:	resw 1		; Number of sectors taken up by one FAT
   379                                  .size:
   380                                  endstruc
   381                                  
   382                                  ; 09/07/2018 - Retro DOS v3.0
   383                                  ; (BPB.INC, MSDOS 6.0, 1991)
   384                                  
   385                                  ;**	BIOS PARAMETER BLOCK DEFINITION
   386                                  ;
   387                                  ;	The BPB contains information about the disk structure. It dates
   388                                  ;	back to the earliest FAT systems and so FAT information is
   389                                  ;	intermingled with physical driver information.
   390                                  ;
   391                                  ;	A boot sector contains a BPB for its device; for other disks
   392                                  ;	the driver creates a BPB. DOS keeps copies of some of this
   393                                  ;	information in the DPB.
   394                                  ;
   395                                  ;	The BDS structure contains a BPB within it. 
   396                                  
   397                                  struc A_BPB
   398 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   399 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   400 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   401 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   402 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   403 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   404 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   405 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   406 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   407 0000000F ????                    .BPB_HEADS:		resw	1
   408 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   409 00000013 ????                    			resw	1
   410 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   411 00000017 ????                    			resw	1
   412 00000019 ????????????            			resb	6	; NOTE:  many times these
   413                                  ;					; 	 6 bytes are omitted
   414                                  ;					;	 when BPB manipulations
   415                                  ;					;	 are performed!
   416                                  .size:
   417                                  endstruc
   418                                  
   419                                  ;                                                                          ;
   420                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   421                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   422                                  
   423                                  ;============================================================================
   424                                  ; BUFFER.INC, MSDOS 6.0, 1991
   425                                  ;============================================================================
   426                                  ; 04/05/2019 - Retro DOS v4.0
   427                                  
   428                                  ; 22/07/2019 - Retro DOS v3.2
   429                                  
   430                                  ; <Disk I/O Buffer Header>
   431                                  
   432                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   433                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   434                                  ;									   ;
   435                                  
   436                                  ; Field definition for I/O buffer information
   437                                  
   438                                  struc BUFFINFO
   439                                  ; MSDOS 3.3
   440 00000000 ????????                .buf_link:	resd 1		; Pointer to next buffer in list  ; Retro DOS v3.2
   441                                  ; MSDOS 6.0
   442                                  ;.buf_next:	resw 1		; Pointer to next buffer in list
   443                                  ;.buf_prev:	resw 1		; Pointer to prev buffer in list
   444 00000004 ??                      .buf_ID:	resb 1		; Drive of buffer (bit 7 = 0)
   445                                  				; SFT table index (bit 7 = 1)
   446                                  				; = FFH if buffer free
   447 00000005 ??                      .buf_flags:	resb 1		; Bit 7 = 1 if Remote file buffer
   448                                  				;	= 0 if Local device buffer
   449                                  				; Bit 6 = 1 if buffer dirty
   450                                  				; Bit 5 = Reserved
   451                                  				; Bit 4 = Search bit (bit 7 = 1)
   452                                  				; Bit 3 = 1 if buffer is DATA
   453                                  				; Bit 2 = 1 if buffer is DIR
   454                                  				; Bit 1 = 1 if buffer is FAT
   455                                  				; Bit 0 = Reserved
   456 00000006 ????????                .buf_sector:	resd 1		; Sector number of buffer (flags bit 7 = 0)
   457                                  ; The next two items are often refed as a word (flags bit 7 = 0)
   458 0000000A ??                      .buf_wrtcnt:	resb 1		; For FAT sectors, # times sector written out
   459 0000000B ????                    .buf_wrtcntinc:	resw 1		; "   "     "   , # sectors between each write
   460 0000000D ????????                .buf_DPB:	resd 1		; Pointer to drive parameters
   461 00000011 ????                    .buf_fill:	resw 1		; How full buffer is (flags bit 7 = 1)
   462 00000013 ??                      .buf_reserved:	resb 1		; make DWORD boundary for 386
   463                                  .size:	; 20 bytes
   464                                  endstruc
   465                                  
   466                                  %define buf_offset	BUFFINFO.buf_sector ; 22/07/2019
   467                                  				;For buf_flags bit 7 = 1, this is the byte
   468                                  				;offset of the start of the buffer in
   469                                  				;the file pointed to by buf_ID. Thus
   470                                  				;the buffer starts at location
   471                                  				;buf_offset in the file and contains
   472                                  				;buf_fill bytes.
   473                                  
   474                                  BUFINSIZ        EQU     BUFFINFO.size
   475                                  
   476                                  buf_Free	EQU	0FFh	; buf_id of free buffer
   477                                  
   478                                  ;Flag byte masks
   479                                  buf_isnet	EQU	10000000b
   480                                  buf_dirty	EQU	01000000b
   481                                  ;***
   482                                  buf_visit	EQU	00100000b
   483                                  ;***
   484                                  buf_snbuf	EQU	00010000b
   485                                  
   486                                  buf_isDATA	EQU	00001000b
   487                                  buf_isDIR	EQU	00000100b
   488                                  buf_isFAT	EQU	00000010b
   489                                  buf_type_0	EQU	11110001b	; AND sets type to "none"
   490                                  
   491                                  buf_NetID	EQU	BUFINSIZ
   492                                  
   493                                  ;                                                                          ;
   494                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   495                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   496                                  
   497                                  ; <User stack inside of system call>
   498                                  ; Location of user registers relative user stack pointer
   499                                  
   500                                  struc	user_env   ; user_environ
   501 00000000 ????                    .user_AX: resw 1
   502 00000002 ????                    .user_BX: resw 1
   503 00000004 ????                    .user_CX: resw 1
   504 00000006 ????                    .user_DX: resw 1
   505 00000008 ????                    .user_SI: resw 1
   506 0000000A ????                    .user_DI: resw 1
   507 0000000C ????                    .user_BP: resw 1
   508 0000000E ????                    .user_DS: resw 1
   509 00000010 ????                    .user_ES: resw 1
   510 00000012 ????                    .user_IP: resw 1
   511 00000014 ????                    .user_CS: resw 1
   512 00000016 ????                    .user_F:  resw 1
   513                                  .size:
   514                                  endstruc
   515                                  
   516                                  ; 09/07/2018 - Retro DOS v3.0
   517                                  ; (VECTOR.INC, MSDOS 3.3, 1987)
   518                                  ; ----------------------------------------------------------------------------
   519                                  
   520                                  ; <interrupt definitions>
   521                                  
   522                                  INTTAB          EQU     20H
   523                                  INTBASE         EQU     4 * INTTAB
   524                                  ENTRYPOINT      EQU     INTBASE+40H
   525                                  
   526                                  ;	IF      ALTVECT
   527                                  ;ALTTAB  EQU     0F0H
   528                                  ;ALTBASE EQU     4 * ALTTAB
   529                                  ;	ENDIF
   530                                  
   531                                  ;
   532                                  ; interrupt assignments
   533                                  ;
   534                                  ;	IF	NOT ALTVECT
   535                                  int_abort	    EQU     INTTAB	; abort process
   536                                  int_command	    EQU     int_abort+1 ; call MSDOS
   537                                  int_terminate	    EQU     int_abort+2 ; int to terminate address
   538                                  int_ctrl_c	    EQU     int_abort+3 ; ^c trapper
   539                                  int_fatal_abort     EQU     int_abort+4 ; hard disk error
   540                                  int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   541                                  int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   542                                  int_keep_process    EQU     int_abort+7 ; terminate program and stay
   543                                  					; resident
   544                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   545                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   546                                  ;									   ;
   547                                  int_spooler	    EQU     int_abort+8 ; spooler call
   548                                  int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   549                                  int_IBM 	    EQU     int_abort+10; critical section maintenance
   550                                  ;									   ;
   551                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   552                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   553                                  ;	ELSE
   554                                  ;int_abort	    EQU     INTTAB	; abort process
   555                                  ;int_command	    EQU     int_abort+1 ; call MSDOS
   556                                  ;int_terminate	    EQU     ALTTAB	; int to terminate address
   557                                  ;int_ctrl_c	    EQU     int_terminate+1 ; ^c trapper
   558                                  ;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
   559                                  ;int_disk_read	    EQU     int_abort+5 ; logical sector disk read
   560                                  ;int_disk_write	    EQU     int_abort+6 ; logical sector disk write
   561                                  ;int_keep_process   EQU     int_abort+7 ; terminate program and stay resident
   562                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   563                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   564                                  ;									   ;
   565                                  ;int_spooler	    EQU     int_terminate+3 ; spooler call
   566                                  ;int_fastcon	    EQU     int_abort+9 ; fast CON interrupt
   567                                  ;									   ;
   568                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   569                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   570                                  ;	ENDIF
   571                                  
   572                                  addr_int_abort		EQU    4 * int_abort
   573                                  addr_int_command	EQU    4 * int_command
   574                                  addr_int_terminate	EQU    4 * int_terminate
   575                                  addr_int_ctrl_c 	EQU    4 * int_ctrl_c
   576                                  addr_int_fatal_abort	EQU    4 * int_fatal_abort
   577                                  addr_int_disk_read	EQU    4 * int_disk_read
   578                                  addr_int_disk_write	EQU    4 * int_disk_write
   579                                  addr_int_keep_process	EQU    4 * int_keep_process
   580                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   581                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   582                                  ;									   ;
   583                                  addr_int_spooler	EQU    4 * int_spooler
   584                                  addr_int_fastcon	EQU    4 * int_fastcon
   585                                  addr_int_IBM		EQU    4 * int_IBM
   586                                  ;									   ;
   587                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   588                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   589                                  
   590                                  
   591                                  ; <Disk map>
   592                                  ;  MSDOS partitions the disk into 4 sections:
   593                                  ;
   594                                  ;  phys sector 0:   +-------------------+
   595                                  ;       |           | boot/reserved     |
   596                                  ;       |           +-------------------+
   597                                  ;       |           |  File allocation  |
   598                                  ;       v           |      table(s)     |
   599                                  ;                   |  (multiple copies |
   600                                  ;                   |     are kept)     |
   601                                  ;                   +-------------------+
   602                                  ;                   |     Directory     |
   603                                  ;                   +-------------------+
   604                                  ;                   |     File space    |
   605                                  ;                   +-------------------+
   606                                  ;                   |   Unaddressable   |
   607                                  ;                   |  (to end of disk) |
   608                                  ;                   +-------------------+
   609                                  ;
   610                                  ; All partition boundaries are sector boundaries.  The size of the FAT is
   611                                  ; adjusted to maximize the file space addressable.
   612                                  
   613                                  ; BREAK <Directory entry>
   614                                  
   615                                  ;
   616                                  ;       +---------------------------+
   617                                  ;       |  (12 BYTE) filename/ext   |       0       0
   618                                  ;       +---------------------------+
   619                                  ;       |     (BYTE) attributes     |       11      B
   620                                  ;       +---------------------------+
   621                                  ;       |    (10 BYTE) reserved     |       12      C
   622                                  ;       +---------------------------+
   623                                  ;       | (WORD) time of last write |       22      16
   624                                  ;       +---------------------------+
   625                                  ;       | (WORD) date of last write |       24      18
   626                                  ;       +---------------------------+
   627                                  ;       |   (WORD) First cluster    |       26      1A
   628                                  ;       +---------------------------+
   629                                  ;       |     (DWORD) file size     |       28      1C
   630                                  ;       +---------------------------+
   631                                  ;
   632                                  ;   First byte of filename  = E5 -> free directory entry
   633                                  ;                           = 00 -> end of allocated directory
   634                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   635                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   636                                  ;
   637                                  struc dir_entry
   638 00000000 <res Bh>                .dir_name:	resb 11			; file name
   639 0000000B ??                      .dir_attr:	resb 1			; attribute bits
   640 0000000C <res Ah>                .dir_pad:	resb 10			; reserved for expansion
   641 00000016 ????                    .dir_time:	resw 1			; time of last write
   642 00000018 ????                    .dir_date:	resw 1			; date of last write
   643 0000001A ????                    .dir_first:	resw 1			; first allocation unit of file
   644 0000001C ????                    .dir_size_l:	resw 1			; low 16 bits of file size
   645 0000001E ????                    .dir_size_h:	resw 1			; high 16 bits of file size
   646                                  .size:
   647                                  endstruc
   648                                  
   649                                  attr_read_only      EQU      1h
   650                                  attr_hidden         EQU      2h
   651                                  attr_system         EQU      4h
   652                                  attr_volume_id      EQU      8h
   653                                  attr_directory      EQU     10h
   654                                  attr_archive        EQU     20h
   655                                  ;09/07/2018 - Retro DOS v3.0
   656                                  ;(DIRENT.INC, MSDOS 3.3, 1987)
   657                                  attr_device	    EQU     40h	; This is a VERY special bit.
   658                                  				;   NO directory entry on a disk EVER
   659                                  				;   has this bit set. It is set non-zero
   660                                  				;   when a device is found by GETPATH
   661                                  
   662                                  attr_all            EQU     attr_hidden+attr_system+attr_directory
   663                                                                          ; OR of hard attributes for FINDENTRY
   664                                  
   665                                  attr_ignore         EQU     attr_read_only+attr_archive
   666                                                                          ; ignore this(ese) attribute(s)
   667                                                                          ; during search first/next
   668                                  
   669                                  attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
   670                                                                          ; changeable via CHMOD
   671                                  
   672                                  ; 09/08/2018 - Retro DOS v3.0
   673                                  ; (DIRENT.INC, MSDOS 6,0, 1991)
   674                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   675                                  
   676                                  ; <File allocation Table information>
   677                                  ;
   678                                  ; The File Allocation Table uses a 12-bit entry for each allocation unit on the
   679                                  ; disk.  These entries are packed, two for every three bytes.  The contents of
   680                                  ; entry number N is found by 1) multiplying N by 1.5; 2) adding the result to
   681                                  ; the base address of the Allocation Table; 3) fetching the 16-bit word at this
   682                                  ; address; 4) If N was odd (so that N*1.5 was not an integer), shift the word
   683                                  ; right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry number zero
   684                                  ; is used as an end-of-file trap in the OS and is passed to the BIOS to help
   685                                  ; determine disk format.  Entry 1 is reserved for future use.  The first
   686                                  ; available allocation unit is assigned entry number two, and even though it is
   687                                  ; the first, is called cluster 2.  Entries greater than 0FF8H are end of file
   688                                  ; marks; entries of zero are unallocated.  Otherwise, the contents of a FAT
   689                                  ; entry is the number of the next cluster in the file.
   690                                  ;
   691                                  ; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would do
   692                                  ; because these clusters show as allocated, but are not part of any allocation
   693                                  ; chain and thus will never be allocated to a file.  A particular number is
   694                                  ; selected so that disk checking programs know what to do (ie.  a cluster with
   695                                  ; entry FF7H which is not in a chain is not an error).
   696                                  
   697                                  ;DIRSTRLEN       EQU     64	; Max length in bytes of directory strings
   698                                  
   699                                  ;============================================================================
   700                                  ; DPB.INC, MSDOS 6.0, 1991
   701                                  ;============================================================================
   702                                  ; 24/04/2019 - Retro DOS v4.0
   703                                  
   704                                  ; 19/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 3.3, 1987)
   705                                  ; 07/07/2018 - Retro DOS v3.0 (DPB.INC, MSDOS 6.0, 1991)
   706                                  
   707                                  ; 24/07/2019 - Retro DOS v3.2
   708                                  
   709                                  ; ---------------------------------------------------------------------------
   710                                  ;**	DPB - Drive Parameter Block
   711                                  ;
   712                                  ;	BUGBUG - this isn't authorative - it's my probably incomplete and
   713                                  ;	possibly inaccurate deductions from code study... - jgl
   714                                  ;
   715                                  ;	The DPB is DOS's main structure for describing block devices.
   716                                  ;	It contains info about the "Drive" intermingled with info about
   717                                  ;	the FAT file system which is presumably on the drive.  I don't know
   718                                  ;	how those fields are used if it's not the FAT file system - BUGBUG
   719                                  ;
   720                                  ;	The DPBs are statically allocated and chained off of DPBHead.
   721                                  ;	Users scan this chain looking for a match on DPB_DRIVE.
   722                                  ;	The DPBs are built at init time from info in the SYSDEV structure.
   723                                  ; ---------------------------------------------------------------------------
   724                                  
   725                                  struc	DPB
   726 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   727 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   728 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   729 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   730 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   731 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   732 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   733 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   734 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   735 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   736                                  ; MSDOS 3.3
   737                                  ;.FAT_SIZE:	resb 1		; Number of records occupied by FAT
   738                                  ; MSDOS 6.0
   739 0000000F ????                    .FAT_SIZE:	resw 1		; Number of records occupied by FAT
   740 00000011 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   741 00000013 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   742 00000017 ??                      .MEDIA:		resb 1		; Media byte
   743 00000018 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   744                                  				; check the first time this DPB is used
   745 00000019 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   746 0000001D ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   747 0000001F ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   748                                  .size:
   749                                  endstruc
   750                                  
   751                                  DPBSIZ  EQU     DPB.size ; = 33	; Size of the structure in bytes
   752                                  
   753                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   754                                  
   755                                  ;                                                                          ;
   756                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   757                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   758                                  
   759                                  ; 12/07/2018 - Retro DOS v3.0 
   760                                  ; (DOSSYM.INC, MSDOS 6.0, 1991)
   761                                  
   762                                  ;**	Character Type Flags
   763                                  ;
   764                                  ;	These flags are used in a lookup table indexed by the character code.
   765                                  ;	They're used to quickly classify characters when parsing paths.
   766                                  ;	I think that these are only used to parse FCBs - jgl
   767                                  
   768                                  FCHK	equ 1		; I think this means "normal name char, no chks needed" -jgl
   769                                  FDELIM	equ 2		; is a delimiter
   770                                  FSPCHK	equ 4		; set if character is not a space or equivalent
   771                                  FFCB	equ 8		; is valid in an FCB
   772                                  
   773                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   774                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   775                                  ;                                                                          ;
   776                                  devid_file_clean        EQU     40h     ; true if file and not written
   777                                  devid_file_mask_drive   EQU     3Fh     ; mask for drive number
   778                                  
   779                                  devid_device            EQU     80h     ; true if a device
   780                                  devid_device_EOF        EQU     40h     ; true if end of file reached
   781                                  devid_device_raw        EQU     20h     ; true if in raw mode
   782                                  devid_device_special    EQU     10h     ; true if special device
   783                                  devid_device_clock      EQU     08h     ; true if clock device
   784                                  devid_device_null       EQU     04h     ; true if null device
   785                                  devid_device_con_out    EQU     02h     ; true if console output
   786                                  devid_device_con_in     EQU     01h     ; true if consle input
   787                                  
   788                                  ;
   789                                  ; structure of devid field as returned by IOCTL is:
   790                                  ;
   791                                  ;       BIT     7   6   5   4   3   2   1   0
   792                                  ;             |---|---|---|---|---|---|---|---|
   793                                  ;             | I | E | R | S | I | I | I | I |
   794                                  ;             | S | O | A | P | S | S | S | S |
   795                                  ;             | D | F | W | E | C | N | C | C |
   796                                  ;             | E |   |   | C | L | U | O | I |
   797                                  ;             | V |   |   | L | K | L | T | N |
   798                                  ;             |---|---|---|---|---|---|---|---|
   799                                  ;       ISDEV = 1 if this channel is a device
   800                                  ;             = 0 if this channel is a disk file
   801                                  ;
   802                                  ;       If ISDEV = 1
   803                                  ;
   804                                  ;             EOF = 0 if End Of File on input
   805                                  ;             RAW = 1 if this device is in Raw mode
   806                                  ;                 = 0 if this device is cooked
   807                                  ;             ISCLK = 1 if this device is the clock device
   808                                  ;             ISNUL = 1 if this device is the null device
   809                                  ;             ISCOT = 1 if this device is the console output
   810                                  ;             ISCIN = 1 if this device is the console input
   811                                  ;
   812                                  ;       If ISDEV = 0
   813                                  ;             EOF = 0 if channel has been written
   814                                  ;             Bits 0-5  are  the  block  device  number  for
   815                                  ;                 the channel (0 = A, 1 = B, ...)
   816                                  ;
   817                                  devid_ISDEV     EQU     80h
   818                                  devid_EOF       EQU     40h
   819                                  devid_RAW       EQU     20h
   820                                  devid_SPECIAL   EQU     10H
   821                                  devid_ISCLK     EQU     08h
   822                                  devid_ISNUL     EQU     04h
   823                                  devid_ISCOT     EQU     02h
   824                                  devid_ISCIN     EQU     01h
   825                                  
   826                                  devid_block_dev EQU     1Fh             ; mask for block device number
   827                                  
   828                                  ; 08/07/2018 - Retro DOS v3.0
   829                                  ; (PDB.INC, MSDOS 6.0, 1991)
   830                                  ; ----------------------------------------------------------------------------
   831                                  ; BREAK <Process data block>
   832                                  ;
   833                                  ;**	Process data block (otherwise known as program header)
   834                                  ;
   835                                  
   836                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   837                                  ;	can be rearranged here, ever.  Reserved areas are probably safe
   838                                  ;	for use.
   839                                  
   840                                  FILPERPROC	EQU     20
   841                                  
   842                                  struc PDB	; Process_data_block
   843 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   844 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   845 00000004 ??                                      resb 1
   846 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   847 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   848 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   849 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   850 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   851 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   852 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   853 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   854 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   855 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   856 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   857 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   858 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   859 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   860 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   861 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   862 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   863 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   864                                  				;  an extended FCB
   865                                  ;endstruc 	; MSDOS 3.3
   866                                  	  	; MSDOS 6.0
   867 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   868 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   869 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   870 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   871                                  endstruc
   872                                  
   873                                  ; BREAK <EXEC and EXE file structures>
   874                                  ;
   875                                  ; EXEC arg block - load/go program
   876                                  ;
   877                                  
   878                                  ;
   879                                  ; The following get used as arguments to the EXEC system call. They indicate
   880                                  ; whether or not the program is executed or whether or not a program header
   881                                  ; gets created.
   882                                  ;
   883                                  exec_func_no_execute    EQU 1           ; no execute bit
   884                                  exec_func_overlay       EQU 2           ; overlay bit
   885                                  
   886                                  struc EXEC0
   887 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
   888 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
   889 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
   890 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
   891                                  .size:
   892                                  endstruc
   893                                  
   894                                  struc EXEC1
   895 00000000 ????                    .ENVIRON:	resw 1		; seg addr of environment
   896 00000002 ????????                .COM_LINE:	resd 1		; pointer to asciz command line
   897 00000006 ????????                .5C_FCB:	resd 1		; default fcb at 5C
   898 0000000A ????????                .6C_FCB:	resd 1		; default fcb at 6C
   899 0000000E ????                    .SP:		resw 1		; stack pointer of program
   900 00000010 ????                    .SS:		resw 1		; stack seg register of program
   901 00000012 ????                    .IP:		resw 1		; entry point IP
   902 00000014 ????                    .CS:		resw 1		; entry point CS
   903                                  .size:
   904                                  endstruc
   905                                  
   906                                  struc EXEC3
   907 00000000 ????                    .load_addr:	resw 1		; seg address of load point
   908 00000002 ????                    .reloc_fac:	resw 1		; relocation factor
   909                                  endstruc
   910                                  
   911                                  ; 02/08/2018 (MSDOS 6.0, EXEC.INC, 1991)
   912                                  ;**	Exit codes (in upper byte) for terminating programs
   913                                  
   914                                  EXIT_TERMINATE		EQU	0
   915                                  EXIT_ABORT		EQU	0
   916                                  EXIT_CTRL_C		EQU	1
   917                                  EXIT_HARD_ERROR 	EQU	2
   918                                  EXIT_KEEP_PROCESS	EQU	3
   919                                  
   920                                  ;
   921                                  ; EXE file header
   922                                  ;
   923                                  
   924                                  struc EXE
   925 00000000 ????                    .signature:   resw 1		; must contain 4D5A (yay zibo!)
   926 00000002 ????                    .len_mod_512: resw 1		; low 9 bits of length
   927 00000004 ????                    .pages:       resw 1		; number of 512b pages in file
   928 00000006 ????                    .rle_count:   resw 1		; count of reloc entries
   929 00000008 ????                    .par_dir:     resw 1		; number of paragraphs before image
   930 0000000A ????                    .min_BSS:     resw 1		; minimum number of para of BSS
   931 0000000C ????                    .max_BSS:     resw 1		; max number of para of BSS
   932 0000000E ????                    .SS:          resw 1		; stack of image
   933 00000010 ????                    .SP:          resw 1		; SP of image
   934 00000012 ????                    .chksum:      resw 1		; checksum of file (ignored)
   935 00000014 ????                    .IP:          resw 1		; IP of entry
   936 00000016 ????                    .CS:          resw 1		; CS of entry
   937 00000018 ????                    .rle_table:   resw 1		; byte offset of reloc table
   938 0000001A ????                    .iov:         resw 1		; overlay number (0 for root)
   939 0000001C ????????                .sym_tab:     resd 1		; offset of symbol table in file
   940                                  .size:
   941                                  endstruc
   942                                  
   943                                  exe_valid_signature     EQU 5A4Dh
   944                                  exe_valid_old_signature EQU 4D5Ah
   945                                  
   946                                  struc symbol_entry
   947 00000000 ????????                .value:	resd 1
   948 00000004 ????                    .type:	resw 1
   949 00000006 ??                      .len:	resb 1
   950 00000007 <res FFh>               .name:	resb 255
   951                                  endstruc
   952                                  
   953                                  ; 07/07/2018 - Retro DOS v3.0
   954                                  ; MSDOS 6.0 (SF.INC, 1991)
   955                                  ; ----------------------------------------------------------------------------
   956                                  ;**	SF.INC - System File Table
   957                                  ;
   958                                  ;   AN000   version 4.00   Jan. 1988
   959                                  ;   AN003   PTM 3680 --  make NAME offset the same as before (<=3.30)
   960                                  ;   AN009   PTM 3839	 reorder SFT for MS WINDOWS
   961                                  
   962                                  ;**	System File Table SuperStructure
   963                                  ;
   964                                  ;	The system file table entries are allocated in contiguous groups.
   965                                  ;	There may be more than one such groups; the SF "superstructure"
   966                                  ;	tracks the groups.
   967                                  
   968                                  struc	SFT
   969 00000000 ????????                .SFLink:	resd 1
   970 00000004 ????                    .SFCount:	resw 1		; number of entries
   971 00000006 ????                    .SFTable:	resw 1		; beginning of array of the following
   972                                  .size:
   973                                  endstruc
   974                                  
   975                                  ; 07/07/2018 - Retro DOS v3.0
   976                                  ; MSDOS 6.0 (SF.INC, 1991)
   977                                  
   978                                  ; ---------------------------------------------------------------------------
   979                                  ;**	System file table entry
   980                                  ;
   981                                  ;	These are the structures which are at SFTABLE in the SF structure.
   982                                  ; ---------------------------------------------------------------------------
   983                                  
   984                                  ; 25/04/2019 - Retro DOS v4.0
   985                                  ; 24/04/2019 - Retro DOS v3.2
   986                                  
   987                                  struc SF_ENTRY
   988 00000000 ????                    .sf_ref_count:	resw 1		; number of processes sharing entry
   989                                  				;   if FCB then ref count
   990 00000002 ????                    .sf_mode:	resw 1		; mode of access or high bit on if FCB
   991 00000004 ??                      .sf_attr:	resb 1		; attribute of file
   992 00000005 ????                    .sf_flags:	resw 1		;Bits 8-15
   993                                  				; Bit 15 = 1 if remote file
   994                                  				;	 = 0 if local file or device
   995                                  				; Bit 14 = 1 if date/time is not to be
   996                                  				;   set from clock at CLOSE.  Set by
   997                                  				;   FILETIMES and FCB_CLOSE.  Reset by
   998                                  				;   other reseters of the dirty bit
   999                                  				;   (WRITE)
  1000                                  				; Bit 13 = Pipe bit (reserved)
  1001                                  				;
  1002                                  				; Bits 0-7 (old FCB_devid bits)
  1003                                  				; If remote file or local file, bit
  1004                                  				; 6=0 if dirty Device ID number, bits
  1005                                  				; 0-5 if local file.
  1006                                  				; bit 7=0 for local file, bit 7
  1007                                  				;      =1 for local I/O device
  1008                                  				; If local I/O device, bit 6=0 if EOF (input)
  1009                                  				;		Bit 5=1 if Raw mode
  1010                                  				;		Bit 0=1 if console input device
  1011                                  				;		Bit 1=1 if console output device
  1012                                  				;		Bit 2=1 if null device
  1013                                  				;		Bit 3=1 if clock device
  1014 00000007 ????????                .sf_devptr:	resd	1	; Points to DPB if local file, points
  1015                                  				; to device header if local device,
  1016                                  				; points to net device header if
  1017                                  				; remote
  1018 0000000B ????                    .sf_firclus:	resw	1	; First cluster of file (bit 15 = 0)
  1019 0000000D ????                    .sf_time:	resw	1	; Time associated with file
  1020 0000000F ????                    .sf_date:	resw	1	; Date associated with file
  1021 00000011 ????????                .sf_size:	resd 	1	; Size associated with file
  1022 00000015 ????????                .sf_position:	resd	1	; Read/Write pointer or LRU count for FCBs
  1023                                  
  1024                                  ; Starting here, the next 7 bytes may be used by the file system to store
  1025                                  ; an ID
  1026                                  
  1027                                  ; 09/07/2018 - Retro DOS v3.0
  1028                                  
  1029                                  ; MSDOS 3.3 SF.INC, 1987
  1030                                  ;.sf_cluspos:	resw	1	; Position of last cluster accessed
  1031                                  ;.sf_lstclus	resw	1	; Last cluster accessed
  1032                                  ;.sf_dirsec:	resw	1	; Sector number of directory sector
  1033                                  ;				; for this file
  1034                                  ;.sf_dirpos:	resb	1	; Offset of this entry in the above
  1035                                  
  1036                                  ; MSDOS 6.0, SF.INC, 1991
  1037 00000019 ????                    .sf_cluspos:	resw	1	; Position of last cluster accessed
  1038 0000001B ????????                .sf_dirsec:	resd	1	; Sector number of directory sector
  1039                                  				; for this file
  1040 0000001F ??                      .sf_dirpos:	resb	1	; Offset of this entry in the above
  1041                                  
  1042                                  ; End of 7 bytes of file-system specific info.
  1043                                  
  1044 00000020 <res Bh>                .sf_name:	resb	11	; 11 character name that is in the
  1045                                  				; directory entry.  This is used by
  1046                                  				; close to detect file deleted and
  1047                                  				; disk changed errors.
  1048                                  ; SHARING INFO
  1049 0000002B ????????                .sf_chain:	resd	1	; link to next SF
  1050 0000002F ????                    .sf_UID:	resw	1
  1051 00000031 ????                    .sf_PID:	resw	1
  1052 00000033 ????                    .sf_MFT:	resw	1
  1053                                  
  1054                                  ; MSDOS 6.0, SF.INC, 1991
  1055 00000035 ????                    .sf_lstclus:	resw	1	;AN009; Last cluster accessed
  1056 00000037 ????????                .sf_IFS_HDR:	resd	1
  1057                                  
  1058                                  .size:
  1059                                  endstruc
  1060                                  
  1061                                  ; 20/07/2018
  1062                                  ; MSDOS 3.3, SF.INC, 1987
  1063                                  %define sf_netid   SF_ENTRY.sf_cluspos    ; byte
  1064                                  %define sf_OpenAge SF_ENTRY.sf_position+2 ; word
  1065                                  %define sf_LRU	   SF_ENTRY.sf_position	  ; word
  1066                                  ; MSDOS 6.0, SF.INC, 1991
  1067                                  %define sf_fsda	     SF_ENTRY.sf_cluspos  ; byte ;DOS 4.00
  1068                                  %define sf_serial_ID SF_ENTRY.sf_firclus  ; word ;DOS 4.00
  1069                                  
  1070                                  ; 19/07/2018
  1071                                  
  1072                                  ; MSDOS 3.3, SF.INC, 1987
  1073                                  
  1074                                  sf_default_number  EQU	5
  1075                                  
  1076                                  ; Note that we need to mark an SFT as being busy for OPEN/CREATE. This is
  1077                                  ; because an INT 24 may prevent us from 'freeing' it. We mark this as such
  1078                                  ; by placing a -1 in the ref_count field.
  1079                                  
  1080                                  sf_busy EQU -1
  1081                                  
  1082                                  ; mode mask for FCB detection
  1083                                  sf_isFCB		EQU	1000000000000000B
  1084                                  
  1085                                  ; Flag word masks
  1086                                  sf_isnet		EQU	1000000000000000B
  1087                                  sf_close_nodate 	EQU	0100000000000000B
  1088                                  sf_pipe 		EQU	0010000000000000B
  1089                                  sf_no_inherit		EQU	0001000000000000B
  1090                                  sf_net_spool		EQU	0000100000000000B
  1091                                  
  1092                                  ; 19/04/2018
  1093                                  sf_entry_size equ SF_ENTRY.size ; 53
  1094                                  
  1095                                  ;                                                                          ;
  1096                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1097                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1098                                  
  1099                                  ; 09/07/2018 - Retro DOS v3.0
  1100                                  ; (ARENA.INC, MSDOS 3.3, 1987)
  1101                                  ; ----------------------------------------------------------------------------
  1102                                  ;BREAK <Memory arena structure>
  1103                                  
  1104                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1105                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1106                                  ;                                                                          ;
  1107                                  ;
  1108                                  ; arena item
  1109                                  ;
  1110                                  
  1111                                  struc ARENA
  1112 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
  1113 00000001 ????                    .OWNER:		resw 1		; owner of arena item
  1114 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
  1115                                  ; MSDOS 6.0
  1116 00000005 ??????                  .RESERVED:	resb 3		; reserved
  1117 00000008 ????????????????        .NAME:		resb 8		; owner file name
  1118                                  .headersize:			
  1119                                  endstruc
  1120                                  
  1121                                  ; CAUTION: The routines in ALLOC.ASM rely on the fact that arena_signature
  1122                                  ; and arena_owner_system are all equal to zero and are contained in DI.
  1123                                  ; Change them and change ALLOC.ASM.
  1124                                  
  1125                                  arena_owner_system  EQU 0               ; free block indication
  1126                                  
  1127                                  arena_signature_normal	EQU 4Dh		; valid signature, not end of arena
  1128                                  arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
  1129                                  
  1130                                  ; 04/08/2018 - Retro DOS v3.0
  1131                                  ; (ARENA.INC, MSDOS 6.0, 1991)
  1132                                  
  1133                                  FIRST_FIT	EQU	00000000B
  1134                                  BEST_FIT	EQU	00000001B
  1135                                  LAST_FIT	EQU	00000010B
  1136                                  
  1137                                  ; MSDOS 6.0
  1138                                  ;LOW_FIRST	EQU	00000000B	; M001
  1139                                  ;HIGH_FIRST	EQU	10000000B	; M001
  1140                                  ;HIGH_ONLY	EQU	01000000B	; M001
  1141                                  
  1142                                  ;LINKSTATE	EQU	00000001B	; M002
  1143                                  
  1144                                  ;HF_MASK		EQU	~HIGH_FIRST	; M001
  1145                                  ;HO_MASK		EQU	~HIGH_ONLY	; M001
  1146                                  
  1147                                  ;STRAT_MASK	EQU	HF_MASK & HO_MASK	; M001;
  1148                                  						; M026: used to mask of bits
  1149                                  						; M026: 6 & 7 of AllocMethod
  1150                                  ; 07/07/2018 - Retro DOS v3.0
  1151                                  ; (MI.INC, MSDOS 6.0, 1991)
  1152                                  ; ----------------------------------------------------------------------------
  1153                                  ;BREAK <Machine instruction, flag definitions and character types>
  1154                                  
  1155                                  mi_INT		EQU	0CDh
  1156                                  mi_Long_JMP	EQU	0EAh
  1157                                  mi_Long_CALL	EQU	09Ah
  1158                                  mi_Long_RET	EQU	0CBh
  1159                                  mi_Near_RET	EQU	0C3h
  1160                                  
  1161                                  ;			xxxxoditszxaxpxc
  1162                                  f_Overflow	EQU	0000100000000000B
  1163                                  f_Direction	EQU	0000010000000000B
  1164                                  f_Interrupt	EQU	0000001000000000B
  1165                                  f_Trace 	EQU	0000000100000000B
  1166                                  f_Sign		EQU	0000000010000000B
  1167                                  f_Zero		EQU	0000000001000000B
  1168                                  f_Aux		EQU	0000000000010000B
  1169                                  f_Parity	EQU	0000000000000100B
  1170                                  f_Carry 	EQU	0000000000000001B
  1171                                  
  1172                                  ; <Standard I/O assignments>
  1173                                  
  1174                                  stdin       EQU     0
  1175                                  stdout      EQU     1
  1176                                  stderr      EQU     2
  1177                                  stdaux      EQU     3
  1178                                  stdprn      EQU     4
  1179                                  
  1180                                  ; <Xenix subfunction assignments>
  1181                                  
  1182                                  open_for_read   EQU 0
  1183                                  open_for_write  EQU 1
  1184                                  open_for_both   EQU 2
  1185                                  
  1186                                  ; 13/07/2018 - Retro DOS v3.0
  1187                                  ; (FILEMODE.INC, MSDOS 6.0, 1991)
  1188                                  
  1189                                  access_mask	EQU 0Fh ; 09/08/2018
  1190                                  
  1191                                  EXEC_OPEN	EQU 3		; access code of 3 indicates that open was 
  1192                                  				; made from exec
  1193                                  SHARING_MASK	    equ 0F0h
  1194                                  SHARING_COMPAT	    equ 000h
  1195                                  SHARING_DENY_BOTH   equ 010h
  1196                                  SHARING_DENY_WRITE  equ 020h
  1197                                  SHARING_DENY_READ   equ 030h
  1198                                  SHARING_DENY_NONE   equ 040h
  1199                                  SHARING_NET_FCB     equ 070h
  1200                                  SHARING_NO_INHERIT  equ 080h
  1201                                  
  1202                                  ; 09/07/2018 - Retro DOS v3.0
  1203                                  ; (SYSCALL.INC, MSDOS 3.3, 1987)
  1204                                  ; ----------------------------------------------------------------------------
  1205                                  
  1206                                  ; <system call definitions>
  1207                                  
  1208                                  ABORT                           EQU 0   ;  0      0
  1209                                  STD_CON_INPUT                   EQU 1   ;  1      1
  1210                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
  1211                                  STD_AUX_INPUT                   EQU 3   ;  3      3
  1212                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
  1213                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
  1214                                  RAW_CON_IO                      EQU 6   ;  6      6
  1215                                  RAW_CON_INPUT                   EQU 7   ;  7      7
  1216                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
  1217                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
  1218                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
  1219                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
  1220                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
  1221                                  DISK_RESET                      EQU 13  ; 13      D
  1222                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
  1223                                  FCB_OPEN                        EQU 15  ; 15      F
  1224                                  FCB_CLOSE                       EQU 16  ; 16     10
  1225                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
  1226                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
  1227                                  FCB_DELETE                      EQU 19  ; 19     13
  1228                                  FCB_SEQ_READ                    EQU 20  ; 20     14
  1229                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
  1230                                  FCB_CREATE                      EQU 22  ; 22     16
  1231                                  FCB_RENAME                      EQU 23  ; 23     17
  1232                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
  1233                                  SET_DMA                         EQU 26  ; 26     1A
  1234                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1235                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1236                                  ;                                                                          ;
  1237                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
  1238                                  ;                                                                          ;
  1239                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1240                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1241                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
  1242                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
  1243                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
  1244                                  GET_FCB_POSITION                EQU 36  ; 36     24
  1245                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
  1246                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
  1247                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
  1248                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
  1249                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
  1250                                  GET_DATE                        EQU 42  ; 42     2A
  1251                                  SET_DATE                        EQU 43  ; 43     2B
  1252                                  GET_TIME                        EQU 44  ; 44     2C
  1253                                  SET_TIME                        EQU 45  ; 45     2D
  1254                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
  1255                                  ; Extended functionality group
  1256                                  GET_DMA                         EQU 47  ; 47     2F
  1257                                  GET_VERSION                     EQU 48  ; 48     30
  1258                                  KEEP_PROCESS                    EQU 49  ; 49     31
  1259                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1260                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1261                                  ;                                                                          ;
  1262                                  GET_DPB                         EQU 50  ; 50     32
  1263                                  ;                                                                          ;
  1264                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1265                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1266                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
  1267                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
  1268                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
  1269                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
  1270                                  CHAR_OPER                       EQU 55  ; 55     37
  1271                                  INTERNATIONAL                   EQU 56  ; 56     38
  1272                                  ; XENIX CALLS
  1273                                  ;   Directory Group
  1274                                  MKDIR                           EQU 57  ; 57     39
  1275                                  RMDIR                           EQU 58  ; 58     3A
  1276                                  CHDIR                           EQU 59  ; 59     3B
  1277                                  ;   File Group
  1278                                  CREAT                           EQU 60  ; 60     3C
  1279                                  OPEN                            EQU 61  ; 61     3D
  1280                                  CLOSE                           EQU 62  ; 62     3E
  1281                                  READ                            EQU 63  ; 63     3F
  1282                                  WRITE                           EQU 64  ; 64     40
  1283                                  UNLINK                          EQU 65  ; 65     41
  1284                                  LSEEK                           EQU 66  ; 66     42
  1285                                  CHMOD                           EQU 67  ; 67     43
  1286                                  IOCTL                           EQU 68  ; 68     44
  1287                                  XDUP                            EQU 69  ; 69     45
  1288                                  XDUP2                           EQU 70  ; 70     46
  1289                                  CURRENT_DIR                     EQU 71  ; 71     47
  1290                                  ;    Memory Group
  1291                                  ALLOC                           EQU 72  ; 72     48
  1292                                  DEALLOC                         EQU 73  ; 73     49
  1293                                  SETBLOCK                        EQU 74  ; 74     4A
  1294                                  ;    Process Group
  1295                                  EXEC                            EQU 75  ; 75     4B
  1296                                  EXIT                            EQU 76  ; 76     4C
  1297                                  _WAIT				EQU 77  ; 77     4D
  1298                                  FIND_FIRST                      EQU 78  ; 78     4E
  1299                                  ;   Special Group
  1300                                  FIND_NEXT                       EQU 79  ; 79     4F
  1301                                  ; SPECIAL SYSTEM GROUP
  1302                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1303                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1304                                  ;                                                                          ;
  1305                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
  1306                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
  1307                                  GET_IN_VARS                     EQU 82  ; 82     52
  1308                                  SETDPB                          EQU 83  ; 83     53
  1309                                  ;                                                                          ;
  1310                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1311                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1312                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
  1313                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1314                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1315                                  ;                                                                          ;
  1316                                  DUP_PDB                         EQU 85  ; 85     55
  1317                                  ;                                                                          ;
  1318                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1319                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1320                                  RENAME                          EQU 86  ; 86     56
  1321                                  FILE_TIMES                      EQU 87  ; 87     57
  1322                                  ALLOCOPER			EQU 88	; 88	 58
  1323                                  ; Network extention system calls
  1324                                  GETEXTENDEDERROR		EQU 89	; 89	 59
  1325                                  CREATETEMPFILE			EQU 90	; 90	 5A
  1326                                  CREATENEWFILE			EQU 91	; 91	 5B
  1327                                  LOCKOPER			EQU 92	; 92	 5C Lock and Unlock
  1328                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1329                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1330                                  ;									   ;
  1331                                  SERVERCALL			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
  1332                                  					;	    CloseByName, CloseUser,
  1333                                  					;	    CloseUserProcess,
  1334                                  					;	    GetOpenFileList
  1335                                  ;									   ;
  1336                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1337                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1338                                  USEROPER			EQU 94	; 94	 5E Get and Set
  1339                                  ASSINGOPER			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
  1340                                  XNAMETRANS			EQU 96	; 96	 60
  1341                                  PATHPARSE			EQU 97	; 97	 61
  1342                                  GETCURRENTPSP			EQU 98	; 98	 62
  1343                                  HONGEUL 			EQU 99	; 99	 63
  1344                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1345                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1346                                  ;									   ;
  1347                                  SET_PRINTER_FLAG		EQU 100 ; 100	 64
  1348                                  ;									   ;
  1349                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  1350                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1351                                  GETEXTCNTRY			EQU 101 ; 101	 65 
  1352                                  GETSETCDPG			EQU 102 ; 102	 66
  1353                                  EXTHANDLE			EQU 103 ; 103	 67
  1354                                  COMMIT				EQU 104 ; 104	 68
  1355                                  
  1356                                  ; 09/07/2018 - Retro DOS v3.0
  1357                                  ; (MSDOS 6.0, SYSCALL.INC, 1987)
  1358                                  
  1359                                  ;GetSetMediaID			EQU 105 ; 105	 69
  1360                                  ;IFS_IOCTL			EQU 107 ; 107	 6B
  1361                                  ;ExtOpen 			EQU 108 ; 108	 6C
  1362                                  
  1363                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1364                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1365                                  ;                                                                          ;
  1366                                  ;ifdef ROMEXEC
  1367                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
  1368                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
  1369                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
  1370                                  ;endif
  1371                                  ;                                                                          ;
  1372                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  1373                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  1374                                  
  1375                                  SET_OEM_HANDLER			EQU 248 ; 248    F8
  1376                                  ;OEM_C1				EQU 249 ; 249    F9
  1377                                  ;OEM_C2				EQU 250 ; 250    FA
  1378                                  ;OEM_C3				EQU 251 ; 251    FB
  1379                                  ;OEM_C4				EQU 252 ; 252    FC
  1380                                  ;OEM_C5				EQU 253 ; 253    FD
  1381                                  ;OEM_C6				EQU 254 ; 254    FE
  1382                                  ;OEM_C7				EQU 255 ; 255    FF
  1383                                  
  1384                                  ;============================================================================
  1385                                  ; VERSIONA.INC (MSDOS 3.3, 24/07/1987)
  1386                                  ;============================================================================
  1387                                  ; 08/07/2018 - Retro DOS 3.0
  1388                                  
  1389                                  MAJOR_VERSION   EQU     3
  1390                                  MINOR_VERSION   EQU     30
  1391                                  
  1392                                  ;============================================================================
  1393                                  ; DOSSYM_V211.ASM (-*-)
  1394                                  ;============================================================================
  1395                                  
  1396                                  ;DOS_MAJOR_VERSION   EQU      2
  1397                                  ;DOS_MINOR_VERSION   EQU     11
  1398                                  
  1399                                  ;============================================================================
  1400                                  ; INTNAT.INC, MSDOS 3.3, 1987
  1401                                  ;============================================================================
  1402                                  ; 09/07/2018 - Retro DOS 3.0
  1403                                  
  1404                                  ;
  1405                                  ; Current structure of the data returned by the international call
  1406                                  ;
  1407                                  
  1408                                  struc	INTERNAT_BLOCK		; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  1409                                  .Date_tim_format:
  1410 00000000 ????                    		RESW 1		; 0-USA, 1-EUR, 2-JAP
  1411                                  .Currency_sym:
  1412 00000002 ??????????              		RESB 5		; Currency Symbol 5 bytes
  1413                                  .Thous_sep:
  1414 00000007 ????                    		RESB 2		; Thousands separator 2 bytes
  1415                                  .Decimal_sep:
  1416 00000009 ????                    		RESB 2		; Decimal separator 2 bytes
  1417                                  .Date_sep:
  1418 0000000B ????                    		RESB 2		; Date separator 2 bytes
  1419                                  .Time_sep:
  1420 0000000D ????                    		RESB 2		; Time separator 2 bytes
  1421                                  .Bit_field:	
  1422 0000000F ??                      		RESB 1		; Bit values
  1423                                                                     ;   Bit 0 = 0 if currency symbol first
  1424                                                                     ;         = 1 if currency symbol last
  1425                                                                     ;   Bit 1 = 0 if No space after currency symbol
  1426                                                                     ;         = 1 if space after currency symbol
  1427                                  .Currency_cents:
  1428 00000010 ??                      		RESB 	1	; Number of places after currency dec point
  1429                                  .Time_24:
  1430 00000011 ??                      		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
  1431                                  .Map_call:
  1432 00000012 ????                    		RESW	1	; Address of case mapping call (DWORD)
  1433 00000014 ????                                    RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  1434                                  				;  in pieces.
  1435                                  .Data_sep:
  1436 00000016 ????                    		RESB	2	; Data list separator character
  1437                                  .size:		
  1438                                  endstruc
  1439                                  
  1440                                  ;
  1441                                  ; Max size of the block returned by the INTERNATIONAL call
  1442                                  ;
  1443                                  internat_block_max	EQU	32
  1444                                  
  1445                                  ;============================================================================
  1446                                  ; SYSVAR.INC (MSDOS 6.0, 1991)
  1447                                  ;============================================================================
  1448                                  ; 08/07/2018 - Retro DOS v3.0
  1449                                  
  1450                                  ;SysInitVars STRUC
  1451                                  struc SYSI
  1452 00000000 ????????                .DPB:	    resd 1		; DPB chain
  1453 00000004 ????????                .SFT:	    resd 1		; SFT chain
  1454 00000008 ????????                .CLOCK:	    resd 1		; CLOCK device
  1455 0000000C ????????                .CON:	    resd 1		; CON device
  1456 00000010 ????                    .MAXSEC:    resw 1		; maximum sector size
  1457 00000012 ????????                .BUF:	    resd 1		; points to Hashinitvar
  1458 00000016 ????????                .CDS:	    resd 1		; CDS list
  1459 0000001A ????????                .FCB:	    resd 1		; FCB chain
  1460 0000001E ????                    .Keep:	    resw 1		; keep count
  1461 00000020 ??                      .NUMIO:	    resb 1		; Number of block devices
  1462 00000021 ??                      .NCDS:	    resb 1		; number of CDS's
  1463 00000022 ????????                .DEV:	    resd 1		; device list
  1464                                  ; 09/07/2018
  1465                                  ; Above parameters are described in MSDOS 3.3 SYSVAR.INC (85/04/10)
  1466                                  ; Following parameters are used with MSDOS 6.0 (Retro DOS v4.0)
  1467 00000026 ????                    .ATTR:	    resw 1		; null device attribute word
  1468 00000028 ????                    .STRAT:	    resw 1		; null device strategy entry point
  1469 0000002A ????                    .INTER:	    resw 1		; null device interrupt entry point
  1470 0000002C ????????????????        .NAME:	    resb 8		; null device name
  1471 00000034 ??                      .SPLICE:    resb 1		; TRUE -> splices being done
  1472 00000035 ????                    .IBMDOS_SIZE: resw 1		; DOS size in paragraphs
  1473 00000037 ????????                .IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
  1474 0000003B ????????                .IFS:	    resd 1		; IFS header chain
  1475 0000003F ????????                .BUFFERS:   resw 2		; BUFFERS= values (m,n)
  1476 00000043 ??                      .BOOT_DRIVE: resb 1		; boot drive A=1 B=2,..
  1477 00000044 ??                      .DWMOVE:    resb 1		; 1 if 386 machine
  1478 00000045 ????                    .EXT_MEM:   resw 1		; Extended memory size in KB.
  1479                                  endstruc
  1480                                  ;SysInitVars ENDS
  1481                                  
  1482                                  ;This is added for more information exchange between DOS, BIOS.
  1483                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
  1484                                  
  1485                                  ;SysInitVars_Ext struc
  1486                                  struc SYSI_EXT
  1487 00000000 ????????                .SysInitVars:	resd 1		; Points to the above structure.
  1488 00000004 ????????                .Country_Tab:	resd 1		; DOS_Country_cdpg_info
  1489                                  endstruc
  1490                                  ;SysInitVars_Ext ends
  1491                                  
  1492                                  ;============================================================================
  1493                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  1494                                  ;============================================================================
  1495                                  ; 09/07/2018 - Retro DOS v3.0
  1496                                  
  1497                                  ;*** J.K.
  1498                                  ;General Guide -
  1499                                  ;Category Code:
  1500                                  ; 0... .... DOS Defined
  1501                                  ; 1... .... User defined
  1502                                  ; .xxx xxxx Code
  1503                                  
  1504                                  ;Function Code:
  1505                                  ; 0... .... Return error if unsupported
  1506                                  ; 1... .... Ignore if unsupported
  1507                                  ; .0.. .... Intercepted by DOS
  1508                                  ; .1.. .... Passed to driver
  1509                                  ; ..0. .... Sends data/commands to device
  1510                                  ; ..1. .... Quries data/info from device
  1511                                  ; ...x .... Subfunction
  1512                                  ;
  1513                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  1514                                  ; function set.  It plays no critical role; some functions may contain both
  1515                                  ; command and query elements. The convention is that such commands are
  1516                                  ; defined as "sends data".
  1517                                  
  1518                                  ;*****************************;*
  1519                                  ; BLOCK DRIVERS 	      ;*
  1520                                  ;*****************************;*
  1521                                  
  1522                                  ; IOCTL SUB-FUNCTIONS
  1523                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1524                                  IOCTL_GET_DEVICE_INFO	EQU	0
  1525                                  IOCTL_SET_DEVICE_INFO	EQU	1
  1526                                  IOCTL_READ_HANDLE	EQU	2
  1527                                  IOCTL_WRITE_HANDLE	EQU	3
  1528                                  IOCTL_READ_DRIVE	EQU	4
  1529                                  IOCTL_WRITE_DRIVE	EQU	5
  1530                                  IOCTL_GET_INPUT_STATUS	EQU	6
  1531                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  1532                                  IOCTL_CHANGEABLE?	EQU	8
  1533                                  IOCTL_DeviceLocOrRem?	EQU	9
  1534                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  1535                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  1536                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  1537                                  GENERIC_IOCTL		EQU	0Dh   ;13
  1538                                  ; (MSDOS 6.0 + MSDOS 3.3)
  1539                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  1540                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  1541                                  ; (MSDOS 6.0)
  1542                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  1543                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  1544                                  
  1545                                  ; GENERIC IOCTL CATEGORY CODES
  1546                                  IOC_OTHER		EQU	0	; Other device control J.K. 4/29/86
  1547                                  IOC_SE			EQU	1	; SERIAL DEVICE CONTROL
  1548                                  IOC_TC			EQU	2	; TERMINAL CONTROL
  1549                                  IOC_SC			EQU	3	; SCREEN CONTROL
  1550                                  IOC_KC			EQU	4	; KEYBOARD CONTROL
  1551                                  IOC_PC			EQU	5	; PRINTER CONTROL
  1552                                  IOC_DC			EQU	8	; DISK CONTROL (SAME AS RAWIO)
  1553                                  
  1554                                  ; GENERIC IOCTL SUB-FUNCTIONS
  1555                                  RAWIO			EQU	8
  1556                                  
  1557                                  ; RAWIO SUB-FUNCTIONS
  1558                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1559                                  GET_DEVICE_PARAMETERS	EQU	60H
  1560                                  SET_DEVICE_PARAMETERS	EQU	40H
  1561                                  READ_TRACK		EQU	61H
  1562                                  WRITE_TRACK		EQU	41H
  1563                                  VERIFY_TRACK		EQU	62H
  1564                                  FORMAT_TRACK		EQU	42H
  1565                                  ; (MSDOS 6.0)
  1566                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  1567                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  1568                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  1569                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  1570                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  1571                                  
  1572                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  1573                                  BUILD_DEVICE_BPB	EQU	000000001B
  1574                                  
  1575                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  1576                                  INSTALL_FAKE_BPB	EQU	000000001B
  1577                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  1578                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  1579                                  
  1580                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  1581                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1582                                  STATUS_FOR_FORMAT	EQU	000000001B
  1583                                  ; (MSDOS 6.0)
  1584                                  DO_FAST_FORMAT		EQU	000000010B ;AN001;
  1585                                  
  1586                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  1587                                  FORMAT_NO_ROM_SUPPORT	EQU	000000001B
  1588                                  FORMAT_COMB_NOT_SUPPORTED EQU	000000010B
  1589                                  
  1590                                  ; DEVICETYPE VALUES
  1591                                  ; (MSDOS 3.3 + MSDOS 6.0)
  1592                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  1593                                  DEV_5INCH		EQU	0
  1594                                  DEV_5INCH96TPI		EQU	1
  1595                                  DEV_3INCH720KB		EQU	2
  1596                                  DEV_8INCHSS		EQU	3
  1597                                  DEV_8INCHDS		EQU	4
  1598                                  DEV_HARDDISK		EQU	5
  1599                                  DEV_OTHER		EQU	7
  1600                                  ; (MSDOS 6.0)
  1601                                  ;DEV_3INCH1440KB	EQU	7
  1602                                  DEV_3INCH2880KB		EQU	9
  1603                                  ; Retro DOS v2.0 - 26/03/2018
  1604                                  ;;DEV_TAPE		EQU	6
  1605                                  ;;DEV_ERIMO		EQU	8
  1606                                  ;DEV_3INCH2880KB	EQU	9
  1607                                  DEV_3INCH1440KB		EQU	10
  1608                                  
  1609                                  ; (MSDOS 3.3)
  1610                                  ;MAX_DEV_TYPE		EQU	7
  1611                                  
  1612                                  ; (MSDOS 6.0)
  1613                                  MAX_DEV_TYPE		EQU	10	; MAXIMUM DEVICE TYPE THAT WE
  1614                                  					; CURRENTLY SUPPORT.
  1615                                  
  1616                                  struc A_SECTORTABLE
  1617 00000000 ????                    .ST_SECTORNUMBER:	resw	1
  1618 00000002 ????                    .ST_SECTORSIZE:		resw	1
  1619                                  .size:
  1620                                  endstruc
  1621                                  
  1622                                  ;============================================================================
  1623                                  ; DEVSYM.ASM
  1624                                  ;============================================================================
  1625                                  
  1626                                  ;SUBTTL DEVICE TABLE AND SRH DEFINITION
  1627                                  ;PAGE
  1628                                  
  1629                                  ; 07/07/2018 - Retro DOS v3.0
  1630                                  ; (DEVSYM.INC, MSDOS 6.0, 1991)
  1631                                  
  1632                                  ;**	DevSym.inc - Device Symbols
  1633                                  
  1634                                  ; The device table list has the form:
  1635                                  struc	SYSDEV
  1636 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
  1637 00000004 ????                    .ATT:		resw 1		;Attributes of the device
  1638 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
  1639 00000008 ????                    .INT:		resw 1		;Interrupt entry point
  1640 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
  1641                                  .size:
  1642                                  endstruc
  1643                                  
  1644                                  ;
  1645                                  ; ATTRIBUTE BIT MASKS
  1646                                  ;
  1647                                  ; CHARACTER DEVICES:
  1648                                  ;
  1649                                  ; BIT 15 -> MUST BE 1
  1650                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1651                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
  1652                                  ;     12 -> UNUSED
  1653                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
  1654                                  ;     10 -> MUST BE 0
  1655                                  ;      9 -> MUST BE 0
  1656                                  ;      8 -> UNUSED
  1657                                  ;      7 -> UNUSED
  1658                                  ;      6 -> UNUSED
  1659                                  ;      5 -> UNUSED
  1660                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
  1661                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
  1662                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
  1663                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
  1664                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
  1665                                  ;
  1666                                  ; BLOCK DEVICES:
  1667                                  ;
  1668                                  ; BIT 15 -> MUST BE 0
  1669                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
  1670                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
  1671                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
  1672                                  ;	    THE SAME PLACE.
  1673                                  ;     12 -> UNUSED
  1674                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
  1675                                  ;     10 -> MUST BE 0
  1676                                  ;      9 -> MUST BE 0
  1677                                  ;      8 -> UNUSED
  1678                                  ;      7 -> UNUSED
  1679                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
  1680                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
  1681                                  ;      5 -> UNUSED
  1682                                  ;      4 -> UNUSED
  1683                                  ;      3 -> UNUSED
  1684                                  ;      2 -> UNUSED
  1685                                  ;      1 -> UNUSED
  1686                                  ;      0 -> UNUSED
  1687                                  ;
  1688                                  
  1689                                  ;Attribute bit masks
  1690                                  DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
  1691                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
  1692                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
  1693                                  
  1694                                  ; 09/07/2018 - Retro DOS
  1695                                  ; (DEVSYM.INC, MSDOS 3.3, 1987) 
  1696                                  
  1697                                  OUTTILBUSY EQU	2000H		; OUTPUT UNTIL BUSY IS ENABLED
  1698                                  ISNET	   EQU	1000H		; BIT 12 - 1 IF A NET DEVICE, 0 IF
  1699                                  				;  NOT.  CURRENTLY BLOCK ONLY.
  1700                                  DEVOPCL    EQU	0800H		; BIT 11 - 1 IF THIS DEVICE HAS
  1701                                  				;  OPEN,CLOSE AND REMOVABLE MEDIA
  1702                                  				;  ENTRY POINTS, 0 IF NOT
  1703                                  
  1704                                  EXTENTBIT  EQU	0400H		; BIT 10 - CURRENTLY 0 ON ALL DEVS
  1705                                  				;  THIS BIT IS RESERVED FOR FUTURE USE
  1706                                  				;  TO EXTEND THE DEVICE HEADER BEYOND
  1707                                  				;  ITS CURRENT FORM.
  1708                                  
  1709                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
  1710                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
  1711                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
  1712                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
  1713                                  
  1714                                  ; 18/03/2019 - Retro DOS v4.0 (MSDOS 6.0)
  1715                                  IOQUERY	EQU	0080H		;Bit 7 - Supports generic IOCtl query M017
  1716                                  
  1717                                  DEV320	EQU	0040H		;BIT 6 - FOR BLOCK DEVICES, THIS
  1718                                  				;DEVICE SUPPORTS SET/GET MAP OF
  1719                                  				;LOGICAL DRIVES, AND SUPPORTS
  1720                                  				;GENERIC IOCTL CALLS.
  1721                                  				;FOR CHARACTER DEVICES, THIS
  1722                                  				;DEVICE SUPPORTS GENERIC IOCTL.
  1723                                  				;THIS IS A DOS 3.2 DEVICE DRIVER.
  1724                                  
  1725                                  ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018
  1726                                  ;ISIBM	EQU     0010H		;Bit 4 - This device is special
  1727                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
  1728                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
  1729                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
  1730                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
  1731                                  ; 23/07/2019 - Retro DOS v3.2
  1732                                  EXTDRVR	EQU	0002h		;BIT 1 - BLOCK DEVICE EXTENDED DRIVER
  1733                                  				; (MSDOS 6.0, DEVSYM.INC, 1991)
  1734                                  
  1735                                  ;Static Reguest Header
  1736                                  struc	SRHEAD
  1737 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
  1738 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
  1739 00000002 ??                      .REQFUNC:	resb 1		;Type of request
  1740 00000003 ????                    .REQSTAT:	resw 1		;Status Word
  1741 00000005 ????????????????                	resb 8		;Reserved for queue links
  1742                                  .size:
  1743                                  endstruc
  1744                                  
  1745                                  ;Status word masks
  1746                                  STERR   EQU     8000H           ;Bit 15 - Error
  1747                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
  1748                                  STDON   EQU     0100H           ;Bit 8 - Done
  1749                                  STECODE EQU     00FFH           ;Error code
  1750                                  WRECODE EQU     0
  1751                                  
  1752                                  ;Function codes
  1753                                  DEVINIT EQU     0               ;Initialization
  1754                                  DINITHL EQU     26              ;Size of init header
  1755                                  DEVMDCH EQU     1               ;Media check
  1756                                  DMEDHL  EQU     15              ;Size of media check header
  1757                                  DEVBPB  EQU     2               ;Get BPB
  1758                                  DEVRDIOCTL EQU  3               ;IOCTL read
  1759                                  DBPBHL  EQU     22              ;Size of Get BPB header
  1760                                  DEVRD   EQU     4               ;Read
  1761                                  DRDWRHL EQU     22              ;Size of RD/WR header
  1762                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
  1763                                  DRDNDHL EQU     14              ;Size of non destructive read header
  1764                                  DEVIST  EQU     6               ;Input status
  1765                                  DSTATHL EQU     13              ;Size of status header
  1766                                  DEVIFL  EQU     7               ;Input flush
  1767                                  DFLSHL  EQU     15              ;Size of flush header
  1768                                  DEVWRT  EQU     8               ;Write
  1769                                  DEVWRTV EQU     9               ;Write with verify
  1770                                  DEVOST  EQU     10              ;Output status
  1771                                  DEVOFL  EQU     11              ;Output flush
  1772                                  DEVWRIOCTL EQU  12              ;IOCTL write
  1773                                  
  1774                                  ; 09/07/2018 - Retro DOS v3.0
  1775                                  ; (DEVSYM.INC, MSDOS 3.3, 1987) 
  1776                                  
  1777                                  DEVOPN	EQU	13		;DEVICE OPEN
  1778                                  DEVCLS	EQU	14		;DEVICE CLOSE
  1779                                  DOPCLHL EQU	13		;SIZE OF OPEN/CLOSE HEADER
  1780                                  DEVRMD	EQU	15		;REMOVABLE MEDIA
  1781                                  ; 07/08/2018 - Retro DOS v3.0
  1782                                  REMHL	EQU	13		;SIZE OF REMOVABLE MEDIA HEADER
  1783                                  GENIOCTL EQU	19
  1784                                  
  1785                                  ; THE NEXT THREE ARE USED IN DOS 4.0
  1786                                  ;		     20
  1787                                  ;		     21
  1788                                  ;		     22
  1789                                  DEVGETOWN      EQU   23		;GET DEVICE OWNER
  1790                                  DEVSETOWN      EQU   24		;SET DEVICE OWNER
  1791                                  OWNHL	       EQU   13		;SIZE OF DEVICE OWNER HEADER
  1792                                  
  1793                                  DEVOUT	       EQU   16		; OUTPUT UNTIL BUSY.
  1794                                  DEVOUTL        EQU   DEVWRT	; LENGTH OF OUTPUT UNTIL BUSY
  1795                                  
  1796                                  ; GENERIC IOCTL REQUEST STRUCTURE
  1797                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
  1798                                  ;
  1799                                  
  1800                                  struc IOCTL_REQ
  1801 00000000 <res Dh>                .SRHEAD:	resb SRHEAD.size
  1802                                  				; GENERIC IOCTL ADDITION.
  1803 0000000D ??                      .MAJORFUNCTION: resb 1		;FUNCTION CODE
  1804 0000000E ??                      .MINORFUNCTION: resb 1		;FUNCTION CATEGORY
  1805 0000000F ????                    .REG_SI:	resw 1
  1806 00000011 ????                    .REG_DI:	resw 1
  1807 00000013 ????????                .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
  1808                                  .size: ; 07/08/2018
  1809                                  endstruc
  1810                                  
  1811                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
  1812                                  GEN_IOCTL_WRT_TRK EQU	40H
  1813                                  GEN_IOCTL_RD_TRK  EQU	60H
  1814                                  GEN_IOCTL_FN_TST  EQU	20H	; USED TO DIFF. BET READS AND WRTS
  1815                                  
  1816                                  ; 24/07/2019 - Retro DOS v3.2
  1817                                  
  1818                                  ;; 32-bit absolute read/write input list structure
  1819                                  
  1820                                  struc ABS_32RW
  1821 00000000 ????????                .SECTOR_RBA:	resd 1		; relative block address
  1822 00000004 ????                    .ABS_RW_COUNT:	resw 1		; number of sectors to be transferred
  1823 00000006 ????????                .BUFFER_ADDR:	resd 1		; data addrress
  1824                                  .size:
  1825                                  endstruc
  1826                                  
  1827                                  ;============================================================================
  1828                                  ; ERROR.INC (MSDOS 6.0, 1991)
  1829                                  ;============================================================================
  1830                                  ; 16/07/2018 - Retro DOS v3.0 
  1831                                  
  1832                                  ;**	ERROR.INC - DOS Error Codes
  1833                                  ;
  1834                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
  1835                                  ;    return error codes through AX. If an error occurred then
  1836                                  ;    the carry bit will be set and the error code is in AX. If no error
  1837                                  ;    occurred then the carry bit is reset and AX contains returned info.
  1838                                  ;
  1839                                  ;    Since the set of error codes is being extended as we extend the operating
  1840                                  ;    system, we have provided a means for applications to ask the system for a
  1841                                  ;    recommended course of action when they receive an error.
  1842                                  ;
  1843                                  ;    The GetExtendedError system call returns a universal error, an error
  1844                                  ;    location and a recommended course of action. The universal error code is
  1845                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
  1846                                  ;    is issued.
  1847                                  
  1848                                  
  1849                                  ;	2.0 error codes
  1850                                  
  1851                                  error_invalid_function		EQU	1
  1852                                  error_file_not_found		EQU	2
  1853                                  error_path_not_found		EQU	3
  1854                                  error_too_many_open_files	EQU	4
  1855                                  error_access_denied		EQU	5
  1856                                  error_invalid_handle		EQU	6
  1857                                  error_arena_trashed		EQU	7
  1858                                  error_not_enough_memory 	EQU	8
  1859                                  error_invalid_block		EQU	9
  1860                                  error_bad_environment		EQU	10
  1861                                  error_bad_format		EQU	11
  1862                                  error_invalid_access		EQU	12
  1863                                  error_invalid_data		EQU	13
  1864                                  ;**** reserved			EQU	14	; *****
  1865                                  error_invalid_drive		EQU	15
  1866                                  error_current_directory 	EQU	16
  1867                                  error_not_same_device		EQU	17
  1868                                  error_no_more_files		EQU	18
  1869                                  
  1870                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
  1871                                  
  1872                                  error_write_protect		EQU	19
  1873                                  error_bad_unit			EQU	20
  1874                                  error_not_ready 		EQU	21
  1875                                  error_bad_command		EQU	22
  1876                                  error_CRC			EQU	23
  1877                                  error_bad_length		EQU	24
  1878                                  error_seek			EQU	25
  1879                                  error_not_DOS_disk		EQU	26
  1880                                  error_sector_not_found		EQU	27
  1881                                  error_out_of_paper		EQU	28
  1882                                  error_write_fault		EQU	29
  1883                                  error_read_fault		EQU	30
  1884                                  error_gen_failure		EQU	31
  1885                                  
  1886                                  ;	the new 3.0 error codes reported through INT 24
  1887                                  
  1888                                  error_sharing_violation 	EQU	32
  1889                                  error_lock_violation		EQU	33
  1890                                  error_wrong_disk		EQU	34
  1891                                  error_FCB_unavailable		EQU	35
  1892                                  error_sharing_buffer_exceeded	EQU	36
  1893                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00  ;AN000;
  1894                                  error_handle_EOF		EQU	38    ; DOS 4.00  ;AN000;
  1895                                  error_handle_Disk_Full		EQU	39    ; DOS 4.00  ;AN000;
  1896                                  
  1897                                  ;	New OEM network-related errors are 50-79
  1898                                  
  1899                                  error_not_supported		EQU	50
  1900                                  
  1901                                  error_net_access_denied		EQU	65	;M028
  1902                                  
  1903                                  ;	End of INT 24 reportable errors
  1904                                  
  1905                                  error_file_exists		EQU	80
  1906                                  error_DUP_FCB			EQU	81	; *****
  1907                                  error_cannot_make		EQU	82
  1908                                  error_FAIL_I24			EQU	83
  1909                                  
  1910                                  ;	New 3.0 network related error codes
  1911                                  
  1912                                  error_out_of_structures 	EQU	84
  1913                                  error_already_assigned		EQU	85
  1914                                  error_invalid_password		EQU	86
  1915                                  error_invalid_parameter 	EQU	87
  1916                                  error_NET_write_fault		EQU	88
  1917                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00  ;AN000;
  1918                                  
  1919                                  ;	BREAK <Interrupt 24 error codes>
  1920                                  
  1921                                  ;**	Int24 Error Codes
  1922                                  
  1923                                  error_I24_write_protect 	EQU	0
  1924                                  error_I24_bad_unit		EQU	1
  1925                                  error_I24_not_ready		EQU	2
  1926                                  error_I24_bad_command		EQU	3
  1927                                  error_I24_CRC			EQU	4
  1928                                  error_I24_bad_length		EQU	5
  1929                                  error_I24_Seek			EQU	6
  1930                                  error_I24_not_DOS_disk		EQU	7
  1931                                  error_I24_sector_not_found	EQU	8
  1932                                  error_I24_out_of_paper		EQU	9
  1933                                  error_I24_write_fault		EQU	0Ah
  1934                                  error_I24_read_fault		EQU	0Bh
  1935                                  error_I24_gen_failure		EQU	0Ch
  1936                                  ; NOTE: Code 0DH is used by MT-DOS.
  1937                                  error_I24_wrong_disk		EQU	0Fh
  1938                                  
  1939                                  ;	THE FOLLOWING ARE MASKS FOR THE AH REGISTER ON Int 24
  1940                                  ;
  1941                                  ;	NOTE: ABORT is ALWAYS allowed
  1942                                  
  1943                                  Allowed_FAIL			EQU	00001000B
  1944                                  Allowed_RETRY			EQU	00010000B
  1945                                  Allowed_IGNORE			EQU	00100000B
  1946                                  
  1947                                  I24_operation			EQU	00000001B  ;Z if READ,NZ if Write
  1948                                  I24_area			EQU	00000110B  ; 00 if DOS
  1949                                  						   ; 01 if FAT
  1950                                  						   ; 10 if root DIR
  1951                                  						   ; 11 if DATA
  1952                                  I24_class			EQU	10000000B  ;Z if DISK, NZ if FAT or char
  1953                                  
  1954                                  ;	BREAK <GetExtendedError CLASSes ACTIONs LOCUSs>
  1955                                  
  1956                                  ;**	The GetExtendedError call takes an error code and returns CLASS,
  1957                                  ;	ACTION and LOCUS codes to help programs determine the proper action
  1958                                  ;	to take for error codes that they don't explicitly understand.
  1959                                  
  1960                                  ;	Values for error CLASS
  1961                                  
  1962                                  errCLASS_OutRes 	EQU	1	; Out of Resource
  1963                                  errCLASS_TempSit	EQU	2	; Temporary Situation
  1964                                  errCLASS_Auth		EQU	3	; Permission problem
  1965                                  errCLASS_Intrn		EQU	4	; Internal System Error
  1966                                  errCLASS_HrdFail	EQU	5	; Hardware Failure
  1967                                  errCLASS_SysFail	EQU	6	; System Failure
  1968                                  errCLASS_Apperr 	EQU	7	; Application Error
  1969                                  errCLASS_NotFnd 	EQU	8	; Not Found
  1970                                  errCLASS_BadFmt 	EQU	9	; Bad Format
  1971                                  errCLASS_Locked 	EQU	10	; Locked
  1972                                  errCLASS_Media		EQU	11	; Media Failure
  1973                                  errCLASS_Already	EQU	12	; Collision with Existing Item
  1974                                  errCLASS_Unk		EQU	13	; Unknown/other
  1975                                  
  1976                                  ;	Values for error ACTION
  1977                                  
  1978                                  errACT_Retry		EQU	1	; Retry
  1979                                  errACT_DlyRet		EQU	2	; Delay Retry, retry after pause
  1980                                  errACT_User		EQU	3	; Ask user to regive info
  1981                                  errACT_Abort		EQU	4	; abort with clean up
  1982                                  errACT_Panic		EQU	5	; abort immediately
  1983                                  errACT_Ignore		EQU	6	; ignore
  1984                                  errACT_IntRet		EQU	7	; Retry after User Intervention
  1985                                  
  1986                                  ;	Values for error LOCUS
  1987                                  
  1988                                  errLOC_Unk		EQU	1	; No appropriate value
  1989                                  errLOC_Disk		EQU	2	; Random Access Mass Storage
  1990                                  errLOC_Net		EQU	3	; Network
  1991                                  errLOC_SerDev		EQU	4	; Serial Device
  1992                                  errLOC_Mem		EQU	5	; Memory
  1993                                  
  1994                                  ;============================================================================
  1995                                  ; MULT.INC (MSDOS 3.3, 1987)
  1996                                  ;============================================================================
  1997                                  
  1998                                  ;Break <Critical section and Multiplex channels>
  1999                                  
  2000                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2001                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2002                                  ;									   ;
  2003                                  ; Critical section definitions
  2004                                  ;
  2005                                  ; These below are subject to leave-all sections
  2006                                  critDisk    EQU     1			; Disk I/O critical section
  2007                                  critDevice  EQU     2			; Device I/O critical section
  2008                                  critShare   EQU     1			; Sharer I/O critical section
  2009                                  critMem     EQU     1			; memory maintenance critical section
  2010                                  critNet     EQU     5			; network critical section
  2011                                  critSFT     EQU     1			; sft table allocation
  2012                                  ; These below are not subject to leave-all sections
  2013                                  critASSIGN  EQU     8			; Assign has munged a system call
  2014                                  ;									   ;
  2015                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2016                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2017                                  
  2018                                  ;
  2019                                  ; The current set of defined multiplex channels is (* means documented):
  2020                                  ;
  2021                                  ;   Channel(h)	Issuer		Receiver    Function
  2022                                  ;      00	server		PSPRINT     print job control
  2023                                  ;     *01	print/apps	PRINT	    Queueing of files
  2024                                  ;      02	BIOS		REDIR	    signal open/close of printers
  2025                                  ;
  2026                                  ;      05	command 	REDIR	    obtain text of net int 24 message
  2027                                  ;     *06	server/assign	ASSIGN	    Install check
  2028                                  ;
  2029                                  ;      08	external driver IBMBIO	    interface to internal routines
  2030                                  ;
  2031                                  ;      10	sharer/server	Sharer	    install check
  2032                                  ;      11	DOS/server	Redir	    install check/redirection funcs
  2033                                  ;      12	sharer/redir	DOS	    dos functions and structure maint
  2034                                  ;      13	MSNET		MSNET	    movement of NCBs
  2035                                  ;      14	DOS		NLSFUNC     down load NLS country info,DOS 3.3
  2036                                  ;      14	Apps		Popup	    DOS 4.XX popup screen functions
  2037                                  ;	  ***> NOTE <***  Yes there are 2 users of 14h but since DOS 4.XX
  2038                                  ;			  doesn't use NLSFUNC, there is no conflict
  2039                                  ;      15	Apps		MSCDEX	    CD-ROM redirector interface
  2040                                  ;      16	Winoldap (?)	WIN386	    Private Windows communication
  2041                                  ;      17	Winoldap (?)	WIN386	    Win386 clipboard interface
  2042                                  ;      18	Apps		MS-Manager  Toggle interface to manager
  2043                                  ;      19,(13h) external driver IBMBIO	    Reset_Int_13, allows installation
  2044                                  ;					    of alternative INT_13 drivers after
  2045                                  ;					    boot_up
  2046                                  ;      B0	GRAFTABL	GRAFTABL
  2047                                  ;
  2048                                  
  2049                                  MultSHARE   EQU     10h 		; sharer
  2050                                      ;	1   MFT_enter
  2051                                      ;	2   MFTClose
  2052                                      ;	3   MFTclU
  2053                                      ;	4   MFTCloseP
  2054                                      ;	5   MFTCloN
  2055                                      ;	6   set_block
  2056                                      ;	7   clr_block
  2057                                      ;	8   chk_block
  2058                                      ;	9   MFT_get
  2059                                      ;	10  ShSave
  2060                                      ;	11  ShChk
  2061                                      ;	12  ShCol
  2062                                      ;	13  ShCloseFile
  2063                                  
  2064                                  MultNET     EQU     11h 		; Network support
  2065                                      ;	1   NET_RMDIR
  2066                                      ;	2   NET_SEQ_RMDIR
  2067                                      ;	3   NET_MKDIR
  2068                                      ;	4   NET_SEQ_MKDIR
  2069                                      ;	5   NET_CHDIR
  2070                                      ;	6   NET_CLOSE
  2071                                      ;	7   NET_COMMIT
  2072                                      ;	8   NET_READ
  2073                                      ;	9   NET_WRITE
  2074                                      ;	10  NET_LOCK
  2075                                      ;	11  NET_UNLOCK
  2076                                      ;	12  NET_DISK_INFO
  2077                                      ;	13  NET_SET_FILE_ATTRIBUTE
  2078                                      ;	14  NET_SEQ_SET_FILE_ATTRIBUTE
  2079                                      ;	15  NET_GET_FILE_INFO
  2080                                      ;	16  NET_SEQ_GET_FILE_INFO
  2081                                      ;	17  NET_RENAME
  2082                                      ;	18  NET_SEQ_RENAME
  2083                                      ;	19  NET_DELETE
  2084                                      ;	20  NET_SEQ_DELETE
  2085                                      ;	21  NET_OPEN
  2086                                      ;	22  NET_SEQ_OPEN
  2087                                      ;	23  NET_CREATE
  2088                                      ;	24  NET_SEQ_CREATE
  2089                                      ;	25  NET_SEQ_SEARCH_FIRST
  2090                                      ;	26  NET_SEQ_SEARCH_NEXT
  2091                                      ;	27  NET_SEARCH_FIRST
  2092                                      ;	28  NET_SEARCH_NEXT
  2093                                      ;	29  NET_ABORT
  2094                                      ;	30  NET_ASSOPER
  2095                                      ;	31  Printer_SET_STRING
  2096                                      ;	32  NetFlushBuf
  2097                                      ;	33  NetBufWrite
  2098                                      ;	34  NetResetEnvironment
  2099                                      ;	35  NetSpoolCheck
  2100                                      ;	36  NetSpoolClose
  2101                                  
  2102                                  MultDOS     EQU     12h 		; DOS call back
  2103                                      ;	1   DOS_CLOSE
  2104                                      ;	2   RECSET
  2105                                      ;	3   Get DOSGROUP
  2106                                      ;	4   PATHCHRCMP
  2107                                      ;	5   OUT
  2108                                      ;	6   NET_I24_ENTRY
  2109                                      ;	7   PLACEBUF
  2110                                      ;	8   FREE_SFT
  2111                                      ;	9   BUFWRITE
  2112                                      ;	10  SHARE_VIOLATION
  2113                                      ;	11  SHARE_ERROR
  2114                                      ;	12  SET_SFT_MODE
  2115                                      ;	13  DATE16
  2116                                      ;	14  SETVISIT
  2117                                      ;	15  SCANPLACE
  2118                                      ;	16  SKIPVISIT
  2119                                      ;	17  StrCpy
  2120                                      ;	18  StrLen
  2121                                      ;	19  UCase
  2122                                      ;	20  POINTCOMP
  2123                                      ;	21  CHECKFLUSH
  2124                                      ;	22  SFFromSFN
  2125                                      ;	23  GetCDSFromDrv
  2126                                      ;	24  Get_User_Stack
  2127                                      ;	25  GetThisDrv
  2128                                      ;	26  DriveFromText
  2129                                      ;	27  SETYEAR
  2130                                      ;	28  DSUM
  2131                                      ;	29  DSLIDE
  2132                                      ;	30  StrCmp
  2133                                      ;	31  initcds
  2134                                      ;	32  pjfnfromhandle
  2135                                      ;	33  $NameTrans
  2136                                      ;	34  CAL_LK
  2137                                      ;	35  DEVNAME
  2138                                      ;	36  Idle
  2139                                      ;
  2140                                  NLSFUNC     EQU     14h 		; NLSFUNC CALL , DOS 3.3
  2141                                      ;	0   NLSInstall
  2142                                      ;	1   ChgCodePage
  2143                                      ;	2   GetExtInfo
  2144                                      ;	3   SetCodePage
  2145                                      ;	4   GetCntry
  2146                                      ;
  2147                                  ;FASTOPEN is not chained through INT 2F   ; DOS 3.3 F.C.
  2148                                  ;	  it calls Multdos 42 to set up an entry routine address
  2149                                      ;	0   Install status  (reserved)
  2150                                      ;	1   Lookup
  2151                                      ;	2   Insert
  2152                                      ;	3   Delete
  2153                                      ;	4   Purge	    (reserved)
  2154                                  
  2155                                  ;============================================================================
  2156                                  ; FIND.INC (MSDOS 3.3, 1987)
  2157                                  ;============================================================================
  2158                                  ; 09/07/2018 - Retro DOS v3.0
  2159                                  
  2160                                  ;Break	<find first/next buffer>
  2161                                  
  2162                                  struc find_buf
  2163 00000000 ??                      .drive:	    resb 1		; drive of search
  2164 00000001 <res Bh>                .name:	    resb 11		; formatted name
  2165 0000000C ??                      .sattr:	    resb 1		; attribute of search
  2166 0000000D ????                    .LastEnt:   resw 1		; LastEnt
  2167 0000000F ????                    .DirStart:  resw 1		; DirStart
  2168 00000011 ??                      .attr:	    resb 1		; attribute found
  2169 00000012 ????                    .time:	    resw 1		; time
  2170 00000014 ????                    .date:	    resw 1		; date
  2171 00000016 ????                    .size_l:    resw 1		; low(size)
  2172 00000018 ????                    .size_h:    resw 1		; high(size)
  2173 0000001A <res Dh>                .pname:	    resb 13		; packed name
  2174                                  .size:
  2175                                  endstruc
  2176                                  
  2177                                  ;============================================================================
  2178                                  ; DOSCNTRY.INC (MSDOS 3.3, 1987)
  2179                                  ;============================================================================
  2180                                  ; 09/07/2018 - Retro DOS v3.0
  2181                                  
  2182                                  ;Equates for COUNTRY INFORMATION.
  2183                                  SetCountryInfo	EQU	1	;country info
  2184                                  SetUcase	EQU	2	;uppercase table
  2185                                  SetLcase	EQU	3	;lowercase table (Reserved)
  2186                                  SetUcaseFile	EQU	4	;uppercase file spec table
  2187                                  SetFileList	EQU	5	;valid file character list
  2188                                  SetCollate	EQU	6	;collating sequence
  2189                                  SetDBCS 	EQU	7	;double byte character set
  2190                                  SetALL		EQU	-1	;all the entries
  2191                                  
  2192                                  
  2193                                  ;DOS country and code page information table structure.
  2194                                  ;Internally, IBMDOS gives a pointer to this table.
  2195                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
  2196                                  ;this structure.
  2197                                  struc  DOS_CCDPG	; DOS_country_cdpg_info
  2198 00000000 ????????????????        .ccInfo_reserved: 	resb 8	;reserved for internal use
  2199 00000008 <res 40h>               .ccPath_CountrySys:	resb 64 ;path and filename for country info
  2200 00000048 ????                    .ccSysCodePage:		resw 1	;system code page id
  2201 0000004A ????                    .ccNumber_of_entries:	resw 1  ; (default value = 5)
  2202 0000004C ??                      .ccSetUcase:		resb 1  ; (default value = SetUcase)
  2203 0000004D ????????                .ccUcase_ptr:		resd 1	;pointer to Ucase table
  2204                                  
  2205 00000051 ??                      .ccSetUcaseFile:	resb 1	; (default value = SetUcaseFile)
  2206 00000052 ????????                .ccFileUcase_ptr: 	resd 1	;pointer to File Ucase table
  2207                                  
  2208 00000056 ??                      .ccSetFileList:		resb 1 	; (default value = SetFileList)
  2209 00000057 ????????                .ccFileChar_ptr:	resd 1	;pointer to File char list table
  2210                                  
  2211 0000005B ??                      .ccSetCollate:		resb 1	; (default value = SetCollate)
  2212 0000005C ????????                .ccCollate_ptr:		resd 1	;pointer to collate table
  2213                                  
  2214 00000060 ??                      .ccSetCountryInfo:	resb 1  ; (default value = SetCountryInfo)
  2215 00000061 ????                    .ccCountryInfoLen:	resw 1	;length of country info
  2216 00000063 ????                    .ccDosCountry:		resw 1	;system country code id
  2217 00000065 ????                    .ccDosCodePage:		resw 1	;system code page id
  2218 00000067 ????                    .ccDFormat:		resw 1	;date format
  2219 00000069 ??????????              .ccCurSymbol:		resb 5	;5 byte of (currency symbol+0)
  2220 0000006E ????                    .cc1000Sep:		resb 2	;2 byte of (1000 sep. + 0)
  2221 00000070 ????                    .ccDecSep:		resb 2	;2 byte of (Decimal sep. + 0)
  2222 00000072 ????                    .ccDateSep:		resb 2	;2 byte of (date sep. + 0)
  2223 00000074 ????                    .ccTimeSep:		resb 2	;2 byte of (time sep. + 0)
  2224 00000076 ??                      .ccCFormat:		resb 1	;currency format flags
  2225 00000077 ??                      .ccCSigDigits:		resb 1	;# of digits in currency
  2226 00000078 ??                      .ccTFormat:		resb 1	;time format
  2227 00000079 ????????                .ccMono_Ptr:		resd 1	;monocase routine entry point
  2228 0000007D ????                    .ccListSep:		resb 2	;data list separator
  2229 0000007F <res Ah>                .ccReserved_area: 	resw 5	;reserved
  2230                                  .size:
  2231                                  endstruc
  2232                                  
  2233                                  ;Ucase table
  2234                                  struc CC_UCASE_TAB
  2235 00000000 ????                    .ccUcase_leng:		resw 1	; (default value = 128)
  2236 00000002 <res 80h>               .ccUcase_data:		resb 128
  2237                                  endstruc
  2238                                  
  2239                                  ;File Ucase table
  2240                                  struc CC_FILE_UCASE_TAB
  2241 00000000 ????                    .ccFileucase_leng:	resw 1	; (default value = 128)
  2242 00000002 <res 80h>               .ccFileucase_data:	resb 128
  2243                                  endstruc
  2244                                  
  2245                                  ;File char list
  2246                                  struc CC_FILE_CHAR_TAB
  2247 00000000 ????                    .ccFilechar_leng:	resw 1
  2248 00000002 <res 2Eh>               .ccFilechar_data:	resb 46
  2249                                  endstruc
  2250                                  
  2251                                  ;collate table
  2252                                  struc CC_COLLATE_TAB
  2253 00000000 ????                    .ccCollate_leng:	resw 1	; (default value = 128)
  2254 00000002 <res 100h>              .ccCollate_data:	resb 256
  2255                                  endstruc
  2256                                  
  2257                                  OLD_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDFormat - 10)
  2258                                  NEW_COUNTRY_SIZE  equ	(DOS_CCDPG.size - DOS_CCDPG.ccDosCountry) 
  2259                                  
  2260                                  ; 06/08/2018
  2261                                  ; DOSCNTRY.INC (MSDOS 6.0, 1991)
  2262                                  
  2263                                  ;CAPITALIZATION equates
  2264                                  CAP_ONE_CHAR	equ	20H
  2265                                  CAP_STRING	equ	21H
  2266                                  CAP_ASCIIZ	equ	22H
  2267                                  CHECK_YES_NO	equ	23H
  2268                                  UPPER_TABLE	equ	80H
  2269                                  
  2270                                  ;NLS_YES	equ	59H  ; 'Y'
  2271                                  ;NLS_yes2	equ	79H  ; 'y' 	
  2272                                  ;NLS_NO		equ	4EH  ; 'N'	
  2273                                  ;NLS_no2	equ	6EH  ; 'n'	
  2274                                  
  2275                                  ;============================================================================
  2276                                  ; CURDIR.INC (MSDOS 3.3, 1987)
  2277                                  ;============================================================================
  2278                                  ; 09/07/2018 - Retro DOS v3.0
  2279                                  
  2280                                  ;BREAK <Current directory list structure>
  2281                                  
  2282                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2283                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2284                                  ;									   ;
  2285                                  ; CDS items are used bu the internal routines to store cluster numbers and ;
  2286                                  ; network identifiers for each logical name.  The ID field is used dually, ;
  2287                                  ; both as net ID and for a cluster number for local devices.  In the case  ;
  2288                                  ; of local devices, the cluster number will be -1 if there is a potential  ;
  2289                                  ; of the disk being changed or if the path must be recracked.  The END	   ;
  2290                                  ; field is the location of the end of the definition.  No .. is allowed    ;
  2291                                  ; past this point							   ;
  2292                                  
  2293                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
  2294                                  TEMPLEN 	EQU	DIRSTRLEN*2
  2295                                  
  2296                                  struc curdir	; curdir_list
  2297 00000000 <res 43h>               .text:		resb DIRSTRLEN		; text of assignment and curdir
  2298 00000043 ????                    .flags:		resw 1			; various flags
  2299 00000045 ????????                .devptr:	resd 1			; local pointer to DPB or net device
  2300 00000049 ????                    .ID:		resw 1			; cluster of current dir (net ID)
  2301 0000004B ????                    		resw 1
  2302 0000004D ????                    .user_word:	resw 1
  2303 0000004F ????                    .end:		resw 1			; end of assignment
  2304                                  .size:
  2305                                  endstruc
  2306                                  
  2307                                  curdirLen	EQU curdir.size		; Needed for screwed up
  2308                                  
  2309                                  %define curdir_netID curdir_ID  ; dword
  2310                                  
  2311                                  ;Flag word masks
  2312                                  curdir_isnet	EQU	1000000000000000B
  2313                                  curdir_inuse	EQU	0100000000000000B
  2314                                  curdir_splice	EQU	0010000000000000B
  2315                                  curdir_local	EQU	0001000000000000B
  2316                                  ;									   ;
  2317                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2318                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2319                                  
  2320                                  ;============================================================================
  2321                                  ; CPMFCB.INC (MSDOS 3.3, 1987)
  2322                                  ;============================================================================
  2323                                  ; 09/07/2018 - Retro DOS v3.0
  2324                                  
  2325                                  ;BREAK <File Control Block definition>
  2326                                  
  2327                                  ;
  2328                                  ; Field definition for FCBs
  2329                                  ; The FCB has the following structure:
  2330                                  ;
  2331                                  ;	+---------------------------+
  2332                                  ;	|   Drive indicator(byte)   |
  2333                                  ;	+---------------------------+
  2334                                  ;	|    Filename (8 chars)     |
  2335                                  ;	+---------------------------+
  2336                                  ;	|    Extension (3 chars)    |
  2337                                  ;	+---------------------------+
  2338                                  ;	|   Current Extent(word)    |
  2339                                  ;	+---------------------------+
  2340                                  ;	|    Record size (word)     |
  2341                                  ;	+---------------------------+
  2342                                  ;	|    File Size (2 words)    |
  2343                                  ;	+---------------------------+
  2344                                  ;	|	Date of write	    |
  2345                                  ;	+---------------------------+
  2346                                  ;	|	Time of write	    |
  2347                                  ;	+---------------------------+
  2348                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2349                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2350                                  ;									   ;
  2351                                  ;	+---------------------------+
  2352                                  ;	|   8 bytes reserved	    |
  2353                                  ;	+---------------------------+
  2354                                  ;									   ;
  2355                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2356                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2357                                  ;	|    next record number     |
  2358                                  ;	+---------------------------+
  2359                                  ;	|   random record number    |
  2360                                  ;	+---------------------------+
  2361                                  ;
  2362                                  
  2363                                  struc	SYS_FCB
  2364 00000000 ??                      .drive:	resb 1
  2365 00000001 ????????????????        .name:	resb 8
  2366 00000009 ??????                  .ext:	resb 3
  2367 0000000C ????                    .EXTENT: resw 1
  2368 0000000E ????                    .RECSIZ: resw 1			; Size of record (user settable)
  2369 00000010 ????                    .FILSIZ: resw 1			; Size of file in bytes; used with the
  2370                                  				; following word
  2371 00000012 ????                    .DRVBP:	resw 1			; BP for SEARCH FIRST and SEARCH NEXT
  2372 00000014 ????                    .FDATE:	resw 1			; Date of last writing
  2373 00000016 ????                    .FTIME:	resw 1			; Time of last writing
  2374                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2375                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2376                                  ;									   ;
  2377 00000018 ????????????????        .reserved: resb 8		; RESERVED
  2378                                  ;									   ;
  2379                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
  2380                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  2381 00000020 ??                      .NR:	resb 1			; Next record
  2382 00000021 ????????                .RR:	resb 4			; Random record
  2383                                  endstruc
  2384                                  
  2385                                  FILDIRENT EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and SEARCH
  2386                                  				; NEXT
  2387                                  ; 20/07/2018
  2388                                  %define fcb_sfn	SYS_FCB.reserved ; byte
  2389                                  
  2390                                  ; Note that fcb_net_handle, fcb_nsl_drive, fcb_nsld_drive and fcb_l_drive
  2391                                  ; all must point to the same byte.  Otherwise, the FCBRegen will fail.
  2392                                  ; NOTE about this byte (fcb_nsl_drive)
  2393                                  ;   The high two bits of this byte are used as follows to indicate the FCB type
  2394                                  ;	00 means a local file or device with sharing loaded
  2395                                  ;	10 means a remote (network) file
  2396                                  ;	01 means a local file with no sharing loaded
  2397                                  ;	11 means a local device with no sharing loaded
  2398                                  
  2399                                  ; 20/07/2018
  2400                                  
  2401                                  ;
  2402                                  ; Network FCB
  2403                                  ;
  2404                                  
  2405                                  %define fcb_net_drive	SYS_FCB.reserved+1  ; byte
  2406                                  %define fcb_net_handle	SYS_FCB.reserved+2  ; word
  2407                                  %define fcb_netID	SYS_FCB.reserved+4  ; dword		
  2408                                  
  2409                                  ;
  2410                                  ; No sharing local file FCB
  2411                                  ;
  2412                                  
  2413                                  %define fcb_nsl_drive	SYS_FCB.reserved+1  ; byte
  2414                                  %define fcb_nsl_bits	SYS_FCB.reserved+2  ; byte	
  2415                                  %define fcb_nsl_firclus SYS_FCB.reserved+3  ; word	
  2416                                  %define fcb_nsl_dirsec	SYS_FCB.reserved+5  ; word
  2417                                  %define fcb_nsl_dirpos  SYS_FCB.reserved+7  ; byte
  2418                                  
  2419                                  ;
  2420                                  ; No sharing local device FCB
  2421                                  ;
  2422                                  
  2423                                  %define fcb_nsld_drive	SYS_FCB.reserved+1  ; byte	
  2424                                  %define fcb_nsld_drvptr SYS_FCB.reserved+2  ; dword
  2425                                  
  2426                                  ;
  2427                                  ; Sharing local FCB
  2428                                  ;
  2429                                  
  2430                                  %define fcb_l_drive	SYS_FCB.reserved+1  ; byte
  2431                                  %define fcb_l_firclus	SYS_FCB.reserved+2  ; word
  2432                                  %define fcb_l_mfs	SYS_FCB.reserved+4  ; word
  2433                                  %define fcb_l_attr	SYS_FCB.reserved+6  ; byte
  2434                                  
  2435                                  ;
  2436                                  ; Bogusness:  the four cases are:
  2437                                  ;
  2438                                  ;   local file	    00
  2439                                  ;   local device    40
  2440                                  ;   local sharing   C0
  2441                                  ;   network	    80
  2442                                  ;
  2443                                  ; Since sharing and network collide, we cannot use a test instruction for
  2444                                  ; deciding whether a network or a share check in involved
  2445                                  ;
  2446                                  FCBDEVICE   EQU 040h
  2447                                  FCBNETWORK  EQU 080h
  2448                                  FCBSHARE    EQU 0C0h
  2449                                  
  2450                                  ; FCBSPECIAL must be able to mask off both net and share
  2451                                  FCBSPECIAL  EQU 080h
  2452                                  FCBMASK     EQU 0C0h
  2453                                  
  2454                                  ;============================================================================
  2455                                  ; FASTOPEN.INC, MSDOS 6.0, 1991
  2456                                  ;============================================================================
  2457                                  ; 11/07/2018 - Retro DOS v3.0
  2458                                  
  2459                                  ; 22/07/2019 - Retro DOS v3.2
  2460                                  
  2461                                  struc	FEI	; FASTOPEN_EXTENDED_INFO
  2462 00000000 ??                      .dirpos:	resb 1
  2463 00000001 ????????                .dirsec:	resd 1 ; MSDOS 6.0
  2464                                  ;.dirsec:	resw 1 ; MSDOS 3.3
  2465 00000005 ????                    .clusnum:	resw 1
  2466 00000007 ????                    .lastent:	resw 1	; for search first ; MSDOS 6.0
  2467 00000009 ????                    .dirstart:	resw 1	; for search first ; MSDOS 6.0
  2468                                  .size:
  2469                                  endstruc
  2470                                  
  2471                                  ; 23/07/2018
  2472                                  ;FASTOPEN NAME CACHING Subfunctions
  2473                                  FONC_Look_up	equ	1
  2474                                  FONC_insert	equ	2
  2475                                  FONC_delete	equ	3
  2476                                  FONC_update	equ	4
  2477                                  FONC_purge	equ	5	;reserved for the future use.
  2478                                  FONC_Rename	equ	6	;AN001
  2479                                  
  2480                                  ; 27/07/2018
  2481                                  ;FastOpen Data Structure
  2482                                  struc fastopen_entry	;Fastopen Entry pointer in DOS
  2483 00000000 ????                    .entry_size:	resw 1	; = 4	; size of the following
  2484 00000002 ????????                .name_caching:	resd 1
  2485                                  ; MSDOS 6.0
  2486                                  ;.fatchain_caching: resd 1	;reserved for future use
  2487                                  .size:
  2488                                  endstruc
  2489                                  
  2490                                  ; 27/07/2018
  2491                                  ;Equates used in DOS.
  2492                                  FastOpen_Set	       equ     00000001b
  2493                                  FastOpen_Reset	       equ     11111110b
  2494                                  Lookup_Success	       equ     00000010b
  2495                                  Lookup_Reset	       equ     11111101b
  2496                                  Special_Fill_Set       equ     00000100b
  2497                                  Special_Fill_Reset     equ     11111011b
  2498                                  No_Lookup	       equ     00001000b
  2499                                  Set_For_Search	       equ     00010000b	;DCR 167
  2500                                  
  2501                                  ; 09/08/2018 
  2502                                  ; (FASTXXXX.INC, MSDOS 6.0, 1991)
  2503                                  ; Fastxxx equates
  2504                                  FastOpen_ID	   equ	   1
  2505                                  FastSeek_ID	   equ	   2
  2506                                  Fast_yes	   equ	   10000000B	 ; fastxxx flag
  2507                                  
  2508                                  ;Structure definitions
  2509                                  ;
  2510                                  struc Fasttable_Entry	 ; Fastxxx  Entry pointer in DOS
  2511 00000000 ????                    .Fast_Entry_Num: resw 1	 ; number of entries
  2512 00000002 ????????                .FastOpen_Seek:	 resd 1	 ; fastopen & fastseek entry address
  2513                                  endstruc
  2514                                  
  2515                                  ;============================================================================
  2516                                  ; LOCK.INC, MSDOS 6.0, 1991
  2517                                  ;============================================================================
  2518                                  ; 14/07/2018 - Retro DOS v3.0
  2519                                  
  2520                                  ;**	LOCK.INC - Definitions for Record Locking
  2521                                  
  2522                                  ;**	LOCK functions
  2523                                  
  2524                                  LOCK_ALL	    equ    0
  2525                                  UNLOCK_ALL	    equ    1
  2526                                  LOCK_MUL_RANGE	    equ    2
  2527                                  UNLOCK_MUL_RANGE    equ    3
  2528                                  LOCK_READ	    equ    4
  2529                                  WRITE_UNLOCK	    equ    5
  2530                                  LOCK_ADD	    equ    6
  2531                                  
  2532                                  ;**	Structure for Lock buffer
  2533                                  
  2534                                  struc LockBuf
  2535 00000000 ????????                .Lock_position:	resd 1		; file position for LOCK
  2536 00000004 ????????                .Lock_length:	resd 1		; number of bytes to LOCK
  2537                                  endstruc
  2538                                  
  2539                                  ;============================================================================
  2540                                  ; DPL.ASM, MSDOS 6.0, 1991
  2541                                  ;============================================================================
  2542                                  ; 04/08/2018 - Retro DOS v3.0
  2543                                  
  2544                                  ; (SRVCALL.ASM)
  2545                                  
  2546                                  struc DPL
  2547 00000000 ????                    .AX:	resw	1	; AX register
  2548 00000002 ????                    .BX:	resw	1	; BX register
  2549 00000004 ????                    .CX:	resw	1	; CX register
  2550 00000006 ????                    .DX:	resw	1	; DX register
  2551 00000008 ????                    .SI:	resw	1	; SI register
  2552 0000000A ????                    .DI:	resw	1	; DI register
  2553 0000000C ????                    .DS:	resw	1	; DS register
  2554 0000000E ????                    .ES:	resw	1	; ES register
  2555 00000010 ????                    .rsrvd: resw	1	; Reserved
  2556 00000012 ????                    .UID:	resw	1	; User (Machine) ID (0 = local macine)
  2557 00000014 ????                    .PID:	resw	1	; Process ID (0 = local user PID)
  2558                                  .size:
  2559                                  endstruc
  2560                                   
  2561                                  ;============================================================================
  2562                                  ; MSDATA.ASM
  2563                                  ;============================================================================
  2564                                  ;============================================================================
  2565                                  ; MS_DATA.ASM (MSDOS 6.0, 1991) (1)
  2566                                  ;============================================================================
  2567                                  ; 16/07/2018 - Retro DOS 3.0	
  2568                                  
  2569                                  ;Break <Uninitialized data overlayed by initialization code>
  2570                                  
  2571                                  ;DOSDATA    SEGMENT WORD PUBLIC 'DATA'
  2572                                  ; Init code overlaps with data area below
  2573                                  
  2574                                  		; Offset 0358h in IBMDOS.COM (MSDOS 3.3)
  2575                                  
  2576                                  ;	I_am    TIMEBUF,6               ; Time read from clock device
  2577                                  ;	I_am    DEVIOBUF,2              ; Buffer for I/O under file assignment
  2578                                  
  2579                                  TIMEBUF		EQU 	DATASEGMENT	; Offset 0358h (in IBMDOS.COM 3.3)
  2580                                  DEVIOBUF	EQU	TIMEBUF+6
  2581                                  ;
  2582                                  ; The following areas are used as temp buffer in EXEC system call
  2583                                  ;
  2584                                  ;       I_am    OPENBUF,128             ; buffer for name operations
  2585                                  ;       I_am    RenBuf,128              ; buffer for rename destination
  2586                                  
  2587                                  OPENBUF		EQU	DEVIOBUF+2	; DATASEGMENT+8 
  2588                                  RENBUF		EQU	OPENBUF+128	; DATASEGMENT+136
  2589                                  
  2590                                  ; Buffer for search calls
  2591                                  ;        I_am    SEARCHBUF,53		; internal search buffer
  2592                                  ;        I_am    DummyCDS,curdirLen
  2593                                  
  2594                                  SEARCHBUF	EQU	RENBUF+128	; DATASEGMENT+264
  2595                                  DUMMYCDS	EQU	SEARCHBUF+53	; DATASEGMENT+317 
  2596                                  						; Offset 495h in MSDOS 3.3
  2597                                  ;
  2598                                  ; End of contiguous buffer
  2599                                  ;
  2600                                  
  2601                                  ; Temporary directory entry for use by many routines. Device directory
  2602                                  ; entries (bogus) are built here.
  2603                                  ;
  2604                                  ;        PUBLIC  DevFCB
  2605                                  ;DEVFCB  LABEL   BYTE                    ; Uses NAME1, NAME2, combined
  2606                                  ; WARNING.. do not alter position of NAME1 relative to DEVFCB
  2607                                  ; without first examining BUILD_DEVICE_ENT. Look carefully at DOS_RENAME
  2608                                  ; as well as it is the only guy who uses NAME2 and DESTSTART.
  2609                                  
  2610                                  DEVFCB		EQU	DUMMYCDS+curdirLen ; DATASEGMENT+398
  2611                                  
  2612                                  ;	I_am    NAME1,12                ; File name buffer
  2613                                  ;       I_am    NAME2,13                ;
  2614                                  ;	I_am    DESTSTART,WORD          ;
  2615                                  ;	DB      ((SIZE DIR_ENTRY) - ($ - DEVFCB)) DUP (?)
  2616                                  
  2617                                  NAME1		EQU	DEVFCB		; Offset 04E6h in IBMDOS.COM 3.3
  2618                                  NAME2		EQU	NAME1+12	; DATASEGMENT+410
  2619                                  DESTSTART	EQU	NAME2+13	; DATASEGMENT+423
  2620                                  
  2621                                  ;
  2622                                  ; End Temporary directory entry.
  2623                                  ;
  2624                                  
  2625                                  ;       I_am    ATTRIB,BYTE             ; storage for file attributes
  2626                                  ;	I_am    EXTFCB,BYTE             ; TRUE => extended FCB in use
  2627                                  
  2628                                  ATTRIB		EQU	DEVFCB + dir_entry.size ; Offset 0506h
  2629                                  	; Offset 0507h in IBMDOS.COM (MSDOS 3.3) 
  2630                                  EXTFCB		EQU	ATTRIB+1	; DATASEGMENT+431
  2631                                  
  2632                                  ;       I_am    SATTRIB,BYTE            ; Storage for search attributes
  2633                                  ;       I_AM    open_access,BYTE        ; access of open system call
  2634                                  ;       I_am    FoundDel,BYTE           ; true => file was deleted
  2635                                  ;       I_am    Found_dev,BYTE          ; true => search found a device
  2636                                  ;       I_am    fSplice,BYTE            ; true => do a splice in transpath
  2637                                  ;       I_am    fSharing,BYTE           ; TRUE => no redirection
  2638                                  ;       I_am    SECCLUSPOS,BYTE         ; Position of first sector within cluster
  2639                                  ;       I_am    TRANS,BYTE              ;
  2640                                  ;       I_am    READOP,BYTE             ;
  2641                                  ;       I_am    THISDRV,BYTE            ;
  2642                                  ;       I_am    CLUSFAC,BYTE            ;
  2643                                  ;       I_am    CLUSSPLIT,BYTE          ;
  2644                                  ;       I_am    INSMODE,BYTE            ; true => insert mode in buffered read
  2645                                  ;       I_am    cMeta,BYTE              ; count of meta'ed components found
  2646                                  ;       I_am    VOLID,BYTE              ;
  2647                                  ;       I_am    exit_type,BYTE          ; type of exit...
  2648                                  
  2649                                  SATTRIB		EQU	EXTFCB+1	; DATASEGMENT+432
  2650                                  OPEN_ACCESS	EQU	SATTRIB+1	; DATASEGMENT+433
  2651                                  FOUNDDEL	EQU	OPEN_ACCESS+1	; DATASEGMENT+434
  2652                                  FOUND_DEV	EQU	FOUNDDEL+1	; DATASEGMENT+435
  2653                                  FSPLICE		EQU	FOUND_DEV+1	; DATASEGMENT+436
  2654                                  FSHARING	EQU	FSPLICE+1	; DATASEGMENT+437
  2655                                  SECCLUSPOS	EQU	FSHARING+1	; DATASEGMENT+438
  2656                                  TRANS		EQU	SECCLUSPOS+1	; DATASEGMENT+439
  2657                                  READOP		EQU	TRANS+1		; DATASEGMENT+440	
  2658                                  THISDRV		EQU	READOP+1	; DATASEGMENT+441
  2659                                  CLUSFAC		EQU	THISDRV+1	; DATASEGMENT+442
  2660                                  CLUSSPLIT	EQU	CLUSFAC+1	; DATASEGMENT+443
  2661                                  INSMODE		EQU	CLUSSPLIT+1	; DATASEGMENT+444
  2662                                  CMETA		EQU	INSMODE+1	; DATASEGMENT+445
  2663                                  VOLID		EQU	CMETA+1		; DATASEGMENT+446
  2664                                  EXIT_TYPE	EQU	VOLID+1		; DATASEGMENT+447
  2665                                          
  2666                                  ;	EVEN
  2667                                  
  2668                                  ; WARNING - the following two items are accessed as a word
  2669                                  
  2670                                  ;	I_am    CREATING,BYTE           ; true => creating a file
  2671                                  ;	I_am	DELALL,BYTE		; = 0 iff BUGBUG
  2672                                  ;					; = DIRFREE iff BUGBUG
  2673                                  ;	I_am    EXITHOLD,DWORD          ; Temp location for proc terminate
  2674                                  ;	I_am    user_SP,WORD            ; User SP for system call
  2675                                  ;	I_am    user_SS,WORD            ; User SS for system call
  2676                                  ;	I_am    CONTSTK,WORD            ;
  2677                                  ;	I_am    THISDPB,DWORD           ;
  2678                                  ;	I_am    CLUSSAVE,WORD           ;
  2679                                  ; MSDOS 3.3
  2680                                  ;	I_am    CLUSSEC,WORD		;	
  2681                                  ;; MSDOS 6.0
  2682                                  ;;	I_am    CLUSSEC,DWORD           ;>32mb         ; AC0000
  2683                                  
  2684                                  	; Offset 0518h in IBMDOS.COM (MSDOS 3.3) 
  2685                                  
  2686                                  CREATING	EQU	EXIT_TYPE+1 	; DATASEGMENT+448
  2687                                  	; (End of 'MOVDPB' (in MSINIT) - Offset 0519h (just after 'retf'))
  2688                                  DELALL		EQU	CREATING+1	; DATASEGMENT+449
  2689                                  EXITHOLD	EQU	DELALL+1	; DATASEGMENT+450
  2690                                  USER_SP		EQU	EXITHOLD+4	; DATASEGMENT+454
  2691                                  USER_SS		EQU	USER_SP+2	; DATASEGMENT+456
  2692                                  CONTSTK		EQU	USER_SS+2	; DATASEGMENT+458	
  2693                                  THISDPB		EQU	CONTSTK+2	; DATASEGMENT+460
  2694                                  CLUSSAVE	EQU	THISDPB+4	; DATASEGMENT+464
  2695                                  CLUSSEC		EQU	CLUSSAVE+2	; Offset 052Ah ; DATASEGMENT+466
  2696                                  
  2697                                  ;       I_am    PREREAD,WORD            ; 0 means preread; 1 means optional
  2698                                  ;       I_am    FATBYT,WORD             ; Used by ALLOCATE
  2699                                  ;       I_am    FATBYTE,WORD            ; Used by $SLEAZEFUNC
  2700                                  ;       I_am    DEVPT,DWORD             ;
  2701                                  ;       I_am    THISSFT,DWORD           ; Address of user SFT
  2702                                  ;       I_am    THISCDS,DWORD           ; Address of current CDS
  2703                                  ;       I_am    THISFCB,DWORD           ; Address of user FCB
  2704                                  
  2705                                  ; 27/07/2019 - Retro DOS v3.2
  2706                                  ; MSDOS 3.3
  2707                                  ;PREREAD	EQU	CLUSSEC+2	; OffseT 052Ch ; DATASEGMENT+468
  2708                                  ; MSDOS 6.0
  2709                                  PREREAD		EQU	CLUSSEC+4	; DATASEGMENT+470 (27/07/2019)
  2710                                  
  2711                                  FATBYT		EQU	PREREAD+2	; DATASEGMENT+472 (27/07/2019) 
  2712                                  FATBYTE		EQU	FATBYT+2	; DATASEGMENT+474 (27/07/2019)
  2713                                  DEVPT		EQU	FATBYTE+2	; DATASEGMENT+476 (27/07/2019)	
  2714                                  THISSFT		EQU	DEVPT+4		; DATASEGMENT+480 (27/07/2019)
  2715                                  THISCDS		EQU	THISSFT+4	; DATASEGMENT+484 (27/07/2019)	
  2716                                  THISFCB		EQU	THISCDS+4	; DATASEGMENT+488 (27/07/2019)
  2717                                  
  2718                                  ; DATASEGMENT+490 :  ; *!!!*
  2719                                  	; Here is offset 0542h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 
  2720                                  
  2721                                  ; 27/07/2019 - Retro DOS v3.2
  2722                                  ; Here is...
  2723                                  ; DATASEGMENT+492 :  ; *!!!*
  2724                                  
  2725                                  ;SFN		EQU	THISFCB+4	; DATASEGMENT + 0542h - 0358h
  2726                                  
  2727                                  ;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
  2728                                  ;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
  2729                                  ;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
  2730                                  ;       I_am    WFP_START,WORD          ;
  2731                                  ;       I_am    REN_WFP,WORD            ;
  2732                                  ;       I_am    CURR_DIR_END,WORD       ;
  2733                                  ;       I_am    NEXTADD,WORD            ;
  2734                                  ;       I_am    LASTPOS,WORD            ;
  2735                                  ;       I_am    CLUSNUM,WORD            ;
  2736                                  ;       I_am    DIRSEC,DWORD            ;>32mb 		; AC0000
  2737                                  ;       I_am    DIRSTART,WORD           ;
  2738                                  ;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
  2739                                  ;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
  2740                                  ;                                       ; sectors
  2741                                  ;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
  2742                                  ;       I_am    BYTPOS,4                ; Byte position in file of access
  2743                                  ;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
  2744                                  ;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
  2745                                  ;       I_am    SECCNT,WORD             ; No. of whole sectors
  2746                                  ;       I_am    ENTFREE,WORD            ;
  2747                                  ;       I_am    ENTLAST,WORD            ;
  2748                                  ;       I_am    NXTCLUSNUM,WORD         ;
  2749                                  ;       I_am    GROWCNT,DWORD           ;
  2750                                  ;       I_am    CURBUF,DWORD            ;
  2751                                  ;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
  2752                                  ;       I_am    SAVEBX,WORD             ;
  2753                                  ;       I_am    SAVEDS,WORD             ;
  2754                                  ;       I_am    restore_tmp,WORD        ; return address for restore world
  2755                                  ;       I_am    NSS,WORD
  2756                                  ;       I_am    NSP,WORD	
  2757                                  
  2758                                  ;	....  [ MS_DATA.ASM (MSDOS 6.0, 1991) (2) ] ; $$$
  2759                                  
  2760                                  ;DOSDATA ENDS
  2761                                  
  2762                                  ;============================================================================
  2763                                  ; MSHEAD.ASM
  2764                                  ;============================================================================
  2765                                  
  2766                                  [BITS 16]
  2767                                  [ORG 0]
  2768                                  
  2769                                  START:
  2770 00000000 E9BE76                          JMP     DOSINIT
  2771                                  
  2772                                  ;============================================================================
  2773                                  ; MSHEAD.ASM (MSDOS 6.0, 1991)
  2774                                  ;============================================================================
  2775                                  ; 16/07/2018 - Retro DOS 3.0
  2776                                  
  2777                                  	; MSDOS 6.0
  2778                                  ;	dw	PARASTART	; PARASTART = 3DE0h for MSDOS 6.0, 6.22
  2779                                  ;BioDataSeg:
  2780                                  ;	dw	0070h		; Bios data segment fixed at 70h
  2781                                  
  2782                                  	; MSDOS 3.3
  2783 00000003 0000                    	dw	0
  2784 00000005 00                      	db	0 ; 12/08/2018
  2785 00000006 42554720                	db	"BUG "
  2786 0000000A 0000                    	dw	0
  2787 0000000C 0000                    	dw	0
  2788                                  
  2789                                  ;============================================================================
  2790                                  ; MSCONST.ASM (MSDOS 6.0, 1991)
  2791                                  ;============================================================================
  2792                                  ; 16/07/2018 - Retro DOS 3.0	
  2793                                  
  2794                                  	; MSDOS 3.3
  2795                                  MYNUM:			; Offset 000Eh
  2796 0000000E 0000                    	dw	0	
  2797                                  FCBLRU: 
  2798 00000010 0000                    	dw	0
  2799                                  OpenLRU:
  2800 00000012 0000                    	dw	0
  2801                                  OEM_HANDLER: 		; Pointer to OEM handler code	
  2802 00000014 FFFFFFFF                	dd	-1
  2803                                  LeaveAddr:
  2804                                  	;dd	LeaveDOS
  2805 00000018 [FA15]                  	dw	LeaveDOS ; 12/08/2018
  2806                                  RetryCount:		; Share retries
  2807 0000001A 0300                    	dw	3
  2808                                  RetryLoop:
  2809 0000001C 0100                    	dw	1
  2810                                  LastBuffer:
  2811 0000001E FFFFFFFF                	dd	-1	; Buffer queue recency pointer
  2812                                  CONTPOS:
  2813 00000022 0000                    	dw	0	; location in buffer of next read
  2814                                  arena_head:
  2815 00000024 0000                    	dw	0	; Segment # of first arena in memory
  2816                                  
  2817                                  ;; 16/07/2018
  2818                                  ;;****************************************************************************
  2819                                  ;; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
  2820                                  ;;****************************************************************************
  2821                                  ;; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
  2822                                  ;;
  2823                                  ;;	AH = 52h
  2824                                  ;;
  2825                                  ;;	on return:
  2826                                  ;;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
  2827                                  ;;		Known "invars" fields follow (varies with DOS version):
  2828                                  ;;
  2829                                  ;;	Offset Size		 Description
  2830                                  ;;
  2831                                  ;;	 -12   word   sharing retry count (DOS 3.1-3.3)
  2832                                  ;;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
  2833                                  ;;	  -8   dword  pointer to current disk buffer (DOS 3.x)
  2834                                  ;;	  -4   word   pointer in DOS code segment of unread CON input;
  2835                                  ;;		      0 indicates no unread input (DOS 3.x)
  2836                                  ;;	  -2   word   segment of first Memory Control Block (MCB)
  2837                                  ;;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
  2838                                  ;;	  04   dword  pointer to DOS System File Table (SFT)
  2839                                  ;;	  08   dword  pointer to $CLOCK device driver
  2840                                  ;;	  0C   dword  pointer to CON device driver
  2841                                  ;;	  10   byte   number of logical drives in system
  2842                                  ;;	  11   word   maximum bytes/block of any block device
  2843                                  ;;	  13   dword  pointer to DOS cache buffer header
  2844                                  ;;	  17 18bytes  NUL device header, first 4 bytes of device header
  2845                                  ;;		      point to the next device in device chain
  2846                                  ;;
  2847                                  ;;****************************************************************************
  2848                                  
  2849                                  ; The following block of data is used by SYSINIT. 
  2850                                  ; Do not change the order or size of this block
  2851                                  
  2852                                  ;SYSINITVAR:
  2853                                  SYSINITVARS:
  2854                                  DPBHEAD:
  2855 00000026 00000000                	dd	0	; Pointer to head of DPB-FAT list
  2856                                  SFT_ADDR:
  2857 0000002A [98000000]              	dd	SFTABL	; Pointer to first SFT table
  2858                                  BCLOCK:
  2859 0000002E 00000000                	dd	0	; The CLOCK device
  2860                                  BCON:
  2861 00000032 00000000                	dd	0	; Console device entry points
  2862                                  MAXSEC:
  2863 00000036 8000                    	dw	128	; Maximum allowed sector size
  2864                                  BUFFHEAD:
  2865 00000038 00000000                	dd	0	; Pointer to head of buffer queue
  2866                                  CDSADDR:
  2867 0000003C 00000000                	dd	0	; Pointer to curdir structure table
  2868                                  SFTFCB:
  2869 00000040 00000000                	dd	0	; pointer to FCB cache table
  2870                                  KEEPCOUNT:
  2871 00000044 0000                    	dw	0	; count of FCB opens to keep
  2872                                  NUMIO:
  2873 00000046 00                      	db	0	; Number of disk tables
  2874                                  CDSCOUNT:
  2875 00000047 00                      	db	0	; Number of CDS structures in above
  2876                                  ; A fake header for the NUL device
  2877                                  NULDEV:
  2878 00000048 00000000                	dd	0	; Link to rest of device list
  2879                                  	;dw	8004h
  2880 0000004C 0480                    	dw	DEVTYP | ISNULL	; Null device attributes
  2881 0000004E [6A16]                  	dw	SNULDEV	; Strategy entry point
  2882 00000050 [7016]                  	dw	INULDEV	; Interrupt entry point
  2883 00000052 4E554C2020202020        	db	"NUL     " ; Name of null device
  2884                                  SPLICES:
  2885 0000005A 00                      	db	0	; TRUE => splices being done
  2886                                  
  2887                                  	; MSDOS 6.0 
  2888                                  ;Special_Entries:
  2889                                  ;	dw	0	; address of special entries	;AN000;
  2890                                  ;UU_IFS_DOS_CALL:
  2891                                  ;	dd	0	; entry for IFS DOS service	;AN000;
  2892                                  ;; 
  2893                                  ;; UU_IFS_HEADER:
  2894                                  ;; 	dd	0	; IFS header chain		;AN000;
  2895                                  ;;
  2896                                  ;ChkCopyProt:
  2897                                  ;	dw	0	; M068
  2898                                  ;A20OFF_PSP:
  2899                                  ;	dw	0	; M068
  2900                                  ;BUFFERS_PARM1:
  2901                                  ;	dw	0	; value of BUFFERS= ,m 	;AN000;
  2902                                  ;BUFFERS_PARM2:
  2903                                  ;	dw	0	; value of BUFFERS= ,n 	;AN000
  2904                                  ;BOOTDRIVE:
  2905                                  ;	db	0	; the boot drive	;AN000;
  2906                                  ;DDMOVE:
  2907                                  ;	db	0 	; 1 if we need DWORD move ;AN000;
  2908                                  ;EXT_MEM_SIZE:
  2909                                  ;	dw	0	; extended memory size 	;AN000;
  2910                                  
  2911                                  ;HASHINITVAR: ; LABEL   WORD	; AN000;
  2912                                  ;;
  2913                                  ;; Replaced by next two declarations
  2914                                  ;;
  2915                                  ;;UU_BUF_HASH_PTR:
  2916                                  ;;	dd	0	; buffer Hash table addr
  2917                                  ;;UU_BUF_HASH_COUNT:
  2918                                  ;;	dw	1	; number of Hash entries
  2919                                  ;
  2920                                  ;BufferQueue:
  2921                                  ;	dd	0	; Head of the buffer Queue
  2922                                  ;DirtyBufferCount:
  2923                                  ;	dw	0	; Count of Dirty buffers in the Que
  2924                                  ;			; BUGBUG ---- change to byte
  2925                                  ;SC_CACHE_PTR:
  2926                                  ;	dd	0	; secondary cache pointer
  2927                                  ;SC_CACHE_COUNT:
  2928                                  ;	dw	0 	; secondary cache count
  2929                                  ;BuffInHMA:
  2930                                  ;	db	0	; Flag to indicate that buffs are in HMA
  2931                                  ;LoMemBuff:
  2932                                  ;	dd	0	; Ptr to intermediate buffer
  2933                                  ;			;  in Low mem when buffs are in HMA
  2934                                  ;;
  2935                                  ;; All variables which have UU_ as prefix can be reused for other
  2936                                  ;; purposes and can be renamed. All these variables were used for
  2937                                  ;; EMS support of Buffer Manager. Now they are useless for Buffer
  2938                                  ;; manager ---- MOHANS
  2939                                  ;;
  2940                                  ;
  2941                                  ;	I_am	UU_BUF_EMS_FIRST_PAGE,3,<0,0,0>  
  2942                                  ;UU_BUF_EMS_FIRST_PAGE:	
  2943                                  ;	db	0,0,0	; holds the first page above 640K
  2944                                  ;
  2945                                  ;;	I_am	UU_BUF_EMS_NPA640,WORD,<0> ; holds the number of pages 
  2946                                  ;;					   ; above 640K
  2947                                  ;;UU_BUF_EMS_NPA640:
  2948                                  ;;	dw	0			
  2949                                  ;
  2950                                  ;CL0FATENTRY:
  2951                                  ;	dw	-1	; M014:	Holds the data that
  2952                                  ;			; is used in pack/unpack rts.
  2953                                  ;			; in fat.asm if cluster 0 is specified.
  2954                                  ;			; SR;
  2955                                  ;IoStatFail:
  2956                                  ;	db	0	; IoStatFail has been added to 
  2957                                  ;			; record a fail on an I24 
  2958                                  ;			; issued from IOFUNC on a status call. 
  2959                                  ;
  2960                                  ;;***	I_am	UU_BUF_EMS_MODE,BYTE,<-1>	; EMS mode 	;AN000;
  2961                                  ;;***	I_am	UU_BUF_EMS_HANDLE,BYTE		; buffer EMS handle ;AN000;
  2962                                  ;;***	I_am	UU_BUF_EMS_PAGE_FRAME,WORD ,<-1>; EMS page frame # ;AN000;
  2963                                  ;;***	I_am	UU_BUF_EMS_SEG_CNT,WORD,<1>	; EMS seg count	;AN000;
  2964                                  ;;***	I_am	UU_BUF_EMS_PFRAME,WORD		; EMS page frame seg address ;AN000;
  2965                                  ;;***	I_am	UU_BUF_EMS_RESERV,WORD,<0> 	; reserved	;AN000;
  2966                                  ;
  2967                                  ;;***	I_am	UU_BUF_EMS_MAP_BUFF,1,<0>	; this is not used to save the 
  2968                                  ;						; state of the 	buffers page.
  2969                                  ;						; This one byte is retained to 
  2970                                  ;						; keep the size of this data 
  2971                                  ;						; block the same.;
  2972                                  ;ALLOCMSAVE:
  2973                                  ;	db	0	; M063: temp var. used to 
  2974                                  ;			; M063: save alloc method in
  2975                                  ;			; M063: msproc.asm
  2976                                  ;A20OFF_COUNT:
  2977                                  ;	db	0	; M068: indiactes the # of 
  2978                                  ;			; M068: int 21 calls for 
  2979                                  ;			; M068: which A20 is off
  2980                                  ;DOS_FLAG:
  2981                                  ;	db	0	; see DOSSYM.INC for Bit 
  2982                                  ;			; definitions
  2983                                  ;UNPACK_OFFSET:
  2984                                  ;	dw	0	; saves pointer to the start
  2985                                  ;			; of unpack code in exepatch.
  2986                                  ;			; asm.
  2987                                  ;UMBFLAG:
  2988                                  ;	db	0 	; M003: bit 0 indicates the 
  2989                                  ;			; M003: link state of the UMBs
  2990                                  ;			; M003: whether linked or not 
  2991                                  ;			; M003: to the DOS arena chain
  2992                                  ;SAVE_AX:
  2993                                  ;	dw	0	; M000: temp varibale to store ax
  2994                                  ;			; M000: in msproc.asm
  2995                                  ;UMB_HEAD:
  2996                                  ;	dw	-1	; M000: this is initialized to  
  2997                                  ;			; M000: the first umb arena by 
  2998                                  ;			; M000: BIOS sysinit.
  2999                                  ;START_ARENA:
  3000                                  ;	dw	1	; M000: this is the first arena 
  3001                                  ;			; M000: from which DOS will 
  3002                                  ;			; M000: start its scan for alloc.
  3003                                  
  3004                                  ; End of SYSINITVar block
  3005                                  
  3006                                  ; 16/07/2018
  3007                                  ; MSDOS 3.3 (& MDOS 6.0)
  3008                                  
  3009                                  ;
  3010                                  ; Sharer jump table
  3011                                  ;
  3012                                  
  3013                                  ;PUBLIC	JShare
  3014                                  	;EVEN
  3015 0000005B 90                      align 2
  3016                                  
  3017                                  JShare: ; LABEL	DWORD
  3018 0000005C [5618]0000              		DW	BadCall,0
  3019 00000060 [5A18]0000              MFT_enter	DW	OKCall, 0  ; 1   MFT_enter
  3020 00000064 [5A18]0000              MFTClose	DW	OKCall, 0  ; 2   MFTClose
  3021 00000068 [5618]0000              MFTclU		DW	BadCall,0  ; 3   MFTclU
  3022 0000006C [5618]0000              MFTCloseP	DW	BadCall,0  ; 4   MFTCloseP
  3023 00000070 [5618]0000              MFTCloN		DW	BadCall,0  ; 5   MFTCloN
  3024 00000074 [5618]0000              set_block	DW	BadCall,0  ; 6   set_block
  3025 00000078 [5618]0000              clr_block	DW	BadCall,0  ; 7   clr_block
  3026 0000007C [5A18]0000              chk_block	DW	OKCall, 0  ; 8   chk_block
  3027 00000080 [5618]0000              MFT_get		DW	BadCall,0  ; 9   MFT_get
  3028 00000084 [5618]0000              ShSave		DW	BadCall,0  ; 10  ShSave
  3029 00000088 [5618]0000              ShChk		DW	BadCall,0  ; 11  ShChk
  3030 0000008C [5A18]0000              ShCol		DW	OKCall, 0  ; 12  ShCol
  3031 00000090 [5618]0000              ShCloseFile	DW	BadCall,0  ; 13  ShCloseFile
  3032 00000094 [5618]0000              ShSU		DW	BadCall,0  ; 14  ShSU
  3033                                  
  3034                                  ;============================================================================
  3035                                  ; CONST2.ASM (MSDOS 6.0, 1991)
  3036                                  ;============================================================================
  3037                                  ; 16/07/2018 - Retro DOS 3.0	
  3038                                  
  3039                                  ;Break <Initialized data and data used at DOS initialization>
  3040                                  
  3041                                  ;
  3042                                  ; We need to identify the parts of the data area that are relevant to tasks
  3043                                  ; and those that are relevant to the system as a whole.  Under 3.0, the system
  3044                                  ; data will be gathered with the system code.  The process data under 2.x will
  3045                                  ; be available for swapping and under 3.0 it will be allocated per-process.
  3046                                  ;
  3047                                  ; The data that is system data will be identified by [SYSTEM] in the comments
  3048                                  ; describing that data item.
  3049                                  
  3050                                  ;	AsmVars <Debug, Redirector, ShareF>
  3051                                  
  3052                                  ;DOSDATA SEGMENT WORD PUBLIC 'DATA'
  3053                                  
  3054                                  ;
  3055                                  ; Table of routines for assignable devices
  3056                                  ;
  3057                                  ; MSDOS allows assignment if the following standard devices:
  3058                                  ;   stdin  (usually CON input)
  3059                                  ;   stdout (usually CON output)
  3060                                  ;   auxin  (usually AUX input)
  3061                                  ;   auxout (usually AUX output)
  3062                                  ;   stdlpt (usually PRN output)
  3063                                  ;
  3064                                  ; SPECIAL NOTE:
  3065                                  ;   Status of a file is a strange idea. We choose to handle it in this manner:
  3066                                  ;   If we're not at end-of-file, then we always say that we have a character.
  3067                                  ;   Otherwise, we return ^Z as the character and set the ZERO flag. In this
  3068                                  ;   manner we can support program written under the old DOS (they use ^Z as EOF
  3069                                  ;   on devices) and programs written under the new DOS (they use the ZERO flag
  3070                                  ;   as EOF).
  3071                                  
  3072                                  ; Default SFTs for boot up
  3073                                  
  3074                                  		;PUBLIC	SFTABL
  3075                                  
  3076                                  SFTABL:	   ; LABEL   DWORD		; file table
  3077 00000098 FFFF                    		DW -1			; link to next table
  3078 0000009A FFFF                    		DW -1			; link seg to next table
  3079 0000009C 0500                    		DW sf_default_number	; Number of entries in table
  3080 0000009E 00<rep 127h>            		times (sf_default_number*sf_entry_size) db 0
  3081                                  
  3082                                  ; the next two variables relate to the position of the logical stdout/stdin
  3083                                  ; cursor. They are only meaningful when stdin/stdout are assigned to the
  3084                                  ; console.
  3085                                  
  3086                                  		; Offset 01A7h in IBMDOS.COM (MSDOS 3.3)
  3087 000001C5 00                      CARPOS:		db 0			; cursor position in stdin
  3088 000001C6 00                      STARTPOS:	db 0			; position of cursor at beginning
  3089 000001C7 00<rep 80h>             INBUF:		times 128 db 0		; general device input buffer
  3090 00000247 00<rep 83h>             CONBUF:		times 131 db 0		; The rest of INBUF and console buffer
  3091                                  		; Offset 02ACh in IBMDOS.COM (MSDOS 3.3)
  3092 000002CA 00                      PFLAG:		db 0			; printer echoing flag
  3093 000002CB 00                      VERFLG:		db 0			; Initialize with verify off
  3094 000002CC 03                      CHARCO:		db 00000011b		; Allows statchks every 4 chars...
  3095                                  switch_character:
  3096 000002CD 2F                      chSwitch:	db '/'			; UNUSED - obsolete datum, can be reused
  3097 000002CE 00                      AllocMethod:	db 0			; how to alloc first(best)last
  3098 000002CF 00                      fShare:		db 0			; TRUE => sharing installed
  3099 000002D0 01                      DIFFNAM:	db 1			; Indicates when MYNAME has changed                                        ; of buffered input call
  3100 000002D1 20<rep 10h>             MYNAME:		times 16 db 20h		; My network name
  3101                                  
  3102                                  ;
  3103                                  ; The following table is a list of addresses that the sharer patches to be
  3104                                  ; PUSH AX to enable the critical sections
  3105                                  ;
  3106                                  		; Offset 02C3h in IBMDOS.COM (MSDOS 3.3)
  3107                                  
  3108                                  ;PUBLIC	CritPatch
  3109                                  
  3110                                  CritPatch:	; LABEL WORD
  3111                                  
  3112                                  ;IRP sect,<critDisk,critDevice>
  3113                                  
  3114                                  ;IF (NOT REDIRECTOR) AND (NOT SHAREF)
  3115                                  ;
  3116                                  ;SR; Change code patch address to a variable in data segment
  3117                                  ;
  3118                                  ;       dw OFFSET DOSDATA: redir_patch
  3119                                  ;       dw OFFSET DOSDATA: redir_patch
  3120                                  ;
  3121                                  ;;hkn	Short_Addr  E&sect
  3122                                  ;;hkn	Short_Addr  L&sect
  3123                                  ;
  3124                                  ;ELSE
  3125                                  ;	DW	0
  3126                                  ;	DW	0
  3127                                  ;ENDIF
  3128                                  ;ENDM
  3129                                  ;	DW	0
  3130                                  
  3131                                  	; 16/07/2018 - Retro DOS v3.0
  3132                                  	; IBMDOS.COM (MSDOS 3.3), offset 02C3h
  3133                                   
  3134 000002E1 [0D21]                  	dw 	EcritDisk
  3135 000002E3 [1521]                  	dw 	LcritDisk			
  3136 000002E5 [1D21]                  	dw	EcritDevice
  3137 000002E7 [2521]                  	dw 	LcritDevice
  3138                                  
  3139 000002E9 0000                    	dw	0
  3140                                  
  3141                                  ;
  3142                                  ; WARNING!!!  PRINT and PSPRINT *REQUIRE* ErrorMode to precede INDOS.
  3143                                  ; Also, IBM server 1.0 requires this also.
  3144                                  ;
  3145                                  	;EVEN			; Force swap area to start on word boundry
  3146 000002EB 90                      align 2
  3147                                  	;PUBLIC	SWAP_START
  3148                                  SWAP_START:	; LABEL BYTE
  3149 000002EC 00                      ERRORMODE:	db 0		; Flag for INT 24 processing
  3150 000002ED 00                      INDOS:		db 0		; DOS status for interrupt processing
  3151 000002EE FF                      WPERR:		db -1		; Write protect error flag
  3152 000002EF 00                      EXTERR_LOCUS:	db 0		; Extended Error Locus
  3153 000002F0 0000                    EXTERR:		dw 0		; Extended Error code
  3154                                  
  3155                                  ;WARNING Following two bytes Accessed as word in $GetExtendedError
  3156 000002F2 00                      EXTERR_ACTION:	db 0		; Extended Error Action
  3157 000002F3 00                      EXTERR_CLASS:	db 0		; Extended Error Class
  3158                                  ; end warning
  3159                                   
  3160 000002F4 00000000                EXTERRPT:	dd 0		; Extended Error pointer
  3161                                  
  3162 000002F8 8000                    DMAADD:		dw 80H		; User's disk transfer address (disp/seg)
  3163 000002FA 0000                                    dw 0	
  3164 000002FC 0000                    CurrentPDB:	dw 0		; Current process identifier
  3165 000002FE 0000                    ConC_Spsave:	dw 0		; saved SP before ^C
  3166 00000300 0000                    exit_code:	dw 0		; exit code of last proc.
  3167 00000302 00                      CURDRV:		db 0		; Default drive (init A)
  3168 00000303 00                      CNTCFLAG:	db 0		; ^C check in dispatch disabled
  3169                                  ;				; F.C. 2/17/86
  3170                                  ;CPSWFLAG:	db 0		; Code Page Switching Flag  DOS 4.00
  3171                                  ;CPSWSAVE:	db 0		; copy of above in case of ABORT
  3172                                  SWAP_ALWAYS:	; 05/08/2018
  3173 00000304 0000                    USER_IN_AX:	dw 0		; User INPUT AX value (used for
  3174                                  				;   extended error type stuff.
  3175                                  				;   NOTE: does not have Correct value on
  3176                                  				;   1-12, OEM, Get/Set CurrentPDB,
  3177                                  				;   GetExtendedError system calls)
  3178 00000306 0000                    PROC_ID:	dw 0		; PID for sharing (0 = local)
  3179 00000308 0000                    USER_ID:	dw 0		; Machine for sharing (0 = local)
  3180 0000030A 0000                    FirstArena:	dw 0		; first free block found
  3181 0000030C 0000                    BestArena:	dw 0		; best free block found
  3182 0000030E 0000                    LastArena:	dw 0		; last free block found
  3183 00000310 0000                    ENDMEM:		dw 0		; End of memory used in DOSINIT
  3184 00000312 0000                    LASTENT:	dw 0		; Last entry for directory search
  3185 00000314 00                      FAILERR:	db 0		; NZ if user did FAIL on I 24
  3186 00000315 00                      ALLOWED:	db 0		; Allowed I 24 answers (see allowed_)
  3187 00000316 00                      NoSetDir:	db 0		; true -> do not set directory
  3188 00000317 00                      DidCTRLC:	db 0		; true -> we did a ^C exit
  3189 00000318 00                      SpaceFlag:	db 0		; true -> embedded spaces are allowed in FC
  3190                                  
  3191                                  ; Warning!  The following items are accessed as a WORD in TIME.ASM
  3192                                  	;EVEN
  3193 00000319 90                      align 2
  3194                                  	; Offset 02FCh in IBMDOS.COM (MSDOS 3.3); 
  3195 0000031A 00                      DAY:		db 0		; Day of month
  3196 0000031B 00                      MONTH:		db 0		; Month of year
  3197 0000031C 0000                    YEAR:		dw 0		; Year (with century)
  3198 0000031E FFFF                    DAYCNT:		dw -1		; Day count from beginning of year
  3199 00000320 00                      WEEKDAY:	db 0		; Day of week
  3200                                  ; end warning
  3201                                  
  3202 00000321 00                      CONSWAP:	db 0		; TRUE => console was swapped during device read
  3203 00000322 01                      IDLEINT:	db 1		; TRUE => idle int is allowed
  3204 00000323 00                      fAborting:	db 0		; TRUE => abort in progress
  3205                                  
  3206                                  ; Combination of all device call parameters
  3207                                  	;PUBLIC	DEVCALL 	;
  3208                                  ;DEVCALL SRHEAD	<>		; basic header for disk packet
  3209                                  DEVCALL: ; 08/08/2018
  3210 00000324 00                      DEVCALL_REQLEN:  db 0 		;Length in bytes of request block
  3211 00000325 00                      DEVCALL_REQUNIT: db 0		;Device unit number
  3212 00000326 00                      DEVCALL_REQFUNC: db 0		;Type of request
  3213 00000327 0000                    DEVCALL_REQSTAT: dw 0		;Status Word
  3214 00000329 00<rep 8h>                       times 8 db 0		;Reserved for queue links
  3215                                  
  3216                                  	;PUBLIC	CALLUNIT
  3217                                  CALLUNIT: ; LABEL   BYTE	; unit number for disk
  3218                                  CALLFLSH: ; LABEL   WORD	;
  3219 00000331 00                      CALLMED:	db 0		; media byte
  3220                                  CALLBR:	  ; LABEL   DWORD	;
  3221                                  	;PUBLIC	CALLXAD 	;
  3222                                  CALLXAD:  ; LABEL   DWORD	;
  3223 00000332 00                      CALLRBYT:	db 0		;
  3224                                  	;PUBLIC	CALLVIDM	;
  3225                                  CALLVIDM: ; LABEL   DWORD	;
  3226 00000333 00<rep 3h>              	times 3 db 0	;
  3227                                  	;PUBLIC CallBPB		;
  3228                                  CALLBPB:  ; LABEL   DWORD	;
  3229                                  CALLSCNT:			;
  3230 00000336 0000                    		dw 0		;
  3231                                  	;PUBLIC	CALLSSEC	;
  3232                                  CALLSSEC: ; LABEL   WORD	;
  3233 00000338 0000                    		dw 0		;
  3234 0000033A 00000000                CALLVIDRW:	dd 0		;
  3235                                  		; 24/07/2019
  3236                                  ;MSDOS 6.0
  3237 0000033E 00000000                CALLNEWSC:	dd 0		; starting sector for >32mb
  3238 00000342 00000000                CALLDEVAD:	dd 0		; stash for device entry point
  3239                                  
  3240                                  ; Same as above for I/O calls	;
  3241                                  				;
  3242                                  	;PUBLIC	IOCall		;
  3243                                  ;IOCALL	SRHEAD	<>		;
  3244                                  IOCALL:	; 07/08/2018
  3245 00000346 00                      IOCALL_REQLEN:	db 0		;Length in bytes of request block	
  3246 00000347 00                      IOCALL_REQUNIT:	db 0		;Device unit number
  3247 00000348 00                      IOCALL_REQFUNC: db 0		;Type of request
  3248 00000349 0000                    IOCALL_REQSTAT: dw 0		;Status Word
  3249 0000034B 00<rep 8h>              	times 8	db 0		;Reserved for queue links
  3250                                  IOFLSH:	  ; LABEL   WORD	;
  3251                                          ;PUBLIC  IORCHR		;
  3252                                  IORCHR:	  ; LABEL   BYTE	;
  3253 00000353 00                      IOMED:		db 0		;
  3254 00000354 00000000                IOXAD:		dd 0		;
  3255 00000358 0000                    IOSCNT:		dw 0		;	
  3256 0000035A 0000                    IOSSEC:		dw 0		;
  3257                                  
  3258                                  ; Call struct for DSKSTATCHK	;
  3259 0000035C 0E                      DSKSTCALL:	db DRDNDHL 	; = 14
  3260 0000035D 00                      		db 0
  3261 0000035E 05                      DSKSTCOM:	db DEVRDND	; = 5
  3262 0000035F 0000                    DSKSTST:	dw 0		;
  3263 00000361 00<rep 8h>              	times 8	db 0		;
  3264 00000369 00                      DSKCHRET:	db 0		;
  3265                                  
  3266                                  ;hkn; short_addr has been changed to provide offset in DOSCODE.
  3267                                  ;hkn; deviobuf is in DATA seg (DOSDATA)
  3268                                  ;hkn   short_addr  DEVIOBUF	;
  3269                                  	
  3270 0000036A [8003]                  DEVIOBUF_PTR	dw DEVIOBUF
  3271 0000036C 0000                    DOSSEG_INIT	dw 0		; DOS segment set at Init
  3272 0000036E 0100                    DSKSTCNT:	dw 1		;
  3273 00000370 0000                    		dw 0		;
  3274                                  
  3275 00000372 00                      CreatePDB:	db 0		; flag for creating a process
  3276                                  
  3277                                  ;* MSDOS 6.0
  3278                                  ;*	;PUBLIC	Lock_Buffer	;
  3279                                  ;*Lock_Buffer: ; LABEL  DWORD	;MS. DOS Lock Buffer for Ext Lock
  3280                                  ;*	    	dd 0		;MS. position
  3281                                  ;*	 	dd 0		;MS. length
  3282                                  
  3283                                  ;hkn; the foll. was moved from dosmes.asm.
  3284                                  
  3285                                  	;EVEN
  3286 00000373 90                      align 2				; needed to maintain offsets
  3287                                  
  3288                                  	; Offset 0352h in IBMDOS.COM (MSDOS 3.3)
  3289                                  	;PUBLIC  UserNum, OEMNum
  3290                                  USERNUM:
  3291 00000374 0000                     		dw 0		; 24 bit user number
  3292 00000376 00                      		db 0
  3293                                  ;IF IBM
  3294                                  ;IF IBMCOPYRIGHT
  3295 00000377 00                      OEMNUM:		DB 0		; 8 bit OEM number
  3296                                  ;ELSE
  3297                                  ;OEMNUM:	DB 0FFh		; 8 bit OEM number
  3298                                  ;ENDIF
  3299                                  ;ELSE
  3300                                  ;OEMNUM:	DB 0FFh
  3301                                  ;ENDIF
  3302                                  
  3303                                  ; 17/07/2018
  3304                                  ;----------------------------------------------------------------------------
  3305                                  ; (MSDOS 3.3, DOSMES.INC, 1987)
  3306                                  
  3307                                  ; The next variable points to the country table for the current country
  3308                                  ;	(the table returned by the AL=0 INTERNATIONAL call).
  3309                                  
  3310 00000378 [2210]                  CurrentCounry:	dw USTABLE			
  3311                                  
  3312                                  
  3313                                  ;DOSDATA ENDS
  3314                                  
  3315                                  ;----------------------------------------------------------------------------
  3316                                  
  3317                                  ; 16/07/2018 - Retro DOS v3.0
  3318                                  
  3319                                  align 2
  3320                                  
  3321                                  DATASEGMENT EQU $ ; 17/04/2018
  3322                                  
  3323                                  ;============================================================================
  3324                                  ; MSINIT.ASM
  3325                                  ;============================================================================
  3326                                  ; 16/07/2018 - Retro DOS v3.0
  3327                                  ;	      (MSINIT code order/reference: MSDOS 3.3, IBMDOS.COM, 1987)
  3328                                  	
  3329                                  ; 15/04/2018 - Retro DOS v2.0 (DATA adaption for NASM)
  3330                                  
  3331                                  ; TITLE MSINIT.ASM -- MS-DOS INITIALIZATION CODE
  3332                                  
  3333                                  ;       ORG     0                       ; reset to beginning of data segment
  3334                                  ; Init code below overlaps with data area
  3335                                  	
  3336                                  	; Offset 0358h in IBMDOS.COM (MSDOS 3.3)
  3337                                  
  3338                                  ;INITBLOCK DB	110H DUP(0)     ; Allow for segment round up
  3339 0000037A 00<rep 110h>            INITBLOCK:	TIMES 272 DB 0
  3340                                  
  3341                                  	; Offset 0468h in IBMDOS.COM (MSDOS 3.3)
  3342                                  
  3343 0000048A 0000                    INITSP:		DW 0
  3344 0000048C 0000                    INITSS:		DW 0
  3345                                  ;BUFFSTRT:	DW 0
  3346                                  
  3347                                  	; Offset 046Ch in IBMDOS.COM (MSDOS 3.3)	
  3348                                  
  3349                                  ;ASSUME  CS:DOSGROUP,DS:DOSGROUP,ES:DOSGROUP,SS:NOTHING
  3350                                  ;
  3351                                  ;        EXTRN   QUIT:NEAR,IRET:NEAR,ABSDRD:FAR,ABSDWRT:FAR
  3352                                  ;        EXTRN   COMMAND:NEAR,CALL_ENTRY:NEAR
  3353                                  ;        IF      NOT IBM
  3354                                  ;        EXTRN   HEADER:BYTE
  3355                                  ;        ENDIF
  3356                                  
  3357                                  MOVDPB:
  3358                                  	; 08/07/2018 - Retro DOS v3.0
  3359                                  ; This section of code is safe from being overwritten by block move
  3360                                          ;MOV     SP,[CS:INITSP]
  3361                                          ;MOV     SS,[CS:INITSS]
  3362                                          ; 30/03/2018
  3363 0000048E 8B26[8A04]              	MOV     SP,[INITSP]
  3364 00000492 8E16[8C04]                      MOV     SS,[INITSS]
  3365 00000496 F3A4                    	REP     MOVSB
  3366 00000498 FC                              CLD
  3367                                          ; 15/07/2018
  3368                                  	;MOV	[ES:DMAADD+2],DX
  3369 00000499 8916[FA02]              	MOV	[DMAADD+2],DX
  3370 0000049D 8B36[2600]                      MOV     SI,[DPBHEAD]	; Address of first DPB
  3371                                  	;MOV	[ES:DPBHEAD+2],ES
  3372 000004A1 8C06[2800]                      MOV	[DPBHEAD+2],ES
  3373                                  	;MOV	[ES:SFT_ADDR+2],ES
  3374 000004A5 8C06[2C00]              	MOV     [SFT_ADDR+2],ES
  3375 000004A9 8A0E[4600]                      MOV     CL,[NUMIO]	; Number of DPBs
  3376 000004AD 30ED                            XOR     CH,CH
  3377                                  SETFINDPB:
  3378                                  	; 24/07/2019 - Retro DOS v3.2
  3379                                  	; 06/07/2019 - Retro DOS v3.1
  3380                                          ;MOV	[ES:SI+1AH],ES
  3381                                  	;mov	[si+1Ah],es ; MSDOS 3.3
  3382                                  	;mov	[si+1Bh],es ; MSDOS 6.0
  3383 000004AF 8C441B                          mov	[si+DPB.NEXT_DPB+2],es
  3384                                  	;MOV	BYTE [ES:SI+17H],-1  ; Never accessed before
  3385                                  	;mov	byte [si+17h],-1 ; MSDOS 3.3
  3386                                  	;mov	byte [si+18h],-1 ; MSDOS 6.0
  3387 000004B2 C64418FF                	mov	byte [si+DPB.FIRST_ACCESS],-1
  3388                                  	;add	si,32 ; MSDOS 3.3
  3389                                  	;add	si,33 ; MSDOS 6.0
  3390 000004B6 83C621                          ADD     SI,DPBSIZ ; Point to next DPB
  3391 000004B9 E2F4                    	LOOP    SETFINDPB
  3392                                  	;sub	si,32 ; MSDOS 3.3
  3393                                  	;sub	si,33 ; MSDOS 6.0
  3394 000004BB 83EE21                          SUB     SI,DPBSIZ
  3395                                  	;MOV	WORD [ES:SI+1AH],-1
  3396                                  	;mov	word [SI+1Ah],-1 ; MSDOS 3.3 
  3397                                  	;mov	word [si+1Bh],-1 ; MSDOS 6.0
  3398 000004BE C7441BFFFF              	mov	word [si+DPB.NEXT_DPB+2],-1
  3399                                  
  3400                                          ; 15/07/2018 - Retro DOS v3.0
  3401                                  	;; MSDOS 2.11
  3402                                          ;MOV	DI,[BUFFSTRT]		; Set up one default buffer
  3403                                  	;MOV	[ES:BUFFHEAD+2],ES
  3404                                          ;MOV	[ES:BUFFHEAD],DI
  3405                                  	; MSDOS 3.3
  3406 000004C3 06                      	push	es ; *
  3407 000004C4 BF[CF76]                	mov	di,SYSBUF+15  ; 721Fh for MSDOS 3.3 kernel (MSDOS.SYS)
  3408 000004C7 D1DF                    	rcr	di,1
  3409 000004C9 D1EF                    	shr	di,1
  3410 000004CB D1EF                    	shr	di,1
  3411 000004CD D1EF                    	shr	di,1
  3412 000004CF 8CC0                    	mov	ax,es
  3413 000004D1 01F8                    	add	ax,di
  3414 000004D3 8EC0                    	mov	es,ax
  3415 000004D5 31FF                    	xor	di,di
  3416 000004D7 8C06[3A00]              	mov     [BUFFHEAD+2],es
  3417 000004DB 893E[3800]              	mov     [BUFFHEAD],di
  3418                                  	;	
  3419 000004DF 26C74504FF00                    MOV     WORD [ES:DI+4],00FFH
  3420 000004E5 26C705FFFF                      MOV     WORD [ES:DI],-1
  3421 000004EA 26C74502FFFF                    MOV     WORD [ES:DI+2],-1
  3422 000004F0 07                      	pop	es ; * ; 15/07/2018
  3423 000004F1 06                              PUSH    ES
  3424 000004F2 42                              INC     DX ; **			; Leave enough room for the ARENA
  3425 000004F3 8B36[1003]              	mov	si,[ENDMEM] ; 15/07/2018
  3426                                  
  3427                                  	; 11/08/2018 - Retro DOS v3.0
  3428                                          ;invoke _$DUP_PDB		; create jfns and set CurrentPDB
  3429 000004F7 E8F219                  	CALL	_$DUP_PDB
  3430 000004FA 07                              POP	ES
  3431                                  
  3432                                  	; [CurrentPDB] = dx ; **
  3433                                  	; ds = previous [CurrentPDB]
  3434                                  	; es = cs
  3435                                  
  3436                                  ; set up memory arena
  3437                                  ;SPECIAL NOTE FOR HIGHMEM VERSION
  3438                                  ; At this point a process header has been built where the start of the 
  3439                                  ; CONSTANTS segment as refed by CS is. From this point until the return 
  3440                                  ; below be careful about references off of CS.
  3441                                  
  3442                                  	; 13/04/2018 ; *
  3443                                          ;PUSH	AX ; *
  3444                                          ;MOV	AX,[CurrentPDB]
  3445                                         	
  3446                                  	; 06/07/2019
  3447                                  	;MOV	AX,[CS:CurrentPDB] ; 15/03/2018
  3448                                  	;MOV    [ES:CurrentPDB],AX	; Put it in the REAL location
  3449                                          ;MOV	BYTE [ES:CreatePDB],0	; reset flag in REAL location
  3450                                          
  3451 000004FB 2EA1[FC02]              	mov	ax,[cs:CurrentPDB]  ; es = cs
  3452                                  
  3453 000004FF 48                      	DEC     AX
  3454 00000500 26A3[2400]                      MOV     [ES:arena_head],AX
  3455 00000504 1E                              PUSH    DS
  3456 00000505 8ED8                            MOV     DS,AX
  3457 00000507 C60600005A                      MOV     BYTE [ARENA.SIGNATURE],arena_signature_end
  3458 0000050C C70601000000                    MOV     WORD [ARENA.OWNER],arena_owner_system
  3459 00000512 262B06[1003]                    SUB     AX,[ES:ENDMEM]
  3460 00000517 F7D8                            NEG     AX
  3461 00000519 48                              DEC     AX
  3462 0000051A A30300                          MOV     [ARENA.SIZE],AX
  3463 0000051D 1F                              POP     DS
  3464                                          ;POP	AX ; *
  3465                                  
  3466 0000051E BF[9E00]                        MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
  3467                                  	; 15/07/2018
  3468 00000521 B80300                          MOV     AX,3
  3469 00000524 AB                              STOSW		; Adjust Refcount
  3470                                  	;MOV	DI,SYSINITVAR	; 16/03/2018 (Retro DOS v2.0)
  3471 00000525 BF[6B0F]                	MOV     DI,SysInitTable ; 15/07/2018 (Retro DOS v3.0)
  3472 00000528 CB                              RETF
  3473                                  	
  3474                                  	; 18/04/2018
  3475                                  FILL1	equ	$ - DATASEGMENT
  3476                                  ; ---------------------------------------------------------------------------
  3477                                  ; 16/07/2018 - Retro DOS v3.0
  3478                                  	;times (490-FILL1) db 0	; *!!!*
  3479                                  ; 27/07/2019 - Retro DOS v3.2
  3480 00000529 00<rep 3Dh>             	times (492-FILL1) db 0	; *!!!*
  3481                                  
  3482                                  ;============================================================================
  3483                                  ; MS_DATA.ASM (MSDOS 6.0, 1991)  (2)
  3484                                  ;============================================================================
  3485                                  ; 16/07/2018 - Retro DOS 3.0	
  3486                                  ; 27/07/2019 - Retro DOS 3.2
  3487                                  
  3488                                  ;  MS_DATA.ASM (MSDOS 6.0, 1991) (1) ... $$$
  3489                                   
  3490                                  ; (continues from 'SFN' ..) - from offset 0542h in IBMDOS.COM, 1987 -
  3491                                  
  3492                                  ; DATASEGMENT + 490 ; Retro DOS v3.0
  3493                                  ; DATASEGMENT + 492 ; Retro DOS v3.2
  3494                                  
  3495                                  ;       I_am    SFN,WORD,<-1>           ; SystemFileNumber found for accessfile
  3496                                  ;       I_am    JFN,WORD                ; JobFileNumber found for accessfile
  3497                                  ;       I_am    PJFN,DWORD              ; PointerJobFileNumber found for accessfile
  3498                                  ;       I_am    WFP_START,WORD          ;
  3499                                  ;       I_am    REN_WFP,WORD            ;
  3500                                  ;       I_am    CURR_DIR_END,WORD       ;
  3501                                  ;       I_am    NEXTADD,WORD            ;
  3502                                  ;       I_am    LASTPOS,WORD            ;
  3503                                  ;       I_am    CLUSNUM,WORD            ;
  3504                                  ; MSDOS 3.3
  3505                                  ;	I_am	DIRSEC,WORD
  3506                                  ;; MSDOS 6.0
  3507                                  ;;      I_am    DIRSEC,DWORD            ;>32mb		; AC0000
  3508                                  ;       I_am    DIRSTART,WORD           ;
  3509                                  ;       I_am    SECPOS,DWORD		;>32mb Position of first sector accessed
  3510                                  ;       I_am    VALSEC,DWORD		;>32mb Number of valid (previously written)
  3511                                  ;                                       ; sectors
  3512                                  ;       I_am    BYTSECPOS,WORD          ; Position of first byte within sector
  3513                                  ;       I_am    BYTPOS,4                ; Byte position in file of access
  3514                                  ;       I_am    BYTCNT1,WORD            ; No. of bytes in first sector
  3515                                  ;       I_am    BYTCNT2,WORD            ; No. of bytes in last sector
  3516                                  ;       I_am    SECCNT,WORD             ; No. of whole sectors
  3517                                  
  3518 00000566 FFFF                    SFN:		dw -1
  3519 00000568 0000                    JFN:		dw 0
  3520 0000056A 00000000                PJFN:		dd 0
  3521 0000056E 0000                    WFP_START: 	dw 0
  3522 00000570 0000                    REN_WFP: 	dw 0
  3523 00000572 0000                    CURR_DIR_END: 	dw 0
  3524 00000574 0000                    NEXTADD: 	dw 0
  3525 00000576 0000                    LASTPOS: 	dw 0
  3526 00000578 0000                    CLUSNUM: 	dw 0
  3527                                  ; MSDOS 3.3
  3528                                  ;DIRSEC: 	dw 0
  3529                                  ; MSDOS 6.0
  3530 0000057A 00000000                DIRSEC:		dd 0 ; 24/07/2019	;>32mb
  3531 0000057E 0000                    DIRSTART: 	dw 0
  3532                                  ; MSDOS 3.3
  3533                                  ;SECPOS: 	dw 0
  3534                                  ; MSDOS 6.0
  3535 00000580 00000000                SECPOS: 	dd 0 ; 24/07/2019	;>32mb Position of first sector accessed
  3536                                  ; MSDOS 3.3
  3537                                  ;VALSEC: 	dw 0
  3538                                  ; MSDOS 6.0
  3539 00000584 00000000                VALSEC: 	dd 0 ; 24/07/2019  ;>32mb Num of valid (previously written) sectors	
  3540 00000588 0000                    BYTSECPOS: 	dw 0
  3541 0000058A 00000000                BYTPOS:		dd 0
  3542 0000058E 0000                    BYTCNT1: 	dw 0
  3543 00000590 0000                    BYTCNT2: 	dw 0
  3544 00000592 0000                    SECCNT: 	dw 0
  3545                                  
  3546                                  	; Offset 056Ah in IBMDOS.COM (MSDOS 3.3)
  3547                                  ; DATASEGMENT + 530 (in Retro DOS v3.0)
  3548                                  
  3549                                  ;       I_am    ENTFREE,WORD            ;
  3550                                  ;       I_am    ENTLAST,WORD            ;
  3551                                  ;       I_am    NXTCLUSNUM,WORD         ;
  3552                                  ;       I_am    GROWCNT,DWORD           ;
  3553                                  ;       I_am    CURBUF,DWORD            ;
  3554                                  ;       I_am    CONSft,DWORD            ; SFT of console swapped guy.
  3555                                  ;       I_am    SAVEBX,WORD             ;
  3556                                  ;       I_am    SAVEDS,WORD             ;
  3557                                  ;       I_am    restore_tmp,WORD        ; return address for restore world
  3558                                  ;       I_am    NSS,WORD
  3559                                  ;       I_am    NSP,WORD
  3560                                  
  3561 00000594 0000                    ENTFREE:	dw 0
  3562 00000596 0000                    ENTLAST:	dw 0
  3563 00000598 0000                    NXTCLUSNUM:	dw 0
  3564 0000059A 00000000                GROWCNT:	dd 0
  3565 0000059E 00000000                CURBUF:		dd 0
  3566 000005A2 00000000                CONSFT:		dd 0
  3567 000005A6 0000                    SAVEBX:		dw 0
  3568 000005A8 0000                    SAVEDS:		dw 0
  3569 000005AA 0000                    RESTORE_TMP:	dw 0
  3570 000005AC 0000                    NSS:		dw 0
  3571 000005AE 0000                    NSP:		dw 0	 ; Offset 0584h in IBMDOS.COM (MSDOS 3.3)
  3572                                  
  3573                                  ; DATASEGMENT+558 :  ; *!!!*
  3574                                  	; Here is offset 0586h in IBMDOS.COM, 1987 (MSDOS 3.3 kernel) 
  3575                                  
  3576                                  ; MSDOS 6.0
  3577                                  ;       I_am    EXTOPEN_FLAG,WORD,<0>   ;FT. extended open input flag       ;AN000;
  3578                                  ;       I_am    EXTOPEN_ON,BYTE,<0>     ;FT. extended open conditional flag ;AN000;
  3579                                  ;       I_am    EXTOPEN_IO_MODE,WORD,<0>;FT. extended open io mode          ;AN000;
  3580                                  ;       I_am    SAVE_DI,WORD            ;FT. extended open saved DI         ;AN000;
  3581                                  ;       I_am    SAVE_ES,WORD            ;FT. extended open saved ES         ;AN000;
  3582                                  ;       I_am    SAVE_DX,WORD            ;FT. extended open saved DX         ;AN000;
  3583                                  ;       I_am    SAVE_CX,WORD            ;FT. extended open saved CX         ;AN000;
  3584                                  ;       I_am    SAVE_BX,WORD            ;FT. extended open saved BX         ;AN000;
  3585                                  ;       I_am    SAVE_SI,WORD            ;FT. extended open saved SI         ;AN000;
  3586                                  ;       I_am    SAVE_DS,WORD            ;FT. extended open saved DS         ;AN000;
  3587                                  
  3588                                  ;	HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
  3589                                  ;	we used to just pass 16 bits in a register.  Now High_SECTOR holds
  3590                                  ;	the high 16, the low 16 are still in the register.
  3591                                  ;
  3592                                  ;       I_am    HIGH_SECTOR,WORD,<0>    ;>32mb higher sector #		    ;AN000;
  3593                                  ;
  3594                                  ;       ;I_am    UU_HIGH_SECTOR_TEMP,WORD,<0> ;M019: Unused
  3595                                  ;       I_am    OffsetMagicPatch,WORD,<offset MagicPatch> ;scottq 8/6/92
  3596                                  ;                                                         ;see dos\mpatch.asm
  3597                                  ;
  3598                                  ;       I_am    DISK_FULL,BYTE          ;>32mb indicating disk full when 1  ;AN000;
  3599                                  ;       I_am    TEMP_VAR,WORD           ; temporary variable for everyone   ;AN000;
  3600                                  ;       I_am    TEMP_VAR2,WORD          ; temporary variable 2 for everyone ;AN000;
  3601                                  ;       I_am    DrvErr,BYTE             ; used to save drive error          ;AN000;
  3602                                  ;       I_am    DOS34_FLAG,WORD,<0>     ; common flag for DOS 3.4           ;AN000;
  3603                                  ;       I_am    NO_FILTER_PATH,DWORD    ; pointer to orignal path           ;AN000;
  3604                                  ;       I_am    NO_FILTER_DPATH,DWORD   ; pointer to orignal path of destination;AN000;
  3605                                  ;; M008
  3606                                  ;       I_am   AbsRdWr_SS,WORD         ; INT 25/26 user stack segment
  3607                                  ;       I_am   AbsRdWr_SP,WORD         ; INT 25/26 user stack offset
  3608                                  ;       I_am   UU_Callback_flag,BYTE,<0>  ; Unused
  3609                                  ;; M008
  3610                                  
  3611                                  ; 23/07/2019 - Retro DOS v3.2
  3612                                  
  3613                                  ; HIGH_SECTOR is a hack to allow passing 32-bit sector numbers where
  3614                                  ; we used to just pass 16 bits in a register. Now High_SECTOR holds
  3615                                  ; the high 16, the low 16 are still in the register.
  3616                                  
  3617                                  HIGH_SECTOR:	
  3618 000005B0 0000                    	dw	0		;>32mb higher sector #		;AN000;
  3619                                  ; 24/07/2019
  3620                                  ;DISK_FULL:
  3621                                  ;	db	0		;>32mb indicating disk full when 1 ;AN000;
  3622                                  ;	db	0 ; reserved
  3623                                  TEMP_VAR:
  3624 000005B2 0000                    	dw	0		; temporary variable for everyone ;AN000;
  3625                                  TEMP_VAR2:
  3626 000005B4 0000                    	dw	0		; temporary variable 2 for everyone ;AN000;
  3627                                   
  3628                                  ; make those pushes fast!!!
  3629                                  	;.EVEN
  3630                                  align 2
  3631                                  
  3632                                  ; MSDOS 3.3 (& MSDOS 6.0)
  3633                                  StackSize equ 180h			; gross but effective
  3634                                  
  3635                                  ;;;StackSize = 300h			; This is a "trial" change IBM hasn't
  3636                                  ;;;					; made up their minds about
  3637                                   
  3638                                  ;
  3639                                  ; WARNING!!!! DskStack may grow into AUXSTACK due to interrupt service.
  3640                                  ; This is NO problem as long as AUXSTACK comes immediately before DSKSTACK
  3641                                  ;
  3642                                          ;PUBLIC  RENAMEDMA,AuxStack,DskStack,IOStack
  3643                                  RENAMEDMA:  ; LABEL   BYTE		; See DOS_RENAME
  3644                                  	;DB	StackSize DUP (?)       ;
  3645 000005B6 00<rep 180h>            	times	StackSize db 0
  3646                                  AUXSTACK:   ; LABEL   BYTE		;  Offset 0706h in IBMDOS.COM, 1987
  3647                                   	;DB	StackSize DUP (?)       ;
  3648 00000736 00<rep 180h>            	times	StackSize db 0
  3649                                  DSKSTACK:   ; LABEL   BYTE		;  Offset 0886h in IBMDOS.COM, 1987
  3650                                   	;DB	StackSize DUP (?)       ;
  3651 000008B6 00<rep 180h>            	times	StackSize db 0
  3652                                  IOSTACK:    ; LABEL   BYTE		;  Offset 0A06h in IBMDOS.COM, 1987
  3653                                   
  3654                                  ; patch space for Boca folks.
  3655                                  ; Say What????!!! This does NOT go into the swappable area!
  3656                                  ; NOTE: We include the decl of ibmpatch in ms-dos even though it is not needed.
  3657                                  ;       This allows the REDIRector to work on either IBM or MS-DOS.
  3658                                   
  3659                                  ;PUBLIC  IBMPATCH
  3660                                  ;IBMPATCH label byte
  3661                                  ;	I_am    PRINTER_FLAG,BYTE,<0>   ; status of PRINT utility
  3662                                  ;	I_am    VOLCHNG_FLAG,BYTE,<0>   ; true if volume label created
  3663                                  ;	I_am    VIRTUAL_OPEN,BYTE,<0>   ; non-zero if we opened a virtual file
  3664                                  
  3665                                  IBMPATCH:
  3666 00000A36 00                      PRINTER_FLAG:	db 0
  3667 00000A37 00                      VOLCHNG_FLAG:	db 0
  3668 00000A38 00                      VIRTUAL_OPEN:	db 0
  3669                                  
  3670                                  ; MSDOS 6.0
  3671                                  ;; Following 4 variables moved to MSDATA.asm from MSTABLE.asm (P4986)
  3672                                  ;      I_am     FSeek_drive,BYTE         ;AN000; fastseek drive #
  3673                                  ;      I_am     FSeek_firclus,WORD       ;AN000; fastseek first cluster #
  3674                                  ;      I_am     FSeek_logclus,WORD       ;AN000; fastseek logical cluster #
  3675                                  ;      I_am     FSeek_logsave,WORD       ;AN000; fastseek returned log clus #
  3676                                  ;      I_am     UU_ACT_PAGE,WORD,<-1>    ;;;;;;; ;BL ; active EMS page ;AN000;
  3677                                  ;      I_am     TEMP_DOSLOC,WORD,<-1>    ;stores the temporary location of dos
  3678                                  					;at SYSINIT time.
  3679                                  ;SWAP_END LABEL   BYTE
  3680                                  ;PUBLIC  SWAP_END
  3681                                  
  3682                                  SWAP_END:
  3683                                   
  3684                                  ;; THE FOLLOWING BYTE MUST BE HERE, IMMEDIATELY FOLLOWING SWAP_END. IT CANNOT
  3685                                  ;;   BE USED. If the size of the swap data area is ODD, it will be rounded up
  3686                                  ;;   to include this byte.
  3687                                  ;       DB      ?
  3688                                  
  3689 00000A39 00                      	db	0
  3690                                   
  3691                                  ;;hkn;	DB      (512+80+32-(SWAP_END-ibmpatch)) DUP (?)
  3692                                  
  3693                                  ;DOSDATA    ENDS
  3694                                  
  3695                                  ; 08/09/2018
  3696 00000A3A 00<rep 243h>            	times 579 db 0
  3697                                  
  3698                                  ;12/08/2018 - Retro DOS v3.0
  3699                                  ;15/07/2018
  3700                                  ;============================================================================
  3701                                  ; 	Retro DOS v3.0
  3702                                  ;============================================================================
  3703 00000C7D 00                      	db 	0
  3704                                  RETRODOSMSG:
  3705 00000C7E 0D0A                    	db	13,10
  3706                                  	;;;db	"Retro DOS v3.0 by Erdogan Tan [2018]"
  3707                                  	;;db	"Retro DOS v3.1 by Erdogan Tan [2019]" ; 29/06/2019
  3708                                  	;db	"Retro DOS v3.2 by Erdogan Tan [2019]" ; 17/07/2019
  3709 00000C80 526574726F20444F53-     	db	"Retro DOS v3.2 by Erdogan Tan [2019-2022]" ; 22/11/2022
  3709 00000C89 2076332E3220627920-
  3709 00000C92 4572646F67616E2054-
  3709 00000C9B 616E205B323031392D-
  3709 00000CA4 323032325D         
  3710 00000CA9 0D0A2400                	db	13,10,"$", 0 
  3711                                  
  3712                                  ;============================================================================
  3713                                  ; MSTABLE.ASM (MSDOS 6.0, 1991)
  3714                                  ;============================================================================
  3715                                  ; 16/07/2018 - Retro DOS 3.0
  3716                                  
  3717                                  	; Offset 0C78h in IBMDOS.COM (MSDOS 3.3, 1987)
  3718                                  MSVERS:				; MS-DOS version in hex for $GET_VERSION
  3719 00000CAD 03                      MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  3720 00000CAE 1E                      MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  3721                                  
  3722                                  ;;hkn YRTAB & MONTAB moved to DOSDATA in ms_data.asm
  3723                                  ;        I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   ; [SYSTEM]
  3724                                  ;        I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> ; [SYSTEM]
  3725                                  
  3726                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3727                                  ; YRTAB & MONTAB moved from TABLE segment in ms_table.asm
  3728                                  ;
  3729                                  ;	I_am    YRTAB,8,<200,166,200,165,200,165,200,165>   
  3730                                  ;	I_am    MONTAB,12,<31,28,31,30,31,30,31,31,30,31,30,31> 
  3731                                  
  3732                                  ; Days in year
  3733                                  
  3734                                  YRTAB:   
  3735 00000CAF C8A6                    	DB	200,166			; Leap year
  3736 00000CB1 C8A5                    	DB	200,165
  3737 00000CB3 C8A5                    	DB	200,165
  3738 00000CB5 C8A5                    	DB	200,165
  3739                                  
  3740                                  ; Days of each month
  3741                                  
  3742                                  MONTAB:        
  3743 00000CB7 1F                      	DB      31                      ; January
  3744                                  february:
  3745 00000CB8 1C                      	DB	28 			; February--reset each 
  3746                                  					; time year changes
  3747 00000CB9 1F                              DB      31                      ; March
  3748 00000CBA 1E                              DB      30                      ; April
  3749 00000CBB 1F                              DB      31                      ; May
  3750 00000CBC 1E                              DB      30                      ; June
  3751 00000CBD 1F                              DB      31                      ; July
  3752 00000CBE 1F                              DB      31                      ; August
  3753 00000CBF 1E                              DB      30                      ; September
  3754 00000CC0 1F                              DB      31                      ; October
  3755 00000CC1 1E                              DB      30                      ; November
  3756 00000CC2 1F                              DB      31                      ; December
  3757                                  
  3758                                  ;
  3759                                  ; This is the error code mapping table for INT 21 errors. This table defines
  3760                                  ; those error codes which are "allowed" for each system call. If the error
  3761                                  ; code ABOUT to be returned is not "allowed" for the call, the correct action
  3762                                  ; is to return the "real" error via Extended error, and one of the allowed
  3763                                  ; errors on the actual call.
  3764                                  ;
  3765                                  ; The table is organized as follows:
  3766                                  ;
  3767                                  ;    Each entry in the table is of variable size, but the first
  3768                                  ;       two bytes are always:
  3769                                  ;
  3770                                  ;       Call#,Cnt of bytes following this byte
  3771                                  ;
  3772                                  ; EXAMPLE:
  3773                                  ;       Call 61 (OPEN)
  3774                                  ;
  3775                                  ;       DB      61,5,12,3,2,4,5
  3776                                  ;
  3777                                  ;       61 is the AH INT 21 call value for OPEN.
  3778                                  ;        5 indicates that there are 5 bytes after this byte (12,3,2,4,5).
  3779                                  ;       Next five bytes are those error codes which are "allowed" on OPEN.
  3780                                  ;       The order of these values is not important EXCEPT FOR THE LAST ONE (in
  3781                                  ;       this case 5). The last value will be the one returned on the call if
  3782                                  ;       the "real" error is not one of the allowed ones.
  3783                                  ;
  3784                                  ; There are a number of calls (for instance all of the FCB calls) for which
  3785                                  ;   there is NO entry. This means that NO error codes are returned on this
  3786                                  ;   call, so set up an Extended error and leave the current error code alone.
  3787                                  ;
  3788                                  ; The table is terminated by a call value of 0FFh
  3789                                  
  3790                                  ;PUBLIC I21_MAP_E_TAB
  3791                                  	; 10/08/2018
  3792                                  I21_MAP_E_TAB:	; LABEL	BYTE
  3793 00000CC3 38020102                    DB  INTERNATIONAL,2,error_invalid_function,error_file_not_found
  3794 00000CC7 3903030205                  DB  MKDIR,3,error_path_not_found,error_file_not_found,error_access_denied
  3795 00000CCC 3A041003                    DB  RMDIR,4,error_current_directory,error_path_not_found
  3796 00000CD0 0205                        DB          error_file_not_found,error_access_denied
  3797 00000CD2 3B020203                    DB  CHDIR,2,error_file_not_found,error_path_not_found
  3798 00000CD6 3C040302                    DB  CREAT,4,error_path_not_found,error_file_not_found
  3799 00000CDA 04                          DB          error_too_many_open_files
  3800 00000CDB 05                          DB          error_access_denied
  3801                                      ; MSDOS 6.0
  3802                                      ;DB  OPEN,6,error_path_not_found,error_file_not_found,error_invalid_access
  3803                                      ;DB          error_too_many_open_files
  3804                                      ;DB          error_not_dos_disk,error_access_denied
  3805                                      ; MSDOS 3.3
  3806 00000CDC 3D0503020C                  DB  OPEN,5,error_path_not_found,error_file_not_found,error_invalid_access
  3807 00000CE1 0405                        DB          error_too_many_open_files,error_access_denied
  3808 00000CE3 3E0106                      DB  CLOSE,1,error_invalid_handle
  3809 00000CE6 3F020605                    DB  READ,2,error_invalid_handle,error_access_denied
  3810 00000CEA 40020605                    DB  WRITE,2,error_invalid_handle,error_access_denied
  3811 00000CEE 4103030205                  DB  UNLINK,3,error_path_not_found,error_file_not_found,error_access_denied
  3812 00000CF3 42020601                    DB  LSEEK,2,error_invalid_handle,error_invalid_function
  3813 00000CF7 4304030201                  DB  CHMOD,4,error_path_not_found,error_file_not_found,error_invalid_function
  3814 00000CFC 05                          DB          error_access_denied
  3815 00000CFD 44050F0D01                  DB  IOCTL,5,error_invalid_drive,error_invalid_data,error_invalid_function
  3816 00000D02 0605                        DB          error_invalid_handle,error_access_denied
  3817 00000D04 45020604                    DB  XDUP,2,error_invalid_handle,error_too_many_open_files
  3818 00000D08 46020604                    DB  XDUP2,2,error_invalid_handle,error_too_many_open_files
  3819                                      ; MSDOS 6.0	
  3820                                      ;DB  CURRENT_DIR,2,error_not_DOS_disk,error_invalid_drive
  3821                                      ; MSDOS 3.3	
  3822 00000D0C 47010F                      DB  CURRENT_DIR,1,error_invalid_drive
  3823 00000D0F 48020708                    DB  ALLOC,2,error_arena_trashed,error_not_enough_memory
  3824 00000D13 49020709                    DB  DEALLOC,2,error_arena_trashed,error_invalid_block
  3825 00000D17 4A03070908                  DB  SETBLOCK,3,error_arena_trashed,error_invalid_block,error_not_enough_memory
  3826 00000D1C 4B08030102                  DB  EXEC,8,error_path_not_found,error_invalid_function,error_file_not_found
  3827 00000D21 040B0A                      DB          error_too_many_open_files,error_bad_format,error_bad_environment
  3828 00000D24 0805                        DB          error_not_enough_memory,error_access_denied
  3829 00000D26 4E03030212                  DB  FIND_FIRST,3,error_path_not_found,error_file_not_found,error_no_more_files
  3830 00000D2B 4F0112                      DB  FIND_NEXT,1,error_no_more_files
  3831                                      ; MSDOS 6.0
  3832                                      ;DB  RENAME,5,error_not_same_device,error_path_not_found,error_file_not_found
  3833                                      ;DB          error_current_directory,error_access_denied
  3834                                      ; MSDOS 3.3
  3835 00000D2E 5604110302                  DB  RENAME,4,error_not_same_device,error_path_not_found,error_file_not_found
  3836 00000D33 05                          DB          error_access_denied
  3837                                      ; MSDOS 6.0	
  3838                                      ;DB  FILE_TIMES,4,error_invalid_handle,error_not_enough_memory
  3839                                      ;DB             error_invalid_data,error_invalid_function
  3840                                      ; MSDOS 3.03	
  3841 00000D34 57020601                    DB  FILE_TIMES,2,error_invalid_handle,error_invalid_function
  3842 00000D38 580101                      DB  ALLOCOPER,1,error_invalid_function
  3843 00000D3B 5A040302                    DB  CREATETEMPFILE,4,error_path_not_found,error_file_not_found
  3844 00000D3F 0405                        DB          error_too_many_open_files,error_access_denied
  3845 00000D41 5B055003                    DB  CREATENEWFILE,5,error_file_exists,error_path_not_found
  3846 00000D45 020405                      DB          error_file_not_found,error_too_many_open_files,error_access_denied
  3847 00000D48 5C040601                    DB  LOCKOPER,4,error_invalid_handle,error_invalid_function
  3848 00000D4C 2421                        DB          error_sharing_buffer_exceeded,error_lock_violation
  3849 00000D4E 65020102                    DB  GETEXTCNTRY,2,error_invalid_function,error_file_not_found	;DOS 3.3
  3850 00000D52 66020102                    DB  GETSETCDPG,2,error_invalid_function,error_file_not_found        ;DOS 3.3
  3851 00000D56 680106                      DB  COMMIT,1,error_invalid_handle                                   ;DOS 3.3
  3852 00000D59 67030408                    DB  EXTHANDLE,3,error_too_many_open_files,error_not_enough_memory
  3853 00000D5D 01                          DB              error_invalid_function
  3854                                      ; MSDOS 6.0		
  3855                                      ;DB	ExtOpen,10
  3856                                      ;DB   error_path_not_found,error_file_not_found,error_invalid_access
  3857                                      ;DB         error_too_many_open_files,error_file_exists,error_not_enough_memory
  3858                                      ;DB         error_not_dos_disk,error_invalid_data
  3859                                      ;DB             error_invalid_function,error_access_denied
  3860                                      ;DB GetSetMediaID,4,error_invalid_drive,error_invalid_data
  3861                                      ;DB         error_invalid_function,error_access_denied
  3862 00000D5E FF                          DB  0FFh
  3863                                  
  3864                                  ;============================================================================
  3865                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  3866                                  ;============================================================================
  3867                                  ; 16/07/2018 - Retro DOS 3.0
  3868                                  
  3869                                  ;**
  3870                                  ;
  3871                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 21H
  3872                                  ; errors.  Each entry is 4 bytes long:
  3873                                  ;
  3874                                  ;       Err#,Class,Action,Locus
  3875                                  ;
  3876                                  ; A value of 0FFh indicates a call specific value (ie.  should already
  3877                                  ; be set).  AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
  3878                                  ; THE END, IT IS ASSUMES THAT CLASS, ACTION, LOCUS IS ALREADY SET.
  3879                                  ;
  3880                                  
  3881                                  ;PUBLIC  ERR_TABLE_21
  3882                                  ERR_TABLE_21: ; LABEL   BYTE
  3883 00000D5F 010704FF                    DB  error_invalid_function,       errCLASS_Apperr,    errACT_Abort,     0FFh
  3884 00000D63 02080302                    DB  error_file_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3885 00000D67 03080302                    DB  error_path_not_found,         errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3886 00000D6B 04010401                    DB  error_too_many_open_files,    errCLASS_OutRes,    errACT_Abort,     errLOC_Unk
  3887 00000D6F 050303FF                    DB  error_access_denied,          errCLASS_Auth,      errACT_User,      0FFh
  3888 00000D73 06070401                    DB  error_invalid_handle,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3889 00000D77 07070505                    DB  error_arena_trashed,          errCLASS_Apperr,    errACT_Panic,     errLOC_Mem
  3890 00000D7B 08010405                    DB  error_not_enough_memory,      errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3891 00000D7F 09070405                    DB  error_invalid_block,          errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
  3892 00000D83 0A070405                    DB  error_bad_environment,        errCLASS_Apperr,    errACT_Abort,     errLOC_Mem
  3893 00000D87 0B090301                    DB  error_bad_format,             errCLASS_BadFmt,    errACT_User,      errLOC_Unk
  3894 00000D8B 0C070401                    DB  error_invalid_access,         errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3895 00000D8F 0D090401                    DB  error_invalid_data,           errCLASS_BadFmt,    errACT_Abort,     errLOC_Unk
  3896 00000D93 0F080302                    DB  error_invalid_drive,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3897 00000D97 10030302                    DB  error_current_directory,      errCLASS_Auth,      errACT_User,      errLOC_Disk
  3898 00000D9B 110D0302                    DB  error_not_same_device,        errCLASS_Unk,       errACT_User,      errLOC_Disk
  3899 00000D9F 12080302                    DB  error_no_more_files,          errCLASS_NotFnd,    errACT_User,      errLOC_Disk
  3900 00000DA3 500C0302                    DB  error_file_exists,            errCLASS_Already,   errACT_User,      errLOC_Disk
  3901 00000DA7 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3902 00000DAB 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3903 00000DAF 540104FF                    DB  error_out_of_structures,      errCLASS_OutRes,    errACT_Abort,     0FFh
  3904 00000DB3 56030301                    DB  error_invalid_password,       errCLASS_Auth,      errACT_User,      errLOC_Unk
  3905 00000DB7 52010402                    DB  error_cannot_make,            errCLASS_OutRes,    errACT_Abort,     errLOC_Disk
  3906 00000DBB 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
  3907 00000DBF 550C0303                    DB  error_already_assigned,       errCLASS_Already,   errACT_User,      errLOC_Net
  3908 00000DC3 57090301                    DB  error_invalid_parameter,      errCLASS_BadFmt,    errACT_User,      errLOC_Unk
  3909 00000DC7 530D0401                    DB  error_FAIL_I24,               errCLASS_Unk,       errACT_Abort,     errLOC_Unk
  3910 00000DCB 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3911                                      ; MSDOS 6.0
  3912                                      ;DB  error_handle_EOF,            errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
  3913                                      ;DB  error_handle_Disk_Full,      errCLASS_OutRes,    errACT_Abort,     errLOC_Unk ;AN000;
  3914                                      ;DB  error_sys_comp_not_loaded,   errCLASS_Unk,       errACT_Abort,     errLOC_Disk ;AN001;
  3915 00000DCF FFFFFFFF                    DB  0FFh,                         0FFH,       	  0FFH,       	    0FFh
  3916                                  
  3917                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D2Ah
  3918                                  ;ERR_TABLE_21:	db 1,7,4,0FFh
  3919                                  ;		db 2,8,3,2
  3920                                  ;		db 3,8,3,2
  3921                                  ;		db 4,1,4,1
  3922                                  ;		db 5,3,3,0FFh
  3923                                  ;		db 6,7,4,1
  3924                                  ;		db 7,7,5,5
  3925                                  ;		db 8,1,4,5
  3926                                  ;		db 9,7,4,5
  3927                                  ;		db 0Ah,7,4,5
  3928                                  ;		db 0Bh,9,3,1
  3929                                  ;		db 0Ch,7,4,1
  3930                                  ;		db 0Dh,9,4,1
  3931                                  ;		db 0Fh,8,3,2
  3932                                  ;		db 10h,3,3,2
  3933                                  ;		db 11h,0Dh,3,2
  3934                                  ;		db 12h,8,3,2
  3935                                  ;		db 50h,0Ch,3,2
  3936                                  ;		db 20h,0Ah,2,2
  3937                                  ;		db 21h,0Ah,2,2
  3938                                  ;		db 54h,1,4,0FFh
  3939                                  ;		db 56h,3,3,1
  3940                                  ;		db 52h,1,4,2
  3941                                  ;		db 32h,9,3,3
  3942                                  ;		db 55h,0Ch,3,3
  3943                                  ;		db 57h,9,3,1
  3944                                  ;		db 53h,0Dh,4,1
  3945                                  ;		db 24h,1,4,5
  3946                                  ;		db 0FFh,0FFh,0FFh,0FFh
  3947                                  
  3948                                  ;
  3949                                  ; The following table defines CLASS ACTION and LOCUS info for the INT 24H
  3950                                  ; errors.  Each entry is 4 bytes long:
  3951                                  ;
  3952                                  ;       Err#,Class,Action,Locus
  3953                                  ;
  3954                                  ; A Locus value of 0FFh indicates a call specific value (ie. should already
  3955                                  ; be set). AN ERROR CODE NOT IN THE TABLE FALLS THROUGH TO THE CATCH ALL AT
  3956                                  ; THE END.
  3957                                  
  3958                                  ;PUBLIC  ERR_TABLE_24
  3959                                  ERR_TABLE_24: ; LABEL   BYTE
  3960 00000DD3 130B0702                    DB  error_write_protect,          errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3961 00000DD7 14040501                    DB  error_bad_unit,               errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3962 00000DDB 150507FF                    DB  error_not_ready,              errCLASS_HrdFail,   errACT_IntRet,    0FFh
  3963 00000DDF 16040501                    DB  error_bad_command,            errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3964 00000DE3 170B0402                    DB  error_CRC,                    errCLASS_Media,     errACT_Abort,     errLOC_Disk
  3965 00000DE7 18040501                    DB  error_bad_length,             errCLASS_Intrn,     errACT_Panic,     errLOC_Unk
  3966 00000DEB 19050102                    DB  error_seek,                   errCLASS_HrdFail,   errACT_Retry,     errLOC_Disk
  3967 00000DEF 1A0B0702                    DB  error_not_DOS_disk,           errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3968 00000DF3 1B0B0402                    DB  error_sector_not_found,       errCLASS_Media,     errACT_Abort,     errLOC_Disk
  3969 00000DF7 1C020704                    DB  error_out_of_paper,           errCLASS_TempSit,   errACT_IntRet,    errLOC_SerDev
  3970 00000DFB 1D0504FF                    DB  error_write_fault,            errCLASS_HrdFail,   errACT_Abort,     0FFh
  3971 00000DFF 1E0504FF                    DB  error_read_fault,             errCLASS_HrdFail,   errACT_Abort,     0FFh
  3972 00000E03 1F0D04FF                    DB  error_gen_failure,            errCLASS_Unk,       errACT_Abort,     0FFh
  3973 00000E07 200A0202                    DB  error_sharing_violation,      errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3974 00000E0B 210A0202                    DB  error_lock_violation,         errCLASS_Locked,    errACT_DlyRet,    errLOC_Disk
  3975 00000E0F 220B0702                    DB  error_wrong_disk,             errCLASS_Media,     errACT_IntRet,    errLOC_Disk
  3976 00000E13 32090303                    DB  error_not_supported,          errCLASS_BadFmt,    errACT_User,      errLOC_Net
  3977 00000E17 23070401                    DB  error_FCB_unavailable,        errCLASS_Apperr,    errACT_Abort,     errLOC_Unk
  3978 00000E1B 24010405                    DB  error_sharing_buffer_exceeded,errCLASS_OutRes,    errACT_Abort,     errLOC_Mem
  3979 00000E1F FF0D05FF                    DB	0FFh,                         errCLASS_Unk,       errACT_Panic,     0FFh
  3980                                  
  3981                                  
  3982                                  ; MSDOS 3.3 (IBMDOS.COM, 1987) - Offset 0D9Eh
  3983                                  ;ERR_TABLE_24:	db 13h,0Bh,7,2
  3984                                  ;		db 14h,4,5,1
  3985                                  ;		db 15h,5,7,0FFh
  3986                                  ;		db 16h,4,5,1
  3987                                  ;		db 17h,0Bh,4,2
  3988                                  ;		db 18h,4,5,1
  3989                                  ;		db 19h,5,1,2
  3990                                  ;		db 1Ah,0Bh,7,2
  3991                                  ;		db 1Bh,0Bh,4,2
  3992                                  ;		db 1Ch,2,7,4
  3993                                  ;		db 1Dh,5,4,0FFh
  3994                                  ;		db 1Eh,5,4,0FFh
  3995                                  ;		db 1Fh,0Dh,4,0FFh
  3996                                  ;		db 20h,0Ah,2,2
  3997                                  ;		db 21h,0Ah,2,2
  3998                                  ;		db 22h,0Bh,7,2
  3999                                  ;		db 32h,9,3,3
  4000                                  ;		db 23h,7,4,1
  4001                                  ;		db 24h,1,4,5
  4002                                  ;		db 0FFh,0Dh,5,0FFh
  4003                                  
  4004                                  ;
  4005                                  ; We need to map old int 24 errors and device driver errors into the new set
  4006                                  ; of errors. The following table is indexed by the new errors
  4007                                  ;
  4008                                  
  4009                                  ;Public  ErrMap24
  4010                                  ErrMap24: ; Label   BYTE
  4011 00000E23 13                          DB  error_write_protect	; 0
  4012 00000E24 14                          DB  error_bad_unit		; 1
  4013 00000E25 15                          DB  error_not_ready		; 2
  4014 00000E26 16                          DB  error_bad_command	; 3
  4015 00000E27 17                          DB  error_CRC		; 4
  4016 00000E28 18                          DB  error_bad_length	; 5
  4017 00000E29 19                          DB  error_seek		; 6
  4018 00000E2A 1A                          DB  error_not_DOS_disk	; 7
  4019 00000E2B 1B                          DB  error_sector_not_found	; 8
  4020 00000E2C 1C                          DB  error_out_of_paper	; 9
  4021 00000E2D 1D                          DB  error_write_fault	; A
  4022 00000E2E 1E                          DB  error_read_fault	; B
  4023 00000E2F 1F                          DB  error_gen_failure	; C
  4024 00000E30 1F                          DB  error_gen_failure	; D  RESERVED
  4025 00000E31 1F                          DB  error_gen_failure	; E  RESERVED
  4026 00000E32 22                          DB  error_wrong_disk	; F
  4027                                  
  4028                                  ;Public  ErrMap24End
  4029                                  ErrMap24End: ; LABEL   BYTE
  4030                                  
  4031                                  ; 16/07/2018 - Retro DOS v3.0
  4032                                  ;_MAXCALL:	db 	36
  4033                                  ;_MAXCOM:	db	104
  4034                                  
  4035                                  ; 08/09/2018
  4036 00000E33 24                          db  36
  4037 00000E34 68                          db  104
  4038                                  
  4039                                  ;============================================================================
  4040                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  4041                                  ;============================================================================
  4042                                  ; 11/07/2018 - Retro DOS v3.0
  4043                                  
  4044                                  	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
  4045                                  
  4046 00000E35 90                      align 2
  4047                                  
  4048                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0E00h
  4049                                  
  4050                                  ; Standard Functions
  4051                                  ;DISPATCH    LABEL WORD
  4052                                  DISPATCH:
  4053                                  	; 16/07/2018 - Retro DOS v3.0
  4054                                  	; (MSDOS 3.3)
  4055                                  
  4056 00000E36 [1068]                          short_addr  _$ABORT			    ;  0      0
  4057 00000E38 [0824]                          short_addr  _$STD_CON_INPUT		    ;  1      1
  4058 00000E3A [1124]                          short_addr  _$STD_CON_OUTPUT		    ;  2      2
  4059 00000E3C [CA24]                          short_addr  _$STD_AUX_INPUT		    ;  3      3
  4060 00000E3E [E724]                          short_addr  _$STD_AUX_OUTPUT		    ;  4      4
  4061 00000E40 [ED24]                          short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
  4062 00000E42 [5A23]                          short_addr  _$RAW_CON_IO		    ;  6      6
  4063 00000E44 [8623]                          short_addr  _$RAW_CON_INPUT		    ;  7      7
  4064 00000E46 [2D21]                          short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
  4065 00000E48 [8721]                          short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
  4066 00000E4A [9321]                          short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
  4067 00000E4C [0125]                          short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
  4068 00000E4E [0B25]                          short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
  4069 00000E50 [EE1D]                          short_addr  _$DISK_RESET		    ; 13      D
  4070 00000E52 [EA1C]                          short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
  4071 00000E54 [EA2B]                          short_addr  _$FCB_OPEN			    ; 15      F
  4072 00000E56 [B425]                          short_addr  _$FCB_CLOSE			    ; 16     10
  4073 00000E58 [FE2C]                          short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
  4074 00000E5A [932D]                          short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
  4075 00000E5C [5025]                          short_addr  _$FCB_DELETE		    ; 19     13
  4076 00000E5E [EA2C]                          short_addr  _$FCB_SEQ_READ		    ; 20     14
  4077 00000E60 [EF2C]                          short_addr  _$FCB_SEQ_WRITE	            ; 21     15
  4078 00000E62 [D02C]                          short_addr  _$FCB_CREATE		    ; 22     16
  4079 00000E64 [2526]                          short_addr  _$FCB_RENAME		    ; 23     17
  4080                                  	; 16/07/2018
  4081                                          ;short_addr _CPMFUNC			    ; 24     18	
  4082 00000E66 [B717]                          short_addr  NO_OP			    ; 24     18
  4083 00000E68 [E51C]                          short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
  4084 00000E6A [DA1C]                          short_addr  _$SET_DMA			    ; 26     1A
  4085                                  
  4086                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4087                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4088                                  ;                                                                          ;
  4089 00000E6C [771D]                          short_addr  _$SLEAZEFUNC		    ; 27     1B
  4090 00000E6E [791D]                          short_addr  _$SLEAZEFUNCDL		    ; 28     1C
  4091                                  ;                                                                          ;
  4092                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4093                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4094                                  
  4095                                          ;short_addr  _CPMFUNC			    ; 29     1D
  4096                                          ;short_addr  _CPMFUNC			    ; 30     1E
  4097                                  
  4098                                  ; 08/07/2018 - Retro DOS v3.0
  4099                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4100                                  
  4101 00000E70 [B717]                  	short_addr  NO_OP			    ; 29     1D
  4102 00000E72 [B717]                  	short_addr  NO_OP			    ; 30     1E
  4103                                  
  4104                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4105                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4106                                  ;                                                                          ;
  4107 00000E74 [BD1D]                          short_addr  _$GET_DEFAULT_DPB               ; 31     1F
  4108                                  ;                                                                          ;
  4109                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4110                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4111                                          ;short_addr _CPMFUNC			    ; 32     20
  4112                                  
  4113                                  ; 08/07/2018 - Retro DOS v3.0
  4114                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4115                                  
  4116 00000E76 [B717]                  	short_addr  NO_OP			    ; 32     20
  4117                                  
  4118 00000E78 [F42C]                          short_addr  _$FCB_RANDOM_READ               ; 33     21
  4119 00000E7A [F92C]                          short_addr  _$FCB_RANDOM_WRITE              ; 34     22
  4120 00000E7C [6525]                          short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
  4121 00000E7E [3825]                          short_addr  _$GET_FCB_POSITION		    ; 36     24
  4122                                  
  4123                                  ;MAXCALL = ($-DISPATCH)/2 - 1
  4124                                  MAXCALL EQU ($-DISPATCH)/2 - 1
  4125                                  
  4126                                  ; Extended Functions
  4127 00000E80 [0C1D]                          short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
  4128                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4129                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4130                                  ;                                                                          ;
  4131 00000E82 [FA1E]                          short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
  4132                                  ;                                                                          ;
  4133                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4134                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4135 00000E84 [E52C]                          short_addr  _$FCB_RANDOM_READ_BLOCK	    ; 39     27
  4136 00000E86 [E02C]                          short_addr  _$FCB_RANDOM_WRITE_BLOCK        ; 40     28
  4137 00000E88 [6C1D]                          short_addr  _$PARSE_FILE_DESCRIPTOR	    ; 41     29
  4138 00000E8A [BF18]                          short_addr  _$GET_DATE                      ; 42     2A
  4139 00000E8C [DC18]                          short_addr  _$SET_DATE                      ; 43     2B
  4140 00000E8E [FC18]                          short_addr  _$GET_TIME                      ; 44     2C
  4141 00000E90 [0D19]                          short_addr  _$SET_TIME                      ; 45     2D
  4142 00000E92 [BA1A]                          short_addr  _$SET_VERIFY_ON_WRITE           ; 46     2E
  4143                                  
  4144                                  ; Extended functionality group
  4145 00000E94 [C61C]                          short_addr  _$GET_DMA                       ; 47     2F
  4146 00000E96 [9C1A]                          short_addr  _$GET_VERSION                   ; 48     30
  4147 00000E98 [B467]                          short_addr  _$KEEP_PROCESS		    ; 49     31
  4148                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4149                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4150                                  ;                                                                          ;
  4151 00000E9A [BF1D]                          short_addr  _$GET_DPB			    ; 50     32
  4152                                  ;                                                                          ;
  4153                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4154                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4155 00000E9C [9D14]                          short_addr  _$SET_CTRL_C_TRAPPING           ; 51     33
  4156 00000E9E [A51D]                          short_addr  _$GET_INDOS_FLAG                ; 52     34
  4157 00000EA0 [FC1C]                          short_addr  _$GET_INTERRUPT_VECTOR          ; 53     35
  4158 00000EA2 [9B1C]                          short_addr  _$GET_DRIVE_FREESPACE           ; 54     36
  4159 00000EA4 [241D]                          short_addr  _$CHAR_OPER                     ; 55     37
  4160 00000EA6 [C11A]                          short_addr  _$INTERNATIONAL                 ; 56     38
  4161                                  ; XENIX CALLS
  4162                                  ;   Directory Group
  4163 00000EA8 [D22F]                          short_addr  _$MKDIR			    ; 57     39
  4164 00000EAA [242F]                          short_addr  _$RMDIR			    ; 58     3A
  4165 00000EAC [602F]                          short_addr  _$CHDIR			    ; 59     3B
  4166                                  ;   File Group
  4167 00000EAE [3674]                          short_addr  _$CREAT			    ; 60     3C
  4168 00000EB0 [7C73]                          short_addr  _$OPEN			    ; 61     3D
  4169 00000EB2 [0971]                          short_addr  _$CLOSE		 	    ; 62     3E
  4170 00000EB4 [2172]                          short_addr  _$READ			    ; 63     3F
  4171 00000EB6 [7672]                          short_addr  _$WRITE			    ; 64     40
  4172 00000EB8 [8B74]                          short_addr  _$UNLINK			    ; 65     41
  4173 00000EBA [7B72]                          short_addr  _$LSEEK			    ; 66     42
  4174 00000EBC [4374]                          short_addr  _$CHMOD			    ; 67     43
  4175 00000EBE [2F30]                          short_addr  _$IOCTL			    ; 68     44
  4176 00000EC0 [3773]                          short_addr  _$DUP			    ; 69     45
  4177 00000EC2 [5973]                          short_addr  _$DUP2			    ; 70     46
  4178 00000EC4 [C72E]                          short_addr  _$CURRENT_DIR		    ; 71     47
  4179                                  ;   Memory Group
  4180 00000EC6 [9568]                          short_addr  _$ALLOC			    ; 72     48
  4181 00000EC8 [B269]                          short_addr  _$DEALLOC                       ; 73     49
  4182 00000ECA [8E69]                          short_addr  _$SETBLOCK                      ; 74     4A
  4183                                  ;   Process Group
  4184 00000ECC [2963]                          short_addr  _$EXEC			    ; 75     4B
  4185 00000ECE [EC67]                          short_addr  _$EXIT			    ; 76     4C
  4186 00000ED0 [1F63]                          short_addr  _$WAIT			    ; 77     4D
  4187 00000ED2 [062E]                          short_addr  _$FIND_FIRST		    ; 78     4E
  4188                                  ;   Special Group
  4189 00000ED4 [5F2E]                          short_addr  _$FIND_NEXT			    ; 79     4F
  4190                                  ; SPECIAL SYSTEM GROUP
  4191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4192                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4193                                  ;                                                                          ;
  4194 00000ED6 [9114]                          short_addr  _$SET_CURRENT_PDB		    ; 80     50
  4195 00000ED8 [9714]                          short_addr  _$GET_CURRENT_PDB               ; 81     51
  4196 00000EDA [B11D]                          short_addr  _$GET_IN_VARS                   ; 82     52
  4197 00000EDC [1E1E]                          short_addr  _$SETDPB			    ; 83     53
  4198                                  ;                                                                          ;
  4199                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4201 00000EDE [B51A]                          short_addr  _$GET_VERIFY_ON_WRITE	    ; 84     54
  4202                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4203                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4204                                  ;                                                                          ;
  4205 00000EE0 [EC1E]                          short_addr  _$DUP_PDB                       ; 85     55
  4206                                  ;                                                                          ;
  4207                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4208                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4209 00000EE2 [B374]                          short_addr  _$RENAME			    ; 86     56
  4210 00000EE4 [E772]                          short_addr  _$FILE_TIMES                    ; 87     57
  4211 00000EE6 [D369]                          short_addr  _$ALLOCOPER                     ; 88     58
  4212                                  
  4213                                  ; 08/07/2018 - Retro DOS v3.0
  4214                                  ; -------------------------------------------------------------------------;
  4215                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4216                                  
  4217                                  ; Network extention system calls
  4218 00000EE8 [491D]                          short_addr  _$GetExtendedError              ; 89     59
  4219 00000EEA [4075]                          short_addr  _$CreateTempFile                ; 90     5A
  4220 00000EEC [2875]                          short_addr  _$CreateNewFile                 ; 91     5B
  4221 00000EEE [D875]                          short_addr  _$LockOper                      ; 92     5C
  4222 00000EF0 [F569]                          short_addr  _$ServerCall                    ; 93     5D
  4223 00000EF2 [4A6C]                          short_addr  _$UserOper                      ; 94     5E
  4224 00000EF4 [D96B]                          short_addr  _$AssignOper                    ; 95     5F
  4225 00000EF6 [A270]                          short_addr  _$NameTrans                     ; 96     60
  4226 00000EF8 [B717]                  	short_addr  NO_OP			    ; 97     61
  4227 00000EFA [9714]                          short_addr  _$GET_CURRENT_PDB		    ; 98     62
  4228                                  ; the next call is reserved for hangool sys call
  4229                                  	; 16/07/2018
  4230                                  	;short_addr  _$ECS_Call			    ; 99     63
  4231 00000EFC [B717]                  	short_addr  NO_OP			    ; 99     63
  4232                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4233                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4234                                  ;                                                                          ;
  4235 00000EFE [C414]                          short_addr  _$SET_PRINTER_FLAG              ; 100    64
  4236                                  ;                                                                          ;
  4237                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4238                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4239 00000F00 [471B]                          short_addr  _$GetExtCntry                   ; 101    65
  4240 00000F02 [441C]                          short_addr  _$GetSetCdPg                    ; 102    66
  4241 00000F04 [5871]                          short_addr  _$ExtHandle                     ; 103    67
  4242 00000F06 [3C71]                          short_addr  _$COMMIT                        ; 104    68
  4243                                  
  4244                                  ; 08/07/2018
  4245                                  ; Above system calls are valid for Retro DOS v3.0 (MSDOS 3.3) 
  4246                                  ; Following system calls are valid for Retro DOS v4.0 (MSDOS 6.0)
  4247                                  
  4248                                  ;	short_addr  _$GSetMediaID                   ; 105    69   ;AN000;
  4249                                  ;	short_addr  _$COMMIT                        ; 106    6A   ;AN000;
  4250                                  ;	short_addr  NO_OP                           ; 107    6B   
  4251                                  ;						    ; IFS_IOCTL no longer 
  4252                                  ;						    ; supported
  4253                                  ;	short_addr  _$Extended_Open                 ; 108    6C   ;AN000;
  4254                                  
  4255                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4256                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4257                                  ;                                                                          ;
  4258                                  ;ifdef ROMEXEC
  4259                                  ;       short_addr  $ROM_FIND_FIRST	   	    ; 109    6D
  4260                                  ;       short_addr  $ROM_FIND_NEXT	   	    ; 110    6E
  4261                                  ;	short_addr  $ROM_EXCLUDE		    ; 111    6F	  ; M078
  4262                                  ;endif
  4263                                  ;                                                                          ;
  4264                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
  4265                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
  4266                                  
  4267                                  ;MAXCOM  = ($-DISPATCH)/2 - 1
  4268                                  
  4269                                  MAXCOM  EQU ($-DISPATCH)/2 - 1
  4270                                  
  4271                                  ; 08/07/2018 - Retro DOS v3.0
  4272                                  ; MSDOS 6.0 - MSTABLE.ASM, 1991
  4273                                  
  4274                                  ;	If	Installed
  4275                                  
  4276                                  align 2
  4277                                  
  4278                                  ;PUBLIC FOO
  4279                                  
  4280                                  FOO:	; LABEL WORD
  4281 00000F08 [6918]                          short_addr  Leave2F
  4282                                  
  4283 00000F0A [0C0F]                  DTab:	DW  DOSTable
  4284                                  
  4285                                  	;PUBLIC FOO,DTAB
  4286                                  
  4287                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 0ED6h
  4288                                         
  4289                                  DOSTable:  ; LABEL  WORD
  4290 00000F0C 2F                              DB      (DOSTableEnd-DOSTable-1)/2 ; db  46
  4291 00000F0D [9618]                          short_addr  DOSInstall          ;   0 install check
  4292 00000F0F [313B]                          short_addr  DOS_CLOSE           ;   1   DOS_CLOSE
  4293 00000F11 [191D]                          short_addr  RECSET              ;   2   RECSET
  4294 00000F13 [9318]                          short_addr  DosGetGroup         ;   3   Get DOSGROUP
  4295 00000F15 [2B59]                          short_addr  PATHCHRCMP          ;   4   PATHCHRCMP
  4296 00000F17 [1324]                          short_addr  OUTT                ;   5   OUT
  4297 00000F19 [975B]                          short_addr  NET_I24_ENTRY       ;   6   NET_I24_ENTRY
  4298 00000F1B [F960]                          short_addr  PLACEBUF            ;   7   PLACEBUF
  4299 00000F1D [293C]                          short_addr  FREE_SFT            ;   8   FREE_SFT
  4300 00000F1F [BD62]                          short_addr  BUFWRITE            ;   9   BUFWRITE
  4301 00000F21 [7276]                          short_addr  SHARE_VIOLATION     ;   10  SHARE_VIOLATION
  4302 00000F23 [DB38]                          short_addr  SHARE_ERROR         ;   11  SHARE_ERROR
  4303 00000F25 [C438]                          short_addr  SET_SFT_MODE        ;   12  SET_SFT_MODE
  4304 00000F27 [5419]                          short_addr  DATE16              ;   13  DATE16
  4305 00000F29 [2A20]                          short_addr  Idle		;   14      empty slot
  4306 00000F2B [ED60]                          short_addr  SCANPLACE           ;   15  SCANPLACE
  4307 00000F2D [2A20]                          short_addr  Idle		;   16      empty slot
  4308 00000F2F [F31F]                          short_addr  StrCpy              ;   17  StrCpy
  4309 00000F31 [0B20]                          short_addr  StrLen              ;   18  StrLen
  4310 00000F33 [EF58]                          short_addr  UCase		;   19  UCase
  4311 00000F35 [9161]                          short_addr  POINTCOMP           ;   20  POINTCOMP
  4312 00000F37 [9462]                          short_addr  CHECKFLUSH          ;   21  CHECKFLUSH
  4313 00000F39 [596B]                          short_addr  SFFromSFN           ;   22  SFFromSFN
  4314 00000F3B [0A6D]                          short_addr  GetCDSFromDrv       ;   23  GetCDSFromDrv
  4315 00000F3D [4916]                          short_addr  Get_User_Stack      ;   24  Get_User_Stack
  4316 00000F3F [B76C]                          short_addr  GETTHISDRV          ;   25  GetThisDrv
  4317 00000F41 [C770]                          short_addr  DriveFromText       ;   26  DriveFromText
  4318 00000F43 [FB19]                          short_addr  SETYEAR             ;   27  SETYEAR
  4319 00000F45 [921A]                          short_addr  DSUM                ;   28  DSUM
  4320 00000F47 [EF19]                          short_addr  DSLIDE              ;   29  DSLIDE
  4321 00000F49 [D51F]                          short_addr  StrCmp              ;   30  StrCmp
  4322 00000F4B [FD6B]                          short_addr  InitCDS             ;   31  initcds
  4323 00000F4D [2B6B]                          short_addr  pJFNFromHandle      ;   32  pJfnFromHandle
  4324 00000F4F [A270]                          short_addr  _$NameTrans		;   33  $NameTrans
  4325 00000F51 [DE17]                          short_addr  CAL_LK              ;   34  CAL_LK
  4326 00000F53 [D74C]                          short_addr  DEVNAME             ;   35  DEVNAME
  4327 00000F55 [2A20]                          short_addr  Idle                ;   36  Idle
  4328 00000F57 [1920]                          short_addr  DStrLen             ;   37  DStrLen
  4329 00000F59 [AC20]                          short_addr  NLS_OPEN            ;   38  NLS_OPEN      DOS 3.3
  4330 00000F5B [0971]                          short_addr  _$CLOSE		;   39  $CLOSE        DOS 3.3
  4331 00000F5D [B220]                          short_addr  NLS_LSEEK           ;   40  NLS_LSEEK     DOS 3.3
  4332 00000F5F [2172]                          short_addr  _$READ		;   41  $READ         DOS 3.3
  4333 00000F61 [8B20]                          short_addr  FastInit            ;   42  FastInit      DOS 3.4  ;AN000;
  4334 00000F63 [EB20]                          short_addr  NLS_IOCTL           ;   43  NLS_IOCTL     DOS 3.3
  4335 00000F65 [DE20]                          short_addr  GetDevList          ;   44  GetDevList    DOS 3.3
  4336 00000F67 [0821]                          short_addr  NLS_GETEXT          ;   45  NLS_GETEXT    DOS 3.3
  4337                                          
  4338                                  	; 10/08/2018
  4339                                  	;short_addr  MSG_RETRIEVAL	;   46  MSG_RETRIEVAL DOS 4.0  ;AN000;
  4340                                  
  4341 00000F69 [B717]                  	short_addr  NO_OP		;   M006: 47  no longer supported
  4342                                  ;*** 	short_addr  Fake_Version	;   47  Fake_Version  DOS 4.0  ;AN006;
  4343                                  
  4344                                  DOSTableEnd:  ; LABEL BYTE
  4345                                  
  4346                                  	;ENDIF
  4347                                  
  4348                                  ;============================================================================
  4349                                  ; DOSTAB.ASM, MSDOS 6.0, 1991
  4350                                  ;============================================================================
  4351                                  ; 16/07/2018 - Retro DOS v3.0
  4352                                  
  4353                                  ;----------------THE FOLL. BLOCK MOVED FROM TABLE SEG IN MS_TABLE.ASM-------
  4354                                  
  4355                                  ; SYS init extended table,   DOS 3.3   F.C. 5/29/86
  4356                                  ;
  4357                                  	;PUBLIC	SysInitTable
  4358                                  
  4359                                  SysInitTable:	; label  byte
  4360 00000F6B [2600]                  	dw      SYSINITVARS			; pointer to sysinit var
  4361 00000F6D 0000                            dw      0                             	; segment
  4362 00000F6F [3B10]                          dw      COUNTRY_CDPG		   	; pointer to country tabl
  4363 00000F71 0000                            dw      0                            	; segment of pointer
  4364                                  
  4365                                  ; DOS 3.3 F.C. 6/12/86
  4366                                  ; FASTOPEN communications area DOS 3.3   F.C. 5/29/86
  4367                                  ;
  4368                                  	;PUBLIC	FastOpenTable
  4369                                  	;PUBLIC	FastTable		; a better name
  4370                                  	;EXTRN	FastRet:FAR		; defined in misc2.asm
  4371                                  
  4372                                  ; MSDOS 6.0
  4373                                  ;FastTable:     ;label  byte		; a better name
  4374                                  ;FastOpenTable: ;label  byte
  4375                                  ;	dw      2                       ; number of entries
  4376                                  ;	dw      FastRet			; pointer to ret instr.
  4377                                  ;	dw      0                       ; and will be modified by
  4378                                  ;	dw      FastRet			; FASTxxx when loaded in
  4379                                  ;	dw      0                       
  4380                                  
  4381                                  ;
  4382                                  ; DOS 3.3 F.C. 6/12/86
  4383                                  ;
  4384                                  
  4385                                  ;	PUBLIC	FastFlg                 ; flags
  4386                                  ;FastFlg:	;label  byte		; don't change the foll: order
  4387                                  ;FastOpenFlg:
  4388                                  ;	db	0  ; I_am    FastOpenFlg,BYTE,<0>
  4389                                  
  4390                                  ; MSDOS 3.3
  4391                                  FastTable:
  4392                                  FastOpenTable:
  4393 00000F73 0400                    	dw	4 
  4394 00000F75 [A820]                  	dw	FastRet
  4395 00000F77 0000                    	dw	0  ; (('FastRet' segment will be set to CS by DOSINIT))
  4396                                  
  4397                                  	;PUBLIC	FastOpen_Ext_Info
  4398                                  
  4399                                  ; FastOpen_Ext_Info is used as a temporary storage for saving dirpos,dirsec
  4400                                  ; and clusnum  which are filled by DOS 3.ncwhen calling FastOpen Insert
  4401                                  ; or filled by FastOPen when calling FastOpen Lookup
  4402                                  
  4403                                  FastOpen_Ext_Info: ;label  byte		;dirpos
  4404 00000F79 00<rep Bh>              	times	FEI.size db 0	; 5 (for MSDOS 3.3), 11 (for MSDOS 6.0)
  4405                                  
  4406                                  ; Dir_Info_Buff is a dir entry buffer which is filled by FastOPen
  4407                                  ; when calling FastOpen Lookup
  4408                                  
  4409                                  	;PUBLIC	Dir_Info_Buff
  4410                                  
  4411                                  Dir_Info_Buff:	; label  byte
  4412 00000F84 00<rep 20h>             	times	dir_entry.size db 0 ; 32 ; segment of pointer
  4413                                  
  4414                                  ; MSDOS 3.3 (IBMDOS.COM, 1987)
  4415                                  FastFlg:
  4416                                  FastOpenFlg:
  4417 00000FA4 00                      	db	0
  4418                                  
  4419                                  	;I_am	Next_Element_Start,WORD	; save next element start offset
  4420                                  Next_Element_Start:
  4421 00000FA5 0000                    	dw	0
  4422                                  
  4423                                  	; MSDOS 6.0
  4424                                  	;I_am    Del_ExtCluster,WORD     ; for dos_delete                       
  4425                                  
  4426                                  ; 17/07/2018
  4427                                  
  4428                                  ; The following is a stack and its pointer for interrupt 2F which is uesd
  4429                                  ; by NLSFUNC.  There is no significant use of this stack, we are just trying
  4430                                  ; not to destroy the INT 21 stack saved for the user.
  4431                                  
  4432                                  	;PUBLIC	USER_SP_2F
  4433                                  
  4434                                  USER_SP_2F:	; LABEL  WORD
  4435 00000FA7 [A90F]                  	dw	FAKE_STACK_2F
  4436                                  
  4437                                  	;PUBLIC	Packet_Temp
  4438                                  ;Packet_Temp	label  word		; temporary packet used by readtime
  4439                                  	;PUBLIC  DOS_TEMP		; temporary word
  4440                                  ;DOS_TEMP	label  word
  4441                                  FAKE_STACK_2F:
  4442                                  	;dw	14 dup (0)
  4443 00000FA9 0000<rep Ch>            	times	12 dw 0			; 12 register temporary storage
  4444                                  
  4445                                  	;PUBLIC	Hash_Temp		; temporary word
  4446                                  ;Hash_Temp	label  word              
  4447                                  	;dw	4 dup (0)		; temporary hash table during config.sys
  4448                                  
  4449                                  	;PUBLIC  SCAN_FLAG             	; flag to indicate key ALT_Q
  4450                                  SCAN_FLAG:	; label  byte
  4451 00000FC1 00                      	db	0
  4452                                  
  4453                                  ; MSDOS 3.3
  4454                                  DISK_FULL:
  4455 00000FC2 00                      	db	0
  4456                                  
  4457                                  	;PUBLIC  DATE_FLAG
  4458                                  DATE_FLAG:   	;label  word 		; flag to
  4459 00000FC3 0000                    	dw     0                	; to update the date
  4460                                  
  4461                                  ;FETCHI_TAG:	;label  word		; OBSOLETE - no longer used
  4462                                  ;	dw     0			; formerly part of IBM's piracy protection
  4463                                  
  4464                                  ; 24/07/2019 - Retro DOS v3.2
  4465                                  ; (MSDOS 6.0)
  4466                                  ;*** New FCB Implementation
  4467                                  ; This variable is used as a cache in the new FCB implementation to remember
  4468                                  ;the address of a local SFT that can be recycled for a regenerate operation
  4469                                  
  4470                                  LocalSFT: 
  4471 00000FC5 00000000                	dd	0			; 0 to indicate invalid pointer
  4472                                  OLD_FIRSTCLUS:
  4473 00000FC9 0000                    	dw	0			; save old first cluster for fastopen
  4474                                  CL0FATENTRY:
  4475 00000FCB FFFF                    	dw	-1			; M014:	Holds the data that
  4476                                  					; is used in pack/unpack rts.
  4477                                  					; in fat.asm if cluster 0 is specified.
  4478                                  					; SR;
  4479                                  ; MSDOS 6.0
  4480                                  ;      PUBLIC	MSG_EXTERROR 		; for system message addr              
  4481                                  ;MSG_EXTERROR	label  DWORD                                                     
  4482                                  ;               dd     0                ; for extended error                   
  4483                                  ;               dd     0                ; for parser                           
  4484                                  ;              	dd     0                ; for critical errror                  
  4485                                  ;              	dd     0                ; for IFS                              
  4486                                  ;              	dd     0                ; for code reduction                   
  4487                                  ;
  4488                                  ;      PUBLIC  	SEQ_SECTOR              ; last sector read                     
  4489                                  ;SEQ_SECTOR    	label  DWORD                                                     
  4490                                  ;              	dd     -1                                                        
  4491                                  ;
  4492                                  ;;      I_am    ACT_PAGE,WORD,<-1>      ; active EMS page                       
  4493                                  ;	I_am    SC_SECTOR_SIZE,WORD     ; sector size for SC                 
  4494                                  ;       I_am    SC_DRIVE,BYTE           ; drive # for secondary cache        
  4495                                  ;       I_am    CurSC_DRIVE,BYTE,<-1>   ; current SC drive                   
  4496                                  ;       I_am    CurSC_SECTOR,DWORD      ; current SC starting sector         
  4497                                  ;       I_am    SC_STATUS,WORD,<0>      ; SC status word                     
  4498                                  ;       I_am    SC_FLAG,BYTE,<0>        ; SC flag                            
  4499                                  ;       I_am    AbsDskErr,WORD,<0>	; Storage for Abs dsk read/write err
  4500                                  ;
  4501                                  ;	PUBLIC 	NO_NAME_ID                                                           
  4502                                  ;NO_NAME_ID	label byte                                                           
  4503                                  ;		db   'NO NAME    '	; null media id                      
  4504                                  ;
  4505                                  ;;hkn; moved from TABLE segment in kstrin.asm
  4506                                  ;
  4507                                  ;Public	KISTR001S,KISTR001E,LOOKSIZ	; 2/17/KK
  4508                                  ;KISTR001S	label	byte		; 2/17/KK
  4509                                  ;LOOKSIZ DB	0			; 0 if byte, NZ if word	2/17/KK
  4510                                  ;KISTR001E	label	byte		; 2/17/KK
  4511                                  ;
  4512                                  ;; the nul device driver used to be part of the code. However, since the 
  4513                                  ;; header is in the data, and the entry points are only given as an offset,
  4514                                  ;; the strategy and interrupt entry points must also be in the data now.
  4515                                  ;;
  4516                                  ;
  4517                                  ;procedure   snuldev,far
  4518                                  ;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
  4519                                  ; 	or	es:[bx.reqstat],stdon	; set done bit
  4520                                  ;entry inuldev
  4521                                  ;	ret				; must not be a return!
  4522                                  ;endproc snuldev
  4523                                  ;
  4524                                  
  4525                                  ; 24/07/2019
  4526                                  AbsDskErr:
  4527 00000FCD 0000                    	dw	0			; Storage for Abs dsk read/write err
  4528                                  
  4529                                  ;============================================================================
  4530                                  ; MSTABLE.ASM, MSDOS 6.0, 1991
  4531                                  ;============================================================================
  4532                                  ; 17/07/2018 - Retro DOS v3.0
  4533                                  
  4534                                  ; ----------------------------------------------------------------------------
  4535                                  ; BREAK   <Copyright notice and version>
  4536                                  ; ----------------------------------------------------------------------------
  4537                                  
  4538                                  ;CODSTRT EQU     $
  4539                                  
  4540                                  ; 08/07/2018 - Retro DOS v3.0 by Erdogan Tan
  4541                                  ; (MSTABLE.ASM, MSDOS 6.0, 1991)
  4542                                  
  4543                                  ; NOTE WARNING: This declaration of HEADER must be THE LAST thing in this
  4544                                  ;       module. The reason is so that the data alignments are the same in
  4545                                  ;       IBM-DOS and MS-DOS up through header.
  4546                                  
  4547                                  	;PUBLIC	HEADER
  4548                                  
  4549                                  HEADER:	; LABEL	BYTE
  4550                                          ;IF	DEBUG
  4551                                          ;DB	13,10,"Debugging DOS version "
  4552                                          ;DB	MAJOR_VERSION + "0"
  4553                                          ;DB	"."
  4554                                          ;DB	(MINOR_VERSION / 10) + "0"
  4555                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  4556                                          ;ENDIF
  4557                                  
  4558                                          ;IF	NOT IBM
  4559 00000FCF 0D0A4D532D444F5320-             DB	13,10,"MS-DOS version "
  4559 00000FD8 76657273696F6E20   
  4560 00000FE0 33                              DB	MAJOR_VERSION + "0"
  4561 00000FE1 2E                              DB	"."
  4562 00000FE2 33                              DB	(MINOR_VERSION / 10) + "0"
  4563                                          ;DB	(MINOR_VERSION MOD 10) + "0"
  4564 00000FE3 30                              DB	(MINOR_VERSION % 10) + "0"
  4565                                  
  4566                                          ;IF	HIGHMEM
  4567                                          ;DB	"H"
  4568                                          ;ENDIF
  4569                                  
  4570 00000FE4 0D0A436F7079726967-     	DB	13,10,"Copyright 1981,82,83,84,88 Microsoft Corp.",13,10,"$"
  4570 00000FED 687420313938312C38-
  4570 00000FF6 322C38332C38342C38-
  4570 00000FFF 38204D6963726F736F-
  4570 00001008 667420436F72702E0D-
  4570 00001011 0A24               
  4571                                  	;ENDIF
  4572                                  
  4573                                  ;IF DEBUG
  4574                                  ;	DB	13,10,"$"
  4575                                  ;ENDIF
  4576                                  
  4577                                  ;include copyrigh.inc
  4578                                  
  4579                                  	;DB	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
  4580                                  	;DB	"Licensed Material - Property of Microsoft "
  4581                                  	;DB	"All rights reserved "
  4582                                  
  4583                                  ;============================================================================
  4584                                  ; MCODE.ASM, MSDOS 6.0, 1991
  4585                                  ;============================================================================
  4586                                  ; 17/07/2018 - Retro DOS v3.0
  4587                                  
  4588                                  ;	TITLE	MISC DOS ROUTINES - Int 25 and 26 handlers and other
  4589                                  ;	NAME	IBMCODE
  4590                                  
  4591                                  ;BREAK <NullDev -- Driver for null device>
  4592                                  
  4593                                  ; ROMDOS note:
  4594                                  ;	NUL device driver used to be here, but it was removed and placed in
  4595                                  ;	DOSDATA, because the entry points have to be in the segment as the
  4596                                  ;	header, which is also in DOSDATA.
  4597                                  
  4598                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>
  4599                                  
  4600                                  ;Public MSC001S,MSC001E
  4601                                  ;MSC001S label byte
  4602                                  	;IF	IBM
  4603                                  ; Codes returned by BIOS
  4604                                  ERRIN:
  4605 00001013 02                      	DB	2			; NO RESPONSE
  4606 00001014 06                      	DB	6			; SEEK FAILURE
  4607 00001015 0C                      	DB	12			; GENERAL ERROR
  4608 00001016 04                      	DB	4			; BAD CRC
  4609 00001017 08                      	DB	8			; SECTOR NOT FOUND
  4610 00001018 00                      	DB	0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
  4611                                  ERROUT:
  4612                                  ; DISK ERRORS RETURNED FROM INT 25 and 26
  4613 00001019 80                      	DB	80H			; NO RESPONSE
  4614 0000101A 40                      	DB	40H			; Seek failure
  4615 0000101B 02                      	DB	2			; Address Mark not found
  4616 0000101C 10                      	DB	10H			; BAD CRC
  4617 0000101D 04                      	DB	4			; SECTOR NOT FOUND
  4618 0000101E 03                      	DB	3			; WRITE ATTEMPT TO WRITE-PROTECT DISK
  4619                                  
  4620                                  NUMERR	EQU	$-ERROUT
  4621                                  	;ENDIF
  4622                                  ;MSC001E label byte
  4623                                  
  4624                                  ;============================================================================
  4625                                  ; DOSMES.INC (MSDOS 3.3, 1987)
  4626                                  ;============================================================================
  4627                                  ; 17/07/2018 - Retro DOS v3.0
  4628                                  
  4629                                  ;TABLE	SEGMENT BYTE PUBLIC 'TABLE'
  4630                                  
  4631                                  ; The international table(s). Used for DOS 3.x  (x < 3)
  4632                                  ; This is simply a sequence of tables of the following form:
  4633                                  ;
  4634                                  ; Offset
  4635                                  ;		BYTE  Size of this table excluding this byte and the next
  4636                                  ;		WORD  Country code represented by this table
  4637                                  ;			A sequence of n bytes, where n is the number specified
  4638                                  ;			by the first byte above and is not > internat_block_max,
  4639                                  ;			in the correct order for being returned by the
  4640                                  ;			INTERNATIONAL call as follows:
  4641                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  4642                                  ;		5 BYTE	Currency symbol null terminated
  4643                                  ;		2 BYTE	thousands separator null terminated
  4644                                  ;		2 BYTE	Decimal point null terminated
  4645                                  ;		2 BYTE	Date separator null terminated
  4646                                  ;		2 BYTE	Time separator null terminated
  4647                                  ;		1 BYTE	Bit field.  Currency format.
  4648                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  4649                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  4650                                  ;			Bit 2.	=1 imbedded at decimal point, & no spaces;
  4651                                  ;		1 BYTE	No. of significant decimal digits in currency
  4652                                  ;		1 BYTE	Bit field.  Time format.
  4653                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  4654                                  ;		WORD	Segment offset for address of case conversion routine
  4655                                  ;		WORD	RESERVED. Filled in by DOS. Segment value for above routine
  4656                                  ;		2 BYTE	Data list separator null terminated.
  4657                                  ;		   NOTE: The segment part of the DWORD Map_call is set
  4658                                  ;			by the INTERNATIONAL call. Do not try to initialize
  4659                                  ;			it to anything meaningful.
  4660                                  ;
  4661                                  ; The list of tables is terminated by putting a byte of -1 after the last
  4662                                  ;	table (a table with length -1).
  4663                                  
  4664                                  	; PUBLIC  international_table
  4665                                  
  4666                                  ; Offset 0F95h in IBMDOS.COM (MSDOS 3.3), 1987
  4667                                  
  4668                                  international_table:	; LABEL BYTE
  4669                                  
  4670 0000101F 18                      	DB 	INTERNAT_BLOCK.size  ; = 24 ; Size in bytes of this table
  4671 00001020 0100                    	DW 	1		; Country code
  4672                                  USTABLE:
  4673 00001022 0000                    	dw	0		; 0-USA, 1-EUR, 2-JAP
  4674 00001024 2400000000              	db	'$',0,0,0,0	; Currency Symbol 5 bytes
  4675 00001029 2C00                    	db	',',0		; Thousands separator 2 bytes
  4676 0000102B 2E00                    	db	'.',0		; Decimal separator 2 bytes
  4677 0000102D 2D00                    	db	'-',0		; Date separator 2 bytes
  4678 0000102F 3A00                    	db	':',0		; Time separator 2 bytes
  4679 00001031 00                      	db	0		; Bit values
  4680                                                                 	;   Bit 0 = 0 if currency symbol first
  4681                                                                 	;         = 1 if currency symbol last
  4682                                                                 	;   Bit 1 = 0 if No space after currency symbol
  4683                                                                 	;         = 1 if space after currency symbol
  4684 00001032 02                      	db	2		; Number of places after currency dec point
  4685 00001033 00                      	db	0		; if 24 hour time, 0 if 12 hour time
  4686 00001034 [9918]                  	dw	MAP_CASE	; Address of case mapping call (DWORD)
  4687 00001036 0000                            dw	0		; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
  4688                                  				;  in pieces.
  4689 00001038 2C00                    	db	',',0		; Data list separator character
  4690                                  
  4691                                  ;	Tables for the IBM PC character set follow. The values
  4692                                  ;	associated with some of the currency symbols may change with
  4693                                  ;	other character sets. You may wish to add or delete country
  4694                                  ;	entries. NOTE: It is not a mistake that the JAPANESE entry
  4695                                  ;	has different currency symbols for the KANJI and
  4696                                  ;	non-KANJI versions.
  4697                                  	
  4698 0000103A FF                      	DB	-1		; end of table
  4699                                  
  4700                                  ; The following table is used for DOS 3.3
  4701                                  ;DOS country and code page information is defined here for DOS 3.3.
  4702                                  ;The initial value for ccDosCountry is 1 (USA).
  4703                                  ;The initial value for ccDosCodepage is 850.
  4704                                  ;
  4705                                  ;
  4706                                  	;PUBLIC  COUNTRY_CDPG,UCASE_TAB,FILE_UCASE_TAB
  4707                                  	;PUBLIC  FILE_CHAR_TAB
  4708                                  
  4709                                  ; country and code page infomation
  4710                                  
  4711                                  COUNTRY_CDPG:	; label  byte
  4712 0000103B 0000000000000000        	db	0,0,0,0,0,0,0,0		; reserved words
  4713 00001043 5C434F554E5452592E-     	db	'\COUNTRY.SYS',0	; path name of country.sys
  4713 0000104C 53595300           
  4714 00001050 00<rep 33h>             	times	51 db 0
  4715 00001083 B501                    	dw	437			; system code page id
  4716 00001085 0500                    	dw	5			; number of entries
  4717 00001087 02                      	db	SetUcase		; Ucase type
  4718 00001088 [C410]                  	dw	UCASE_TAB		; pointer to upper case table
  4719 0000108A 0000                    	dw	0			; segment of poiter
  4720 0000108C 04                      	db	SetUcaseFile		; Ucase file char type
  4721 0000108D [4611]                  	dw	FILE_UCASE_TAB		; pointer to file upper case table
  4722 0000108F 0000                    	dw	0			; segment of poiter
  4723 00001091 05                      	db	SetFileList		; valid file chars type
  4724 00001092 [C811]                  	dw	FILE_CHAR_TAB		; pointer to valid file char tab
  4725 00001094 0000                    	dw	0			; segment of poiter
  4726 00001096 06                      	db	SetCollate		; collate type
  4727 00001097 [F811]                  	dw	COLLATE_TAB		; pointer to collate table
  4728 00001099 0000                    	dw	0			; segment of pointer
  4729 0000109B 01                      	db	SetCountryInfo		; country info type
  4730 0000109C 2600                    	dw	NEW_COUNTRY_SIZE	; extended country info size
  4731 0000109E 0100                    	dw	1			; USA country id
  4732 000010A0 B501                    	dw	437			; USA system code page id
  4733 000010A2 0000                    	dw	0			; date format
  4734 000010A4 2400000000              	db	'$',0,0,0,0		; currency symbol
  4735 000010A9 2C00                    	db	',',0			; thousand separator
  4736 000010AB 2E00                    	db	'.',0			; decimal separator
  4737 000010AD 2D00                    	db	'-',0			; date separator
  4738 000010AF 3A00                    	db	':',0			; time separator
  4739 000010B1 00                      	db	0			; currency format flag
  4740 000010B2 02                      	db	2			; # of disgit in currency
  4741 000010B3 00                      	db	0			; time format
  4742 000010B4 [9918]                  	dw	MAP_CASE		;mono case routine entry point
  4743 000010B6 0000                    	dw	0			; segment of entry point
  4744 000010B8 2C00                    	db	',',0			; data list separator
  4745 000010BA 000000000000000000-     	dw	0,0,0,0,0		; reserved
  4745 000010C3 00                 
  4746                                  
  4747                                  ; upper case table
  4748                                  
  4749                                  UCASE_TAB: 	; label   byte
  4750 000010C4 8000                    	dw	128
  4751 000010C6 809A45418E418F80        	db	128,154,069,065,142,065,143,128
  4752 000010CE 4545454949498E8F        	db	069,069,069,073,073,073,142,143
  4753 000010D6 9092924F994F5555        	db	144,146,146,079,153,079,085,085
  4754 000010DE 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
  4755 000010E6 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
  4756 000010EE A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
  4757 000010F6 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4758 000010FE B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4759 00001106 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4760 0000110E C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4761 00001116 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4762 0000111E D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4763 00001126 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
  4764 0000112E E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4765 00001136 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4766 0000113E F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4767                                  
  4768                                  ; file upper case table
  4769                                  
  4770                                  FILE_UCASE_TAB: ; label  byte
  4771 00001146 8000                    	dw	128
  4772 00001148 809A45418E418F80        	db	128,154,069,065,142,065,143,128
  4773 00001150 4545454949498E8F        	db	069,069,069,073,073,073,142,143
  4774 00001158 9092924F994F5555        	db	144,146,146,079,153,079,085,085
  4775 00001160 59999A9B9C9D9E9F        	db	089,153,154,155,156,157,158,159
  4776 00001168 41494F55A5A5A6A7        	db	065,073,079,085,165,165,166,167
  4777 00001170 A8A9AAABACADAEAF        	db	168,169,170,171,172,173,174,175
  4778 00001178 B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4779 00001180 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4780 00001188 C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4781 00001190 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4782 00001198 D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4783 000011A0 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4784 000011A8 E0E1E2E3E4E5E6E7        	db	224,225,226,227,228,229,230,231
  4785 000011B0 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4786 000011B8 F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4787 000011C0 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4788                                  
  4789                                  ; file char list
  4790                                  
  4791                                  FILE_CHAR_TAB:	; label  byte
  4792 000011C8 1600                    	dw	22				; length
  4793 000011CA 0100FF                  	db	1,0,255 			; include all
  4794 000011CD 000020                  	db	0,0,20h 			; exclude 0 - 20h
  4795 000011D0 020E2E222F5C5B5D3A-     	db	2,14,'."/\[]:|<>+=;,'           ; exclude 14 special
  4795 000011D9 7C3C3E2B3D3B2C     
  4796                                  	;db	24 dup (?)			; reserved
  4797 000011E0 00<rep 18h>             	times	24 db 0
  4798                                  
  4799                                  ; collate table
  4800                                  
  4801                                  COLLATE_TAB:	; label   byte
  4802 000011F8 0001                    	dw	256
  4803 000011FA 0001020304050607        	db	0,1,2,3,4,5,6,7
  4804 00001202 08090A0B0C0D0E0F        	db	8,9,10,11,12,13,14,15
  4805 0000120A 1011121314151617        	db	16,17,18,19,20,21,22,23
  4806 00001212 18191A1B1C1D1E1F        	db	24,25,26,27,28,29,30,31
  4807 0000121A 2021222324252627        	db	" ","!",'"',"#","$","%","&","'"
  4808 00001222 28292A2B2C2D2E2F        	db	"(",")","*","+",",","-",".","/"
  4809 0000122A 3031323334353637        	db	"0","1","2","3","4","5","6","7"
  4810 00001232 38393A3B3C3D3E3F        	db	"8","9",":",";","<","=",">","?"
  4811 0000123A 4041424344454647        	db	"@","A","B","C","D","E","F","G"
  4812 00001242 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
  4813 0000124A 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
  4814 00001252 58595A5B5C5D5E5F        	db	"X","Y","Z","[","\","]","^","_"
  4815 0000125A 6041424344454647        	db	"`","A","B","C","D","E","F","G"
  4816 00001262 48494A4B4C4D4E4F        	db	"H","I","J","K","L","M","N","O"
  4817 0000126A 5051525354555657        	db	"P","Q","R","S","T","U","V","W"
  4818 00001272 58595A7B7C7D7E7F        	db	"X","Y","Z","{","|","}","~",127
  4819 0000127A 4355454141414143        	db	"C","U","E","A","A","A","A","C"
  4820 00001282 4545454949494141        	db	"E","E","E","I","I","I","A","A"
  4821 0000128A 4541414F4F4F5555        	db	"E","A","A","O","O","O","U","U"
  4822 00001292 594F552424242424        	db	"Y","O","U","$","$","$","$","$"
  4823 0000129A 41494F554E4EA6A7        	db	"A","I","O","U","N","N",166,167
  4824 000012A2 3FA9AAABAC212222        	db	"?",169,170,171,172,"!",'"','"'
  4825 000012AA B0B1B2B3B4B5B6B7        	db	176,177,178,179,180,181,182,183
  4826 000012B2 B8B9BABBBCBDBEBF        	db	184,185,186,187,188,189,190,191
  4827 000012BA C0C1C2C3C4C5C6C7        	db	192,193,194,195,196,197,198,199
  4828 000012C2 C8C9CACBCCCDCECF        	db	200,201,202,203,204,205,206,207
  4829 000012CA D0D1D2D3D4D5D6D7        	db	208,209,210,211,212,213,214,215
  4830 000012D2 D8D9DADBDCDDDEDF        	db	216,217,218,219,220,221,222,223
  4831 000012DA E053                    	db	224,"S"
  4832 000012DC E2E3E4E5E6E7            	db	226,227,228,229,230,231
  4833 000012E2 E8E9EAEBECEDEEEF        	db	232,233,234,235,236,237,238,239
  4834 000012EA F0F1F2F3F4F5F6F7        	db	240,241,242,243,244,245,246,247
  4835 000012F2 F8F9FAFBFCFDFEFF        	db	248,249,250,251,252,253,254,255
  4836                                  
  4837                                  ;include divmes.inc
  4838                                  
  4839                                  ; THIS IS THE ONLY DOS "MESSAGE". IT DOES NOT NEED A TERMINATOR.
  4840                                  	;PUBLIC	DIVMES
  4841                                  
  4842 000012FA 0D0A44697669646520-     DIVMES:	DB	13,10,"Divide overflow",13,10
  4842 00001303 6F766572666C6F770D-
  4842 0000130C 0A                 
  4843                                  
  4844                                  	;PUBLIC	DivMesLen
  4845                                  DivMesLen:
  4846 0000130D 1300                    	DW	$-DIVMES	; Length of the above message in bytes
  4847                                  
  4848                                  ;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS
  4849                                  
  4850                                  ; The following two tables implement the current buffered input editing
  4851                                  ; routines. The tables are pairwise associated in reverse order for ease
  4852                                  ; in indexing. That is; The first entry in ESCTAB corresponds to the last
  4853                                  ; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.
  4854                                  
  4855                                  	;PUBLIC	CANCHAR
  4856                                  CANCHAR:
  4857 0000130F 1B                      	DB	CANCEL	; 1Bh	;Cancel line character
  4858                                  	
  4859                                  	;PUBLIC	ESCCHAR
  4860                                  ESCCHAR:
  4861 00001310 00                      	DB	ESCCH	; 0	;Lead-in character for escape sequences
  4862                                  	
  4863                                  	;IF	NOT Rainbow
  4864                                  
  4865                                  ESCTAB:	; LABEL BYTE
  4866                                  
  4867                                  	;IF	IBM
  4868 00001311 40                      	DB	64		; Ctrl-Z - F6
  4869 00001312 4D                      	DB	77		; Copy one char - -->
  4870 00001313 3B                      	DB	59		; Copy one char - F1
  4871 00001314 53                      	DB	83		; Skip one char - DEL
  4872 00001315 3C                      	DB	60		; Copy to char - F2
  4873 00001316 3E                      	DB	62		; Skip to char - F4
  4874 00001317 3D                      	DB	61		; Copy line - F3
  4875 00001318 3D                      	DB	61		; Kill line (no change to template ) - Not used
  4876 00001319 3F                      	DB	63		; Reedit line (new template) - F5
  4877 0000131A 4B                      	DB	75		; Backspace - <--
  4878 0000131B 52                      	DB	82		; Enter insert mode - INS (toggle)
  4879 0000131C 52                      	DB	82		; Exit insert mode - INS (toggle)
  4880 0000131D 41                      	DB	65		; Escape character - F7
  4881 0000131E 41                      	DB	65		; End of table
  4882                                  	;ENDIF
  4883                                  
  4884                                  ESCEND: ; LABEL BYTE
  4885                                  
  4886                                  ESCTABLEN EQU ESCEND-ESCTAB
  4887                                  
  4888                                  ESCFUNC: ; LABEL WORD
  4889                                  	
  4890 0000131F [CE21]                  	short_addr  GETCH	; Ignore the escape sequence
  4891 00001321 [BB22]                  	short_addr  TWOESC
  4892 00001323 [4323]                  	short_addr  EXITINS
  4893 00001325 [4323]                  	short_addr  ENTERINS
  4894 00001327 [4522]                  	short_addr  BACKSP
  4895 00001329 [2F23]                  	short_addr  REEDIT
  4896 0000132B [3222]                  	short_addr  KILNEW
  4897 0000132D [C222]                  	short_addr  COPYLIN
  4898 0000132F [F522]                  	short_addr  SKIPSTR
  4899 00001331 [C822]                  	short_addr  COPYSTR
  4900 00001333 [EB22]                  	short_addr  SKIPONE
  4901 00001335 [CD22]                  	short_addr  COPYONE
  4902 00001337 [CD22]                  	short_addr  COPYONE
  4903 00001339 [4B23]                  	short_addr  CTRLZ
  4904                                  
  4905                                  	;ENDIF
  4906                                  
  4907                                  ;TABLE	ENDS
  4908                                  
  4909                                  ; 17/07/2018
  4910                                  ; Offset 12B1h of IBMDOS.COM (MSDOS 3.3), 1987
  4911                                  
  4912                                  ;CRTERRTAB: ; 19/07/2018	
  4913                                  ;	db	0,5,52h,50h,3,5,20h
  4914                                  
  4915                                  ; 08/08/2018
  4916                                  
  4917                                  CRTERRTAB:	;LABEL BYTE	; Lookup table for MakeNode returns
  4918 0000133B 00                      	DB	0			; none
  4919 0000133C 05                      	DB	error_access_denied	; MakeNode error 1
  4920 0000133D 52                      	DB	error_cannot_make	; MakeNode error 2
  4921 0000133E 50                      	DB	error_file_exists	; MakeNode error 3
  4922 0000133F 03                      	DB	error_path_not_found	; MakeNode error 4
  4923 00001340 05                      	DB	error_access_denied	; MakeNode error 5
  4924 00001341 20                      	DB	error_sharing_violation ; MakeNode error 6
  4925                                  	; MSDOS 6.0
  4926                                  	;DB	error_file_not_found	; MakeNode error 7
  4927                                  
  4928                                  ;============================================================================
  4929                                  ; DEV.ASM (MSDOS 6.0, 1987)
  4930                                  ;============================================================================
  4931                                  ; 17/07/2018 - Retro DOS v3.0
  4932                                  
  4933                                  ; Offset 12B8h of IBMDOS.COM (MSDOS 3.3), 1987
  4934                                  
  4935                                  ;Public DEV001S, DEV001E 		; Pathgen labels
  4936                                  ;DEV001s:
  4937                                  ;		length of packets
  4938 00001342 160E160D0F0E            LenTab:		DB	DRDWRHL, DRDNDHL, DRDWRHL, DSTATHL, DFLSHL, DRDNDHL
  4939                                  ;LenTab:	db	22,14,22,13,15,14
  4940                                  
  4941                                  ;	       Error Function
  4942                                  
  4943                                  CmdTab:
  4944 00001348 8604                    	DB	86h, DEVRD	; 0 input
  4945 0000134A 8605                    	DB	86h, DEVRDND	; 1 input status
  4946 0000134C 8708                    	DB	87h, DEVWRT	; 2 output
  4947 0000134E 870A                    	DB	87h, DEVOST	; 3 output status
  4948 00001350 8607                    	DB	86h, DEVIFL	; 4 input flush
  4949 00001352 8605                    	DB	86H, DEVRDND	; 5 input status with system WAIT
  4950                                  
  4951                                  ; Offset 12BEh of IBMDOS.COM (MSDOS 3.3), 1987
  4952                                  
  4953                                  ;CmdTab:
  4954                                  ;	db	86h, 4
  4955                                  ;	db	86h, 5
  4956                                  ;	db	87h, 8
  4957                                  ;	db	87h, 10
  4958                                  ;	db	86h, 7
  4959                                  ;	db	86h, 5
  4960                                  
  4961                                  ;DEV001E:
  4962                                  
  4963                                  ;============================================================================
  4964                                  ; FCB.ASM (MSDOS 6.0, 1987)
  4965                                  ;============================================================================
  4966                                  ; 17/07/2018 - Retro DOS v3.0
  4967                                  
  4968                                  ; Character type table for file name scanning
  4969                                  ; Table provides a mapping of characters to validity bits.
  4970                                  ; Four bits are provided for each character.  Values 7Dh and above
  4971                                  ; have all bits set, so that part of the table is chopped off, and
  4972                                  ; the translation routine is responsible for screening these values.
  4973                                  ; The bit values are defined in DOSSYM.INC
  4974                                  
  4975                                  ;	      ; ^A and NUL
  4976                                  ;CharType:
  4977                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4978                                  ;
  4979                                  ;	      ; ^C and ^B
  4980                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4981                                  ;
  4982                                  ;	      ; ^E and ^D
  4983                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4984                                  ;
  4985                                  ;	      ; ^G and ^F
  4986                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4987                                  ;
  4988                                  ;	      ; TAB and BS
  4989                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM+FSPCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4990                                  ;
  4991                                  ;	      ; ^K and ^J
  4992                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4993                                  ;
  4994                                  ;	      ; ^M and ^L
  4995                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4996                                  ;
  4997                                  ;	      ; ^O and ^N
  4998                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  4999                                  ;
  5000                                  ;	      ; ^Q and ^P
  5001                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5002                                  ;
  5003                                  ;	      ; ^S and ^R
  5004                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5005                                  ;
  5006                                  ;	      ; ^U and ^T
  5007                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5008                                  ;
  5009                                  ;	      ; ^W and ^V
  5010                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5011                                  ;
  5012                                  ;	      ; ^Y and ^X
  5013                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5014                                  ;
  5015                                  ;	      ; ESC and ^Z
  5016                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5017                                  ;
  5018                                  ;	      ; ^] and ^;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5020                                  ;
  5021                                  ;	      ; ^_ and ^^
  5022                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5023                                  ;
  5024                                  ;	      ; ! and SPACE
  5025                                  ;	 db   LOW (NOT FCHK+FDELIM+FSPCHK)
  5026                                  ;
  5027                                  ;	      ; # and "
  5028                                  ;	 db   LOW (NOT FFCB+FCHK)
  5029                                  ;
  5030                                  ;	      ; $ - )
  5031                                  ;	 db   3 dup (0FFh)
  5032                                  ;
  5033                                  ;	      ; + and *
  5034                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR 0Fh
  5035                                  ;
  5036                                  ;	      ; - and '
  5037                                  ;	 db   NOT (FFCB+FCHK+FDELIM)
  5038                                  ;
  5039                                  ;	      ; / and .
  5040                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FCHK) AND 0Fh
  5041                                  ;
  5042                                  ;	      ; 0 - 9
  5043                                  ;	 db   5 dup (0FFh)
  5044                                  ;
  5045                                  ;	      ; ; and :
  5046                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
  5047                                  ;
  5048                                  ;	      ; = and <
  5049                                  ;	 db   LOW ((NOT FFCB+FCHK+FDELIM) SHL 4) OR LOW (NOT FFCB+FCHK+FDELIM) AND 0Fh
  5050                                  ;
  5051                                  ;	      ; ? and >
  5052                                  ;	 db   NOT FFCB+FCHK+FDELIM
  5053                                  ;
  5054                                  ;	      ; A - Z
  5055                                  ;	 db   13 dup (0FFh)
  5056                                  ;
  5057                                  ;	      ; \ and [
  5058                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR 0Fh
  5059                                  ;
  5060                                  ;	      ; ^ and ]
  5061                                  ;	 db   LOW ((NOT FFCB+FCHK) SHL 4) OR LOW (NOT FFCB+FCHK) AND 0Fh
  5062                                  ;
  5063                                  ;	      ; _ - {
  5064                                  ;	 db   15 dup (0FFh)
  5065                                  ;
  5066                                  ;	      ; } and |
  5067                                  ;	 db   NOT FFCB+FCHK+FDELIM
  5068                                  
  5069                                  ;CharType_last equ ($ - CharType) * 2	; This is the value of the last
  5070                                  ;					; character in the table
  5071                                  
  5072                                  ; Offset 12CAh of IBMDOS.COM (MSDOS 3.3), 1987
  5073                                  
  5074                                  CharType:
  5075 00001354 F6F6F6F6F6F6F6F6                db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  5076 0000135C F6F0F6F6F6F6F6F6        	db 0F6h,0F0h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  5077 00001364 F6F6F6F6F6F6F6F6        	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  5078 0000136C F6F6F6F6F6F6F6F6        	db 0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h,0F6h
  5079 00001374 F8FFF6FFFFFFFFFF        	db 0F8h,0FFh,0F6h,0FFh,0FFh,0FFh,0FFh,0FFh
  5080 0000137C FFFFFFF4F4FFFEF6        	db 0FFh,0FFh,0FFh,0F4h,0F4h,0FFh,0FEh,0F6h
  5081 00001384 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5082 0000138C FFFFF4F4F4F4F4FF        	db 0FFh,0FFh,0F4h,0F4h,0F4h,0F4h,0F4h,0FFh
  5083 00001394 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5084 0000139C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5085 000013A4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5086 000013AC FFFFFFF6F6F6FFFF        	db 0FFh,0FFh,0FFh,0F6h,0F6h,0F6h,0FFh,0FFh
  5087 000013B4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5088 000013BC FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5089 000013C4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5090 000013CC FFFFFFFFF4FFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0F4h,0FFh,0FFh,0FFh
  5091 000013D4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5092 000013DC FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5093 000013E4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5094 000013EC FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5095 000013F4 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5096 000013FC FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5097 00001404 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5098 0000140C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5099 00001414 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5100 0000141C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5101 00001424 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5102 0000142C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5103 00001434 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5104 0000143C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5105 00001444 FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5106 0000144C FFFFFFFFFFFFFFFF        	db 0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh,0FFh
  5107                                  
  5108                                  ; 02/08/2018 - Retro DOS v3.0
  5109                                  ; DOSTAB.ASM - MSDOS 6.0 - 1991
  5110                                  
  5111                                  ; Offset 13CAh of IBMDOS.COM (MSDOS 3.3), 1987
  5112                                  
  5113 00001454 0000                    exec_init_SP:	dw 0
  5114 00001456 0000                    exec_init_SS:	dw 0
  5115 00001458 0000                    exec_init_IP:	dw 0
  5116 0000145A 0000                    exec_init_CS:	dw 0
  5117                                  
  5118 0000145C 0000                    exec_signature:	dw 0	; must contain 4D5A  (yay zibo!)
  5119 0000145E 0000                    exec_len_mod_512: dw 0	; low 9 bits of length
  5120 00001460 0000                    exec_pages:	dw 0	; number of 512b pages in file
  5121 00001462 0000                    exec_rle_count:	dw 0	; count of reloc entries
  5122 00001464 0000                    exec_par_dir:	dw 0	; number of paragraphs before image
  5123 00001466 0000                    exec_min_BSS:	dw 0	; minimum number of para of BSS
  5124 00001468 0000                    exec_max_BSS:	dw 0	; max number of para of BSS
  5125 0000146A 0000                    exec_SS:	dw 0	; stack of image
  5126 0000146C 0000                    exec_SP:	dw 0	; SP of image
  5127 0000146E 0000                    exec_chksum:	dw 0	; checksum  of file (ignored)
  5128 00001470 0000                    exec_IP:	dw 0	; IP of entry
  5129 00001472 0000                    exec_CS:	dw 0	; CS of entry
  5130 00001474 0000                    exec_rle_table:	dw 0	; byte offset of reloc table
  5131                                  
  5132                                  Exec_Header_Len	EQU $-exec_signature
  5133                                  
  5134                                  ; 02/08/2018 - Retro DOS v3.0
  5135                                  ; SRVCALL.ASM - MSDOS 6.0 - 1991
  5136                                  ;** Server DOS call functions
  5137                                  
  5138 00001476 [7A14]                  SERVERTAB:      dw SERVER_DISP
  5139 00001478 [286A]                  SERVERLEAVE:	dw SERVERRETURN
  5140 0000147A 0B                      SERVER_DISP:	db (SERVER_DISP_END-SERVER_DISP-1)/2
  5141 0000147B [936A]                  		dw SRV_CALL	; 0
  5142 0000147D [296A]                  		dw COMMIT_ALL	; 1
  5143 0000147F [606A]                  		dw CLOSE_NAME	; 2
  5144 00001481 [6C6A]                  		dw CLOSE_UID	; 3
  5145 00001483 [736A]                  		dw CLOSE_UID_PID ; 4
  5146 00001485 [7A6A]                  		dw GET_LIST	; 5
  5147 00001487 [D46A]                  		dw GET_DOS_DATA	; 6
  5148 00001489 [F86A]                  		dw SPOOL_OPER	; 7
  5149 0000148B [F86A]                  		dw SPOOL_OPER	; 8
  5150 0000148D [F86A]                  		dw SPOOL_OPER	; 9
  5151 0000148F [076B]                  		dw _$SetExtendedError ; 10
  5152                                  SERVER_DISP_END:
  5153                                  
  5154                                  ;============================================================================
  5155                                  ; MSCODE.ASM
  5156                                  ;============================================================================
  5157                                  
  5158                                  ; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
  5159                                  ; 03/03/2018
  5160                                  
  5161                                  ;
  5162                                  ; MSCODE.ASM -- MSDOS code
  5163                                  ;
  5164                                  
  5165                                  ;INCLUDE DOSSEG.ASM
  5166                                  ;INCLUDE STDSW.ASM
  5167                                  
  5168                                  ;CODE    SEGMENT BYTE PUBLIC  'CODE'
  5169                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5170                                  
  5171                                  ;.xcref
  5172                                  ;INCLUDE DOSSYM.ASM
  5173                                  ;INCLUDE DEVSYM.ASM
  5174                                  ;.cref
  5175                                  ;.list
  5176                                  
  5177                                  ;IFNDEF  KANJI
  5178                                  ;KANJI   EQU     0       ; FALSE
  5179                                  ;ENDIF
  5180                                  
  5181                                  ;IFNDEF  IBM
  5182                                  ;IBM     EQU     0
  5183                                  ;ENDIF
  5184                                  
  5185                                  ;IFNDEF  HIGHMEM
  5186                                  ;HIGHMEM  EQU     0
  5187                                  ;ENDIF
  5188                                  
  5189                                          ;i_need  USER_SP,WORD
  5190                                          ;i_need  USER_SS,WORD
  5191                                          ;i_need  SAVEDS,WORD
  5192                                          ;i_need  SAVEBX,WORD
  5193                                          ;i_need  INDOS,BYTE
  5194                                          ;i_need  NSP,WORD
  5195                                          ;i_need  NSS,WORD
  5196                                          ;i_need  CURRENTPDB,WORD
  5197                                          ;i_need  AUXSTACK,BYTE
  5198                                          ;i_need  CONSWAP,BYTE
  5199                                          ;i_need  IDLEINT,BYTE
  5200                                          ;i_need  NOSETDIR,BYTE
  5201                                          ;i_need  ERRORMODE,BYTE
  5202                                          ;i_need  IOSTACK,BYTE
  5203                                          ;i_need  WPERR,BYTE
  5204                                          ;i_need  DSKSTACK,BYTE
  5205                                          ;i_need  CNTCFLAG,BYTE
  5206                                          ;i_need  LEAVEADDR,WORD
  5207                                          ;i_need  NULLDEVPT,DWORD
  5208                                  
  5209                                          ;IF NOT IBM
  5210                                          ;i_need  OEM_HANDLER,DWORD
  5211                                          ;ENDIF
  5212                                  
  5213                                          ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR
  5214                                  
  5215                                  ;============================================================================
  5216                                  ; MSDISP.ASM, MSDOS 6.0, 1991
  5217                                  ;============================================================================
  5218                                  ; 11/07/2018 - Retro DOS v3.0
  5219                                  
  5220                                  ; 18/07/2018
  5221                                  
  5222                                  ; The following two routines are dispatched to directly with ints disabled
  5223                                  ; immediately after the int 21h entry.	no DIS state is set.
  5224                                  
  5225                                  ; ---------------------------------------------------------------------------
  5226                                  ; $Set_current_PDB takes BX and sets it to be the current process
  5227                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  5228                                  ;
  5229                                         ;procedure   $SET_CURRENT_PDB,NEAR
  5230                                  _$SET_CURRENT_PDB:
  5231                                          ;ASSUME	DS:NOTHING,SS:NOTHING
  5232 00001491 2E891E[FC02]                    MOV     [CS:CurrentPDB],BX ; 12/03/2018
  5233 00001496 CF                      	iret ; 08/07/2018 - Retro DOS v3.0
  5234                                  ;$SET_CURRENT_PDB    ENDP
  5235                                  
  5236                                  ; ---------------------------------------------------------------------------
  5237                                  ; $get_current_PDB returns in BX the current process
  5238                                  ;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
  5239                                  ;
  5240                                          ;procedure $GET_CURRENT_PDB,NEAR
  5241                                  _$GET_CURRENT_PDB:
  5242                                          ;ASSUME	DS:NOTHING,SS:NOTHING
  5243 00001497 2E8B1E[FC02]            	mov	BX,[CS:CurrentPDB] ; 11/07/2018
  5244 0000149C CF                      	iret ; 08/07/2018 - Retro DOS v3.0
  5245                                  ;$GET_CURRENT_PDB    ENDP
  5246                                  ; ---------------------------------------------------------------------------
  5247                                  
  5248                                  ; 11/07/2018 - Retro DOS v3.0
  5249                                  
  5250                                  ;BREAK <$Set_CTRL_C_Trapping -- En/Disable ^C check in dispatcher>
  5251                                  
  5252                                  _$SET_CTRL_C_TRAPPING:
  5253                                  
  5254                                  ; Inputs:
  5255                                  ;       AL = 0 read ^C status
  5256                                  ;       AL = 1 Set ^C status, DL = 0/1 for ^C off/on
  5257                                  ;	AL = 2 Set ^C status to contents of DL.	Output is old state.
  5258                                  ;	     (MSDISP.ASM,MSDOS 6.0, 1991)
  5259                                  ; Function:
  5260                                  ;       Enable disable ^C checking in dispatcher
  5261                                  ; Outputs:
  5262                                  ;       If AL = 0 then DL = 0/1 for ^C off/on
  5263                                  
  5264                                  	; 08/07/2018 - Retro DOS v3.0
  5265                                  
  5266 0000149D 08C0                            OR      AL,AL
  5267 0000149F 7506                            JNZ     SHORT CTRL_C_set
  5268                                  
  5269                                  	; 11/07/2018
  5270 000014A1 2E8A16[0303]            	mov	dl,[CS:CNTCFLAG]
  5271 000014A6 CF                      	iret
  5272                                  
  5273                                  CTRL_C_set:
  5274                                  	; 08/07/2018
  5275 000014A7 3C02                    	cmp	al,2
  5276 000014A9 7716                    	ja	short bad_val
  5277 000014AB 740B                    	je	short scct_3
  5278                                  
  5279 000014AD 52                      	push    dx
  5280 000014AE 80E201                  	and     dl,1
  5281 000014B1 2E8816[0303]            	mov     [cs:CNTCFLAG],dl
  5282 000014B6 5A                      	pop     dx
  5283 000014B7 CF                      	iret
  5284                                  
  5285                                  scct_3:
  5286 000014B8 80E201                  	and	dl,1
  5287 000014BB 2E8616[0303]                    xchg	dl,[CS:CNTCFLAG]
  5288 000014C0 CF                              iret
  5289                                  
  5290                                  bad_val:
  5291 000014C1 B0FF                    	MOV	AL,0FFH
  5292 000014C3 CF                      	iret
  5293                                  
  5294                                  ; 11/07/2018
  5295                                  
  5296                                  _$SET_PRINTER_FLAG:
  5297                                  	; 08/07/2018 - Retro DOS v3.0
  5298                                  	;mov 	[cs:IOSTACK],al
  5299 000014C4 2EA2[360A]              	mov	[cs:PRINTER_FLAG],al
  5300 000014C8 CF                      	iret
  5301                                  
  5302                                  ; 08/07/2018 - Retro DOS v3.0
  5303                                  ; (MSDISP.ASM, MSDOS 6.0, 1991)
  5304                                  
  5305                                  ; ----------------------------------------------------------------------------
  5306                                  ; BREAK   <System call entry points and dispatcher>
  5307                                  ; ----------------------------------------------------------------------------
  5308                                  ;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  5309                                  
  5310                                          ;procedure   SYSTEM_CALL,NEAR
  5311                                  SYSTEM_CALL:
  5312                                  ;entry	QUIT				; INT 20H entry point
  5313                                  QUIT:
  5314                                  	;MOV	AH,0
  5315 000014C9 30E4                    	xor	ah,ah ; 08/07/2018
  5316 000014CB EB47                    	JMP     SHORT SAVREGS
  5317                                  
  5318                                  ; ---------------------------------------------------------------------------
  5319                                  
  5320                                  ;COMMAND:
  5321                                  ;	;IF	NOT IBM
  5322                                  ;       CMP	AH,SET_OEM_HANDLER
  5323                                  ;       JB      SHORT NOTOEM
  5324                                  ;	; 18/07/2018
  5325                                  ;	je	_$SET_OEM_HANDLER	
  5326                                  ;
  5327                                  ;	; 20/04/2018
  5328                                  ;       ;JMP	_$SET_OEM_HANDLER
  5329                                  ;
  5330                                  ;	; Retro DOS v2.0 - 20/04/2018
  5331                                  ;	CMP	AX, 0FFFFh
  5332                                  ;	;JNE	_$SET_OEM_HANDLER
  5333                                  ;	; 18/07/2018
  5334                                  ;	jne	DO_OEM_FUNC
  5335                                  ;
  5336                                  ;	PUSHA
  5337                                  ;	MOV     SI,RETRODOSMSG
  5338                                  ;       ;CALL	OUTMES
  5339                                  ;wrdosmsg:
  5340                                  ;	mov	ah, 0Eh
  5341                                  ;	mov	bx, 7
  5342                                  ;wrdosmsg_nxt:
  5343                                  ;	cs	lodsb
  5344                                  ;	cmp	al, '$'
  5345                                  ;	je	short wrdosmsg_ok		
  5346                                  ;	int	10h
  5347                                  ;	jmp	short wrdosmsg_nxt
  5348                                  ;wrdosmsg_ok:
  5349                                  ;	POPA
  5350                                  ;	JMP	SHORT BADCALL 
  5351                                  ;	;
  5352                                  ;NOTOEM:
  5353                                  ;	;ENDIF
  5354                                  ;
  5355                                  ;       CMP     AH,MAXCOM
  5356                                  ;       JBE     SHORT SAVREGS
  5357                                  
  5358                                  	; The system call in AH is out of the range that we know how
  5359                                  	; to handle. We arbitrarily set the contents of AL to 0 and
  5360                                  	; IRET. Note that we CANNOT set the carry flag to indicate an
  5361                                  	; error as this may break some programs compatability.
  5362                                  
  5363                                  BADCALL:
  5364                                          ;MOV	AL,0
  5365 000014CD 30C0                    	xor	al,al ; 08/07/2018
  5366                                  ;entry	IRET
  5367                                  _IRET:
  5368 000014CF CF                              IRET
  5369                                  
  5370                                  ; ---------------------------------------------------------------------------
  5371                                  
  5372                                  ;entry	CALL_ENTRY                      ; System call entry point and dispatcher
  5373                                  CALL_ENTRY:
  5374 000014D0 58                              POP     AX                      ; IP from the long call at 5
  5375 000014D1 58                              POP     AX                      ; Segment from the long call at 5
  5376                                          ;POP	WORD [USER_SP]		; IP from the CALL 5
  5377 000014D2 2E8F06[4005]                    POP	WORD [CS:USER_SP] ; 12/03/2018
  5378 000014D7 9C                      	PUSHF                           ; Start re-ordering the stack
  5379 000014D8 FA                              CLI
  5380 000014D9 50                              PUSH    AX                      ; Save segment
  5381                                          ;PUSH	WORD [USER_SP]		; Stack now ordered as if INT had been used
  5382 000014DA 2EFF36[4005]                    PUSH	WORD [CS:USER_SP] ; 12/03/2018
  5383 000014DF 80F924                          CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
  5384 000014E2 77E9                            JA      SHORT BADCALL
  5385 000014E4 88CC                            MOV     AH,CL
  5386                                  	; 08/07/2018
  5387 000014E6 EB2C                    	jmp	short SAVREGS 
  5388                                  
  5389                                  COMMAND:
  5390                                  	; 08/07/2018 - Retro DOS v3.0
  5391                                  
  5392                                  	;IF	NOT IBM
  5393 000014E8 80FCF8                          CMP	AH,SET_OEM_HANDLER
  5394 000014EB 7221                            JB      SHORT NOTOEM
  5395                                  	; 18/07/2018
  5396 000014ED 0F845E01                	je	_$SET_OEM_HANDLER	
  5397                                  
  5398                                  	; 20/04/2018
  5399                                          ;JMP	_$SET_OEM_HANDLER
  5400                                  
  5401                                  	; Retro DOS v2.0 - 20/04/2018
  5402 000014F1 83F8FF                  	CMP	AX,0FFFFh
  5403                                  	;JNE	_$SET_OEM_HANDLER
  5404                                  	; 18/07/2018
  5405 000014F4 0F856201                	jne	DO_OEM_FUNC
  5406                                  
  5407 000014F8 60                      	PUSHA
  5408 000014F9 BE[7E0C]                	MOV     SI,RETRODOSMSG
  5409                                          ;CALL	OUTMES
  5410                                  wrdosmsg:
  5411 000014FC B40E                    	mov	ah,0Eh
  5412 000014FE BB0700                  	mov	bx,7
  5413                                  wrdosmsg_nxt:
  5414 00001501 2EAC                    	cs	lodsb
  5415 00001503 3C24                    	cmp	al,'$'
  5416 00001505 7404                    	je	short wrdosmsg_ok		
  5417 00001507 CD10                    	int	10h
  5418 00001509 EBF6                    	jmp	short wrdosmsg_nxt
  5419                                  wrdosmsg_ok:
  5420 0000150B 61                      	POPA
  5421 0000150C EBBF                    	JMP	SHORT BADCALL 
  5422                                  	;
  5423                                  
  5424                                  NOTOEM:
  5425                                  	;ENDIF
  5426                                  
  5427 0000150E FA                      	cli	; 08/07/2018
  5428                                  
  5429                                  _COMMAND: ; MSDOS 3.3 (IBM)
  5430                                  
  5431 0000150F 80FC68                          CMP     AH,MAXCOM
  5432                                  	;JBE	SHORT SAVREGS
  5433 00001512 77B9                            JA	SHORT BADCALL ; 08/07/2018
  5434                                  
  5435                                  SAVREGS:
  5436                                  	; 10/08/2018
  5437                                  	; 08/07/2018 - Retro DOS v3.0
  5438 00001514 80FC33                  	cmp	ah,33h
  5439 00001517 7484                    	jz	short _$SET_CTRL_C_TRAPPING
  5440 00001519 721C                    	jb	short SaveAllRegs
  5441 0000151B 80FC64                  	cmp	ah,64h
  5442 0000151E 7717                    	ja	short SaveAllRegs
  5443 00001520 74A2                    	jz	short _$SET_PRINTER_FLAG
  5444 00001522 80FC51                  	cmp	ah,51h
  5445 00001525 0F846EFF                	jz	_$GET_CURRENT_PDB
  5446 00001529 80FC62                  	cmp	ah,62h
  5447 0000152C 0F8467FF                	jz	_$GET_CURRENT_PDB
  5448 00001530 80FC50                  	cmp     ah,50h
  5449 00001533 0F845AFF                	jz	_$SET_CURRENT_PDB
  5450                                  SaveAllRegs:
  5451 00001537 E8FC00                          CALL    save_world
  5452 0000153A 2E8C1E[A805]                    MOV	[CS:SAVEDS],DS	; 12/03/2018
  5453 0000153F 2E891E[A605]                    MOV	[CS:SAVEBX],BX	; 12/03/2018
  5454 00001544 8CCB                            MOV     BX,CS
  5455 00001546 8EDB                            MOV     DS,BX
  5456                                  ;ASSUME  DS:DOSGROUP
  5457 00001548 FE06[ED02]                      INC     BYTE [INDOS]		; Flag that we're in the DOS
  5458                                  	
  5459                                  	; 08/07/2018 - Retro DOS v3.0        
  5460 0000154C 31C0                    	xor     ax, ax
  5461 0000154E A3[0803]                	mov     [USER_ID],ax
  5462 00001551 A1[FC02]                	mov     ax,[CurrentPDB]
  5463 00001554 A3[0603]                	mov     [PROC_ID],ax
  5464                                  
  5465 00001557 A1[4005]                	MOV     AX,[USER_SP]
  5466 0000155A A3[AE05]                        MOV     [NSP],AX
  5467 0000155D A1[4205]                        MOV     AX,[USER_SS]
  5468 00001560 A3[AC05]                        MOV     [NSS],AX
  5469 00001563 58                              POP     AX
  5470 00001564 50                              PUSH    AX
  5471 00001565 8926[4005]                      MOV     [USER_SP],SP
  5472 00001569 8C16[4205]                      MOV     [USER_SS],SS
  5473                                  ;
  5474                                  ; save user stack in his area for later returns (possibly from EXEC)
  5475                                  ; Here comes multitasking!!!
  5476                                  ;
  5477 0000156D 8E1E[FC02]                      MOV     DS,[CurrentPDB]
  5478 00001571 89262E00                        MOV     [PDB.USER_STACK],SP
  5479 00001575 8C163000                        MOV     [PDB.USER_STACK+2],SS
  5480                                  	; 18/07/2018
  5481 00001579 2EC606[2F05]00          	mov	byte [CS:FSHARING], 0
  5482                                  
  5483 0000157F 8CCB                            MOV     BX,CS                   ; no holes here.
  5484 00001581 8ED3                            MOV     SS,BX
  5485                                  ;ASSUME  SS:DOSGROUP
  5486                                  
  5487                                  ;entry	REDISP
  5488                                  REDISP:
  5489 00001583 BC[3607]                        MOV     SP,AUXSTACK		; Enough stack for interrupts
  5490 00001586 FB                              STI                             ; Stack OK now
  5491                                  	; 08/07/2018
  5492                                          ;PUSH	CS
  5493                                          ;POP	DS
  5494 00001587 8CCB                    	mov	bx,cs
  5495 00001589 8EDB                    	mov	ds,bx
  5496 0000158B 30FF                            XOR     BH,BH
  5497 0000158D 883E[2103]                      MOV     [CONSWAP],BH
  5498 00001591 C606[2203]01                    MOV     BYTE [IDLEINT],1
  5499 00001596 883E[1603]                      MOV     BYTE [NoSetDir],bh ; 0	; set directories on search
  5500 0000159A 883E[1403]                      mov	byte [FAILERR],bh ; 0	
  5501 0000159E 88E3                    	MOV     BL,AH
  5502 000015A0 D1E3                            SHL     BX,1
  5503 000015A2 FC                              CLD
  5504 000015A3 08E4                            OR      AH,AH
  5505 000015A5 7416                            JZ      SHORT DSKROUT		; ABORT
  5506                                  
  5507                                          ;CMP	AH,12
  5508                                          ;JBE	SHORT IOROUT		; Character I/O
  5509                                          ;CMP	AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
  5510                                          ;JZ	SHORT IOROUT
  5511                                          ;CMP	AH,SET_CURRENT_PDB
  5512                                          ;JNZ	SHORT DSKROUT
  5513                                  
  5514                                  	; 10/08/2018
  5515 000015A7 80FC59                  	cmp     ah,GETEXTENDEDERROR ; 59h
  5516 000015AA 743D                    	jz      short DISPCALL
  5517 000015AC 80FC0C                  	cmp     ah,STD_CON_INPUT_FLUSH ; 0Ch
  5518 000015AF 770C                    	ja      short DSKROUT
  5519                                  
  5520                                  IOROUT:
  5521 000015B1 803E[EC02]00                    CMP     BYTE [ERRORMODE],0
  5522 000015B6 7531                            JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
  5523 000015B8 BC[360A]                        MOV     SP,IOSTACK
  5524 000015BB EB2C                            JMP     SHORT DISPCALL
  5525                                  
  5526                                  DSKROUT:
  5527                                  	; 08/07/2018 - Retro DOS v3.0
  5528 000015BD A3[0403]                        mov     [USER_IN_AX],ax
  5529 000015C0 C606[EF02]01            	mov     byte [EXTERR_LOCUS],1	; errLOC_Unk  (Default)
  5530                                  
  5531 000015C5 C606[EC02]00                    MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
  5532 000015CA C606[EE02]FF                    MOV     BYTE [WPERR],-1		; error mode, so good place to
  5533                                                                          ; make sure flags are reset
  5534 000015CF 50                      	push    ax
  5535 000015D0 B482                    	mov     ah,82h
  5536 000015D2 CD2A                    	int     2Ah 		; Microsoft Networks 
  5537                                  				; END DOS CRITICAL SECTIONS 0 THROUGH 7
  5538 000015D4 58                      	pop     ax
  5539 000015D5 C606[2203]00            	mov     byte [IDLEINT],0
  5540                                  
  5541 000015DA BC[B608]                        MOV     SP,DSKSTACK
  5542 000015DD F606[0303]FF                    TEST    BYTE [CNTCFLAG],-1
  5543 000015E2 7405                            JZ      SHORT DISPCALL
  5544 000015E4 50                              PUSH    AX
  5545                                          ;invoke	DSKSTATCHK
  5546 000015E5 E85043                          CALL	DSKSTATCHK
  5547 000015E8 58                      	POP     AX
  5548                                  DISPCALL:
  5549                                  	; 08/07/2018 -Retro DOS v3.0
  5550                                  	;;;PUSH	WORD [LEAVEADDR] ; (***)
  5551                                          ;;;PUSH	WORD [CS:BX+DISPATCH]
  5552                                          ;;;;PUSH WORD [BX+DISPATCH]
  5553                                  
  5554                                  	; 11/07/2018	
  5555                                  	;mov	bx,[CS:BX+DISPATCH]
  5556 000015E9 8B9F[360E]               	mov	bx,[bx+DISPATCH] 
  5557                                  
  5558                                  	;;;MOV	BX,[SAVEBX]
  5559 000015ED 871E[A605]              	xchg    bx,[SAVEBX]        
  5560                                  
  5561 000015F1 8E1E[A805]              	MOV     DS,[SAVEDS]
  5562                                  ;ASSUME	DS:NOTHING
  5563                                          ;return
  5564                                  ;;;	RETN	
  5565                                  
  5566 000015F5 36FF16[A605]            	call	word [SS:SAVEBX]
  5567                                  
  5568                                  ;entry LEAVE
  5569                                  ;;;_LEAVE:				; Exit from a system call
  5570                                  LeaveDOS: ; 18/07/2018 
  5571                                  ;ASSUME	SS:NOTHING			; User routines may misbehave
  5572 000015FA FA                      	CLI
  5573                                          ; 12/03/2018
  5574 000015FB 2EFE0E[ED02]            	DEC     BYTE [CS:INDOS]
  5575 00001600 2E8B26[4005]                    MOV     SP,[CS:USER_SP]
  5576 00001605 2E8E16[4205]                    MOV     SS,[CS:USER_SS]
  5577 0000160A 89E5                    	MOV     BP,SP
  5578                                  	;MOV	[BP.user_AX],AL	
  5579                                          ;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
  5580 0000160C 884600                          MOV     [BP],AL
  5581 0000160F 2EA1[AE05]              	MOV     AX,[CS:NSP]
  5582 00001613 2EA3[4005]                      MOV     [CS:USER_SP],AX
  5583 00001617 2EA1[AC05]                      MOV     AX,[CS:NSS]
  5584 0000161B 2EA3[4205]                      MOV     [CS:USER_SS],AX
  5585 0000161F E80100                  	CALL    restore_world
  5586                                  
  5587 00001622 CF                              IRET
  5588                                  
  5589                                  ;SYSTEM_CALL ENDP
  5590                                  
  5591                                  ;
  5592                                  ; restore_world restores all registers ('cept SS:SP, CS:IP, flags) from
  5593                                  ; the stack prior to giving the user control
  5594                                  ;
  5595                                  
  5596                                  ; 11/07/2018 - Retro DOS v3.0
  5597                                          ;ASSUME  DS:NOTHING,ES:NOTHING
  5598                                  ;;restore_tmp DW  ?
  5599                                  ;restore_tmp: 
  5600                                  ;	dw	0
  5601                                          ;procedure restore_world,NEAR
  5602                                  restore_world:
  5603 00001623 2E8F06[AA05]                    POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
  5604 00001628 58                              POP     AX              ; PUSH    ES
  5605 00001629 5B                              POP     BX              ; PUSH    DS
  5606 0000162A 59                              POP     CX              ; PUSH    BP
  5607 0000162B 5A                              POP     DX              ; PUSH    DI
  5608 0000162C 5E                              POP     SI              ; PUSH    SI
  5609 0000162D 5F                              POP     DI              ; PUSH    DX
  5610 0000162E 5D                              POP     BP              ; PUSH    CX
  5611 0000162F 1F                              POP     DS              ; PUSH    BX
  5612 00001630 07                              POP     ES              ; PUSH    AX
  5613                                  	; 07/07/2018 - Retro DOS v3.0
  5614 00001631 2EFF26[AA05]                   	jmp	word [CS:RESTORE_TMP]
  5615                                  
  5616                                  ;restore_world	ENDP
  5617                                  
  5618                                  ;
  5619                                  ; save_world saves complete registers on the stack
  5620                                  ;
  5621                                          ;procedure save_world,NEAR
  5622                                  save_world:
  5623 00001636 2E8F06[AA05]                    POP	WORD [CS:RESTORE_TMP] ; 12/03/2018
  5624 0000163B 06                              PUSH    ES
  5625 0000163C 1E                              PUSH    DS
  5626 0000163D 55                              PUSH    BP
  5627 0000163E 57                              PUSH    DI
  5628 0000163F 56                              PUSH    SI
  5629 00001640 52                              PUSH    DX
  5630 00001641 51                              PUSH    CX
  5631 00001642 53                              PUSH    BX
  5632 00001643 50                              PUSH    AX
  5633                                  	; 07/07/2018 - Retro DOS v3.0
  5634 00001644 2EFF26[AA05]                   	jmp	word [CS:RESTORE_TMP]
  5635                                  
  5636                                  ;save_world	ENDP
  5637                                  
  5638                                  ;
  5639                                  ; get_user_stack returns the user's stack (and hence registers) in DS:SI
  5640                                  ;
  5641                                          ;procedure get_user_stack,NEAR
  5642                                  Get_User_Stack:
  5643                                          ;LDS	SI,DWORD PTR [USER_SP]
  5644                                          ;LDS	SI,[USER_SP]
  5645 00001649 2EC536[4005]                    LDS	SI,[CS:USER_SP] ; 12/03/2018
  5646                                  	;return
  5647 0000164E C3                      	RETN
  5648                                  
  5649                                  ;get_user_stack  ENDP
  5650                                  
  5651                                  ; ---------------------------------------------------------------------------
  5652                                  ;
  5653                                  ; Set_OEM_Handler -- Set OEM sys call address and handle OEM Calls
  5654                                  ; Inputs:
  5655                                  ;	User registers, User Stack, INTS disabled
  5656                                  ;	If CALL F8, DS:DX is new handler address
  5657                                  ; Function:
  5658                                  ;	Process OEM INT 21 extensions
  5659                                  ; Outputs:
  5660                                  ;	Jumps to OEM_HANDLER if appropriate
  5661                                  ;
  5662                                  ; ---------------------------------------------------------------------------
  5663                                  
  5664                                  ;IF	NOT IBM
  5665                                  
  5666                                  _$SET_OEM_HANDLER:
  5667                                  	; 18/07/2018
  5668                                  
  5669                                  	;JNE	short DO_OEM_FUNC	; If above F8 try to jump to handler
  5670 0000164F 2E8916[1400]            	MOV     [CS:OEM_HANDLER],DX	; Set Handler
  5671 00001654 2E8C1E[1600]            	MOV     [CS:OEM_HANDLER+2],DS
  5672 00001659 CF                      	IRET                            ; Quick return, Have altered no registers
  5673                                  
  5674                                  DO_OEM_FUNC:
  5675 0000165A 2E833E[1400]FF          	CMP     WORD [CS:OEM_HANDLER],-1
  5676 00001660 7503                    	JNZ     short OEM_JMP
  5677 00001662 E968FE                  	JMP     BADCALL                 ; Handler not initialized
  5678                                  
  5679                                  OEM_JMP:
  5680 00001665 2EFF2E[1400]            	JMP     FAR [CS:OEM_HANDLER]
  5681                                  
  5682                                  ;       ENDIF
  5683                                  
  5684                                  ;============================================================================
  5685                                  ; DOSTAB.ASM - MSDOS 6.0 - 1991
  5686                                  ;============================================================================
  5687                                  ; 11/07/2018 - Retro DOS v3.0
  5688                                  
  5689                                  ; the nul device driver used to be part of the code.  However, since the 
  5690                                  ; header is in the data, and the entry points are only given as an offset,
  5691                                  ; the strategy and interrupt entry points must also be in the data now.
  5692                                  ;
  5693                                  
  5694                                  ;procedure	snuldev,far
  5695                                  SNULDEV:
  5696                                  ;assume ds:nothing,es:nothing,ss:nothing, cs:dosdata
  5697                                  ; Offset 1599h in IBMDOS.COM (MSDOS 3.3), 1987
  5698                                  	;or	word [ES:BX+3],0100h
  5699 0000166A 26814F030001             	OR	word [ES:BX+SRHEAD.REQSTAT],STDON ; set done bit
  5700                                  ;entry inuldev
  5701                                  INULDEV:
  5702 00001670 CB                      	retf				; must not be a return!
  5703                                  ;endproc snuldev
  5704                                  
  5705                                  ;============================================================================
  5706                                  ; MSCODE.ASM - MSDOS 6.0 - 1991
  5707                                  ;============================================================================
  5708                                  ; 18/07/2018 - Retro DOS v3.0
  5709                                  ; 15/05/2019 - Retro DOS v4.0
  5710                                  
  5711                                  ; 23/07/2019 - Retro DOS v3.2
  5712                                  
  5713                                  ;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>
  5714                                  
  5715                                  ;   AbsSetup - setup for abs disk functions
  5716                                  ;----------------------------------------------------------------------------
  5717                                  
  5718                                  AbsSetup:
  5719 00001671 36FE06[ED02]            	INC	byte [SS:INDOS]		; SS override
  5720 00001676 FB                      	STI
  5721 00001677 FC                      	CLD
  5722 00001678 1E                      	PUSH	DS
  5723 00001679 16                      	push	ss
  5724 0000167A 1F                      	pop	ds
  5725 0000167B E8DE00                  	CALL	GETBP
  5726 0000167E 7206                    	JC	short errdriv 		; PM. error drive ;AN000;
  5727 00001680 26C7461FFFFF            	MOV	WORD [ES:BP+DPB.FREE_CNT],-1 ; do not trust user at all.
  5728                                  errdriv:
  5729 00001686 1F                      	POP	DS
  5730 00001687 7301                    	jnc	short AbsSetup2
  5731                                  AbsSetup_retn:
  5732 00001689 C3                      	retn
  5733                                  
  5734                                  AbsSetup2:
  5735                                  	; 10/07/2019 - Retro DOS v3.1
  5736                                  	; 23/07/2019 - Retro DOS v3.2
  5737                                  	; MSDOS 6.0
  5738                                  	;				; SS override
  5739 0000168A 36C706[B005]0000        	MOV	word [SS:HIGH_SECTOR],0 ;>32mb	from API		;AN000;
  5740 00001691 E82700                  	CALL	RW32_CONVERT		;>32mb convert 32bit format to 16bit ;AN000;
  5741 00001694 72F3                    	jc	short AbsSetup_retn
  5742                                  	;call	SET_RQ_SC_PARMS 	;LB. set up SC parms		;AN000;
  5743                                  
  5744                                  	; MSDOS 3.3 (& MSDOS 6.0)
  5745 00001696 1E                      	PUSH	DS
  5746 00001697 56                      	PUSH	SI
  5747 00001698 50                      	PUSH	AX
  5748                                  
  5749 00001699 16                      	push	ss
  5750 0000169A 1F                      	pop	ds
  5751                                  	
  5752 0000169B BE[8203]                	MOV	SI,OPENBUF
  5753 0000169E 8804                    	MOV	[SI],AL
  5754 000016A0 800441                  	ADD	BYTE [SI],"A"
  5755 000016A3 C744013A00              	MOV	WORD [SI+1],003Ah ; ":",0
  5756 000016A8 B80003                  	MOV	AX,0300h
  5757 000016AB F8                      	CLC
  5758 000016AC CD2A                    	INT	int_IBM ; int 2Ah	; Will set carry if shared
  5759 000016AE 58                      	POP	AX
  5760 000016AF 5E                      	POP	SI
  5761 000016B0 1F                      	POP	DS
  5762 000016B1 73D6                    	jnc	short AbsSetup_retn
  5763                                  
  5764                                  	;mov	word [ss:EXTERR],32h
  5765 000016B3 36C706[F002]3200        	MOV	word [ss:EXTERR],error_not_supported
  5766 000016BA C3                      	retn
  5767                                  
  5768                                  ; 15/05/2019 - Retro DOS v4.0
  5769                                  
  5770                                  ;------------------------------------------------------------------------
  5771                                  ;
  5772                                  ; Procedure Name : RW32_CONVERT
  5773                                  ;
  5774                                  ;Input: same as ABSDRD and ABSDWRT
  5775                                  ;	 ES:BP -> DPB
  5776                                  ;Functions: convert 32bit absolute RW input parms to 16bit input parms
  5777                                  ;Output: carry set when CX=-1 and drive is less then 32mb
  5778                                  ;	 carry clear, parms ok
  5779                                  ;
  5780                                  ;------------------------------------------------------------------------
  5781                                  
  5782                                  ; 23/07/2019 - Retro DOS v3.2
  5783                                  
  5784                                  RW32_CONVERT:
  5785 000016BB 83F9FF                  	CMP	CX,-1			   ;>32mb  new format ?	;AN000;
  5786 000016BE 7424                    	JZ	short new32format	   ;>32mb  yes		;AN000;
  5787 000016C0 50                      	PUSH	AX			   ;>32mb  save ax	;AN000;
  5788 000016C1 52                      	PUSH	DX			   ;>32mb  save dx	;AN000;
  5789 000016C2 268B460D                	MOV	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  get max cluster # ;AN000;
  5790 000016C6 268A5604                	MOV	DL,[ES:BP+DPB.CLUSTER_MASK] ;>32mb		;AN000;
  5791 000016CA 80FAFE                  	CMP	DL,0FEh 		;>32mb  removable ?	;AN000;
  5792 000016CD 7408                    	JZ	short letold		;>32mb  yes		;AN000;
  5793 000016CF FEC2                    	INC	DL			;>32mb			;AN000;
  5794 000016D1 30F6                    	XOR	DH,DH			;>32mb  dx = sector/cluster ;AN000;
  5795 000016D3 F7E2                    	MUL	DX			;>32mb  dx:ax= max sector # ;AN000;
  5796 000016D5 09D2                    	OR	DX,DX			;>32mb  > 32mb ?	;AN000;
  5797                                  letold:
  5798 000016D7 5A                      	POP	DX			;>32mb  restore dx	;AN000;
  5799 000016D8 58                      	POP	AX			;>32mb  restore ax 	;AN000;
  5800 000016D9 7419                    	JZ	short old_style		;>32mb  no 		;AN000;
  5801                                  
  5802                                  	;push	ds
  5803                                  	;;getdseg <ds>
  5804                                  	;mov	ds,[cs:DosDSeg]
  5805                                  	;mov	word [AbsDskErr],207h	;>32mb  bad address mark
  5806                                  	;pop	ds
  5807                                  
  5808                                  	; 23/07/2019
  5809 000016DB 2EC706[CD0F]0702        	mov	word [cs:AbsDskErr],207h ;>32mb  bad address mark
  5810                                  
  5811 000016E2 F9                      	STC				;>32mb			;AN000;
  5812 000016E3 C3                      	retn				;>32mb			;AN000;
  5813                                  
  5814                                  new32format:
  5815                                  	;mov	dx,[bx+2]
  5816 000016E4 8B5702                  	MOV	DX,[BX+ABS_32RW.SECTOR_RBA+2] ;>32mb		;AN000;
  5817                                  
  5818                                  	;push	ds			; set up ds to DOSDATA
  5819                                  	;;getdseg <ds>
  5820                                  	;mov	ds,[cs:DosDSeg]
  5821                                  	;MOV	[HIGH_SECTOR],DX	;>32mb			;AN000;
  5822                                  	;pop	ds
  5823                                  
  5824                                  	; 23/07/2019
  5825 000016E7 2E8916[B005]            	mov	[cs:HIGH_SECTOR],dx
  5826                                  
  5827 000016EC 8B17                    	mov	dx,[bx]
  5828                                  	;MOV	DX,[BX+ABS_32RW.SECTOR_RBA]  ;>32mb		;AN000;
  5829                                  	;mov	cx,[bx+4]
  5830 000016EE 8B4F04                  	MOV	CX,[BX+ABS_32RW.ABS_RW_COUNT] ;>32mb		;AN000;
  5831                                  	;lds	bx,[bx+6]
  5832 000016F1 C55F06                  	LDS	BX,[BX+ABS_32RW.BUFFER_ADDR] ;>32mb		;AN000;
  5833                                  old_style:				;>32mb			;AN000;
  5834 000016F4 F8                      	CLC				;>32mb			;AN000;
  5835 000016F5 C3                      	retn				;>32mb			;AN000;
  5836                                  
  5837                                  ;---------------------------------------------------------------------------
  5838                                  ;
  5839                                  ; Procedure Name : ABSDRD
  5840                                  ;
  5841                                  ; Interrupt 25 handler. Performs absolute disk read.
  5842                                  ; Inputs:	AL - 0-based drive number
  5843                                  ;		DS:BX point to destination buffer
  5844                                  ;		CX number of logical sectors to read
  5845                                  ;		DX starting logical sector number (0-based)
  5846                                  ; Outputs:	Original flags still on stack
  5847                                  ;		Carry set
  5848                                  ;		    AH error from BIOS
  5849                                  ;		    AL same as low byte of DI from INT 24
  5850                                  ;
  5851                                  ;---------------------------------------------------------------------------
  5852                                          ;procedure   ABSDRD,FAR
  5853                                  ABSDRD:
  5854                                  	; 23/07/2019 - Retro DOS v3.2
  5855                                  	; 15/07/2018
  5856                                  ;ASSUME DS:NOTHING,ES:NOTHING,SS:NOTHING
  5857 000016F6 FA                              CLI
  5858                                  	; 15/03/2018
  5859 000016F7 2E8C16[4205]                    MOV	[CS:USER_SS],SS
  5860 000016FC 2E8926[4005]                    MOV	[CS:USER_SP],SP        
  5861 00001701 0E                      	PUSH    CS
  5862 00001702 17                              POP     SS
  5863                                  ;ASSUME SS:DOSGROUP
  5864 00001703 BC[B608]                        MOV	SP,DSKSTACK
  5865                                  
  5866                                  	;; MSDOS 2.11
  5867                                  
  5868                                          ;;;INC	BYTE [INDOS]
  5869                                          ;;INC	BYTE [SS:INDOS]
  5870                                  	;;STI
  5871                                          ;;CLD
  5872                                          ;;PUSH	ES
  5873                                          ;;PUSH	DS
  5874                                          ;;PUSH	SS
  5875                                          ;;POP	DS
  5876                                  ;;;ASSUME DS:DOSGROUP
  5877                                          ;;;invoke GETBP
  5878                                  	;;CALL	GETBP
  5879                                          ;;POP	DS
  5880                                  ;;;ASSUME DS:NOTHING
  5881                                  
  5882                                  	; 15/07/2018 - Retro DOS v3.0
  5883                                  	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
  5884 00001706 06                              PUSH    ES ; **
  5885 00001707 E867FF                  	call    AbsSetup
  5886                                  	;	
  5887 0000170A 721E                            JC      SHORT ILEAVE
  5888                                          ;invoke	DSKREAD
  5889 0000170C E89B2B                  	CALL	DSKREAD
  5890                                  TLEAVE:
  5891 0000170F 7419                            JZ      SHORT ILEAVE
  5892                                  
  5893                                  	; 15/07/2018 - Retro DOS v3.0
  5894                                          ;IF	IBM
  5895                                  ; Translate the error code to ancient 1.1 codes
  5896 00001711 06                              PUSH    ES ; *
  5897 00001712 0E                              PUSH    CS
  5898 00001713 07                              POP     ES
  5899 00001714 30E4                            XOR     AH,AH			; Nul error code
  5900                                  	;mov	cx,6
  5901 00001716 B90600                          MOV     CX,NUMERR		; Number of possible error conditions
  5902 00001719 BF[1310]                        MOV     DI,ERRIN		; Point to error conditions
  5903 0000171C F2AE                            REPNE   SCASB
  5904 0000171E 7504                            JNZ     SHORT LEAVECODE		; Not found
  5905                                  	;mov	ah,[ES:DI+5]
  5906 00001720 268A6505                        MOV     AH,[ES:DI+NUMERR-1]	; Get translation
  5907                                  LEAVECODE:
  5908 00001724 07                              POP     ES ; *
  5909                                  	; 15/05/2019 - Retro DOS v4.0
  5910 00001725 2EA3[CD0F]              	mov	[cs:AbsDskErr],ax
  5911                                          ;ENDIF
  5912                                  
  5913 00001729 F9                              STC
  5914                                  ILEAVE:
  5915 0000172A 07                              POP     ES ; **
  5916 0000172B FA                              CLI
  5917                                  	; 23/07/2019
  5918 0000172C 2EA1[CD0F]              	mov     ax,[cs:AbsDskErr]	; restore error
  5919                                          ; 15/03/2018
  5920 00001730 2EFE0E[ED02]            	DEC	BYTE [CS:INDOS]
  5921                                  	; 15/08/2018
  5922 00001735 2E8E16[4205]                    MOV	SS,[CS:USER_SS]
  5923 0000173A 2E8B26[4005]            	MOV	SP,[CS:USER_SP]
  5924                                  ;ASSUME SS:NOTHING
  5925 0000173F FB                              STI
  5926                                          ;return
  5927 00001740 CB                      	RETF   ; ! FAR return !
  5928                                  
  5929                                  ;ABSDRD	ENDP
  5930                                  
  5931                                  ;---------------------------------------------------------------------------
  5932                                  ;
  5933                                  ; Procedure Name : ABSDWRT
  5934                                  ;
  5935                                  ; Interrupt 26 handler. Performs absolute disk write.
  5936                                  ; Inputs:	AL - 0-based drive number
  5937                                  ;		DS:BX point to source buffer
  5938                                  ;		CX number of logical sectors to write
  5939                                  ;		DX starting logical sector number (0-based)
  5940                                  ; Outputs:	Original flags still on stack
  5941                                  ;		Carry set
  5942                                  ;		    AH error from BIOS
  5943                                  ;		    AL same as low byte of DI from INT 24
  5944                                  ;
  5945                                  ;---------------------------------------------------------------------------
  5946                                          ;procedure   ABSDWRT,FAR
  5947                                  ABSDWRT:
  5948                                  		; 23/07/2019 - Retro DOS v3.2
  5949                                  	; 15/07/2018
  5950                                  ;ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING
  5951                                  
  5952 00001741 FA                              CLI
  5953                                  	; 15/08/2018
  5954                                  	; 15/03/2018
  5955 00001742 2E8C16[4205]            	MOV	[CS:USER_SS],SS
  5956 00001747 2E8926[4005]                    MOV	[CS:USER_SP],SP
  5957 0000174C 0E                              PUSH    CS
  5958 0000174D 17                              POP     SS
  5959                                  ;ASSUME	SS:DOSGROUP
  5960                                          ;MOV	SP,OFFSET DOSGROUP:DSKSTACK
  5961 0000174E BC[B608]                        MOV	SP,DSKSTACK
  5962                                  
  5963                                  	;; MSDOS 2.11
  5964                                  
  5965                                          ;;;INC	BYTE [INDOS]
  5966                                          ;;INC	BYTE [SS:INDOS]
  5967                                  	;;STI
  5968                                          ;;CLD
  5969                                          ;;PUSH	ES
  5970                                          ;;PUSH	DS
  5971                                          ;;PUSH	SS
  5972                                          ;;POP	DS
  5973                                  ;;;ASSUME DS:DOSGROUP
  5974                                          ;;;invoke GETBP
  5975                                  	;;CALL	GETBP
  5976                                          ;;POP	DS
  5977                                  ;;;ASSUME DS:NOTHING
  5978                                  
  5979                                  	; 15/07/2018 - Retro DOS v3.0
  5980                                  	; MSDOS 3.3 (& MSDOS 6.0, MSCODE.ASM, 1991)
  5981 00001751 06                              PUSH    ES ; **
  5982 00001752 E81CFF                  	call    AbsSetup
  5983                                  	;
  5984 00001755 72D3                            JC      SHORT ILEAVE
  5985                                          ;invoke DSKWRITE
  5986 00001757 E8792B                          CALL	DSKWRITE
  5987 0000175A EBB3                    	JMP     SHORT TLEAVE
  5988                                  
  5989                                  ;ABSDWRT ENDP
  5990                                  
  5991                                  ;----------------------------------------------------------------------------
  5992                                  ;
  5993                                  ; Procedure Name : GETBP
  5994                                  ;
  5995                                  ; Inputs:
  5996                                  ;	AL = Logical unit number (A = 0)
  5997                                  ; Function:
  5998                                  ;	Find Drive Parameter Block
  5999                                  ; Outputs:
  6000                                  ;	ES:BP points to DPB
  6001                                  ;	[THISDPB] = ES:BP
  6002                                  ;	Carry set if unit number bad or unit is a NET device.
  6003                                  ;		Later case sets extended error error_I24_not_supported
  6004                                  ; No other registers altered
  6005                                  ;
  6006                                  ;----------------------------------------------------------------------------
  6007                                  
  6008                                  GETBP:
  6009                                  	; 23/07/2019 - Retro DOS v3.2
  6010                                  	; 15/05/2019 - Retro DOS v4.0
  6011                                  	; 11/07/2018 - Retro DOS v3.0
  6012 0000175C 50                      	PUSH	AX
  6013 0000175D 0401                    	ADD	AL, 1		; No increment; need carry flag
  6014 0000175F 7216                    	JC	SHORT SKIPGET
  6015 00001761 E85355                  	CALL	GETTHISDRV
  6016                                  	; MSDOS 6.0
  6017 00001764 7311                    	JNC	SHORT SKIPGET		;PM. good drive		;AN000;
  6018 00001766 30E4                    	XOR	AH,AH			;DCR. ax= error code 	;AN000;
  6019 00001768 83F81A                  	CMP	AX,error_not_DOS_disk	;DCR. is unknown media ? ;AN000;
  6020 0000176B 740A                    	JZ	SHORT SKIPGET 		;DCR. yes, let it go 	;AN000;
  6021 0000176D F9                      	STC				;DCR.			;AN000;
  6022 0000176E A3[F002]                	MOV	[EXTERR],AX	;PM. invalid drive or Non DOS drive ;AN000;
  6023 00001771 C706[CD0F]0102          	MOV	WORD [AbsDskErr],201h
  6024                                  SKIPGET:
  6025 00001777 58                      	POP	AX
  6026 00001778 7213                    	JC	SHORT GETBP_RETN
  6027                                  
  6028 0000177A C42E[5E05]              	LES	BP,[THISCDS]
  6029                                  	;TEST	WORD [ES:BP+43h],8000H
  6030 0000177E 26F746430080            	TEST	WORD [ES:BP+curdir.flags],curdir_isnet ; Clears carry
  6031 00001784 7408                    	JZ	SHORT GETBP_CDS
  6032 00001786 C706[F002]3200          	MOV	WORD [EXTERR],error_not_supported  ; 32h
  6033 0000178C F9                      	STC
  6034                                  GETBP_RETN:
  6035 0000178D C3                      	RETN
  6036                                  
  6037                                  GETBP_CDS:
  6038                                  	;LES	BP,[ES:BP+45h]
  6039 0000178E 26C46E45                	LES	BP,[ES:BP+curdir.devptr]
  6040                                  GOTDPB:
  6041                                  	; Load THISDPB from ES:BP
  6042 00001792 892E[4605]              	MOV	[THISDPB],BP
  6043 00001796 8C06[4805]              	MOV	[THISDPB+2],ES
  6044 0000179A C3                      	RETN
  6045                                  
  6046                                  ;BREAK <SYS_RET_OK SYS_RET_ERR CAL_LK ETAB_LK set system call returns>
  6047                                  
  6048                                  ;----------------------------------------------------------------------------
  6049                                  ;
  6050                                  ; Procedure Name : SYS_RETURN
  6051                                  ;
  6052                                  ; These are the general system call exit mechanisms. All internal system
  6053                                  ; calls will transfer (jump) to one of these at the end. Their sole purpose
  6054                                  ; is to set the user's flags and set his AX register for return.
  6055                                  ;
  6056                                  ;----------------------------------------------------------------------------
  6057                                  
  6058                                          ;procedure   SYS_RETURN,NEAR
  6059                                  SYS_RETURN:        
  6060                                          ;entry	SYS_RET_OK
  6061                                  SYS_RET_OK:   
  6062                                  	; 18/07/2018
  6063                                  	; Offset 1666h in IBMDOS.COM (MSDOS 3.3), 1987
  6064                                  	; 23/07/2019 - Retro DOS v3.2
  6065                                  	;call	FETCHI_CHECK ; MSDOS 3.3 ! IBMDOS feature ! 
  6066                                  	     
  6067 0000179B E8ABFE                  	call    Get_User_Stack
  6068                                  		; turn off user's carry flag
  6069                                  SYS_RET_OK_clc: ; 26/07/2019 
  6070                                          ;and	word [SI+16h],0FFFEh 
  6071 0000179E 836416FE                        and	word [SI+user_env.user_F],~f_Carry 
  6072 000017A2 EB10                            JMP     SHORT DO_RET
  6073                                  
  6074                                          ;entry	SYS_RET_ERR
  6075                                  SYS_RET_ERR:        
  6076 000017A4 30E4                    	XOR     AH,AH 		; hack to allow for smaller error rets
  6077 000017A6 E86900                  	call	ETAB_LK 	; Make sure code is OK, EXTERR gets set
  6078 000017A9 E81A00                  	CALL	ErrorMap
  6079                                  
  6080                                  	;entry	From_GetSet
  6081                                  From_GetSet:
  6082 000017AC E89AFE                          call    Get_User_Stack
  6083                                  		; signal carry to user
  6084                                  	;or	word [SI+16h],1
  6085 000017AF 834C1601                	OR	word [SI+user_env.user_F],f_Carry
  6086 000017B3 F9                      	STC			; also, signal internal error
  6087                                  DO_RET:
  6088                                          ;MOV	[SI+user_env.user_AX],AX ; Really only sets AH
  6089 000017B4 8904                    	MOV	[SI],AX
  6090 000017B6 C3                      	RETN
  6091                                  
  6092                                  	;entry	FCB_RET_OK
  6093                                  FCB_RET_OK:
  6094                                  	;entry	NO_OP		; obsolete system calls dispatch to here
  6095                                  NO_OP:
  6096 000017B7 30C0                    	XOR	AL,AL
  6097 000017B9 C3                      	retn
  6098                                  
  6099                                  	;entry	FCB_RET_ERR
  6100                                  FCB_RET_ERR:
  6101 000017BA 30E4                    	XOR	AH,AH
  6102 000017BC 36A3[F002]              	mov	[ss:EXTERR],AX
  6103 000017C0 E80300                  	CALL	ErrorMap
  6104 000017C3 B0FF                    	MOV	AL,-1
  6105 000017C5 C3                      	retn
  6106                                  
  6107                                  	;entry	ErrorMap
  6108                                  ErrorMap:
  6109 000017C6 56                      	PUSH	SI
  6110                                  				; ERR_TABLE_21 is now in DOSDATA
  6111 000017C7 BE[5F0D]                	MOV	SI,ERR_TABLE_21
  6112                                  				; SS override for FAILERR and EXTERR
  6113 000017CA 36803E[1403]00          	CMP	byte [SS:FAILERR],0 ; Check for SPECIAL case.
  6114 000017D0 7407                    	JZ	short EXTENDED_NORMAL ; All is OK.
  6115                                  		 ; Ooops, this is the REAL reason
  6116                                  	;mov	word [SS:EXTERR],53h
  6117 000017D2 36C706[F002]5300        	MOV	word [SS:EXTERR],error_FAIL_I24
  6118                                  EXTENDED_NORMAL:
  6119 000017D9 E80200                  	call	CAL_LK		; Set CLASS,ACTION,LOCUS for EXTERR
  6120 000017DC 5E                      	POP	SI
  6121 000017DD C3                      	retn
  6122                                  
  6123                                  	;EndProc SYS_RETURN
  6124                                  
  6125                                  ;---------------------------------------------------------------------------
  6126                                  ;
  6127                                  ; Procedure Name : CAL_LK
  6128                                  ;
  6129                                  ; Inputs:
  6130                                  ;	SI is OFFSET in DOSDATA of CLASS,ACTION,LOCUS Table to use
  6131                                  ;		(DS NEED not be DOSDATA)
  6132                                  ;	[EXTERR] is set with error
  6133                                  ; Function:
  6134                                  ;	Look up and set CLASS ACTION and LOCUS values for GetExtendedError
  6135                                  ; Outputs:
  6136                                  ;	[EXTERR_CLASS] set
  6137                                  ;	[EXTERR_ACTION] set
  6138                                  ;	[EXTERR_LOCUS] set  (EXCEPT on certain errors as determined by table)
  6139                                  ; Destroys SI, FLAGS
  6140                                  ;
  6141                                  ;---------------------------------------------------------------------------
  6142                                  
  6143                                  	;procedure CAL_LK,NEAR
  6144                                  CAL_LK:
  6145 000017DE 1E                      	PUSH	DS
  6146 000017DF 50                      	PUSH	AX
  6147 000017E0 53                      	PUSH	BX
  6148                                  
  6149                                  ;M048	Context DS		; DS:SI -> Table
  6150                                  ;
  6151                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6152                                  ; is DOSDATA
  6153                                  
  6154                                  	;getdseg	<ds>	; M048: DS:SI -> Table
  6155                                  
  6156                                  	; 18/07/2018
  6157 000017E1 16                      	push	ss
  6158 000017E2 1F                      	pop	ds
  6159                                  
  6160 000017E3 8B1E[F002]              	MOV	BX,[EXTERR]	; Get error in BL
  6161                                  TABLK1:
  6162 000017E7 AC                      	LODSB
  6163                                  
  6164 000017E8 3CFF                    	CMP	AL,0FFH
  6165 000017EA 7409                    	JZ	short GOT_VALS	; End of table
  6166 000017EC 38D8                    	CMP	AL,BL
  6167 000017EE 7405                    	JZ	short GOT_VALS	; Got entry
  6168 000017F0 83C603                  	ADD	SI,3		; Next table entry
  6169                                  	; 15/08/2018
  6170 000017F3 EBF2                    	JMP	short TABLK1
  6171                                  
  6172                                  GOT_VALS:
  6173 000017F5 AD                      	LODSW			; AL is CLASS, AH is ACTION
  6174                                  
  6175 000017F6 80FCFF                  	CMP	AH,0FFH
  6176 000017F9 7404                    	JZ	short NO_SET_ACT
  6177 000017FB 8826[F202]              	MOV	[EXTERR_ACTION],AH	; Set ACTION
  6178                                  NO_SET_ACT:
  6179 000017FF 3CFF                    	CMP	AL,0FFH
  6180 00001801 7403                    	JZ	short NO_SET_CLS
  6181 00001803 A2[F302]                	MOV	[EXTERR_CLASS],AL	; Set CLASS
  6182                                  NO_SET_CLS:
  6183 00001806 AC                      	LODSB			; Get LOCUS
  6184                                  
  6185 00001807 3CFF                    	CMP	AL,0FFH
  6186 00001809 7403                    	JZ	short NO_SET_LOC
  6187 0000180B A2[EF02]                	MOV	[EXTERR_LOCUS],AL
  6188                                  NO_SET_LOC:
  6189 0000180E 5B                      	POP	BX
  6190 0000180F 58                      	POP	AX
  6191 00001810 1F                      	POP	DS
  6192 00001811 C3                      	retn
  6193                                  
  6194                                  	;EndProc CAL_LK
  6195                                  
  6196                                  ;---------------------------------------------------------------------------
  6197                                  ;
  6198                                  ; Procedure Name : ETAB_LK
  6199                                  ;
  6200                                  ; Inputs:
  6201                                  ;	AX is error code
  6202                                  ;	[USER_IN_AX] has AH value of system call involved
  6203                                  ; Function:
  6204                                  ;	Make sure error code is appropriate to this call.
  6205                                  ; Outputs:
  6206                                  ;	AX MAY be mapped error code
  6207                                  ;	[EXTERR] = Input AX
  6208                                  ; Destroys ONLY AX and FLAGS
  6209                                  ;
  6210                                  ;---------------------------------------------------------------------------
  6211                                  
  6212                                  	;procedure ETAB_LK,NEAR
  6213                                  
  6214                                  ETAB_LK: ; 10/08/2018
  6215 00001812 1E                      	PUSH	DS
  6216 00001813 56                      	PUSH	SI
  6217 00001814 51                      	PUSH	CX
  6218 00001815 53                      	PUSH	BX
  6219                                  
  6220                                  	;Context DS			; SS is DOSDATA
  6221                                  
  6222 00001816 16                      	push	ss
  6223 00001817 1F                      	pop	ds
  6224                                  
  6225 00001818 A3[F002]                	MOV	[EXTERR],AX		; Set EXTERR with "real" error
  6226                                  
  6227                                  					; I21_MAP_E_TAB is now in DOSCODE
  6228 0000181B BE[C30C]                	MOV	SI,I21_MAP_E_TAB
  6229 0000181E 88C7                    	MOV	BH,AL			; Real code to BH
  6230 00001820 8A1E[0503]              	MOV	BL,[USER_IN_AX+1]	; Sys call to BL
  6231                                  TABLK2:
  6232                                  ;;hkn;	LODSW
  6233                                  ;	LODS	word ptr cs:[si] ; MSDOS 6.0
  6234                                  	
  6235                                  	; 18/07/2018
  6236 00001824 AD                      	lodsw		; IBMDOS.COM (MSDOS 3.3) - Offset 16F7h
  6237                                  
  6238 00001825 3CFF                    	CMP	AL,0FFH 		; End of table?
  6239 00001827 740C                    	JZ	short NOT_IN_TABLE	; Yes
  6240 00001829 38D8                    	CMP	AL,BL			; Found call?
  6241 0000182B 740C                    	JZ	short GOT_CALL		; Yes
  6242 0000182D 86E0                    	XCHG	AH,AL			; Count to AL
  6243 0000182F 30E4                    	XOR	AH,AH			; Make word for add
  6244 00001831 01C6                    	ADD	SI,AX			; Next table entry
  6245 00001833 EBEF                    	JMP	short TABLK2
  6246                                  
  6247                                  NOT_IN_TABLE:
  6248 00001835 88F8                    	MOV	AL,BH			; Restore original code
  6249 00001837 EB0B                    	JMP	SHORT NO_MAP
  6250                                  
  6251                                  GOT_CALL:
  6252 00001839 88E1                    	MOV	CL,AH
  6253 0000183B 30ED                    	XOR	CH,CH			; Count of valid err codes to CX
  6254                                  CHECK_CODE:
  6255                                  ;;hkn;	LODSB
  6256                                  ;	LODS	byte ptr cs:[si]
  6257                                  
  6258                                  	; 18/07/2018
  6259 0000183D AC                      	lodsb		; IBMDOS.COM (MSDOS 3.3) - Offset 1710h
  6260                                  
  6261 0000183E 38F8                    	CMP	AL,BH			; Code OK?
  6262 00001840 7402                    	JZ	short NO_MAP		; Yes
  6263 00001842 E2F9                    	LOOP	CHECK_CODE
  6264                                  NO_MAP:
  6265 00001844 30E4                    	XOR	AH,AH			; AX is now valid code
  6266 00001846 5B                      	POP	BX
  6267 00001847 59                      	POP	CX
  6268 00001848 5E                      	POP	SI
  6269 00001849 1F                      	POP	DS
  6270 0000184A C3                      	retn
  6271                                  
  6272                                  	;EndProc ETAB_LK
  6273                                  
  6274                                  ; 18/07/2018 - Retro DOS v3.0
  6275                                  ;---------------------------------------------------------------------------
  6276                                  ; BREAK <DOS 2F Handler and default NET 2F handler>
  6277                                  
  6278                                  ;IF installed
  6279                                  ;---------------------------------------------------------------------------
  6280                                  ;
  6281                                  ; Procedure Name : SetBad
  6282                                  ;
  6283                                  ; SetBad sets up info for bad functions
  6284                                  ;
  6285                                  ;---------------------------------------------------------------------------
  6286                                  
  6287                                  SetBad:
  6288                                  	;mov	ax,1
  6289 0000184B B80100                  	MOV	AX,error_invalid_function ; ALL NET REQUESTS get inv func
  6290                                  
  6291                                  ;	set up ds to point to DOSDATA
  6292                                  
  6293                                  	; MSDOS 6.0
  6294                                  	;push	ds
  6295                                  
  6296                                  	;getdseg <ds>
  6297                                  	;MOV	[EXTERR_LOCUS],errLOC_Unk	
  6298                                  
  6299                                  	; MSDOS 3.3
  6300                                  	;mov	byte [cs:EXTERR_LOCUS],1
  6301 0000184E 2EC606[EF02]01          	MOV	byte [CS:EXTERR_LOCUS],errLOC_Unk
  6302                                  
  6303                                  	;pop	ds	  		;hkn; restore ds
  6304                                  
  6305 00001854 F9                      	STC
  6306 00001855 C3                      	retn
  6307                                  
  6308                                  ;--------------------------------------------------------------------------
  6309                                  ;
  6310                                  ; Procedure Name : BadCall
  6311                                  ;
  6312                                  ; BadCall is the initial routine for bad function calls
  6313                                  ;
  6314                                  ;--------------------------------------------------------------------------
  6315                                  
  6316                                  BadCall:
  6317 00001856 E8F2FF                  	call	SetBad
  6318 00001859 CB                      	retf
  6319                                  
  6320                                  ;--------------------------------------------------------------------------
  6321                                  ;
  6322                                  ; OKCall always sets carry to off.
  6323                                  ;
  6324                                  ;-----------------------------------------------------------------------
  6325                                  
  6326                                  OKCall:
  6327 0000185A F8                      	CLC
  6328 0000185B CB                      	retf
  6329                                  
  6330                                  ;---------------------------------------------------------------------------
  6331                                  ;
  6332                                  ; Procedure Name : INT2F
  6333                                  ;
  6334                                  ; INT 2F handler works as follows:
  6335                                  ;   PUSH    AX
  6336                                  ;   MOV     AX,multiplex:function
  6337                                  ;   INT     2F
  6338                                  ;   POP     ...
  6339                                  ; The handler itself needs to make the AX available for the various routines.
  6340                                  ;
  6341                                  ;----------------------------------------------------------------------------
  6342                                  
  6343                                  ;PUBLIC	Int2F
  6344                                  ;INT2F	PROC	FAR
  6345                                  
  6346                                  	; 18/07/2018 - Retro DOS v3.0
  6347                                  
  6348                                  INT2F:
  6349                                  	; Offset 172Fh in IBMDOS.COM (MSDOS 3.3), 1987
  6350                                  INT2FNT:
  6351                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  6352 0000185C FB                      	STI
  6353                                  	;cmp	ah,11h
  6354 0000185D 80FC11                  	CMP	AH,MultNET
  6355 00001860 750A                    	JNZ	short INT2FSHR
  6356                                  TestInstall:
  6357 00001862 08C0                    	OR	AL,AL
  6358 00001864 7403                    	JZ	short Leave2F
  6359                                  BadFunc:
  6360 00001866 E8E2FF                  	CALL	SetBad
  6361                                  
  6362                                  	;entry	Leave2F
  6363                                  Leave2F:
  6364 00001869 CA0200                  	RETF	2			; long return + clear flags off stack
  6365                                  
  6366                                  INT2FSHR:
  6367                                  	;cmp	ah,10h
  6368 0000186C 80FC10                  	CMP	AH,MultSHARE		; is this a share request
  6369 0000186F 74F1                    	JZ	short TestInstall	; yes, check for installation
  6370                                  INT2FNLS:
  6371                                  	;cmp	ah,14h
  6372 00001871 80FC14                  	CMP	AH,NLSFUNC		; is this a DOS 3.3 NLSFUNC request
  6373 00001874 74EC                    	JZ	short TestInstall	; yes check for installation
  6374                                  INT2FDOS:
  6375                                  	;ASSUME	CS:DOSCODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
  6376                                  
  6377                                  	; 18/07/2018
  6378                                  	; MSDOS 6.0
  6379                                  	;CMP	AH,MultDOS
  6380                                  	;JNZ	check_win		;check if win386 broadcast
  6381                                  	;jmp	DispatchDOS
  6382                                  
  6383                                  	; .... win386 .... 
  6384                                  	
  6385                                  	; 18/07/2018
  6386                                  	; MSDOS 3.3
  6387                                  	;cmp	ah,12h	
  6388 00001876 80FC12                  	CMP	AH,MultDOS
  6389 00001879 7401                    	jz	short DispatchDOS
  6390 0000187B CF                      	iret
  6391                                  
  6392                                  ;INT2F	ENDP
  6393                                  	
  6394                                  DispatchDOS:
  6395 0000187C 2EFF36[080F]            	PUSH	word [CS:FOO]		; push return address
  6396 00001881 2EFF36[0A0F]            	PUSH	word [CS:DTab]		; push table address
  6397 00001886 50                      	PUSH	AX			; push index
  6398 00001887 55                      	PUSH	BP
  6399 00001888 89E5                    	MOV	BP,SP
  6400                                  		; stack looks like:
  6401                                  		;   0	BP
  6402                                  		;   2	DISPATCH
  6403                                  		;   4	TABLE
  6404                                  		;   6	RETURN
  6405                                  		;   8	LONG-RETURN
  6406                                  		;   c	FLAGS
  6407                                  		;   e	AX
  6408                                  	
  6409 0000188A 8B460E                  	MOV	AX,[BP+0Eh]		; get AX value
  6410 0000188D 5D                      	POP	BP
  6411 0000188E E8B307                  	call	TableDispatch
  6412 00001891 EBD3                    	JMP	short BadFunc 		; return indicates invalid function
  6413                                  
  6414                                  INT2F_etcetera:
  6415                                  	;entry	DosGetGroup
  6416                                  DosGetGroup:
  6417                                  	; MSDOS 6.0
  6418                                  ;SR; Cannot use CS now
  6419                                  ;
  6420                                  ;	PUSH	CS
  6421                                  ;	POP	DS
  6422                                  
  6423                                  	;getdseg <ds>
  6424                                  	;retn
  6425                                  
  6426                                  	; MSDOS 3.3
  6427 00001893 0E                      	push	cs
  6428 00001894 1F                      	pop	ds
  6429 00001895 C3                      	retn
  6430                                  
  6431                                  	;entry	DOSInstall
  6432                                  DOSInstall:
  6433 00001896 B0FF                    	MOV	AL,0FFh
  6434 00001898 C3                      	retn
  6435                                  
  6436                                  ;ENDIF
  6437                                  
  6438                                  ;============================================================================
  6439                                  ; DOSTAB.ASM (MSDOS 6.0, 1991)
  6440                                  ;============================================================================
  6441                                  ; 18/07/2018 - Retro DOS 3.0
  6442                                  
  6443                                  ;CASE MAPPER ROUTINE FOR 80H-FFH character range, DOS 3.3
  6444                                  ;     ENTRY: AL = Character to map
  6445                                  ;     EXIT:  AL = The converted character
  6446                                  ; Alters no registers except AL and flags.
  6447                                  ; The routine should do nothing to chars below 80H.
  6448                                  ;
  6449                                  ; Example:
  6450                                  
  6451                                  ;Procedure   MAP_CASE,FAR
  6452                                  
  6453                                  MAP_CASE:
  6454                                  	; Offset 176Ch in IBMDOS.COM (MSDOS 3.3), 1987
  6455                                  	
  6456 00001899 3C80                    	CMP	AL,80H
  6457 0000189B 7301                    	JAE	short Map1	;Map no chars below 80H ever
  6458 0000189D CB                      	RETF
  6459                                  Map1:
  6460 0000189E 2C80                    	SUB	AL,80H		;Turn into index value
  6461 000018A0 1E                      	PUSH	DS
  6462 000018A1 53                      	PUSH	BX
  6463 000018A2 BB[C610]                	MOV	BX,UCASE_TAB+2
  6464                                  FINISH:
  6465 000018A5 0E                      	PUSH	CS		;Move to DS
  6466 000018A6 1F                      	POP	DS
  6467 000018A7 D7                      	XLAT			; Get upper case character
  6468 000018A8 5B                      	POP	BX
  6469 000018A9 1F                      	POP	DS
  6470                                  L_RET:	
  6471 000018AA CB                      	RETF
  6472                                  
  6473                                  ;EndProc MAP_CASE
  6474                                  
  6475                                  ;============================================================================
  6476                                  ; DOSMES.INC (MSDOS 6.0, 1991)
  6477                                  ;============================================================================
  6478                                  ; 18/07/2018 - Retro DOS v3.0
  6479                                  
  6480                                  ; DOSMES.ASM (MSDOS 2.11, 1983)
  6481                                  
  6482                                  ; OEMFunction key is expected to process a single function
  6483                                  ;   key input from a device and dispatch to the proper
  6484                                  ;   routines leaving all registers UNTOUCHED.
  6485                                  ;
  6486                                  ; Inputs:   CS, SS are DOSGROUP
  6487                                  ; Outputs:  None. This function is expected to JMP to onw of
  6488                                  ;           the following labels:
  6489                                  ;
  6490                                  ;           GetCh       - ignore the sequence
  6491                                  ;           TwoEsc      - insert an ESCChar in the buffer
  6492                                  ;           ExitIns     - toggle insert mode
  6493                                  ;           EnterIns    - toggle insert mode
  6494                                  ;           BackSp      - move backwards one space
  6495                                  ;           ReEdit      - reedit the line with a new template
  6496                                  ;           KilNew      - discard the current line and start from scratch
  6497                                  ;           CopyLin     - copy the rest of the template into the line
  6498                                  ;           SkipStr     - read the next character and skip to it in the template
  6499                                  ;           CopyStr     - read next char and copy from template to line until char
  6500                                  ;           SkipOne     - advance position in template one character
  6501                                  ;           CopyOne     - copy next character in template into line
  6502                                  ;           CtrlZ       - place a ^Z into the template
  6503                                  ; Registers that are allowed to be modified by this function are:
  6504                                  ;           AX, CX, BP
  6505                                  
  6506                                  OEMFunctionKey:
  6507 000018AB E87F08                  	CALL	_$STD_CON_INPUT_NO_ECHO  ; Get the second byte of the sequence
  6508 000018AE B10E                    	MOV     CL,ESCTABLEN ; 14	; length of table for scan
  6509 000018B0 57                      	PUSH    DI                      ; save DI (cannot change it!)
  6510 000018B1 BF[1113]                	MOV     DI,ESCTAB		; offset of second byte table
  6511 000018B4 F2AE                    	REPNE   SCASB                   ; Look it up in the table
  6512 000018B6 5F                      	POP     DI                      ; restore DI
  6513 000018B7 D1E1                    	SHL     CX,1                    ; convert byte offset to word
  6514 000018B9 89CD                    	MOV     BP,CX                   ; move to indexable register
  6515                                  	;JMP	word [SS:BP+ESCFUNC]	; Go to the right routine
  6516 000018BB FFA6[1F13]              	JMP	word [BP+ESCFUNC]
  6517                                  	
  6518                                  ;============================================================================
  6519                                  ; TIME.ASM (MSDOS 6.0, 1991)
  6520                                  ;============================================================================
  6521                                  ; Retro DOS v3.0 - 18/07/2018
  6522                                  
  6523                                  ; SYSCALL.ASM (MSDOS 2.11, 1983)
  6524                                  ;----------------------------------------------------------------------------
  6525                                  ; Retro DOS v2.0 - 13/03/2018
  6526                                  
  6527                                  ;**	TIME.ASM - System Calls and low level routines for DATE and TIME
  6528                                  
  6529                                  	;BREAK <DATE AND TIME - SYSTEM CALLS 42,43,44,45>
  6530                                  
  6531                                  ;**	$GET_DATE - Get Current Date
  6532                                  ;
  6533                                  ;	ENTRY	none
  6534                                  ;	EXIT	(cx:dx) = current date
  6535                                  ;	USES	all
  6536                                  
  6537                                  _$GET_DATE:	;System call 42
  6538                                  
  6539 000018BF 16                              PUSH    SS
  6540 000018C0 1F                              POP     DS
  6541 000018C1 E8B700                          CALL	READTIME        ;Check for rollover to next day
  6542 000018C4 A1[1C03]                        MOV     AX,[YEAR]
  6543                                  
  6544                                  ;	WARNING!!!! DAY and MONTH must be adjacently allocated!
  6545                                  
  6546 000018C7 8B1E[1A03]                      MOV     BX,[DAY]	; fetch both day and month
  6547 000018CB E87BFD                  	CALL	Get_User_Stack	;Get pointer to user registers
  6548                                          ;MOV    [SI+6],BX  	;DH=month, DL=day
  6549 000018CE 895C06                  	MOV	[SI+user_env.user_DX],BX
  6550 000018D1 05BC07                          ADD     AX,1980         ;Put bias back
  6551                                          ;MOV    [SI+4],AX  	;CX=year
  6552 000018D4 894404                  	MOV	[SI+user_env.user_CX],AX
  6553                                          ;MOV	AL,[WEEKDAY]
  6554 000018D7 36A0[2003]                      MOV	AL,[SS:WEEKDAY]	;hkn; SS override
  6555 000018DB C3                      	RETN
  6556                                  
  6557                                  ;**	$SET_DATE - Set Current Date
  6558                                  ;
  6559                                  ;	ENTRY	(cx:dx) = current date
  6560                                  ;	EXIT	(al) = -1 iff bad date
  6561                                  ;		(al) = 0 if ok
  6562                                  ;	USES	all
  6563                                  
  6564                                  _$SET_DATE:			;System call 43
  6565                                  
  6566 000018DC B0FF                            MOV     AL,-1           ;Be ready to flag error
  6567 000018DE 81E9BC07                        SUB     CX,1980         ;Fix bias in year
  6568 000018E2 7217                            JC      SHORT RET24	;Error if not big enough
  6569 000018E4 83F977                          CMP     CX,119          ;Year must be less than 2100
  6570 000018E7 7712                            JA      SHORT RET24
  6571 000018E9 08F6                            OR      DH,DH
  6572 000018EB 740E                            JZ      SHORT RET24
  6573 000018ED 08D2                            OR      DL,DL
  6574 000018EF 740A                            JZ      SHORT RET24	;Error if either month or day is 0
  6575 000018F1 80FE0C                          CMP     DH,12           ;Check against max. month
  6576 000018F4 7705                            JA      SHORT RET24
  6577 000018F6 16                              PUSH    SS
  6578 000018F7 1F                              POP     DS
  6579 000018F8 E81301                  	CALL	DODATE
  6580                                  RET24:  
  6581 000018FB C3                      	RETN
  6582                                  
  6583                                  
  6584                                  ;**	$GET_TIME - Get Current Time
  6585                                  ;
  6586                                  ;	ENTRY	none
  6587                                  ;	EXIT	(cx:dx) = current time
  6588                                  ;	USES	all
  6589                                  
  6590                                  _$GET_TIME:			;System call 44
  6591                                  
  6592 000018FC 16                              PUSH    SS
  6593 000018FD 1F                              POP     DS
  6594 000018FE E87A00                  	CALL	READTIME
  6595 00001901 E845FD                  	CALL	Get_User_Stack           ;Get pointer to user registers
  6596                                         ;MOV     [SI+6],DX
  6597 00001904 895406                  	MOV	[SI+user_env.user_DX],DX
  6598                                         ;MOV     [SI+4],CX
  6599 00001907 894C04                  	MOV	[SI+user_env.user_CX],CX
  6600 0000190A 30C0                            XOR     AL,AL
  6601                                  RET26:  
  6602 0000190C C3                      	RETN
  6603                                  
  6604                                  ;**	$SET_TIME - Set Current Time
  6605                                  ;
  6606                                  ;	ENTRY	(cx:dx) = time
  6607                                  ;	EXIT	(al) = 0 if 0k
  6608                                  ;		(al) = -1 if invalid
  6609                                  ;	USES	ALL
  6610                                  
  6611                                  _$SET_TIME:			;System call 45
  6612                                  
  6613 0000190D B0FF                            MOV     AL,-1           ;Flag in case of error
  6614 0000190F 80FD18                          CMP     CH,24           ;Check hours
  6615 00001912 73F8                            JAE     SHORT RET26
  6616 00001914 80F93C                          CMP     CL,60           ;Check minutes
  6617 00001917 73F3                            JAE     SHORT RET26
  6618 00001919 80FE3C                          CMP     DH,60           ;Check seconds
  6619 0000191C 73EE                            JAE     SHORT RET26
  6620 0000191E 80FA64                          CMP     DL,100          ;Check 1/100's
  6621 00001921 73E9                            JAE     SHORT RET26
  6622 00001923 51                              PUSH    CX
  6623 00001924 52                              PUSH    DX
  6624 00001925 16                              PUSH    SS
  6625 00001926 1F                              POP     DS
  6626 00001927 BB[7A03]                        MOV     BX,TIMEBUF
  6627 0000192A B90600                          MOV     CX,6
  6628 0000192D 31D2                            XOR     DX,DX
  6629 0000192F 89D0                            MOV     AX,DX
  6630 00001931 53                              PUSH    BX
  6631 00001932 E86F38                  	CALL	SETREAD
  6632 00001935 1E                              PUSH    DS
  6633 00001936 C536[2E00]                      LDS     SI,[BCLOCK]
  6634 0000193A E8F537                  	CALL	DEVIOCALL2      ;Get correct day count
  6635 0000193D 1F                              POP     DS
  6636 0000193E 5B                              POP     BX
  6637 0000193F E89538                  	CALL	SETWRITE
  6638 00001942 8F06[7E03]                      POP     WORD [TIMEBUF+4]
  6639 00001946 8F06[7C03]                      POP     WORD [TIMEBUF+2]
  6640 0000194A C536[2E00]                      LDS     SI,[BCLOCK]
  6641 0000194E E8E137                  	CALL	DEVIOCALL2      ;Set the time
  6642 00001951 30C0                            XOR     AL,AL
  6643 00001953 C3                              RETN
  6644                                  
  6645                                  ; 11/07/2018 - Retro DOS v3.0
  6646                                  ; Retro DOS v2.0 - 14/03/2018
  6647                                  
  6648                                  FOURYEARS EQU 3*365 + 366  ; = 1461 
  6649                                  
  6650                                  ;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE
  6651                                  
  6652                                  ;
  6653                                  ; Date16 returns the current date in AX, current time in DX
  6654                                  ;   AX - YYYYYYYMMMMDDDDD  years months days
  6655                                  ;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
  6656                                  ;
  6657                                  
  6658                                  DATE16:
  6659                                  	
  6660                                  ;M048	Context DS
  6661                                  ;
  6662                                  ; Since this function can be called thru int 2f we shall not assume that SS
  6663                                  ; is DOSDATA
  6664                                  
  6665                                  	;getdseg	<ds>			; M048
  6666                                  
  6667                                  	;PUSH	SS
  6668 00001954 0E                      	PUSH	CS
  6669 00001955 1F                      	POP	DS
  6670                                  
  6671 00001956 51                              PUSH    CX
  6672 00001957 06                              PUSH    ES
  6673 00001958 E82000                          CALL    READTIME
  6674 0000195B 07                              POP     ES
  6675 0000195C D0E1                            SHL     CL,1            ;Minutes to left part of byte
  6676 0000195E D0E1                            SHL     CL,1
  6677 00001960 D1E1                            SHL     CX,1            ;Push hours and minutes to left end
  6678 00001962 D1E1                            SHL     CX,1
  6679 00001964 D1E1                            SHL     CX,1
  6680 00001966 D0EE                            SHR     DH,1            ;Count every two seconds
  6681 00001968 08F1                            OR      CL,DH           ;Combine seconds with hours and minutes
  6682 0000196A 89CA                            MOV     DX,CX
  6683                                  
  6684                                  ;	WARNING!  MONTH and YEAR must be adjacently allocated
  6685                                  
  6686 0000196C A1[1B03]                        MOV     AX,[MONTH]	;Fetch month and year
  6687 0000196F B104                            MOV     CL,4
  6688 00001971 D2E0                            SHL     AL,CL		;Push month to left to make room for day
  6689 00001973 D1E0                            SHL     AX,1
  6690 00001975 59                              POP     CX
  6691 00001976 0A06[1A03]                      OR      AL,[DAY]
  6692                                  RET21:
  6693 0000197A C3                              RETN
  6694                                  
  6695                                  READTIME:
  6696                                  ;Gets time in CX:DX. Figures new date if it has changed.
  6697                                  ;Uses AX, CX, DX.
  6698                                  
  6699 0000197B C706[C30F]0000          	MOV	word [DATE_FLAG],0 ; reset date flag for CPMIO
  6700 00001981 56                              PUSH    SI
  6701 00001982 53                              PUSH    BX
  6702                                  
  6703 00001983 BB[7A03]                        MOV     BX,TIMEBUF
  6704                                  
  6705 00001986 B90600                          MOV     CX,6
  6706 00001989 31D2                            XOR     DX,DX
  6707 0000198B 89D0                            MOV     AX,DX
  6708 0000198D E81438                  	CALL	SETREAD
  6709 00001990 1E                              PUSH    DS
  6710 00001991 C536[2E00]                      LDS     SI,[BCLOCK]
  6711 00001995 E89A37                  	CALL	DEVIOCALL2      ;Get correct date and time
  6712 00001998 1F                              POP     DS
  6713 00001999 5B                              POP     BX
  6714 0000199A 5E                              POP     SI
  6715 0000199B A1[7A03]                        MOV     AX,[TIMEBUF]
  6716 0000199E 8B0E[7C03]                      MOV     CX,[TIMEBUF+2]
  6717 000019A2 8B16[7E03]                      MOV     DX,[TIMEBUF+4]
  6718 000019A6 3B06[1E03]                      CMP     AX,[DAYCNT]     ;See if day count is the same
  6719                                          ;JZ	SHORT RET22
  6720 000019AA 74CE                    	JZ	SHORT RET21 ; 18/07/2018
  6721                                  	;cmp	ax,43830
  6722 000019AC 3D36AB                          CMP     AX,FOURYEARS*30 ;Number of days in 120 years
  6723 000019AF 733D                            JAE     SHORT RET22	;Ignore if too large
  6724 000019B1 A3[1E03]                        MOV     [DAYCNT],AX
  6725 000019B4 56                              PUSH    SI
  6726 000019B5 51                              PUSH    CX
  6727 000019B6 52                              PUSH    DX              ;Save time
  6728 000019B7 31D2                            XOR     DX,DX
  6729                                  	;mov	cx,1461
  6730 000019B9 B9B505                          MOV     CX,FOURYEARS    ;Number of days in 4 years
  6731 000019BC F7F1                            DIV     CX              ;Compute number of 4-year units
  6732 000019BE D1E0                            SHL     AX,1
  6733 000019C0 D1E0                            SHL     AX,1
  6734 000019C2 D1E0                            SHL     AX,1            ;Multiply by 8 (no. of half-years)
  6735 000019C4 89C1                            MOV     CX,AX           ;<240 implies AH=0
  6736                                  
  6737 000019C6 BE[AF0C]                        MOV     SI,YRTAB        ;Table of days in each year
  6738                                  
  6739 000019C9 E82300                          CALL    DSLIDE          ;Find out which of four years we're in
  6740 000019CC D1E9                            SHR     CX,1            ;Convert half-years to whole years
  6741 000019CE 7304                            JNC     SHORT SK	;Extra half-year?
  6742 000019D0 81C2C800                        ADD     DX,200
  6743                                  SK:
  6744 000019D4 E82400                          CALL    SETYEAR
  6745 000019D7 B101                            MOV     CL,1            ;At least at first month in year
  6746                                  
  6747 000019D9 BE[B70C]                        MOV     SI,MONTAB       ;Table of days in each month
  6748                                          
  6749 000019DC E81000                  	CALL    DSLIDE          ;Find out which month we're in
  6750 000019DF 880E[1B03]                      MOV     [MONTH],CL
  6751 000019E3 42                              INC     DX              ;Remainder is day of month (start with one)
  6752 000019E4 8816[1A03]                      MOV     [DAY],DL
  6753 000019E8 E89400                          CALL    WKDAY           ;Set day of week
  6754 000019EB 5A                              POP     DX
  6755 000019EC 59                              POP     CX
  6756 000019ED 5E                              POP     SI
  6757                                  RET22:  
  6758 000019EE C3                      	RETN
  6759                                  
  6760                                  DSLIDE:
  6761 000019EF B400                            MOV     AH,0
  6762                                  DSLIDE1:
  6763 000019F1 AC                              LODSB			;Get count of days
  6764 000019F2 39C2                            CMP     DX,AX           ;See if it will fit
  6765 000019F4 7217                            JB      SHORT RET23	;If not, done
  6766 000019F6 29C2                            SUB     DX,AX
  6767 000019F8 41                              INC     CX              ;Count one more month/year
  6768 000019F9 EBF6                            JMP     SHORT DSLIDE1
  6769                                  
  6770                                  SETYEAR:
  6771                                  ;Set year with value in CX. Adjust length of February for this year.
  6772                                  
  6773                                  ; NOTE: This can also be called thru int 2f. If this is called then it will
  6774                                  ;       set DS to DOSDATA. Since the only guy calling this should be the DOS
  6775                                  ;	redir, DS will be DOSDATA anyway. It is going to be in-efficient to
  6776                                  ;	preserve DS as CHKYR is also called as a routine.
  6777                                  
  6778                                  
  6779                                  	; MSDOS 6.0 (18/07/2018) ; *
  6780                                  
  6781                                  	;GETDSEG DS
  6782                                  
  6783 000019FB 0E                      	PUSH	CS  ; *
  6784 000019FC 1F                      	POP	DS  ; *
  6785                                  
  6786                                  	; Offset 18CEh in IBMDOS.COM (MSDOS 3.3), 1987 
  6787                                  
  6788 000019FD 880E[1C03]                      MOV     [YEAR],CL
  6789                                  CHKYR:
  6790 00001A01 F6C103                          TEST    CL,3            ;Check for leap year
  6791 00001A04 B01C                            MOV     AL,28
  6792 00001A06 7502                            JNZ     SHORT SAVFEB	;28 days if no leap year
  6793 00001A08 FEC0                            INC     AL              ;Add leap day
  6794                                  SAVFEB:
  6795                                  	;mov	[february],al
  6796 00001A0A A2[B80C]                        MOV     [MONTAB+1],AL   ;Store for February
  6797                                  RET23:  
  6798 00001A0D C3                      	RETN
  6799                                  
  6800                                  DODATE:
  6801 00001A0E E8F0FF                          CALL    CHKYR           ;Set Feb. up for new year
  6802 00001A11 88F0                            MOV     AL,DH
  6803                                  
  6804 00001A13 BB[B60C]                        MOV     BX,MONTAB-1
  6805                                  
  6806 00001A16 D7                              XLAT                    ;Look up days in month
  6807 00001A17 38D0                            CMP     AL,DL
  6808 00001A19 B0FF                            MOV     AL,-1           ;Restore error flag, just in case
  6809                                          ;JB	SHORT RET25	;Error if too many days
  6810 00001A1B 72F0                            jb	short RET23 ; 18/07/2018
  6811 00001A1D E8DBFF                  	CALL    SETYEAR
  6812                                  ;
  6813                                  ; WARNING!  DAY and MONTH must be adjacently allocated
  6814                                  ;
  6815 00001A20 8916[1A03]                      MOV     [DAY],DX	;Set both day and month
  6816 00001A24 D1E9                            SHR     CX,1
  6817 00001A26 D1E9                            SHR     CX,1
  6818                                  	;mov	ax,1461
  6819 00001A28 B8B505                          MOV     AX,FOURYEARS
  6820 00001A2B 89D3                            MOV     BX,DX
  6821 00001A2D F7E1                            MUL     CX
  6822 00001A2F 8A0E[1C03]                      MOV     CL,[YEAR]
  6823 00001A33 80E103                          AND     CL,3
  6824                                  
  6825 00001A36 BE[AF0C]                        MOV     SI,YRTAB
  6826                                  
  6827 00001A39 89C2                            MOV     DX,AX
  6828 00001A3B D1E1                            SHL     CX,1            ;Two entries per year, so double count
  6829 00001A3D E85200                          CALL    DSUM            ;Add up the days in each year
  6830 00001A40 88F9                            MOV     CL,BH           ;Month of year
  6831                                  
  6832 00001A42 BE[B70C]                        MOV     SI,MONTAB
  6833                                  
  6834 00001A45 49                              DEC     CX              ;Account for months starting with one
  6835 00001A46 E84900                          CALL    DSUM            ;Add up days in each month
  6836 00001A49 88D9                            MOV     CL,BL           ;Day of month
  6837 00001A4B 49                              DEC     CX              ;Account for days starting with one
  6838 00001A4C 01CA                            ADD     DX,CX           ;Add in to day total
  6839 00001A4E 92                              XCHG    AX,DX           ;Get day count in AX
  6840 00001A4F A3[1E03]                        MOV     [DAYCNT],AX
  6841 00001A52 56                              PUSH    SI
  6842 00001A53 53                              PUSH    BX
  6843 00001A54 50                              PUSH    AX
  6844                                  
  6845 00001A55 BB[7A03]                        MOV     BX,TIMEBUF
  6846                                  
  6847 00001A58 B90600                          MOV     CX,6
  6848 00001A5B 31D2                            XOR     DX,DX
  6849 00001A5D 89D0                            MOV     AX,DX
  6850 00001A5F 53                              PUSH    BX
  6851 00001A60 E84137                  	CALL	SETREAD
  6852                                  
  6853 00001A63 1E                              PUSH    DS
  6854 00001A64 C536[2E00]                      LDS     SI,[BCLOCK]
  6855 00001A68 E8C736                  	CALL	DEVIOCALL2	;Get correct date and time
  6856 00001A6B 1F                              POP     DS
  6857 00001A6C 5B                              POP     BX
  6858 00001A6D E86737                  	CALL	SETWRITE
  6859 00001A70 8F06[7A03]                      POP     WORD [TIMEBUF]
  6860 00001A74 1E                              PUSH    DS
  6861 00001A75 C536[2E00]                      LDS     SI,[BCLOCK]
  6862 00001A79 E8B636                  	CALL	DEVIOCALL2      ;Set the date
  6863 00001A7C 1F                              POP     DS
  6864 00001A7D 5B                              POP     BX
  6865 00001A7E 5E                              POP     SI
  6866                                  WKDAY:
  6867 00001A7F A1[1E03]                        MOV     AX,[DAYCNT]
  6868 00001A82 31D2                            XOR     DX,DX
  6869 00001A84 B90700                          MOV     CX,7
  6870 00001A87 40                              INC     AX
  6871 00001A88 40                              INC     AX              ;First day was Tuesday
  6872 00001A89 F7F1                            DIV     CX              ;Compute day of week
  6873 00001A8B 8816[2003]                      MOV     [WEEKDAY],DL
  6874 00001A8F 30C0                            XOR     AL,AL           ;Flag OK
  6875                                  RET25:
  6876 00001A91 C3                      	RETN
  6877                                  
  6878                                  ;**	DSUM - Compute the sum of a string of bytes
  6879                                  ;
  6880                                  ;	ENTRY	(cx) = byte count
  6881                                  ;		(ds:si) = byte address
  6882                                  ;		(dx) = sum register, initialized by caller
  6883                                  ;	EXIT	(dx) updated
  6884                                  ;	USES	ax, cx, dx, si, flags
  6885                                  
  6886                                  DSUM:
  6887 00001A92 B400                            MOV     AH,0
  6888                                  	;JCXZ	DSUM9
  6889 00001A94 E3FB                            JCXZ	RET25 ; 18/07/2018
  6890                                  DSUM1:
  6891 00001A96 AC                              LODSB
  6892 00001A97 01C2                            ADD     DX,AX
  6893 00001A99 E2FB                            LOOP    DSUM1
  6894                                  DSUM9:
  6895 00001A9B C3                              RETN
  6896                                  
  6897                                  ;============================================================================
  6898                                  ; GETSET.ASM
  6899                                  ;============================================================================
  6900                                  ; 18/07/2018 - Retro DOS v3.0 (GETSET.ASM, MSDOS 6.0, 1991)
  6901                                  ; Retro DOS v2.0 - 12/03/2018
  6902                                  
  6903                                  ;TITLE	GETSET - GETting and SETting MS-DOS system calls
  6904                                  ;NAME	GETSET
  6905                                  
  6906                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
  6907                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
  6908                                  
  6909                                  ;USERNUM:
  6910                                  ;	DW	0			; 24 bit user number
  6911                                  ;       DB      0
  6912                                  ;;	IF      IBM
  6913                                  ;;OEMNUM: DB    0			; 8 bit OEM number
  6914                                  ;;	ELSE
  6915                                  ;OEMNUM: DB     0FFH			; 8 bit OEM number
  6916                                  ;;	ENDIF
  6917                                  
  6918                                  ;MSVERS:		; MS-DOS version in hex for $GET_VERSION
  6919                                  ;; 08/07/2018 - Retro DOS v3.0
  6920                                  ;MSMAJOR: DB	MAJOR_VERSION	; DOS_MAJOR_VERSION
  6921                                  ;MSMINOR: DB	MINOR_VERSION	; DOS_MINOR_VERSION  
  6922                                  
  6923                                  
  6924                                  ;BREAK <$Get_Version -- Return MSDOS version number>
  6925                                  
  6926                                  _$GET_VERSION:
  6927                                  
  6928                                  ; Inputs:
  6929                                  ;       None
  6930                                  ; Function:
  6931                                  ;       Return MS-DOS version number
  6932                                  ; Outputs:
  6933                                  ;       OEM number in BH
  6934                                  ;       User number in BL:CX (24 bits)
  6935                                  ;       Version number as AL.AH in binary
  6936                                  ;       NOTE: On pre 1.28 DOSs AL will be zero
  6937                                  
  6938                                  ; MSDOS 6.0
  6939                                  ;		if input al = 00
  6940                                  ;		  (bh) = OEM number			
  6941                                  ;		else if input al = 01
  6942                                  ;		  (bh) = version flags
  6943                                  ;		 
  6944                                  ;		       	 bits 0-2 = DOS internal revision
  6945                                  ;		       	 bits 3-7 = DOS type flags
  6946                                  ;		              bit 3    = DOS is in ROM
  6947                                  ;		              bit 4    = DOS in in HMA
  6948                                  ;		              bits 5-7 = reserved
  6949                                  ;               M007 change - only bit 3 is now valid. Other bits
  6950                                  ;               are 0 when AL = 1
  6951                                  
  6952                                  	
  6953                                  	; MSDOS 3.3 (IBMDOS.COM, offset 196Dh)
  6954                                  
  6955 00001A9C 16                              PUSH    SS
  6956 00001A9D 1F                              POP     DS
  6957 00001A9E 8B1E[7603]                      MOV     BX,[USERNUM+2]
  6958 00001AA2 8B0E[7403]                      MOV     CX,[USERNUM]
  6959 00001AA6 A1[AD0C]                        MOV     AX,[MSVERS]
  6960 00001AA9 E89DFB                          call	Get_User_Stack
  6961                                          ;MOV	[SI+2],BX
  6962 00001AAC 895C02                  	mov	[SI+user_env.user_BX],BX
  6963                                          ;MOV	[SI+4],CX
  6964 00001AAF 894C04                  	mov	[SI+user_env.user_CX],CX
  6965                                          ;MOV	[SI+user_env.user_AX],AX  ; Really only sets AH
  6966 00001AB2 8904                            MOV	[SI],AX ; 31/03/2018
  6967 00001AB4 C3                      	RETN
  6968                                  
  6969                                  ; 18/07/2018 - Retro DOS v3.0
  6970                                  
  6971                                  ;BREAK <$Get/Set_Verify_on_Write - return/set verify-after-write flag>
  6972                                  
  6973                                  ;**	$Get_Verify_On_Write - Get Status of Verify on write flag
  6974                                  ;
  6975                                  ;	ENTRY	none
  6976                                  ;	EXIT	(al) = value of VERIFY flag
  6977                                  ;	USES	all
  6978                                  
  6979                                  
  6980                                  _$GET_VERIFY_ON_WRITE:
  6981                                  
  6982                                  ;hkn; SS override
  6983 00001AB5 36A0[CB02]              	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
  6984 00001AB9 C3                      	retn
  6985                                  
  6986                                  ;**	$Set_Verify_On_Write - Set Status of Verify on write flag
  6987                                  ;
  6988                                  ;	ENTRY	(al) = value of VERIFY flag
  6989                                  ;	EXIT	none
  6990                                  ;	USES	all
  6991                                  
  6992                                  _$SET_VERIFY_ON_WRITE:
  6993                                  
  6994 00001ABA 2401                    	AND	AL,1
  6995                                  ;hkn; SS override
  6996 00001ABC 36A2[CB02]              	MOV	[SS:VERFLG],AL	; Retro DOS v2.0 - 12/03/2018
  6997                                  RET27:	; 18/07/2018
  6998 00001AC0 C3                      	retn
  6999                                  
  7000                                  ; 19/07/2018 - Retro DOS v3.0
  7001                                  
  7002                                  ;BREAK <$International - return country-dependent information>
  7003                                  
  7004                                  ;----------------------------------------------------------------------------
  7005                                  ;
  7006                                  ; Procedure Name : $INTERNATIONAL
  7007                                  ;
  7008                                  ; Inputs:
  7009                                  ;	MOV	AH,International
  7010                                  ;	MOV	AL,country	(al = 0 => current country)
  7011                                  ;      [MOV	BX,country]
  7012                                  ;	LDS	DX,block
  7013                                  ;	INT	21
  7014                                  ; Function:
  7015                                  ;	give users an idea of what country the application is running
  7016                                  ; Outputs:
  7017                                  ;	IF DX != -1 on input (get country)
  7018                                  ;	  AL = 0 means return current country table.
  7019                                  ;	  0<AL<0FFH means return country table for country AL
  7020                                  ;	  AL = 0FF means return country table for country BX
  7021                                  ;	  No Carry:
  7022                                  ;	     Register BX will contain the 16-bit country code.
  7023                                  ;	     Register AL will contain the low 8 bits of the country code.
  7024                                  ;	     The block pointed to by DS:DX is filled in with the information
  7025                                  ;	     for the particular country.
  7026                                  ;		BYTE  Size of this table excluding this byte and the next
  7027                                  ;		BYTE  Country code represented by this table
  7028                                  ;			A sequence of n bytes, where n is the number specified
  7029                                  ;			by the first byte above and is not > internat_block_max,
  7030                                  ;			in the correct order for being returned by the
  7031                                  ;			INTERNATIONAL call as follows:
  7032                                  ;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
  7033                                  ;		5 BYTE	Currency symbol null terminated
  7034                                  ;		2 BYTE	thousands separator null terminated
  7035                                  ;		2 BYTE	Decimal point null terminated
  7036                                  ;		2 BYTE	Date separator null terminated
  7037                                  ;		2 BYTE	Time separator null terminated
  7038                                  ;		1 BYTE	Bit field.  Currency format.
  7039                                  ;			Bit 0.	=0 $ before #  =1 $ after #
  7040                                  ;			Bit 1.	no. of spaces between # and $ (0 or 1)
  7041                                  ;		1 BYTE	No. of significant decimal digits in currency
  7042                                  ;		1 BYTE	Bit field.  Time format.
  7043                                  ;			Bit 0.	=0 12 hour clock  =1 24 hour
  7044                                  ;		DWORD	Call address of case conversion routine
  7045                                  ;		2 BYTE	Data list separator null terminated.
  7046                                  ;	  Carry:
  7047                                  ;	     Register AX has the error code.
  7048                                  ;	IF DX = -1 on input (set current country)
  7049                                  ;	  AL = 0 is an error
  7050                                  ;	  0<AL<0FFH means set current country to country AL
  7051                                  ;	  AL = 0FF means set current country to country BX
  7052                                  ;	  No Carry:
  7053                                  ;	    Current country SET
  7054                                  ;	    Register AL will contain the low 8 bits of the country code.
  7055                                  ;	  Carry:
  7056                                  ;	     Register AX has the error code.
  7057                                  ;-----------------------------------------------------------------------------
  7058                                  
  7059                                  ;procedure   $INTERNATIONAL,NEAR   ; DOS 3.3
  7060                                  
  7061                                  _$INTERNATIONAL:  ; IBMDOS.COM (MSDOS 3.3), offset 1992h
  7062                                  	 
  7063 00001AC1 3CFF                    	CMP	AL,0FFH
  7064 00001AC3 7404                    	JZ	short BX_HAS_CODE	; -1 means country code is in BX
  7065 00001AC5 88C3                    	MOV	BL,AL			; Put AL country code in BX
  7066 00001AC7 30FF                    	XOR	BH,BH
  7067                                  BX_HAS_CODE:
  7068 00001AC9 1E                      	PUSH	DS
  7069 00001ACA 07                      	POP	ES
  7070 00001ACB 52                      	PUSH	DX
  7071 00001ACC 5F                      	POP	DI			; User buffer to ES:DI
  7072                                  
  7073                                  ;hkn; SS is DOSDATA
  7074                                  ;	context DS
  7075                                  
  7076 00001ACD 16                      	push	ss
  7077 00001ACE 1F                      	pop	ds
  7078                                  
  7079 00001ACF 83FFFF                  	CMP	DI,-1
  7080 00001AD2 745F                    	JZ	short international_set
  7081 00001AD4 09DB                    	OR	BX,BX
  7082 00001AD6 7505                    	JNZ	short international_find
  7083                                  
  7084                                  ;hkn; country_cdpg is in DOSDATA segment.
  7085 00001AD8 BE[3B10]                	MOV	SI,COUNTRY_CDPG
  7086                                  
  7087 00001ADB EB40                    	JMP	SHORT international_copy
  7088                                  
  7089                                  international_find:
  7090 00001ADD BD0000                  	MOV	BP,0			 ; flag it for GetCntry only
  7091 00001AE0 E80B00                  	CALL	international_get
  7092 00001AE3 7256                    	JC	short errtn
  7093 00001AE5 83FB00                  	CMP	BX,0			 ; nlsfunc finished it ?
  7094 00001AE8 7533                    	JNZ	SHORT international_copy ; no, copy by myself
  7095 00001AEA 89D3                    	MOV	BX,DX			 ; put country back
  7096 00001AEC EB3A                    	JMP	SHORT international_ok3
  7097                                  
  7098                                  international_get:
  7099                                  
  7100                                  ;hkn; country_cdpg is in DOSDATA segment.
  7101                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7102 00001AEE BE[3B10]                	MOV	SI,COUNTRY_CDPG
  7103                                  
  7104                                  	; MSDOS 6.0
  7105                                  	;CMP	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
  7106                                  	;retz				 ; return if equal
  7107                                  
  7108                                  	; MSDOS 3.3
  7109                                  	;cmp	bx,[SI+63h]
  7110 00001AF1 3B5C63                  	CMP	BX,[SI+DOS_CCDPG.ccDosCountry]
  7111 00001AF4 74CA                    	jz	short RET27
  7112                                  
  7113 00001AF6 89DA                    	MOV	DX,BX
  7114 00001AF8 31DB                    	XOR	BX,BX			; bx = 0, default code page
  7115                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7116                                  
  7117 00001AFA B80014                  	mov	ax,1400h
  7118 00001AFD CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7119                                  			; Return: AL = 00h not installed, OK to install
  7120                                  			; 01h not installed, not OK
  7121                                  			; FFh installed
  7122                                  	
  7123 00001AFF 3CFF                    	CMP	AL,0FFH
  7124 00001B01 7516                    	JNZ	short interr		; not in memory
  7125                                  	;cmp	bp,0
  7126 00001B03 09ED                    	or	bp,bp			; GetCntry ?
  7127 00001B05 7507                    	JNZ	short stcdpg
  7128                                  	;CallInstall GetCntry,NLSFUNC,4	; get country info
  7129                                  
  7130 00001B07 B80414                  	mov     ax,1404h
  7131 00001B0A CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7132                                  			; BX = code page, DX = country code,
  7133                                  			; DS:SI -> internal code page structure
  7134                                  			; ES:DI -> user buffer
  7135                                  			; Return: AL = status
  7136                                  
  7137 00001B0C EB05                    	JMP	short chkok
  7138                                  	
  7139                                  	;nop
  7140                                  
  7141                                  stcdpg:
  7142                                  	;CallInstall SetCodePage,NLSFUNC,3  ; set country info
  7143                                  
  7144 00001B0E B80314                  	mov     ax,1403h
  7145 00001B11 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - SET COUNTRY INFO
  7146                                  			; DS:SI -> internal code page structure
  7147                                  			; BX = code page, DX = country code
  7148                                  			; Return: AL = status
  7149                                  chkok:
  7150 00001B13 08C0                    	or	al,al			; success ?
  7151                                  	;retz				; yes
  7152 00001B15 74A9                    	jz	short RET27
  7153                                  
  7154                                  setcarry:
  7155 00001B17 F9                      	STC				; set carry
  7156 00001B18 C3                      	retn
  7157                                  interr:
  7158 00001B19 B0FF                    	MOV	AL,0FFH			; flag nlsfunc error
  7159 00001B1B EBFA                    	JMP	short setcarry
  7160                                  
  7161                                  international_copy:
  7162                                  
  7163                                  ;hkn; country_cdpg is in DOSDATA segment.
  7164                                  ;hkn; use ss override to access COUNTRY_CDPG fields
  7165                                  	; MSDOS 6.0
  7166                                  	;MOV	BX,ss:[SI.ccDosCountry]	 ; = current country id;smr;SS Override
  7167                                  	;MOV	SI,OFFSET DOSDATA:COUNTRY_CDPG.ccDFormat
  7168                                  
  7169                                  	; MSDOS 3.3
  7170                                  	;mov	bx,[SI+63h]
  7171 00001B1D 8B5C63                  	mov	BX,[SI+DOS_CCDPG.ccDosCountry]
  7172 00001B20 BE[A210]                	mov	SI,COUNTRY_CDPG+DOS_CCDPG.ccDFormat ; 08/09/2018
  7173                                  
  7174                                  	;mov	cx,24
  7175 00001B23 B91800                  	MOV	CX,OLD_COUNTRY_SIZE
  7176                                  
  7177                                  	; MSDOS 6.0
  7178                                  ;hkn;	must set up DS to SS so that international info can be copied
  7179                                  	;push	ds
  7180                                  	;push	ss					; cs -> ss
  7181                                  	;pop	ds
  7182                                  
  7183 00001B26 F3A4                    	REP	MOVSB			;copy country info
  7184                                  
  7185                                  	; MSDOS 6.0
  7186                                  ;hkn;	restore ds
  7187                                  	;pop	ds
  7188                                  
  7189                                  international_ok3:
  7190 00001B28 E81EFB                  	call	Get_User_Stack
  7191                                  ;ASSUME	DS:NOTHING
  7192                                  	;MOV	[SI+2],BX
  7193 00001B2B 895C02                  	MOV	[SI+user_env.user_BX],BX
  7194                                  international_ok:
  7195 00001B2E 89D8                    	MOV	AX,BX			; Return country code in AX too.
  7196 00001B30 E968FC                  	jmp	SYS_RET_OK
  7197                                  
  7198                                  international_set:
  7199                                  
  7200                                  ;hkn; ASSUME	DS:DOSGROUP
  7201                                  ;ASSUME	DS:DOSDATA
  7202                                  
  7203 00001B33 BD0100                  	MOV	BP,1			; flag it for SetCodePage only
  7204 00001B36 E8B5FF                  	CALL	international_get
  7205 00001B39 73F3                    	JNC	short international_ok
  7206                                  errtn:
  7207 00001B3B 3CFF                    	CMP	AL,0FFH
  7208 00001B3D 7403                    	JZ	short errtn2
  7209                                  errtn1:
  7210 00001B3F E962FC                  	jmp	SYS_RET_ERR		; return what we got from NLSFUNC
  7211                                  errtn2:
  7212                                  	;error	error_invalid_function	; NLSFUNC not existent
  7213                                  
  7214                                  	;mov	al,1
  7215 00001B42 B001                    	mov	al,error_invalid_function 
  7216                                  	;jmp	short errtn1
  7217                                  errtn3:
  7218 00001B44 E95DFC                  	jmp	SYS_RET_ERR
  7219                                  
  7220                                  ;EndProc $INTERNATIONAL
  7221                                  
  7222                                  ; 19/07/2018
  7223                                  
  7224                                  ;BREAK <$GetExtCntry - return extended country-dependent information>
  7225                                  
  7226                                  ;---------------------------------------------------------------------------
  7227                                  ;
  7228                                  ; Procedure Name : $GetExtCntry
  7229                                  ;
  7230                                  ; Inputs:
  7231                                  ;	if AL >= 20H
  7232                                  ;	  AL= 20H    capitalize single char, DL= char
  7233                                  ;	      21H    capitalize string, CX= string length
  7234                                  ;	      22H    capitalize ASCIIZ string
  7235                                  ;	      23H    YES/NO check, DL=1st char DH= 2nd char (DBCS)
  7236                                  ;	      80H bit 0 = use normal upper case table
  7237                                  ;		      1 = use file upper case table
  7238                                  ;	   DS:DX points to string
  7239                                  ;
  7240                                  ;	else
  7241                                  ;
  7242                                  ;	MOV	AH,GetExtCntry	 ; DOS 3.3
  7243                                  ;	MOV	AL,INFO_ID	( info type,-1 selects all )
  7244                                  ;	MOV	BX,CODE_PAGE	( -1 = active code page )
  7245                                  ;	MOV	DX,COUNTRY_ID	( -1 = active country )
  7246                                  ;	MOV	CX,SIZE 	( amount of data to return )
  7247                                  ;	LES	DI,COUNTRY_INFO ( buffer for returned data )
  7248                                  ;	INT	21
  7249                                  ; Function:
  7250                                  ;	give users extended country dependent information
  7251                                  ;	or capitalize chars
  7252                                  ; Outputs:
  7253                                  ;	  No Carry:
  7254                                  ;	     extended country info is succesfully returned
  7255                                  ;	  Carry:
  7256                                  ;	     Register AX has the error code.
  7257                                  ;	     AX=0, NO	 for YES/NO CHECK
  7258                                  ;		1, YES
  7259                                  ;-------------------------------------------------------------------------------
  7260                                  
  7261                                  ;procedure   $GetExtCntry,NEAR	; DOS 3.3
  7262                                  
  7263                                  	; MSDOS 6.0
  7264                                  _$GetExtCntry:
  7265 00001B47 3C20                    	CMP	AL,CAP_ONE_CHAR 	; < 20H ?
  7266 00001B49 7262                    	JB	short notcap
  7267                                  capcap: 				;
  7268 00001B4B A880                    	TEST	AL,UPPER_TABLE		; which upper case table
  7269 00001B4D 7505                    	JNZ	short fileupper		; file upper case
  7270                                  
  7271                                  ;hkn; UCASE_TAB in DOSDATA
  7272 00001B4F BB[C610]                	MOV	BX,UCASE_TAB+2		; get normal upper case
  7273 00001B52 EB03                    	JMP	SHORT capit
  7274                                  
  7275                                  fileupper:
  7276                                  ;hkn; FILE_UCASE_TAB in DOSDATA
  7277 00001B54 BB[4811]                	MOV	BX,FILE_UCASE_TAB+2 ; get file upper case
  7278                                  capit:					;
  7279 00001B57 3C20                    	CMP	AL,CAP_ONE_CHAR 	; cap one char ?
  7280 00001B59 750D                    	JNZ	short chkyes		; no
  7281 00001B5B 88D0                    	MOV	AL,DL			; set up AL
  7282 00001B5D E8B03D                  	call	GETLET3 		; upper case it
  7283 00001B60 E8E6FA                  	call	Get_User_Stack		; get user stack
  7284 00001B63 884406                  	MOV	[SI+user_env.user_DX],AL ; user's DL=AL
  7285 00001B66 EB1C                    	JMP	SHORT nono		; done
  7286                                  chkyes: 				;
  7287 00001B68 3C23                    	CMP	AL,CHECK_YES_NO		; check YES or NO ?
  7288 00001B6A 751B                    	JNZ	short capstring		; no
  7289 00001B6C 31C0                    	XOR	AX,AX			; presume NO
  7290                                  		      
  7291                                  ;hkn; NLS_YES, NLS_NO, NLS_yes2, NLS_no2 is defined in msdos.cl3 which is
  7292                                  ;hkn; included in yesno.asm in the DOSCODE segment.
  7293                                  
  7294                                  	; 06/08/2018 - Retro DOS v3.0
  7295                                  	;CMP	DL,[cs:NLS_YES]		; is 'Y' ?
  7296 00001B6E 80FA59                  	cmp	DL,'Y'
  7297 00001B71 7410                    	JZ	short yesyes		; yes
  7298                                  	;CMP	DL,[cs:NLS_yes2]	; is 'y' ?
  7299 00001B73 80FA79                  	cmp	dl,'y'
  7300 00001B76 740B                    	JZ	short yesyes		; yes
  7301 00001B78 80FA4E                  	cmp	dl,'N'
  7302                                  	;CMP	DL,[cs:NLS_NO]		; is  'N'?
  7303 00001B7B 7407                    	JZ	short nono		; no
  7304 00001B7D 80FA6E                  	CMP	DL,'n'
  7305                                  	;CMP	DL,[cs:NLS_no2]		; is 'n' ?
  7306 00001B80 7402                    	JZ	short nono		; no
  7307                                  ;dbcs_char:				;
  7308 00001B82 40                      	INC	AX			; not YES or NO
  7309                                  yesyes: 				;
  7310 00001B83 40                      	INC	AX			; return 1
  7311                                  nono:					;
  7312 00001B84 E914FC                  	jmp	SYS_RET_OK		; done
  7313                                  capstring:				;
  7314 00001B87 89D6                    	MOV	SI,DX			; si=dx
  7315 00001B89 3C21                    	CMP	AL,CAP_STRING		; cap string ?
  7316 00001B8B 750F                    	JNZ	short capascii		; no
  7317 00001B8D 09C9                    	OR	CX,CX			; check count 0
  7318 00001B8F 74F3                    	JZ	short nono		; yes finished
  7319                                  concap: 				;
  7320 00001B91 AC                      	LODSB				; get char
  7321 00001B92 E87B3D                  	call	GETLET3 		; upper case it
  7322 00001B95 8844FF                  	MOV	byte [SI-1],AL		; store back
  7323                                  next99: 				;
  7324 00001B98 E2F7                    	LOOP	concap			; continue
  7325 00001B9A EBE8                    	JMP	short nono		; done
  7326                                  capascii:				;
  7327 00001B9C 3C22                    	CMP	AL,CAP_ASCIIZ		; cap ASCIIZ string ?
  7328 00001B9E 7545                    	JNZ	short capinval		; no
  7329                                  concap2:				;
  7330 00001BA0 AC                      	LODSB				; get char
  7331 00001BA1 08C0                    	or	al,al			; end of string ?
  7332 00001BA3 74DF                    	JZ	short nono		; yes
  7333 00001BA5 E8683D                  	call	GETLET3 		; upper case it
  7334 00001BA8 8844FF                  	MOV	[SI-1],AL		; store back
  7335 00001BAB EBF3                    	JMP	short concap2 		; continue
  7336                                  
  7337                                  	; MSDOS 3.3 ($ MSDOS 6.0)
  7338                                  
  7339                                  ; Offset 1A19h in IBMDOS.COM (MSDOS 3.3), 1987 	
  7340                                  ; _$GetExtCntry:
  7341                                  
  7342                                  notcap:
  7343 00001BAD 83F905                  	CMP	CX,5			; minimum size is 5
  7344 00001BB0 7279                    	jb	short sizeerror
  7345                                  
  7346                                  GEC_CONT:
  7347                                  ;hkn; SS is DOSDATA
  7348                                  	;context DS
  7349                                  
  7350 00001BB2 16                      	push	ss
  7351                                  	;pop	es  ; ! (Retro DOS v3.0 BUG) !
  7352 00001BB3 1F                      	pop	ds  ; 17/05/2019 - BugFix
  7353                                  	
  7354                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7355 00001BB4 BE[3B10]                	MOV	SI,COUNTRY_CDPG
  7356                                  
  7357 00001BB7 83FAFF                  	CMP	DX,-1			; active country ?
  7358 00001BBA 7503                    	JNZ	short GETCDPG 		; no
  7359                                  
  7360                                  ;hkn; use DS override to accesss country_cdpg fields
  7361                                  	;mov	dx,[si+63h]
  7362 00001BBC 8B5463                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]
  7363                                  					; get active country id;smr;use DS
  7364                                  GETCDPG:
  7365 00001BBF 83FBFF                  	CMP	BX,-1			; active code page?
  7366 00001BC2 7503                    	JNZ	short CHKAGAIN		; no, check again
  7367                                  
  7368                                  ;hkn; use DS override to accesss country_cdpg fields
  7369                                  	;mov	bx,[si+65h]
  7370 00001BC4 8B5C65                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7371                                  					; get active code page id;smr;Use DS
  7372                                  CHKAGAIN:
  7373                                  	;cmp	dx,[si+63h]
  7374 00001BC7 3B5463                  	CMP	DX,[SI+DOS_CCDPG.ccDosCountry]
  7375                                  					; same as active country id?;smr;use DS
  7376 00001BCA 7552                    	JNZ	short CHKNLS		; no
  7377                                  	;cmp	bx,[si+65h]
  7378 00001BCC 3B5C65                  	CMP	BX,[SI+DOS_CCDPG.ccDosCodePage]	
  7379                                  					; same as active code pg id?;smr;use DS
  7380 00001BCF 754D                    	JNZ	short CHKNLS		; no
  7381                                  CHKTYPE:
  7382                                  	;mov	bx,[si+48h]
  7383 00001BD1 8B5C48                  	MOV	BX,[SI+DOS_CCDPG.ccSysCodePage]	
  7384                                  					; bx = sys code page id;smr;use DS
  7385                                  ;	CMP	AL,SetALL		; select all?
  7386                                  ;	JNZ	short SELONE
  7387                                  ;	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccNumber_of_entries
  7388                                  ;SELONE:
  7389 00001BD4 51                      	PUSH	CX			; save cx
  7390                                  	;mov	cx,[si+4Ah]
  7391 00001BD5 8B4C4A                  	MOV	CX,[SI+DOS_CCDPG.ccNumber_of_entries]	;smr;use DS
  7392 00001BD8 BE[8710]                	MOV	SI,COUNTRY_CDPG+DOS_CCDPG.ccSetUcase   ;smr;CDPG in DOSDATA
  7393                                  NXTENTRY:
  7394 00001BDB 3A04                    	CMP	AL,[SI] 		; compare info type;smr;use DS
  7395 00001BDD 740B                    	JZ	short FOUNDIT
  7396 00001BDF 83C605                  	ADD	SI,5			; next entry
  7397 00001BE2 E2F7                    	LOOP	NXTENTRY
  7398 00001BE4 59                      	POP	CX
  7399                                  capinval:
  7400                                  	;error	error_invalid_function	; info type not found
  7401                                  	;mov	al,1
  7402 00001BE5 B001                    	mov	al,error_invalid_function
  7403 00001BE7 E9BAFB                  	jmp	SYS_RET_ERR
  7404                                  
  7405                                  FOUNDIT:
  7406 00001BEA A4                      	MOVSB				; move info id byte
  7407 00001BEB 59                      	POP	CX			; retsore char count
  7408                                  	;cmp	al,1
  7409 00001BEC 3C01                    	CMP	AL,SetCountryInfo	; select country info type ?
  7410 00001BEE 7415                    	JZ	short setsize
  7411 00001BF0 B90400                  	MOV	CX,4			; 4 bytes will be moved
  7412 00001BF3 B80500                  	MOV	AX,5			; 5 bytes will be returned in CX
  7413                                  OK_RETN:
  7414 00001BF6 F3A4                    	REP	MOVSB			; copy info
  7415 00001BF8 89C1                    	MOV	CX,AX			; CX = actual length returned
  7416 00001BFA 89D8                    	MOV	AX,BX			; return sys code page in ax
  7417                                  GETDONE:
  7418 00001BFC E84AFA                  	call	Get_User_Stack		; return actual length to user's CX
  7419                                  	;mov	[si+4],cx 
  7420 00001BFF 894C04                  	MOV	[SI+user_env.user_CX],CX
  7421                                  	; 26/07/2019
  7422                                  	;jmp	SYS_RET_OK
  7423 00001C02 E999FB                  	jmp	SYS_RET_OK_clc
  7424                                  setsize:
  7425 00001C05 83E903                  	SUB	CX,3			; size after length field
  7426 00001C08 390C                    	CMP	[SI],CX			; less than table size ;smr;use ds
  7427 00001C0A 7302                    	JAE	short setsize2		; no
  7428 00001C0C 8B0C                    	MOV	CX,[SI]			; truncate to table size ;smr;use ds
  7429                                  setsize2:
  7430 00001C0E 26890D                  	MOV	[ES:DI],CX		; copy actual length to user's
  7431 00001C11 83C702                  	ADD	DI,2			; update index
  7432 00001C14 83C602                  	ADD	SI,2
  7433 00001C17 89C8                    	MOV	AX,CX
  7434 00001C19 83C003                  	ADD	AX,3			; AX has the actual length
  7435 00001C1C EBD8                    	JMP	short OK_RETN 		; go move it
  7436                                  CHKNLS:
  7437 00001C1E 30E4                    	XOR	AH,AH
  7438 00001C20 50                      	PUSH	AX			; save info type
  7439 00001C21 5D                      	POP	BP			; bp = info type
  7440                                  	
  7441                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7442                                  
  7443 00001C22 B80014                  	mov     ax, 1400h
  7444 00001C25 CD2F                    	int     2Fh     ; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7445                                  			; Return: AL = 00h not installed, OK to install
  7446                                  			; 01h not installed, not OK
  7447                                  			; FFh installed
  7448                                  	
  7449 00001C27 3CFF                    	CMP	AL,0FFH
  7450 00001C29 7405                    	JZ	short NLSNXT		; in memory
  7451                                  
  7452                                  sizeerror:
  7453                                  	;error	error_invalid_function
  7454                                  	;mov	al,1
  7455 00001C2B B001                    	mov	al,error_invalid_function
  7456 00001C2D E974FB                  	jmp	SYS_RET_ERR
  7457                                  
  7458                                  NLSNXT: 
  7459                                  	;CallInstall GetExtInfo,NLSFUNC,2 ;get extended info
  7460                                  
  7461 00001C30 B80214                  	mov     ax, 1402h
  7462 00001C33 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - GET COUNTRY INFO
  7463                                  			; BP = subfunction, BX = code page
  7464                                  			; DX = country code, DS:SI -> internal code page structure
  7465                                  			; ES:DI -> user buffer, CX = size of user buffer
  7466                                  			; Return: AL = status
  7467                                  			; 00h successful
  7468                                  			; else DOS error code
  7469                                  
  7470 00001C35 3C00                    	CMP	AL,0			; success ?
  7471 00001C37 7508                    	JNZ	short NLSERROR
  7472 00001C39 8B4448                  	mov     ax,[si+48h]
  7473 00001C3C 8B4448                  	MOV	AX,[SI+DOS_CCDPG.ccSysCodePage]	
  7474                                  			; ax = sys code page id;smr;use ds;
  7475                                  			;BUGBUG;check whether DS is OK after the above calls
  7476 00001C3F EBBB                    	JMP	short GETDONE
  7477                                  NLSERROR:
  7478 00001C41 E960FB                  	jmp	SYS_RET_ERR		; return what is got from NLSFUNC
  7479                                  
  7480                                  ;EndProc $GetExtCntry
  7481                                  
  7482                                  ;BREAK <$GetSetCdPg - get or set global code page>
  7483                                  
  7484                                  ;**	$GetSetCdPg - Get or Set Global Code Page
  7485                                  ;
  7486                                  ;   System call format:
  7487                                  ;
  7488                                  ;	MOV	AH,GetSetCdPg	; DOS 3.3
  7489                                  ;	MOV	AL,n		; n = 1 : get code page, n = 2 : set code page
  7490                                  ;	MOV	BX,CODE_PAGE	( set code page only)
  7491                                  ;	INT	21
  7492                                  ;
  7493                                  ;	ENTRY	(al) = n
  7494                                  ;		(bx) = code page
  7495                                  ;	EXIT	'C' clear
  7496                                  ;		  global code page is set	(set global code page)
  7497                                  ;		  (BX) = active code page id	(get global code page)
  7498                                  ;		  (DX) = system code page id	(get global code page)
  7499                                  ;		'C' set
  7500                                  ;		  (AX) = error code
  7501                                  
  7502                                  ;procedure  $GetSetCdPg,NEAR   ; DOS 3.3
  7503                                  
  7504                                  _$GetSetCdPg:
  7505                                  
  7506                                  ;hkn; SS is DOSDATA
  7507                                  	;context DS
  7508                                  
  7509 00001C44 16                      	push	ss
  7510 00001C45 1F                      	pop	ds
  7511                                  
  7512                                  ;hkn; COUNTRY_CDPG is in DOSDATA
  7513 00001C46 BE[3B10]                	MOV	SI,COUNTRY_CDPG
  7514                                  
  7515 00001C49 3C01                    	CMP	AL,1		       ; get global code page
  7516 00001C4B 7512                    	JNZ	short setglpg 	       ; set global cod epage
  7517                                  	;mov	bx,[si+65h]
  7518 00001C4D 8B5C65                  	MOV	BX,[SI+DOS_CCDPG.ccDosCodePage]
  7519                                  					; get active code page id;smr;use ds
  7520                                  	;mov	dx,[si+48h]
  7521 00001C50 8B5448                  	MOV	DX,[SI+DOS_CCDPG.ccSysCodePage]
  7522                                  				  	; get sys code page id;smr;use ds
  7523 00001C53 E8F3F9                  	call	Get_User_Stack
  7524                                  ;ASSUME DS:NOTHING
  7525                                  	;mov	[si+2],bx
  7526 00001C56 895C02                  	MOV	[SI+user_env.user_BX],BX ; update returned bx
  7527                                  	;mov	[si+6],dx
  7528 00001C59 895406                  	MOV	[SI+user_env.user_DX],DX ; update returned dx
  7529                                  OK_RETURN:
  7530                                  	;transfer SYS_RET_OK
  7531 00001C5C E93CFB                  	jmp	SYS_RET_OK
  7532                                  
  7533                                  ;hkn; ASSUME DS:DOSGROUP
  7534                                  ;ASSUME	DS:DOSDATA
  7535                                  
  7536                                  setglpg:
  7537 00001C5F 3C02                    	CMP	AL,2
  7538 00001C61 7534                    	JNZ	short nomem
  7539                                  ;;;;;;; CMP	BX,[SI+DOS_CCDPG.ccDosCodePage] ; same as active code page
  7540                                  ;;;;;;; JZ	short OK_RETURN		; yes
  7541                                  	;mov	dx,[si+63h]
  7542 00001C63 8B5463                  	MOV	DX,[SI+DOS_CCDPG.ccDosCountry]	;smr;use ds
  7543                                  	;CallInstall NLSInstall,NLSFUNC,0 ; check if NLSFUNC in memory
  7544 00001C66 B80014                  	mov     ax, 1400h
  7545 00001C69 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - INSTALLATION CHECK
  7546                                  			; Return: AL = 00h not installed, OK to install
  7547                                  			; 01h not installed, not OK
  7548                                  			; FFh installed
  7549 00001C6B 3CFF                    	CMP	AL,0FFH
  7550 00001C6D 7528                    	JNZ	short nomem		; not in memory
  7551                                  	;CallInstall SetCodePage,NLSFUNC,1  ;set the code page
  7552 00001C6F B80114                  	mov     ax, 1401h
  7553 00001C72 CD2F                    	int     2Fh	; - Multiplex - NLSFUNC.COM - CHANGE CODE PAGE
  7554                                  			; DS:SI -> internal code page structure
  7555                                  			; BX = new code page, DX = country code???
  7556                                  			; Return: AL = status
  7557                                  			; 00h successful
  7558                                  			; else DOS error code
  7559                                  	;cmp	al,0
  7560 00001C74 08C0                    	or	al,al			   ; success ?
  7561 00001C76 74E4                    	JZ	short OK_RETURN		   ; yes
  7562 00001C78 3C41                    	CMP	AL,65			   ; set device code page failed
  7563 00001C7A 7518                    	JNZ	short seterr
  7564 00001C7C B84100                  	MOV	AX,65
  7565 00001C7F A3[F002]                	MOV	[EXTERR],AX
  7566                                  	;mov	byte [EXTERR_ACTION],6
  7567                                  	;mov	byte [EXTERR_CLASS],5
  7568                                  	;mov	byte [EXTERR_LOCUS],4
  7569 00001C82 C606[F202]06            	MOV	byte [EXTERR_ACTION],errACT_Ignore
  7570 00001C87 C606[F302]05            	MOV	byte [EXTERR_CLASS],errCLASS_HrdFail
  7571 00001C8C C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
  7572                                  	;transfer From_GetSet
  7573 00001C91 E918FB                  	jmp	From_GetSet
  7574                                  
  7575                                  seterr:
  7576                                  	;transfer SYS_RET_ERR
  7577 00001C94 E90DFB                  	jmp	SYS_RET_ERR
  7578                                  
  7579                                  nomem:
  7580                                  	;error	error_invalid_function ; function not defined
  7581                                  	;mov	al,1
  7582 00001C97 B001                    	mov	al,error_invalid_function
  7583 00001C99 EBF9                    	jmp	short seterr
  7584                                  
  7585                                  ;EndProc $GetSetCdPg
  7586                                  
  7587                                  ;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>
  7588                                  
  7589                                  ;**	$Get_Drive_Freespace - Return amount of drive free space
  7590                                  ;
  7591                                  ;	$Get_Drive_Freespace returns the # of free allocation units on a
  7592                                  ;		drive.
  7593                                  ;
  7594                                  ;	This call returns the same info in the same registers (except for the
  7595                                  ;	FAT pointer) as the old FAT pointer calls
  7596                                  ;
  7597                                  ;	ENTRY	DL = Drive number
  7598                                  ;	EXIT	AX = Sectors per allocation unit
  7599                                  ;		   = -1 if bad drive specified
  7600                                  ;		On User Stack
  7601                                  ;		    BX = Number of free allocation units
  7602                                  ;		    DX = Total Number of allocation units on disk
  7603                                  ;		    CX = Sector size
  7604                                  
  7605                                  ;procedure   $GET_DRIVE_FREESPACE,NEAR
  7606                                  
  7607                                  _$GET_DRIVE_FREESPACE:
  7608                                  
  7609                                  ;hkn; SS is DOSDATA
  7610                                  	;context DS
  7611 00001C9B 16                      	push	ss
  7612 00001C9C 1F                      	pop	ds
  7613                                  
  7614 00001C9D 88D0                    	MOV	AL,DL
  7615                                  	;invoke	GetThisDrv		; Get drive
  7616 00001C9F E81550                  	call	GETTHISDRV
  7617                                  SET_AX_RET:
  7618 00001CA2 7218                    	JC	short BADFDRV
  7619                                  	;invoke	DISK_INFO
  7620 00001CA4 E87F1C                  	call	DISK_INFO
  7621 00001CA7 87D3                    	XCHG	DX,BX
  7622 00001CA9 72F7                    	JC	short SET_AX_RET	; User FAILed to I 24
  7623 00001CAB 30E4                    	XOR	AH,AH			; Chuck Fat ID byte
  7624                                  DoSt:
  7625 00001CAD E899F9                  	call	Get_User_Stack
  7626                                  ;ASSUME	DS:NOTHING
  7627                                  	;mov	[si+6],dx
  7628                                  	;mov	[si+4],cx
  7629                                  	;mov	[si+2],bx
  7630 00001CB0 895406                  	MOV	[SI+user_env.user_DX],DX
  7631 00001CB3 894C04                  	MOV	[SI+user_env.user_CX],CX
  7632 00001CB6 895C02                  	MOV	[SI+user_env.user_BX],BX
  7633                                  	;MOV	[SI+user_env.user_AX],AX
  7634 00001CB9 8904                    	mov     [si],ax
  7635                                  	;return
  7636 00001CBB C3                      	retn
  7637                                  
  7638                                  BADFDRV:
  7639                                  	; MSDOS 3.3
  7640                                  	;mov	al,0Fh
  7641 00001CBC B00F                    	mov	al,error_invalid_drive	; Assume error
  7642                                  
  7643                                  	;invoke	FCB_RET_ERR
  7644 00001CBE E8F9FA                  	call	FCB_RET_ERR
  7645 00001CC1 B8FFFF                  	MOV	AX,-1
  7646 00001CC4 EBE7                    	JMP	short DoSt
  7647                                  
  7648                                  ;EndProc $GET_DRIVE_FREESPACE
  7649                                  
  7650                                  ;	BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>
  7651                                  
  7652                                  ;**	$Get_DMA - Get Disk Transfer Address
  7653                                  ;
  7654                                  ;	ENTRY	none
  7655                                  ;	EXIT	ES:BX is current transfer address
  7656                                  ;	USES	all
  7657                                  
  7658                                  _$GET_DMA:
  7659 00001CC6 368B1E[F802]            	MOV	BX,[SS:DMAADD]
  7660 00001CCB 368B0E[FA02]            	MOV	CX,[SS:DMAADD+2]
  7661 00001CD0 E876F9                  	call	Get_User_Stack
  7662                                  	;mov	[si+2],bx
  7663                                  	;mov	[si+10h],cx
  7664 00001CD3 895C02                  	MOV	[SI+user_env.user_BX],BX
  7665 00001CD6 894C10                  	MOV	[SI+user_env.user_ES],CX
  7666 00001CD9 C3                      	retn
  7667                                  
  7668                                  ;**	$Set_DMA - Set Disk Transfer Address
  7669                                  ;
  7670                                  ;	ENTRY	DS:DX is current transfer address
  7671                                  ;	EXIT	none
  7672                                  ;	USES	all
  7673                                  
  7674                                  _$SET_DMA:
  7675 00001CDA 368916[F802]            	MOV	[SS:DMAADD],DX
  7676 00001CDF 368C1E[FA02]            	MOV	[SS:DMAADD+2],DS
  7677 00001CE4 C3                      	retn
  7678                                  
  7679                                  ;	BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>
  7680                                  
  7681                                  ;**	$Get_Default_Drive - Get Current Default Drive
  7682                                  ;
  7683                                  ;	ENTRY	none
  7684                                  ;	EXIT	(AL) = drive number
  7685                                  ;	USES	all
  7686                                  
  7687                                  _$GET_DEFAULT_DRIVE:
  7688 00001CE5 36A0[0203]              	MOV	AL,[SS:CURDRV]
  7689 00001CE9 C3                      	retn
  7690                                  
  7691                                  ;**	$Set_Default_Drive - Specify new Default Drive
  7692                                  ;
  7693                                  ;	ENTRY	(DL) = Drive number for new default drive
  7694                                  ;	EXIT	(AL) = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD
  7695                                  
  7696                                  _$SET_DEFAULT_DRIVE:
  7697 00001CEA 88D0                    	MOV	AL,DL
  7698 00001CEC FEC0                    	INC	AL			; A=1, B=2...
  7699 00001CEE E8AF4F                  	call	GetVisDrv		; see if visible drive
  7700 00001CF1 7204                    	JC	short SETRET		; errors do not set
  7701 00001CF3 36A2[0203]              	MOV	[SS:CURDRV],AL		; no, set
  7702                                  
  7703                                  SETRET:
  7704 00001CF7 36A0[4700]              	MOV	AL,[SS:CDSCOUNT]	; let user see what the count really is
  7705 00001CFB C3                      	retn
  7706                                  
  7707                                  
  7708                                  ;BREAK <$Get/Set_Interrupt_Vector - Get/Set interrupt vectors>
  7709                                  
  7710                                  ;**	$Get_Interrupt_Vector - Get Interrupt Vector
  7711                                  ;
  7712                                  ;	$Get_Interrupt_Vector is the official way for user pgms to get the
  7713                                  ;	contents of an interrupt vector.
  7714                                  ;
  7715                                  ;	ENTRY	(AL) = interrupt number
  7716                                  ;	EXIT	(ES:BX) = current interrupt vector
  7717                                  
  7718                                  _$GET_INTERRUPT_VECTOR:
  7719 00001CFC E81A00                  	CALL	RECSET
  7720 00001CFF 26C41F                  	LES	BX,[ES:BX]
  7721 00001D02 E844F9                  	call	Get_User_Stack
  7722                                  	;mov	[si+2],bx
  7723                                  	;mov	[si+10h],es
  7724 00001D05 895C02                  	MOV	[SI+user_env.user_BX],BX
  7725 00001D08 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7726 00001D0B C3                      	retn
  7727                                  
  7728                                  ;**	$Set_Interrupt_Vector - Set Interrupt Vector
  7729                                  ;
  7730                                  ;	$Set_Interrupt_Vector is the official way for user pgms to set the
  7731                                  ;	contents of an interrupt vector.
  7732                                  ;
  7733                                  ;	M004, M068: Also set A20OFF_COUNT to 1 if EXECA20OFF bit has been set 
  7734                                  ;	and if A20OFF_COUNT is non-zero. See under tag M003 in inc\dossym.inc 
  7735                                  ;	for explanation.
  7736                                  ;
  7737                                  ;	ENTRY	(AL) = interrupt number
  7738                                  ;		(ds:dx) = desired new vector value
  7739                                  ;	EXIT	none
  7740                                  ;	USES	all
  7741                                  
  7742                                  _$SET_INTERRUPT_VECTOR:
  7743 00001D0C E80A00                  	CALL	RECSET
  7744 00001D0F FA                      	CLI				; Watch out!!!!! Folks sometimes use
  7745 00001D10 268917                  	MOV	[ES:BX],DX		;   this for hardware ints (like timer).
  7746 00001D13 268C5F02                	MOV	[ES:BX+2],DS
  7747 00001D17 FB                      	STI
  7748                                  					; M004, M068 - Start
  7749                                  	; MSDOS 6.0
  7750                                  	;test	byte [DOS_FLAG],EXECA20OFF
  7751                                  					; Q: was the previous call an int 21
  7752                                  					;    exec call
  7753                                  	;jnz	short siv_1		; Y: go set count
  7754 00001D18 C3                      	retn				; N: return
  7755                                  
  7756                                  ;siv_1:	
  7757                                  	;cmp	byte [A20OFF_COUNT],0	; Q: is count 0
  7758                                  	;jne	short siv_2		; N: done 
  7759                                  	;mov	byte [A20OFF_COUNT],1	; Y: set it to 1 to indicate to dos 
  7760                                  					; dispatcher to turn A20 Off before 
  7761                                  					; returning to user.
  7762                                  ;siv_2:
  7763                                  	;retn				; M004, M068 - End
  7764                                  	
  7765                                  RECSET:
  7766 00001D19 31DB                    	XOR	BX,BX
  7767 00001D1B 8EC3                    	MOV	ES,BX
  7768 00001D1D 88C3                    	MOV	BL,AL
  7769 00001D1F D1E3                    	SHL	BX,1
  7770 00001D21 D1E3                    	SHL	BX,1
  7771 00001D23 C3                      	retn
  7772                                  
  7773                                  
  7774                                  ;	BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>
  7775                                  
  7776                                  ;**	$Char_Oper - Manipulate Switch Character
  7777                                  ;
  7778                                  ;	This function was put in to facilitate XENIX path/switch compatibility
  7779                                  ;
  7780                                  ;	ENTRY	AL = function:
  7781                                  ;		    0 - read switch char
  7782                                  ;		    1 - set switch char (char in DL)
  7783                                  ;		    2 - read device availability
  7784                                  ;			Always returns available
  7785                                  ;		    3 - set device availability
  7786                                  ;			No longer supported (NOP)
  7787                                  ;	EXIT	(al) = 0xff iff error
  7788                                  ;		(al) != 0xff if ok
  7789                                  ;		  (dl) = character/flag, iff "read switch char" subfunction
  7790                                  ;	USES	AL, DL
  7791                                  ;
  7792                                  ;	NOTE	This already obsolete function has been deactivated in DOS 5.0
  7793                                  ;		The character / is always returned for subfunction 0,
  7794                                  ;		subfunction 2 always returns -1, all other subfunctions are ignored.
  7795                                  
  7796                                  _$CHAR_OPER:
  7797                                  	; MSDOS 6.0
  7798                                  	;or	al,al				; get switch?
  7799                                  	;mov	dl,'/'				; assume yes
  7800                                  	;jz	short chop_1			; jump if yes
  7801                                  	;cmp	al,2				; check device availability?
  7802                                  	;mov	dl,-1				; assume yes
  7803                                  	;jz	short chop_1				; jump if yes
  7804                                  	;retn					; otherwise just quit
  7805                                  
  7806                                  ; subfunctions requiring return of value to user come here. DL holds
  7807                                  ; value to return
  7808                                  
  7809                                  ;chop_1:
  7810                                  	;call	Get_User_Stack
  7811                                  	;mov	[SI+user_env.user_DX],dx	; store value for user
  7812                                  	;retn
  7813                                  
  7814                                  	; MSDOS 3.3
  7815                                  	; Offset 1B87h in IBMDOS.COM (MSDOS 3.3), 1987
  7816 00001D24 16                      	push    ss
  7817 00001D25 1F                      	pop     ds
  7818 00001D26 3C01                    	cmp     al, 1
  7819 00001D28 720B                    	jb      short chop_1
  7820 00001D2A 740F                    	jz      short chop_2
  7821 00001D2C 3C03                    	cmp     al, 3
  7822 00001D2E 7210                    	jb      short chop_3
  7823 00001D30 7416                    	jz      short chop_5
  7824 00001D32 B0FF                    	mov     al, 0FFh
  7825 00001D34 C3                      	retn
  7826                                  chop_1:
  7827 00001D35 8A16[CD02]              	mov     dl,[chSwitch]
  7828 00001D39 EB07                    	jmp     short chop_4
  7829                                  chop_2:
  7830 00001D3B 8816[CD02]              	mov     [chSwitch], dl
  7831 00001D3F C3                      	retn
  7832                                  chop_3:
  7833 00001D40 B2FF                    	mov     dl, 0FFh
  7834                                  chop_4:
  7835 00001D42 E804F9                  	call    Get_User_Stack
  7836 00001D45 895406                  	mov     [si+6],dx
  7837                                  chop_5:
  7838 00001D48 C3                      	retn
  7839                                  
  7840                                  ;**	$GetExtendedError - Return Extended error code
  7841                                  ;
  7842                                  ;	This function reads up the extended error info from the static
  7843                                  ;	variables where it was stored.
  7844                                  ;
  7845                                  ;	ENTRY	none
  7846                                  ;	EXIT	AX = Extended error code (0 means no extended error)
  7847                                  ;		BL = recommended action
  7848                                  ;		BH = class of error
  7849                                  ;		CH = locus of error
  7850                                  ;		ES:DI = may be pointer
  7851                                  ;	USES	ALL
  7852                                  
  7853                                  _$GetExtendedError:
  7854 00001D49 16                      	push	ss
  7855 00001D4A 1F                      	pop	ds
  7856 00001D4B A1[F002]                	MOV	AX,[EXTERR]
  7857 00001D4E C43E[F402]              	LES	DI,[EXTERRPT]
  7858 00001D52 8B1E[F202]              	MOV	BX,[EXTERR_ACTION]	; BL = Action, BH = Class
  7859 00001D56 8A2E[EF02]              	MOV	CH,[EXTERR_LOCUS]
  7860 00001D5A E8ECF8                  	call	Get_User_Stack
  7861                                  	;mov	[si+0Ah],di
  7862 00001D5D 897C0A                  	MOV	[SI+user_env.user_DI],DI
  7863                                  	;mov	[si+10h],es
  7864 00001D60 8C4410                  	MOV	[SI+user_env.user_ES],ES
  7865                                  	;mov	[si+2],bx
  7866 00001D63 895C02                  	MOV	[SI+user_env.user_BX],BX
  7867                                  	;mov	[si+4],cx
  7868 00001D66 894C04                  	MOV	[SI+user_env.user_CX],CX
  7869                                  	;jmp	SYS_RET_OK
  7870                                  	; 26/07/2019
  7871 00001D69 E932FA                  	jmp	SYS_RET_OK_clc
  7872                                  
  7873                                  ;============================================================================
  7874                                  ; PARSE.ASM, MSDOS 6.0, 1991
  7875                                  ;============================================================================
  7876                                  ; 19/07/2018 - Retro DOS v3.0
  7877                                  
  7878                                  ; System calls for parsing command lines
  7879                                  ;
  7880                                  ;   $PARSE_FILE_DESCRIPTOR
  7881                                  ;
  7882                                  ;   Modification history:
  7883                                  ;
  7884                                  ;       Created: ARR 30 March 1983
  7885                                  ;               EE PathParse 10 Sept 1983
  7886                                  ;
  7887                                  
  7888                                  ;BREAK <$Parse_File_Descriptor -- Parse an arbitrary string into an FCB>
  7889                                  ;---------------------------------------------------------------------------
  7890                                  ; Inputs:
  7891                                  ;       DS:SI Points to a command line
  7892                                  ;       ES:DI Points to an empty FCB
  7893                                  ;       Bit 0 of AL = 1 At most one leading separator scanned off
  7894                                  ;                   = 0 Parse stops if separator encountered
  7895                                  ;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
  7896                                  ;                   = 0  "    "    "     "         "      "  - put 0 in FCB
  7897                                  ;       Bit 2 of AL = 1 If filename field blank - leave FCB
  7898                                  ;                   = 0  "       "      "       - put blanks in FCB
  7899                                  ;       Bit 3 of AL = 1 If extension field blank - leave FCB
  7900                                  ;                   = 0  "       "      "        - put blanks in FCB
  7901                                  ; Function:
  7902                                  ;       Parse command line into FCB
  7903                                  ; Returns:
  7904                                  ;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
  7905                                  ;       DS:SI points to first character after filename
  7906                                  ;---------------------------------------------------------------------------
  7907                                  
  7908                                  _$PARSE_FILE_DESCRIPTOR:
  7909 00001D6C E89B3A                  	call	MAKEFCB
  7910 00001D6F 56                      	PUSH    SI
  7911 00001D70 E8D6F8                  	call	Get_User_Stack
  7912                                  	;pop	word [si+8]
  7913 00001D73 8F4408                  	POP     word [SI+user_env.user_SI]
  7914 00001D76 C3                      	retn
  7915                                  
  7916                                  ;============================================================================
  7917                                  ; MISC.ASM, MSDOS 6.0, 1991
  7918                                  ;============================================================================
  7919                                  ; 19/07/2018 - Retro DOS v3.0
  7920                                  
  7921                                  ;ENTRYPOINTSEG	EQU	0CH
  7922                                  ;MAXDIF		EQU	0FFFH
  7923                                  ;SAVEXIT 	EQU	10
  7924                                  ;WRAPOFFSET	EQU	0FEF0h
  7925                                  
  7926                                  ;
  7927                                  ;----------------------------------------------------------------------------
  7928                                  ;
  7929                                  ;**	$SLEAZEFUNC - Get a Pointer to the Media Byte
  7930                                  ;
  7931                                  ;	Return Stuff sort of like old get fat call
  7932                                  ;
  7933                                  ;	ENTRY	none
  7934                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7935                                  ;			GOD help anyone who tries to do ANYTHING except
  7936                                  ;			READ this ONE byte.
  7937                                  ;		DX = Total Number of allocation units on disk
  7938                                  ;		CX = Sector size
  7939                                  ;		AL = Sectors per allocation unit
  7940                                  ;		   = -1 if bad drive specified
  7941                                  ;	USES	all
  7942                                  ;
  7943                                  ;**	$SLEAZEFUNCDL - Get a Pointer to the Media Byte
  7944                                  ;
  7945                                  ;	Identical to $SLEAZEFUNC except (dl) = drive
  7946                                  ;
  7947                                  ;	ENTRY	(dl) = drive (0=default, 1=A, 2=B, etc.)
  7948                                  ;	EXIT	DS:BX = Points to FAT ID byte (IBM only)
  7949                                  ;			GOD help anyone who tries to do ANYTHING except
  7950                                  ;			READ this ONE byte.
  7951                                  ;		DX = Total Number of allocation units on disk
  7952                                  ;		CX = Sector size
  7953                                  ;		AL = Sectors per allocation unit
  7954                                  ;		   = -1 if bad drive specified
  7955                                  ;	USES	all
  7956                                  ;
  7957                                  ;----------------------------------------------------------------------------
  7958                                  ;
  7959                                  
  7960                                  _$SLEAZEFUNC:
  7961 00001D77 B200                    	MOV	DL,0
  7962                                  
  7963                                  _$SLEAZEFUNCDL:
  7964 00001D79 16                      	push	ss
  7965 00001D7A 1F                      	pop	ds
  7966                                  	
  7967 00001D7B 88D0                    	MOV	AL,DL
  7968 00001D7D E8374F                  	call	GETTHISDRV		; Get CDS structure
  7969                                  SET_AL_RET:
  7970                                  	; MSDOS 3.3
  7971                                  	;mov	al,0Fh
  7972 00001D80 B00F                    	MOV	AL,error_invalid_drive	; Assume error	;AC000;
  7973                                  
  7974 00001D82 721E                    	JC	short BADSLDRIVE
  7975                                  
  7976 00001D84 E89F1B                  	call	DISK_INFO
  7977 00001D87 72F7                    	JC	short SET_AL_RET	; User FAILed to I 24
  7978 00001D89 8826[5405]              	MOV	[FATBYTE],AH
  7979                                  
  7980                                  ; NOTE THAT A FIXED MEMORY CELL IS USED --> THIS CALL IS NOT
  7981                                  ; RE-ENTRANT. USERS BETTER GET THE ID BYTE BEFORE THEY MAKE THE
  7982                                  ; CALL AGAIN
  7983                                  
  7984 00001D8D BF[5405]                	MOV	DI,FATBYTE
  7985 00001D90 30E4                    	XOR	AH,AH			; AL has sectors/cluster
  7986 00001D92 E8B4F8                  	call	Get_User_Stack
  7987                                  	;mov	[si+4],cx
  7988                                  	;mov	[si+6],bx
  7989                                  	;mov	[si+2],di
  7990 00001D95 894C04                  	MOV	[SI+user_env.user_CX],CX
  7991 00001D98 895C06                  	MOV	[SI+user_env.user_DX],BX
  7992 00001D9B 897C02                  	MOV	[SI+user_env.user_BX],DI
  7993                                  	
  7994                                  	;mov	[si+0Eh],cs
  7995                                  	;mov	[SI+user_env.user_DS],SS
  7996 00001D9E 8C4C0E                  	MOV     [SI+user_env.user_DS],CS ; stash correct pointer
  7997                                  
  7998 00001DA1 C3                      	retn
  7999                                  
  8000                                  BADSLDRIVE:
  8001 00001DA2 E915FA                  	jmp	FCB_RET_ERR
  8002                                  
  8003                                  ;
  8004                                  ;----------------------------------------------------------------------------
  8005                                  ;
  8006                                  ;**	$Get_INDOS_Flag - Return location of DOS Critical Section Flag
  8007                                  ;
  8008                                  ;	Returns location of DOS status for interrupt routines
  8009                                  ;									   ;
  8010                                  ;	ENTRY	none
  8011                                  ;	EXIT	(es:bx) = flag location
  8012                                  ;	USES	all
  8013                                  ;
  8014                                  ;----------------------------------------------------------------------------
  8015                                  ;
  8016                                  
  8017                                  _$GET_INDOS_FLAG:
  8018 00001DA5 E8A1F8                          CALL	Get_User_Stack
  8019                                          ;MOV	WORD [SI+2],INDOS
  8020 00001DA8 C74402[ED02]            	MOV     word [SI+user_env.user_BX],INDOS
  8021                                          ;MOV	[SI+10H],SS
  8022 00001DAD 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8023 00001DB0 C3                      	RETN 
  8024                                  
  8025                                  ;
  8026                                  ;----------------------------------------------------------------------------
  8027                                  ;
  8028                                  ;**	$Get_IN_Vars - Return Pointer to DOS Variables
  8029                                  ;
  8030                                  ;	Return a pointer to interesting DOS variables This call is version
  8031                                  ;	dependent and is subject to change without notice in future versions.
  8032                                  ;	Use at risk.
  8033                                  ;
  8034                                  ;	ENTRY	none
  8035                                  ;	EXIT	(es:bx) = address of SYSINITVAR
  8036                                  ;	uses	ALL
  8037                                  ;
  8038                                  ;----------------------------------------------------------------------------
  8039                                  ;
  8040                                  
  8041                                  _$GET_IN_VARS:
  8042 00001DB1 E895F8                          CALL	Get_User_Stack
  8043                                          ;MOV	WORD [SI+2],SYSINITVAR
  8044                                  	;MOV	word [SI+user_env.user_BX],SYSINITVAR
  8045 00001DB4 C74402[2600]            	MOV	word [SI+user_env.user_BX],SYSINITVARS
  8046                                          ;MOV	[SI+10H],SS
  8047 00001DB9 8C5410                  	MOV	[SI+user_env.user_ES],SS
  8048 00001DBC C3                      	RETN
  8049                                  
  8050                                  ;
  8051                                  ;----------------------------------------------------------------------------
  8052                                  ;
  8053                                  ;**	$Get_Default_DPB - Return a pointer to the Default DPB
  8054                                  ;
  8055                                  ;	Return pointer to drive parameter table for default drive
  8056                                  ;
  8057                                  ;	ENTRY	none
  8058                                  ;	EXIT	(ds:bx) = DPB address
  8059                                  ;	USES	all
  8060                                  ;
  8061                                  ;**	$Get_DPB - Return a pointer to a specified DPB
  8062                                  ;
  8063                                  ;	Return pointer to a specified drive parameter table
  8064                                  ;
  8065                                  ;	ENTRY	(dl) = drive # (0 = default, 1=A, 2=B, etc.)
  8066                                  ;	EXIT	(al) = 0 iff ok
  8067                                  ;		  (ds:bx) = DPB address
  8068                                  ;		(al) = -1 if bad drive
  8069                                  ;	USES	all
  8070                                  ;
  8071                                  ;----------------------------------------------------------------------------
  8072                                  ;
  8073                                  
  8074                                  _$GET_DEFAULT_DPB:
  8075 00001DBD B200                    	MOV	DL,0
  8076                                  _$GET_DPB:
  8077 00001DBF 16                      	push	ss
  8078 00001DC0 1F                      	pop	ds
  8079                                  
  8080 00001DC1 88D0                    	MOV	AL,DL
  8081 00001DC3 E8F14E                  	call	GETTHISDRV		; Get CDS structure
  8082 00001DC6 7223                    	JC	short ISNODRV 		; no valid drive
  8083 00001DC8 C43E[5E05]              	LES	DI,[THISCDS]		; check for net CDS
  8084                                  	;test	word [es:di+43h],8000h
  8085 00001DCC 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
  8086 00001DD2 7517                    	JNZ	short ISNODRV 		; No DPB to point at on NET stuff
  8087 00001DD4 E83603                  	call	EcritDisk
  8088 00001DD7 E8F740                  	call	FATREAD_CDS		; Force Media Check and return DPB
  8089 00001DDA E83803                  	call	LcritDisk
  8090 00001DDD 720C                    	JC	short ISNODRV 		; User FAILed to I 24, only error we
  8091                                  					;   have.
  8092 00001DDF E867F8                  	call	Get_User_Stack
  8093                                  	;mov	[si+2],bp
  8094                                  	;mov	[si+0Eh],es
  8095 00001DE2 896C02                  	MOV	[SI+user_env.user_BX],BP
  8096 00001DE5 8C440E                  	MOV	[SI+user_env.user_DS],ES
  8097 00001DE8 30C0                    	XOR	AL,AL
  8098 00001DEA C3                      	retn
  8099                                  ISNODRV:
  8100 00001DEB B0FF                    	MOV	AL,-1
  8101 00001DED C3                      	retn
  8102                                  
  8103                                  ;
  8104                                  ;----------------------------------------------------------------------------
  8105                                  ;
  8106                                  ;**	$Disk_Reset - Flush out Dirty Buffers
  8107                                  ;
  8108                                  ;	$DiskReset flushes and invalidates all buffers.  BUGBUG - do
  8109                                  ;		we really invalidate?  SHould we?  THis screws non-removable
  8110                                  ;		caching.  Maybe CHKDSK relies upon it, though....
  8111                                  ;
  8112                                  ;	ENTRY	none
  8113                                  ;	EXIT	none
  8114                                  ;	USES	all
  8115                                  ;
  8116                                  ;----------------------------------------------------------------------------
  8117                                  ;
  8118                                  
  8119                                  _$DISK_RESET:
  8120 00001DEE 16                      	push	ss
  8121 00001DEF 1F                      	pop	ds
  8122 00001DF0 B0FF                    	MOV	AL,-1
  8123 00001DF2 E81803                  	call	EcritDisk
  8124                                  	; MSDOS 6.0
  8125                                  	;or	word [DOS34_FLAG],FROM_DISK_RESET    ;AN000;
  8126 00001DF5 E87644                  	call	FLUSHBUF
  8127                                  	; MSDOS 6.0
  8128                                  	;AND	word [DOS34_FLAG],NO_FROM_DISK_RESET ;AN000;
  8129                                  	;mov	word [SC_STATUS],0	; Throw out secondary cache M041
  8130                                  ;
  8131                                  ; We will "ignore" any errors on the flush, and go ahead and invalidate. This
  8132                                  ; call doesn't return any errors and it is supposed to FORCE a known state, so
  8133                                  ; let's do it.
  8134                                  ;
  8135                                  ; Invalidate 'last-buffer' used
  8136                                  ;
  8137 00001DF8 BBFFFF                  	MOV	BX,-1
  8138 00001DFB 891E[2000]              	MOV	[LastBuffer+2],BX
  8139 00001DFF 891E[1E00]              	MOV	[LastBuffer],BX
  8140                                  
  8141                                  	; MSDOS 3.3 
  8142                                  	; IBMDOS.COM, Offset 1C66h
  8143                                  	;;;;
  8144 00001E03 C536[3800]              	lds     si,[BUFFHEAD]
  8145 00001E07 B8FF20                  	mov	ax,20FFh	; .buf_ID,    AL = FFh (Free buffer)
  8146                                  				; .buf_flags, AH = 0, reset/clear
  8147                                  DRST_1:
  8148                                  	; 25/07/2019 - Retro DOS v3.2
  8149                                  	;;mov	[si+4],ax
  8150                                  	;mov	[si+BUFFINFO.buf_ID],ax
  8151                                  	;lds	si,[SI]
  8152                                  	;cmp	si,bx ; -1
  8153                                  	;je	short DRST_2
  8154                                  
  8155                                  	;mov	[si+4],ax
  8156 00001E0A 894404                  	mov	[si+BUFFINFO.buf_ID],ax
  8157 00001E0D C534                    	lds	si,[SI]
  8158 00001E0F 39DE                    	cmp	si,bx
  8159 00001E11 75F7                    	jne	short DRST_1
  8160                                  	;;;;
  8161                                  DRST_2:
  8162 00001E13 E8FF02                  	call	LcritDisk
  8163                                  
  8164                                  	; 20/05/2019
  8165                                  	;MOV	AX,-1
  8166                                  	;CallInstall NetFlushBuf,MultNET,32,AX,AX
  8167                                  	;mov	ax,0FFFFh
  8168                                  
  8169 00001E16 B82011                  	mov     ax,1120h
  8170 00001E19 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - FLUSH ALL DISK BUFFERS
  8171                                  			; DS = DOS CS
  8172                                  			; Return: CF clear (successful)
  8173 00001E1B C3                      	retn
  8174                                  
  8175                                  	; 19/07/2018 - Retro DOS v3.0
  8176                                  
  8177                                  ;
  8178                                  ;	BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>
  8179                                  ;
  8180                                  ;----------------------------------------------------------------------------
  8181                                  ;
  8182                                  ;**	$SetDPB - Create a DPB
  8183                                  ;
  8184                                  ;	SetDPB Creates a valid DPB from a user-specified BPB
  8185                                  ;
  8186                                  ;	ENTRY	ES:BP Points to DPB
  8187                                  ;		DS:SI Points to BPB
  8188                                  ;	EXIT	DPB setup
  8189                                  ;	USES	ALL but BP, DS, ES
  8190                                  ;
  8191                                  ;----------------------------------------------------------------------------
  8192                                  ;
  8193                                  
  8194                                  ; 10/05/2019 - Retro DOS v4.0
  8195                                  
  8196                                  ; MSDOS 6.0
  8197 00001E1C 0300                    word3:	dw	3			; M008 -- word value for divides
  8198                                  
  8199                                  ;procedure   $SETDPB,NEAR
  8200                                  
  8201                                  _$SETDPB:
  8202                                  	; 25/07/2019 - Retro DOS v3.2
  8203 00001E1E 89EF                    	MOV	DI,BP
  8204 00001E20 83C702                  	ADD	DI,2			; Skip over dpb_drive and dpb_UNIT
  8205 00001E23 AD                      	LODSW
  8206 00001E24 AB                      	STOSW				; dpb_sector_size
  8207                                  	; MSDOS 6.0
  8208 00001E25 807C0300                	CMP	BYTE [SI+A_BPB.BPB_NUMBEROFFATS-2],0 ; FAT file system drive ;AN000;
  8209 00001E29 7507                    	JNZ	short yesfat			     ; yes		;AN000;
  8210 00001E2B 26C6450400              	MOV	BYTE [ES:DI+DPB.FAT_COUNT-4],0
  8211 00001E30 EB76                    	JMP	short setend			     ; NO		;AN000;
  8212                                  yesfat: ; 10/08/2018
  8213 00001E32 89C2                    	MOV	DX,AX
  8214 00001E34 AC                      	LODSB
  8215 00001E35 FEC8                    	DEC	AL
  8216 00001E37 AA                      	STOSB				; dpb_cluster_mask
  8217 00001E38 FEC0                    	INC	AL
  8218 00001E3A 30E4                    	XOR	AH,AH
  8219                                  LOG2LOOP:
  8220 00001E3C A801                    	test	AL,1
  8221 00001E3E 7506                    	JNZ	short SAVLOG
  8222 00001E40 FEC4                    	INC	AH
  8223 00001E42 D0E8                    	SHR	AL,1
  8224 00001E44 EBF6                    	JMP	SHORT LOG2LOOP
  8225                                  SAVLOG:
  8226 00001E46 88E0                    	MOV	AL,AH
  8227 00001E48 AA                      	STOSB				; dpb_cluster_shift
  8228 00001E49 88C3                    	MOV	BL,AL
  8229 00001E4B A5                      	MOVSW				; dpb_first_FAT Start of FAT (# of reserved sectors)
  8230 00001E4C AC                      	LODSB
  8231 00001E4D AA                      	STOSB				; dpb_FAT_count Number of FATs
  8232                                  ;	OR	AL,AL			; NONFAT ?				;AN000;
  8233                                  ;	JZ	short setend		; yes, don't do anything                ;AN000;
  8234 00001E4E 88C7                    	MOV	BH,AL
  8235 00001E50 AD                      	LODSW
  8236 00001E51 AB                      	STOSW				; dpb_root_entries Number of directory entries
  8237 00001E52 B105                    	MOV	CL,5
  8238 00001E54 D3EA                    	SHR	DX,CL			; Directory entries per sector
  8239 00001E56 48                      	DEC	AX
  8240 00001E57 01D0                    	ADD	AX,DX			; Cause Round Up
  8241 00001E59 89D1                    	MOV	CX,DX
  8242 00001E5B 31D2                    	XOR	DX,DX
  8243 00001E5D F7F1                    	DIV	CX
  8244 00001E5F 89C1                    	MOV	CX,AX			; Number of directory sectors
  8245 00001E61 47                      	INC	DI
  8246 00001E62 47                      	INC	DI			; Skip dpb_first_sector
  8247 00001E63 A5                      	MOVSW			; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
  8248 00001E64 AC                      	LODSB
  8249                                  	;mov	[es:bp+16h],al
  8250                                  	;mov	[es:bp+17h],al ; MSDOS 6.0
  8251 00001E65 26884617                	MOV	[ES:BP+DPB.MEDIA],AL	; Media byte
  8252 00001E69 AD                      	LODSW				; Number of sectors in a FAT
  8253                                  
  8254                                  	; 25/07/2019
  8255                                  	;;;
  8256                                  	; MSDOS 3.3
  8257                                  	;STOSB		; DPB.FAT_SIZE
  8258                                  	;MUL	BH
  8259                                  	; MSDOS 6.0
  8260 00001E6A AB                      	STOSW		; DPB.FAT_SIZE	;AC000;;>32mb dpb_FAT_size
  8261 00001E6B 88FA                    	MOV	DL,BH			;AN000;;>32mb
  8262 00001E6D 30F6                    	XOR	DH,DH			;AN000;;>32mb
  8263 00001E6F F7E2                    	MUL	DX			;AC000;;>32mb Space occupied by all FATs
  8264                                  	;;;
  8265                                  	;add	ax,[es:bp+6]
  8266 00001E71 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
  8267 00001E75 AB                      	STOSW				; dpb_dir_sector
  8268 00001E76 01C8                    	ADD	AX,CX			; Add number of directory sectors
  8269                                  	;mov	[es:bp+0Bh],ax
  8270 00001E78 2689460B                	MOV	[ES:BP+DPB.FIRST_SECTOR],AX
  8271                                  	
  8272                                  	; MSDOS 6.0
  8273 00001E7C 88D9                    	MOV	CL,BL			;F.C. >32mb				;AN000;
  8274                                  	;cmp	word [es:bp+0Dh],0
  8275                                  	;CMP	WORD [ES:BP+DSKSIZ],0	;F.C. >32mb				;AN000;
  8276                                  	;JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8277                                  	; 28/07/2019
  8278 00001E7E 268B5E0D                	mov	bx,[ES:BP+DSKSIZ]
  8279 00001E82 09DB                    	or	bx,bx
  8280 00001E84 751C                    	JNZ	short normal_dpb	;F.C. >32mb				;AN000;
  8281                                  	
  8282 00001E86 30ED                    	XOR	CH,CH			;F.C. >32mb				;AN000;
  8283                                  	;mov	bx,[si+8]
  8284 00001E88 8B5C08                  	MOV	BX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK]	;AN000;
  8285                                  	;mov	dx,[si+10]
  8286 00001E8B 8B540A                  	MOV	DX,[SI+A_BPB.BPB_BIGTOTALSECTORS-A_BPB.BPB_SECTORSPERTRACK+2]	;AN000;
  8287 00001E8E 29C3                    	SUB	BX,AX			;AN000;;F.C. >32mb
  8288 00001E90 83DA00                  	SBB	DX,0			;AN000;;F.C. >32mb
  8289 00001E93 09C9                    	OR	CX,CX			;AN000;;F.C. >32mb
  8290 00001E95 7407                    	JZ	short norot		;AN000;;F.C. >32mb
  8291                                  rott:					;AN000;;F.C. >32mb
  8292 00001E97 F8                      	CLC				;AN000;;F.C. >32mb
  8293 00001E98 D1DA                    	RCR	DX,1			;AN000;;F.C. >32mb
  8294 00001E9A D1DB                    	RCR	BX,1			;AN000;;F.C. >32mb
  8295 00001E9C E2F9                    	LOOP	rott			;AN000;;F.C. >32mb
  8296                                  norot:					;AN000;
  8297 00001E9E 89D8                    	MOV	AX,BX			;AN000;;F.C. >32mb
  8298 00001EA0 EB06                    	JMP	short setend		;AN000;;F.C. >32mb
  8299                                  normal_dpb:
  8300                                  	;sub	ax,[es:bp+0Dh]
  8301                                  	;SUB	AX,[ES:BP+DSKSIZ]
  8302 00001EA2 29D8                    	sub	ax,bx ; 28/07/2019
  8303 00001EA4 F7D8                    	NEG	AX			; Sectors in data area
  8304                                  ;;	MOV	CL,BL			; dpb_cluster_shift
  8305 00001EA6 D3E8                    	SHR	AX,CL			; Div by sectors/cluster
  8306                                  setend:
  8307                                  
  8308                                  ;	M008 - CAS
  8309                                  ;
  8310 00001EA8 40                      	INC	AX			; +2 (reserved), -1 (count -> max)
  8311                                  ;
  8312                                  ;	There has been a bug in our fatsize calculation for so long
  8313                                  ;	  that we can't correct it now without causing some user to
  8314                                  ;	  experience data loss. There are even cases where allowing
  8315                                  ;	  the number of clusters to exceed the fats is the optimal
  8316                                  ;	  case -- where adding 2 more fat sectors would make the
  8317                                  ;	  data field smaller so that there's nothing to use the extra
  8318                                  ;	  fat sectors for.
  8319                                  ;
  8320                                  ;	Note that this bug had very minor known symptoms. CHKDSK would
  8321                                  ;	  still report that there was a cluster left when the disk was
  8322                                  ;	  actually full. Very graceful failure for a corrupt system
  8323                                  ;	  configuration. There may be worse cases that were never
  8324                                  ;	  properly traced back to this bug. The problem cases only
  8325                                  ;	  occurred when partition sizes were very near FAT sector
  8326                                  ;	  rounding boundaries, which were rare cases.
  8327                                  ;
  8328                                  ;	Also, it's possible that some third-party partition program might
  8329                                  ;	  create a partition that had a less-than-perfect FAT calculation
  8330                                  ;	  scheme. In this hypothetical case, the number of allocation
  8331                                  ;	  clusters which don't actually have FAT entries to represent
  8332                                  ;	  them might be larger and might create a more catastrophic
  8333                                  ;	  failure. So we'll provide the safeguard of limiting the
  8334                                  ;	  max_cluster to the amount that will fit in the FATs.
  8335                                  ;
  8336                                  ;	ax = maximum legal cluster, ES:BP -> dpb
  8337                                  
  8338                                  ;	make sure the number of fat sectors is actually enough to
  8339                                  ;	  hold that many clusters. otherwise, back the number of
  8340                                  ;	  clusters down
  8341                                  
  8342                                  	; 19/07/2018 - Retro DOS v3.0
  8343                                  	; 25/07/2019 - Retro DOS v3.2
  8344                                  	; MSDOS 6.0
  8345 00001EA9 89C3                    	mov	bx,ax			; remember calculated # clusters
  8346                                  
  8347                                  	; 01/08/2018 (MSDOS 3.3)
  8348                                  	;mov	al,[ES:BP+DPB.FAT_SIZE]
  8349                                  	;xor	ah,ah 
  8350                                  
  8351                                  	; 10/05/2019 - Retro DOS v4.0
  8352                                  	;mov	ax,[ES:BP+0Fh]
  8353 00001EAB 268B460F                	mov	ax,[ES:BP+DPB.FAT_SIZE]
  8354                                  
  8355                                  	;mul	word [es:bp+2]	
  8356 00001EAF 26F76602                	mul	word [ES:BP+DPB.SECTOR_SIZE] ; how big is the FAT?
  8357 00001EB3 81FBF60F                	cmp	bx,4096-10  ; 0FF6h	; test for 12 vs. 16 bit fat
  8358 00001EB7 720D                    	jb	short setend_fat12
  8359 00001EB9 D1EA                    	shr	dx,1
  8360                                  ;cs3 7/2/92
  8361 00001EBB 751C                    	jnz	short setend_faterr	; some bonehead gave us more fatspace
  8362                                  ;					; than enough for the maximum FAT,
  8363                                  ;					; so go ahead and use the calculated
  8364                                  ;					; number of clusters.
  8365                                  ;cs3 7/2/92
  8366                                  
  8367 00001EBD D1D8                    	rcr	ax,1			; find number of entries
  8368 00001EBF 3DF70F                  	cmp	ax,4096-10+1		; would this truncation move us
  8369                                  ;					;  into 12-bit fatland?
  8370 00001EC2 7215                    	jb	short setend_faterr	; then go ahead and let the
  8371                                  ;					;  inconsistency pass through
  8372                                  ;					;  rather than lose data by
  8373                                  ;					;  correcting the fat type
  8374 00001EC4 EB0E                    	jmp	short setend_fat16
  8375                                  
  8376                                  setend_fat12:
  8377 00001EC6 01C0                    	add	ax,ax			; (fatsiz*2)/3 = # of fat entries
  8378 00001EC8 11D2                    	adc	dx,dx
  8379                                  ;cs3 7/2/92
  8380 00001ECA 83FA03                  	cmp	dx,3			; if our fatspace is WAY more than
  8381 00001ECD 730A                    	jnb	short setend_faterr	; we need, we may get an overflow
  8382                                  ;					; here. Check for it and use
  8383                                  ;					; the calculated size in this case.
  8384                                  ;cs3 7/2/92
  8385 00001ECF 2EF736[1C1E]            	div	word [cs:word3]
  8386                                  
  8387                                  setend_fat16:
  8388 00001ED4 48                      	dec	ax			; limit at 1
  8389 00001ED5 39D8                    	cmp	ax,bx			; is fat big enough?
  8390 00001ED7 7602                    	jbe	short setend_fat	; use max value that'll fit
  8391                                  
  8392                                  setend_faterr:
  8393 00001ED9 89D8                    	mov	ax,bx			; use calculated value
  8394                                  
  8395                                  setend_fat:
  8396                                  
  8397                                  ;	now ax = maximum legal cluster
  8398                                  
  8399                                  ;	end M008
  8400                                  
  8401                                  	;mov	[es:bp+0Dh], ax
  8402 00001EDB 2689460D                	MOV	[ES:BP+DPB.MAX_CLUSTER],AX
  8403                                  	;;mov	word [es:bp+1Ch],0  ; MSDOS 3.3
  8404                                  	;mov	word [es:bp+1Dh],0  ; MSDOS 6.0
  8405 00001EDF 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 
  8406                                  					; Init so first ALLOC starts at
  8407                                  					; begining of FAT
  8408                                  	;;mov	word [es:bp+1Eh],-1 ; MSDOS 3.3
  8409                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
  8410 00001EE5 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; current count is invalid.
  8411                                  
  8412 00001EEB C3                      	retn
  8413                                  
  8414                                  ;EndProc $SETDPB
  8415                                  
  8416                                  ;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
  8417                                  
  8418                                  ;
  8419                                  ;----------------------------------------------------------------------------
  8420                                  ;
  8421                                  ;**	$Dup_PDB
  8422                                  ;
  8423                                  ; Inputs:   DX is new segment address of process
  8424                                  ;	    SI is end of new allocation block
  8425                                  ;
  8426                                  ;----------------------------------------------------------------------------
  8427                                  ;
  8428                                  
  8429                                  _$DUP_PDB:
  8430                                  
  8431                                  ;hkn;	CreatePDB would have a CS override. This is not valid.
  8432                                  ;hkn;	Must set up ds in order to access CreatePDB. Also SS is 
  8433                                  ;hkn;	has been assumed to be NOTHING. It may not have DOSDATA.
  8434                                  
  8435 00001EEC 2EC606[7203]FF          	MOV	byte [CS:CreatePDB],0FFh  ; indicate a new process
  8436 00001EF2 2E8E1E[FC02]            	MOV	DS,[CS:CurrentPDB]
  8437 00001EF7 56                      	PUSH	SI
  8438 00001EF8 EB0A                    	JMP	SHORT CreateCopy
  8439                                  
  8440                                  ;
  8441                                  ;----------------------------------------------------------------------------
  8442                                  ;
  8443                                  ; Inputs:
  8444                                  ;	DX = Segment number of new base
  8445                                  ; Function:
  8446                                  ;	Set up program base and copy term and ^C from int area
  8447                                  ; Returns:
  8448                                  ;	None
  8449                                  ; Called at DOS init
  8450                                  ;
  8451                                  ;----------------------------------------------------------------------------
  8452                                  ;
  8453                                  
  8454                                  _$CREATE_PROCESS_DATA_BLOCK:
  8455                                  			; Offset 1D02h in IBMDOS.COM (MSDOS 3.3), 1987
  8456 00001EFA E84CF7                  	CALL	Get_User_Stack
  8457                                  	;mov	ds,[si+14h]
  8458 00001EFD 8E5C14                  	MOV	DS,[SI+user_env.user_CS]
  8459                                  	;push	word [2]
  8460 00001F00 FF360200                	PUSH	word [PDB.BLOCK_LEN] ;*
  8461                                  CreateCopy:
  8462 00001F04 8EC2                    	MOV	ES,DX
  8463                                  
  8464 00001F06 31F6                    	XOR	SI,SI			; copy entire PDB
  8465 00001F08 89F7                    	MOV	DI,SI
  8466 00001F0A B98000                  	MOV	CX,128
  8467 00001F0D F3A5                    	REP	MOVSW
  8468                                  
  8469                                  ; DOS 3.3 7/9/86
  8470                                  
  8471                                  	;mov	cx,20
  8472                                  	;MOV	CX,FILPERPROC		; copy handles in case of
  8473 00001F0F B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8474                                  	;mov	di,18h
  8475 00001F11 BF1800                  	MOV	DI,PDB.JFN_TABLE	; Set Handle Count has been issued
  8476                                  
  8477                                  	; 28/07/2019
  8478                                  	;PUSH	DS
  8479                                  	;lds	si,[34h]
  8480 00001F14 C5363400                	LDS	SI,[PDB.JFN_Pointer]
  8481 00001F18 F3A4                    	REP	MOVSB
  8482                                  	;POP	DS
  8483                                  
  8484 00001F1A 0E                      	push	cs
  8485 00001F1B 1F                      	pop	ds
  8486                                  
  8487                                  ; DOS 3.3 7/9/86
  8488                                  
  8489                                  	;test	byte [cs:CreatePDB],0FFh
  8490                                  	;cmp	byte [CS:CreatePDB],0	; Shall we create a process?
  8491 00001F1C 803E[7203]00            	cmp	byte [CreatePDB],0
  8492 00001F21 7446                    	JZ	short Create_PDB_cont 	; nope, old style call
  8493                                  ;
  8494                                  ; Here we set up for a new process...
  8495                                  ;
  8496                                  	;PUSH    CS			; Called at DOSINIT time, NO SS
  8497                                  	;POP     DS
  8498                                  
  8499 00001F23 31DB                    	XOR	BX,BX			; dup all jfns
  8500                                  	;mov	cx,20
  8501                                  	;MOV	CX,FILPERPROC		; only 20 of them
  8502 00001F25 B114                    	mov	cl,FILPERPROC ; 06/07/2019
  8503                                  
  8504                                  Create_dup_jfn:
  8505 00001F27 06                      	PUSH	ES ;**			; save new PDB
  8506 00001F28 E8184C                  	call	SFFromHandle		; get sf pointer
  8507 00001F2B B0FF                    	MOV	AL,-1			; unassigned JFN
  8508 00001F2D 7225                    	JC	short CreateStash	; file was not really open
  8509                                  	;test	word [es:di+5],1000h
  8510 00001F2F 26F745050010            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_no_inherit
  8511 00001F35 751D                    	JNZ	short CreateStash	; if no-inherit bit is set, skip dup.
  8512                                  ;
  8513                                  ; We do not inherit network file handles.
  8514                                  ;
  8515                                  	;mov	ah,[es:di+2]
  8516 00001F37 268A6502                	MOV	AH,[ES:DI+SF_ENTRY.sf_mode]
  8517                                  	;and	ah,0F0h
  8518 00001F3B 80E4F0                  	AND	AH,SHARING_MASK
  8519                                  	;cmp	ah,70h
  8520 00001F3E 80FC70                  	CMP	AH,SHARING_NET_FCB
  8521 00001F41 7411                    	jz	short CreateStash
  8522                                  ;
  8523                                  ; The handle we have found is duplicatable (and inheritable). Perform
  8524                                  ; duplication operation.
  8525                                  ;
  8526 00001F43 893E[5A05]              	MOV	[THISSFT],DI
  8527 00001F47 8C06[5C05]              	MOV	[THISSFT+2],ES
  8528 00001F4B E8FC17                  	call	DOS_DUP 		; signal duplication
  8529                                  ;
  8530                                  ; get the old sfn for copy
  8531                                  ;
  8532 00001F4E E8DA4B                  	call	pJFNFromHandle		; ES:DI is jfn
  8533 00001F51 268A05                  	MOV	AL,[ES:DI]		; get sfn
  8534                                  ;
  8535                                  ; Take AL (old sfn or -1) and stash it into the new position
  8536                                  ;
  8537                                  CreateStash:
  8538 00001F54 07                      	POP	ES ;**
  8539                                  	;mov	[es:bx+18h],al
  8540 00001F55 26884718                	MOV	[ES:BX+PDB.JFN_TABLE],AL ; copy into new place!
  8541 00001F59 43                      	INC	BX			; next jfn...
  8542 00001F5A E2CB                    	LOOP	Create_dup_jfn
  8543                                  
  8544 00001F5C 8B1E[FC02]              	MOV	BX,[CurrentPDB]		; get current process
  8545                                  	;mov	[es:bx+16h]
  8546 00001F60 26891E1600              	MOV	[ES:PDB.PARENT_PID],BX	; stash in child
  8547 00001F65 8C06[FC02]              	MOV	[CurrentPDB],ES
  8548                                  	;MOV	DS,BX ; 28/07/2019
  8549                                  ;
  8550                                  ; end of new process create
  8551                                  ;
  8552                                  Create_PDB_cont:
  8553                                  	;MOV	BYTE [CS:CreatePDB],0	; reset flag
  8554                                  	; 28/07/2019
  8555 00001F69 C606[7203]00            	MOV	byte [CreatePDB],0	; reset flag
  8556 00001F6E 58                      	POP	AX  ;*
  8557                                  
  8558                                  	;entry	SETMEM
  8559                                  
  8560                                  ;---------------------------------------------------------------------------
  8561                                  ; Inputs:
  8562                                  ;	AX = Size of memory in paragraphs
  8563                                  ;	DX = Segment
  8564                                  ; Function:
  8565                                  ;	Completely prepares a program base at the
  8566                                  ;	specified segment.
  8567                                  ; Called at DOS init
  8568                                  ; Outputs:
  8569                                  ;	DS = DX
  8570                                  ;	ES = DX
  8571                                  ;	[0] has INT int_abort
  8572                                  ;	[2] = First unavailable segment
  8573                                  ;	[5] to [9] form a long call to the entry point
  8574                                  ;	[10] to [13] have exit address (from int_terminate)
  8575                                  ;	[14] to [17] have ctrl-C exit address (from int_ctrl_c)
  8576                                  ;	[18] to [21] have fatal error address (from int_fatal_abort)
  8577                                  ; DX,BP unchanged. All other registers destroyed.
  8578                                  ;---------------------------------------------------------------------------
  8579                                  
  8580                                  SETMEM:
  8581 00001F6F 31C9                    	XOR	CX,CX
  8582 00001F71 8ED9                    	MOV	DS,CX
  8583 00001F73 8EC2                    	MOV	ES,DX
  8584                                  	;mov	si,88h
  8585 00001F75 BE8800                  	MOV	SI,addr_int_terminate
  8586                                  	;mov	di,10
  8587 00001F78 BF0A00                  	MOV	DI,SAVEXIT
  8588                                  	;MOV	CX,6
  8589 00001F7B B106                    	mov	cl,6 ; 06/07/2019
  8590 00001F7D F3A5                    	REP	MOVSW
  8591 00001F7F 26A30200                	MOV	[ES:2],AX
  8592 00001F83 29D0                    	SUB	AX,DX
  8593 00001F85 3DFF0F                  	CMP	AX,MAXDIF ; 0FFFh
  8594 00001F88 7603                    	JBE	short HAVDIF
  8595 00001F8A B8FF0F                  	MOV	AX,MAXDIF
  8596                                  HAVDIF:
  8597 00001F8D 83E810                  	SUB	AX,10h			; Allow for 100h byte "stack"
  8598 00001F90 BB0C00                  	MOV	BX,ENTRYPOINTSEG	;	in .COM files
  8599 00001F93 29C3                    	SUB	BX,AX
  8600 00001F95 B104                    	MOV	CL,4
  8601 00001F97 D3E0                    	SHL	AX,CL
  8602 00001F99 8EDA                    	MOV	DS,DX
  8603                                  
  8604                                  	; (MSDOS 6.0 note)
  8605                                  	;
  8606                                  	; The address in BX:AX will be F01D:FEF0 if there is 64K or more 
  8607                                  	; memory in the system. This is equivalent to 0:c0 if A20 is OFF.
  8608                                  	; If DOS is in HMA this equivalence is no longer valid as A20 is ON.
  8609                                  	; But the BIOS which now resides in FFFF:30 has 5 bytes in FFFF:D0
  8610                                  	; (F01D:FEF0) which is the same as the ones in 0:C0, thereby 
  8611                                  	; making this equvalence valid for this particular case. If however
  8612                                  	; there is less than 64K remaining the address in BX:AX will not 
  8613                                  	; be the same as above. We will then stuff 0:c0, the call 5 address
  8614                                  	; into the PSP.
  8615                                  	;
  8616                                  	; Therefore for the case where there is less than 64K remaining in 
  8617                                  	; the system old CPM Apps that look at PSP:6 to determine memory
  8618                                  	; requirements will not work. Call 5, however will continue to work
  8619                                  	; for all cases.
  8620                                  	;
  8621                                  
  8622                                  	;mov	[6],ax
  8623                                  	;mov	[8],bx
  8624                                  
  8625 00001F9B A30600                  	MOV	[PDB.CPM_CALL+1],AX
  8626 00001F9E 891E0800                	MOV	[PDB.CPM_CALL+3],BX
  8627                                  
  8628                                  	;cmp	ax,WRAPOFFSET		; Q: does the system have >= 64k of
  8629                                  	;				;    memory left
  8630                                  	;je	short addr_ok		; Y: the above calculated address is
  8631                                  	;				;    OK
  8632                                  	;				; N: 
  8633                                  
  8634                                  	;MOV	WORD [PDB.CPM_CALL+1],0C0h
  8635                                  	;MOV	WORD [PDB.CPM_CALL+3],0
  8636                                  
  8637                                  ;addr_ok:
  8638                                  	;mov	word [0],20CDh
  8639 00001FA2 C7060000CD20            	MOV	word [PDB.EXIT_CALL],(int_abort*256) + mi_INT
  8640                                  	;mov	byte [5],9Ah
  8641 00001FA8 C60605009A              	MOV	BYTE [PDB.CPM_CALL],mi_Long_CALL
  8642                                  	;mov	word [50h],21CDh
  8643 00001FAD C7065000CD21            	MOV	WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
  8644                                  	;mov	byte [52h],0CBh
  8645 00001FB3 C6065200CB              	MOV	BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
  8646                                  	;mov	word [34h],18h
  8647 00001FB8 C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE
  8648                                  	;mov	word [36h],ds
  8649 00001FBE 8C1E3600                	MOV	WORD [PDB.JFN_Pointer+2],DS
  8650                                  	;mov	word [32h],20
  8651 00001FC2 C70632001400            	MOV	WORD [PDB.JFN_Length],FILPERPROC
  8652                                  ;
  8653                                  ; The server runs several PDB's without creating them VIA EXEC. We need to
  8654                                  ; enumerate all PDB's at CPS time in order to find all references to a
  8655                                  ; particular SFT. We perform this by requiring that the server link together
  8656                                  ; for us all sub-PDB's that he creates. The requirement for us, now, is to
  8657                                  ; initialize this pointer.
  8658                                  ;
  8659                                   	;mov	word [38h],-1
  8660 00001FC8 C7063800FFFF            	MOV	word [PDB.Next_PDB],-1
  8661                                  	;mov	word [3Ah],-1
  8662 00001FCE C7063A00FFFF            	MOV	word [PDB.Next_PDB+2],-1
  8663                                  			; Set the real version number in the PSP - 5.00
  8664                                  	;mov	[ES:PDB.Version],(MINOR_VERSION*256)+MAJOR_VERSION
  8665                                  
  8666 00001FD4 C3                      	retn
  8667                                  
  8668                                  ; 23/07/2019 - Retro DOS v3.2
  8669                                  
  8670                                  ;============================================================================
  8671                                  ; IBMDOS.COM (MSDOS 3.3 KERNEL), 1987 - Offset 1DE6h
  8672                                  ;============================================================================
  8673                                  ; 19/07/2018 - Retro DOS v3.0
  8674                                  
  8675                                  ;FETCHI_CHECK:
  8676                                  ;	pushf
  8677                                  ;	cmp	word [cs:FETCHI_TAG],5872h
  8678                                  ;	jz      short FETCHI_CHK_RETN
  8679                                  ;	call    DOSINIT
  8680                                  ;FETCHI_CHK_RETN:
  8681                                  ;	popf
  8682                                  ;	retn
  8683                                  
  8684                                  ;============================================================================
  8685                                  ; MISC2.ASM, MSDOS 6.0, 1991
  8686                                  ;============================================================================
  8687                                  ; 20/07/2018 - Retro DOS v3.0
  8688                                  
  8689                                  ; Break <STRCMP - compare two ASCIZ strings DS:SI to ES:DI>
  8690                                  ;----------------------------------------------------------------------------
  8691                                  ;
  8692                                  ;   Strcmp - compare ASCIZ DS:SI to ES:DI. Case INSENSITIVE. '/' = '\'
  8693                                  ;		Strings of different lengths don't match.
  8694                                  ;   Inputs:	DS:SI - pointer to source string  ES:DI - pointer to dest string
  8695                                  ;   Outputs:	Z if strings same, NZ if different
  8696                                  ;   Registers modified: NONE
  8697                                  ;----------------------------------------------------------------------------
  8698                                  
  8699                                  StrCmp:
  8700 00001FD5 56                      	push	si
  8701 00001FD6 57                      	push	di
  8702 00001FD7 50                      	push	ax
  8703                                  
  8704                                  Cmplp:
  8705 00001FD8 AC                      	LODSB
  8706 00001FD9 E81339                  	call	UCase			; convert to upper case
  8707 00001FDC E84C39                  	call	PATHCHRCMP		; convert / to 	MOV	AH,AL
  8709 00001FDF 268A05                  	MOV	AL,[ES:DI]
  8710 00001FE2 47                      	INC	DI
  8711 00001FE3 E80939                  	call	UCase			; convert to upper case
  8712 00001FE6 E84239                  	call	PATHCHRCMP		; convert / to 	CMP	AH,AL
  8714 00001FE9 7504                    	JNZ	short PopRet		; Strings dif
  8715                                  Tend:
  8716 00001FEB 08C0                    	OR	AL,AL
  8717 00001FED 75E9                    	JNZ	short Cmplp		; More string
  8718                                  PopRet:
  8719 00001FEF 58                      	pop	ax
  8720 00001FF0 5F                      	pop	di
  8721 00001FF1 5E                      	pop	si
  8722 00001FF2 C3                      	retn
  8723                                  
  8724                                  ;Break <STRCPY - copy ASCIZ string from DS:SI to ES:DI>
  8725                                  ;----------------------------------------------------------------------------
  8726                                  ;
  8727                                  ;   Strcpy - copy an ASCIZ string from DS:SI to ES:DI and make uppercase
  8728                                  ;   FStrcpy - copy an ASCIZ string from DS:SI to ES:DI.  no modification of
  8729                                  ;	characters.
  8730                                  ;
  8731                                  ;   Inputs:	DS:SI - pointer to source string
  8732                                  ;		ES:DI - pointer to destination string
  8733                                  ;   Outputs:	ES:DI point byte after nul byte at end of dest string
  8734                                  ;		DS:SI point byte after nul byte at end of source string
  8735                                  ;   Registers modified: SI,DI
  8736                                  ;----------------------------------------------------------------------------
  8737                                  
  8738                                  StrCpy:
  8739 00001FF3 50                      	push	ax
  8740                                  CPYLoop:
  8741 00001FF4 AC                      	LODSB
  8742 00001FF5 E8F738                  	call	UCase			; convert to upper case
  8743 00001FF8 E83039                  	call	PATHCHRCMP		; convert / to \ ;
  8744 00001FFB AA                      	STOSB
  8745                                  Tend2:
  8746 00001FFC 08C0                    	OR	AL,AL
  8747 00001FFE 75F4                    	JNZ	short CPYLoop
  8748 00002000 58                      	pop	ax
  8749 00002001 C3                      	retn
  8750                                  
  8751                                  ;----------------------------------------------------------------------------
  8752                                  ; Procedure Name : FStrCpy
  8753                                  ;----------------------------------------------------------------------------
  8754                                  
  8755                                  FStrCpy:
  8756 00002002 50                      	push	ax
  8757                                  FCPYLoop:
  8758 00002003 AC                      	LODSB
  8759 00002004 AA                      	STOSB
  8760 00002005 08C0                    	OR	AL,AL
  8761 00002007 75FA                    	JNZ	short FCPYLoop
  8762 00002009 58                      	pop	ax
  8763 0000200A C3                      	retn
  8764                                  
  8765                                  ; 20/07/2018 - Retro DOS v3.0
  8766                                  ;----------------------------------------------------------------------------
  8767                                  ; UCase, IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1E2Fh
  8768                                  ;----------------------------------------------------------------------------
  8769                                  ;
  8770                                  ;UCase:	
  8771                                  ;	call	_UCase	 ; Offset 5518h (GetLet, Offset 5517h)
  8772                                  ;	retn
  8773                                  
  8774                                  ;Break <StrLen - compute length of string ES:DI>
  8775                                  ;----------------------------------------------------------------------------
  8776                                  ;**	StrLen - Compute Length of String
  8777                                  ;
  8778                                  ;	StrLen computes the length of a string, including the trailing 00
  8779                                  ;
  8780                                  ;	ENTRY	(es:di) = address of string
  8781                                  ;	EXIT	(cx) = size of string
  8782                                  ;	USES	cx, flags
  8783                                  ;----------------------------------------------------------------------------
  8784                                  
  8785                                  StrLen:
  8786 0000200B 57                      	push	di
  8787 0000200C 50                      	push	ax
  8788                                  	;MOV	CX,-1
  8789 0000200D B9FFFF                  	mov	cx,65535
  8790 00002010 30C0                    	XOR	AL,AL
  8791 00002012 F2AE                    	REPNE	SCASB
  8792 00002014 F7D1                    	NOT	CX
  8793 00002016 58                      	pop	ax
  8794 00002017 5F                      	pop	di
  8795 00002018 C3                      	retn
  8796                                  
  8797                                  ;----------------------------------------------------------------------------
  8798                                  ;**	DStrLen - Compute Length of String
  8799                                  ;
  8800                                  ;	ENTRY	(ds:si) = address of string
  8801                                  ;	EXIT	(cx) = size of string, including trailing NUL
  8802                                  ;	USES	cx, flags
  8803                                  ;----------------------------------------------------------------------------
  8804                                  
  8805                                  DStrLen:	; BUGBUG - this guy is a pig, who uses him?
  8806 00002019 E80700                  	CALL	XCHGP
  8807 0000201C E8ECFF                  	CALL	StrLen
  8808 0000201F E80100                  	CALL	XCHGP
  8809 00002022 C3                      	retn
  8810                                  
  8811                                  ;----------------------------------------------------------------------------
  8812                                  ;**	XCHGP - Exchange Source and Destination Pointers
  8813                                  ;
  8814                                  ;	XCHGP exchanges (DS:SI) and (ES:DI)
  8815                                  ;
  8816                                  ;	ENTRY	none
  8817                                  ;	EXIT	pairs exchanged
  8818                                  ;	USES	SI, DI, DS, ES
  8819                                  ;----------------------------------------------------------------------------
  8820                                  
  8821                                  XCHGP:
  8822 00002023 1E                      	push	ds
  8823 00002024 06                      	push	es
  8824 00002025 1F                      	pop	ds
  8825 00002026 07                      	pop	es
  8826 00002027 87F7                    	XCHG	SI,DI
  8827                                  xchgp_retn:
  8828 00002029 C3                      	retn
  8829                                  
  8830                                  ;Break	<Idle - wait for a specified amount of time>
  8831                                  ;----------------------------------------------------------------------------
  8832                                  ;
  8833                                  ;   Idle - when retrying an operation due to a lock/sharing violation,
  8834                                  ;   	   we spin until RetryLoop is exhausted.
  8835                                  ;
  8836                                  ;   Inputs:	RetryLoop is the number of times we spin
  8837                                  ;   Outputs:	Wait
  8838                                  ;   Registers modified: none
  8839                                  ;----------------------------------------------------------------------------
  8840                                  
  8841                                  Idle:
  8842                                  	;test	byte [SS:FSHARING],0FFh
  8843 0000202A 36803E[2F05]00          	cmp	byte [SS:FSHARING],0	;hkn; SS override
  8844                                  	;retnz
  8845 00002030 75F7                    	jnz	short xchgp_retn
  8846                                  	;SAVE	<CX>
  8847 00002032 51                      	push	cx
  8848 00002033 368B0E[1C00]            	MOV	CX,[ss:RetryLoop]	;hkn; SS override
  8849 00002038 E308                    	JCXZ	Idle3
  8850                                  Idle1:	
  8851 0000203A 51                      	PUSH	CX
  8852 0000203B 31C9                    	XOR	CX,CX
  8853                                  Idle2:	
  8854 0000203D E2FE                    	LOOP	Idle2
  8855 0000203F 59                      	POP	CX
  8856 00002040 E2F8                    	LOOP	Idle1
  8857                                  Idle3:	
  8858                                  	;RESTORE <CX>
  8859 00002042 59                      	pop	cx
  8860 00002043 C3                      	retn
  8861                                  
  8862                                  ;Break	<TableDispatch - dispatch to a table>
  8863                                  ;----------------------------------------------------------------------------
  8864                                  ;
  8865                                  ;   TableDispatch - given a table and an index, jmp to the approptiate
  8866                                  ;   routine.  Preserve all input registers to the routine.
  8867                                  ;
  8868                                  ;   Inputs:	Push	return address
  8869                                  ;		Push	Table address
  8870                                  ;		Push	index (byte)
  8871                                  ;   Outputs:	appropriate routine gets jumped to.
  8872                                  ;		return indicates invalid index
  8873                                  ;   Registers modified: none.
  8874                                  ;----------------------------------------------------------------------------
  8875                                  
  8876                                  struc TFrame	 ; TableFrame
  8877 00000000 ????                    .OldBP:	 resw 1  ; 0
  8878 00000002 ????                    .OldRet: resw 1  ; 2
  8879 00000004 ??                      .Index:	 resb 1  ; 4
  8880 00000005 ??                      .Pad:	 resb 1  ; 5  
  8881 00000006 ????                    .Tab:	 resw 1  ; 6
  8882 00000008 ????                    .NewRet: resw 1  ; 8
  8883                                  endstruc
  8884                                  
  8885                                  TableDispatch:
  8886 00002044 55                      	PUSH	BP
  8887 00002045 89E5                    	MOV	BP,SP
  8888 00002047 53                      	PUSH	BX			; save BX
  8889                                  	;mov	bx,[bp+6]
  8890 00002048 8B5E06                  	MOV	BX,[BP+TFrame.Tab]	; get pointer to table
  8891 0000204B 2E8A1F                  	MOV	BL,[CS:BX]		; maximum index
  8892                                  	;cmp	[bp+4],bl
  8893 0000204E 385E04                  	CMP	[BP+TFrame.Index],BL	; table error?
  8894 00002051 7317                    	JAE	short TableError	; yes
  8895                                  	;mov	bl,[bp+4]
  8896 00002053 8A5E04                  	MOV	BL,[BP+TFrame.Index]	; get desired table index
  8897 00002056 30FF                    	XOR	BH,BH			; convert to word
  8898 00002058 D1E3                    	SHL	BX,1			; convert to word pointer
  8899 0000205A 43                      	INC	BX			; point past first length byte
  8900                                  	; 17/08/2018
  8901                                  	;add	bx,[bp+6]
  8902 0000205B 035E06                  	ADD	BX,[BP+TFrame.Tab]	; get real offset
  8903 0000205E 2E8B1F                  	MOV	BX,[CS:BX]		; get contents of table entry
  8904                                  	;mov	[bp+6],bx
  8905 00002061 895E06                  	MOV	[BP+TFrame.Tab],BX	; put table entry into return address
  8906 00002064 5B                      	POP	BX			; restore BX
  8907 00002065 5D                      	POP	BP			; restore BP
  8908 00002066 83C404                  	ADD	SP,4			; clean off Index and our return addr
  8909 00002069 C3                      	retn				; do operation
  8910                                  TableError:
  8911 0000206A 5B                      	POP	BX			; restore BX
  8912 0000206B 5D                      	POP	BP			; restore BP
  8913 0000206C C20600                  	RETN	6			; clean off Index, Table and RetAddr
  8914                                  
  8915                                  
  8916                                  ;Break	<TestNet - determine if a CDS is for the network>
  8917                                  ;----------------------------------------------------------------------------
  8918                                  ;
  8919                                  ;   TestNet - examine CDS pointed to by ThisCDS and see if it indicates a
  8920                                  ;	network CDS.  This will handle NULL cds also.
  8921                                  ;
  8922                                  ;   Inputs:	ThisCDS points to CDS or NULL
  8923                                  ;   Outputs:	ES:DI = ThisCDS
  8924                                  ;		carry Set => network
  8925                                  ;		carry Clear => local
  8926                                  ;   Registers modified: none.
  8927                                  ;----------------------------------------------------------------------------
  8928                                  
  8929                                  TestNet:
  8930 0000206F 2EC43E[5E05]            	LES	DI,[CS:THISCDS]
  8931 00002074 83FFFF                  	CMP	DI,-1
  8932 00002077 7409                    	JZ	short CMCRet		; UNC? carry is clear
  8933                                  	;test	word [es:di+43h],8000h
  8934 00002079 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
  8935 0000207F 7501                    	JNZ	short CMCRet		; jump has carry clear
  8936 00002081 C3                      	retn				; carry is clear
  8937                                  CMCRet: 
  8938 00002082 F5                      	CMC
  8939 00002083 C3                      	retn
  8940                                  
  8941                                  ;Break	<IsSFTNet - see if an sft is for the network>
  8942                                  ;----------------------------------------------------------------------------
  8943                                  ;
  8944                                  ;   IsSFTNet - examine SF pointed to by ES:DI and see if it indicates a
  8945                                  ;	network file.
  8946                                  ;
  8947                                  ;   Inputs:	ES:DI point to SFT
  8948                                  ;   Outputs:	Zero set if not network sft
  8949                                  ;		zero reset otherwise
  8950                                  ;		Carry CLEAR!!!
  8951                                  ;   Registers modified: none.
  8952                                  ;----------------------------------------------------------------------------
  8953                                  
  8954                                  IsSFTNet:
  8955                                  	;test	word [es:di+5],8000h
  8956 00002084 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
  8957 0000208A C3                      	retn
  8958                                  
  8959                                  ;Break	<FastInit - Initialize FastTable entries >
  8960                                  ;----------------------------------------------------------------------------
  8961                                  ;   DOS 4.00   2/9/87
  8962                                  ;   FastInit  - initialize the FASTXXX routine entry
  8963                                  ;		  in the FastTable
  8964                                  ;
  8965                                  ;   Inputs:	BX = FASTXXX ID ( 1=fastopen )
  8966                                  ;		DS:SI = address of FASTXXX routine entry
  8967                                  ;		   SI = -1 for query only
  8968                                  ;   Outputs:	Carry flag clear, if success
  8969                                  ;		Carry flag set,   if failure
  8970                                  ;
  8971                                  ;
  8972                                  ;----------------------------------------------------------------------------
  8973                                  
  8974                                  ;Procedure FastInit,NEAR
  8975                                  ;	ASSUME	CS:DOSCODE,SS:NOTHING
  8976                                  ;FastInit:
  8977                                  	; MSDOS 6.0
  8978                                  	;hkn; set up es to dosdataseg.
  8979                                  	;push	es
  8980                                  	;getdseg <es>			; es -> dosdata
  8981                                  
  8982                                  	;hkn; FastTable is in DOSDATA
  8983                                  	;MOV	DI,OFFSET DOSDATA:FastTable + 2 ;AN000;FO. points to fastxxx entry
  8984                                  	;DEC	BX				;AN000;FO.;; decrement index
  8985                                  	;MOV	DX,BX				;AN000;FO.;; save bx
  8986                                  	;SHL	BX,1				;AN000;FO.;; times 4 , each entry is DWORD
  8987                                  	;SHL	BX,1				;AN000;FO.
  8988                                  	;ADD	DI,BX				;AN000;FO. index to the entry
  8989                                  	;MOV	AX,WORD PTR ES:[DI+2]		;AN000;FO. get entry segment
  8990                                  ;fcheck: 					;AN000;
  8991                                  	;MOV	CX,CS				;AN000;FO.;; get DOS segment
  8992                                  	;CMP	AX,CX				;AN000;FO.;; first time installed ?
  8993                                  	;JZ	short ok_install			;AN000;FO.;; yes
  8994                                  	;OR	AX,AX				;AN000;FO.;
  8995                                  	;JZ	short ok_install		;AN000;FO.;
  8996                                  	;STC					;AN000;FO.;; already installed !
  8997                                  	;JMP	SHORT FSret			;AN000;FO. set carry
  8998                                  ;ok_install:					;AN000;
  8999                                  	;CMP	SI,-1				;AN000;FO.; Query only ?
  9000                                  	;JZ	short FSret			;AN000;FO.; yes
  9001                                  	;MOV	CX,DS				;AN000;FO.; get FASTXXX entry segment
  9002                                  	;MOV	WORD PTR ES:[DI+2],CX		;AN000;FO.; initialize routine entry
  9003                                  	;MOV	WORD PTR ES:[DI],SI		;AN000;FO.; initialize routine offset
  9004                                  
  9005                                  ;hkn; FastFlg moved to DOSDATA
  9006                                  	;MOV	DI,OFFSET DOSDATA:FastFlg	;AN000;FO.; get addr of FASTXXX flags
  9007                                  	;ADD	DI,DX				;AN000;FO.; index to a FASTXXX flag
  9008                                  	;OR	byte ptr ES:[DI],Fast_yes	;AN000;FO.; indicate installed
  9009                                  FSret:						;AN000;
  9010                                  	;pop	es
  9011                                  	;return					;AN000;FO.
  9012                                  ;EndProc FastInit				;AN000;FO.
  9013                                  
  9014                                  	; MSDOS 3.3
  9015                                  	; IBMDOS.COM (1987) - Offset 1EB3h
  9016                                  FastInit:
  9017 0000208B BF[730F]                	mov	di,FastTable ; FastOpenTable
  9018 0000208E 2E8B4504                	mov	ax,[cs:di+4]		; Entry segment
  9019 00002092 8CCB                    	mov	bx,cs			; get DOS segment
  9020 00002094 39D8                    	cmp	ax,bx			; first time installed ?	
  9021 00002096 7402                    	je	short ok_install	; yes
  9022 00002098 F9                      	stc				; set carry
  9023 00002099 C3                      	retn				; (cf=1 means) already installed !
  9024                                  
  9025                                  ok_install:
  9026 0000209A BB[730F]                	mov	bx,FastTable ; FastOpenTable
  9027 0000209D 8CD9                    	mov	cx,ds
  9028                                  	; set address of FASTXXX (FASTOPEN) routine entry
  9029 0000209F 2E894F04                	mov	[cs:bx+4],cx
  9030 000020A3 2E897702                	mov	[cs:bx+2],si
  9031 000020A7 C3                      	retn
  9032                                  
  9033                                  ;Break	<FastRet - initial routine in FastOpenTable >
  9034                                  ;----------------------------------------------------------------------------
  9035                                  ;   DOS 3.3   6/10/86
  9036                                  ;   FastRet	- indicate FASTXXXX  not in memory
  9037                                  ;
  9038                                  ;   Inputs:	None
  9039                                  ;   Outputs:	AX = -1 and carry flag set
  9040                                  ;
  9041                                  ;   Registers modified: none.
  9042                                  ;----------------------------------------------------------------------------
  9043                                  
  9044                                  FastRet:
  9045                                  	;mov	ax,-1
  9046                                  	;stc
  9047                                  	;retf
  9048 000020A8 F9                      	STC
  9049 000020A9 19C0                    	sbb	ax,ax		; (ax) = -1, 'C' set
  9050 000020AB CB                      	RETF
  9051                                  
  9052                                  ;Break	<NLS_OPEN - do $open for NLSFUNC>
  9053                                  ;----------------------------------------------------------------------------
  9054                                  ;   DOS 3.3   6/10/86
  9055                                  ;   NLS_OPEN	- call $OPEN for NLSFUNC
  9056                                  ;
  9057                                  ;   Inputs:	Same input as $OPEN except CL = mode
  9058                                  ;   Outputs:	same output as $OPEN
  9059                                  ;
  9060                                  ;----------------------------------------------------------------------------
  9061                                  
  9062                                  ;hkn; NOTE! SS MUST HAVE BEEN SET UP TO DOSDATA BY THE TIME THESE
  9063                                  ;hkn; NLS FUNCTIONS ARE CALLED!!! THERE FORE WE WILL USE SS OVERRIDES
  9064                                  ;hkn; IN ORDER TO ACCESS DOS DATA VARIABLES!
  9065                                  
  9066                                  NLS_OPEN:
  9067                                  ;	MOV	BL,[CPSWFLAG]	 ; disable code page matching logic
  9068                                  ;	MOV	BYTE [CPSWFLAG],0
  9069                                  ;	PUSH	BX		 ; save current state
  9070                                  
  9071 000020AC 88C8                    	MOV	AL,CL		 ; set up correct interface for $OPEN
  9072 000020AE E8CB52                  	call	_$OPEN
  9073                                  
  9074                                   ;	POP	BX		 ; restore current state
  9075                                   ;	MOV	[CPSWFLAG],BL
  9076 000020B1 C3                      	RETN
  9077                                  
  9078                                  ;Break	<NLS_LSEEK - do $LSEEK for NLSFUNC>
  9079                                  ;----------------------------------------------------------------------------
  9080                                  ;   DOS 3.3   6/10/86
  9081                                  ;   NLS_LSEEK	- call $LSEEK for NLSFUNC
  9082                                  ;
  9083                                  ;   Inputs:	BP = open mode
  9084                                  ;   Outputs:	same output as $LSEEK
  9085                                  ;
  9086                                  ;----------------------------------------------------------------------------
  9087                                  
  9088                                  NLS_LSEEK:
  9089                                  	;PUSH	word [SS:USER_SP] ; save user stack
  9090                                  	;PUSH	word [SS:USER_SS]
  9091 000020B2 2EFF36[4005]            	PUSH	word [CS:USER_SP] ; save user stack
  9092 000020B7 2EFF36[4205]            	PUSH	word [CS:USER_SS]
  9093 000020BC E81000                  	CALL	Fake_User_Stack
  9094 000020BF 89E8                    	MOV	AX,BP		; set up correct interface for $LSEEK
  9095 000020C1 E8B751                  	call	_$LSEEK
  9096                                  	;POP	word [SS:USER_SS] ; restore user stack
  9097                                  	;POP	word [SS:USER_SP]
  9098 000020C4 2E8F06[4205]            	POP	word [cs:USER_SS] ; restore user stack
  9099 000020C9 2E8F06[4005]            	POP	word [cs:USER_SP]
  9100 000020CE C3                      	RETN
  9101                                  
  9102                                  ;Break	<Fake_User_Stack - save user stack>
  9103                                  ;----------------------------------------------------------------------------
  9104                                  ;   DOS 3.3   6/10/86
  9105                                  ;   Fake_User_Stack - save user stack pointer
  9106                                  ;
  9107                                  ;----------------------------------------------------------------------------
  9108                                  
  9109                                  Fake_User_Stack:
  9110                                  	;MOV	AX,[ss:USER_SP_2F] ; replace with INT 2F stack
  9111 000020CF 2EA1[A70F]              	MOV	AX,[cs:USER_SP_2F]
  9112                                  	;MOV	[SS:USER_SP],AX
  9113 000020D3 2EA3[4005]              	MOV	[CS:USER_SP],AX
  9114 000020D7 8CC8                    	MOV	AX,CS
  9115                                  	;mov	ax,ss
  9116                                  	;MOV	[SS:USER_SS],AX
  9117 000020D9 2EA3[4205]              	MOV	[CS:USER_SS],AX
  9118 000020DD C3                      	RETN
  9119                                  
  9120                                  ;Break	<GetDevList - get device header list pointer>
  9121                                  ;----------------------------------------------------------------------------
  9122                                  ;   DOS 3.3   7/25/86
  9123                                  ;   GetDevList - get device header list pointer
  9124                                  ;
  9125                                  ;   Output: AX:BX points to the device header list
  9126                                  ;----------------------------------------------------------------------------
  9127                                  
  9128                                  GetDevList:
  9129 000020DE BE[6B0F]                	MOV	SI,SysInitTable
  9130                                  	;LDS	SI,[CS:SI+SYSINITVARS]
  9131 000020E1 2EC534                  	LDS	SI,[CS:SI]
  9132                                  	;mov	ax,[si+34]  ; SSYSINITVARS offset 34 = [SI+SYSI.DEV]
  9133                                  	;mov	bx,[si+36]  ; SSYSINITVARS offset 36 = [SI+SYSI.DEV+2]
  9134 000020E4 8B4422                  	MOV	AX,[SI+SYSI.DEV]
  9135 000020E7 8B5C24                  	MOV	BX,[SI+SYSI.DEV+2]
  9136 000020EA C3                      	RETN
  9137                                  
  9138                                  ;Break	<NLS_IOCTL - do $IOCTL for NLSFUNC   >
  9139                                  ;----------------------------------------------------------------------------
  9140                                  ;   DOS 3.3   7/25/86
  9141                                  ;   NLS_IOCTL	- call $IOCTL for NLSFUNC
  9142                                  ;
  9143                                  ;   Inputs:	BP = function code 0CH
  9144                                  ;   Outputs:	same output as generic $IOCTL
  9145                                  ;
  9146                                  ;----------------------------------------------------------------------------
  9147                                  
  9148                                  NLS_IOCTL:
  9149                                  	;PUSH	word [SS:USER_SP] ; save user stack
  9150                                  	;PUSH	word [SS:USER_SS]
  9151 000020EB 2EFF36[4005]            	PUSH	word [CS:USER_SP] ; save user stack
  9152 000020F0 2EFF36[4205]            	PUSH	word [CS:USER_SS]
  9153 000020F5 E8D7FF                  	CALL	Fake_User_Stack
  9154 000020F8 89E8                    	MOV	AX,BP	     ; set up correct interface for $LSEEK
  9155 000020FA E8320F                  	call	_$IOCTL
  9156                                  	;POP	word [SS:USER_SS] ; restore user stack
  9157                                  	;POP	word [SS:USER_SP]
  9158 000020FD 2E8F06[4205]            	POP	word [CS:USER_SS] ; restore user stack
  9159 00002102 2E8F06[4005]            	POP	word [CS:USER_SP]
  9160 00002107 C3                      	RETN
  9161                                  
  9162                                  ;Break	<NLS_GETEXT- get extended error for NLSFUNC>
  9163                                  ;----------------------------------------------------------------------------
  9164                                  ;   DOS 3.3   7/25/86
  9165                                  ;   NLS_GETEXT	-
  9166                                  ;
  9167                                  ;   Inputs:	none
  9168                                  ;   Outputs:	AX = extended error
  9169                                  ;
  9170                                  ;----------------------------------------------------------------------------
  9171                                  
  9172                                  NLS_GETEXT:
  9173                                  	;MOV	AX,[SS:EXTERR]	 ; return extended error
  9174 00002108 2EA1[F002]              	mov	AX,[CS:EXTERR]
  9175 0000210C C3                      	RETN
  9176                                  
  9177                                  ;============================================================================
  9178                                  ; EcritDisk, LcritDisk, EcritDevice, LCritDevice
  9179                                  ; IBMDOS.COM (MSDOS 3.3), 1987 - Offset 1F36h
  9180                                  ;============================================================================
  9181                                  ; 20/07/2018 - Retro DOS v3.0
  9182                                  
  9183                                  	; MSDOS 3.3
  9184                                  	; 08/08/2018 - Retro DSOS v3.0
  9185                                  EcritMem:
  9186                                  EcritSFT:
  9187                                  	;
  9188                                  EcritDisk:
  9189                                  	;push	ax
  9190 0000210D C3                      	retn
  9191                                  	
  9192 0000210E B80180                  	mov	ax,8001h
  9193 00002111 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9194                                  			; AL = critical section number (00h-0Fh)
  9195 00002113 58                      	pop	ax
  9196 00002114 C3                      	retn
  9197                                  
  9198                                  	; MSDOS 3.3
  9199                                  	; 08/08/2018 - Retro DSOS v3.0
  9200                                  LcritMem:
  9201                                  LcritSFT:
  9202                                  	;
  9203                                  LcritDisk:
  9204                                  	;push	ax
  9205 00002115 C3                      	retn
  9206                                  	
  9207 00002116 B80181                  	mov	ax,8101h
  9208 00002119 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9209                                  			; AL = critical section number (00h-0Fh)
  9210 0000211B 58                      	pop	ax
  9211 0000211C C3                      	retn
  9212                                  
  9213                                  EcritDevice:
  9214                                  	;push	ax
  9215 0000211D C3                      	retn
  9216                                  	
  9217 0000211E B80280                  	mov	ax,8002h
  9218 00002121 CD2A                    	int	2Ah	; Microsoft Networks - BEGIN DOS CRITICAL SECTION
  9219                                  			; AL = critical section number (00h-0Fh)
  9220 00002123 58                      	pop	ax
  9221 00002124 C3                      	retn
  9222                                  
  9223                                  LcritDevice:
  9224                                  	;push	ax
  9225 00002125 C3                      	retn
  9226                                  	
  9227 00002126 B80281                  	mov	ax,8102h
  9228 00002129 CD2A                    	int	2Ah	; Microsoft Networks - END DOS CRITICAL SECTION
  9229                                  			; AL = critical section number (00h-0Fh)
  9230 0000212B 58                      	pop	ax
  9231 0000212C C3                      	retn
  9232                                  
  9233                                  ;============================================================================
  9234                                  ; CRIT.ASM, MSDOS 6.0, 1991
  9235                                  ;============================================================================
  9236                                  ; 20/07/2018 - Retro DOS v3.0
  9237                                  
  9238                                  ; (DOSMAC.INC, MSDOS 6.0, 1991)
  9239                                  
  9240                                  ; Some old versions of the 80286 have a bug in the chip.  The popf
  9241                                  ; instruction will enable interrupts.  Therefore in a section of code with
  9242                                  ; interrupts disabled and you need a popf instruction use the 'popff'
  9243                                  ; macro instead.
  9244                                  ;
  9245                                  
  9246                                  ;%macro POPFF 0
  9247                                  ;	jmp	$+3
  9248                                  ;	iret
  9249                                  ;	push	cs
  9250                                  ;	call	$-2
  9251                                  ;%endmacro
  9252                                  
  9253                                  ;**	CRIT.ASM - Critical Section Routines
  9254                                  ;
  9255                                  ;	Critical section handlers
  9256                                  ;
  9257                                  ;	Modification history:
  9258                                  ;
  9259                                  ;	    Created: ARR 30 March 1983
  9260                                  
  9261                                  ;
  9262                                  ;SR; This variable is set when the redir installs itself
  9263                                  ;
  9264                                  	;I_need redir_patch,BYTE
  9265                                  
  9266                                  ; Break	<Critical section handlers>
  9267                                  
  9268                                  ;   Each handler must leave everything untouched; including flags!
  9269                                  ;
  9270                                  ;   Sleaze for time savings:  first instruction is a return.  This is patched
  9271                                  ;   by the sharer to be a PUSH AX to complete the correct routines.
  9272                                  
  9273                                  ;Procedure  EcritDisk,NEAR
  9274                                  	;public  EcritMem
  9275                                  	;public  EcritSFT
  9276                                  ;ECritMEM    LABEL   NEAR
  9277                                  ;ECritSFT    LABEL   NEAR
  9278                                  
  9279                                  ;
  9280                                  ;SR; Check if critical section is to be entered
  9281                                  ;
  9282                                  
  9283                                  ;	pushf
  9284                                  ;	cmp	ss:[redir_patch],0
  9285                                  ;	jz	@f
  9286                                  ;	popff
  9287                                  ;
  9288                                  ;       PUSH    AX
  9289                                  ;	MOV     AX,8000h+critDisk
  9290                                  ;	INT     int_ibm
  9291                                  ;	POP     AX
  9292                                  ;	return
  9293                                  ;@@:
  9294                                  ;	popff
  9295                                  ;	ret
  9296                                  ;EndProc EcritDisk
  9297                                  
  9298                                  ;Procedure   LcritDisk,NEAR
  9299                                  ;	public  LcritMem
  9300                                  ;	public  LcritSFT
  9301                                  ;LCritMEM    LABEL   NEAR
  9302                                  ;LCritSFT    LABEL   NEAR
  9303                                  
  9304                                  ;
  9305                                  ;SR; Check if critical section is to be entered
  9306                                  ;
  9307                                  
  9308                                  ;	pushf
  9309                                  ;	cmp	ss:[redir_patch],0
  9310                                  ;	jz	@f
  9311                                  ;	popff
  9312                                  
  9313                                  ;       PUSH    AX
  9314                                  ;	MOV     AX,8100h+critDisk
  9315                                  ;	INT     int_ibm
  9316                                  ;	POP     AX
  9317                                  ;	return
  9318                                  ;@@:
  9319                                  ;	popff
  9320                                  ;	ret
  9321                                  
  9322                                  ;EndProc LcritDisk
  9323                                  
  9324                                  ;Procedure   EcritDevice,NEAR
  9325                                  ;
  9326                                  ;SR; Check if critical section is to be entered
  9327                                  ;
  9328                                  
  9329                                  ;	pushf
  9330                                  ;	cmp	ss:[redir_patch],0
  9331                                  ;	jz	@f
  9332                                  ;	popff
  9333                                  
  9334                                  ;       PUSH    AX
  9335                                  ;	MOV     AX,8000h+critDevice
  9336                                  ;	INT     int_ibm
  9337                                  ;	POP     AX
  9338                                  ;	return
  9339                                  ;@@:
  9340                                  ;	popff
  9341                                  ;	ret
  9342                                  
  9343                                  ;EndProc EcritDevice
  9344                                  
  9345                                  ;Procedure   LcritDevice,NEAR
  9346                                  ;
  9347                                  ;SR; Check if critical section is to be entered
  9348                                  ;
  9349                                  
  9350                                  ;	pushf
  9351                                  ;	cmp	ss:[redir_patch],0
  9352                                  ;	jz	@f
  9353                                  ;	popff
  9354                                  
  9355                                  ;       PUSH    AX
  9356                                  ;	MOV     AX,8100h+critDevice
  9357                                  ;	INT     int_ibm
  9358                                  ;	POP     AX
  9359                                  ;	return
  9360                                  ;@@:
  9361                                  ;	popff
  9362                                  ;	ret
  9363                                  
  9364                                  ;EndProc LcritDevice
  9365                                  
  9366                                  
  9367                                  ;============================================================================
  9368                                  ; CPMIO.ASM, MSDOS 6.0, 1991
  9369                                  ;============================================================================
  9370                                  ; 20/07/2018 - Retro DOS v3.0
  9371                                  
  9372                                  ;============================================================================
  9373                                  ; STDIO.ASM - (MSDOS 2.0)
  9374                                  ;============================================================================
  9375                                  
  9376                                  ;
  9377                                  ; Standard device IO for MSDOS (first 12 function calls)
  9378                                  ;
  9379                                  
  9380                                  ;.xlist
  9381                                  ;.xcref
  9382                                  ;INCLUDE STDSW.ASM
  9383                                  ;INCLUDE DOSSEG.ASM
  9384                                  ;.cref
  9385                                  ;.list
  9386                                  
  9387                                  ;TITLE   STDIO - device IO for MSDOS
  9388                                  ;NAME    STDIO
  9389                                  
  9390                                  ;INCLUDE IO.ASM
  9391                                  
  9392                                  ; ---------------------------------------------------------------------------
  9393                                  ;
  9394                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9395                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9396                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9397                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9398                                  ;			    to restore MSDOS 2.0 device IO source code 
  9399                                  ;
  9400                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)	
  9401                                  	
  9402                                  ;============================================================================
  9403                                  ; STDIO.ASM - (MSDOS 2.0)
  9404                                  ;============================================================================
  9405                                  
  9406                                  ;
  9407                                  ; Standard device IO for MSDOS (first 12 function calls)
  9408                                  ;
  9409                                  
  9410                                  ;.xlist
  9411                                  ;.xcref
  9412                                  ;INCLUDE STDSW.ASM
  9413                                  ;INCLUDE DOSSEG.ASM
  9414                                  ;.cref
  9415                                  ;.list
  9416                                  
  9417                                  ;TITLE   STDIO - device IO for MSDOS
  9418                                  ;NAME    STDIO
  9419                                  
  9420                                  ;INCLUDE IO.ASM
  9421                                  
  9422                                  ; ---------------------------------------------------------------------------
  9423                                  ;
  9424                                  ; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
  9425                                  ;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
  9426                                  ;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
  9427                                  ;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
  9428                                  ;			    to restore MSDOS 2.0 device IO source code 
  9429                                  ;
  9430                                  ;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
  9431                                  ;
  9432                                  ;============================================================================
  9433                                  ; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
  9434                                  ;============================================================================
  9435                                  ; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018
  9436                                  
  9437                                  ; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
  9438                                  ; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 
  9439                                  
  9440                                  ;**	Standard device IO for MSDOS (first 12 function calls)
  9441                                  ;
  9442                                  ;	TITLE	IBMCPMIO - device IO for MSDOS
  9443                                  ;	NAME	IBMCPMIO
  9444                                  
  9445                                  ;	Old style CP/M 1-12 system calls to talk to reserved devices
  9446                                  ;
  9447                                  ;	$Std_Con_Input_No_Echo
  9448                                  ;	$Std_Con_String_Output
  9449                                  ;	$Std_Con_String_Input
  9450                                  ;	$RawConIO
  9451                                  ;	$RawConInput
  9452                                  ;	RAWOUT
  9453                                  ;	RAWOUT2
  9454                                  ;
  9455                                  
  9456                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9457                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9458                                  ; references to be SS or CS relative which is desired.
  9459                                  
  9460                                  ; ---------------------------------------------------------------------------
  9461                                  
  9462                                  ;	TITLE	CPMIO2 - device IO for MSDOS
  9463                                  ;	NAME	CPMIO2
  9464                                  
  9465                                  ;
  9466                                  ;	Microsoft Confidential
  9467                                  ;	Copyright (C) Microsoft Corporation 1991
  9468                                  ;	All Rights Reserved.
  9469                                  ;
  9470                                  
  9471                                  ;**	Old style CP/M 1-12 system calls to talk to reserved devices
  9472                                  ;
  9473                                  ;	$Std_Con_Input
  9474                                  ;	$Std_Con_Output
  9475                                  ;	OUTT
  9476                                  ;	TAB
  9477                                  ;	BUFOUT
  9478                                  ;	$Std_Aux_Input
  9479                                  ;	$Std_Aux_Output
  9480                                  ;	$Std_Printer_Output
  9481                                  ;	$Std_Con_Input_Status
  9482                                  ;	$Std_Con_Input_Flush
  9483                                  ;
  9484                                  ;	Revision History:
  9485                                  ;
  9486                                  ;	  AN000	 version 4.00 - Jan. 1988
  9487                                  
  9488                                  ; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
  9489                                  ; They assume ES and DS NOTHING, while not strictly correct, this forces data
  9490                                  ; references to be SS or CS relative which is desired.
  9491                                  
  9492                                  ;DOSCODE SEGMENT
  9493                                  ;	ASSUME	SS:DOSDATA,CS:DOSCODE
  9494                                  
  9495                                  
  9496                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
  9497                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
  9498                                  ;hkn;	not valid. 
  9499                                  
  9500                                  ;
  9501                                  ;----------------------------------------------------------------------------
  9502                                  ;
  9503                                  ; Procedure : $Std_Con_Input_No_Echo
  9504                                  ;
  9505                                  ;----------------------------------------------------------------------------
  9506                                  ;
  9507                                  
  9508                                  _$STD_CON_INPUT_NO_ECHO:   ;System call 8
  9509                                  
  9510                                  ; Inputs:
  9511                                  ;	None
  9512                                  ; Function:
  9513                                  ;	Input character from console, no echo
  9514                                  ; Returns:
  9515                                  ;	AL = character
  9516                                  
  9517 0000212D 1E                      	push	ds
  9518 0000212E 56                      	push	si
  9519                                  INTEST:
  9520 0000212F E8A038                  	call	STATCHK
  9521 00002132 753B                    	jnz	short GET ; 08/09/2018
  9522                                  ;*************************************************************************
  9523                                  ;hkn; SS override
  9524 00002134 36803E[360A]00          	cmp	byte [SS:PRINTER_FLAG],0  ; is printer idle?
  9525 0000213A 7505                    	jnz	short no_sys_wait
  9526 0000213C B405                    	mov	ah,5			; get input status with system wait
  9527 0000213E E8442E                  	call	IOFUNC
  9528                                  no_sys_wait:
  9529                                  ;**************************************************************************
  9530 00002141 B484                    	MOV	AH,84h
  9531 00002143 CD2A                    	INT	int_IBM	 ; int 2Ah
  9532                                  
  9533                                  ;;; 7/15/86  update the date in the idle loop
  9534                                  ;;; Dec 19, 1986 D.C.L. changed following CMP to Byte Ptr from Word Ptr
  9535                                  ;;;;		 to shorten loop in consideration of the PC Convertible
  9536                                  
  9537                                  ;hkn; SS override
  9538 00002145 36803E[C30F]FF          	CMP	byte [SS:DATE_FLAG],-1	; date is updated may be every
  9539 0000214B 751B                    	JNZ	short NoUpdate		; 65535 x ? ms if no one calls
  9540 0000214D 50                      	PUSH	AX
  9541 0000214E 53                      	PUSH	BX			; following is tricky,
  9542 0000214F 51                      	PUSH	CX			; it may be called by critical handler
  9543 00002150 52                      	PUSH	DX			; at that time, DEVCALL is used by
  9544                                  					; other's READ or WRITE
  9545 00002151 1E                      	PUSH	DS			; save DS = SFT's sgement
  9546                                  
  9547                                  ;hkn; READTIME must use ds = DOSDATA
  9548                                  ;hkn;	PUSH	CS			; READTIME must use DS=CS
  9549                                  
  9550                                  	;push	ss
  9551 00002152 0E                      	PUSH	CS
  9552 00002153 1F                      	POP	DS
  9553                                  
  9554 00002154 B80000                  	MOV	AX,0			; therefore, we save DEVCALL
  9555 00002157 E88D02                  	CALL	Save_Restore_Packet	; save DEVCALL packet
  9556                                  	;invoke	READTIME		; readtime
  9557 0000215A E81EF8                  	call	READTIME
  9558 0000215D B80100                  	MOV	AX,1
  9559 00002160 E88402                  	CALL	Save_Restore_Packet	; restore DEVCALL packet
  9560                                  	
  9561                                  	; 24/07/2019 - Retro DOS v3.2
  9562                                  
  9563                                  	; MSDOS 3.3 (IBMDOS.COM, Offset 1F8Ch)
  9564                                  	; (MSDOS 6.0 code does not contain IBM DOS FETCHI_TAG check)
  9565                                  	;push	bx
  9566                                  	;mov	bx,DATE_FLAG
  9567                                  	;add	bx,2  ; mov bx,FETCHI_FLAG
  9568                                  	;cmp	word [cs:bx],5872h
  9569                                  	;jz	short FETCHI_TAG_chk_ok
  9570                                  	;call	DOSINIT
  9571                                  ;FETCHI_TAG_chk_ok:
  9572                                  	;pop	bx
  9573                                  	
  9574 00002163 1F                      	POP	DS			; restore DS
  9575 00002164 5A                      	POP	DX
  9576 00002165 59                      	POP	CX
  9577 00002166 5B                      	POP	BX
  9578 00002167 58                      	POP	AX
  9579                                  NoUpdate:
  9580                                  
  9581                                  ;hkn; SS override
  9582 00002168 36FF06[C30F]            	INC	word [SS:DATE_FLAG]
  9583                                  
  9584                                  ;;; 7/15/86 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  9585 0000216D EBC0                    	JMP	short INTEST
  9586                                  GET:
  9587 0000216F 30E4                    	XOR	AH,AH
  9588 00002171 E8112E                  	call	IOFUNC
  9589 00002174 5E                      	POP	SI
  9590 00002175 1F                      	POP	DS
  9591                                  ;;; 7/15/86
  9592                                  
  9593                                  ;hkn; SS override
  9594                                  	; MSDOS 6.0
  9595 00002176 36C606[C10F]00          	MOV	BYTE [SS:SCAN_FLAG],0
  9596                                  	;
  9597 0000217C 3C00                    	CMP	AL,0	    ; extended code ( AL )
  9598 0000217E 7506                    	JNZ	short noscan
  9599                                  
  9600                                  ;hkn; SS override
  9601 00002180 36C606[C10F]01          	MOV	BYTE [SS:SCAN_FLAG],1 ; set this flag for ALT_Q key
  9602                                  
  9603                                  noscan:
  9604 00002186 C3                      	retn
  9605                                  ;
  9606                                  ;----------------------------------------------------------------------------
  9607                                  ;
  9608                                  ;**	$STD_CON_STRING_OUTPUT - Console String Output
  9609                                  ;
  9610                                  ;
  9611                                  ;	ENTRY	(DS:DX) Point to output string '$' terminated
  9612                                  ;	EXIT	none
  9613                                  ;	USES	ALL
  9614                                  ;
  9615                                  ;----------------------------------------------------------------------------
  9616                                  ;
  9617                                  
  9618                                  _$STD_CON_STRING_OUTPUT:	;System call 9
  9619                                  
  9620 00002187 89D6                    	mov	si,dx
  9621                                  STRING_OUT1:	
  9622 00002189 AC                      	lodsb
  9623 0000218A 3C24                    	cmp	al,'$'
  9624 0000218C 74F8                    	jz	short noscan
  9625                                  NEXT_STR1:
  9626 0000218E E88202                  	call	OUTT
  9627 00002191 EBF6                    	jmp	short STRING_OUT1
  9628                                  
  9629                                  ;----------------------------------------------------------------------------
  9630                                  ;
  9631                                  ;**	$STD_CON_STRING_INPUT - Input Line from Console
  9632                                  ;
  9633                                  ;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
  9634                                  ;
  9635                                  ;	ENTRY	(ds:dx) = input buffer
  9636                                  ;	EXIT	none
  9637                                  ;	USES	ALL
  9638                                  ;
  9639                                  ;----------------------------------------------------------------------------
  9640                                  
  9641                                  _$STD_CON_STRING_INPUT:		;System call 10
  9642                                  
  9643 00002193 8CD0                    	mov	ax,ss
  9644 00002195 8EC0                    	mov	es,ax
  9645 00002197 89D6                    	mov	si,dx
  9646 00002199 30ED                    	xor	ch,ch
  9647 0000219B AD                      	lodsw
  9648                                  
  9649                                  ;	(AL) = the buffer length
  9650                                  ;	(AH) = the template length
  9651                                  
  9652 0000219C 08C0                            or	al,al
  9653 0000219E 74E6                            jz	short noscan	;Buffer is 0 length!!?
  9654 000021A0 88E3                    	mov	bl,ah		;Init template counter
  9655 000021A2 88EF                            mov	bh,ch		;Init template counter
  9656                                  
  9657                                  ;	(BL) = the number of bytes in the template
  9658                                  
  9659 000021A4 38D8                            cmp	al,bl
  9660 000021A6 7605                            jbe	short NOEDIT	;If length of buffer inconsistent with contents
  9661 000021A8 80380D                          cmp	byte [bx+si],c_CR ; 0Dh
  9662 000021AB 7402                            jz	short EDITON	;If CR correctly placed EDIT is OK
  9663                                  
  9664                                  ; The number of chars in the template is >= the number of chars in buffer or
  9665                                  ; there is no CR at the end of the template.  This is an inconsistant state
  9666                                  ; of affairs.  Pretend that the template was empty:
  9667                                  ;
  9668                                  
  9669                                  NOEDIT:	
  9670 000021AD 88EB                    	mov	bl,ch		;Reset buffer
  9671                                  EDITON: 
  9672 000021AF 88C2                    	mov	dl,al
  9673 000021B1 4A                      	dec	dx		;DL is # of bytes we can put in the buffer
  9674                                  
  9675                                  ;	Top level.  We begin to read a line in.
  9676                                  
  9677                                  NEWLIN: 
  9678 000021B2 36A0[C501]              	mov	al,[SS:CARPOS]
  9679 000021B6 36A2[C601]              	mov	[SS:STARTPOS],al ;Remember position in raw buffer
  9680                                  
  9681 000021BA 56                      	push	si
  9682 000021BB BF[C701]                	mov	di,INBUF ;Build the new line here
  9683 000021BE 36882E[3605]            	mov	byte [SS:INSMODE],ch ;Insert mode off
  9684 000021C3 88EF                    	mov	bh,ch		;No chars from template yet
  9685 000021C5 88EE                    	mov	dh,ch		;No chars to new line yet
  9686 000021C7 E863FF                  	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
  9687 000021CA 3C0A                    	cmp	al,c_LF		; 0Ah	;Linefeed 
  9688 000021CC 7503                    	jnz	short GOTCH
  9689                                  
  9690                                  ;	This is the main loop of reading in a character and processing it.
  9691                                  ;
  9692                                  ;	(BH) = the index of the next byte in the template
  9693                                  ;	(BL) = the length of the template
  9694                                  ;	(DH) = the number of bytes in the buffer
  9695                                  ;	(DL) = the length of the buffer
  9696                                  
  9697                                  GETCH:
  9698 000021CE E85CFF                  	call	_$STD_CON_INPUT_NO_ECHO
  9699                                  GOTCH:
  9700                                  ;
  9701                                  ; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
  9702                                  ; input queue.
  9703                                  ;
  9704 000021D1 3C06                            cmp	al,"F"-"@"  ; CMP AL, 6  ; Ignore ^F
  9705 000021D3 74F9                    	jz	short GETCH
  9706                                  
  9707                                  ;	If the leading char is the function-key lead byte
  9708                                  
  9709 000021D5 363A06[1013]                    cmp	al,[SS:ESCCHAR]
  9710 000021DA 7438                            jz	short ESCAPE	;change reserved keyword DBM 5-7-87
  9711                                  
  9712                                  ;	Rubout and ^H are both destructive backspaces.
  9713                                  
  9714 000021DC 3C7F                            cmp	al,c_DEL ; 7FH
  9715 000021DE 742B                            jz	short BACKSPJ
  9716 000021E0 3C08                            cmp	al,c_BS  ; 8
  9717 000021E2 7427                            jz	short BACKSPJ
  9718                                  
  9719                                  	; MSDOS 6.0
  9720                                  ;;	^W deletes backward once and then backs up until a letter is before the
  9721                                  ;;	cursor
  9722                                  ;
  9723                                  ;	CMP     AL,"W"-"@" ; 17h
  9724                                  ;
  9725                                  ;;	The removal of the comment characters before the jump statement will
  9726                                  ;;	cause ^W to backup a word.
  9727                                  ;
  9728                                  ;;***	JZ	short WordDel
  9729                                  ;	NOP
  9730                                  ;	NOP
  9731                                  ;	CMP     AL,"U"-"@" ; 15h
  9732                                  ;
  9733                                  ;;	The removal of the comment characters before the jump statement will
  9734                                  ;;	cause ^U to clear a line.
  9735                                  ;
  9736                                  ;;***	JZ	short LineDel
  9737                                  ;	NOP
  9738                                  ;	NOP
  9739                                  
  9740                                  ;	CR terminates the line.
  9741                                  
  9742 000021E4 3C0D                            cmp	al,c_CR ; 0Dh
  9743 000021E6 742F                            jz	short ENDLIN
  9744                                  
  9745                                  ;	LF goes to a new line and keeps on reading.
  9746                                  
  9747 000021E8 3C0A                            cmp	al,c_LF ; 0Ah
  9748 000021EA 7441                    	jz	short PHYCRLF
  9749                                  
  9750                                  ;	^X (or ESC) deletes the line and starts over
  9751                                  
  9752                                  	; MSDOS 3.3
  9753                                  	;cmp	al,[ss:CANCHAR] ; 1Bh
  9754                                  	;jz	short KILNEW
  9755                                  	; MSDOS 6.0
  9756 000021EC 3C1B                    	cmp	al,CANCEL ; 1Bh
  9757 000021EE 7442                    	jz	short KILNEW
  9758                                  
  9759                                  ; Otherwise, we save the input character.
  9760                                  
  9761                                  SAVCH:	
  9762 000021F0 38D6                    	cmp	dh,dl
  9763 000021F2 7319                    	jnb	short BUFFUL		; buffer is full.
  9764 000021F4 AA                              stosb
  9765 000021F5 FEC6                    	inc	dh                      ; increment count in buffer.
  9766 000021F7 E8B302                  	call	BUFOUT			;Print control chars nicely
  9767                                  
  9768 000021FA 36803E[3605]00                  cmp	byte [SS:INSMODE], 0
  9769 00002200 75CC                    	jnz	short GETCH		; insertmode => don't advance template
  9770 00002202 38DF                            cmp	bh,bl
  9771 00002204 73C8                            jnb	short GETCH		; no more characters in template
  9772 00002206 46                              inc	si                      ; Skip to next char in template
  9773 00002207 FEC7                            inc	bh                      ; remember position in template
  9774 00002209 EBC3                            jmp	short GETCH
  9775                                  
  9776                                  BACKSPJ: 
  9777 0000220B EB38                    	jmp	short BACKSP
  9778                                  
  9779                                  BUFFUL: 
  9780 0000220D B007                    	mov	al, 7			; Bell to signal full buffer
  9781 0000220F E80102                  	call	OUTT
  9782 00002212 EBBA                    	jmp	short GETCH
  9783                                  
  9784                                  ESCAPE: 
  9785                                  	;transfer OEMFunctionKey
  9786 00002214 E994F6                  	JMP	OEMFunctionKey
  9787                                  
  9788                                  ENDLIN:
  9789 00002217 AA                              stosb				; Put the CR in the buffer
  9790 00002218 E8F801                  	call	OUTT                    ; Echo it
  9791 0000221B 5F                              pop	di                      ; Get start of user buffer
  9792 0000221C 8875FF                          mov	[di-1], dh		; Tell user how many bytes
  9793 0000221F FEC6                            inc	dh			; DH is length including CR
  9794                                  
  9795                                  COPYNEW:
  9796                                  	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
  9797                                  	;mov	bp, es
  9798                                  	;mov	bx, ds
  9799                                  	;mov	es, bx
  9800                                  	;mov	ds, bp
  9801                                  	;mov	si, INBUF
  9802                                  	;mov	cl, dh
  9803                                  	;rep	movsb
  9804                                  	;retn
  9805                                  
  9806                                  	; CPMIO.ASM (MSDOS 6.0)
  9807                                  	; (IBMDOS.COM, MSDOS 3.3, Offset 2061h) 
  9808                                  	;SAVE	<DS,ES>
  9809 00002221 1E                      	PUSH	DS
  9810 00002222 06                      	PUSH	ES
  9811                                  	;RESTORE <DS,ES>		; XCHG ES,DS
  9812 00002223 1F                      	POP	DS
  9813 00002224 07                      	POP	ES
  9814                                  
  9815                                  ;;hkn; INBUF is in DOSDATA
  9816 00002225 BE[C701]                        MOV     SI,INBUF
  9817 00002228 88F1                            MOV     CL,DH                   ; set up count
  9818 0000222A F3A4                            REP     MOVSB                   ; Copy final line to user buffer
  9819                                  OLDBAK_RETN:
  9820 0000222C C3                              RETN
  9821                                  
  9822                                  ;	Output a CRLF to the user screen and do NOT store it into the buffer
  9823                                  
  9824                                  PHYCRLF:
  9825 0000222D E82001                  	CALL	CRLF
  9826 00002230 EB9C                            JMP	short GETCH
  9827                                  
  9828                                  	; MSDOS 6.0 (& MSDOS 3.3, IBMDOS.COM, 1987)
  9829                                  
  9830                                  	; Note: Following routines were not used in IBMDOS.COM
  9831                                  	;	-CRTL+W, CRTL+U is not activated-
  9832                                  	;	but they were in the kernel code!?)
  9833                                  ;
  9834                                  ; Delete the previous line
  9835                                  ;
  9836                                  ;LineDel:
  9837                                  ;	OR      DH,DH
  9838                                  ;	JZ	short GetCh
  9839                                  ;	Call    BackSpace
  9840                                  ;	JMP	short LineDel
  9841                                  
  9842                                  ;
  9843                                  ; delete the previous word.
  9844                                  ;
  9845                                  ;WordDel:
  9846                                  ;WordLoop:
  9847                                  ;	Call    BackSpace               ; backspace the one spot
  9848                                  ;	OR      DH,DH
  9849                                  ;	JZ	short GetChJ
  9850                                  ;	MOV     AL,[ES:DI-1]
  9851                                  ;	cmp     al,'0'
  9852                                  ;	jb	short GetChj
  9853                                  ;	cmp     al,'9'
  9854                                  ;	jbe	short WordLoop
  9855                                  ;	OR      AL,20h
  9856                                  ;	CMP     AL,'a'
  9857                                  ;	JB	short GetChJ
  9858                                  ;	CMP     AL,'z'
  9859                                  ;	JBE	short WordLoop
  9860                                  ;getchj: 
  9861                                  ;	JMP	GetCh
  9862                                  
  9863                                  ; The user wants to throw away what he's typed in and wants to start over.
  9864                                  ; We print the backslash and then go to the next line and tab to the correct
  9865                                  ; spot to begin the buffered input.
  9866                                  
  9867                                  KILNEW:
  9868 00002232 B05C                            mov	al,'\'
  9869 00002234 E8DC01                          call	OUTT            ;Print the CANCEL indicator
  9870 00002237 5E                              pop	si		;Remember start of edit buffer
  9871                                  PUTNEW:
  9872 00002238 E81501                  	call	CRLF            ;Go to next line on screen
  9873 0000223B 36A0[C601]              	mov	al,[SS:STARTPOS]
  9874 0000223F E84702                  	call	TAB             ;Tab over
  9875 00002242 E96DFF                          JMP     NEWLIN		;Start over again
  9876                                  
  9877                                  ;	Destructively back up one character position
  9878                                  
  9879                                  BACKSP:
  9880                                  	; 09/09/2018
  9881 00002245 E80200                  	Call    BackSpace
  9882 00002248 EB84                    	JMP     GETCH
  9883                                  
  9884                                  BackSpace:
  9885 0000224A 08F6                    	or	dh,dh
  9886 0000224C 7419                    	jz	short OLDBAK	;No chars in line, do nothing to line
  9887 0000224E E85800                  	call	BACKUP          ;Do the backup
  9888 00002251 268A05                  	mov	al,[es:di]	;Get the deleted char
  9889 00002254 3C20                            cmp	al,20h	; ' '
  9890 00002256 730F                    	jnb	short OLDBAK	;Was a normal char
  9891 00002258 3C09                            cmp	al,c_HT ; 9
  9892 0000225A 741B                    	jz	short BAKTAB	;Was a tab, fix up users display
  9893                                  ;; 9/27/86 fix for ctrl-U backspace
  9894 0000225C 3C15                    	CMP     AL,"U"-"@" ; 15h ; ctrl-U is a section symbol not ^U
  9895 0000225E 7407                    	JZ	short OLDBAK
  9896 00002260 3C14                           	CMP     AL,"T"-"@" ; 14h ; ctrl-T is a paragraphs symbol not ^T
  9897 00002262 7403                    	JZ	short OLDBAK
  9898                                  ;; 9/27/86 fix for ctrl-U backspace
  9899 00002264 E84500                          call	BACKMES         ;Was a control char, zap the '^'
  9900                                  OLDBAK:
  9901 00002267 36803E[3605]00                  cmp	byte [SS:INSMODE], 0
  9902 0000226D 75BD                    	jnz	short OLDBAK_RETN ;In insert mode, done
  9903 0000226F 08FF                    	or	bh,bh
  9904 00002271 74B9                            jz	short OLDBAK_RETN 
  9905                                  				;Not advanced in template, stay where we are
  9906 00002273 FECF                    	dec	bh		;Go back in template
  9907 00002275 4E                              dec	si
  9908 00002276 C3                      	retn
  9909                                  
  9910                                  BAKTAB:
  9911 00002277 57                              push	di
  9912 00002278 4F                              dec	di		;Back up one char
  9913 00002279 FD                              std			;Go backward
  9914 0000227A 88F1                            mov	cl,dh		;Number of chars currently in line
  9915 0000227C B020                            mov	al,20h	; ' '
  9916 0000227E 53                              push	bx
  9917 0000227F B307                            mov	bl,7		;Max
  9918 00002281 E30E                            jcxz	FIGTAB		;At start, do nothing
  9919                                  FNDPOS:
  9920 00002283 AE                              scasb			;Look back
  9921 00002284 7609                    	jbe	short CHKCNT
  9922 00002286 26807D0109              	cmp	byte [es:di+1],9
  9923 0000228B 7409                    	jz	short HAVTAB	;Found a tab
  9924 0000228D FECB                    	dec	bl		;Back one char if non tab control char
  9925                                  CHKCNT:
  9926 0000228F E2F2                            loop	FNDPOS
  9927                                  FIGTAB:		
  9928 00002291 362A1E[C601]            	sub	bl,[SS:STARTPOS]
  9929                                  HAVTAB:
  9930 00002296 28F3                    	sub	bl,dh
  9931 00002298 00D9                    	add	cl,bl
  9932 0000229A 80E107                  	and	cl,7		;CX has correct number to erase
  9933 0000229D FC                      	cld			;Back to normal
  9934 0000229E 5B                      	pop	bx
  9935 0000229F 5F                      	pop	di
  9936 000022A0 74C5                    	jz	short OLDBAK	;Nothing to erase
  9937                                  TABBAK:
  9938 000022A2 E80700                  	call	BACKMES
  9939 000022A5 E2FB                    	loop	TABBAK		;Erase correct number of chars
  9940 000022A7 EBBE                    	jmp	short OLDBAK
  9941                                  
  9942                                  BACKUP:
  9943 000022A9 FECE                            dec	dh             ;Back up in line
  9944 000022AB 4F                              dec	di
  9945                                  BACKMES:
  9946 000022AC B008                            mov	al,c_BS ; 8	;Backspace
  9947 000022AE E86201                          call	OUTT
  9948 000022B1 B020                            mov	al,20h ; ' '	;Erase
  9949 000022B3 E85D01                          call	OUTT
  9950 000022B6 B008                            mov	al,c_BS ; 8	;Backspace
  9951 000022B8 E95801                  	jmp	OUTT		;Done
  9952                                  
  9953                                  ;User really wants an ESC character in his line
  9954                                  TWOESC:	
  9955 000022BB 36A0[1013]              	mov	al,[SS:ESCCHAR]
  9956 000022BF E92EFF                  	jmp	SAVCH
  9957                                  
  9958                                  ;Copy the rest of the template
  9959                                  COPYLIN:
  9960 000022C2 88D9                            mov	cl,bl		;Total size of template
  9961 000022C4 28F9                    	sub	cl,bh		;Minus position in template, is number to move
  9962 000022C6 EB07                            jmp	short COPYEACH
  9963                                  
  9964                                  COPYSTR:
  9965 000022C8 E83400                  	call	FINDOLD         ;Find the char
  9966 000022CB EB02                    	jmp	short COPYEACH  ;Copy up to it
  9967                                  
  9968                                  ;Copy one char from template to line
  9969                                  COPYONE:
  9970 000022CD B101                            mov	cl,1
  9971                                  ;Copy CX chars from template to line
  9972                                  COPYEACH:
  9973 000022CF 36C606[3605]00                  mov	byte [SS:INSMODE],0	;All copies turn off insert mode
  9974 000022D5 38D6                    	cmp	dh,dl
  9975 000022D7 740F                            jz	short GETCH2		;At end of line, can't do anything
  9976 000022D9 38DF                            cmp	bh,bl
  9977 000022DB 740B                            jz	short GETCH2		;At end of template, can't do anything
  9978 000022DD AC                              lodsb
  9979 000022DE AA                              stosb
  9980 000022DF E8CB01                  	call	BUFOUT
  9981 000022E2 FEC7                            inc	bh			;Ahead in template
  9982 000022E4 FEC6                            inc	dh			;Ahead in line
  9983 000022E6 E2E7                            loop	COPYEACH
  9984                                  GETCH2:
  9985 000022E8 E9E3FE                          jmp	GETCH
  9986                                  
  9987                                  ;Skip one char in template
  9988                                  SKIPONE:
  9989 000022EB 38DF                    	cmp	bh,bl
  9990 000022ED 74F9                    	jz	short GETCH2		;At end of template
  9991 000022EF FEC7                    	inc	bh			;Ahead in templat
  9992 000022F1 46                      	inc	si
  9993 000022F2 E9D9FE                  	jmp	GETCH
  9994                                  
  9995                                  SKIPSTR:
  9996 000022F5 E80700                  	call	FINDOLD                 ;Find out how far to go
  9997 000022F8 01CE                            add	si,cx			;Go there
  9998 000022FA 00CF                            add	bh,cl
  9999 000022FC E9CFFE                          jmp	GETCH
 10000                                  
 10001                                  ;Get the next user char, and look ahead in template for a match
 10002                                  ;CX indicates how many chars to skip to get there on output
 10003                                  ;NOTE: WARNING: If the operation cannot be done, the return
 10004                                  ;       address is popped off and a jump to GETCH is taken.
 10005                                  ;       Make sure nothing extra on stack when this routine
 10006                                  ;       is called!!! (no PUSHes before calling it).
 10007                                  FINDOLD:
 10008 000022FF E82BFE                          call	_$STD_CON_INPUT_NO_ECHO
 10009                                  	; STRIN.ASM (MSDOS 2.11, 19/07/2018) 
 10010 00002302 363A06[1013]            	CMP     AL,[SS:ESCCHAR]	; did he type a function key?
 10011                                  ;hkn; ESCCHAR is in TABLE seg (DOSCODE), so CS override
 10012                                  	;CMP	AL,[CS:ESCCHAR]
 10013 00002307 7505                    	JNZ     SHORT FINDSETUP		; no, set up for scan
 10014 00002309 E821FE                          CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
 10015 0000230C EB1D                            JMP     SHORT NOTFND		; go try again
 10016                                  FINDSETUP:
 10017 0000230E 88D9                    	mov	cl,bl
 10018 00002310 28F9                            sub	cl,bh		;CX is number of chars to end of template
 10019 00002312 7417                    	jz	short NOTFND	;At end of template
 10020 00002314 49                              dec	cx		;Cannot point past end, limit search
 10021 00002315 7414                            jz	short NOTFND	 ;If only one char in template, forget it
 10022 00002317 06                      	push	es
 10023 00002318 1E                      	push	ds
 10024 00002319 07                      	pop	es
 10025 0000231A 57                      	push	di
 10026 0000231B 89F7                    	mov	di,si		;Template to ES:DI
 10027 0000231D 47                      	inc	di
 10028 0000231E F2AE                    	repne	scasb		;Look
 10029 00002320 5F                      	pop	di
 10030 00002321 07                      	pop	es
 10031 00002322 7507                    	jnz	short NOTFND	;Didn't find the char
 10032 00002324 F6D1                            not	cl		;Turn how far to go into how far we went
 10033 00002326 00D9                            add	cl,bl		;Add size of template
 10034 00002328 28F9                            sub	cl,bh		;Subtract current pos, result distance to skip
 10035                                  FINDOLD_RETN:
 10036 0000232A C3                      	retn
 10037                                  
 10038                                  NOTFND:
 10039 0000232B 5D                              pop	bp              ;Chuck return address
 10040 0000232C E99FFE                          jmp	GETCH
 10041                                  
 10042                                  REEDIT:
 10043 0000232F B040                    	mov	al,'@'		;Output re-edit character
 10044 00002331 E8DF00                  	call	OUTT
 10045 00002334 5F                      	pop	di
 10046 00002335 57                      	push	di
 10047 00002336 06                      	push	es
 10048 00002337 1E                      	push	ds
 10049 00002338 E8E6FE                  	call	COPYNEW		;Copy current line into template
 10050 0000233B 1F                      	pop	ds
 10051 0000233C 07                      	pop	es
 10052 0000233D 5E                      	pop	si
 10053 0000233E 88F3                    	mov	bl,dh		;Size of line is new size template
 10054 00002340 E9F5FE                  	jmp	PUTNEW		;Start over again
 10055                                  
 10056                                  EXITINS:
 10057                                  ENTERINS:
 10058 00002343 36F616[3605]            	not	byte [SS:INSMODE]
 10059 00002348 E983FE                  	jmp	GETCH
 10060                                  
 10061                                  ;Put a real live ^Z in the buffer (embedded)
 10062                                  CTRLZ:
 10063 0000234B B01A                    	mov	al,"Z"-"@" ; 1Ah
 10064 0000234D E9A0FE                          jmp	SAVCH
 10065                                  
 10066                                  ;Output a CRLF
 10067                                  CRLF:
 10068 00002350 B00D                    	mov	al,c_CR ; 0Dh 
 10069 00002352 E8BE00                  	call	OUTT
 10070 00002355 B00A                    	mov	al,c_LF ; 0Ah
 10071 00002357 E9B900                  	jmp	OUTT
 10072                                  
 10073                                  ;
 10074                                  ;----------------------------------------------------------------------------
 10075                                  ;
 10076                                  ;**	$RAW_CON_IO - Do Raw Console I/O
 10077                                  ;
 10078                                  ;	Input or output raw character from console, no echo
 10079                                  ;
 10080                                  ;	ENTRY	DL = -1 if input
 10081                                  ;		   =  output character if output
 10082                                  ;	EXIT	(AL) = input character if input
 10083                                  ;	USES	all
 10084                                  ;
 10085                                  ;----------------------------------------------------------------------------
 10086                                  ; 20/07/2018 - Retro DOS v3.0
 10087                                  
 10088                                  _$RAW_CON_IO:			; System call 6
 10089                                  
 10090 0000235A 88D0                            MOV     AL,DL
 10091 0000235C 3CFF                            CMP     AL,-1
 10092 0000235E 7542                            JNZ     SHORT RAWOUT
 10093                                          ;LES 	DI,[USER_SP]	; Get pointer to register save area
 10094 00002360 36C43E[4005]                    LES     DI,[SS:USER_SP] ; 12/03/2018
 10095 00002365 31DB                    	XOR     BX,BX
 10096                                      	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10097 00002367 E82C1E                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10098                                          ;JC	SHORT RET17
 10099 0000236A 72BE                            jc	short FINDOLD_RETN
 10100 0000236C B401                    	MOV     AH,1
 10101 0000236E E8142C                          CALL	IOFUNC
 10102 00002371 750B                            JNZ     SHORT RESFLG
 10103 00002373 E83D36                          CALL	SPOOLINT
 10104                                          ;OR	BYTE [ES:DI+16H],40H
 10105 00002376 26804D1640              	OR	BYTE [ES:DI+user_env.user_F],40H ; Set user's zero flag
 10106 0000237B 30C0                            XOR     AL,AL
 10107                                  RET17:
 10108 0000237D C3                              RETN
 10109                                  
 10110                                  RESFLG:
 10111                                  	;AND	BYTE [ES:DI+16H],0FFH-40H  ; 0BFh
 10112 0000237E 26806516BF              	AND	BYTE [ES:DI+user_env.user_F],0FFH-40H
 10113                                  				; Reset user's zero flag
 10114                                  ;RILP:
 10115                                  rci0:
 10116 00002383 E82D36                       	CALL	SPOOLINT
 10117                                  
 10118                                  ;
 10119                                  ;----------------------------------------------------------------------------
 10120                                  ;
 10121                                  ;**	$Raw_CON_INPUT - Raw Console Input
 10122                                  ;
 10123                                  ;	Input raw character from console, no echo
 10124                                  ;
 10125                                  ;	ENTRY	none
 10126                                  ;	EXIT	(al) = character
 10127                                  ;	USES	all
 10128                                  ;
 10129                                  ;----------------------------------------------------------------------------
 10130                                  ;
 10131                                  
 10132                                  ;rci0:	invoke	SPOOLINT
 10133                                  
 10134                                  	;entry	$RAW_CON_INPUT
 10135                                  
 10136                                  _$RAW_CON_INPUT:		; System call 7
 10137 00002386 53                      	push	bx
 10138 00002387 31DB                            XOR     BX,BX
 10139                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10140 00002389 E80A1E                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10141 0000238C 5B                              pop	bx
 10142 0000238D 72EE                    	JC	SHORT RET17
 10143 0000238F B401                            MOV     AH,1
 10144 00002391 E8F12B                          CALL	IOFUNC
 10145                                  	;JZ	SHORT RILP	; MSDOS 2.11
 10146                                  	;XOR     AH,AH
 10147                                          ;CALL	IOFUNC
 10148                                          ;RETN
 10149 00002394 7506                    	jnz	short rci5	; MSDOS 3.3 & MSDOS 6.0
 10150 00002396 B484                    	MOV	AH,84h
 10151 00002398 CD2A                    	INT	int_IBM  ; int 2Ah
 10152 0000239A EBE7                    	JMP	short rci0
 10153                                  rci5:	
 10154 0000239C 30E4                            XOR     AH,AH
 10155 0000239E E8E42B                          CALL	IOFUNC
 10156 000023A1 C3                              RETN
 10157                                  
 10158                                  ;
 10159                                  ;       Output the character in AL to stdout
 10160                                  ;
 10161                                  	;entry   RAWOUT
 10162                                  
 10163                                  RAWOUT:
 10164 000023A2 53                              PUSH    BX
 10165 000023A3 BB0100                          MOV     BX,1
 10166                                  
 10167                                          ;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10168 000023A6 E8ED1D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10169 000023A9 721B                            JC      SHORT RAWRET1
 10170                                  	;
 10171                                  	; MSDOS 2.11
 10172                                          ;TEST	BYTE [SI+18H],080H	; output to file?
 10173                                          ;JZ	SHORT RAWNORM		; if so, do normally
 10174                                          ;PUSH	DS
 10175                                          ;PUSH	SI
 10176                                          ;LDS	SI,[SI+19H]		; output to special?
 10177                                  	;TEST	BYTE [SI+4],ISSPEC
 10178                                  	;POP	SI
 10179                                  	;
 10180                                          
 10181                                  	; MSDOS 3.3 & MSDOS 6.0
 10182                                  	;mov	bx,[si+5]
 10183 000023AB 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags] ;hkn; DS set up by get_io_sft
 10184                                   ;
 10185                                   ; If we are a network handle OR if we are not a local device then go do the
 10186                                   ; output the hard way.
 10187                                   ;	
 10188                                  	;and	bx,8080h
 10189 000023AE 81E38080                	AND	BX,sf_isnet+devid_device
 10190                                  	;cmp	bx,80h
 10191 000023B2 81FB8000                	CMP	BX,devid_device
 10192 000023B6 7510                    	jnz     short RAWNORM
 10193 000023B8 1E                      	push    ds
 10194                                  	;lds	bx,[si+7]
 10195 000023B9 C55C07                  	LDS	BX,[SI+SF_ENTRY.sf_devptr] ; output to special?
 10196                                  	;test	byte [bx+4],10h
 10197 000023BC F6470410                	TEST	BYTE [BX+SYSDEV.ATT],ISSPEC
 10198                                  	;
 10199                                  
 10200 000023C0 1F                              POP     DS
 10201 000023C1 7405                            JZ      SHORT RAWNORM		; if not, do normally
 10202 000023C3 CD29                            INT     int_fastcon   ; int 29h	; quickly output the char
 10203                                  
 10204                                          ;JMP     SHORT RAWRET
 10205                                  ;RAWNORM:
 10206                                  ;	CALL    RAWOUT3
 10207                                  
 10208                                  RAWRET: 
 10209 000023C5 F8                      	CLC
 10210                                  RAWRET1:
 10211 000023C6 5B                              POP     BX
 10212                                  RAWRET2:
 10213 000023C7 C3                      	RETN
 10214                                  
 10215                                  RAWNORM:
 10216 000023C8 E80700                  	CALL    RAWOUT3
 10217 000023CB EBF8                    	jmp	short RAWRET
 10218                                  
 10219                                  ;
 10220                                  ;       Output the character in AL to handle in BX
 10221                                  ;
 10222                                  ;	entry   RAWOUT2
 10223                                  
 10224                                  RAWOUT2:
 10225                                  	;CALL	GET_IO_FCB	; MSDOS 2.11 (Retro DOS v2.0)
 10226                                  	;JC	SHORT RET18
 10227 000023CD E8C61D                  	CALL	GET_IO_SFT	; MSDOS 3.3 & MSDOS 6.0
 10228 000023D0 72F5                    	JC	SHORT RAWRET2
 10229                                  RAWOUT3:
 10230 000023D2 50                              PUSH    AX
 10231 000023D3 EB03                            JMP     SHORT RAWOSTRT
 10232                                  ROLP:
 10233 000023D5 E8DB35                          CALL	SPOOLINT
 10234                                  
 10235                                  	; MSDOS 6.0
 10236                                  	;OR	word [DOS34_FLAG],CTRL_BREAK_FLAG ; 001000000000b
 10237                                  				;AN002; set control break
 10238                                  	;;invoke DSKSTATCHK
 10239                                  	;call	DSKSTATCHK	;AN002; check control break
 10240                                  
 10241                                  RAWOSTRT:
 10242 000023D8 B403                            MOV     AH,3
 10243 000023DA E8A82B                          CALL    IOFUNC
 10244 000023DD 74F6                            JZ      SHORT ROLP
 10245                                  
 10246                                  	; MSDOS 6.0
 10247                                  ;SR;
 10248                                  ; IOFUNC now returns ax = 0ffffh if there was an I24 on a status call and
 10249                                  ;the user failed. We do not send a char if this happens. We however return 
 10250                                  ;to the caller with carry clear because this DOS call does not return any
 10251                                  ;status. 
 10252                                  ;
 10253                                  	;inc	ax		;fail on I24 if ax = -1
 10254                                  	;POP	AX
 10255                                  	;jz	short nosend	;yes, do not send char
 10256                                  	;MOV	AH,2
 10257                                  	;call	IOFUNC
 10258                                  ;nosend:
 10259                                  	;CLC			; Clear carry indicating successful
 10260                                  	;retn
 10261                                  
 10262                                  	; MSDOS 3.3 & MSDOS 2.11
 10263 000023DF 58                              POP     AX
 10264 000023E0 B402                            MOV     AH,2
 10265 000023E2 E8A02B                          CALL    IOFUNC
 10266 000023E5 F8                              CLC                     ; Clear carry indicating successful
 10267                                  RET18:    
 10268 000023E6 C3                      	RETN
 10269                                  
 10270                                  ;;10/08/2018
 10271                                  ; 20/07/2018 - Retro DOS v3.0
 10272                                  ; ---------------------------------------------------------------------------
 10273                                  ; Retro DOS v2.0 (MSDOS 2.11) - OUTMES
 10274                                  ; ---------------------------------------------------------------------------
 10275                                  
 10276                                  ; This routine is called at DOS init
 10277                                  
 10278                                  ;;	;procedure OUTMES,NEAR ; String output for internal messages
 10279                                  ;;OUTMES:
 10280                                  ;;	;LODS	CS:BYTE PTR [SI]
 10281                                  ;;	CS	LODSB
 10282                                  ;;	CMP     AL,"$" ; 24h
 10283                                  ;;	JZ	SHORT RET18
 10284                                  ;;	CALL	OUTT
 10285                                  ;;	JMP     SHORT OUTMES
 10286                                  
 10287                                  ; ---------------------------------------------------------------------------
 10288                                  
 10289                                  ; 20/07/2018 - Retro DOS v3.0
 10290                                  
 10291                                  ; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 2252h
 10292                                  
 10293                                  ;
 10294                                  ;----------------------------------------------------------------------------
 10295                                  ;
 10296                                  ; Inputs:
 10297                                  ;	AX=0 save the DEVCALL request packet
 10298                                  ;	  =1 restore the DEVCALL request packet
 10299                                  ; Function:
 10300                                  ;	save or restore the DEVCALL packet
 10301                                  ; Returns:
 10302                                  ;	none
 10303                                  ;
 10304                                  ;----------------------------------------------------------------------------
 10305                                  ;
 10306                                  
 10307                                  Save_Restore_Packet:
 10308 000023E7 1E                      	PUSH	DS
 10309 000023E8 06                      	PUSH	ES
 10310 000023E9 56                      	PUSH	SI
 10311 000023EA 57                      	PUSH	DI
 10312                                  
 10313                                  	; 09/09/2018
 10314 000023EB BF[A90F]                	mov	di,FAKE_STACK_2F 
 10315 000023EE BE[2403]                	mov	si,DEVCALL
 10316                                  	;
 10317 000023F1 83F800                  	CMP	AX,0		; save packet
 10318                                  	;JZ	short save_packet
 10319 000023F4 7402                    	je	short set_seg 
 10320                                  
 10321                                  	; MSDOS 6.0
 10322                                  restore_packet:
 10323                                  ;	MOV	SI,OFFSET DOSDATA:Packet_Temp	 ;sourec
 10324                                  ;	MOV	DI,OFFSET DOSDATA:DEVCALL	 ;destination
 10325                                  	; MSDOS 3.3
 10326                                  	;mov	si,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10327                                  	;mov	di,DEVCALL  ; 09/09/2018
 10328                                  	;
 10329                                  	;JMP	short set_seg
 10330                                  	
 10331                                  	; 09/09/2018
 10332 000023F6 87F7                    	xchg	si,di  ; DI = offset DEVCALL, SI = offset FAKE_STACK_2F
 10333                                  
 10334                                  	; MSDOS 6.0
 10335                                  save_packet:
 10336                                  ;	MOV	DI,OFFSET DOSDATA:Packet_Temp	 ;destination
 10337                                  ;	MOV	SI,OFFSET DOSDATA:DEVCALL	 ;source
 10338                                  	; 09/09/2018
 10339                                  	; MSDOS 3.3
 10340                                  	;mov	di,FAKE_STACK_2F ; DOS_TEMP ; Packed_Temp 
 10341                                  	;mov	si,DEVCALL ; 09/09/2018
 10342                                  
 10343                                  set_seg:
 10344                                  	; MSDOS 6.0
 10345                                  	;MOV	AX,SS		; set DS,ES to DOSDATA
 10346                                  	; MSDOS 3.3
 10347 000023F8 8CC8                    	mov	ax,cs
 10348                                  	;
 10349 000023FA 8ED8                    	MOV	DS,AX
 10350 000023FC 8EC0                    	MOV	ES,AX
 10351 000023FE B90B00                  	MOV	CX,11		; 11 words to move
 10352 00002401 F3A5                    	REP	MOVSW
 10353                                  
 10354 00002403 5F                      	POP	DI
 10355 00002404 5E                      	POP	SI
 10356 00002405 07                      	POP	ES
 10357 00002406 1F                      	POP	DS
 10358 00002407 C3                      	retn
 10359                                  
 10360                                  ;============================================================================
 10361                                  ; CPMIO2.ASM, MSDOS 6.0, 1991
 10362                                  ;============================================================================
 10363                                  ; 20/07/2018 - Retro DOS v3.0
 10364                                  
 10365                                  ;hkn; 	All the variables use SS override or DS. Therefore there is
 10366                                  ;hkn;	no need to specifically set up any seg regs unless SS assumption is
 10367                                  ;hkn;	not valid. 
 10368                                  
 10369                                  ;
 10370                                  ;----------------------------------------------------------------------------
 10371                                  ;
 10372                                  ;**	$STD_CON_INPUT - System Call 1
 10373                                  ;
 10374                                  ;	Input character from console, echo
 10375                                  ;
 10376                                  ;	ENTRY	none
 10377                                  ;	EXIT	(al) = character
 10378                                  ;	USES	ALL
 10379                                  ;
 10380                                  ;----------------------------------------------------------------------------
 10381                                  ;
 10382                                  
 10383                                  _$STD_CON_INPUT:	;System call 1
 10384                                  	
 10385 00002408 E822FD                  	CALL	_$STD_CON_INPUT_NO_ECHO
 10386 0000240B 50                      	PUSH	AX
 10387 0000240C E80400                  	CALL	OUTT
 10388 0000240F 58                      	POP	AX
 10389                                  CON_INPUT_RETN:	
 10390 00002410 C3                      	RETN
 10391                                  
 10392                                  ;
 10393                                  ;----------------------------------------------------------------------------
 10394                                  ;
 10395                                  ;**	$STD_CON_OUTPUT - System Call 2
 10396                                  ;
 10397                                  ;	Output character to console
 10398                                  ;
 10399                                  ;	ENTRY	(dl) = character
 10400                                  ;	EXIT	none
 10401                                  ;	USES	all
 10402                                  ;
 10403                                  ;----------------------------------------------------------------------------
 10404                                  ;
 10405                                  
 10406                                  _$STD_CON_OUTPUT:	;System call 2
 10407                                  
 10408 00002411 88D0                    	MOV	AL,DL
 10409                                  
 10410                                  OUTT:
 10411 00002413 3C20                    	CMP	AL,20H ; " "
 10412 00002415 725E                    	JB	SHORT CTRLOUT
 10413 00002417 3C7F                    	CMP	AL,c_DEL ; 7Fh
 10414 00002419 7405                    	JZ	SHORT OUTCH
 10415                                  OUTCHA:	
 10416                                  	;INC	BYTE PTR [CARPOS]
 10417 0000241B 36FE06[C501]            	INC	BYTE [SS:CARPOS]
 10418                                  OUTCH:
 10419 00002420 1E                      	PUSH	DS
 10420 00002421 56                      	PUSH	SI
 10421                                  	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
 10422                                  	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
 10423 00002422 36FE06[CC02]            	INC	BYTE [SS:CHARCO]	
 10424                                  	;AND	BYTE [SS:CHARCO],00111111B
 10425                                  	; 14/03/2018
 10426 00002427 368026[CC02]03          	and	byte [SS:CHARCO],3  ; IBMDOS.COM, MSDOS 3.3, MSDOS 2.11
 10427 0000242D 7505                    	JNZ	SHORT OUTSKIP
 10428 0000242F 50                      	PUSH	AX
 10429 00002430 E89F35                  	CALL	STATCHK
 10430 00002433 58                      	POP	AX
 10431                                  OUTSKIP:
 10432 00002434 E86BFF                  	CALL	RAWOUT				;output the character
 10433 00002437 5E                      	POP	SI
 10434 00002438 1F                      	POP	DS
 10435                                  
 10436                                  	;TEST	BYTE PTR [PFLAG],-1
 10437                                  	;retz
 10438 00002439 36F606[CA02]FF          	TEST	BYTE [SS:PFLAG],0FFh
 10439 0000243F 74CF                    	JZ	SHORT CON_INPUT_RETN
 10440                                  
 10441 00002441 53                      	PUSH	BX
 10442 00002442 1E                      	PUSH	DS
 10443 00002443 56                      	PUSH	SI
 10444 00002444 BB0100                  	MOV	BX,1
 10445                                  	; 20/07/2018 - Retro DOS v3.0
 10446                                  	; MSDOS 3.3
 10447                                  	; MSDOS 6.0 (CPMIO2.ASM)
 10448 00002447 E84C1D                  	CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
 10449                                  					;hkn; to sft entry
 10450 0000244A 7226                    	JC	SHORT TRIPOPJ
 10451                                  	;mov	bx,[si+5]
 10452 0000244C 8B5C05                  	MOV	BX,[SI+SF_ENTRY.sf_flags]
 10453                                  	;test	bx,8000h
 10454 0000244F F7C30080                	TEST	BX,sf_isnet	; 8000H		; output to NET?
 10455 00002453 751D                    	JNZ	short TRIPOPJ 			; if so, no echo
 10456                                  	;test	bx,80h
 10457 00002455 F7C38000                	TEST	BX,devid_device ; 80H		; output to file?
 10458 00002459 7417                    	JZ	SHORT TRIPOPJ 			; if so, no echo
 10459                                  	; 14/03/2018
 10460                                  	;call	GET_IO_FCB	 	; IBMDOS.COM, MSDOS 2.11
 10461                                  	;jc	short TRIPOPJ
 10462                                  	; MSDOS 2.11
 10463                                  	;test	byte [SI+18H], 80h
 10464                                  	;jz	short TRIPOPJ
 10465 0000245B BB0400                  	MOV	BX,4
 10466 0000245E E8351D                  	CALL	GET_IO_SFT
 10467 00002461 720F                    	JC	SHORT TRIPOPJ
 10468                                  	;test	word [si+5], 800h
 10469 00002463 F744050008              	TEST	word [SI+SF_ENTRY.sf_flags],sf_net_spool ; 800H 
 10470                                  						; StdPrn redirected?
 10471                                  	;JZ	SHORT LISSTRT2J			; No, OK to echo
 10472 00002468 0F848E00                	jz	LISSTRT2 ; 10/08/2018 
 10473                                  	;MOV	BYTE [PFLAG],0			
 10474 0000246C 36C606[CA02]00          	MOV	BYTE [SS:PFLAG],0		; If a spool, NEVER echo
 10475                                  	; MSDOS 2.11
 10476                                  	;mov	bx,4
 10477                                  	;jmp	short LISSTRT2
 10478                                  	
 10479                                  TRIPOPJ:
 10480                                  	; 20/07/2018
 10481 00002472 E98800                  	JMP	TRIPOP
 10482                                  
 10483                                  ;LISSTRT2J:
 10484                                  ;	JMP	LISSTRT2
 10485                                  
 10486                                  CTRLOUT:
 10487 00002475 3C0D                    	CMP	AL,c_CR ; 0Dh
 10488 00002477 7420                    	JZ	SHORT ZERPOS
 10489 00002479 3C08                    	CMP	AL,c_BS ; 8
 10490 0000247B 7428                    	JZ	SHORT BACKPOS
 10491 0000247D 3C09                    	CMP	AL,c_HT ; 9
 10492 0000247F 759F                    	JNZ	SHORT OUTCH
 10493                                  	;MOV	AL,[CARPOS]
 10494 00002481 36A0[C501]              	MOV	AL,[SS:CARPOS]
 10495 00002485 0CF8                    	OR	AL,0F8H
 10496 00002487 F6D8                    	NEG	AL
 10497                                  
 10498                                  TAB:
 10499 00002489 51                      	PUSH	CX
 10500 0000248A 88C1                    	MOV	CL,AL
 10501 0000248C B500                    	MOV	CH,0
 10502 0000248E E307                    	JCXZ	POPTAB
 10503                                  TABLP:
 10504 00002490 B020                    	MOV	AL," "
 10505 00002492 E87EFF                  	CALL	OUTT
 10506 00002495 E2F9                    	LOOP	TABLP
 10507                                  POPTAB:
 10508 00002497 59                      	POP	CX
 10509 00002498 C3                      	RETN
 10510                                  
 10511                                  ZERPOS:
 10512                                  	;MOV	BYTE PTR [CARPOS],0
 10513 00002499 36C606[C501]00          	MOV	BYTE [SS:CARPOS],0
 10514                                  	; 10/08/2018
 10515 0000249F E97EFF                  	JMP	OUTCH
 10516                                  OUTJ:	
 10517 000024A2 E96EFF                  	JMP	OUTT
 10518                                  
 10519                                  BACKPOS:
 10520                                  	;DEC	BYTE PTR [CARPOS]
 10521 000024A5 36FE0E[C501]            	DEC	BYTE [SS:CARPOS]
 10522 000024AA E973FF                  	JMP	OUTCH
 10523                                  
 10524                                  BUFOUT:
 10525 000024AD 3C20                    	CMP	AL," "
 10526 000024AF 73F1                    	JAE	SHORT OUTJ		;Normal char
 10527 000024B1 3C09                    	CMP	AL,9
 10528 000024B3 74ED                    	JZ	SHORT OUTJ		;OUT knows how to expand tabs
 10529                                  	;DOS 3.3  7/14/86
 10530 000024B5 3C15                    	CMP	AL,"U"-"@" ; 15h	; turn ^U to section symbol
 10531 000024B7 740D                    	JZ	short CTRLU
 10532 000024B9 3C14                    	CMP	AL,"T"-"@" ; 14h	; turn ^T to paragraph symbol
 10533 000024BB 7409                    	JZ	short CTRLU
 10534                                  NOT_CTRLU:
 10535                                  	;DOS 3.3  7/14/86
 10536 000024BD 50                      	PUSH	AX
 10537 000024BE B05E                    	MOV	AL,"^"
 10538 000024C0 E850FF                  	CALL	OUTT		;Print '^' before control chars
 10539 000024C3 58                      	POP	AX
 10540 000024C4 0C40                    	OR	AL,40H		;Turn it into Upper case mate
 10541                                  CTRLU:
 10542 000024C6 E84AFF                  	CALL	OUTT
 10543                                  BUFOUT_RETN:
 10544 000024C9 C3                      	RETN
 10545                                  
 10546                                  ;
 10547                                  ;----------------------------------------------------------------------------
 10548                                  ;
 10549                                  ;**	$STD_AUX_INPUT - System Call 3
 10550                                  ;
 10551                                  ;	$STD_AUX_INPUT returns a character from Aux Input
 10552                                  ;
 10553                                  ;	ENTRY	none
 10554                                  ;	EXIT	(al) = character
 10555                                  ;	USES	all
 10556                                  ;
 10557                                  ;----------------------------------------------------------------------------
 10558                                  ;
 10559                                  
 10560                                  _$STD_AUX_INPUT:	;System call 3
 10561                                  
 10562 000024CA E80535                  	CALL	STATCHK
 10563 000024CD BB0300                  	MOV	BX,3
 10564 000024D0 E8C31C                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 10565                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 10566                                  	;retc
 10567 000024D3 72F4                    	JC	SHORT BUFOUT_RETN
 10568 000024D5 EB03                    	JMP	SHORT TAISTRT
 10569                                  AUXILP:
 10570 000024D7 E8D934                  	CALL	SPOOLINT
 10571                                  TAISTRT:
 10572 000024DA B401                    	MOV	AH,1
 10573 000024DC E8A62A                  	CALL	IOFUNC
 10574 000024DF 74F6                    	JZ	SHORT AUXILP
 10575 000024E1 30E4                    	XOR	AH,AH
 10576 000024E3 E89F2A                  	CALL	IOFUNC
 10577 000024E6 C3                      	RETN
 10578                                  
 10579                                  ;
 10580                                  ;----------------------------------------------------------------------------
 10581                                  ;
 10582                                  ;**	$STD_AUX_OUTPUT - Output character to AUX
 10583                                  ;
 10584                                  ;	ENTRY	(dl) = character
 10585                                  ;	EXIT	none
 10586                                  ;	USES	all
 10587                                  ;
 10588                                  ;----------------------------------------------------------------------------
 10589                                  ;
 10590                                  
 10591                                  _$STD_AUX_OUTPUT:	;System call 4
 10592                                  
 10593 000024E7 53                      	PUSH	BX
 10594 000024E8 BB0300                  	MOV	BX,3
 10595 000024EB EB04                    	JMP	SHORT SENDOUT
 10596                                  
 10597                                  ;
 10598                                  ;----------------------------------------------------------------------------
 10599                                  ;
 10600                                  ;**	$STD_PRINTER_OUTPUT - Output character to printer
 10601                                  ;
 10602                                  ;	ENTRY	(dl) = character
 10603                                  ;	EXIT	none
 10604                                  ;	USES	all
 10605                                  ;
 10606                                  ;----------------------------------------------------------------------------
 10607                                  ;
 10608                                  
 10609                                  _$STD_PRINTER_OUTPUT:	;System call 5
 10610                                  
 10611 000024ED 53                      	PUSH	BX
 10612 000024EE BB0400                  	MOV	BX,4
 10613                                  
 10614                                  SENDOUT:
 10615 000024F1 88D0                    	MOV	AL,DL
 10616 000024F3 50                      	PUSH	AX
 10617 000024F4 E8DB34                  	CALL	STATCHK
 10618 000024F7 58                      	POP	AX
 10619 000024F8 1E                      	PUSH	DS
 10620 000024F9 56                      	PUSH	SI
 10621                                  LISSTRT2:
 10622 000024FA E8D0FE                  	CALL	RAWOUT2
 10623                                  TRIPOP:
 10624 000024FD 5E                      	POP	SI
 10625 000024FE 1F                      	POP	DS
 10626 000024FF 5B                      	POP	BX
 10627                                  SCIS_RETN:	; 20/07/2018
 10628 00002500 C3                      	RETN
 10629                                  ;
 10630                                  ;----------------------------------------------------------------------------
 10631                                  ;
 10632                                  ;**	$STD_CON_INPUT_STATUS - System Call 11
 10633                                  ;
 10634                                  ;	Check console input status
 10635                                  ;
 10636                                  ;	ENTRY	none
 10637                                  ;	EXIT	AL = -1 character available, = 0 no character
 10638                                  ;	USES	all
 10639                                  ;
 10640                                  ;----------------------------------------------------------------------------
 10641                                  ;
 10642                                  
 10643                                  _$STD_CON_INPUT_STATUS:		 ;System call 11
 10644                                  
 10645 00002501 E8CE34                  	CALL	STATCHK
 10646 00002504 B000                    	MOV	AL,0			; no xor!!
 10647                                  	;retz
 10648 00002506 74F8                    	JZ	SHORT SCIS_RETN ; 15/04/2018
 10649 00002508 0CFF                    	OR	AL,-1
 10650                                  ;SCIS_RETN:
 10651 0000250A C3                      	RETN
 10652                                  
 10653                                  ;
 10654                                  ;----------------------------------------------------------------------------
 10655                                  ;
 10656                                  ;**	$STD_CON_INPUT_FLUSH - System Call 12
 10657                                  ;
 10658                                  ;	Flush console input buffer and perform call in AL
 10659                                  ;
 10660                                  ;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
 10661                                  ;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
 10662                                  ;		return arguments for the fcn supplied in (AL)
 10663                                  ;	USES	all
 10664                                  ;
 10665                                  ;----------------------------------------------------------------------------
 10666                                  ;
 10667                                  
 10668                                  _$STD_CON_INPUT_FLUSH:		;System call 12
 10669                                  
 10670 0000250B 50                      	PUSH	AX
 10671 0000250C 52                      	PUSH	DX
 10672 0000250D 31DB                    	XOR	BX,BX
 10673 0000250F E8841C                  	CALL	GET_IO_SFT	; 20/07/2018 - MSDOS 3.3 (MSDOS 6.0)
 10674                                  	;CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.11
 10675 00002512 7205                    	JC	SHORT BADJFNCON
 10676 00002514 B404                    	MOV	AH,4
 10677 00002516 E86C2A                  	CALL	IOFUNC
 10678                                  
 10679                                  BADJFNCON:
 10680 00002519 5A                      	POP	DX
 10681 0000251A 58                      	POP	AX
 10682 0000251B 88C4                    	MOV	AH,AL
 10683 0000251D 3C01                    	CMP	AL,1
 10684 0000251F 7413                    	JZ	SHORT REDISPJ
 10685 00002521 3C06                    	CMP	AL,6
 10686 00002523 740F                    	JZ	SHORT REDISPJ
 10687 00002525 3C07                    	CMP	AL,7
 10688 00002527 740B                    	JZ	SHORT REDISPJ
 10689 00002529 3C08                    	CMP	AL,8
 10690 0000252B 7407                    	JZ	SHORT REDISPJ
 10691 0000252D 3C0A                    	CMP	AL,10
 10692 0000252F 7403                    	JZ	SHORT REDISPJ
 10693 00002531 B000                    	MOV	AL,0
 10694 00002533 C3                      	RETN
 10695                                  
 10696                                  REDISPJ:
 10697 00002534 FA                      	CLI
 10698                                  	;transfer REDISP
 10699 00002535 E94BF0                  	JMP	REDISP
 10700                                  
 10701                                  ;============================================================================
 10702                                  ; FCBIO.ASM, MSDOS 6.0, 1991
 10703                                  ;============================================================================
 10704                                  ; 20/07/2018 - Retro DOS v3.0
 10705                                  ; 17/05/2019 - Retro DOS v4.0
 10706                                  ; 24/07/2019 - Retro DOS v3.2
 10707                                  
 10708                                  ;**	FCBIO.ASM - Ancient 1.0 1.1 FCB system calls
 10709                                  ;
 10710                                  ;	$GET_FCB_POSITION
 10711                                  ;	$FCB_DELETE
 10712                                  ;	$GET_FCB_FILE_LENGTH
 10713                                  ;	$FCB_CLOSE
 10714                                  ;	$FCB_RENAME
 10715                                  ;	SaveFCBInfo
 10716                                  ;	ResetLRU
 10717                                  ;	SetOpenAge
 10718                                  ;	LRUFCB
 10719                                  ;	FCBRegen
 10720                                  ;	BlastSFT
 10721                                  ;	CheckFCB
 10722                                  ;	SFTFromFCB
 10723                                  ;	FCBHardErr
 10724                                  ;
 10725                                  ;	Revision history:
 10726                                  ;
 10727                                  ;		Created: ARR 4 April 1983"
 10728                                  ;			 MZ  6 June  1983 completion of functions
 10729                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 10730                                  ;					  times.  Change so successive closes work by
 10731                                  ;					  always returning OK.	Also, detect I/O to
 10732                                  ;					  already closed FCB and return EOF.
 10733                                  ;			 MZ 16 Jan   1984 More braindamage.  Need to separate info
 10734                                  ;					  out of sft into FCB for reconnection
 10735                                  ;
 10736                                  ;		A000	 version 4.00  Jan. 1988
 10737                                  
 10738                                  ;Break <$Get_FCB_Position - set random record fields to current pos>
 10739                                  ;----------------------------------------------------------------------------
 10740                                  ;
 10741                                  ;   $Get_FCB_Position - look at an FCB, retrieve the current position from the
 10742                                  ;	extent and next record field and set the random record field to point
 10743                                  ;	to that record
 10744                                  ;
 10745                                  ;   Inputs:	DS:DX point to a possible extended FCB
 10746                                  ;   Outputs:	The random record field of the FCB is set to the current record
 10747                                  ;   Registers modified: all
 10748                                  ;
 10749                                  ;----------------------------------------------------------------------------
 10750                                  ;
 10751                                  
 10752                                  _$GET_FCB_POSITION:
 10753 00002538 E8F104                  	call	GetExtended		; point to FCB
 10754 0000253B E8C104                  	call	GetExtent		; DX:AX is current record
 10755                                  	;mov	[si+21h],ax
 10756 0000253E 894421                  	MOV	[SI+SYS_FCB.RR],AX ; drop in low order piece
 10757                                  	;mov	[si+23h],dl
 10758 00002541 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; drop in high order piece
 10759                                  	;cmp	word [si+0Eh],64
 10760 00002544 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 10761 00002548 7303                    	JAE	short GetFCBBye
 10762                                  	;mov	[si+24h],dh
 10763 0000254A 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 10764                                  GetFCBBye:
 10765 0000254D E967F2                  	jmp	FCB_RET_OK
 10766                                  
 10767                                  
 10768                                  ;Break <$FCB_Delete - remove several files that match the input FCB>
 10769                                  ;----------------------------------------------------------------------------
 10770                                  ;
 10771                                  ;**	$FCB_Delete - Delete from FCB Template
 10772                                  ;
 10773                                  ;	given an FCB, remove all directory entries in the current
 10774                                  ;	directory that have names that match the FCB's ?  marks.
 10775                                  ;
 10776                                  ;	ENTRY	(DS:DX) = address of FCB
 10777                                  ;	EXIT	entries matching the FCB are deleted
 10778                                  ;		(al) = ff iff no entries were deleted
 10779                                  ;	USES	all
 10780                                  ;
 10781                                  ;----------------------------------------------------------------------------
 10782                                  ;
 10783                                  
 10784                                  _$FCB_DELETE:		; System call 19
 10785                                  					; OpenBuf is in DOSDATA
 10786 00002550 BF[8203]                	MOV	DI,OPENBUF 		; appropriate place 
 10787                                  
 10788 00002553 E8D847                  	call	TransFCB		; convert FCB to path
 10789 00002556 720A                    	JC	short BadPath 		; signal no deletions
 10790                                  
 10791 00002558 16                      	push	SS
 10792 00002559 1F                      	pop	DS			; SS is DOSDATA
 10793                                  
 10794 0000255A E8820D                  	call	DOS_DELETE		; wham
 10795 0000255D 7203                    	JC	short BadPath
 10796                                  GoodPath:
 10797 0000255F E955F2                  	jmp	FCB_RET_OK		; do a good return
 10798                                  BadPath:
 10799                                  	; Error code is in AX
 10800                                  
 10801 00002562 E955F2                  	jmp	FCB_RET_ERR		; let someone else signal the error
 10802                                  
 10803                                  ;Break <$Get_FCB_File_Length - return the length of a file>
 10804                                  ;----------------------------------------------------------------------------
 10805                                  ;
 10806                                  ;   $Get_FCB_File_Length - set the random record field to the length of the
 10807                                  ;	file in records (rounded up if partial).
 10808                                  ;
 10809                                  ;   Inputs:	DS:DX - point to a possible extended FCB
 10810                                  ;   Outputs:	Random record field updated to reflect the number of records
 10811                                  ;   Registers modified: all
 10812                                  ;
 10813                                  ;----------------------------------------------------------------------------
 10814                                  ;
 10815                                  
 10816                                  _$GET_FCB_FILE_LENGTH:
 10817 00002565 E8C404                  	call	GetExtended		; get real FCB pointer
 10818                                  					; DX points to Input FCB
 10819                                  
 10820                                  					; OpenBuf is in DOSDATA
 10821 00002568 BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 10822                                  
 10823 0000256B 1E                      	push	ds			; save pointer to true FCB
 10824 0000256C 56                      	push	si
 10825 0000256D E8BE47                  	call	TransFCB		; Trans name DS:DX, sets SATTRIB
 10826 00002570 5E                      	pop	si
 10827 00002571 1F                      	pop	ds
 10828 00002572 72EE                    	JC	short BadPath
 10829 00002574 1E                      	push	ds			; save pointer
 10830 00002575 56                      	push	si
 10831 00002576 16                      	push	ss		
 10832 00002577 1F                      	pop	ds
 10833 00002578 E8E710                  	call	GET_FILE_INFO		; grab the info
 10834 0000257B 5E                      	pop	si			; get pointer back
 10835 0000257C 1F                      	pop	ds
 10836 0000257D 72E3                    	JC	short BadPath 		; invalid something
 10837 0000257F 89DA                    	MOV	DX,BX			; get high order size
 10838 00002581 89F8                    	MOV	AX,DI			; get low order size
 10839                                  	;mov	bx,[si+0Eh]
 10840 00002583 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 10841 00002586 09DB                    	OR	BX,BX			; empty record => 0 size for file
 10842 00002588 7503                    	JNZ	short GetSize 		; not empty
 10843 0000258A BB8000                  	MOV	BX,128
 10844                                  GetSize:
 10845 0000258D 89C7                    	MOV	DI,AX			; save low order word
 10846 0000258F 89D0                    	MOV	AX,DX			; move high order for divide
 10847 00002591 31D2                    	XOR	DX,DX			; clear out high
 10848 00002593 F7F3                    	DIV	BX			; wham
 10849 00002595 50                      	PUSH	AX			; save dividend
 10850 00002596 89F8                    	MOV	AX,DI			; get low order piece
 10851 00002598 F7F3                    	DIV	BX			; wham
 10852 0000259A 89D1                    	MOV	CX,DX			; save remainder
 10853 0000259C 5A                      	POP	DX			; get high order dividend
 10854 0000259D E306                    	JCXZ	LengthStore		; no roundup
 10855 0000259F 83C001                  	ADD	AX,1
 10856 000025A2 83D200                  	ADC	DX,0			; 32-bit increment
 10857                                  LengthStore:
 10858                                  	;mov	[si+21h],ax
 10859 000025A5 894421                  	MOV	[SI+SYS_FCB.RR],AX	; store low order
 10860                                  	;mov	[si+23h],dl
 10861 000025A8 885423                  	MOV	[SI+SYS_FCB.RR+2],DL	; store high order
 10862 000025AB 08F6                    	OR	DH,DH
 10863 000025AD 74B0                    	JZ	short GoodPath		; not storing insignificant zero
 10864                                  	;mov	[si+24h],dh
 10865 000025AF 887424                  	MOV	[SI+SYS_FCB.RR+3],DH	; save that high piece
 10866                                  GoodRet:
 10867                                  	;jmp	FCB_RET_OK
 10868 000025B2 EBAB                    	jmp	short GoodPath
 10869                                  
 10870                                  ;Break <$FCB_Close - close a file>
 10871                                  ;----------------------------------------------------------------------------
 10872                                  ;
 10873                                  ;   $FCB_Close - given an FCB, look up the SFN and close it.  Do not free it
 10874                                  ;	as the FCB may be used for further I/O
 10875                                  ;
 10876                                  ;   Inputs:	DS:DX point to FCB
 10877                                  ;   Outputs:	AL = FF if file was not found on disk
 10878                                  ;   Registers modified: all
 10879                                  ;
 10880                                  ;----------------------------------------------------------------------------
 10881                                  ;
 10882                                  
 10883                                  _$FCB_CLOSE:		; System call 16
 10884                                  
 10885 000025B4 30C0                    	XOR	AL,AL			; default search attributes
 10886 000025B6 E87304                  	call	GetExtended		; DS:SI point to real FCB
 10887 000025B9 7403                    	JZ	short NoAttr		; not extended
 10888 000025BB 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 10889                                  NoAttr:
 10890                                  					; SS override
 10891 000025BE 36A2[2805]              	MOV	[SS:ATTRIB],AL		; stash away found attributes
 10892 000025C2 E8DC03                  	call	SFTFromFCB
 10893 000025C5 72EB                    	JC	short GoodRet 		; MZ 16 Jan Assume death
 10894                                  
 10895                                  	; If the sharer is present, then the SFT is not regenable. Thus, 
 10896                                  	; there is no need to set the SFT's attribute.
 10897                                  
 10898                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 10899                                  	;;; done
 10900                                  
 10901                                  	;mov	al,[es:di+4]
 10902 000025C7 268A4504                	MOV	AL,[ES:DI+SF_ENTRY.sf_attr]
 10903 000025CB 30E4                    	XOR	AH,AH
 10904 000025CD 50                      	PUSH	AX
 10905                                  
 10906                                  	;;; 9/8/86 F.C. save SFT attribute and restore it back when close is 
 10907                                  	;;; done
 10908                                  
 10909 000025CE E89550                  	call	CheckShare
 10910 000025D1 7508                    	JNZ	short NoStash
 10911 000025D3 36A0[2805]              	MOV	AL,[SS:ATTRIB]
 10912                                  	;mov	[es:di+4],al
 10913 000025D7 26884504                	MOV	[ES:DI+SF_ENTRY.sf_attr],AL ; attempted attribute for close
 10914                                  NoStash:
 10915                                  	;mov	ax,[si+14h]
 10916 000025DB 8B4414                  	MOV	AX,[SI+SYS_FCB.FDATE] ; move in the time and date
 10917                                  	;mov	[es:di+0Fh],ax
 10918 000025DE 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 10919                                  	;mov	ax,[si+16h]
 10920 000025E2 8B4416                  	MOV	AX,[SI+SYS_FCB.FTIME]
 10921                                  	;mov	[es:di+0Dh],ax
 10922 000025E5 2689450D                	MOV	[ES:DI+SF_ENTRY.sf_time],AX
 10923                                  	;mov	ax,[si+10h]
 10924 000025E9 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 10925                                  	;mov	[es:di+11h],ax
 10926 000025EC 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 10927                                  	;mov	ax,[si+12h]
 10928 000025F0 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 10929                                  	;mov	[es:di+13h],ax
 10930 000025F3 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 10931                                  	;or	word [es:di+5],4000h
 10932 000025F7 26814D050040            	OR	word [ES:DI+SF_ENTRY.sf_flags],sf_close_nodate
 10933 000025FD 16                      	push	ss
 10934 000025FE 1F                      	pop	ds
 10935 000025FF E82F15                  	call	DOS_CLOSE	; wham
 10936 00002602 C43E[5A05]              	LES	DI,[THISSFT]
 10937                                  
 10938                                  	;;; 9/8/86 F.C. restore SFT attribute
 10939 00002606 59                      	POP	CX
 10940                                  	;mov	[es:di+4],cl
 10941 00002607 26884D04                	MOV	[ES:DI+SF_ENTRY.sf_attr],CL
 10942                                  	;;; 9/8/86 F.C. restore SFT attribute
 10943                                  
 10944 0000260B 9C                      	PUSHF
 10945                                  	;test	word [es:di],0FFFFh
 10946                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],0
 10947                                  				; zero ref count gets blasted
 10948 0000260C 26833D00                	cmp	word [ES:DI],0
 10949 00002610 7507                    	jnz     short CloseOK
 10950 00002612 50                      	PUSH	AX
 10951 00002613 B04D                    	MOV	AL,'M'
 10952 00002615 E8F602                  	call	BlastSFT
 10953 00002618 58                      	POP	AX
 10954                                  CloseOK:
 10955 00002619 9D                      	POPF
 10956 0000261A 7396                    	JNC	short GoodRet
 10957                                  	;cmp	al,6
 10958 0000261C 3C06                    	CMP	AL,error_invalid_handle
 10959 0000261E 7492                    	JZ	short GoodRet
 10960                                  	;mov	al,2
 10961 00002620 B002                    	MOV	AL,error_file_not_found
 10962                                  fcb_close_err:
 10963 00002622 E995F1                  	jmp	FCB_RET_ERR
 10964                                  
 10965                                  ;
 10966                                  ;----------------------------------------------------------------------------
 10967                                  ;
 10968                                  ;**	$FCB_Rename - Rename a File
 10969                                  ;
 10970                                  ;	$FCB_Rename - rename a file in place within a directory. Renames
 10971                                  ;	multiple files copying from the meta characters.
 10972                                  ;
 10973                                  ;	ENTRY	DS:DX point to an FCB. The normal name field is the source
 10974                                  ;		    name of the files to be renamed. Starting at offset 11h
 10975                                  ;		    in the FCB is the destination name.
 10976                                  ;	EXIT	AL = 0 -> no error occurred and all files were renamed
 10977                                  ;		AL = FF -> some files may have been renamed but:
 10978                                  ;			rename to existing file or source file not found
 10979                                  ;	USES	ALL
 10980                                  ;
 10981                                  ;----------------------------------------------------------------------------
 10982                                  ;
 10983                                  
 10984                                  _$FCB_RENAME:		; System call 23
 10985                                  
 10986 00002625 E80404                  	call	GetExtended		; get pointer to real FCB
 10987 00002628 52                      	push	dx
 10988 00002629 8A04                    	MOV	AL,[SI] 		; get drive byte
 10989 0000262B 83C610                  	ADD	SI,10h			; point to destination
 10990                                  
 10991                                  					; RenBuf is in DOSDATA
 10992 0000262E BF[0204]                	MOV	DI,RENBUF		; point to destination buffer
 10993 00002631 FF34                    	push	word [SI]
 10994 00002633 1E                      	push	ds
 10995 00002634 57                      	push	di			; save source pointer for TransFCB
 10996 00002635 8804                    	MOV	[SI],AL			; drop in real drive
 10997 00002637 89F2                    	MOV	DX,SI			; let TransFCB know where the FCB is
 10998 00002639 E8F246                  	call	TransFCB		; munch this pathname
 10999 0000263C 5E                      	pop	si
 11000 0000263D 1F                      	pop	ds	
 11001 0000263E 8F04                    	pop	WORD [SI]		; get path back
 11002 00002640 5A                      	pop	dx			; Original FCB pointer
 11003 00002641 721A                    	JC	short fren90		; bad path -> error
 11004                                  
 11005                                  					; SS override for WFP_Start & Ren_WFP
 11006 00002643 368B36[6E05]            	MOV	SI,[ss:WFP_START]	; get pointer
 11007 00002648 368936[7005]            	MOV	[ss:REN_WFP],SI		; stash it
 11008                                  
 11009                                  					; OpenBuf is in DOSDATA
 11010 0000264D BF[8203]                	MOV	DI,OPENBUF		; appropriate spot
 11011 00002650 E8DB46                  	call	TransFCB		; wham
 11012                                  					; NOTE that this call is pointing
 11013                                  					;  back to the ORIGINAL FCB so
 11014                                  					;  SATTRIB gets set correctly
 11015 00002653 7208                    	JC	short fren90		; error
 11016 00002655 E8320E                  	call	DOS_RENAME
 11017 00002658 7203                    	JC	short fren90
 11018 0000265A E95AF1                  	jmp	FCB_RET_OK
 11019                                  
 11020                                  ;	Error -
 11021                                  ;
 11022                                  ;	(al) = error code
 11023                                  
 11024                                  fren90:	
 11025 0000265D E95AF1                  	jmp	FCB_RET_ERR
 11026                                  
 11027                                  ;Break <Misbehavior fixers>
 11028                                  ;
 11029                                  ;   FCBs suffer from several problems. First, they are maintained in the
 11030                                  ;   user's space so he may move them at will. Second, they have a small
 11031                                  ;   reserved area that may be used for system information. Third, there was
 11032                                  ;   never any "rules for behavior" for FCBs; there was no protocol for their
 11033                                  ;   usage.
 11034                                  ;
 11035                                  ;   This results in the following misbehavior:
 11036                                  ;
 11037                                  ;	infinite opens of the same file:
 11038                                  ;
 11039                                  ;	While (TRUE) {			While (TRUE) {
 11040                                  ;	    FCBOpen (FCB);		    FCBOpen (FCB);
 11041                                  ;	    Read (FCB); 		    Write (FCB);
 11042                                  ;	    }				    }
 11043                                  ;
 11044                                  ;	infinite opens of different files:
 11045                                  ;
 11046                                  ;	While (TRUE) {			While (TRUE) {
 11047                                  ;	    FCBOpen (FCB[i++]); 	    FCBOpen (FCB[i++]);
 11048                                  ;	    Read (FCB); 		    Write (FCB);
 11049                                  ;	    }				    }
 11050                                  ;
 11051                                  ;	multiple closes of the same file:
 11052                                  ;
 11053                                  ;	FCBOpen (FCB);
 11054                                  ;	while (TRUE)
 11055                                  ;	    FCBClose (FCB);
 11056                                  ;
 11057                                  ;	I/O after closing file:
 11058                                  ;
 11059                                  ;	FCBOpen (FCB);
 11060                                  ;	while (TRUE) {
 11061                                  ;	    FCBWrite (FCB);
 11062                                  ;	    FCBClose (FCB);
 11063                                  ;	    }
 11064                                  ;
 11065                                  ;   The following is am implementation of a methodology for emulating the
 11066                                  ;   above with the exception of I/O after close. We are NOT attempting to
 11067                                  ;   resolve that particular misbehavior. We will enforce correct behaviour in
 11068                                  ;   FCBs when they refer to a network file or when there is file sharing on
 11069                                  ;   the local machine.
 11070                                  ;
 11071                                  ;   The reserved fields of the FCB (10 bytes worth) is divided up into various
 11072                                  ;   structures depending on the file itself and the state of operations of the
 11073                                  ;   OS. The information contained in this reserved field is enough to
 11074                                  ;   regenerate the SFT for the local non-shared file. It is assumed that this
 11075                                  ;   regeneration procedure may be expensive. The SFT for the FCB is
 11076                                  ;   maintained in a LRU cache as the ONLY performance inprovement.
 11077                                  ;
 11078                                  ;   No regeneration of SFTs is attempted for network FCBs.
 11079                                  ;
 11080                                  ;   To regenerate the SFT for a local FCB, it is necessary to determine if the
 11081                                  ;   file sharer is working. If the file sharer is present then the SFT is not
 11082                                  ;   regenerated.
 11083                                  ;
 11084                                  ;   Finally, if there is no local sharing, the full name of the file is no
 11085                                  ;   longer available. We can make up for this by using the following
 11086                                  ;   information:
 11087                                  ;
 11088                                  ;	The Drive number (from the DPB).
 11089                                  ;	The physical sector of the directory that contains the entry.
 11090                                  ;	The relative position of the entry in the sector.
 11091                                  ;	The first cluster field.
 11092                                  ;	The last used SFT.
 11093                                  ;      OR In the case of a device FCB
 11094                                  ;	The low 6 bits of sf_flags (indicating device type)
 11095                                  ;	The pointer to the device header
 11096                                  ;
 11097                                  ;   We read in the particular directory sector and examine the indicated
 11098                                  ;   directory entry. If it matches, then we are kosher; otherwise, we fail.
 11099                                  ;
 11100                                  ;   Some key items need to be remembered:
 11101                                  ;
 11102                                  ;	Even though we are caching SFTs, they may contain useful sharing
 11103                                  ;	information. We enforce good behavior on the FCBs.
 11104                                  ;
 11105                                  ;	Network support must not treat FCBs as impacting the ref counts on
 11106                                  ;	open VCs. The VCs may be closed only at process termination.
 11107                                  ;
 11108                                  ;	If this is not an installed version of the DOS, file sharing will
 11109                                  ;	always be present.
 11110                                  ;
 11111                                  ;	We MUST always initialize lstclus to = firclus when regenerating a
 11112                                  ;	file. Otherwise we start allocating clusters up the wazoo.
 11113                                  ;
 11114                                  ;	Always initialize, during regeneration, the mode field to both isFCB
 11115                                  ;	and open_for_both. This is so the FCB code in the sharer can find the
 11116                                  ;	proper OI record.
 11117                                  ;
 11118                                  ;   The test bits are:
 11119                                  ;
 11120                                  ;	00 -> local file
 11121                                  ;	40 -> sharing local
 11122                                  ;	80 -> network
 11123                                  ;	C0 -> local device
 11124                                  
 11125                                  ;Break	<SaveFCBInfo - store pertinent information from an SFT into the FCB>
 11126                                  ;----------------------------------------------------------------------------
 11127                                  ;
 11128                                  ;   SaveFCBInfo - given an FCB and its associated SFT, copy the relevant
 11129                                  ;	pieces of information into the FCB to allow for subsequent
 11130                                  ;	regeneration. Poke LRU also.
 11131                                  ;
 11132                                  ;   Inputs:	ThisSFT points to a complete SFT.
 11133                                  ;		DS:SI point to the FCB (not an extended one)
 11134                                  ;   Outputs:	The relevant reserved fields in the FCB are filled in.
 11135                                  ;		DS:SI preserved
 11136                                  ;		ES:DI point to sft
 11137                                  ;   Registers modified: All
 11138                                  ;
 11139                                  ;
 11140                                  ;----------------------------------------------------------------------------
 11141                                  ;
 11142                                  
 11143                                  SaveFCBInfo:
 11144                                  
 11145 00002660 36C43E[5A05]            	LES	DI,[SS:THISSFT]		; SS override
 11146 00002665 E81CFA                  	call	IsSFTNet
 11147 00002668 740B                    	JZ	short SaveLocal		; if not network then save local info
 11148                                  ;
 11149                                  ;----- In net support -----
 11150                                  ;
 11151                                  	; 17/05/2019 - Retro DOS v4.0
 11152                                  	; 24/07/2019 - Retro DOS v3.2
 11153                                  
 11154                                  	; MSDOS 3.3
 11155                                  	;;mov	ax,[es:di+1Dh]
 11156                                  	;mov	ax,[es:di+SF_ENTRY.sf_dirsec]
 11157                                  	;;mov	[si+1Ah],ax
 11158                                  	;mov	[si+fcb_net_handle],ax
 11159                                  	;push	es
 11160                                  	;push	di
 11161                                  	;;les	di,[es:di+19h]
 11162                                  	;LES	DI,[ES:DI+sf_netid]
 11163                                  	;;mov	[si+1Ch],di
 11164                                  	;MOV	[SI+fcb_netID],DI	; save net ID
 11165                                  	;;mov 	[si+1Eh],es
 11166                                  	;MOV	[SI+fcb_netID+2],ES
 11167                                  	;pop	di
 11168                                  	;pop	es
 11169                                  
 11170                                  	; MSDOS 6.0
 11171                                  	;mov	ax,[es:di+0Bh]
 11172 0000266A 268B450B                	MOV	AX,[ES:DI+sf_serial_ID] ;AN000;;IFS. save IFS ID
 11173                                  	;mov	[si+1Ch],ax
 11174 0000266E 89441C                  	MOV	[SI+fcb_netID],ax	;AN000;;IFS.
 11175                                  	
 11176                                  	;mov	bl,80h
 11177 00002671 B380                    	MOV	BL,FCBNETWORK
 11178                                  ;
 11179                                  ;----- END In net support -----
 11180                                  ;
 11181 00002673 EB65                    	jmp	SHORT SaveSFN
 11182                                  
 11183                                  SaveLocal:
 11184                                  	;IF	Installed
 11185 00002675 E8EE4F                  	call	CheckShare
 11186                                  	;JZ	short SaveNoShare	; no sharer
 11187                                  	;JMP	short SaveShare		; sharer present
 11188                                  	; 28/07/2019
 11189 00002678 755B                    	jnz	short SaveShare
 11190                                  
 11191                                  SaveNoShare:
 11192                                  	;;test 	word [es:di+5],80h
 11193                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 11194 0000267A 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; 80h	
 11195 0000267F 7542                    	JNZ	short SaveNoShareDev	; Device
 11196                                  
 11197                                  	; Save no sharing local file information
 11198                                  
 11199                                  	;;mov	ax,[es:di+1Dh]  ; MSDOS 3.3
 11200                                  	;mov	ax,[es:di+1Bh]  ; MSDOS 6.0
 11201 00002681 268B451B                	MOV	AX,[ES:DI+SF_ENTRY.sf_dirsec] ; get directory sector F.C.
 11202                                  	;mov	[si+1Dh],ax
 11203 00002685 89441D                  	MOV	[SI+fcb_nsl_dirsec],AX
 11204                                  
 11205                                  	; MSDOS 6.0
 11206                                  
 11207                                  	;SR; Store high byte of directory sector
 11208                                  	;mov	ax,[es:di+1Dh]
 11209 00002688 268B451D                	mov	ax,[es:di+SF_ENTRY.sf_dirsec+2] ; get high word
 11210                                  	
 11211                                  	; SR;
 11212                                  	; We have to store the read-only and archive attributes of the file.
 11213                                  	; We extract it from the SFT and store it in the top two bits of the 
 11214                                  	; sector number ( sector number == 22 bits only )
 11215                                  
 11216                                  	;mov	bl,[es:di+4]
 11217 0000268C 268A5D04                	mov	bl,[es:di+SF_ENTRY.sf_attr]
 11218 00002690 88DF                    	mov	bh,bl
 11219 00002692 D0CB                    	ror	bl,1
 11220 00002694 D0E7                    	shl	bh,1
 11221 00002696 08FB                    	or	bl,bh
 11222 00002698 80E3C0                  	and	bl,0C0h
 11223 0000269B 08D8                    	or	al,bl
 11224 0000269D 884418                  	mov	[si+fcb_sfn],al	; sector number = 22 bits
 11225                                  
 11226                                  	; MSDOS 6.0 (& MSDOS 3.3)
 11227                                  	;mov	al,[es:di+1Fh]
 11228 000026A0 268A451F                	MOV	AL,[ES:DI+SF_ENTRY.sf_dirpos] ; location in sector
 11229                                  	;mov	[si+1Fh],al
 11230 000026A4 88441F                  	MOV	[SI+fcb_nsl_dirpos],AL
 11231                                  	;mov	ax,[es:di+0Bh]
 11232 000026A7 268B450B                	MOV	AX,[ES:DI+SF_ENTRY.sf_firclus] ; first cluster
 11233                                  	;mov	[si+1Bh],ax
 11234 000026AB 89441B                  	MOV	[SI+fcb_nsl_firclus],AX
 11235 000026AE B300                    	MOV	BL,0
 11236                                  
 11237                                  	; Create the bits field from the dirty/device bits of the flags word 
 11238                                  	; and the mode byte
 11239                                  
 11240                                  SetFCBBits:
 11241                                  	;mov	ax,[es:di+5]
 11242 000026B0 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11243 000026B4 24C0                    	AND	AL,0C0h 		; mask off drive bits
 11244                                  	;or	al,[es:di+2]
 11245 000026B6 260A4502                	OR	AL,[ES:DI+SF_ENTRY.sf_mode] ; stick in open mode
 11246                                  	;mov	[si+1Ah], al
 11247 000026BA 88441A                  	MOV	[SI+fcb_nsl_bits],AL	; save dirty info
 11248                                  
 11249                                  	; MSDOS 6.0
 11250                                  	
 11251                                  	; SR;
 11252                                  	; Check if we came here for local file or device. If for local file, 
 11253                                  	; skip setting of SFT index
 11254                                  	
 11255 000026BD 08DB                    	or	bl,bl
 11256 000026BF 742A                    	jz	short SaveNoSFN		; do not save SFN if local file
 11257                                  
 11258 000026C1 EB17                    	JMP	short SaveSFN 		; go and save SFN
 11259                                  
 11260                                  	; Save no sharing local device information
 11261                                  
 11262                                  SaveNoShareDev:
 11263                                  	;mov	ax,[es:di+7]
 11264 000026C3 268B4507                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr]
 11265                                  	;mov	[si+1Ah],ax
 11266 000026C7 89441A                  	MOV	[SI+fcb_nsld_drvptr],AX
 11267                                  	;mov	ax,[es:di+9]
 11268 000026CA 268B4509                	MOV	AX,[ES:DI+SF_ENTRY.sf_devptr+2]
 11269 000026CE 89441C                  	MOV	[SI+fcb_nsld_drvptr+2],AX
 11270                                  	;mov	bl,40h
 11271 000026D1 B340                    	MOV	BL,FCBDEVICE
 11272 000026D3 EBDB                    	JMP	SetFCBBits		; go and save SFN
 11273                                  
 11274                                  SaveShare:
 11275                                  	;ENDIF
 11276                                  ;
 11277                                  ;----- In share support -----
 11278                                  ;
 11279                                  	;call	far [ss:ShSave]
 11280 000026D5 36FF1E[8400]            	Call	far [ss:JShare+(10*4)] ; 10 = ShSave ; SS Override
 11281                                  ;
 11282                                  ;----- end in share support -----
 11283                                  ;
 11284                                  	; 17/05/2019 - Retro DOS v4.0
 11285                                  SaveSFN:
 11286                                  	; 24/07/2019 - Retro DOS v3.2
 11287                                  	;lea	ax,[di-6]
 11288 000026DA 8D45FA                  	LEA	AX,[DI-SFT.SFTable]
 11289                                  	
 11290                                  	; Adjust for offset to table.
 11291                                  	
 11292 000026DD 362B06[4000]            	SUB	AX,[SS:SFTFCB]		; SS override for SftFCB
 11293                                  
 11294 000026E2 53                      	push	bx			;bx = FCB type (net/Share or local)
 11295                                  	;;mov	bl,53 ; MSDOS 3.3
 11296                                  	;mov	bl,59 ; MSDOS 6.0
 11297 000026E3 B33B                    	MOV	BL,SF_ENTRY.size
 11298 000026E5 F6F3                    	DIV	BL
 11299                                  	;mov	[si+18h],al
 11300 000026E7 884418                  	MOV	[SI+fcb_sfn],AL		; last used SFN
 11301 000026EA 5B                      	pop	bx			;restore bx
 11302                                  
 11303                                  SaveNoSFN:
 11304                                  	;mov	ax,[es:di+5]
 11305 000026EB 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 11306 000026EF 243F                    	AND	AL,3Fh			; get real drive
 11307 000026F1 08D8                    	OR	AL,BL
 11308                                  	;mov	[si+19h],al
 11309 000026F3 884419                  	MOV	[SI+fcb_l_drive],AL
 11310                                  
 11311 000026F6 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; get lru count
 11312 000026FA 40                      	INC	AX
 11313                                  	;mov	[es:di+15h],ax
 11314 000026FB 26894515                	MOV	[ES:DI+sf_LRU],AX
 11315 000026FF 7506                    	JNZ	short SimpleStuff
 11316                                  	
 11317                                  	; lru flag overflowed. Run through all FCB sfts and adjust:  
 11318                                  	; LRU < 8000H get set to 0. Others -= 8000h.  This LRU = 8000h
 11319                                  	
 11320                                  	;mov	bx,15h
 11321 00002701 BB1500                  	MOV	BX,SF_ENTRY.sf_position
 11322 00002704 E80500                  	call	ResetLRU
 11323                                  
 11324                                  	; Set new LRU to AX
 11325                                  SimpleStuff:
 11326 00002707 36A3[1000]              	MOV	[SS:FCBLRU],AX
 11327 0000270B C3                      	retn
 11328                                  
 11329                                  ;Break	<ResetLRU - reset overflowed lru counts>
 11330                                  ;----------------------------------------------------------------------------
 11331                                  ;
 11332                                  ;   ResetLRU - during lru updates, we may wrap at 64K. We must walk the
 11333                                  ;   entire set of SFTs and subtract 8000h from their lru counts and truncate
 11334                                  ;   at 0.
 11335                                  ;
 11336                                  ;   Inputs:	BX is offset into SFT field where lru firld is kept
 11337                                  ;		ES:DI point to SFT currently being updated
 11338                                  ;   Outputs:	All FCB SFTs have their lru fields truncated
 11339                                  ;		AX has 8000h
 11340                                  ;   Registers modified: none
 11341                                  ;
 11342                                  ;----------------------------------------------------------------------------
 11343                                  ;
 11344                                  	; 24/07/2019 - Retro DOS v3.2
 11345                                  ResetLRU:
 11346                                  
 11347                                  	; ResetLRU is only called from fcbio.asm. So SS can be assumed to be 
 11348                                  	; DOSDATA
 11349                                  
 11350 0000270C B80080                  	MOV	AX,8000h
 11351 0000270F 06                      	push	es
 11352 00002710 57                      	push	di
 11353 00002711 2EC43E[4000]            	LES	DI,[CS:SFTFCB]		; get pointer to head
 11354                                  	;LES	DI,[SS:SFTFCB] ; MSDOS 6.0
 11355                                  	;mov	cx,[es:di+4]
 11356 00002716 268B4D04                	MOV	CX,[ES:DI+SFT.SFCount]
 11357                                  	;lea	di,[di+6]
 11358 0000271A 8D7D06                  	LEA	DI,[DI+SFT.SFTable] 	; point at table
 11359                                  ovScan:
 11360 0000271D 262901                  	SUB	[ES:DI+BX],AX		; decrement lru count
 11361 00002720 7703                    	JA	short ovLoop
 11362 00002722 268901                  	MOV	[ES:DI+BX],AX		; truncate at 0
 11363                                  ovLoop:
 11364                                  	;;add	di,53	; MSDOS 3.3
 11365                                  	;add	di,59	; MSDOS 6.0
 11366 00002725 83C73B                  	ADD	DI,SF_ENTRY.size	; advance to next
 11367 00002728 E2F3                    	LOOP	ovScan
 11368 0000272A 5F                      	pop	di
 11369 0000272B 07                      	pop	es
 11370 0000272C 268901                  	MOV	[ES:DI+BX],AX
 11371 0000272F C3                      	retn
 11372                                  
 11373                                  ; 24/07/2019 - Retro DOS v3.2
 11374                                  
 11375                                  ;IF  0  ; We dont need this routine any more.
 11376                                  ;
 11377                                  ;Break	<SetOpenAge - update the open age of a SFT>
 11378                                  ;----------------------------------------------------------------------------
 11379                                  ;
 11380                                  ;   SetOpenAge - In order to maintain the first N open files in the FCB cache,
 11381                                  ;   we keep the 'open age' or an LRU count based on opens. We update the
 11382                                  ;   count here and fill in the appropriate field.
 11383                                  ;
 11384                                  ;   Inputs:	ES:DI point to SFT
 11385                                  ;   Outputs:	ES:DI has the open age field filled in.
 11386                                  ;		If open age has wraparound, we will have subtracted 8000h
 11387                                  ;		    from all open ages.
 11388                                  ;   Registers modified: AX
 11389                                  ;
 11390                                  ;----------------------------------------------------------------------------
 11391                                  ;
 11392                                  ;SetOpenAge:
 11393                                  ;	; 20/07/2018 - Retro DOS v3.0
 11394                                  ;	; MSDOS 3.3 - IBMDOS.COM, Offset 2597h 
 11395                                  ;	; (& MSDOS 6.0, FCBIO.ASM)
 11396                                  ;
 11397                                  ;	; SetOpenAge is called from fcbio2.asm. SS can be assumed to be valid.
 11398                                  ;
 11399                                  ;	MOV	AX,[CS:OpenLRU]	; SS override
 11400                                  ;	INC	AX
 11401                                  ;	;mov	[es:di+17h],ax
 11402                                  ;	MOV	[ES:DI+sf_OpenAge],AX
 11403                                  ;	JNZ	short SetDone
 11404                                  ;	;mov	bx,17h
 11405                                  ;	MOV	BX,SF_ENTRY.sf_position+2 ; mov bx,sf_OpenAge
 11406                                  ;	call	ResetLRU
 11407                                  ;SetDone:
 11408                                  ;	MOV	[CS:OpenLRU],AX
 11409                                  ;	retn
 11410                                  ;
 11411                                  ;ENDIF	; SetOpenAge no longer needed
 11412                                  
 11413                                  ; 24/07/2019 - Retro DOS v3.2
 11414                                  
 11415                                  ; LRUFCB for MSDOS 6.0 !
 11416                                  
 11417                                  ;Break	<LRUFCB - perform LRU on FCB sfts>
 11418                                  ;----------------------------------------------------------------------------
 11419                                  ;
 11420                                  ;   LRUFCB - find LRU fcb in cache. Set ThisSFT and return it. We preserve
 11421                                  ;	the first keepcount sfts if they are network sfts or if sharing is
 11422                                  ;	loaded.  If carry is set then NO BLASTING is NECESSARY.
 11423                                  ;
 11424                                  ;   Inputs:	none
 11425                                  ;   Outputs:	ES:DI point to SFT
 11426                                  ;		ThisSFT points to SFT
 11427                                  ;		SFT is zeroed
 11428                                  ;		Carry set of closes failed
 11429                                  ;   Registers modified: none
 11430                                  ;
 11431                                  ;----------------------------------------------------------------------------
 11432                                  ;
 11433                                  ; MSDOS 6.0
 11434                                  ;IF 0	; rewritten this routine
 11435                                  ;
 11436                                  ;LRUFCB: ; MSDOS 3.3 - IBMDOS.COM (1987) - Offset 25ADh
 11437                                  ;	call	save_world
 11438                                  ;	
 11439                                  ; Find nth oldest NET/SHARE FCB. We want to find its age for the second scan
 11440                                  ; to find the lease recently used one that is younger than the open age.  We
 11441                                  ; operate be scanning the list n times finding the least age that is greater
 11442                                  ; or equal to the previous minimum age.
 11443                                  ;
 11444                                  ;   BP is the count of times we need to go through this loop.
 11445                                  ;   AX is the current acceptable minimum age to consider
 11446                                  ;
 11447                                  ;	mov	bp,[CS:KEEPCOUNT]	; k = keepcount;
 11448                                  ;	XOR	AX,AX			; low = 0;
 11449                                  ;
 11450                                  ; If we've scanned the table n times, then we are done.
 11451                                  ;
 11452                                  ;lru1:
 11453                                  ;	CMP	bp,0			; while (k--) {
 11454                                  ;	JZ	short lru75
 11455                                  ;	DEC	bp
 11456                                  ;
 11457                                  ; Set up for scan.
 11458                                  ;
 11459                                  ;   AX is the minimum age for consideration
 11460                                  ;   BX is the minimum age found during the scan
 11461                                  ;   SI is the position of the entry that corresponds to BX
 11462                                  ;
 11463                                  ;	MOV	BX,-1			;     min = 0xffff;
 11464                                  ;	MOV	si,BX			;     pos = 0xffff;
 11465                                  ;	LES	DI,[CS:SFTFCB]		;     for (CX=FCBCount; CX>0; CX--)
 11466                                  ;	;mov	cx,[es:di+4]
 11467                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 11468                                  ;	;lea	di,[di+6]
 11469                                  ;	LEA	DI,[DI+SFT.SFTable]
 11470                                  ;
 11471                                  ; Innermost loop.  If the current entry is free, then we are done.  Or, if the
 11472                                  ; current entry is busy (indicating a previous aborted allocation), then we
 11473                                  ; are done.  In both cases, we use the found entry.
 11474                                  ;
 11475                                  ;lru2:
 11476                                  ;	cmp	word [es:di],0
 11477                                  ;	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0
 11478                                  ;	jz	short lru25
 11479                                  ;	;cmp	word [es:di],-1
 11480                                  ;	;cmp	word [es:di+SFT_ENTRY.sf_ref_count],sf_busy
 11481                                  ;	cmp	word [es:di],sf_busy
 11482                                  ;	jnz	short lru3
 11483                                  ;
 11484                                  ; The entry is usable without further scan.  Go and use it.
 11485                                  ;
 11486                                  ;lru25:
 11487                                  ;	MOV	si,DI			;	      pos = i;
 11488                                  ;	JMP	short lru11		;	      goto got;
 11489                                  ;
 11490                                  ; See if the entry is for the network or for the sharer.
 11491                                  ;
 11492                                  ;  If for the sharer or network then
 11493                                  ;	if the age < current minimum AND >= allowed minimum then
 11494                                  ;	    this entry becomes current minimum
 11495                                  ;
 11496                                  ;lru3:
 11497                                  ;	;test	word [es:di+5],8000h
 11498                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet 
 11499                                  ;					;	  if (!net[i]
 11500                                  ;	JNZ	short lru35
 11501                                  ;if installed
 11502                                  ;	call	CheckShare		;		&& !sharing)
 11503                                  ;	JZ	short lru5		;	  else
 11504                                  ;ENDIF
 11505                                  ;
 11506                                  ; This SFT is for the net or is for the sharer. See if it less than the
 11507                                  ; current minimum.
 11508                                  ;
 11509                                  ;lru35:
 11510                                  ;	;mov	dx,[es:di+17h]
 11511                                  ;	MOV	DX,[ES:DI+sf_OpenAge]
 11512                                  ;	CMP	DX,AX			;	  if (age[i] >= low &&
 11513                                  ;	JB	short lru5
 11514                                  ;	CMP	DX,BX
 11515                                  ;	JAE	short lru5		;	      age[i] < min) {
 11516                                  ;
 11517                                  ; entry is new minimum.  Remember his age.
 11518                                  ;
 11519                                  ;	mov	bx,DX			;	      min = age[i];
 11520                                  ;	mov	si,di			;	      pos = i;
 11521                                  ;
 11522                                  ; End of loop.	gp back for more
 11523                                  ;
 11524                                  ;lru5:
 11525                                  ;	;add	di,53
 11526                                  ;	add	di,SF_ENTRY.size
 11527                                  ;	loop	lru2			;	      }
 11528                                  ;
 11529                                  ; The scan is complete. If we have successfully found a new minimum (pos != -1)
 11530                                  ; set then threshold value to this new minimum + 1. Otherwise, the scan is
 11531                                  ; complete.  Go find LRU.
 11532                                  ;
 11533                                  ;lru6:	
 11534                                  ;	cmp	si,-1			; position not -1?
 11535                                  ;	jz	short lru75		; no, done with everything
 11536                                  ;	lea	ax,[bx+1]		; set new threshold age
 11537                                  ;	jmp	short lru1		; go and loop for more
 11538                                  ;lru65:	
 11539                                  ;	stc
 11540                                  ;	jmp	short LRUDead		;	  return -1;
 11541                                  ;
 11542                                  ; Main loop is done. We have AX being the age+1 of the nth oldest sharer or
 11543                                  ; network entry. We now make a second pass through to find the LRU entry
 11544                                  ; that is local-no-share or has age >= AX
 11545                                  ;
 11546                                  ;lru75:
 11547                                  ;	mov	bx,-1			; min = 0xffff;
 11548                                  ;	mov	si,bx			; pos = 0xffff;
 11549                                  ;	LES	DI,[CS:SFTFCB]		; for (CX=FCBCount; CX>0; CX--)
 11550                                  ;	;mov	cx,[es:di+4]
 11551                                  ;	MOV	CX,[ES:DI+SFT.SFCount]
 11552                                  ;	;lea	di,[di+6]
 11553                                  ;	LEA	DI,[DI+SFT.SFTable]
 11554                                  ;
 11555                                  ; If this is is local-no-share then go check for LRU else if age >= threshold
 11556                                  ; then check for lru.
 11557                                  ;
 11558                                  ;lru8:
 11559                                  ;	;test	word [es:di+5],8000h
 11560                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11561                                  ;	jnz	short lru85		; is for network, go check age
 11562                                  ;	call	CheckShare		; sharer here?
 11563                                  ;	jz	short lru86		; no, go check lru
 11564                                  ;
 11565                                  ; Network or sharer.  Check age
 11566                                  ;
 11567                                  ;lru85:
 11568                                  ;	;cmp	[es:di+17h],ax
 11569                                  ;	cmp	[es:di+sf_OpenAge],ax
 11570                                  ;	jb	short lru9		; age is before threshold, skip it
 11571                                  ;
 11572                                  ; Check LRU
 11573                                  ;
 11574                                  ;lru86:
 11575                                  ;	;cmp	[es:di+15h],bx
 11576                                  ;	cmp	[es:di+sf_LRU],bx	; is LRU less than current LRU?
 11577                                  ;	jae	short lru9		; no, skip this
 11578                                  ;	mov	si,di			; remember position
 11579                                  ;	;mov	bx,[es:di+15h]
 11580                                  ;	mov	bx,[es:di+sf_LRU]	; remember new minimum LRU
 11581                                  ;
 11582                                  ; Done with this entry, go back for more.
 11583                                  ;
 11584                                  ;lru9:
 11585                                  ;	;add	di, 53
 11586                                  ;	add	di,SF_ENTRY.size
 11587                                  ;	loop	lru8
 11588                                  ;
 11589                                  ; Scan is complete. If we found NOTHING that satisfied us then we bomb
 11590                                  ; out. The conditions here are:
 11591                                  ;
 11592                                  ;  No local-no-shares AND all net/share entries are older than threshold
 11593                                  ;
 11594                                  ;lru10:
 11595                                  ;	cmp	si,-1			; if no one f
 11596                                  ;	jz	short lru65		;     return -1;
 11597                                  ;lru11:
 11598                                  ;	mov	di,si
 11599                                  ;	MOV	[CS:THISSFT],DI		; set thissft
 11600                                  ;	MOV	[CS:THISSFT+2],ES
 11601                                  ;
 11602                                  ; If we have sharing or thisSFT is a net sft, then close it until ref count
 11603                                  ; is 0.
 11604                                  ;
 11605                                  ;	;test	word [es:di+5],8000h
 11606                                  ;	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 11607                                  ;	JNZ	short LRUClose
 11608                                  ;IF INSTALLED
 11609                                  ;	call	CheckShare
 11610                                  ;	JZ	short LRUDone
 11611                                  ;ENDIF
 11612                                  ;
 11613                                  ; Repeat close until ref count is 0
 11614                                  ;
 11615                                  ;LRUClose:
 11616                                  ;	push	ss
 11617                                  ;	pop	ds
 11618                                  ;	LES	DI,[THISSFT]
 11619                                  ;	cmp     word [es:di],0
 11620                                  ;	;CMP	word [ES:DI+SFT.sf_ref_count],0 ; is ref count still <> 0?
 11621                                  ;	JZ	short LRUDone 		; nope, all done
 11622                                  ;	call	DOS_CLOSE
 11623                                  ;	jnc	short LRUClose		; no error => clean up
 11624                                  ;	;cmp	al,6
 11625                                  ;	cmp	al,error_invalid_handle
 11626                                  ;	jz	short LRUClose
 11627                                  ;	stc
 11628                                  ;	JMP	short LRUDead
 11629                                  ;LRUDone:
 11630                                  ;	XOR	AL,AL
 11631                                  ;	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 11632                                  ;
 11633                                  ;LRUDead:
 11634                                  ;	call	restore_world
 11635                                  ;	LES     DI,[CS:THISSFT]
 11636                                  ;	jnc	short LRUFCB_retn
 11637                                  ;LRUFCB_err:
 11638                                  ;	; mov	al, 23h	
 11639                                  ;	MOV	AL,error_FCB_unavailable
 11640                                  ;LRUFCB_retn:	
 11641                                  ;	retn:
 11642                                  ;
 11643                                  ;ENDIF	; LRUFCB has been rewritten below.
 11644                                  
 11645                                  ; 24/07/2019 - Retro DOS v3.2
 11646                                  
 11647                                  ; 17/05/2019 - Retro DOS v4.0
 11648                                  ; LRUFCB for MSDOS 6.0 !
 11649                                  ;----------------------------------------------------------------------------
 11650                                  ;
 11651                                  ; LruFCB -- allocate the LRU SFT from the SFT Table. The LRU scheme
 11652                                  ; maintains separate counts for net/Share and local SFTs. We allocate a 
 11653                                  ; net/Share SFT only if we do not find a local SFT. This helps keep
 11654                                  ; net/Share SFTs which cannot be regenerated for as long as possible. We
 11655                                  ; optimize regeneration operations by keeping track of the current local
 11656                                  ; SFT. This avoids scanning of the SFTs as long as we have at least one 
 11657                                  ; local SFT in the SFT Block.
 11658                                  ;
 11659                                  ; Inputs: al = 0 => Regenerate SFT operation
 11660                                  ;	    = 1 => Allocate new SFT for Open/Create
 11661                                  ;
 11662                                  ; Outputs: Carry clear
 11663                                  ;	 	es:di = Address of allocated SFT
 11664                                  ;	  	ThisSFT = Address of allocated SFT
 11665                                  ;
 11666                                  ;	  carry set if closes of net/Share files failed 
 11667                                  ;		al = error_FCB_unavailable
 11668                                  ;
 11669                                  ; Registers affected: None
 11670                                  ;
 11671                                  ;----------------------------------------------------------------------------
 11672                                  
 11673                                  ;LruFCB	PROC	NEAR
 11674                                  LRUFCB:
 11675                                  	; 17/05/2019 - Retro DOS v4.0
 11676                                  	; DOSCODE:5805h (MSDOS 6.21, MSDOS.SYS)
 11677                                  
 11678                                  	;push	es	; * (MSDOS 6.21)
 11679                                  	
 11680 00002730 E803EF                  	call	save_world
 11681                                  	
 11682                                  	; MSDOS 6.0
 11683                                  	;;getdseg <ds>		;ds = DOSDATA
 11684                                  	;mov	ds,[cs:DosDSeg]
 11685                                  
 11686                                  	; 24/07/2019 - Retro DOS v3.2
 11687 00002733 0E                      	push	cs
 11688 00002734 1F                      	pop	ds
 11689                                  
 11690 00002735 08C0                    	or	al,al		;Check if regenerate allocation
 11691 00002737 751A                    	jnz	short lru1	;Try to find SFT to use
 11692                                  
 11693                                  	; This is a regen call. If LocalSFT contains the address of a valid 
 11694                                  	; local SFT, just return that SFT to reuse
 11695                                  
 11696 00002739 8B3E[C50F]              	mov	di,[LocalSFT]
 11697 0000273D 0B3E[C70F]              	or	di,[LocalSFT+2]	;is address == 0?
 11698 00002741 7410                    	jz	short lru1	;invalid local SFT, find one
 11699                                  
 11700                                  	; We have found a valid local SFT. Recycle this SFT
 11701                                  
 11702 00002743 C43E[C50F]              	les	di,[LocalSFT]
 11703                                  
 11704                                  gotlocalSFT:
 11705 00002747 893E[5A05]              	mov	[THISSFT],di
 11706 0000274B 8C06[5C05]              	mov	[THISSFT+2],es
 11707 0000274F F8                      	clc
 11708 00002750 E9AE00                  	jmp	LRUDone		;clear up SFT and return
 11709                                  
 11710                                  lru1:
 11711 00002753 C43E[4000]              	les	di,[SFTFCB]	;es:di = SF Table for FCBs
 11712                                  	;mov	cx,[es:di+4]
 11713 00002757 268B4D04                	mov	cx,[es:di+SFT.SFCount]	;cx = number of SFTs
 11714                                  	;lea	di,[di+6]
 11715 0000275B 8D7D06                  	lea	di,[di+SFT.SFTable]	;es:di = first SFT
 11716                                  
 11717                                  	; We scan through all the SFTs scanning for a free one. It also 
 11718                                  	; remembers the LRU SFT for net/Share SFTs and local SFTs separately. 
 11719                                  	; bx = min. LRU for local SFTs
 11720                                  	; si = pos. of local SFT with min. LRU
 11721                                  	; dx = min. LRU for net/Share SFTs
 11722                                  	; bp = pos. of net/Share SFT with min. LRU
 11723                                  
 11724 0000275E BBFFFF                  	mov	bx,-1		; init. to 0xffff ( max. LRU value )
 11725 00002761 89DE                    	mov	si,bx
 11726 00002763 89DA                    	mov	dx,bx
 11727 00002765 89DD                    	mov	bp,bx
 11728                                  
 11729                                  findSFT:
 11730                                  	;See if this SFT is a free one. If so, return it
 11731 00002767 26830D00                	or	word [es:di],0
 11732                                  	;or	word [es:di+SF_ENTRY.sf_ref_count],0 ;reference count = 0 ?
 11733 0000276B 744E                    	jz	short gotSFT	;yes, SFT is free
 11734                                  	;;cmp	word [es:di],-1
 11735                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy ;Is it busy?
 11736 0000276D 26833DFF                	cmp	word [es:di],sf_busy ; -1 
 11737 00002771 7448                    	jz	short gotSFT	;no, can use it
 11738                                  
 11739                                  	; Check if this SFT is local and store its address in LocalSFT. Can be 
 11740                                  	; used for a later regen.
 11741                                  
 11742                                  	;test	word [es:di+5],8000h
 11743 00002773 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet ; network SFT?
 11744 00002779 7532                    	jnz	short lru5	;yes, get net/Share LRU
 11745                                  
 11746                                  ;IF installed
 11747 0000277B E8E84E                  	call	CheckShare	;Share present?
 11748                                  ;ENDIF
 11749 0000277E 752D                    	jnz	short lru5	;yes, get net/Share LRU
 11750                                  
 11751                                  	;Local SFT, register its address
 11752                                  
 11753                                  	; !!HACK!!!
 11754                                  	; There is a slightly dirty hack out here in a desperate bid to save  
 11755                                  	; code space. There is similar code duplicated at label 'gotSFT'. We 
 11756                                  	; enter from there if al = 0, update the LocalSFT variable, and since 
 11757                                  	; al = 0, we jump out of the loop to the exit point. I have commented 
 11758                                  	; out the code that previously existed at label 'gotSFT'
 11759                                  
 11760                                  hackpoint:
 11761 00002780 893E[C50F]              	mov	[LocalSFT],di
 11762 00002784 8C06[C70F]              	mov	[LocalSFT+2],es	;store local SFT address
 11763                                  
 11764 00002788 08C0                    	or	al,al		;Is operation = REGEN?
 11765 0000278A 74BB                    	jz	short gotlocalSFT ;yes, return this SFT for reuse
 11766                                  
 11767                                  	;Get LRU for local files
 11768                                  	
 11769                                  	;cmp	[es:di+15h],bx
 11770 0000278C 26395D15                	cmp	[es:di+sf_LRU],bx ;SFT.LRU < min?
 11771 00002790 7306                    	jae	short lru4	;no, skip 
 11772                                  
 11773                                  	;mov	bx,[es:di+15h]
 11774 00002792 268B5D15                	mov	bx,[es:di+sf_LRU] ;yes, store new minimum
 11775 00002796 89FE                    	mov	si,di		;store SFT position
 11776                                  
 11777                                  lru4:
 11778                                  	;add	di,59
 11779 00002798 83C73B                  	add	di,SF_ENTRY.size ;go to next SFT
 11780 0000279B E2CA                    	loop	findSFT
 11781                                  
 11782                                  	; Check whether we got a net/Share or local SFT. If local SFT 
 11783                                  	; available, we will reuse it instead of net/Share LRU
 11784                                  
 11785 0000279D 89F7                    	mov	di,si
 11786 0000279F 83FEFF                  	cmp	si,-1		;local SFT available?
 11787 000027A2 7517                    	jnz	short gotSFT	;yes, return it
 11788                                  
 11789                                  	;No local SFT, see if we got a net/Share SFT
 11790                                  
 11791 000027A4 89EF                    	mov	di,bp
 11792 000027A6 83FDFF                  	cmp	bp,-1		;net/Share SFT available?
 11793 000027A9 7530                    	jnz	short gotnetSFT	;yes, return it
 11794                                  noSFT:
 11795                                  	; NB: This error should never occur. We always must have an LRU SFT. 
 11796                                  	; This error can occur only if the SFT has been corrupted or the LRU 
 11797                                  	; count is not maintained properly.
 11798                                  
 11799 000027AB EB51                    	jmp	short errorbadSFT ;error, no FCB available.
 11800                                  
 11801                                  	; Handle the LRU for net/Share SFTs
 11802                                  lru5:
 11803                                  	;cmp	[es:di+15h],dx
 11804 000027AD 26395515                	cmp	[es:di+sf_LRU],dx ;SFT.LRU < min?
 11805 000027B1 73E5                    	jae	short lru4	;no, skip 
 11806                                  
 11807                                  	;mov	dx,[es:di+15h]
 11808 000027B3 268B5515                	mov	dx,[es:di+sf_LRU] ;yes, store new minimum
 11809                                  
 11810 000027B7 89FD                    	mov	bp,di		;store SFT position
 11811 000027B9 EBDD                    	jmp	short lru4	;continue with next SFT
 11812                                  
 11813                                  gotSFT:
 11814 000027BB 08C0                    	or	al,al
 11815 000027BD 74C1                    	jz	short hackpoint	;save es:di in LocalSFT
 11816                                  
 11817                                  	; HACK!!!
 11818                                  	; The code here differs from the code at 'hackpoint' only in the 
 11819                                  	; order of the check for al. If al = 0, we can jump to 'hackpoint' 
 11820                                  	; and then from there jump out to 'gotlocalSFT'. The original code 
 11821                                  	; has been commented out below and replaced by the code just above.
 11822                                  
 11823                                  ;If regen, then this SFT can be registered as a local one ( even if free ).
 11824                                  ;
 11825                                  ;	or	al,al		  ;Regen?
 11826                                  ;	jnz	short notlocaluse ;yes, register it and return
 11827                                  ;
 11828                                  ;Register this SFT as a local one
 11829                                  ;
 11830                                  ;	mov	[LocalSFT],di
 11831                                  ;	mov	[LocalSFT+2],es
 11832                                  ;	jmp	gotlocalSFT	;return to caller
 11833                                  ;
 11834                                  ;notlocaluse:
 11835                                  
 11836                                  	; The caller is probably going to use this SFT for a net/Share file. 
 11837                                  	; We will come here only on a Open/Create when the caller($FCB_OPEN) 
 11838                                  	; does not really know whether it is a local file or not. We 
 11839                                  	; invalidate LocalSFT if the SFT we are going to use was previously 
 11840                                  	; registered as a local SFT that can be recycled.
 11841                                  
 11842 000027BF 8CC0                    	mov	ax,es
 11843 000027C1 393E[C50F]              	cmp	[LocalSFT],di		;Offset same?
 11844 000027C5 7506                    	jne	short notinvalid
 11845 000027C7 3906[C70F]              	cmp	[LocalSFT+2],ax		;Segments same?
 11846 000027CB 7403                    	je	short zerolocalSFT	;no, no need to invalidate
 11847                                  notinvalid:
 11848 000027CD E977FF                  	jmp	gotlocalSFT
 11849                                  
 11850                                  	; The SFT we are going to use was registered in the LocalSFT variable. 
 11851                                  	; Invalidate this variable i.e LocalSFT = NULL
 11852                                  
 11853                                  zerolocalSFT:
 11854 000027D0 31C0                    	xor	ax,ax ; 0
 11855 000027D2 A3[C50F]                	mov	[LocalSFT],ax
 11856 000027D5 A3[C70F]                	mov	[LocalSFT+2],ax
 11857                                  
 11858 000027D8 E96CFF                  	jmp	gotlocalSFT
 11859                                  
 11860                                  gotnetSFT:
 11861                                  	; We have an SFT that is currently net/Share. If it is going to be 
 11862                                  	; used for a regen, we know it has to be a local SFT. Update the 
 11863                                  	; LocalSFT variable
 11864                                  
 11865 000027DB 08C0                    	or	al,al
 11866 000027DD 7508                    	jnz	short closenet
 11867                                  
 11868 000027DF 893E[C50F]              	mov	[LocalSFT],di
 11869 000027E3 8C06[C70F]              	mov	[LocalSFT+2],es	;store local SFT address
 11870                                  closenet:
 11871 000027E7 893E[5A05]              	mov	[THISSFT],di	; set thissft
 11872 000027EB 8C06[5C05]              	mov	[THISSFT+2],es	
 11873                                  
 11874                                  	; If we have sharing or thisSFT is a net sft, then close it until ref 
 11875                                  	; count is 0.
 11876                                  	; NB: We come here only if it is a net/Share SFT that is going to be 
 11877                                  	; recycled -- no need to check for this.
 11878                                  
 11879                                  LRUClose:
 11880 000027EF 26833D00                	cmp	word [es:di],0
 11881                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],0 ; is ref count still <> 0?
 11882 000027F3 740C                    	jz	short LRUDone	; nope, all done
 11883                                  
 11884 000027F5 E83913                  	call	DOS_CLOSE
 11885 000027F8 73F5                    	jnc	short LRUClose	; no error => clean up
 11886                                  
 11887                                  	; Bugbug: I dont know why we are trying to close after we get an 
 11888                                  	; error closing. Seems like we could have a potential infinite loop  
 11889                                  	; here. This has to be verified.
 11890                                  
 11891 000027FA 3C06                    	cmp	al,error_invalid_handle ; 6
 11892 000027FC 74F1                    	je	short LRUClose
 11893                                  errorbadSFT:
 11894 000027FE F9                      	stc
 11895 000027FF EB05                    	JMP	short LRUDead
 11896                                  LRUDone:
 11897 00002801 30C0                    	XOR	AL,AL
 11898 00002803 E80801                  	call	BlastSFT		; fill SFT with 0 (AL), 'C' cleared
 11899                                  
 11900                                  LRUDead:
 11901 00002806 E81AEE                  	call	restore_world		; use macro
 11902                                  	
 11903                                  	;pop	es ; * (MSDOS 6.21)
 11904                                  
 11905                                  	; MSDOS 6.0
 11906                                  	;getdseg <es>
 11907                                  	;mov	es,[cs:DosDSeg]
 11908                                  
 11909                                  	;les	di,[es:THISSFT]		;es:di points at allocated SFT
 11910                                  
 11911                                  	; 24/07/2019 - Retro DOS v3.2
 11912 00002809 2EC43E[5A05]            	les	di,[cs:THISSFT]		;es:di points at allocated SFT
 11913                                  
 11914                                  	;;retnc
 11915                                  	;jc	short LruFCB_err
 11916                                  	;retn
 11917                                  
 11918 0000280E 7302                    	jnc	short LruFCB_retn
 11919                                  		
 11920                                  LruFCB_err:
 11921 00002810 B023                    	MOV	AL,error_FCB_unavailable ; 23h
 11922                                  LruFCB_retn:
 11923 00002812 C3                      	retn
 11924                                  	
 11925                                  ;LruFCB	ENDP
 11926                                  
 11927                                  ;ENDIF
 11928                                  
 11929                                  ; 24/07/2019 - Retro DOS v3.2
 11930                                  
 11931                                  ; 17/05/2019 - Retro DOS v4.0
 11932                                  
 11933                                  ; DOSCODE:58F3h (MSDOS 6.21, MSDOS.SYS)
 11934                                  
 11935                                  ; --------------------------------------------------------------------------
 11936                                  ;**** RegenCopyName -- This function copies the filename from the FCB to
 11937                                  ; SFT and also to DOS local buffers. There was duplicate code in FCBRegen
 11938                                  ; to copy the name to different destinations
 11939                                  ;
 11940                                  ; Inputs: ds:si = source string
 11941                                  ;	 es:di = destination string
 11942                                  ;	 cx = length of string
 11943                                  ;
 11944                                  ; Outputs: String copied to destination
 11945                                  ;
 11946                                  ; Registers affected: cx,di,si
 11947                                  ; --------------------------------------------------------------------------
 11948                                  
 11949                                  RegenCopyName:
 11950                                  CopyName:
 11951 00002813 AC                      	lodsb			;load character
 11952 00002814 E8D830                  	call	UCase		; convert char to upper case
 11953                                  StuffChar2:
 11954 00002817 AA                      	STOSB			;store converted character
 11955 00002818 E2F9                    	LOOP	CopyName	;
 11956                                  DoneName:
 11957 0000281A C3                      	retn
 11958                                  
 11959                                  ; --------------------------------------------------------------------------
 11960                                  
 11961                                  FCBRegen:
 11962                                  	; called from SFTFromFCB. SS already DOSDATA
 11963                                  
 11964                                  	; General data filling. Mode is sf_isFCB + open_for_both, date/time 
 11965                                  	; we do not fill, size we do no fill, position we do not fill,
 11966                                  	; bit 14 of flags = TRUE, other bits = FALSE
 11967                                  
 11968                                  	;mov	al,[si+19h]
 11969 0000281B 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 11970                                  
 11971                                  	; We discriminate based on the first two bits in the reserved field.
 11972                                  	
 11973                                  	;test	al,80h
 11974 0000281E A880                    	test	AL,FCBSPECIAL		; check for no sharing test
 11975 00002820 741C                    	JZ	short RegenNoSharing	; yes, go regen from no sharing
 11976                                  
 11977                                  	; The FCB is for a network or a sharing based system. At this point 
 11978                                  	; we have already closed the SFT for this guy and reconnection is 
 11979                                  	; impossible.
 11980                                  	;
 11981                                  	; Remember that he may have given us a FCB with bogus information in
 11982                                  	; it. Check to see if sharing is present or if the redir is present.
 11983                                  	; If either is around, presume that we have cycled out the FCB and 
 11984                                  	; give the hard error. Otherwise, just return with carry set.
 11985                                  
 11986 00002822 E8414E                  	call	CheckShare		; test for sharer
 11987 00002825 7509                    	JNZ	short RegenFail		; yep, fail this.
 11988                                  	
 11989                                  	;mov	ax,1100h
 11990 00002827 B80011                  	MOV	AX,MultNET<<8		; install check on multnet
 11991 0000282A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - INSTALLATION CHECK
 11992                                  			; Return: AL = 00h  not installed, OK to install
 11993                                  			; 01h  not installed, not OK to install
 11994                                  			; FFh  installed
 11995 0000282C 08C0                    	OR	AL,AL			; is it there?
 11996 0000282E 740C                    	JZ	short RegenDead		; no, just fail the operation
 11997                                  RegenFail:
 11998                                  	; 17/05/2019 - Retro DOS v4.0
 11999                                  	;MOV	AX,[CS:USER_IN_AX]	; SS override
 12000 00002830 36A1[0403]              	mov	ax,[SS:USER_IN_AX] ; MSDOS 6.0
 12001                                  
 12002                                  	;cmp	ah,10h
 12003 00002834 80FC10                  	cmp	AH,FCB_CLOSE
 12004 00002837 7403                    	jz	short RegenDead
 12005 00002839 E89901                  	call	FCBHardErr		; massive hard error.
 12006                                  RegenDead:
 12007 0000283C F9                      	STC				; carry set
 12008                                  FCBRegen_retn:
 12009 0000283D C3                      	retn
 12010                                  
 12011                                  	; Local FCB without sharing. Check to see if sharing is loaded. If 
 12012                                  	; so fail the operation.
 12013                                  
 12014                                  RegenNoSharing:
 12015 0000283E E8254E                  	call	CheckShare		; Sharing around?
 12016 00002841 75ED                    	JNZ	short RegenFail
 12017                                  	
 12018                                  	; Find an SFT for this guy.
 12019                                  	
 12020                                  	; 17/05/2019 - Retro DOS v4.0
 12021                                  
 12022                                  	; MSDOS 3.3
 12023                                  	;call	LRUFCB
 12024                                  	;jc	short FCBRegen_retn
 12025                                  	
 12026                                  	; MSDOS 6.0
 12027 00002843 50                      	push	ax
 12028 00002844 B000                    	mov	al,0			;indicate it is a regen operation
 12029 00002846 E8E7FE                  	call	LRUFCB
 12030 00002849 58                      	pop	ax
 12031 0000284A 72F1                    	jc	short FCBRegen_retn
 12032                                  
 12033                                  	;mov	word [es:di+2],8002h
 12034 0000284C 26C745020280            	MOV	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB+open_for_both+SHARING_COMPAT
 12035 00002852 243F                    	AND	AL,3Fh			; get drive number for flags
 12036 00002854 98                      	CBW
 12037                                  	;or	ax,4000h
 12038 00002855 0D0040                  	OR	AX,sf_close_nodate	; normal FCB operation
 12039                                  
 12040                                  	; The bits field consists of the upper two bits (dirty and device) 
 12041                                  	; from the SFT and the low 4 bits from the open mode.
 12042                                  
 12043                                  	;mov	cl,[si+1Ah]
 12044 00002858 8A4C1A                  	MOV	CL,[SI+fcb_nsl_bits]	; stick in dirty bits.
 12045 0000285B 88CD                    	MOV	CH,CL
 12046 0000285D 80E5C0                  	AND	CH,0C0h 		; mask off the dirty/device bits
 12047 00002860 08E8                    	OR	AL,CH
 12048                                  	;and	cl,0Fh
 12049 00002862 80E10F                  	AND	CL,access_mask		; get the mode bits
 12050                                  	;mov	[es:di+2],cl
 12051 00002865 26884D02                	MOV	[ES:DI+SF_ENTRY.sf_mode],CL
 12052                                  	;mov	[es:di+5],ax
 12053 00002869 26894505                	MOV	[ES:DI+SF_ENTRY.sf_flags],AX ; initial flags
 12054                                  	;MOV	AX,[CS:PROC_ID]		; SS override
 12055 0000286D 36A1[0603]              	mov	ax,[ss:PROC_ID] ; MSDOS 6.0
 12056                                  	;mov	[es:di+31h],ax
 12057 00002871 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX
 12058 00002875 1E                      	push	ds
 12059 00002876 56                      	push	si
 12060 00002877 06                      	push	es
 12061 00002878 57                      	push	di
 12062 00002879 16                      	push	ss
 12063 0000287A 07                      	pop	es
 12064 0000287B BF[0805]                	MOV	DI,NAME1		; NAME1 is in DOSDATA
 12065                                  
 12066 0000287E B90800                  	MOV	CX,8
 12067 00002881 46                      	INC	SI			; Skip past drive byte to name in FCB
 12068                                  
 12069                                  	; MSDOS 3.3
 12070                                  ;RegenCopyName:
 12071                                  	;lodsb
 12072                                  	;call	UCase
 12073                                  	;stosb
 12074                                  	;loop	RegenCopyName
 12075                                  
 12076                                  	; MSDOS 6.0
 12077 00002882 E88EFF                  	call	RegenCopyName		;copy the name to NAME1
 12078                                  
 12079 00002885 16                      	push	ss	; SS is DOSDATA
 12080 00002886 1F                      	pop	ds
 12081                                  
 12082                                  	;mov	byte [ATTRIB],16h
 12083 00002887 C606[2805]16            	MOV	byte [ATTRIB],attr_hidden+attr_system+attr_directory
 12084                                  					; Must set this to something interesting
 12085                                  					; to call DEVNAME.
 12086 0000288C E84824                  	call	DEVNAME 		; check for device
 12087 0000288F 5E                      	pop	si
 12088 00002890 07                      	pop	es
 12089 00002891 5E                      	pop	si
 12090 00002892 1F                      	pop	ds
 12091 00002893 7219                    	JC	short RegenFileNoSharing ; not found on device list => file
 12092                                  
 12093                                  	; Device found. We can ignore disk-specific info
 12094                                  
 12095                                  	;mov	[es:di+5],bh
 12096 00002895 26887D05                	MOV	[ES:DI+SF_ENTRY.sf_flags],BH ; device parms
 12097                                  	;mov	byte [es:di+4],0
 12098 00002899 26C6450400              	MOV	byte [ES:DI+SF_ENTRY.sf_attr],0 ; attribute
 12099                                  					; SS override
 12100                                  	;LDS	SI,[CS:DEVPT]		; get device driver
 12101 0000289E 36C536[5605]            	lds	si,[ss:DEVPT] ; MSDOS 6.0
 12102                                  	;mov	[es:di+7],si
 12103 000028A3 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12104                                  	;mov	[es:di+9],ds
 12105 000028A7 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12106 000028AB C3                      	retn				; carry is clear
 12107                                  
 12108                                  RegenDeadJ:
 12109 000028AC EB8E                    	JMP	short RegenDead
 12110                                  
 12111                                  	; File found. Just copy in the remaining pieces.
 12112                                  
 12113                                  RegenFileNoSharing:
 12114                                  	;mov	ax,[es:di+5]
 12115 000028AE 268B4505                	MOV	AX,[ES:DI+SF_ENTRY.sf_flags]
 12116 000028B2 83E03F                  	AND	AX,03Fh
 12117 000028B5 1E                      	push	ds
 12118 000028B6 56                      	push	si
 12119 000028B7 E82E43                  	call	FIND_DPB
 12120                                  	;mov	[es:di+7],si
 12121 000028BA 26897507                	MOV	[ES:DI+SF_ENTRY.sf_devptr],SI
 12122                                  	;mov	[es:di+9],ds
 12123 000028BE 268C5D09                	MOV	[ES:DI+SF_ENTRY.sf_devptr+2],DS
 12124 000028C2 5E                      	pop	si
 12125 000028C3 1F                      	pop	ds
 12126 000028C4 72E6                    	jc	short RegenDeadJ	; if find DPB fails, then drive
 12127                                  					; indicator was bogus
 12128                                  	;mov	ax,[si+1Dh]
 12129 000028C6 8B441D                  	MOV	AX,[SI+fcb_nsl_dirsec]
 12130                                  	;;mov	[es:di+1Dh],ax ; MSDOS 3.3
 12131                                  	;mov	[es:di+1Bh],ax ; MSDOS 6.0
 12132 000028C9 2689451B                	MOV	[ES:DI+SF_ENTRY.sf_dirsec],AX
 12133                                  
 12134                                  	; MSDOS 6.0
 12135                                  
 12136                                  	; SR;
 12137                                  	; Extract the read-only and archive bits from the top 2 bits of the sector
 12138                                  	; number
 12139                                  
 12140                                  	;mov	al,[si+18h]
 12141 000028CD 8A4418                  	mov	al,[si+fcb_sfn]
 12142 000028D0 24C0                    	and	al,0C0h		;get the 2 attribute bits
 12143 000028D2 88C4                    	mov	ah,al
 12144 000028D4 D0C4                    	rol	ah,1
 12145 000028D6 D0E8                    	shr	al,1
 12146 000028D8 08E0                    	or	al,ah
 12147 000028DA 243F                    	and	al,03Fh		;mask off unused bits
 12148                                  	;mov	[es:di+4],al
 12149 000028DC 26884504                	mov	[es:di+SF_ENTRY.sf_attr],al
 12150                                  
 12151                                  	; SR;
 12152                                  	; Update the higher word of the directory sector from the FCB
 12153                                  
 12154                                  	;;mov	al,[si+18h]
 12155 000028E0 8A4418                  	mov	al,[si+fcb_sfn]
 12156 000028E3 243F                    	and	al,03Fh		;mask off top 2 bits -- attr bits
 12157 000028E5 28E4                    	sub	ah,ah
 12158                                  	;mov	[es:di+1Dh],ax
 12159 000028E7 2689451D                	mov	[es:di+SF_ENTRY.sf_dirsec+2],ax ;update high word
 12160                                  
 12161                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12162                                  	;mov	ax,[si+1Bh]
 12163 000028EB 8B441B                  	MOV	AX,[SI+fcb_nsl_firclus]
 12164                                  	;mov	[es:di+0Bh],ax
 12165 000028EE 2689450B                	MOV	[ES:DI+SF_ENTRY.sf_firclus],AX
 12166                                  	;;mov	[es:di+1Bh],ax ; MSDOS 3.3
 12167                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 12168 000028F2 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 12169                                  	;mov	al,[si+1Fh]
 12170 000028F6 8A441F                  	MOV	AL,[SI+fcb_nsl_dirpos]
 12171                                  	;mov  	[es:di+1Fh],al
 12172 000028F9 2688451F                	MOV	[ES:DI+SF_ENTRY.sf_dirpos],AL
 12173                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 12174 000028FD 26FF05                  	inc	word [ES:DI]		; Increment reference count.
 12175                                  					; Existing FCB entries would be
 12176                                  					; flushed unnecessarily because of
 12177                                  					; check in CheckFCB of the ref_count.
 12178                                  					; July 22/85 - BAS
 12179                                  	;lea	si,[si+1]
 12180 00002900 8D7401                  	LEA	SI,[SI+SYS_FCB.name]
 12181                                  	;lea	di,[di+20h]
 12182 00002903 8D7D20                  	LEA	DI,[DI+SF_ENTRY.sf_name]
 12183                                  	;mov	cx,11
 12184 00002906 B90B00                  	MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 12185                                  	
 12186                                  	; MSDOS 6.0
 12187 00002909 E807FF                  	call	RegenCopyName	;copy name to SFT 
 12188                                  	
 12189                                  	; MSDOS 3.3
 12190                                  ;RegenCopyName2:
 12191                                  	;lodsb
 12192                                  	;call    UCase
 12193                                  	;stosb
 12194                                  	;loop    RegenCopyName2
 12195                                  
 12196 0000290C F8                      	clc
 12197 0000290D C3                      	retn
 12198                                  
 12199                                  ; 24/07/2019 - Retro DOS v3.2
 12200                                  
 12201                                  ;**	BlastSFT - FIll SFT with Garbage
 12202                                  ; --------------------------------------------------------------------------
 12203                                  ;	BlastSFT is used when an SFT is no longer needed; it's called with
 12204                                  ;	various garbage values to put into the SFT.  I don't know why,
 12205                                  ;	presumably to help with debugging (jgl).  We clear the few fields
 12206                                  ;	necessary to show that the SFT is free after filling it.
 12207                                  ;
 12208                                  ;	ENTRY	(es:di) = address of SFT
 12209                                  ;		(al) = fill character
 12210                                  ;	EXIT	(ax) = -1
 12211                                  ;		'C' clear
 12212                                  ;	USES	AX, CX, Flags
 12213                                  
 12214                                  BlastSFT:
 12215 0000290E 57                      	push	di
 12216                                  	;mov	cx,53 ; MSDOS 3.3
 12217                                  	;mov	cx,59 ; MSDOS 6.0
 12218 0000290F B93B00                  	mov	cx,SF_ENTRY.size
 12219 00002912 F3AA                    	rep	stosb
 12220 00002914 5F                      	pop	di
 12221 00002915 29C0                    	sub	ax,ax	; 0		; clear 'C'-----------------;
 12222 00002917 268905                  	mov	[es:di],ax
 12223                                  	;mov	[es:di+SFT_ENTRY.sf_ref_count],ax ; set ref count   ;
 12224                                  	;mov	[es:di+15h],ax
 12225 0000291A 26894515                	mov	[es:di+sf_LRU],ax	; set lru		    ;
 12226 0000291E 48                      	dec	ax	; -1					    ;
 12227                                  	;mov	[es:di+17h],ax ; 0FFFFh ; -1
 12228 0000291F 26894517                	mov	[es:di+sf_OpenAge],ax	; set open age to -1	    ;
 12229                                  BlastSFT_retn:
 12230 00002923 C3                      	retn				; return with 'C' clear     ;
 12231                                  
 12232                                  
 12233                                  ;Break	<CheckFCB - see if the SFT pointed to by the FCB is still OK>
 12234                                  ; --------------------------------------------------------------------------
 12235                                  ;
 12236                                  ;   CheckFCB - examine an FCB and its contents to see if it needs to be
 12237                                  ;   regenerated.
 12238                                  ;
 12239                                  ;   Inputs:	DS:SI point to FCB (not extended)
 12240                                  ;		AL is SFT index
 12241                                  ;   Outputs:	Carry Set - FCB needs to be regened
 12242                                  ;		Carry clear - FCB is OK. ES:DI point to SFT
 12243                                  ;   Registers modified: AX and BX
 12244                                  ;
 12245                                  ; --------------------------------------------------------------------------
 12246                                  
 12247                                  CheckFCB:
 12248                                  		
 12249                                  	; called from $fcb_open and sftfromfcb. SS already set up to DOSDATA
 12250                                  
 12251                                  	; MSDOS 3.3
 12252                                  
 12253                                  	; LES	DI,[CS:SFTFCB]
 12254                                  
 12255                                  	; MSDOS 6.0
 12256                                  	
 12257                                  	; SR;
 12258                                  	; We check if the given FCB is for a local file. If so, we return a 
 12259                                  	; bad SFT status forcing the caller to regenerate the SFT.
 12260                                  
 12261                                  	;test	byte [si+19h],0C0h
 12262 00002924 F64419C0                	test	byte [si+fcb_l_drive],FCBNETWORK|FCBSHARE|FCBDEVICE
 12263 00002928 7453                    	jz	short BadSFT		;Local file, return bad SFT
 12264 0000292A 36C43E[4000]            	LES     DI,[SS:SFTFCB]		; SS override
 12265                                  
 12266                                  	; MSDOS 6.0 (& MSDOS 3.3)
 12267                                  	;cmp	[es:di+4],al
 12268 0000292F 26384504                	CMP	[ES:DI+SFT.SFCount],AL
 12269 00002933 7248                    	JC	short BadSFT
 12270                                  	;;mov	bl,53 ; MSDOS 3.3
 12271                                  	;mov	bl,59 ; MSDOS 6.0
 12272 00002935 B33B                    	MOV	BL,SF_ENTRY.size
 12273 00002937 F6E3                    	MUL	BL
 12274                                  	;lea	di,[di+6]
 12275 00002939 8D7D06                  	LEA	DI,[DI+SFT.SFTable]
 12276 0000293C 01C7                    	ADD	DI,AX
 12277                                  	;MOV	AX,[CS:PROC_ID]	; MSDOS 3.3
 12278 0000293E 36A1[0603]              	mov	ax,[SS:PROC_ID] ; MSDOS 6.0  ; SS override
 12279                                  	;cmp	[es:di+31h],ax
 12280 00002942 26394531                	CMP	[ES:DI+SF_ENTRY.sf_PID],AX
 12281 00002946 7535                    	JNZ	short BadSFT		; must match process
 12282 00002948 26833D00                	cmp	word [es:di],0
 12283                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],0
 12284 0000294C 742F                    	JZ	short BadSFT		; must also be in use
 12285                                  	;mov	al,[si+19h]
 12286 0000294E 8A4419                  	MOV	AL,[SI+fcb_l_drive]
 12287                                  	;test	al,80h
 12288 00002951 A880                    	test	AL,FCBSPECIAL		; a special FCB?
 12289 00002953 7434                    	JZ	short CheckNoShare	; No. try local or device
 12290                                  
 12291                                  	; Since we are a special FCB, try NOT to use a bogus test instruction.
 12292                                  	; FCBSHARE is a superset of FCBNETWORK.
 12293                                  
 12294 00002955 50                      	PUSH	AX
 12295                                  	;and	al,0C0h
 12296 00002956 24C0                    	AND	AL,FCBMASK
 12297                                  	;cmp	al,0C0h
 12298 00002958 3CC0                    	CMP	AL,FCBSHARE		; net FCB?
 12299 0000295A 58                      	POP	AX
 12300 0000295B 7522                    	JNZ	short CheckNet		; yes
 12301                                  ;
 12302                                  ;----- In share support -----
 12303                                  ;
 12304                                  	; 26/07/2019
 12305 0000295D 2EFF1E[8800]            	call	far [cs:JShare+(11*4)]  ; 11 = ShChk
 12306                                  	;Call	far [ss:JShare+(11*4)]	; SS Override
 12307 00002962 7219                    	JC	short BadSFT
 12308 00002964 EB0A                    	JMP	SHORT CheckD
 12309                                  ;
 12310                                  ;----- End in share support -----
 12311                                  ;
 12312                                  CheckFirClus:
 12313 00002966 263B5D0B                	cmp     bx,[es:di+0Bh]
 12314 0000296A 263B5D0B                	CMP	BX,[ES:DI+SF_ENTRY.sf_firclus]
 12315 0000296E 750D                    	JNZ	short BadSFT
 12316                                  CheckD: 
 12317 00002970 243F                    	AND	AL,3Fh
 12318                                  	;mov	ah,[es:di+5]
 12319 00002972 268A6505                	MOV	AH,[ES:DI+SF_ENTRY.sf_flags]
 12320 00002976 80E43F                  	AND	AH,3Fh
 12321 00002979 38C4                    	CMP	AH,AL
 12322 0000297B 74A6                    	jz	short BlastSFT_retn	; carry is clear
 12323                                  BadSFT: 
 12324 0000297D F9                      	STC
 12325 0000297E C3                      	retn				; carry is clear
 12326                                  CheckNet:
 12327                                  	; 17/05/2019 - Retro DOS v4.0
 12328                                  	
 12329                                  ;----- In net support -----
 12330                                  
 12331                                  	; MSDOS 3.3
 12332                                  	;;mov	ax,[si+1Ah]
 12333                                  	;mov	ax,[si+fcb_net_handle]
 12334                                  	;;cmp	ax,[es:di+1Dh]
 12335                                  	;cmp	ax,[ES:DI+SF_ENTRY.sf_dirsec]
 12336                                  	;jnz	short BadSFT
 12337                                  	;;cmp	ax,[es:di+19h]
 12338                                  	;cmp	ax,[ES:DI+sf_netid]
 12339                                  	;jnz     short BadSFT
 12340                                  	;;mov	ax,[si+1Eh]
 12341                                  	;mov	ax,[si+fcb_l_attr]
 12342                                  	;;cmp	ax,[es:di+1Bh]
 12343                                  	;cmp	ax,[es:di+SF_ENTRY.sf_lstclus]
 12344                                  	;jnz     short BadSFT
 12345                                  
 12346                                  	; MSDOS 6.0
 12347                                  	;mov	ax,[si+1Ch]
 12348 0000297F 8B441C                  	MOV	AX,[SI+fcb_netID]	;AN000;IFS.DOS 4.00
 12349                                  	;cmp	ax,[es:di+7]
 12350 00002982 263B450B                	CMP	AX,[ES:DI+sf_serial_ID]	;AN000;IFS.DOS 4.00
 12351 00002986 75F5                    	JNZ	short BadSFT
 12352                                  
 12353                                  ;----- END In net support -----
 12354                                  
 12355                                  CheckNet_retn:
 12356 00002988 C3                      	retn
 12357                                  
 12358                                  CheckNoShare:
 12359                                  	;test	al,40h
 12360 00002989 A840                    	test	AL,FCBDEVICE		; Device?
 12361 0000298B 7500                    	JNZ	short CheckNoShareDev 	; Yes
 12362                                  
 12363                                  	; MSDOS 3.3 - IBMDOS.COM - Offset 27EFh
 12364                                  	;;mov	bx,[si+1Dh]
 12365                                  	;MOV	BX,[SI+fcb_nsl_dirsec]
 12366                                  	;;cmp	bx,[es:di+1Dh]
 12367                                  	;cmp	bx,[ES:DI+SF_ENTRY.sf_dirsec]
 12368                                  	;jnz	short BadSFT
 12369                                  	;;mov	bl,[si+1Fh]
 12370                                  	;MOV	bl,[SI+fcb_nsl_dirpos]
 12371                                  	;;cmp	bl,[es:di+1Fh]
 12372                                  	;cmp	bl,[ES:DI+SF_ENTRY.sf_dirpos]
 12373                                  	;jnz	short BadSFT
 12374                                  	;;mov	bl,[si+1Ah]
 12375                                  	;MOV	bl,[SI+fcb_nsl_bits]
 12376                                  	;;mov	bh,[es:di+5]
 12377                                  	;MOV	bh,[ES:DI+SF_ENTRY.sf_flags]
 12378                                  	;xor	bh,bl
 12379                                  	;and	bh,0C0h
 12380                                  	;jnz	short BadSFT
 12381                                  	;;xor	bl,[es:di+2]
 12382                                  	;xor	bl,[ES:DI+SF_ENTRY.sf_mode]
 12383                                  	;and	bl,0Fh
 12384                                  	;jnz	short BadSFT
 12385                                  	;push	di
 12386                                  	;push	si
 12387                                  	;;lea	di,[di+20h]  ; MSDOS 3.3
 12388                                  	;LEA	DI,[DI+SF_ENTRY.sf_name]
 12389                                  	;;lea	si,[si+1]
 12390                                  	;LEA	SI,[SI+SYS_FCB.name]
 12391                                  	;;mov	cx,11
 12392                                  	;MOV	CX,SYS_FCB.EXTENT-SYS_FCB.name ; 12-1
 12393                                  	;repe	cmpsb
 12394                                  	;pop	si
 12395                                  	;pop	di
 12396                                  	;jnz	short BadSFT
 12397                                  	;;mov	bx,[si+1Bh]
 12398                                  	;MOV	bX,[SI+fcb_nsl_firclus]
 12399                                  	;jmp	short CheckFirClus
 12400                                  
 12401                                  	; MSDOS 6.0
 12402                                  
 12403                                  	; SR;
 12404                                  	; The code below to match a local FCB with its SFT can no longer be
 12405                                  	; used. We just return a no-match status. This check is done right
 12406                                  	; at the top.
 12407                                  
 12408                                  CheckNoShareDev:
 12409                                  	;mov	bx,[si+1Ah]
 12410 0000298D 8B5C1A                  	MOV	BX,[SI+fcb_nsld_drvptr]
 12411                                  	;cmp	bx,[es:di+7]
 12412 00002990 263B5D07                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr]
 12413 00002994 75E7                    	JNZ	short BadSFT
 12414                                  	;mov	bx,[si+1Ch]
 12415 00002996 8B5C1C                  	MOV	BX,[SI+fcb_nsld_drvptr+2]
 12416                                  	;cmp	bx,[es:di+9]
 12417 00002999 263B5D09                	CMP	BX,[ES:DI+SF_ENTRY.sf_devptr+2]
 12418 0000299D 75DE                    	JNZ	short BadSFT
 12419 0000299F EBCF                    	JMP	short CheckD
 12420                                  
 12421                                  ; 24/07/2019 - Retro DOS v3.2
 12422                                  
 12423                                  ;Break	<SFTFromFCB - take a FCB and obtain a SFT from it>
 12424                                  ;----------------------------------------------------------------------------
 12425                                  ;
 12426                                  ;   SFTFromFCB - the workhorse of this compatability crap. Check to see if
 12427                                  ;	the SFT for the FCB is Good. If so, make ThisSFT point to it. If not
 12428                                  ;	good, get one from the cache and regenerate it. Overlay the LRU field
 12429                                  ;	with PID
 12430                                  ;
 12431                                  ;   Inputs:	DS:SI point to FCB
 12432                                  ;   Outputs:	ThisSFT point to appropriate SFT
 12433                                  ;		Carry clear -> OK ES:DI -> SFT
 12434                                  ;		Carry set -> error in ax
 12435                                  ;   Registers modified: ES,DI, AX
 12436                                  ;
 12437                                  ;----------------------------------------------------------------------------
 12438                                  
 12439                                  SFTFromFCB:
 12440                                  	; called from fcbio and $fcb_close. SS already set up to DOSDATA
 12441                                  
 12442                                  	; 17/05/2019 - Retro DOS v4.0
 12443                                  
 12444 000029A1 50                      	push	ax
 12445 000029A2 53                      	push	bx
 12446                                  	;mov	al,[si+18h]
 12447 000029A3 8A4418                  	MOV	AL,[SI+fcb_sfn] 	; set SFN for check
 12448 000029A6 E87BFF                  	call	CheckFCB
 12449 000029A9 5B                      	pop	bx
 12450 000029AA 58                      	pop	ax
 12451                                  	;MOV	[CS:THISSFT],DI		; SS override
 12452                                  	;MOV	[CS:THISSFT+2],ES
 12453 000029AB 36893E[5A05]            	MOV	[SS:THISSFT],DI		; SS override
 12454 000029B0 368C06[5C05]            	MOV	[SS:THISSFT+2],ES
 12455 000029B5 730F                    	JNC	short Set_SFT		; no problems, just set thissft
 12456                                  	
 12457                                  	; 24/07/2019 - Retro DOS v3.2
 12458                                  	; 31/05/2019
 12459                                  	;push	es ; * (MSDOS 6.21)
 12460 000029B7 E87CEC                  	call	save_world
 12461 000029BA E85EFE                  	call	FCBRegen
 12462 000029BD E863EC                  	call	restore_world		; use macro restore world
 12463                                  	;pop	es ; * (MSDOS 6.21) ; 31/05/2019	
 12464                                  
 12465                                  	;MOV	AX,[CS:EXTERR]		; SS override
 12466 000029C0 36A1[F002]              	MOV	AX,[SS:EXTERR]		; SS override
 12467 000029C4 72C2                    	jc	short CheckNet_retn
 12468                                  
 12469                                  Set_SFT: 
 12470                                  	;LES	DI,[CS:THISSFT]		; SS override for THISSFT & PROC_ID
 12471 000029C6 36C43E[5A05]            	les	di,[ss:THISSFT]
 12472                                  	;PUSH	word [CS:PROC_ID]	; set process id
 12473 000029CB 36FF36[0603]            	push	word [ss:PROC_ID]
 12474                                  	;pop	word [es:di+31h]
 12475 000029D0 268F4531                	POP     word [ES:DI+SF_ENTRY.sf_PID]
 12476 000029D4 C3                      	retn				; carry is clear
 12477                                  
 12478                                  ;Break	<FCBHardErr - generate INT 24 for hard errors on FCBS>
 12479                                  ;----------------------------------------------------------------------------
 12480                                  ;
 12481                                  ;   FCBHardErr - signal to a user app that he is trying to use an
 12482                                  ;	unavailable FCB.
 12483                                  ;
 12484                                  ;   Inputs:	none.
 12485                                  ;   Outputs:	none.
 12486                                  ;   Registers modified: all
 12487                                  ;
 12488                                  ;----------------------------------------------------------------------------
 12489                                  
 12490                                  FCBHardErr:
 12491                                  	; 24/07/2019 - Retro DOS v3.2
 12492                                  	; 17/05/2019 - Retro DOS v4.0
 12493                                  	;mov	es,[cs:DosDSeg]
 12494                                  	;
 12495                                  	;mov	ax,23h
 12496 000029D5 B82300                  	MOV	AX,error_FCB_unavailable
 12497                                  	;;mov	byte [cs:ALLOWED],8
 12498 000029D8 2EC606[1503]08          	MOV	byte [CS:ALLOWED],Allowed_FAIL
 12499                                  	;mov	byte [es:ALLOWED],Allowed_FAIL	
 12500                                  	
 12501 000029DE 2EC42E[4605]            	LES	BP,[CS:THISDPB]
 12502                                  	;les	bp,[es:THISDPB]
 12503                                  	
 12504 000029E3 BF0100                  	MOV	DI,1			; Fake some registers
 12505 000029E6 89F9                    	MOV	CX,DI
 12506                                  	;mov	dx,[es:bp+0Bh]
 12507 000029E8 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 12508 000029EC E83B31                  	call	HARDERR
 12509 000029EF F9                      	STC
 12510 000029F0 C3                      	retn
 12511                                  
 12512                                  ;============================================================================
 12513                                  ; FCBIO2.ASM, MSDOS 6.0, 1991
 12514                                  ;============================================================================
 12515                                  ; 21/07/2018 - Retro DOS v3.0
 12516                                  
 12517                                  ;**	FCBIO2.ASM - Ancient 1.0 1.1 FCB system calls
 12518                                  ;
 12519                                  ;	GetRR
 12520                                  ;	GetExtent
 12521                                  ;	SetExtent
 12522                                  ;	GetExtended
 12523                                  ;	GetRecSize
 12524                                  ;	FCBIO
 12525                                  ;	$FCB_OPEN
 12526                                  ;	$FCB_CREATE
 12527                                  ;	$FCB_RANDOM_WRITE_BLOCK
 12528                                  ;	$FCB_RANDOM_READ_BLOCK
 12529                                  ;	$FCB_SEQ_READ
 12530                                  ;	$FCB_SEQ_WRITE
 12531                                  ;	$FCB_RANDOM_READ
 12532                                  ;	$FCB_RANDOM_WRITE
 12533                                  ;
 12534                                  ;	Revision history:
 12535                                  ;
 12536                                  ;		Created: ARR 4 April 1983
 12537                                  ;			 MZ  6 June  1983 completion of functions
 12538                                  ;			 MZ 15 Dec   1983 Brain damaged programs close FCBs multiple
 12539                                  ;				  times.  Change so successive closes work by
 12540                                  ;				  always returning OK.	Also, detect I/O to
 12541                                  ;				  already closed FCB and return EOF.
 12542                                  ;		 MZ 16 Jan   1984 More braindamage.  Need to separate info
 12543                                  ;				  out of sft into FCB for reconnection
 12544                                  ;
 12545                                  ;	    A000   version 4.00	Jan. 1988
 12546                                  
 12547                                  ; Defintions for FCBOp flags
 12548                                  
 12549                                  RANDOM	equ 2				; random operation
 12550                                  FCBREAD equ 4				; doing a read
 12551                                  BLOCK	equ 8				; doing a block I/O
 12552                                  
 12553                                  ;Break <GetRR - return the random record field in DX:AX>
 12554                                  ;---------------------------------------------------------------------------
 12555                                  ;
 12556                                  ;   GetRR - correctly load DX:AX with the random record field (3 or 4 bytes)
 12557                                  ;	from the FCB pointed to by DS:SI
 12558                                  ;
 12559                                  ;   Inputs:	DS:SI point to an FCB
 12560                                  ;		BX has record size
 12561                                  ;   Outputs:	DX:AX contain the contents of the random record field
 12562                                  ;   Registers modified: none
 12563                                  ;---------------------------------------------------------------------------
 12564                                  
 12565                                  GetRR:
 12566                                  	;mov	ax,[si+21h]
 12567 000029F1 8B4421                  	MOV	AX,[SI+SYS_FCB.RR]	; get low order part
 12568                                  	;mov	dx,[si+23h]
 12569 000029F4 8B5423                  	MOV	DX,[SI+SYS_FCB.RR+2]	; get high order part
 12570 000029F7 83FB40                  	CMP	BX,64			; ignore MSB of RR if recsiz > 64
 12571 000029FA 7202                    	JB	short GetRRBye
 12572 000029FC 30F6                    	XOR	DH,DH
 12573                                  GetRRBye:
 12574 000029FE C3                      	retn
 12575                                  
 12576                                  ;Break <GetExtent - retrieve next location for sequential IO>
 12577                                  ;---------------------------------------------------------------------------
 12578                                  ;
 12579                                  ;   GetExtent - Construct the next record to perform I/O from the EXTENT and
 12580                                  ;	NR fields in the FCB.
 12581                                  ;
 12582                                  ;   Inputs:	DS:SI - point to FCB
 12583                                  ;   Outputs:	DX:AX contain the contents of the random record field
 12584                                  ;   Registers modified: none
 12585                                  ;---------------------------------------------------------------------------
 12586                                  
 12587                                  GetExtent:
 12588                                  	;mov	al,[si+20h]
 12589 000029FF 8A4420                  	MOV	AL,[SI+SYS_FCB.NR]	; get low order piece
 12590                                  	;mov	dx,[si+0Ch]
 12591 00002A02 8B540C                  	MOV	DX,[SI+SYS_FCB.EXTENT]	; get high order piece
 12592 00002A05 D0E0                    	SHL	AL,1
 12593 00002A07 D1EA                    	SHR	DX,1
 12594 00002A09 D0D8                    	RCR	AL,1	; move low order bit of DL to high order of AH
 12595 00002A0B 88D4                    	MOV	AH,DL
 12596 00002A0D 88F2                    	MOV	DL,DH
 12597 00002A0F 30F6                    	XOR	DH,DH
 12598 00002A11 C3                      	retn
 12599                                  
 12600                                  ;Break <SetExtent - update the extent/NR field>
 12601                                  ;---------------------------------------------------------------------------
 12602                                  ;
 12603                                  ;   SetExtent - change the position of an FCB by filling in the extent/NR
 12604                                  ;	fields
 12605                                  ;
 12606                                  ;   Inputs:	DS:SI point to FCB
 12607                                  ;		DX:AX is a record location in file
 12608                                  ;   Outputs:	Extent/NR fields are filled in
 12609                                  ;   Registers modified: CX
 12610                                  ;---------------------------------------------------------------------------
 12611                                  
 12612                                  SetExtent:
 12613 00002A12 50                      	push	ax
 12614 00002A13 52                      	push	dx
 12615 00002A14 89C1                    	MOV	CX,AX
 12616 00002A16 247F                    	AND	AL,7FH			; next rec field
 12617                                  	;mov	[si+20h],al
 12618 00002A18 884420                  	MOV	[SI+SYS_FCB.NR],AL
 12619 00002A1B 80E180                  	AND	CL,80H			; save upper bit
 12620 00002A1E D1E1                    	SHL	CX,1
 12621 00002A20 D1D2                    	RCL	DX,1			; move high bit of CX to low bit of DX
 12622 00002A22 88E8                    	MOV	AL,CH
 12623 00002A24 88D4                    	MOV	AH,DL
 12624                                  	;mov	[si+0Ch], ax
 12625 00002A26 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; all done
 12626 00002A29 5A                      	pop	dx
 12627 00002A2A 58                      	pop	ax
 12628 00002A2B C3                      	retn
 12629                                  
 12630                                  ;Break <GetExtended - find FCB in potential extended fcb>
 12631                                  ;---------------------------------------------------------------------------
 12632                                  ;
 12633                                  ;   GetExtended - Make DS:SI point to FCB from DS:DX
 12634                                  ;
 12635                                  ;   Inputs:	DS:DX point to a possible extended FCB
 12636                                  ;   Outputs:	DS:SI point to the FCB part
 12637                                  ;		zeroflag set if not extended fcb
 12638                                  ;   Registers modified: SI
 12639                                  ;---------------------------------------------------------------------------
 12640                                  
 12641                                  GetExtended:
 12642 00002A2C 89D6                    	MOV	SI,DX			; point to Something
 12643 00002A2E 803CFF                  	CMP	BYTE [SI],-1		; look for extention
 12644 00002A31 7503                    	JNZ	short GetBye		; not there
 12645 00002A33 83C607                  	ADD	SI,7			; point to FCB
 12646                                  GetBye:
 12647 00002A36 39D6                    	CMP	SI,DX			; set condition codes
 12648                                  getextd_retn:
 12649 00002A38 C3                      	retn
 12650                                  
 12651                                  ;Break <GetRecSize - return in BX the FCB record size>
 12652                                  ;---------------------------------------------------------------------------
 12653                                  ;
 12654                                  ;   GetRecSize - return in BX the record size from the FCB at DS:SI
 12655                                  ;
 12656                                  ;   Inputs:	DS:SI point to a non-extended FCB
 12657                                  ;   Outputs:	BX contains the record size
 12658                                  ;   Registers modified: None
 12659                                  ;---------------------------------------------------------------------------
 12660                                  
 12661                                  GetRecSize:
 12662 00002A39 8B5C0E                  	mov	bx,[si+0Eh]
 12663 00002A3C 8B5C0E                  	MOV	BX,[SI+SYS_FCB.RECSIZ]	; get his record size
 12664 00002A3F 09DB                    	OR	BX,BX			; is it nul?
 12665 00002A41 74F5                    	jz	short getextd_retn
 12666 00002A43 BB8000                  	MOV	BX,128			; use default size
 12667                                  	;mov	[si+0Eh],bx
 12668 00002A46 895C0E                  	MOV	[SI+SYS_FCB.RECSIZ],BX	; stuff it back
 12669 00002A49 C3                      	retn
 12670                                  
 12671                                  ; 24/07/2019 - Retro DOS v3.2
 12672                                  
 12673                                  ;BREAK <FCBIO - do internal FCB I/O>
 12674                                  ;---------------------------------------------------------------------------
 12675                                  ;
 12676                                  ;   FCBIO - look at FCBOP and merge all FCB operations into a single routine.
 12677                                  ;
 12678                                  ;   Inputs:	FCBOP flags which operations need to be performed
 12679                                  ;		DS:DX point to FCB
 12680                                  ;		CX may have count of number of records to xfer
 12681                                  ;   Outputs:	AL has error code
 12682                                  ;   Registers modified: all
 12683                                  ;---------------------------------------------------------------------------
 12684                                  
 12685                                  FCBIO:
 12686                                  
 12687                                  FEOF	EQU	1
 12688                                  FTRIM	EQU	2
 12689                                  
 12690                                  %define	FCBErr	byte [bp-1]  ; byte	
 12691                                  %define	cRec	word [bp-3]  ; word	
 12692                                  ;%define RecPos	word [bp-7]  ; dword
 12693                                  %define RecPosL	word [bp-7]  ; word
 12694                                  %define RecPosH	word [bp-5]  ; word
 12695                                  %define	RecSize	word [bp-9]  ; word
 12696                                  ;%define bPos	word [bp-13] ; dword
 12697                                  %define bPosL	word [bp-13] ; word
 12698                                  %define bPosH	word [bp-11] ; word
 12699                                  %define cByte	word [bp-15] ; word	
 12700                                  %define cResult word [bp-17] ; word	
 12701                                  %define	cRecRes	word [bp-19] ; word
 12702                                  %define	FCBOp	byte [bp-20] ; byte
 12703                                  
 12704                                  	;Enter
 12705                                  
 12706 00002A4A 55                      	push	bp
 12707 00002A4B 89E5                    	mov	bp,sp
 12708 00002A4D 83EC14                  	sub	sp,20
 12709                                  	;mov	[bp-20],al
 12710 00002A50 8846EC                  	MOV	FCBOp,AL
 12711                                  	;mov	byte [bp-1],0
 12712 00002A53 C646FF00                	MOV	FCBErr,0		;   FCBErr = 0;
 12713 00002A57 E8D2FF                  	call	GetExtended		;   FCB = GetExtended ();
 12714                                  	;test	byte [bp-20],8
 12715 00002A5A F646EC08                	TEST	FCBOp,BLOCK		;   if ((OP&BLOCK) == 0)
 12716 00002A5E 7503                    	JNZ	short GetPos
 12717 00002A60 B90100                  	MOV	CX,1			;	cRec = 1;
 12718                                  GetPos:
 12719                                  	;mov	[bp-3],cx
 12720 00002A63 894EFD                  	MOV	cRec,CX 		;*Tail coalesce
 12721 00002A66 E896FF                  	call	GetExtent		;   RecPos = GetExtent ();
 12722 00002A69 E8CDFF                  	call	GetRecSize		;   RecSize = GetRecSize ();
 12723                                  	;mov	[bp-9],bx
 12724 00002A6C 895EF7                  	MOV	RecSize,BX
 12725                                  	;test	byte [bp-20],2
 12726 00002A6F F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&RANDOM) <> 0)
 12727 00002A73 7403                    	JZ	short GetRec
 12728 00002A75 E879FF                  	call	GetRR			;	RecPos = GetRR ();
 12729                                  GetRec:
 12730                                  	;mov	[bp-7],ax
 12731 00002A78 8946F9                  	MOV	RecPosL,AX		;*Tail coalesce
 12732                                  	;mov	[bp-5],dx
 12733 00002A7B 8956FB                  	MOV	RecPosH,DX
 12734 00002A7E E891FF                  	call	SetExtent		;   SetExtent (RecPos);
 12735                                  	;mov	ax,[bp-5]
 12736 00002A81 8B46FB                  	MOV	AX,RecPosH		;   bPos = RecPos * RecSize;
 12737 00002A84 F7E3                    	MUL	BX
 12738 00002A86 89C7                    	MOV	DI,AX
 12739                                  	;mov	ax,[bp-7]
 12740 00002A88 8B46F9                  	MOV	AX,RecPosL
 12741 00002A8B F7E3                    	MUL	BX
 12742 00002A8D 01FA                    	ADD	DX,DI
 12743                                  	;mov	[bp-13],ax
 12744 00002A8F 8946F3                  	MOV	bPosL,AX
 12745                                  	;mov	[bp-11],dx
 12746 00002A92 8956F5                  	MOV	bPosH,DX
 12747                                  	;mov	ax,[bp-3]
 12748 00002A95 8B46FD                  	MOV	AX,cRec 		;   cByte = cRec * RecSize;
 12749 00002A98 F7E3                    	MUL	BX
 12750                                  	;mov	[bp-15],ax
 12751 00002A9A 8946F1                  	MOV	cByte,AX
 12752                                  
 12753                                  ;hkn; 	SS override
 12754 00002A9D 360306[F802]            	ADD	AX,[SS:DMAADD]		;   if (cByte+DMA > 64K) {
 12755 00002AA2 83D200                  	ADC	DX,0
 12756 00002AA5 7419                    	JZ	short DoOper
 12757                                  	;mov	byte [bp-1],2
 12758 00002AA7 C646FF02                	MOV	FCBErr,FTRIM		;	FCBErr = FTRIM;
 12759                                  
 12760                                  ;hkn; 	SS override
 12761 00002AAB 36A1[F802]              	MOV	AX,[SS:DMAADD]		;	cRec = (64K-DMA)/RecSize;
 12762 00002AAF F7D8                    	NEG	AX
 12763 00002AB1 7501                    	JNZ	short DoDiv
 12764 00002AB3 48                      	DEC	AX
 12765                                  DoDiv:
 12766 00002AB4 31D2                    	XOR	DX,DX
 12767 00002AB6 F7F3                    	DIV	BX
 12768                                  	;mov	[bp-3],ax
 12769 00002AB8 8946FD                  	MOV	cRec,AX
 12770 00002ABB F7E3                    	MUL	BX			;	cByte = cRec * RecSize;
 12771                                  	;mov	[bp-15],ax
 12772 00002ABD 8946F1                  	MOV	cByte,AX		;	}
 12773                                  DoOper:
 12774 00002AC0 31DB                    	XOR	BX,BX
 12775                                  	;mov	[bp-17],bx
 12776 00002AC2 895EEF                  	MOV	cResult,BX		;   cResult = 0;
 12777                                  	;cmp	[bp-15],bx
 12778 00002AC5 395EF1                  	CMP	cByte,BX		;   if (cByte <> 0 ||
 12779 00002AC8 7506                    	JNZ	short DoGetExt
 12780                                  	;test	byte [bp-1],2
 12781 00002ACA F646FF02                	TEST	FCBErr,FTRIM		;	(FCBErr&FTRIM) == 0) {
 12782                                  	;JZ	short DoGetExt
 12783                                  	;JMP	short SkipOp
 12784 00002ACE 7576                    	jnz	short SkipOp
 12785                                  DoGetExt:
 12786 00002AD0 E8CEFE                  	call	SFTFromFCB		;	if (!SFTFromFCB (SFT,FCB))
 12787 00002AD3 730F                    	JNC	short ContinueOp
 12788                                  FCBDeath:
 12789 00002AD5 E8E2EC                  	call	FCB_RET_ERR		; signal error, map for extended
 12790                                  	;mov	word [bp-19],0
 12791 00002AD8 C746ED0000              	MOV	cRecRes,0		; no bytes transferred
 12792                                  	;mov	byte [bp-1],1
 12793 00002ADD C646FF01                	MOV	FCBErr,FEOF		;	    return FTRIM;
 12794 00002AE1 E9F000                  	JMP	FCBSave 		; bam!
 12795                                  ContinueOp:
 12796                                  	;mov	ax,[si+10h]
 12797 00002AE4 8B4410                  	MOV	AX,[SI+SYS_FCB.FILSIZ]
 12798                                  	;mov	[es:di+11h],ax
 12799 00002AE7 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 12800                                  	;mov	ax,[si+12h]
 12801 00002AEB 8B4412                  	MOV	AX,[SI+SYS_FCB.FILSIZ+2]
 12802                                  	;mov	[es:di+13h],ax
 12803 00002AEE 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 12804                                  	;mov	ax,[bp-13]
 12805 00002AF2 8B46F3                  	MOV	AX,bPosL
 12806                                  	;mov	dx,[bp-11]
 12807 00002AF5 8B56F5                  	MOV	DX,bPosH
 12808                                  	;mov	[es:di+15h],ax
 12809 00002AF8 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 12810                                  	;xchg	dx,[es:di+17h]
 12811 00002AFC 26875517                	XCHG	[ES:DI+SF_ENTRY.sf_position+2],DX
 12812 00002B00 52                      	PUSH	DX			; save away Open age.
 12813                                  	;mov	cx,[bp-15]
 12814 00002B01 8B4EF1                  	MOV	CX,cByte		;	cResult =
 12815                                  
 12816                                  ;hkn; DOS_Read is in DOSCODE
 12817 00002B04 BF[C93E]                	MOV	DI,DOS_READ		;	    *(OP&FCBRead ? DOS_Read
 12818                                  	;test	byte [bp-20],4
 12819 00002B07 F646EC04                	TEST	FCBOp,FCBREAD		;		 : DOS_Write)(cRec);
 12820 00002B0B 7503                    	JNZ	short DoContext
 12821                                  
 12822                                  ;hkn; DOS_Write is in DOSCODE
 12823 00002B0D BF[5440]                	MOV	DI,DOS_WRITE
 12824                                  DoContext:
 12825 00002B10 55                      	push	bp
 12826 00002B11 1E                      	push	ds
 12827 00002B12 56                      	push	si
 12828                                  
 12829                                  ;hkn; SS is DOSDATA
 12830 00002B13 16                      	push	ss
 12831 00002B14 1F                      	pop	ds
 12832                                  
 12833                                  ;; Fix for disk full
 12834 00002B15 FFD7                    	CALL	DI
 12835                                  	
 12836 00002B17 5E                      	pop	si
 12837 00002B18 1F                      	pop	ds
 12838 00002B19 5D                      	pop	bp
 12839 00002B1A 72B9                    	JC	short FCBDeath
 12840                                  	
 12841 00002B1C 36803E[C20F]00          	CMP	BYTE [SS:DISK_FULL],0	; treat disk full as error
 12842 00002B22 740A                    	JZ	short NODSKFULL
 12843 00002B24 36C606[C20F]00          	MOV	BYTE [SS:DISK_FULL],0	; clear the flag
 12844                                  	;mov	byte [bp-1],1 
 12845 00002B2A C646FF01                	MOV	FCBErr,FEOF		; set disk full flag
 12846                                  NODSKFULL:
 12847                                  ;; Fix for disk full
 12848                                  	;mov	[bp-17],cx
 12849 00002B2E 894EEF                  	MOV	cResult,CX
 12850 00002B31 E82CFB                  	call	SaveFCBInfo		;	SaveFCBInfo (FCB);
 12851                                  	;pop	word [es:di+17h]	
 12852 00002B34 268F4517                	POP	WORD [ES:DI+SF_ENTRY.sf_position+2] ; restore open age
 12853                                  			       ; (sf_OpenAge = SF_ENTRY.sf_position+2)			
 12854                                  	;mov	ax,[es:di+11h]
 12855 00002B38 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 12856                                  	;mov	[si+10h],ax
 12857 00002B3C 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 12858                                  	;mov	ax,[es:di+13h]
 12859 00002B3F 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 12860                                  	;mov	[si+12h],ax
 12861 00002B43 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 12862                                  					;	}
 12863                                  SkipOp:
 12864                                  	;mov	ax,[bp-17]
 12865 00002B46 8B46EF                  	MOV	AX,cResult		;   cRecRes = cResult / RecSize;
 12866 00002B49 31D2                    	XOR	DX,DX
 12867                                  	;div	word [bp-9]
 12868 00002B4B F776F7                  	DIV	RecSize
 12869                                  	;mov	[bp-19],ax
 12870 00002B4E 8946ED                  	MOV	cRecRes,AX
 12871                                  	;add	[bp-7],ax
 12872 00002B51 0146F9                  	ADD	RecPosL,AX		;   RecPos += cRecResult;
 12873                                  	;adc	word [bp-5],0
 12874 00002B54 8356FB00                	ADC	RecPosH,0
 12875                                  ;
 12876                                  ; If we have not gotten the expected number of records, we signal an EOF
 12877                                  ; condition. On input, this is EOF.  On output this is usually disk full.
 12878                                  ; BUT... Under 2.0 and before, all device output IGNORED this condition. So
 12879                                  ; do we.
 12880                                  ;
 12881                                  	;cmp	ax,[bp-3]
 12882 00002B58 3B46FD                  	CMP	AX,cRec 		;   if (cRecRes <> cRec)
 12883 00002B5B 7412                    	JZ	short TryBlank
 12884                                  	;test	byte [bp-20],4
 12885 00002B5D F646EC04                	TEST	FCBOp,FCBREAD		;	if (OP&FCBRead || !DEVICE)
 12886 00002B61 7508                    	JNZ	short SetEOF
 12887                                  	;test	word [es:di+5],80h
 12888 00002B63 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 12889 00002B69 7504                    	JNZ	short TryBlank
 12890                                  SetEOF:
 12891                                  	;mov	byte [bp-1],1
 12892 00002B6B C646FF01                	MOV	FCBErr,FEOF		;	FCBErr = FEOF;
 12893                                  TryBlank:				;
 12894 00002B6F 09D2                    	OR	DX,DX			;   if (cResult%RecSize <> 0) {
 12895 00002B71 7426                    	JZ	short SetExt
 12896                                  	;add	word [bp-7],1
 12897 00002B73 8346F901                	ADD	RecPosL,1		;	RecPos++;
 12898                                  	;adc	word [bp-5],0
 12899 00002B77 8356FB00                	ADC	RecPosH,0
 12900                                  	;test	byte [bp-20],4
 12901 00002B7B F646EC04                	TEST	FCBOp,FCBREAD		;	if(OP&FCBRead) <> 0) {
 12902 00002B7F 7418                    	JZ	short SetExt
 12903                                  	;inc	word [bp-19]
 12904 00002B81 FF46ED                  	INC	cRecRes 		;	cRecRes++;
 12905                                  	;mov	byte [bp-1],3
 12906 00002B84 C646FF03                	MOV	FCBErr,FTRIM+FEOF	;	FCBErr = FTRIM | FEOF;
 12907                                  	;mov	cx,[bp-9]
 12908 00002B88 8B4EF7                  	MOV	CX,RecSize		;	Blank (RecSize-cResult%RecSize,
 12909 00002B8B 29D1                    	SUB	CX,DX			;	       DMA+cResult);
 12910 00002B8D 30C0                    	XOR	AL,AL
 12911                                  ;hkn; 	SS override
 12912 00002B8F 36C43E[F802]            	les     di,[ss:DMAADD]
 12913                                  	;add	di,[bp-17]
 12914 00002B94 037EEF                  	ADD	DI,cResult
 12915 00002B97 F3AA                    	REP	STOSB			;   }	}
 12916                                  SetExt:
 12917                                  	;mov	dx,[bp-5]
 12918 00002B99 8B56FB                  	MOV	DX,RecPosH
 12919                                  	;mov	ax,[bp-7]
 12920 00002B9C 8B46F9                  	MOV	AX,RecPosL
 12921                                  	;test	byte [bp-20],2
 12922 00002B9F F646EC02                	TEST	FCBOp,RANDOM		;   if ((OP&Random) == 0 ||
 12923 00002BA3 7406                    	JZ	short DoSetExt
 12924                                  	;test	byte [bp-20],8
 12925 00002BA5 F646EC08                	TEST	FCBOp,BLOCK		;	(OP&BLOCK) <> 0)
 12926 00002BA9 7403                    	JZ	short TrySetRR
 12927                                  DoSetExt:
 12928 00002BAB E864FE                  	call	SetExtent		;	SetExtent (RecPos, FCB);
 12929                                  TrySetRR:
 12930                                  	;test	byte [bp-20],8
 12931 00002BAE F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 12932 00002BB2 740F                    	JZ	short TryReturn
 12933                                  	;mov	[si+21h],ax
 12934 00002BB4 894421                  	MOV	[SI+SYS_FCB.RR],AX	;	FCB->RR = RecPos;
 12935                                  	;mov	[si+23h],dl
 12936 00002BB7 885423                  	MOV	[SI+SYS_FCB.RR+2],DL
 12937                                  	;cmp	word [si+0Eh],64
 12938 00002BBA 837C0E40                	CMP	word [SI+SYS_FCB.RECSIZ],64
 12939 00002BBE 7303                    	JAE	short TryReturn
 12940                                  	;mov	[si+24h],dh
 12941 00002BC0 887424                  	MOV	[SI+SYS_FCB.RR+2+1],DH	; Set 4th byte only if record size < 64
 12942                                  TryReturn: 
 12943                                  	;test	byte [bp-20],4
 12944 00002BC3 F646EC04                	TEST	FCBOp,FCBREAD		;   if (!(FCBOP & FCBREAD)) {
 12945 00002BC7 750B                    	JNZ	short FCBSave
 12946 00002BC9 1E                      	push	ds			;	FCB->FDate = date;
 12947 00002BCA E887ED                  	call	DATE16			;	FCB->FTime = time;
 12948 00002BCD 1F                      	pop	ds
 12949                                  	;mov	[si+14h],ax
 12950 00002BCE 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 12951                                  	;mov	[si+16h],dx
 12952 00002BD1 895416                  	MOV	[SI+SYS_FCB.FTIME],DX	;	}
 12953                                  FCBSave: 
 12954                                  	;test	byte [bp-20],8
 12955 00002BD4 F646EC08                	TEST	FCBOp,BLOCK		;   if ((op&BLOCK) <> 0)
 12956 00002BD8 7409                    	jz	short DoReturn
 12957                                  	;mov	cx,[bp-19]
 12958 00002BDA 8B4EED                  	MOV	CX,cRecRes		;	user_CX = cRecRes;
 12959 00002BDD E869EA                  	call    Get_User_Stack
 12960                                  	;mov	[si+4],cx
 12961 00002BE0 894C04                  	MOV	[SI+user_env.user_CX],CX
 12962                                  DoReturn:
 12963                                  	;mov	al,[bp-1]
 12964 00002BE3 8A46FF                  	MOV	AL,FCBErr		;   return (FCBERR);
 12965                                  	;Leave	
 12966 00002BE6 89EC                    	mov     sp,bp
 12967 00002BE8 5D                      	pop     bp
 12968 00002BE9 C3                      	retn
 12969                                  
 12970                                  ; 24/07/2018 - Retro DOS v3.2
 12971                                  ; 22/07/2018 - Retro DOS v3.0
 12972                                  
 12973                                  ;Break <$FCB_Open - open an old-style FCB>
 12974                                  ;---------------------------------------------------------------------------
 12975                                  ;
 12976                                  ;   $FCB_Open - CPM compatability file open. The user has formatted an FCB
 12977                                  ;	for us and asked to have the rest filled in.
 12978                                  ;
 12979                                  ;   Inputs:	DS:DX point to an unopenned FCB
 12980                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 12981                                  ;		FCB has the following fields filled in:
 12982                                  ;		    Time/Date Extent/NR Size
 12983                                  ;---------------------------------------------------------------------------
 12984                                  
 12985                                  _$FCB_OPEN:			; System call 15
 12986                                  
 12987 00002BEA B80200                  	MOV	AX,SHARING_COMPAT+open_for_both
 12988                                  
 12989                                  ;hkn; DOS_Open is in DOSCODE
 12990 00002BED B9[F137]                	MOV	CX,DOS_OPEN
 12991                                  
 12992                                  ; The following is common code for Creation and openning of FCBs. AX is
 12993                                  ; either attributes (for create) or open mode (for open)... DS:DX points to
 12994                                  ; the FCB
 12995                                  
 12996                                  DoAccess:
 12997 00002BF0 1E                      	push	ds
 12998 00002BF1 52                      	push	dx
 12999 00002BF2 51                      	push	cx
 13000 00002BF3 50                      	push	ax			; save FCB pointer away
 13001                                  
 13002                                  ;hkn; 	OpenBuf is in DOSDATA
 13003 00002BF4 BF[8203]                	MOV	DI,OPENBUF
 13004 00002BF7 E83441                  	call	TransFCB		; crunch the fcb
 13005 00002BFA 58                      	pop	ax
 13006 00002BFB 59                      	pop	cx
 13007 00002BFC 5A                      	pop	dx
 13008 00002BFD 1F                      	pop	ds			; get fcb
 13009 00002BFE 7303                    	JNC	short FindFCB		; everything seems ok
 13010                                  FCBOpenErr:
 13011                                  	; AL has error code
 13012 00002C00 E9B7EB                  	jmp	FCB_RET_ERR
 13013                                  FindFCB:
 13014 00002C03 E826FE                  	call	GetExtended		; DS:SI will point to FCB
 13015                                  
 13016                                  	; 17/05/2019 - Retro DOS v4.0
 13017                                  
 13018                                  	; MSDOS 3.3
 13019                                  	;call	LRUFCB
 13020                                  	;jc	short HardMessage
 13021                                  
 13022                                  	; MSDOS 6.0
 13023 00002C06 50                      	push	ax
 13024 00002C07 B001                    	mov	al,1			;indicate Open/Create operation
 13025 00002C09 E824FB                  	call	LRUFCB			; get a sft entry (no error)
 13026 00002C0C 58                      	pop	ax
 13027 00002C0D 722A                    	jc	short HardMessage
 13028                                  	
 13029                                  	;mov	word [es:di+2],8000h
 13030 00002C0F 26C745020080            	mov	word [es:di+SF_ENTRY.sf_mode],sf_isFCB
 13031 00002C15 1E                      	push	ds
 13032 00002C16 56                      	push	si
 13033 00002C17 53                      	push	bx			; save fcb pointer
 13034 00002C18 89CE                    	MOV	SI,CX
 13035                                  
 13036                                  ;hkn; SS is DOSDATA
 13037 00002C1A 16                      	push	ss
 13038 00002C1B 1F                      	pop	ds			; let DOS_Open see variables
 13039 00002C1C FFD6                    	CALL	SI			; go open the file
 13040 00002C1E 5B                      	pop	bx
 13041 00002C1F 5E                      	pop	si
 13042 00002C20 1F                      	pop	ds			; get fcb
 13043                                  
 13044                                  ;hkn; SS override
 13045 00002C21 36C43E[5A05]            	LES	DI,[SS:THISSFT]		; get sf pointer
 13046 00002C26 7319                    	JNC	short FCBOK		; operation succeeded
 13047                                  failopen:
 13048 00002C28 50                      	PUSH	AX
 13049 00002C29 B052                    	MOV	AL,"R"                  ; clear out field (free sft)
 13050 00002C2B E8E0FC                  	call	BlastSFT
 13051 00002C2E 58                      	POP	AX
 13052                                  	;cmp	ax,4
 13053 00002C2F 83F804                  	CMP	AX,error_too_many_open_files
 13054 00002C32 7405                    	JZ	short HardMessage
 13055                                  	;cmp	ax,24h
 13056 00002C34 83F824                  	CMP	AX,error_sharing_buffer_exceeded
 13057 00002C37 7505                    	jnz	short DeadFCB
 13058                                  HardMessage:
 13059 00002C39 50                      	PUSH	AX
 13060 00002C3A E898FD                  	call	FCBHardErr
 13061 00002C3D 58                      	POP	AX
 13062                                  DeadFCB:
 13063 00002C3E E979EB                  	jmp	FCB_RET_ERR
 13064                                  FCBOK:
 13065                                  	; MSDOS 6.0
 13066 00002C41 E840F4                  	call	IsSFTNet		;AN007;F.C. >32mb  Non Fat file?
 13067 00002C44 750F                    	JNZ	short FCBOK2		;AN007;F.C. >32mb  yes
 13068 00002C46 E81D4A                  	call	CheckShare		;AN000;F.C. >32mb  share around?
 13069 00002C49 750A                    	JNZ	short FCBOK2		;AN000;F.C. >32mb  yes
 13070                                  ;SR;
 13071                                  ; If we reach here, we know we have got a local SFT. Let's update the 
 13072                                  ; LocalSFT variable to reflect this.
 13073                                  
 13074 00002C4B 36893E[C50F]            	mov	[ss:LocalSFT],di
 13075 00002C50 368C06[C70F]            	mov	[ss:LocalSFT+2],es; Store the SFT address
 13076                                  ;;SR;
 13077                                  ;; The check below is not valid anymore since we regenerate for media > 32M.
 13078                                  ;;
 13079                                  ;;	CMP	WORD [ES:DI+SF_ENTRY.sf_dirsec+2],0 
 13080                                  ;;					       ;AN000;F.C. >32mb  if dirsec >32mb
 13081                                  ;;	JZ	short FCBOK2		       ;AN000;F.C. >32mb    then error
 13082                                  ;;	MOV	AX,error_sys_comp_not_loaded   ;AN000;F.C. >32mb
 13083                                  ;;	JMP	short failopen		       ;AN000;F.C. >32mb
 13084                                  
 13085                                  FCBOK2:
 13086                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13087 00002C55 26FF05                  	inc	word [es:di]
 13088                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] ; increment reference count
 13089 00002C58 E805FA                  	call	SaveFCBInfo
 13090                                  	; MSDOS 3.3
 13091                                  	;call	SetOpenAge
 13092                                  	; MSDOS 6.0 (& MSDOS 3.3)
 13093                                  	;test	word [es:di+5],80h
 13094                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 13095 00002C5B 26F6450580              	test	byte  [ES:DI+SF_ENTRY.sf_flags],devid_device  ; 28/07/2019
 13096 00002C60 7509                    	JNZ	short FCBNoDrive	; do not munge drive on devices
 13097 00002C62 8A04                    	MOV	AL,[SI]			; get drive byte
 13098 00002C64 E85040                  	call	GETTHISDRV		; convert
 13099 00002C67 FEC0                    	INC	AL
 13100 00002C69 8804                    	MOV	[SI],AL			; stash in good drive letter
 13101                                  FCBNoDrive:
 13102                                  	;mov	word [si+0Eh],128
 13103 00002C6B C7440E8000              	MOV	word [SI+SYS_FCB.RECSIZ],80h ; stuff in default record size
 13104                                  
 13105                                  	;mov	ax,[es:di+0Dh]
 13106 00002C70 268B450D                	MOV	AX,[ES:DI+SF_ENTRY.sf_time] ; set time
 13107                                  	;mov	[si+16h],ax
 13108 00002C74 894416                  	MOV	[SI+SYS_FCB.FTIME],AX
 13109                                  	;mov	ax,[es:di+0Fh]
 13110 00002C77 268B450F                	MOV	AX,[ES:DI+SF_ENTRY.sf_date] ; set date
 13111                                  	;mov	[si+14h],ax
 13112 00002C7B 894414                  	MOV	[SI+SYS_FCB.FDATE],AX
 13113                                  	;mov	ax,[es:di+11h]
 13114 00002C7E 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size] ; set sizes
 13115                                  	;mov	[si+10h],ax
 13116 00002C82 894410                  	MOV	[SI+SYS_FCB.FILSIZ],AX
 13117                                  	;mov	ax,[es:di+13h]
 13118 00002C85 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]
 13119                                  	;mov	[si+12h],ax
 13120 00002C89 894412                  	MOV	[SI+SYS_FCB.FILSIZ+2],AX
 13121 00002C8C 31C0                    	XOR	AX,AX			; convenient zero
 13122                                  	;mov	[si+0Ch],ax
 13123 00002C8E 89440C                  	MOV	[SI+SYS_FCB.EXTENT],AX	; point to beginning of file
 13124                                  
 13125                                  ; We must scan the set of FCB SFTs for one that appears to match the current
 13126                                  ; one.	We cheat and use CheckFCB to match the FCBs.
 13127                                  
 13128                                  ;hkn; 	SS override
 13129 00002C91 36C43E[4000]            	LES	DI,[SS:SFTFCB]		; get the pointer to head of the list
 13130                                  	;mov	ah,[es:di+4]
 13131 00002C96 268A6504                	MOV	AH,[ES:DI+SFT.SFCount]	; get number of SFTs to scan
 13132                                  OpenScan:
 13133                                  	;cmp	al,[si+18h]
 13134 00002C9A 3A4418                  	CMP	AL,[SI+fcb_sfn]		; don't compare ourselves
 13135 00002C9D 7407                    	JZ	short SkipCheck
 13136 00002C9F 50                      	push	ax			; preserve count
 13137 00002CA0 E881FC                  	call	CheckFCB		; do they match
 13138 00002CA3 58                      	pop	ax			; get count back
 13139 00002CA4 7309                    	JNC	short OpenFound		; found a match!
 13140                                  SkipCheck:
 13141 00002CA6 FEC0                    	INC	AL			; advance to next FCB
 13142 00002CA8 38E0                    	CMP	AL,AH			; table full?
 13143 00002CAA 75EE                    	JNZ	short OpenScan		; no, go for more
 13144                                  OpenDone:
 13145 00002CAC 30C0                    	xor	al,al			; return success
 13146 00002CAE C3                      	retn
 13147                                  
 13148                                  ; The SFT at ES:DI is the one that is already in use for this FCB. We set the
 13149                                  ; FCB to use this one. We increment its ref count. We do NOT close it at all.
 13150                                  ; Consider:
 13151                                  ;
 13152                                  ;   open (foo)	delete (foo) open (bar)
 13153                                  ;
 13154                                  ; This causes us to recycle (potentially) bar through the same local SFT as
 13155                                  ; foo even though foo is no longer needed; this is due to the server closing
 13156                                  ; foo for us when we delete it. Unfortunately, we cannot see this closure.
 13157                                  ; If we were to CLOSE bar, the server would then close the only reference to
 13158                                  ; bar and subsequent I/O would be lost to the redirector.
 13159                                  ;
 13160                                  ; This gets solved by NOT closing the sft, but zeroing the ref count
 13161                                  ; (effectively freeing the SFT) and informing the sharer (if relevant) that
 13162                                  ; the SFT is no longer in use. Note that the SHARER MUST keep its ref counts
 13163                                  ; around. This will allow us to access the same file through multiple network
 13164                                  ; connections and NOT prematurely terminate when the ref count on one
 13165                                  ; connection goes to zero.
 13166                                  
 13167                                  OpenFound:
 13168                                  	;mov	[si+18h],al
 13169 00002CAF 884418                  	MOV	[SI+fcb_sfn],AL 	; assign with this
 13170 00002CB2 26FF05                  	inc	word [es:di]
 13171                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count] 
 13172                                  					; remember this new invocation
 13173 00002CB5 36A1[1000]              	MOV	AX,[SS:FCBLRU]		; update LRU counts
 13174                                  	;mov	[es:di+15h],ax
 13175 00002CB9 26894515                	MOV	[ES:DI+sf_LRU],AX
 13176                                  ;
 13177                                  ; We have an FCB sft that is now of no use.  We release sharing info and then
 13178                                  ; blast it to prevent other reuse.
 13179                                  ;
 13180 00002CBD 16                      	push	ss
 13181 00002CBE 1F                      	pop	ds
 13182 00002CBF C43E[5A05]              	LES	DI,[THISSFT]
 13183 00002CC3 26FF0D                  	dec	word [es:di]
 13184                                  	;DEC	word [ES:DI+SF_ENTRY.sf_ref_count]
 13185                                  					; free the newly allocated SFT
 13186 00002CC6 E8CF49                  	call	ShareEnd
 13187 00002CC9 B043                    	MOV	AL,'C'
 13188 00002CCB E840FC                  	call	BlastSFT
 13189 00002CCE EBDC                    	JMP	short OpenDone
 13190                                  
 13191                                  ;BREAK	<$FCB_Create - create a new directory entry>
 13192                                  ;----------------------------------------------------------------------------
 13193                                  ;
 13194                                  ;   $FCB_Create - CPM compatability file create. The user has formatted an
 13195                                  ;	FCB for us and asked to have the rest filled in.
 13196                                  ;
 13197                                  ;   Inputs:	DS:DX point to an unopenned FCB
 13198                                  ;   Outputs:	AL indicates status 0 is ok FF is error
 13199                                  ;		FCB has the following fields filled in:
 13200                                  ;		    Time/Date Extent/NR Size
 13201                                  ;----------------------------------------------------------------------------
 13202                                  
 13203                                  _$FCB_CREATE:		; System call 22
 13204                                  
 13205                                  ;hkn; DOS_Create is in DOSCODE
 13206 00002CD0 B9[5B37]                	MOV	CX,DOS_CREATE		; routine to call
 13207 00002CD3 31C0                    	XOR	AX,AX			; attributes to create
 13208 00002CD5 E854FD                  	call	GetExtended		; get extended FCB
 13209 00002CD8 7403                    	JZ	short DoAccessJ		; not an extended FCB
 13210 00002CDA 8A44FF                  	MOV	AL,[SI-1]		; get attributes
 13211                                  DoAccessJ:
 13212 00002CDD E910FF                  	JMP	DoAccess		; do dirty work
 13213                                  
 13214                                  ; 22/07/2018 - Retro DOS v3.0
 13215                                  
 13216                                  ;BREAK <$FCB_Random_write_Block - write a block of records to a file >
 13217                                  ;----------------------------------------------------------------------------
 13218                                  ;
 13219                                  ;   $FCB_Random_Write_Block - retrieve a location from the FCB, seek to it
 13220                                  ;	and write a number of blocks from it.
 13221                                  ;
 13222                                  ;   Inputs:	DS:DX point to an FCB
 13223                                  ;   Outputs:	AL = 0 write was successful and the FCB position is updated
 13224                                  ;		AL <> 0 Not enough room on disk for the output
 13225                                  ;
 13226                                  ;----------------------------------------------------------------------------
 13227                                  
 13228                                  _$FCB_RANDOM_WRITE_BLOCK:
 13229                                  	;mov	AL,0Ah	
 13230 00002CE0 B00A                    	MOV	AL,RANDOM+BLOCK
 13231 00002CE2 E965FD                  	JMP	FCBIO
 13232                                  
 13233                                  ;BREAK <$FCB_Random_Read_Block - read a block of records to a file >
 13234                                  ;----------------------------------------------------------------------------
 13235                                  ;
 13236                                  ;   $FCB_Random_Read_Block - retrieve a location from the FCB, seek to it
 13237                                  ;	and read a number of blocks from it.
 13238                                  ;
 13239                                  ;   Inputs:	DS:DX point to an FCB
 13240                                  ;   Outputs:	AL = error codes defined above
 13241                                  ;
 13242                                  ;----------------------------------------------------------------------------
 13243                                  
 13244                                  _$FCB_RANDOM_READ_BLOCK:
 13245                                  	;mov	AL,0Eh	
 13246 00002CE5 B00E                    	MOV	AL,RANDOM+FCBREAD+BLOCK
 13247 00002CE7 E960FD                  	JMP	FCBIO
 13248                                  
 13249                                  ;BREAK <$FCB_Seq_Read - read the next record from a file >
 13250                                  ;----------------------------------------------------------------------------
 13251                                  ;
 13252                                  ;   $FCB_Seq_Read - retrieve the next record from an FCB and read it into
 13253                                  ;	memory
 13254                                  ;
 13255                                  ;   Inputs:	DS:DX point to an FCB
 13256                                  ;   Outputs:	AL = error codes defined above
 13257                                  ;
 13258                                  ;----------------------------------------------------------------------------
 13259                                  
 13260                                  _$FCB_SEQ_READ:
 13261                                  	;mov	AL,4	
 13262 00002CEA B004                    	MOV	AL,FCBREAD
 13263 00002CEC E95BFD                  	JMP	FCBIO
 13264                                  
 13265                                  ;BREAK <$FCB_Seq_Write - write the next record to a file >
 13266                                  ;----------------------------------------------------------------------------
 13267                                  ;
 13268                                  ;   $FCB_Seq_Write - retrieve the next record from an FCB and write it to the
 13269                                  ;	file
 13270                                  ;
 13271                                  ;   Inputs:	DS:DX point to an FCB
 13272                                  ;   Outputs:	AL = error codes defined above
 13273                                  ;
 13274                                  ;----------------------------------------------------------------------------
 13275                                  
 13276                                  _$FCB_SEQ_WRITE:
 13277 00002CEF B000                    	MOV	AL,0
 13278 00002CF1 E956FD                  	jmp	FCBIO
 13279                                  
 13280                                  ;BREAK <$FCB_Random_Read - Read a single record from a file >
 13281                                  ;----------------------------------------------------------------------------
 13282                                  ;
 13283                                  ;   $FCB_Random_Read - retrieve a location from the FCB, seek to it and read a
 13284                                  ;	record from it.
 13285                                  ;
 13286                                  ;   Inputs:	DS:DX point to an FCB
 13287                                  ;   Outputs:	AL = error codes defined above
 13288                                  ;
 13289                                  ;----------------------------------------------------------------------------
 13290                                  
 13291                                  _$FCB_RANDOM_READ:
 13292                                  	;mov	AL,6	
 13293 00002CF4 B006                    	MOV	AL,RANDOM+FCBREAD
 13294 00002CF6 E951FD                  	jmp	FCBIO			; single block
 13295                                  
 13296                                  ;BREAK <$FCB_Random_Write - write a single record to a file >
 13297                                  ;----------------------------------------------------------------------------
 13298                                  ;
 13299                                  ;   $FCB_Random_Write - retrieve a location from the FCB, seek to it and write
 13300                                  ;	a record to it.
 13301                                  ;
 13302                                  ;   Inputs:	DS:DX point to an FCB
 13303                                  ;   Outputs:	AL = error codes defined above
 13304                                  ;
 13305                                  ;----------------------------------------------------------------------------
 13306                                  
 13307                                  _$FCB_RANDOM_WRITE:
 13308                                  	;mov	AL,2	
 13309 00002CF9 B002                    	MOV	AL,RANDOM
 13310 00002CFB E94CFD                  	jmp	FCBIO
 13311                                  
 13312                                  ;============================================================================
 13313                                  ; SEARCH.ASM, MSDOS 6.0, 1991
 13314                                  ;============================================================================
 13315                                  ; 22/07/2018 - Retro DOS v3.0
 13316                                  
 13317                                  ;**	Search.asm
 13318                                  ;
 13319                                  ;	Directory search system calls.
 13320                                  ;	These will be passed direct text of the pathname from the user. 
 13321                                  ;	They will need to be passed through the macro expander prior to
 13322                                  ;	being sent through the low-level stuff. 
 13323                                  ;	I/O specs are defined in DISPATCH. The system calls are:
 13324                                  ;
 13325                                  ;	$Dir_Search_First	  written
 13326                                  ;	$Dir_Search_Next	  written
 13327                                  ;	$Find_First	  written
 13328                                  ;	$Find_Next		  written
 13329                                  ;	PackName		  written
 13330                                  ;
 13331                                  ;	Modification history:
 13332                                  ;
 13333                                  ;	  Created: ARR 4 April 1983
 13334                                  
 13335                                  ;----------------------------------------------------------------------------
 13336                                  ; Procedure Name : $DIR_SEARCH_FIRST
 13337                                  ;
 13338                                  ; Inputs:
 13339                                  ;	DS:DX Points to unopenned FCB
 13340                                  ; Function:
 13341                                  ;	Directory is searched for first matching entry and the directory
 13342                                  ;	entry is loaded at the disk transfer address
 13343                                  ; Returns:
 13344                                  ;	AL = -1 if no entries matched, otherwise 0
 13345                                  ;----------------------------------------------------------------------------
 13346                                  
 13347                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 2B88h
 13348                                  
 13349                                  _$DIR_SEARCH_FIRST:
 13350 00002CFE 368916[6205]            	MOV	[SS:THISFCB],DX
 13351 00002D03 368C1E[6405]            	MOV	[SS:THISFCB+2],DS
 13352 00002D08 89D6                    	MOV	SI,DX
 13353 00002D0A 803CFF                  	CMP	BYTE [SI],0FFH
 13354 00002D0D 7503                    	JNZ	short NORMFCB4
 13355 00002D0F 83C607                  	ADD	SI,7			; Point to drive select byte
 13356                                  NORMFCB4:
 13357 00002D12 FF34                    	push	word [SI]		; Save original drive byte for later
 13358                                  
 13359 00002D14 16                      	push	ss
 13360 00002D15 07                      	pop	es			; get es to address DOSGroup
 13361                                  
 13362 00002D16 BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 13363 00002D19 E81240                  	call	TransFCB		; convert the FCB, set SATTRIB EXTFCB
 13364 00002D1C 7304                    	JNC	short SearchIt		; no error, go and look
 13365 00002D1E 5B                      	pop	bx			; Clean stack
 13366                                  ;
 13367                                  ; Error code is in AX
 13368                                  ;
 13369 00002D1F E998EA                  	jmp	FCB_RET_ERR		; error
 13370                                  
 13371                                  SearchIt:
 13372 00002D22 16                      	push	ss
 13373 00002D23 1F                      	pop	ds			; get ready for search
 13374 00002D24 FF36[F802]              	push	word [DMAADD]
 13375 00002D28 FF36[FA02]              	push	word [DMAADD+2]
 13376 00002D2C C706[F802][8204]        	MOV	WORD [DMAADD],SEARCHBUF
 13377 00002D32 8C1E[FA02]              	MOV	WORD [DMAADD+2],DS
 13378                                  	; MSDOS 6.0
 13379                                  	;call	GET_FAST_SEARCH 	; search
 13380                                  	; MSDOS 3.3
 13381 00002D36 E84E0C                  	call	DOS_SEARCH_FIRST
 13382 00002D39 8F06[FA02]              	pop	word [DMAADD+2]
 13383 00002D3D 8F06[F802]              	pop	word [DMAADD]
 13384 00002D41 7304                    	JNC	short SearchSet		; no error, transfer info
 13385 00002D43 5B                      	pop	bx			; Clean stack
 13386                                  ;
 13387                                  ; Error code is in AX
 13388                                  ;
 13389 00002D44 E973EA                  	jmp	FCB_RET_ERR
 13390                                  
 13391                                  ;
 13392                                  ; The search was successful (or the search-next). We store the information
 13393                                  ; into the user's FCB for continuation.
 13394                                  ;
 13395                                  SearchSet:
 13396 00002D47 BE[8204]                	MOV	SI,SEARCHBUF
 13397 00002D4A C43E[6205]              	LES	DI,[THISFCB]		; point to the FCB
 13398 00002D4E F606[2905]FF            	TEST	byte [EXTFCB],0FFh		;
 13399 00002D53 7403                    	JZ	short NORMFCB1
 13400 00002D55 83C707                  	ADD	DI,7			; Point past the extension
 13401                                  NORMFCB1:
 13402 00002D58 5B                      	pop	bx			; Get original drive byte
 13403 00002D59 08DB                    	OR	BL,BL
 13404 00002D5B 7506                    	JNZ	short SearchDrv
 13405 00002D5D 8A1E[0203]              	MOV	BL,[CURDRV]
 13406 00002D61 FEC3                    	INC	BL
 13407                                  SearchDrv:
 13408 00002D63 AC                      	LODSB				; Get correct search contin drive byte
 13409 00002D64 86C3                    	XCHG	AL,BL			; Search byte to BL, user byte to AL
 13410 00002D66 47                      	INC	DI
 13411                                  	;STOSB				; Store the correct "user" drive byte
 13412                                  					;  at the start of the search info
 13413 00002D67 B90A00                  	MOV	CX,20/2
 13414 00002D6A F3A5                    	REP	MOVSW			; Rest of search cont info, SI -> entry
 13415 00002D6C 86C3                    	XCHG	AL,BL			; User drive byte back to BL, search
 13416                                  					;   byte to AL
 13417 00002D6E AA                      	STOSB				; Search contin drive byte at end of
 13418                                  					;   contin info
 13419 00002D6F C43E[F802]              	LES	DI,[DMAADD]
 13420 00002D73 F606[2905]FF            	TEST	byte [EXTFCB],0FFh
 13421 00002D78 740E                    	JZ	short NORMFCB2
 13422 00002D7A B0FF                    	MOV	AL,0FFh
 13423 00002D7C AA                      	STOSB
 13424 00002D7D FEC0                    	INC	AL
 13425 00002D7F B90500                  	MOV	CX,5
 13426 00002D82 F3AA                    	REP	STOSB
 13427 00002D84 A0[2A05]                	MOV	AL,[SATTRIB]
 13428 00002D87 AA                      	STOSB
 13429                                  NORMFCB2:
 13430 00002D88 88D8                    	MOV	AL,BL			; User Drive byte
 13431 00002D8A AA                      	STOSB
 13432 00002D8B B91000                  	MOV	CX,16			; 32 / 2 words of dir entry
 13433 00002D8E F3A5                    	REP	MOVSW
 13434 00002D90 E924EA                  	jmp	FCB_RET_OK
 13435                                  
 13436                                  ;----------------------------------------------------------------------------
 13437                                  ;
 13438                                  ; Procedure Name : $DIR_SEARCH_NEXT
 13439                                  ;
 13440                                  ; Inputs:
 13441                                  ;	DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
 13442                                  ; Function:
 13443                                  ;	Directory is searched for the next matching entry and the directory
 13444                                  ;	entry is loaded at the disk transfer address
 13445                                  ; Returns:
 13446                                  ;	AL = -1 if no entries matched, otherwise 0
 13447                                  ;----------------------------------------------------------------------------
 13448                                  
 13449                                  _$DIR_SEARCH_NEXT:
 13450 00002D93 368916[6205]            	MOV	[SS:THISFCB],DX
 13451 00002D98 368C1E[6405]            	MOV	[SS:THISFCB+2],DS
 13452 00002D9D 36C606[2A05]00          	MOV	byte [SS:SATTRIB],0
 13453 00002DA3 36C606[2905]00          	MOV	byte [SS:EXTFCB],0
 13454                                  
 13455 00002DA9 16                      	push	ss
 13456 00002DAA 07                      	pop	es
 13457                                  
 13458 00002DAB BF[8204]                	MOV	DI,SEARCHBUF
 13459                                  
 13460 00002DAE 89D6                    	MOV	SI,DX
 13461 00002DB0 803CFF                  	CMP	BYTE [SI],0FFh
 13462 00002DB3 750D                    	JNZ	short NORMFCB6
 13463 00002DB5 83C606                  	ADD	SI,6
 13464 00002DB8 AC                      	LODSB
 13465                                  
 13466 00002DB9 36A2[2A05]              	MOV	[SS:SATTRIB],AL
 13467 00002DBD 36FE0E[2905]            	DEC	byte [SS:EXTFCB]
 13468                                  NORMFCB6:
 13469 00002DC2 AC                      	LODSB				; Get original user drive byte
 13470 00002DC3 50                      	push	ax			; Put it on stack
 13471 00002DC4 8A4414                  	MOV	AL,[SI+20]		; Get correct search contin drive byte
 13472 00002DC7 AA                      	STOSB				; Put in correct place
 13473 00002DC8 B90A00                  	MOV	CX,20/2
 13474 00002DCB F3A5                    	REP	MOVSW			; Transfer in rest of search contin info
 13475                                  
 13476 00002DCD 16                      	push	ss
 13477 00002DCE 1F                      	pop	ds
 13478                                  
 13479 00002DCF FF36[F802]              	push	word [DMAADD]
 13480 00002DD3 FF36[FA02]              	push	word [DMAADD+2]
 13481 00002DD7 C706[F802][8204]        	MOV	WORD [DMAADD],SEARCHBUF
 13482 00002DDD 8C1E[FA02]              	MOV	WORD [DMAADD+2],DS
 13483 00002DE1 E8580C                  	call	DOS_SEARCH_NEXT 	; Find it
 13484 00002DE4 8F06[FA02]              	pop	word [DMAADD+2]
 13485 00002DE8 8F06[F802]              	pop	word [DMAADD]
 13486 00002DEC 7203                    	JC	short SearchNoMore
 13487 00002DEE E956FF                  	JMP	SearchSet		; Ok set return
 13488                                  
 13489                                  SearchNoMore:
 13490 00002DF1 C43E[6205]              	LES	DI,[THISFCB]
 13491 00002DF5 F606[2905]FF            	TEST	byte [EXTFCB],0FFh
 13492 00002DFA 7403                    	JZ	short NORMFCB8
 13493 00002DFC 83C707                  	ADD	DI,7			; Point past the extension
 13494                                  NORMFCB8:
 13495 00002DFF 5B                      	pop	bx			; Get original drive byte
 13496 00002E00 26881D                  	MOV	[ES:DI],BL		; Store the correct "user" drive byte
 13497                                  					;  at the right spot
 13498                                  ;
 13499                                  ; error code is in AX
 13500                                  ;
 13501 00002E03 E9B4E9                  	jmp	FCB_RET_ERR
 13502                                  
 13503                                  ;---------------------------------------------------------------------------
 13504                                  ;
 13505                                  ;   Procedure Name : $FIND_FIRST
 13506                                  ; 
 13507                                  ;   Assembler usage:
 13508                                  ;	    MOV AH, FindFirst
 13509                                  ;	    LDS DX, name
 13510                                  ;	    MOV CX, attr
 13511                                  ;	    INT 21h
 13512                                  ;	; DMA address has datablock
 13513                                  ;
 13514                                  ;   Error Returns:
 13515                                  ;	    AX = error_path_not_found
 13516                                  ;	       = error_no_more_files
 13517                                  ;---------------------------------------------------------------------------
 13518                                  
 13519                                  _$FIND_FIRST:
 13520 00002E06 89D6                    	MOV	SI,DX			; get name in appropriate place
 13521 00002E08 36880E[2A05]            	MOV	[SS:SATTRIB],CL		; Search attribute to correct loc
 13522                                  
 13523 00002E0D BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 13524                                  
 13525 00002E10 E8833F                  	call	TransPathSet		; convert the path
 13526 00002E13 7305                    	JNC	short Find_it 		; no error, go and look
 13527                                  FindError:
 13528                                  	;mov	al,3
 13529 00002E15 B003                    	mov	al, error_path_not_found ; error and map into one.
 13530 00002E17 E98AE9                  	jmp	SYS_RET_ERR
 13531                                  Find_it:
 13532 00002E1A 16                      	push	ss
 13533 00002E1B 1F                      	pop	ds
 13534                                  
 13535 00002E1C FF36[F802]              	push	word [DMAADD]
 13536 00002E20 FF36[FA02]              	push	word [DMAADD+2]
 13537 00002E24 C706[F802][8204]        	MOV	WORD [DMAADD],SEARCHBUF
 13538 00002E2A 8C1E[FA02]              	MOV	WORD [DMAADD+2],DS
 13539                                  	; MSDOS 6.0
 13540                                  	;call	GET_FAST_SEARCH 	; search
 13541                                  	; MSDOS 3.3
 13542 00002E2E E8560B                  	call	DOS_SEARCH_FIRST
 13543 00002E31 8F06[FA02]              	pop	word [DMAADD+2]
 13544 00002E35 8F06[F802]              	pop	word [DMAADD]
 13545 00002E39 7303                    	JNC	short FindSet 		; no error, transfer info
 13546 00002E3B E966E9                  	jmp	SYS_RET_ERR
 13547                                  
 13548                                  FindSet:
 13549 00002E3E BE[8204]                	MOV	SI,SEARCHBUF
 13550 00002E41 C43E[F802]              	LES	DI,[DMAADD]
 13551 00002E45 B91500                  	MOV	CX,21
 13552 00002E48 F3A4                    	REP	MOVSB
 13553 00002E4A 56                      	PUSH	SI			; Save pointer to start of entry
 13554                                  	;mov	al,[si+0Bh]
 13555 00002E4B 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 13556 00002E4E AA                      	STOSB
 13557                                  	;add	si,16h
 13558 00002E4F 83C616                  	ADD	SI,dir_entry.dir_time
 13559 00002E52 A5                      	MOVSW				; dir_time
 13560 00002E53 A5                      	MOVSW				; dir_date
 13561 00002E54 46                      	INC	SI
 13562 00002E55 46                      	INC	SI			; Skip dir_first
 13563 00002E56 A5                      	MOVSW				; dir_size (2 words)
 13564 00002E57 A5                      	MOVSW
 13565 00002E58 5E                      	POP	SI			; Point back to dir_name
 13566 00002E59 E83600                   	CALL	PackName
 13567 00002E5C E93CE9                  	jmp	SYS_RET_OK		; bye with no errors
 13568                                  
 13569                                  ;---------------------------------------------------------------------------
 13570                                  ;
 13571                                  ;   Procedure Name : $FIND_NEXT
 13572                                  ;
 13573                                  ;   Assembler usage:
 13574                                  ;	; dma points at area returned by find_first
 13575                                  ;	    MOV AH, findnext
 13576                                  ;	    INT 21h
 13577                                  ;	; next entry is at dma
 13578                                  ;
 13579                                  ;   Error Returns:
 13580                                  ;	    AX = error_no_more_files
 13581                                  ;---------------------------------------------------------------------------
 13582                                  
 13583                                  _$FIND_NEXT:
 13584 00002E5F 16                      	push	ss
 13585 00002E60 07                      	pop	es
 13586                                  
 13587 00002E61 BF[8204]                	MOV	DI,SEARCHBUF
 13588                                  
 13589 00002E64 36C536[F802]            	LDS	SI,[SS:DMAADD]
 13590                                  
 13591 00002E69 B91500                  	MOV	CX,21
 13592 00002E6C F3A4                    	REP	MOVSB			; Put the search continuation info
 13593                                  					;  in the right place
 13594 00002E6E 16                      	push	ss
 13595 00002E6F 1F                      	pop	ds			; get ready for search
 13596                                  	
 13597 00002E70 FF36[F802]              	push	word [DMAADD]
 13598 00002E74 FF36[FA02]              	push	word [DMAADD+2]
 13599 00002E78 C706[F802][8204]        	MOV	WORD [DMAADD],SEARCHBUF
 13600 00002E7E 8C1E[FA02]              	MOV	WORD [DMAADD+2],DS
 13601 00002E82 E8B70B                  	call	DOS_SEARCH_NEXT 	; Find it
 13602 00002E85 8F06[FA02]              	pop	word [DMAADD+2]
 13603 00002E89 8F06[F802]              	pop	word [DMAADD]
 13604 00002E8D 73AF                    	JNC	short FindSet 		; No error, set info
 13605 00002E8F E912E9                  	jmp	SYS_RET_ERR
 13606                                  
 13607                                  ;---------------------------------------------------------------------------
 13608                                  ;**	PackName - Convert file names from FCB to ASCIZ format.
 13609                                  ;
 13610                                  ;	PackName transfers a file name from DS:SI to ES:DI and converts it to
 13611                                  ;	the ASCIZ format.
 13612                                  ;
 13613                                  ;	ENTRY	(DS:SI) = 11 character FCB or dir entry name
 13614                                  ;		(ES:DI) = destination area (13 bytes)
 13615                                  ;	EXIT	(ds:SI) and (es:DI) advanced
 13616                                  ;	USES	al, CX, SI, DI, Flags  (BUGBUG - not verified - jgl)
 13617                                  ;---------------------------------------------------------------------------
 13618                                  
 13619                                  PackName:
 13620                                  ;	Move over 8 characters to cover the name component, then trim it's
 13621                                  ;	trailing blanks.
 13622                                  
 13623 00002E92 B90800                  	MOV	CX,8			; Pack the name
 13624 00002E95 F3A4                    	REP	MOVSB			; Move all of it
 13625                                  main_kill_tail:
 13626 00002E97 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 13627 00002E9C 7507                    	JNZ	short find_check_dot
 13628 00002E9E 4F                      	DEC	DI			; Back up over trailing space
 13629 00002E9F 41                      	INC	CX
 13630 00002EA0 83F908                  	CMP	CX,8
 13631 00002EA3 72F2                    	JB	short main_kill_tail
 13632                                  find_check_dot:
 13633                                  	;CMP	WORD [SI],(" " << 8) | " "
 13634 00002EA5 813C2020                	cmp     word [si],2020h 
 13635 00002EA9 7506                    	JNZ	short got_ext 		; Some chars in extension
 13636 00002EAB 807C0220                	CMP	BYTE [SI+2]," "
 13637 00002EAF 7412                    	JZ	short find_done		; No extension
 13638                                  got_ext:
 13639 00002EB1 B02E                    	MOV	AL,"."
 13640 00002EB3 AA                      	STOSB
 13641 00002EB4 B90300                  	MOV	CX,3
 13642 00002EB7 F3A4                    	REP	MOVSB
 13643                                  ext_kill_tail:
 13644 00002EB9 26807DFF20              	CMP	BYTE [ES:DI-1]," "
 13645 00002EBE 7503                    	JNZ	short find_done
 13646 00002EC0 4F                      	DEC	DI			; Back up over trailing space
 13647 00002EC1 EBF6                    	JMP	short ext_kill_tail
 13648                                  find_done:
 13649 00002EC3 31C0                    	XOR	AX,AX
 13650 00002EC5 AA                      	STOSB				; NUL terminate
 13651 00002EC6 C3                      	retn
 13652                                  
 13653                                  ;GET_FAST_SEARCH:
 13654                                  ;	; 22/07/2018
 13655                                  ;	; MSDOS 6.0
 13656                                  ;	OR	word [DOS34_FLAG],SEARCH_FASTOPEN 
 13657                                  ;					;FO.trigger fastopen ;AN000;
 13658                                  ;	call	DOS_SEARCH_FIRST
 13659                                  ;	retn
 13660                                  
 13661                                  
 13662                                  ;============================================================================
 13663                                  ; PATH.ASM, MSDOS 6.0, 1991
 13664                                  ;============================================================================
 13665                                  ; 06/08/2018 - Retro DOS v3.0
 13666                                  
 13667                                  ;**	Directory related system calls. These will be passed direct text of the
 13668                                  ;	pathname from the user. They will need to be passed through the macro
 13669                                  ;	expander prior to being sent through the low-level stuff. I/O specs are
 13670                                  ;	defined in DISPATCH. The system calls are:
 13671                                  ;
 13672                                  ;	$CURRENT_DIR  Written
 13673                                  ;	$RMDIR	  Written
 13674                                  ;	$CHDIR	  Written
 13675                                  ;	$MKDIR	  Written
 13676                                  ;
 13677                                  ;
 13678                                  ;	Modification history:
 13679                                  ;
 13680                                  ;	    Created: ARR 4 April 1983
 13681                                  ;		 MZ 10 May 1983     CurrentDir implemented
 13682                                  ;		 MZ 11 May 1983     RmDir, ChDir, MkDir implemented
 13683                                  ;		 EE 19 Oct 1983     RmDir no longer allows you to delete a
 13684                                  ;				    current directory.
 13685                                  ;		 MZ 19 Jan 1983     Brain damaged applications rely on success
 13686                                  
 13687                                  ;	I_Need	ThisCDS,DWORD		; pointer to Current CDS
 13688                                  ;	I_Need	WFP_Start,WORD		; pointer to beginning of directory text
 13689                                  ;	I_Need	Curr_Dir_End,WORD	; offset to end of directory part
 13690                                  ;	I_Need	OpenBuf,128		; temp spot for translated name
 13691                                  ;	I_need	fSplice,BYTE		; TRUE => do splice
 13692                                  ;	I_Need	NoSetDir,BYTE		; TRUE => no exact match on splice
 13693                                  ;	I_Need	cMeta,BYTE
 13694                                  ;	I_Need	DrvErr,BYTE					;AN000;
 13695                                  
 13696                                  
 13697                                  ;BREAK <$CURRENT_DIR - dump the current directory into user space>
 13698                                  ;---------------------------------------------------------------------------
 13699                                  ;
 13700                                  ;   Procedure Name : $CURRENT_DIR
 13701                                  ;
 13702                                  ;   Assembler usage:
 13703                                  ;		LDS	SI,area
 13704                                  ;		MOV	DL,drive
 13705                                  ;		INT	21h
 13706                                  ;	    ; DS:SI is a pointer to 64 byte area that contains drive
 13707                                  ;	    ; current directory.
 13708                                  ;   Error returns:
 13709                                  ;	    AX = error_invalid_drive
 13710                                  ;
 13711                                  ;---------------------------------------------------------------------------
 13712                                  
 13713                                  _$CURRENT_DIR:
 13714                                  	;06/08/2018 - Retro DOS v3.0
 13715                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 2D4Eh
 13716 00002EC7 E843F2                  	call	EcritDisk
 13717 00002ECA 88D0                    	MOV	AL,DL			; get drive number (0=def, 1=A)
 13718 00002ECC E8D13D                  	call	GetVisDrv		; grab it
 13719 00002ECF 7308                    	JNC	short CurrentValidate 	; no error -> go and validate dir
 13720                                  CurdirErr:
 13721 00002ED1 E841F2                  	call	LcritDisk
 13722                                  	
 13723                                  	; MSDOS 6.0
 13724                                  	;MOV	AL,[CS:DrvErr]		;IFS.			;AN000;
 13725                                  
 13726                                  	; MSDOS 3.3
 13727 00002ED4 B00F                    	mov	al,0Fh
 13728                                  
 13729                                  curdir_errj:
 13730 00002ED6 E9CBE8                  	jmp	SYS_RET_ERR		;IFS. make noise	;AN000;
 13731                                  
 13732                                  CurrentValidate:
 13733 00002ED9 1E                      	push	ds		; save destination
 13734 00002EDA 56                      	push	si
 13735 00002EDB 2EC536[5E05]            	LDS	SI,[CS:THISCDS]
 13736                                  	;TEST	word [SI+curdir.flags],curdir_isnet
 13737                                  	;JNZ	short DoCheck
 13738                                  ; Random optimization nuked due to some utilities using GetCurrentDir to do
 13739                                  ; media check.
 13740                                  ;	CMP	word [SI+curdir.ID],0
 13741                                  ;	JZ	short GetDst
 13742                                  DoCheck:
 13743 00002EE0 2EC606[1603]00          	MOV	byte [cs:NoSetDir],0	; interested only in contents
 13744                                  
 13745 00002EE6 BF[8203]                	MOV	DI,OPENBUF
 13746                                  
 13747 00002EE9 E8791E                  	call	ValidateCDS		; output is ES:DI -> CDS
 13748 00002EEC 06                      	push	es	 		; swap source and destination
 13749 00002EED 57                      	push	di
 13750 00002EEE 5E                      	pop	si
 13751 00002EEF 1F                      	pop	ds
 13752                                  GetDst:
 13753 00002EF0 5F                      	pop	di
 13754 00002EF1 07                      	pop	es			; get real destination
 13755 00002EF2 72DD                    	JC	short CurdirErr
 13756                                  	;ADD	SI,curdir.text ; add si,0 ; 09/08/2018
 13757 00002EF4 03744F                  	ADD	SI,[SI+curdir.end]
 13758 00002EF7 803C5C                  	CMP	BYTE [SI],'\'		; root or subdirs present?
 13759 00002EFA 7501                    	JNZ	short CurrentCopy
 13760 00002EFC 46                      	INC	SI
 13761                                  CurrentCopy:
 13762                                  ;	call	FStrCpy
 13763                                  ;; 10/29/86 E5 char
 13764 00002EFD 50                      	PUSH	AX
 13765 00002EFE AC                      	LODSB				; get char
 13766 00002EFF 08C0                    	OR	AL,AL
 13767 00002F01 7413                    	JZ	short FOK
 13768 00002F03 3C05                    	CMP	AL,05
 13769 00002F05 740D                    	JZ	short FCHANGE
 13770 00002F07 EB01                    	JMP	short FFF
 13771                                  FCPYNEXT:
 13772 00002F09 AC                      	LODSB				; get char
 13773                                  FFF:
 13774 00002F0A 3C5C                    	CMP	AL,'\'			; beginning of directory
 13775 00002F0C 7508                    	JNZ	short FOK		; no
 13776 00002F0E AA                      	STOSB				; put into user's buffer
 13777 00002F0F AC                      	LODSB				; 1st char of dir is 05?
 13778 00002F10 3C05                    	CMP	AL,05H
 13779 00002F12 7502                    	JNZ	short FOK		; no
 13780                                  FCHANGE:
 13781 00002F14 B0E5                    	MOV	AL,0E5H			; make it E5
 13782                                  FOK:
 13783 00002F16 AA                      	STOSB				; put into user's buffer
 13784 00002F17 08C0                    	OR	AL,AL			; final char
 13785 00002F19 75EE                    	JNZ	short FCPYNEXT		; no
 13786 00002F1B 58                      	POP	AX
 13787                                  
 13788                                  ;; 10/29/86 E5 char
 13789 00002F1C 30C0                    	xor	AL,AL			; MZ 19 Jan 84
 13790 00002F1E E8F4F1                  	call	LcritDisk
 13791 00002F21 E977E8                  	jmp	SYS_RET_OK		; no more, bye!
 13792                                  
 13793                                  
 13794                                  ;BREAK <$RmDir -- Remove a directory>
 13795                                  ;---------------------------------------------------------------------------
 13796                                  ;
 13797                                  ; Procedure Name : $RmDir
 13798                                  ;
 13799                                  ; Inputs:
 13800                                  ;	DS:DX Points to asciz name
 13801                                  ; Function:
 13802                                  ;	Delete directory if empty
 13803                                  ; Returns:
 13804                                  ;	STD XENIX Return
 13805                                  ;	AX = error_path_not_found If path bad
 13806                                  ;	AX = error_access_denied If
 13807                                  ;		Directory not empty
 13808                                  ;		Path not directory
 13809                                  ;		Root directory specified
 13810                                  ;		Directory malformed (. and .. not first two entries)
 13811                                  ;		User tries to delete a current directory
 13812                                  ;	AX = error_current_directory
 13813                                  ;
 13814                                  ;----------------------------------------------------------------------------
 13815                                  
 13816                                  _$RMDIR:
 13817 00002F24 52                      	push	dx			; Save ptr to name
 13818 00002F25 1E                      	push	ds
 13819 00002F26 89D6                    	mov	si,dx			; Load ptr into si
 13820 00002F28 BF[8203]                	mov	di,OPENBUF		; di = ptr to buf for trans name
 13821 00002F2B 57                      	push	di
 13822 00002F2C E86F3E                  	call	TransPathNoSet		; Translate the name
 13823 00002F2F 5F                      	pop	di			; di = ptr to buf for trans name
 13824 00002F30 7307                    	jnc	short rmlset		; If transpath succeeded, continue
 13825 00002F32 1F                      	pop	ds
 13826 00002F33 5A                      	pop	dx			; Restore the	 name
 13827 00002F34 B003                    	mov	al,error_path_not_found ; Otherwise, return an error
 13828                                  	;jmp	short curdir_errj
 13829                                  rmdir_errj: ; 10/08/2018
 13830 00002F36 E96BE8                  	jmp	SYS_RET_ERR
 13831                                  rmlset:
 13832 00002F39 36803E[3705]FF          	CMP	byte [ss:CMETA],-1	;   if (cMeta >= 0)
 13833 00002F3F 7512                    	Jnz	short rmerr		;	return (-1);
 13834 00002F41 16                      	push	ss
 13835 00002F42 07                      	pop	es
 13836 00002F43 30C0                    	xor	al,al			; al = 0 , ie drive a:
 13837                                  rmloop: 
 13838 00002F45 E8C23D                  	call	GetCDSFromDrv		; Get curdir for drive in al
 13839 00002F48 720F                    	jc	short rmcont		; If error, exit loop & cont normally
 13840 00002F4A E888F0                  	call	StrCmp			; Are the 2 paths the same?
 13841 00002F4D 7404                    	jz	short rmerr		; Yes, report error.
 13842 00002F4F FEC0                    	inc	al			; No, inc al to next drive number
 13843 00002F51 EBF2                    	jmp	short rmloop		; Go check next drive.
 13844                                  rmerr:
 13845 00002F53 1F                      	pop	ds
 13846 00002F54 5A                      	pop	dx			; Restore the name
 13847 00002F55 B010                    	mov	al,error_current_directory ;  error
 13848                                  	;jmp	short curdir_errj
 13849 00002F57 EBDD                    	jmp	short rmdir_errj
 13850                                  rmcont:
 13851 00002F59 1F                      	pop	ds
 13852 00002F5A 5A                      	pop	dx			; Restore the name
 13853 00002F5B BE[EB3D]                	MOV	SI,DOS_RMDIR
 13854 00002F5E EB75                    	JMP	short DoDirCall ; 07/09/2018
 13855                                  
 13856                                  ;BREAK <$ChDir -- Change current directory on a drive>
 13857                                  ;----------------------------------------------------------------------------
 13858                                  ;
 13859                                  ; $ChDir - Top-level change directory system call.  This call is responsible
 13860                                  ; for setting up the CDS for the specified drive appropriately.  There are
 13861                                  ; several cases to consider:
 13862                                  ;
 13863                                  ;   o	Local, simple CDS.  In this case, we take the input path and convert
 13864                                  ;	it into a WFP.	We verify the existance of this directory and then
 13865                                  ;	copy the WFP into the CDS and set up the ID field to point to the
 13866                                  ;	directory cluster.
 13867                                  ;   o	Net CDS.  We form the path from the root (including network prefix)
 13868                                  ;	and verify its existance (via DOS_Chdir).  If successful, we copy the
 13869                                  ;	WFP back into the CDS.
 13870                                  ;   o	SUBST'ed CDS.  This is no different than the local, simple CDS.
 13871                                  ;   o	JOIN'ed CDS.  This is trouble as there are two CDS's at work.  If we
 13872                                  ;	call TransPath, we will get the PHYSICAL CDS that the path refers to
 13873                                  ;	and the PHYSICAL WFP that the input path refers to.  This is perfectly
 13874                                  ;	good for the validation but not for currency.  We call TransPathNoSet
 13875                                  ;	to process the path but to return the logical CDS and the logical
 13876                                  ;	path.  We then copy the logical path into the logical CDS.
 13877                                  ;
 13878                                  ; Inputs:
 13879                                  ;	DS:DX Points to asciz name
 13880                                  ; Returns:
 13881                                  ;	STD XENIX Return
 13882                                  ;	AX = chdir_path_not_found if error
 13883                                  ;
 13884                                  ;----------------------------------------------------------------------------
 13885                                  
 13886                                  _$CHDIR:
 13887 00002F60 BF[8203]                	MOV	DI,OPENBUF		; spot for translated name
 13888 00002F63 89D6                    	MOV	SI,DX			; get source
 13889 00002F65 E82A3E                  	call	TransPath		; go munge the path and get real CDS
 13890 00002F68 7305                    	JNC	short ChDirCrack	; no errors, try path
 13891                                  ChDirErrP:
 13892 00002F6A B003                    	MOV	AL,error_path_not_found
 13893                                  ChDirErr:
 13894 00002F6C E935E8                  	jmp	SYS_RET_ERR 	; oops!
 13895                                  
 13896                                  ChDirCrack:
 13897 00002F6F 803E[3705]FF            	CMP	byte [CMETA],-1		; No meta chars allowed.
 13898 00002F74 75F4                    	JNZ	short ChDirErrP
 13899                                  ;
 13900                                  ; We cannot do a ChDir (yet) on a raw CDS.  This is treated as a path not
 13901                                  ; found.
 13902                                  ;
 13903 00002F76 C43E[5E05]              	LES	DI,[THISCDS]
 13904 00002F7A 83FFFF                  	CMP	DI,-1			;   if (ThisCDS == NULL)
 13905 00002F7D 74EB                    	JZ	short ChDirErrP		;	error ();
 13906                                   ;
 13907                                   ; Find out if the directory exists.
 13908                                   ;
 13909 00002F7F E8340E                  	call	DOS_CHDIR
 13910 00002F82 72E8                    	Jc	short ChDirErr
 13911                                  ;
 13912                                  ; Get back CDS to see if a join as seen.  Set the currency pointer (only if
 13913                                  ; not network).  If one was seen, all we need to do is copy in the text
 13914                                  ;
 13915 00002F84 C43E[5E05]              	LES	DI,[THISCDS]
 13916 00002F88 26F745430020            	TEST	word [ES:DI+curdir.flags],curdir_splice
 13917 00002F8E 7425                    	JZ	short GotCDS
 13918                                  ;
 13919                                  ; The CDS was joined.  Let's go back and grab the logical CDS.
 13920                                  ;
 13921 00002F90 06                      	push	es	
 13922 00002F91 57                      	push	di
 13923 00002F92 51                      	push	cx			; save CDS and cluster...
 13924 00002F93 E8B3E6                  	call	Get_User_Stack		; get original text
 13925 00002F96 8B7C06                  	MOV	DI,[SI+user_env.user_DX]
 13926 00002F99 8E5C0E                  	MOV	DS,[SI+user_env.user_DS]
 13927 00002F9C BE[8203]                	MOV	SI,OPENBUF		; spot for translated name
 13928 00002F9F 87F7                    	XCHG	SI,DI
 13929 00002FA1 30C0                    	XOR	AL,AL			; do no splicing
 13930 00002FA3 57                      	push	di
 13931 00002FA4 E8F73D                  	call	TransPathNoSet		; Munge path
 13932 00002FA7 5E                      	pop	si
 13933                                  ;
 13934                                  ; There should NEVER be an error here.
 13935                                  ;
 13936                                  
 13937                                  ;IF FALSE
 13938                                  ;	JNC SKipErr
 13939                                  ;	fmt <>,<>,<"$p: Internal CHDIR error\n">
 13940                                  ;SkipErr:
 13941                                  ;ENDIF
 13942 00002FA8 C43E[5E05]              	LES	DI,[THISCDS]		; get new CDS
 13943 00002FAC 26C74549FFFF            	MOV	word [ES:DI+curdir.ID],-1
 13944                                  					; no valid cluster here...
 13945 00002FB2 59                      	pop	cx
 13946 00002FB3 5F                      	pop	di
 13947 00002FB4 07                      	pop	es
 13948                                  ;
 13949                                  ; ES:DI point to the physical CDS, CX is the ID (local only)
 13950                                  ;
 13951                                  GotCDS:
 13952                                  ;
 13953                                  ; wfp_start points to the text. See if it is long enough
 13954                                  ;
 13955                                  	; MSDOS 3.3
 13956                                  	;push	ss
 13957                                  	;pop	ds
 13958                                  	;mov	si,[WFP_START]
 13959                                  	;push	cx
 13960                                  	;call	DStrLen
 13961                                  	;cmp	cx,67 ; cmp cx,DIRSTRLEN
 13962                                  	;pop	cx
 13963                                  	;ja	short ChDirErrP
 13964                                  
 13965                                  	; MSDOS 6.0
 13966 00002FB5 E84800                  	CALL	Check_PathLen		;PTM.		;AN000;
 13967 00002FB8 77B0                    	JA	short ChDirErrP
 13968                                  	; MSDOS 3.3 (& MSDOS 6.0)
 13969 00002FBA 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 13970 00002FC0 7508                    	JNZ	short SkipRecency
 13971                                  	; MSDOS 6.0
 13972                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice 
 13973                                  	;				;PTM. for Join and Subst ;AN000;
 13974                                  	;JZ	short setdirclus	;PTM.		;AN000;
 13975                                  	;MOV	CX,-1			;PTM.		;AN000;
 13976                                  ;setdirclus:
 13977 00002FC2 26894D49                	MOV	[ES:DI+curdir.ID],CX
 13978 00002FC6 C43E[5E05]              	LES	DI,[THISCDS]		; get logical CDS
 13979                                  SkipRecency:
 13980 00002FCA E835F0                  	call	FStrCpy
 13981 00002FCD 30C0                    	XOR	AL,AL
 13982                                  mkdir_ok:
 13983 00002FCF E9C9E7                  	jmp	SYS_RET_OK
 13984                                  
 13985                                  
 13986                                  ;BREAK <$MkDir - Make a directory entry>
 13987                                  ;---------------------------------------------------------------------------
 13988                                  ;
 13989                                  ; Procedure Name : $MkDir
 13990                                  ; Inputs:
 13991                                  ;	DS:DX Points to asciz name
 13992                                  ; Function:
 13993                                  ;	Make a new directory
 13994                                  ; Returns:
 13995                                  ;	STD XENIX Return
 13996                                  ;	AX = mkdir_path_not_found if path bad
 13997                                  ;	AX = mkdir_access_denied  If
 13998                                  ;		Directory cannot be created
 13999                                  ;		Node already exists
 14000                                  ;		Device name given
 14001                                  ;		Disk or directory(root) full
 14002                                  ;---------------------------------------------------------------------------
 14003                                  
 14004                                  _$MKDIR:
 14005 00002FD2 BE[C93C]                	MOV	SI,DOS_MKDIR
 14006                                  DoDirCall:
 14007 00002FD5 BF[8203]                	MOV	DI,OPENBUF		; spot for translated name
 14008                                  
 14009 00002FD8 56                      	push	si
 14010 00002FD9 89D6                    	MOV	SI,DX			; get source
 14011 00002FDB E8B43D                  	call	TransPath		; go munge the path
 14012 00002FDE 5E                      	pop	si
 14013 00002FDF 7305                    	JNC	short MkDirCrack	; no errors, try path
 14014                                  MkErrP:
 14015 00002FE1 B003                    	MOV	AL,error_path_not_found	; oops!
 14016                                  MkErr:
 14017 00002FE3 E9BEE7                  	jmp	SYS_RET_ERR
 14018                                  MkDirCrack:
 14019 00002FE6 36803E[3705]FF          	CMP	byte [SS:CMETA],-1
 14020 00002FEC 75F3                    	JNZ	short MkErrP
 14021                                  
 14022                                  	; MSDOS 3.3
 14023                                  	;push	ss
 14024                                  	;pop	ds
 14025                                  	;call	si
 14026                                  	;jb	short MkErr
 14027                                  	;;jmp	short mkdir_ok
 14028                                  	;jmp	SYS_RET_OK
 14029                                  
 14030                                  	; MSDOS 6.0
 14031 00002FEE 56                      	PUSH	SI			;PTM.			;AN000;
 14032 00002FEF E80E00                  	CALL	Check_PathLen		;PTM. check path len > 67 ? ;AN000;
 14033 00002FF2 5E                      	POP	SI			;PTM.			;AN000;
 14034 00002FF3 7604                    	JBE	short pathok		;PTM.			;AN000;
 14035 00002FF5 B005                    	MOV	AL,error_access_denied	;PTM. ops!
 14036                                  	;jmp	SYS_RET_ERR		;PTM.
 14037 00002FF7 EBEA                    	jmp	short MkErr
 14038                                  pathok:
 14039 00002FF9 FFD6                    	CALL	SI			; go get file
 14040 00002FFB 72E6                    	JC	short MkErr		; no errors
 14041                                  	;jmp	short mkdir_ok
 14042 00002FFD E99BE7                  	jmp	SYS_RET_OK
 14043                                  
 14044                                  ;----------------------------------------------------------------------------
 14045                                  ;
 14046                                  ; Procedure Name : Check_PathLen
 14047                                  ;
 14048                                  ; Inputs:
 14049                                  ;	nothing
 14050                                  ; Function:
 14051                                  ;	check if final path length greater than 67
 14052                                  ; Returns:
 14053                                  ;	Above flag set if > 67
 14054                                  ;
 14055                                  ;---------------------------------------------------------------------------
 14056                                  
 14057                                  Check_PathLen:
 14058                                  	; 09/09/2018
 14059                                  	;;MOV	SI,[WFP_START]
 14060                                  	;MOV	SI,[SS:WFP_START] ; MSDOS 6.0
 14061                                  ;check_PathLen2:
 14062 00003000 16                      	push	ss
 14063 00003001 1F                      	pop	ds
 14064 00003002 8B36[6E05]              	mov	SI,[WFP_START] ; MSDOS 3.3
 14065 00003006 51                      	push	CX	
 14066 00003007 E80FF0                  	CALL	DStrLen
 14067 0000300A 83F943                  	CMP	CX,DIRSTRLEN
 14068 0000300D 59                      	POP	CX
 14069 0000300E C3                      	retn
 14070                                  
 14071                                  ;============================================================================
 14072                                  ; IOCTL.ASM, MSDOS 6.0, 1991
 14073                                  ;============================================================================
 14074                                  ; 07/08/2018 - Retro DOS v3.0
 14075                                  
 14076                                  ;**	IOCTL system call.
 14077                                  ;
 14078                                  ;	$IOCTL
 14079                                  ;
 14080                                  ;	  Revision history:
 14081                                  ;
 14082                                  ;		Created: ARR 4 April 1983
 14083                                  ;
 14084                                  ;		GenericIOCTL added:		KGS	22 April 1985
 14085                                  ;
 14086                                  ;		A000	version 4.00	Jan. 1988
 14087                                  ;
 14088                                  ;		Used jump table to dispatch IOCTL functions. HKN 3/12/90
 14089                                  ;
 14090                                  
 14091                                  ;BREAK <IOCTL - munge on a handle to do device specific stuff>
 14092                                  ;---------------------------------------------------------------------------
 14093                                  ;
 14094                                  ;   Assembler usage:
 14095                                  ;	    MOV     BX, Handle
 14096                                  ;	    MOV     DX, Data
 14097                                  ;
 14098                                  ;	(or LDS     DX,BUF
 14099                                  ;	    MOV     CX,COUNT)
 14100                                  ;
 14101                                  ;	    MOV     AH, Ioctl
 14102                                  ;	    MOV     AL, Request
 14103                                  ;	    INT     21h
 14104                                  ;
 14105                                  ;   AH = 0  Return a combination of low byte of sf_flags and device driver
 14106                                  ;	    attribute word in DX, handle in BX:
 14107                                  ;	    DH = high word of device driver attributes
 14108                                  ;	    DL = low byte of sf_flags
 14109                                  ;	 1  Set the bits contained in DX to sf_flags.  DH MUST be 0.  Handle
 14110                                  ;	    in BX.
 14111                                  ;	 2  Read CX bytes from the device control channel for handle in BX
 14112                                  ;	    into DS:DX.  Return number read in AX.
 14113                                  ;	 3  Write CX bytes to the device control channel for handle in BX from
 14114                                  ;	    DS:DX.  Return bytes written in AX.
 14115                                  ;	 4  Read CX bytes from the device control channel for drive in BX
 14116                                  ;	    into DS:DX.  Return number read in AX.
 14117                                  ;	 5  Write CX bytes to the device control channel for drive in BX from
 14118                                  ;	    DS:DX.  Return bytes written in AX.
 14119                                  ;	 6  Return input status of handle in BX. If a read will go to the
 14120                                  ;	    device, AL = 0FFh, otherwise 0.
 14121                                  ;	 7  Return output status of handle in BX. If a write will go to the
 14122                                  ;	    device, AL = 0FFh, otherwise 0.
 14123                                  ;	 8  Given a drive in BX, return 1 if the device contains non-
 14124                                  ;	    removable media, 0 otherwise.
 14125                                  ;	 9  Return the contents of the device attribute word in DX for the
 14126                                  ;	    drive in BX.  0200h is the bit for shared.	1000h is the bit for
 14127                                  ;	    network. 8000h is the bit for local use.
 14128                                  ;	 A  Return 8000h if the handle in BX is for the network or not.
 14129                                  ;	 B  Change the retry delay and the retry count for the system. BX is
 14130                                  ;	    the count and CX is the delay.
 14131                                  ;
 14132                                  ;   Error returns:
 14133                                  ;	    AX = error_invalid_handle
 14134                                  ;	       = error_invalid_function
 14135                                  ;	       = error_invalid_data
 14136                                  ;
 14137                                  ;-------------------------------------------------------------------------------
 14138                                  ;
 14139                                  ;   This is the documentation copied from DOS 4.0 it is much better
 14140                                  ;   than the above
 14141                                  ;
 14142                                  ;	There are several basic forms of IOCTL calls:
 14143                                  ;
 14144                                  ;
 14145                                  ;	** Get/Set device information:	**
 14146                                  ;
 14147                                  ;	ENTRY	(AL) = function code
 14148                                  ;		  0 - Get device information
 14149                                  ;		  1 - Set device information
 14150                                  ;		(BX) = file handle
 14151                                  ;		(DX) = info for "Set Device Information"
 14152                                  ;	EXIT	'C' set if error
 14153                                  ;		  (AX) = error code
 14154                                  ;		'C' clear if OK
 14155                                  ;		  (DX) = info for "Get Device Information"
 14156                                  ;	USES	ALL
 14157                                  ;
 14158                                  ;
 14159                                  ;	**  Read/Write Control Data From/To Handle  **
 14160                                  ;
 14161                                  ;	ENTRY	(AL) = function code
 14162                                  ;		  2 - Read device control info
 14163                                  ;		  3 - Write device control info
 14164                                  ;		(BX) = file handle
 14165                                  ;		(CX) = transfer count
 14166                                  ;		(DS:DX) = address for data
 14167                                  ;	EXIT	'C' set if error
 14168                                  ;		  (AX) = error code
 14169                                  ;		'C' clear if OK
 14170                                  ;		  (AX) = count of bytes transfered
 14171                                  ;	USES	ALL
 14172                                  ;
 14173                                  ;
 14174                                  ;	**  Read/Write Control Data From/To Block Device  **
 14175                                  ;
 14176                                  ;	ENTRY	(AL) = function code
 14177                                  ;		  4 - Read device control info
 14178                                  ;		  5 - Write device control info
 14179                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 14180                                  ;		(CX) = transfer count
 14181                                  ;		(DS:DX) = address for data
 14182                                  ;	EXIT	'C' set if error
 14183                                  ;		  (AX) = error code
 14184                                  ;		'C' clear if OK
 14185                                  ;		  (AX) = count of bytes transfered
 14186                                  ;	USES	ALL
 14187                                  ;
 14188                                  ;
 14189                                  ;	**  Get Input/Output Status  **
 14190                                  ;
 14191                                  ;	ENTRY	(AL) = function code
 14192                                  ;		  6 - Get Input status
 14193                                  ;		  7 - Get Output Status
 14194                                  ;		(BX) = file handle
 14195                                  ;	EXIT	'C' set if error
 14196                                  ;		  (AX) = error code
 14197                                  ;		'C' clear if OK
 14198                                  ;		  (AL) = 00 if not ready
 14199                                  ;		  (AL) = FF if ready
 14200                                  ;	USES	ALL
 14201                                  ;
 14202                                  ;
 14203                                  ;	**  Get Drive Information  **
 14204                                  ;
 14205                                  ;	ENTRY	(AL) = function code
 14206                                  ;		  8 - Check for removable media
 14207                                  ;		  9 - Get device attributes
 14208                                  ;		(BL) = Drive number (0=default, 1='A', 2='B', etc)
 14209                                  ;	EXIT	'C' set if error
 14210                                  ;		  (AX) = error code
 14211                                  ;		'C' clear if OK
 14212                                  ;		  (AX) = 0/1 media is removable/fixed (func. 8)
 14213                                  ;		  (DX) = device attribute word (func. 9)
 14214                                  ;	USES	ALL
 14215                                  ;
 14216                                  ;
 14217                                  ;	**  Get Redirected bit	**
 14218                                  ;
 14219                                  ;	ENTRY	(AL) = function code
 14220                                  ;		  0Ah - Network stuff
 14221                                  ;		(BX) = file handle
 14222                                  ;	EXIT	'C' set if error
 14223                                  ;		  (AX) = error code
 14224                                  ;		'C' clear if OK
 14225                                  ;		  (DX) = SFT flags word, 8000h set if network file
 14226                                  ;	USES	ALL
 14227                                  ;
 14228                                  ;
 14229                                  ;	**  Change sharer retry parameters  **
 14230                                  ;
 14231                                  ;	ENTRY	(AL) = function code
 14232                                  ;		  0Bh - Set retry parameters
 14233                                  ;		(CX) = retry loop count
 14234                                  ;		(DX) = number of retries
 14235                                  ;	EXIT	'C' set if error
 14236                                  ;		  (AX) = error code
 14237                                  ;		'C' clear if OK
 14238                                  ;	USES	ALL
 14239                                  ;
 14240                                  ;
 14241                                  ;   =================================================================
 14242                                  ;
 14243                                  ;	**  New Standard Control  **
 14244                                  ;
 14245                                  ;	ALL NEW IOCTL FACILITIES SHOULD USE THIS FORM.	THE OTHER
 14246                                  ;	FORMS ARE OBSOLETE.
 14247                                  ;
 14248                                  ;   =================================================================
 14249                                  ;
 14250                                  ;	ENTRY	(AL) = function code
 14251                                  ;		  0Ch - Control Function subcode
 14252                                  ;		(BX) = File Handle
 14253                                  ;		(CH) = Category Indicator
 14254                                  ;		(CL) = Function within category
 14255                                  ;		(DS:DX) = address for data, if any
 14256                                  ;		(SI) = Passed to device as argument, use depends upon function
 14257                                  ;		(DI) = Passed to device as argument, use depends upon function
 14258                                  ;	EXIT	'C' set if error
 14259                                  ;		  (AX) = error code
 14260                                  ;		'C' clear if OK
 14261                                  ;		  (SI) = Return value, meaning is function dependent
 14262                                  ;		  (DI) = Return value, meaning is function dependent
 14263                                  ;		  (DS:DX) = Return address, use is function dependent
 14264                                  ;	USES	ALL
 14265                                  ;
 14266                                  ;    ============== Generic IOCTL Definitions for DOS 3.2 ============
 14267                                  ;     (See inc\ioctl.inc for more info)
 14268                                  ;
 14269                                  ;	ENTRY	(AL) = function code
 14270                                  ;		  0Dh - Control Function subcode
 14271                                  ;		(BL) = Drive Number (0 = Default, 1= 'A')
 14272                                  ;		(CH) = Category Indicator
 14273                                  ;		(CL) = Function within category
 14274                                  ;		(DS:DX) = address for data, if any
 14275                                  ;		(SI) = Passed to device as argument, use depends upon function
 14276                                  ;		(DI) = Passed to device as argument, use depends upon function
 14277                                  ;
 14278                                  ;	EXIT	'C' set if error
 14279                                  ;		  (AX) = error code
 14280                                  ;		'C' clear if OK
 14281                                  ;		  (DS:DX) = Return address, use is function dependent
 14282                                  ;	USES	ALL
 14283                                  ;
 14284                                  ;---------------------------------------------------------------------------
 14285                                  	
 14286                                  	; MSDOS 6.0
 14287                                  IOCTLJMPTABLE:	;label	word
 14288                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14289 0000300F [4730]                  	dw	ioctl_getset_data	; 0
 14290 00003011 [4730]                  	dw	ioctl_getset_data   	; 1
 14291 00003013 [9730]                  	dw	ioctl_control_string	; 2
 14292 00003015 [9730]                  	dw	ioctl_control_string	; 3
 14293 00003017 [EB31]                  	dw	ioctl_get_dev		; 4
 14294 00003019 [EB31]                  	dw	ioctl_get_dev		; 5
 14295 0000301B [B230]                  	dw	ioctl_status		; 6
 14296 0000301D [B230]                  	dw	ioctl_status		; 7
 14297 0000301F [4731]                  	dw	ioctl_rem_media		; 8
 14298 00003021 [8531]                  	dw	Ioctl_Drive_attr	; 9
 14299 00003023 [DA31]                  	dw	IOCTL_Handle_Redir	; A
 14300 00003025 [D130]                  	dw	Set_Retry_Parameters	; B
 14301 00003027 [E030]                  	dw	GENERICIOCTLHANDLE	; C
 14302 00003029 [F730]                  	dw	GENERICIOCTL		; D
 14303                                  	; MSDOS 6.0 (& MSDOS 3.3)
 14304 0000302B [9A32]                  	dw	ioctl_drive_owner	; E
 14305 0000302D [9A32]                  	dw	ioctl_drive_owner	; F
 14306                                  	; MSDOS 6.0
 14307                                  	;dw	query_handle_support	; 10h
 14308                                  	;dw	query_device_support	; 11h
 14309                                  
 14310                                  _$IOCTL:
 14311 0000302F 8CDE                    	MOV	SI,DS			; Stash DS for calls 2,3,4 and 5
 14312 00003031 16                      	push	ss
 14313 00003032 1F                      	pop	ds			;hkn; SS is DOSDATA
 14314                                  
 14315                                  	; MSDOS 3.3
 14316 00003033 3C0F                    	cmp	al,0Fh 
 14317                                  	; MSDOS 6.0
 14318                                  	;cmp	al,11h			; al must be between 0 & 11h
 14319 00003035 770D                    	ja	short ioctl_bad_funj2	; if not bad function #
 14320                                  
 14321                                  	; 09/09/2018
 14322                                  	;push	AX			; Need to save AL for generic IOCTL
 14323 00003037 89C7                    	mov	di,ax			; di NOT a PARM
 14324 00003039 81E7FF00                	and	di,0FFh			; di = al
 14325 0000303D D1E7                    	shl	di,1			; di = index into jmp table
 14326                                  	;pop	AX			; Restore AL for generic IOCTL
 14327                                  
 14328 0000303F 2EFFA5[0F30]            	jmp	word [CS:DI+IOCTLJMPTABLE]
 14329                                  
 14330                                  
 14331                                  ioctl_bad_funj2:
 14332 00003044 E9F800                  	JMP	ioctl_bad_fun  ; 10/08/2018
 14333                                  
 14334                                  ;--------------------------------------------------------------------------
 14335                                  ;
 14336                                  ; IOCTL: AL= 0,1
 14337                                  ;
 14338                                  ; ENTRY : DS = DOSDATA
 14339                                  ;
 14340                                  ;--------------------------------------------------------------------------
 14341                                  
 14342                                  ioctl_getset_data:
 14343                                  	; MSDOS 6.0
 14344 00003047 E8F93A                  	call	SFFromHandle		; ES:DI -> SFT
 14345 0000304A 7305                    	JNC	short ioctl_check_permissions ; have valid handle
 14346                                  ioctl_bad_handle:
 14347 0000304C B006                    	mov	al,error_invalid_handle
 14348                                  ioctl_error:
 14349 0000304E E953E7                  	jmp	SYS_RET_ERR
 14350                                  
 14351                                  ioctl_check_permissions:
 14352 00003051 3C00                    	CMP	AL,0
 14353 00003053 268A4505                	MOV	AL,[ES:DI+SF_ENTRY.sf_flags]; Get low byte of flags
 14354 00003057 741B                    	JZ	short ioctl_read	; read the byte
 14355                                  
 14356 00003059 08F6                    	or	dh, dh
 14357 0000305B 7404                    	JZ	short ioctl_check_device ; can I set with this data?
 14358 0000305D B00D                    	mov	al,error_invalid_data	; no DH <> 0
 14359                                  	;jmp	SYS_RET_ERR
 14360 0000305F EBED                    	jmp	short ioctl_error
 14361                                  
 14362                                  ioctl_check_device:
 14363 00003061 A880                    	test	AL,devid_device 	; can I set this handle?
 14364 00003063 74DF                    	jz	short ioctl_bad_funj2
 14365 00003065 80CA80                  	OR	DL,devid_device 	; Make sure user doesn't turn off the
 14366                                  					;   device bit!! He can muck with the
 14367                                  					;   others at will.
 14368 00003068 C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 14369 0000306D 26885505                	MOV	BYTE [ES:DI+SF_ENTRY.sf_flags],DL  ;AC000;MS.; Set flags
 14370                                  
 14371                                  ioctl_ok:
 14372 00003071 E927E7                  	jmp	SYS_RET_OK
 14373                                  
 14374                                  ioctl_read:
 14375 00003074 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 14376 00003079 30E4                    	XOR	AH,AH
 14377 0000307B A880                    	test	AL,devid_device 	; Should I set high byte
 14378 0000307D 740D                    	JZ	short ioctl_no_high	; no
 14379 0000307F C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 14380 00003084 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 14381 00003088 268A6505                	MOV	AH,[ES:DI+SYSDEV.ATT+1] ; Get high byte
 14382                                  ioctl_no_high:
 14383 0000308C 89C2                    	MOV	DX,AX
 14384 0000308E E8B8E5                  	call	Get_User_Stack
 14385 00003091 895406                  	MOV	[SI+user_env.user_DX],DX
 14386                                  	;;jmp	SYS_RET_OK
 14387                                  	;jmp	short ioctl_ok
 14388                                  	; 26/07/2019
 14389 00003094 E907E7                  	jmp	SYS_RET_OK_clc
 14390                                  
 14391                                  ;--------------------------------------------------------------------------
 14392                                  ;
 14393                                  ; IOCTL: 2,3
 14394                                  ;
 14395                                  ; ENTRY : DS = DOSDATA
 14396                                  ;	  SI = user's DS
 14397                                  ;
 14398                                  ;--------------------------------------------------------------------------
 14399                                  
 14400                                  ioctl_control_string:
 14401                                  
 14402 00003097 E8A93A                  	call	SFFromHandle		; ES:DI -> SFT
 14403 0000309A 72B0                    	JC	short ioctl_bad_handle	; invalid handle
 14404 0000309C 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device ; can I?
 14405 000030A2 74A0                    	jz	short ioctl_bad_funj2			; No it is a file
 14406 000030A4 C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 14407 000030A9 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get device pointer
 14408 000030AD 30DB                    	XOR	BL,BL			; Unit number of char dev = 0
 14409 000030AF E93E01                  	JMP	ioctl_do_string
 14410                                  
 14411                                  ;--------------------------------------------------------------------------
 14412                                  ;
 14413                                  ; IOCTL: AL = 6,7
 14414                                  ;
 14415                                  ; ENTRY: DS = DOSDATA
 14416                                  ;
 14417                                  ;--------------------------------------------------------------------------
 14418                                  
 14419                                  ioctl_status:
 14420                                  
 14421 000030B2 B401                    	MOV	AH,1
 14422 000030B4 2C06                    	SUB	AL,6			; 6=0,7=1
 14423 000030B6 7402                    	JZ	short ioctl_get_status
 14424 000030B8 B403                    	MOV	AH,3
 14425                                  ioctl_get_status:
 14426 000030BA 50                      	PUSH	AX
 14427 000030BB E8D810                  	call	GET_IO_SFT
 14428 000030BE 58                      	POP	AX
 14429 000030BF 7302                    	JNC	short DO_IOFUNC
 14430 000030C1 EB89                    	JMP	short ioctl_bad_handle	; invalid SFT
 14431                                  
 14432                                  DO_IOFUNC:
 14433 000030C3 E8BF1E                  	call	IOFUNC
 14434 000030C6 88C4                    	MOV	AH,AL
 14435 000030C8 B0FF                    	MOV	AL,0FFH
 14436 000030CA 7502                    	JNZ	short ioctl_status_ret
 14437 000030CC FEC0                    	INC	AL
 14438                                  ioctl_status_ret:
 14439 000030CE E9CAE6                  	jmp	SYS_RET_OK
 14440                                  
 14441                                  ;--------------------------------------------------------------------------
 14442                                  ;
 14443                                  ; IOCTL: AL = B
 14444                                  ;
 14445                                  ; ENTRY: DS = DOSDATA
 14446                                  ;
 14447                                  ;--------------------------------------------------------------------------
 14448                                  
 14449                                  Set_Retry_Parameters:
 14450                                  	; 09/09/2018
 14451 000030D1 890E[1C00]              	MOV	[RetryLoop],CX		; 0 retry loop count allowed
 14452 000030D5 09D2                    	OR	DX,DX			; zero retries not allowed
 14453 000030D7 7466                    	JZ	short ioctl_bad_fun
 14454 000030D9 8916[1A00]              	MOV	[RetryCount],DX		; Set new retry count
 14455                                  doneok:
 14456 000030DD E9BBE6                  	jmp	SYS_RET_OK		; Done
 14457                                  
 14458                                  ;--------------------------------------------------------------------------
 14459                                  ;
 14460                                  ; Generic IOCTL entry point. AL = C, D, 10h, 11h
 14461                                  ;
 14462                                  ;	here we invoke the Generic IOCTL using the IOCTL_Req structure.
 14463                                  ;	SI:DX -> Users Device Parameter Table
 14464                                  ;	IOCALL -> IOCTL_Req structure
 14465                                  ;
 14466                                  ; 	If on entry AL >= IOCTL_QUERY_HANDLE the function is a
 14467                                  ;	QueryIOCtlSupport call ELSE it's a standard generic IOCtl
 14468                                  ;	call.
 14469                                  ;
 14470                                  ; BUGBUG: Don't push anything on the stack between GENERIOCTL: and 
 14471                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14472                                  ;         return address off the stack if the drive is invalid.
 14473                                  ;
 14474                                  ;--------------------------------------------------------------------------
 14475                                  
 14476                                  query_handle_support:	; Entry point for handles
 14477                                  GENERICIOCTLHANDLE:
 14478                                  
 14479 000030E0 E8603A                  	call	SFFromHandle		; Get SFT for device.
 14480 000030E3 725F                    	jc	short ioctl_bad_handlej
 14481                                  
 14482                                  	; 31/07/2019 - Retro DOS v3.2
 14483                                  	;test	word [es:di+5],8000h
 14484                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet	; M031;
 14485                                  	;test	byte [es:di+6],80h
 14486 000030E5 26F6450680              	test	byte [ES:DI+SF_ENTRY.sf_flags+1],(sf_isnet>>8)
 14487 000030EA 7553                    	jnz	short ioctl_bad_fun	; Cannot do this over net.
 14488                                  
 14489 000030EC C606[EF02]04            	mov	byte [EXTERR_LOCUS],errLOC_SerDev
 14490 000030F1 26C47D07                	les	di,[es:di+SF_ENTRY.sf_devptr]	; Get pointer to device.
 14491 000030F5 EB0F                    	jmp	short Do_GenIOCTL
 14492                                  
 14493                                  query_device_support:	; Entry point for devices:
 14494                                  GENERICIOCTL:
 14495                                  
 14496 000030F7 C606[EF02]02            	mov	byte [EXTERR_LOCUS],errLOC_Disk
 14497 000030FC 80FD08                  	cmp	ch,IOC_DC		; Only disk devices are allowed to use
 14498 000030FF 753E                    	jne	short ioctl_bad_fun	; no handles with Generic IOCTL.
 14499                                  
 14500 00003101 E87A01                  	CALL	Check_If_Net		; ES:DI := Get_hdr_block of device in BL
 14501 00003104 7539                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 14502                                  
 14503                                  Do_GenIOCTL:
 14504                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320 ; Can device handle Generic IOCTL funcs
 14505                                  	; 09/09/2018
 14506 00003106 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 14507 0000310B 7432                    	jz	short ioctl_bad_fun
 14508                                  
 14509                                  	; MSDOS 6.0
 14510                                  	;;mov	byte [IOCALL_REQFUNC],19 ; 13h
 14511                                  	;mov	byte [IOCALL_REQFUNC],GENIOCTL ; Assume real Request
 14512                                  	;;cmp	al,10h
 14513                                  	;cmp	AL,IOCTL_QUERY_HANDLE	; See if this is just a query
 14514                                  	;jl	short SetIOCtlBlock
 14515                                  	
 14516                                  	;;TEST	word [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 14517                                  	;;test	byte [es:di+4],80h 
 14518                                  	;TEST	byte [ES:DI+SYSDEV.ATT],IOQUERY ; See if device supports a query
 14519                                  	;jz	short ioctl_bad_fun	; No support for query 
 14520                                  	;
 14521                                  	;;mov	byte [IOCALL_REQFUNC],19h	
 14522                                  	;mov	byte [IOCALL_REQFUNC],IOCTL_QUERY ; Just a query (5.00)
 14523                                  
 14524                                  ;SetIOCtlBlock:
 14525 0000310D 06                      	PUSH	ES			; DEVIOCALL2 expects Device header block
 14526 0000310E 57                      	PUSH	DI			; in DS:SI
 14527                                  					; Setup Generic IOCTL Request Block
 14528 0000310F C606[4603]17            	mov	byte [IOCALL_REQLEN],IOCTL_REQ.size ; 23
 14529                                  	; 07/09/2018 (MSDOS 3.3)
 14530                                  	;mov	byte [IOCALL_REQFUNC],19
 14531 00003114 C606[4803]13            	mov	byte [IOCALL_REQFUNC],GENIOCTL ; 07/09/2018
 14532                                  	;
 14533 00003119 881E[4703]              	MOV	byte [IOCALL_REQUNIT],BL
 14534 0000311D 882E[5303]              	MOV	byte [IOCALL+IOCTL_REQ.MAJORFUNCTION],CH
 14535 00003121 880E[5403]              	MOV	byte [IOCALL+IOCTL_REQ.MINORFUNCTION],CL
 14536 00003125 8936[5503]              	MOV	word [IOCALL+IOCTL_REQ.REG_SI],SI
 14537 00003129 893E[5703]              	MOV	word [IOCALL+IOCTL_REQ.REG_DI],DI
 14538 0000312D 8916[5903]              	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET],DX
 14539 00003131 8936[5B03]              	MOV	word [IOCALL+IOCTL_REQ.GENERICIOCTL_PACKET+2],SI
 14540                                  
 14541                                  ;hkn; IOCALL is in DOSDATA
 14542 00003135 BB[4603]                	MOV	BX,IOCALL
 14543                                  
 14544 00003138 16                      	PUSH	SS
 14545 00003139 07                      	POP	ES
 14546                                  					; DS:SI -> Device header.
 14547 0000313A 5E                      	POP	SI
 14548 0000313B 1F                      	POP	DS
 14549                                  	; 10/08/2018
 14550 0000313C E9EA00                  	jmp	ioctl_do_IO		; Perform Call to device driver
 14551                                  
 14552                                  ioctl_bad_fun:
 14553 0000313F B001                    	mov	al, error_invalid_function  ; 1
 14554 00003141 E960E6                  	jmp	SYS_RET_ERR	
 14555                                  
 14556                                  ioctl_bad_handlej:
 14557 00003144 E905FF                  	jmp	ioctl_bad_handle
 14558                                  
 14559                                  ;---------------------------------------------------------------------------
 14560                                  ;
 14561                                  ; IOCTL AL = 8
 14562                                  ;
 14563                                  ; ENTRY:  DS = DOSDATA
 14564                                  ;
 14565                                  ; BUGBUG: Don't push anything on the stack between ioctl_rem_media: and 
 14566                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14567                                  ;         return address off the stack if the drive is invalid.
 14568                                  ;
 14569                                  ;-------------------------------------------------------------------------
 14570                                  
 14571                                  ioctl_rem_media:
 14572                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14573 00003147 E83401                  	CALL	Check_If_Net
 14574 0000314A 75F3                    	JNZ	short ioctl_bad_fun	; There are no "net devices", and they
 14575                                  					;   certainly don't know how to do this
 14576                                  					;   call.
 14577                                  	; 31/07/2019 - Retro DOS v3.2
 14578                                  	;test	word [es:di+4],800h
 14579                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL ; See if device can
 14580                                  	;test	byte [es:di+5],8
 14581 0000314C 26F6450508              	TEST	byte [es:di+SYSDEV.ATT+1],(DEVOPCL>>8)
 14582 00003151 74EC                    	JZ	short ioctl_bad_fun		; NO
 14583                                  
 14584                                  ;hkn; SS override for IOCALL
 14585 00003153 36C606[4803]0F          	MOV	byte [SS:IOCALL_REQFUNC],DEVRMD
 14586 00003159 B00D                    	MOV	AL,REMHL
 14587 0000315B 88DC                    	MOV	AH,BL			; Unit number
 14588 0000315D 36A3[4603]              	MOV	[SS:IOCALL_REQLEN],AX
 14589 00003161 31C0                    	XOR	AX,AX
 14590 00003163 36A3[4903]              	MOV	[SS:IOCALL_REQSTAT],AX
 14591 00003167 06                      	PUSH	ES
 14592 00003168 1F                      	POP	DS
 14593 00003169 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14594 0000316B 16                      	PUSH	SS
 14595 0000316C 07                      	POP	ES
 14596                                  
 14597                                  ;hkn; IOCALL is in DOSDATA (msconst.asm)
 14598 0000316D BB[4603]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14599 00003170 1E                      	push	ds
 14600 00003171 56                      	push	si
 14601 00003172 E8BD1F                  	call	DEVIOCALL2
 14602 00003175 5E                      	pop	si
 14603 00003176 1F                      	pop	ds
 14604                                  
 14605                                  ;hkn; SS override
 14606 00003177 36A1[4903]              	MOV	AX,[SS:IOCALL_REQSTAT]	; Get Status word
 14607 0000317B 250002                  	AND	AX,STBUI		; Mask to busy bit
 14608 0000317E B109                    	MOV	CL,9
 14609 00003180 D3E8                    	SHR	AX,CL			; Busy bit to bit 0
 14610 00003182 E916E6                  	jmp	SYS_RET_OK
 14611                                  
 14612                                  ;-------------------------------------------------------------------------
 14613                                  ;
 14614                                  ; IOCTL: AL = 9
 14615                                  ;
 14616                                  ; ENTRY: DS = DOSDATA
 14617                                  ;
 14618                                  ;-------------------------------------------------------------------------
 14619                                  
 14620                                  Ioctl_Drive_attr:
 14621                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14622 00003185 88D8                    	mov	al,bl
 14623 00003187 E82D3B                  	call	GETTHISDRV
 14624 0000318A 7249                    	jc	short ioctl_drv_err
 14625 0000318C E8C100                  	call	Get_Driver_BL
 14626                                  	; MSDOS 6.0
 14627 0000318F 7244                    	JC	short ioctl_drv_err	; drive not valid
 14628                                  
 14629                                  	;mov	dx,[es:di+4]
 14630 00003191 268B5504                	mov	dx,[es:di+SYSDEV.ATT]	
 14631                                  					; get device attribute word
 14632 00003195 88C3                    	MOV	BL,AL			; Phys letter to BL (A=0)
 14633                                  
 14634                                  ;hkn; SS override
 14635 00003197 36C43E[5E05]            	LES	DI,[SS:THISCDS]
 14636                                  	; 31/07/2019
 14637                                  	;test	word [es:di+43h],8000h
 14638                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 14639                                  	;test	byte [es:di+44h],80h
 14640 0000319C 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 14641 000031A1 7403                    	JZ	short IOCTLShare
 14642                                  
 14643                                  	;or	dx,1000h ; msdos 3.3
 14644                                  
 14645                                  ;	Net devices don't return a device attribute word.
 14646                                  ;	Bit 12 = 1, meaning net device, all others = 0.
 14647                                  
 14648 000031A3 BA0010                  	MOV	DX,1000h ;  MSDOS 6.0
 14649                                  IOCTLShare:
 14650 000031A6 16                      	push	ss
 14651 000031A7 1F                      	pop	ds
 14652 000031A8 BE[8203]                	MOV	SI,OPENBUF
 14653 000031AB 80C341                  	ADD	BL,"A"
 14654 000031AE 881C                    	MOV	[SI],BL
 14655 000031B0 C744013A00              	MOV	WORD [SI+1],003AH ; ":",0
 14656 000031B5 B80003                  	MOV	AX,0300h
 14657 000031B8 F8                      	CLC
 14658                                  	;INT	int_IBM
 14659 000031B9 CD2A                    	int     2Ah	; Microsoft Networks - CHECK DIRECT I/O
 14660                                  			; DS:SI -> ASCIZ disk device name (may be full path or only drive
 14661                                  			; specifier--must include the colon)
 14662                                  			; Return: CF clear if absolute disk access allowed
 14663 000031BB 7304                    	JNC	short IOCTLLocal	; Not shared
 14664 000031BD 81CA0002                	OR	DX,0200H		; Shared, bit 9
 14665                                  IOCTLLocal:
 14666                                  	; 31/07/2019
 14667                                  	;test	word [es:di+43h],1000h
 14668                                  	;TEST	word [ES:DI+curdir.flags],curdir_local
 14669                                  	;test	byte [es:di+44h],10h
 14670 000031C1 26F6454410              	TEST	byte [ES:DI+curdir.flags+1],(curdir_local>>8)
 14671 000031C6 7404                    	JZ	short ioctl_set_DX
 14672 000031C8 81CA0080                	OR	DX,8000h
 14673                                  ioctl_set_DX:
 14674 000031CC E87AE4                  	call	Get_User_Stack
 14675 000031CF 895406                  	MOV	[SI+user_env.user_DX],DX
 14676                                  	;jmp	SYS_RET_OK
 14677                                  	; 26/07/2019
 14678 000031D2 E9C9E5                  	jmp	SYS_RET_OK_clc
 14679                                  
 14680                                  ioctl_drv_err:
 14681 000031D5 B00F                    	mov	al, error_invalid_drive ; 0Fh
 14682 000031D7 E9CAE5                  	jmp	SYS_RET_ERR
 14683                                  
 14684                                  ;--------------------------------------------------------------------------
 14685                                  ; IOCTL: AL = A
 14686                                  ;
 14687                                  ; ENTRY: DS = DOSDATA
 14688                                  ;
 14689                                  ;--------------------------------------------------------------------------
 14690                                  
 14691                                  IOCTL_Handle_Redir:
 14692 000031DA E86639                  	call	SFFromHandle		; ES:DI -> SFT
 14693 000031DD 7303                    	JNC	short ioctl_got_sft	; have valid handle
 14694 000031DF E96AFE                  	jmp	ioctl_bad_handle ; 10/08/2018
 14695                                  
 14696                                  ioctl_got_sft:
 14697 000031E2 268B5505                	MOV	DX,[ES:DI+SF_ENTRY.sf_flags] ; Get flags
 14698 000031E6 EBE4                    	JMP	short ioctl_set_DX	; pass dx to user and return
 14699                                  
 14700                                  ioctl_bad_funj:
 14701 000031E8 E954FF                  	JMP	ioctl_bad_fun
 14702                                  
 14703                                  ;--------------------------------------------------------------------------
 14704                                  ;
 14705                                  ; IOCTL: AL= 4,5
 14706                                  ;
 14707                                  ; ENTRY: DS = DOSDATA
 14708                                  ;	 SI = user's DS
 14709                                  ;
 14710                                  ;
 14711                                  ; BUGBUG: Don't push anything on the stack between ioctl_get_dev: and 
 14712                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14713                                  ;         return address off the stack if the drive is invalid.
 14714                                  ;
 14715                                  ;-------------------------------------------------------------------------
 14716                                  
 14717                                  ioctl_get_dev:
 14718 000031EB E89000                  	CALL	Check_If_Net
 14719 000031EE 75F8                    	JNZ	short ioctl_bad_funj	; There are no "net devices", and they
 14720                                  					;   certainly don't know how to do this
 14721                                  					;   call.
 14722                                  ioctl_do_string:
 14723                                  	; 31/07/2019
 14724                                  	;test	word [es:di+4],4000h
 14725                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVIOCTL; See if device accepts control
 14726                                  	;test	byte [es:di+5],40h
 14727 000031F0 26F6450540              	TEST	byte [ES:DI+SYSDEV.ATT+1],(DEVIOCTL>>8)
 14728 000031F5 74F1                    	JZ	short ioctl_bad_funj		; NO
 14729                                  					; assume IOCTL read
 14730 000031F7 C606[4803]03            	MOV	byte [IOCALL_REQFUNC],DEVRDIOCTL
 14731                                  
 14732 000031FC A801                    	TEST	AL,1			; is it func. 4/5 or 2/3
 14733 000031FE 7405                    	JZ	short ioctl_control_call ; it is read. goto ioctl_control_call
 14734                                  
 14735                                  					; it is an IOCTL write
 14736 00003200 C606[4803]0C            	MOV	byte [IOCALL_REQFUNC],DEVWRIOCTL
 14737                                  
 14738                                  ioctl_control_call:
 14739 00003205 B016                    	MOV	AL,DRDWRHL
 14740                                  ioctl_setup_pkt:
 14741 00003207 88DC                    	MOV	AH,BL			; Unit number
 14742 00003209 A3[4603]                	MOV	[IOCALL_REQLEN],AX
 14743 0000320C 31C0                    	XOR	AX,AX
 14744 0000320E A3[4903]                	MOV	[IOCALL_REQSTAT],AX
 14745 00003211 A2[5303]                	MOV	[IOMED],AL
 14746 00003214 890E[5803]              	MOV	[IOSCNT],CX
 14747 00003218 8916[5403]              	MOV	[IOXAD],DX
 14748 0000321C 8936[5603]              	MOV	[IOXAD+2],SI
 14749 00003220 06                      	PUSH	ES
 14750 00003221 1F                      	POP	DS
 14751 00003222 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14752 00003224 16                      	PUSH	SS
 14753 00003225 07                      	POP	ES
 14754                                  
 14755 00003226 BB[4603]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14756                                  ioctl_do_IO:
 14757 00003229 E8061F                  	call	DEVIOCALL2
 14758                                  
 14759                                  ;hkn; SS override for IOCALL
 14760                                  	; 31/07/2019
 14761                                  	;test	word [SS:IOCALL_REQSTAT],8000h
 14762                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 14763                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 14764 0000322C 36F606[4A03]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 14765 00003232 7507                    	JNZ	short ioctl_string_err
 14766                                  
 14767                                  ;hkn; SS override
 14768 00003234 36A1[5803]              	MOV	AX,[SS:IOSCNT]		; Get actual bytes transferred
 14769 00003238 E960E5                  	jmp	SYS_RET_OK
 14770                                  
 14771                                  ioctl_string_err:
 14772 0000323B 368B3E[4903]            	MOV	DI,[SS:IOCALL_REQSTAT]	;Get Error
 14773                                  device_err:
 14774 00003240 81E7FF00                	AND	DI,STECODE ; 00FFh	; mask out irrelevant bits
 14775 00003244 89F8                    	MOV	AX,DI
 14776 00003246 E8AD2A                  	call	SET_I24_EXTENDED_ERROR
 14777                                  
 14778                                  ;hkn; use SS override
 14779                                  ;hkn;	mov	ax,[CS:EXTERR]
 14780 00003249 36A1[F002]              	mov	ax,[SS:EXTERR]
 14781 0000324D E954E5                  	jmp	SYS_RET_ERR
 14782                                  
 14783                                  ;--------------------------------------------------------------------------
 14784                                  ; Proc name : Get_Driver_BL
 14785                                  ;
 14786                                  ;	DS is DOSDATA
 14787                                  ;	BL is drive number (0=default)
 14788                                  ;	Returns pointer to device in ES:DI, unit number in BL if carry clear
 14789                                  ;	No regs modified
 14790                                  ;
 14791                                  ;---------------------------------------------------------------------------
 14792                                  
 14793                                  Get_Driver_BL:
 14794                                  	; 31/07/2019 - Retro DOS v3.2
 14795 00003250 50                      	PUSH	AX
 14796 00003251 88D8                    	MOV	AL,BL			; Drive
 14797 00003253 E8613A                  	call	GETTHISDRV
 14798 00003256 7224                    	jc	short ioctl_bad_drv
 14799 00003258 30DB                    	XOR	BL,BL			; Unit zero on Net device
 14800 0000325A C606[EF02]03            	MOV	byte [EXTERR_LOCUS],errLOC_Net ; 3
 14801 0000325F C43E[5E05]              	LES	DI,[THISCDS]
 14802                                  	;test	word [es:di+43h],8000h
 14803                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 14804                                  	;test	byte [es:di+44h],80h
 14805 00003263 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 14806                                  	;les	di,[es:di+45h]
 14807 00003268 26C47D45                	LES	DI,[ES:DI+curdir.devptr] ; ES:DI -> Dpb or net dev
 14808 0000326C 750D                    	JNZ	short got_dev_ptr	 ; Is net
 14809 0000326E C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk ; 2
 14810                                  	;mov	bl,[es:di+1]
 14811 00003273 268A5D01                	MOV	BL,[ES:DI+DPB.UNIT]	; Unit number
 14812                                  	;les	di,[es:di+13h]
 14813 00003277 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Driver addr
 14814                                  got_dev_ptr:
 14815 0000327B F8                      	CLC
 14816                                  ioctl_bad_drv:
 14817 0000327C 58                      	POP	AX
 14818 0000327D C3                      	retn
 14819                                  
 14820                                  ;-------------------------------------------------------------------------
 14821                                  ; Proc Name : Check_If_Net:
 14822                                  ;
 14823                                  ;
 14824                                  ; Checks if the device is over the net or not. Returns result in ZERO flag.
 14825                                  ; If no device is found, the return address is popped off the stack, and a
 14826                                  ; jump is made to ioctl_drv_err.
 14827                                  ;
 14828                                  ; On Entry:
 14829                                  ; Registers same as those for Get_Driver_BL
 14830                                  ;
 14831                                  ; On Exit:
 14832                                  ; ZERO flag	- set if not a net device
 14833                                  ;		- reset if net device
 14834                                  ; ES:DI -> the device
 14835                                  ;
 14836                                  ;
 14837                                  ; BUGBUG: This function assumes the following stack setup on entry
 14838                                  ;
 14839                                  ;	  SP+2 -> Error return address
 14840                                  ;	  SP   -> Normal return address
 14841                                  ;
 14842                                  ;-------------------------------------------------------------------------
 14843                                  
 14844                                  Check_If_Net:
 14845                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14846 0000327E E8CFFF                  	CALL	Get_Driver_BL
 14847 00003281 720E                    	JC	short ioctl_drv_err_pop	; invalid drive letter
 14848 00003283 06                      	PUSH	ES
 14849 00003284 57                      	PUSH	DI
 14850 00003285 C43E[5E05]              	LES	DI,[THISCDS]
 14851                                  	; 31/07/2019
 14852                                  	;test	word [es:di+43h],8000h
 14853                                  	;TEST	word [ES:DI+curdir.flags],curdir_isnet
 14854                                  	;test	byte [es:di+44h],80h
 14855 00003289 26F6454480              	TEST	byte [ES:DI+curdir.flags+1],(curdir_isnet>>8)
 14856 0000328E 5F                      	POP	DI
 14857 0000328F 07                      	POP	ES
 14858 00003290 C3                      	retn
 14859                                  
 14860                                  ioctl_drv_err_pop:
 14861 00003291 58                      	pop	ax			; pop off return address
 14862 00003292 E940FF                  	jmp	ioctl_drv_err
 14863                                  
 14864                                  ioctl_bad_funj3:
 14865 00003295 E9A7FE                  	jmp	ioctl_bad_fun
 14866                                  
 14867                                  ioctl_string_errj:
 14868 00003298 EBA1                    	jmp	short ioctl_string_err ; 31/07/2019
 14869                                  
 14870                                  ;--------------------------------------------------------------------------
 14871                                  ;
 14872                                  ; IOCTL: AL = E, F
 14873                                  ;
 14874                                  ; ENTRY: DS = DOSDATA
 14875                                  ;
 14876                                  ;
 14877                                  ; BUGBUG: Don't push anything on the stack between ioctl_drive_owner: and 
 14878                                  ;         the call to Check_If_Net because Check_If_Net gets our
 14879                                  ;         return address off the stack if the drive is invalid.
 14880                                  ;
 14881                                  ;--------------------------------------------------------------------------
 14882                                  
 14883                                  ioctl_drive_owner:
 14884                                  	; MSDOS 3.3 (& MSDOS 6.0)
 14885 0000329A E8E1FF                  	Call	Check_If_Net
 14886 0000329D 75F6                    	JNZ	short ioctl_bad_funj3 	; There are no "net devices", and they
 14887                                  					;   certainly don't know how to do this
 14888                                  					;   call.
 14889                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEV320	; See if device can handle this
 14890                                  	; 09/09/2018
 14891 0000329F 26F6450440              	TEST	byte [ES:DI+SYSDEV.ATT],DEV320 ; 0040h
 14892 000032A4 74EF                    	JZ	short ioctl_bad_funj3 	; NO
 14893 000032A6 C606[4803]17            	mov	byte [IOCALL_REQFUNC],DEVGETOWN	; default to get owner
 14894 000032AB 3C0E                    	cmp	al,0Eh			; Get Owner ?
 14895 000032AD 7405                    	jz	short GetOwner
 14896                                  SetOwner:
 14897 000032AF C606[4803]18            	MOV	byte [IOCALL_REQFUNC],DEVSETOWN
 14898                                  GetOwner:
 14899 000032B4 B00D                    	MOV	AL,OWNHL
 14900 000032B6 88DC                    	MOV	AH,BL			; Unit number
 14901 000032B8 A3[4603]                	MOV	[IOCALL_REQLEN],AX
 14902 000032BB 31C0                    	XOR	AX,AX
 14903 000032BD A3[4903]                	MOV	[IOCALL_REQSTAT],AX
 14904 000032C0 06                      	PUSH	ES
 14905 000032C1 1F                      	POP	DS
 14906 000032C2 89FE                    	MOV	SI,DI			; DS:SI -> driver
 14907 000032C4 16                      	PUSH	SS
 14908 000032C5 07                      	POP	ES
 14909 000032C6 BB[4603]                	MOV	BX,IOCALL		; ES:BX -> Call header
 14910 000032C9 1E                      	push	ds
 14911 000032CA 56                      	push	si
 14912 000032CB E8641E                  	call	DEVIOCALL2
 14913 000032CE 5E                      	pop	si
 14914 000032CF 1F                      	pop	ds
 14915                                  	; 31/07/2019
 14916                                  ;hkn; SS override
 14917                                  	;TEST	word [SS:IOCALL_REQSTAT],STERR ;Error?
 14918                                  	;test	byte [SS:IOCALL_REQSTAT+1],80h
 14919 000032D0 36F606[4A03]80          	TEST	byte [SS:IOCALL_REQSTAT+1],(STERR>>8)
 14920 000032D6 75C0                    	jnz	short ioctl_string_errj
 14921 000032D8 36A0[4703]              	MOV	AL,[SS:IOCALL_REQUNIT]	; Get owner returned by device
 14922                                  					; owner returned is 1-based.
 14923 000032DC E9BCE4                  	jmp	SYS_RET_OK
 14924                                  
 14925                                  ;============================================================================
 14926                                  ; DELETE.ASM, MSDOS 6.0, 1991
 14927                                  ;============================================================================
 14928                                  ; 07/08/2018 - Retro DOS v3.0
 14929                                  
 14930                                  ;	TITLE	DOS_DELETE - Internal DELETE call for MS-DOS
 14931                                  ;	NAME	DOS_DELETE
 14932                                  
 14933                                  ;
 14934                                  ;	Microsoft Confidential
 14935                                  ;	Copyright (C) Microsoft Corporation 1991
 14936                                  ;	All Rights Reserved.
 14937                                  ;
 14938                                  
 14939                                  ;**	DELETE.ASM - Low level routine for deleting files
 14940                                  ;
 14941                                  ;		DOS_DELETE
 14942                                  ;		REN_DEL_Check
 14943                                  ;		FastOpen_Delete	       ; DOS 3.3
 14944                                  ;		FastOpen_Update	       ; DOS 3.3
 14945                                  
 14946                                  
 14947                                  ;   Revision history:
 14948                                  ;
 14949                                  ;   A000  version 4.00	Jan. 1988
 14950                                  ;   A001  Fastopen Rename fix	April 1989
 14951                                  
 14952                                  
 14953                                  ;Installed = TRUE
 14954                                  
 14955                                  ;	i_need	NoSetDir,BYTE
 14956                                  ;	i_need	Creating,BYTE
 14957                                  ;	i_need	DELALL,BYTE
 14958                                  ;	i_need	THISDPB,DWORD
 14959                                  ;	i_need	THISSFT,DWORD
 14960                                  ;	i_need	THISCDS,DWORD
 14961                                  ;	i_need	CURBUF,DWORD
 14962                                  ;	i_need	ATTRIB,BYTE
 14963                                  ;	i_need	SATTRIB,BYTE
 14964                                  ;	i_need	WFP_START,WORD
 14965                                  ;	i_need	REN_WFP,WORD			 ;BN001
 14966                                  ;	i_need	NAME1,BYTE			 ;BN001
 14967                                  ;	i_need	FoundDel,BYTE
 14968                                  ;	i_need	AUXSTACK,BYTE
 14969                                  ;	i_need	VOLCHNG_FLAG,BYTE
 14970                                  ;	i_need	JShare,DWORD
 14971                                  ;	i_need	FastOpenTable,BYTE		  ; DOS 3.3
 14972                                  ;	i_need	FastTable,BYTE			  ; DOS 4.00
 14973                                  ;
 14974                                  ;	i_need	Del_ExtCluster,WORD		  ; DOS 4.00
 14975                                  ;
 14976                                  ;	i_need	SAVE_BX,WORD			  ; DOS 4.00
 14977                                  ;	i_need	DMAADD,DWORD
 14978                                  ;	i_need	RENAMEDMA,BYTE
 14979                                  
 14980                                  ;---------------------------------------------------------------------------
 14981                                  ;
 14982                                  ; Procedure Name : DOS_DELETE
 14983                                  ;
 14984                                  ; Inputs:
 14985                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 14986                                  ;		terminated)
 14987                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 14988                                  ;		( = -1 if current dir not involved, else
 14989                                  ;		 Points to first char after last "/" of current dir part)
 14990                                  ;	[THISCDS] Points to CDS being used
 14991                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 14992                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 14993                                  ; Function:
 14994                                  ;	Delete the specified file(s)
 14995                                  ; Outputs:
 14996                                  ;	CARRY CLEAR
 14997                                  ;		OK
 14998                                  ;	CARRY SET
 14999                                  ;	    AX is error code
 15000                                  ;		error_file_not_found
 15001                                  ;			Last element of path not found
 15002                                  ;		error_path_not_found
 15003                                  ;			Bad path (not in curr dir part if present)
 15004                                  ;		error_bad_curr_dir
 15005                                  ;			Bad path in current directory part of path
 15006                                  ;		error_access_denied
 15007                                  ;			Attempt to delete device or directory
 15008                                  ;		***error_sharing_violation***
 15009                                  ;			Deny both access required, generates an INT 24.
 15010                                  ;			This error is NOT returned. The INT 24H is generated,
 15011                                  ;			  and the file is ignored (not deleted). Delete will
 15012                                  ;			  simply continue on looking for more files.
 15013                                  ;			  Carry will NOT be set in this case.
 15014                                  ; DS preserved, others destroyed
 15015                                  ;
 15016                                  ;---------------------------------------------------------------------------
 15017                                  
 15018                                  FILEFOUND   equ 01h
 15019                                  FILEDELETED equ 10h
 15020                                  
 15021                                  DOS_DELETE:
 15022                                  
 15023                                  ;hkn; DOS_Delete is called from file.asm and fcbio.asm. DS has been set up 
 15024                                  ;hkn; appropriately at this point.
 15025                                  
 15026 000032DF E88DED                  	call	TestNet
 15027 000032E2 7306                    	JNC	short LOCAL_DELETE
 15028                                  
 15029                                  ;IF NOT Installed
 15030                                  ;	transfer NET_DELETE
 15031                                  ;ELSE
 15032                                  	;MOV	AX,(MultNET SHL 8) | 19
 15033                                  	;INT	2FH
 15034                                  	;return
 15035                                  
 15036 000032E4 B81311                  	mov	ax,1113h
 15037 000032E7 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - DELETE REMOTE FILE
 15038                                  			; SS = DS = DOS CS, SDA first filename pointer -> 
 15039                                  			;		fully-qualified filename in DOS CS
 15040                                  			; SDA CDS pointer -> current directory structure for drive with file
 15041                                  			; Return: CF set on error
 15042 000032E9 C3                      	retn
 15043                                  
 15044                                  ;ENDIF
 15045                                  
 15046                                  LOCAL_DELETE:
 15047 000032EA C606[2C05]00            	MOV	byte [FOUNDDEL],0	; No files found and no files deleted
 15048 000032EF E81BEE                  	call	EcritDisk
 15049 000032F2 C706[3A05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Assume not del *.*
 15050 000032F8 8B36[6E05]              	MOV	SI,[WFP_START]
 15051                                  SKPNUL:
 15052 000032FC AC                      	LODSB
 15053 000032FD 08C0                    	OR	AL,AL
 15054 000032FF 75FB                    	JNZ	short SKPNUL		; go to end
 15055 00003301 83EE04                  	SUB	SI,4			; Back over possible "*.*"
 15056 00003304 813C2A2E                	CMP	WORD [SI],2E2Ah ; "*."
 15057 00003308 7506                    	JNZ	short TEST_QUEST
 15058 0000330A 807C022A                	CMP	BYTE [SI+2],"*"
 15059 0000330E 741F                    	JZ	short CHECK_ATTS
 15060                                  TEST_QUEST:
 15061 00003310 83EE09                  	SUB	SI,9		; Back over possible "????????.???"
 15062 00003313 87FE                    	XCHG	DI,SI
 15063                                  
 15064 00003315 16                      	push	ss
 15065                                  	;pop	ds ; ! Retro DOS v3.0 BUG !
 15066 00003316 07                      	pop	es ; 17/05/2019 (BugFix)
 15067                                  
 15068 00003317 B83F3F                  	MOV	AX,"??"
 15069 0000331A B90400                  	MOV	CX,4		; four sets of "??"
 15070 0000331D F3AF                    	REPE	SCASW
 15071 0000331F 751C                    	JNZ	short NOT_ALL
 15072 00003321 87FE                    	XCHG	DI,SI
 15073 00003323 AD                      	LODSW
 15074 00003324 3D2E3F                  	CMP	AX,3F2Eh ; ".?"
 15075 00003327 7514                    	JNZ	short NOT_ALL
 15076 00003329 AD                      	LODSW
 15077 0000332A 3D3F3F                  	CMP	AX,"??"
 15078 0000332D 750E                    	JNZ	short NOT_ALL
 15079                                  CHECK_ATTS:
 15080 0000332F A0[2A05]                	MOV	AL,[SATTRIB]
 15081 00003332 241F                    	AND	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 15082                                  					; Look only at hidden bits
 15083 00003334 3C1F                    	CMP	AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
 15084                                  					; All must be set
 15085 00003336 7505                    	JNZ	short NOT_ALL
 15086                                  
 15087                                  ; NOTE WARNING DANGER-----
 15088                                  ;    This DELALL stuff is not safe. It allows directories to be deleted.
 15089                                  ;	It should ONLY be used by FORMAT in the ROOT directory.
 15090                                  
 15091 00003338 C606[3B05]00            	MOV	byte [DELALL],0		; DEL *.* - flag deleting all
 15092                                  NOT_ALL:
 15093 0000333D C606[1603]01            	MOV	byte [NoSetDir],1
 15094 00003342 E8E616                  	call	GetPathNoSet
 15095 00003345 7313                    	JNC	short Del_found
 15096 00003347 750C                    	JNZ	short _bad_path
 15097 00003349 08C9                    	OR	CL,CL
 15098 0000334B 7408                    	JZ	short _bad_path
 15099                                  No_file:
 15100 0000334D B80200                  	MOV	AX,error_file_not_found
 15101                                  ErrorReturn:
 15102 00003350 F9                      	STC
 15103 00003351 E8C1ED                  	call	LcritDisk
 15104 00003354 C3                      	retn
 15105                                  
 15106                                  _bad_path:
 15107 00003355 B80300                  	MOV	AX,error_path_not_found
 15108 00003358 EBF6                    	JMP	short ErrorReturn
 15109                                  
 15110                                  Del_found:
 15111 0000335A 750C                    	JNZ	short NOT_DIR		; Check for dir specified
 15112 0000335C 803E[3B05]00            	CMP	byte [DELALL],0		; DelAll = 0 allows delete of dir.
 15113 00003361 7405                    	JZ	short NOT_DIR
 15114                                  Del_access_err:
 15115 00003363 B80500                  	MOV	AX,error_access_denied
 15116 00003366 EBE8                    	JMP	short ErrorReturn
 15117                                  
 15118                                  NOT_DIR:
 15119 00003368 08E4                    	OR	AH,AH			; Check if device name
 15120 0000336A 78F7                    	JS	short Del_access_err	; Can't delete I/O devices
 15121                                  
 15122                                  ; Main delete loop. CURBUF+2:BX points to a matching directory entry.
 15123                                  
 15124                                  DELFILE:
 15125 0000336C 800E[2C05]01            	OR	byte [FOUNDDEL],FILEFOUND ; file found, not deleted yet
 15126                                  
 15127                                  ; If we are deleting the Volume ID, then we set VOLUME_CHNG flag to make
 15128                                  ; DOS issue a build BPB call the next time this drive is accessed.
 15129                                  
 15130 00003371 1E                      	PUSH	DS
 15131 00003372 8A26[3B05]              	MOV	AH,[DELALL]
 15132 00003376 C53E[9E05]              	LDS	DI,[CURBUF]
 15133                                  	
 15134                                  ;hkn; SS override
 15135 0000337A 36F606[2805]01          	TEST	byte [SS:ATTRIB],attr_read_only ; are we deleting RO files too?
 15136 00003380 7509                    	JNZ	short DoDelete		; yes
 15137                                  
 15138 00003382 F6470B01                	TEST	byte [BX+dir_entry.dir_attr],attr_read_only
 15139 00003386 7403                    	JZ	short DoDelete		; not read only
 15140                                  
 15141 00003388 1F                      	POP	DS
 15142 00003389 EB29                    	JMP	SHORT DELNXT		; Skip it (Note ES:BP not set)
 15143                                  
 15144                                  DoDelete:
 15145 0000338B E87700                  	call	REN_DEL_Check		; Sets ES:BP = [THISDPB]
 15146 0000338E 7303                    	JNC	short DEL_SHARE_OK
 15147 00003390 1F                      	POP	DS
 15148 00003391 EB21                    	JMP	SHORT DELNXT		; Skip it
 15149                                  
 15150                                  DEL_SHARE_OK:
 15151                                  	; MSDOS 6.0
 15152                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 15153                                  	;				;LB. if already dirty		  ;AN000;
 15154                                  	;JNZ	short yesdirty		;LB.  don't increment dirty count ;AN000;
 15155                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 15156 00003393 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty
 15157                                  ;yesdirty:
 15158                                  	;MOV	[BX+dir_entry.dir_name],AH ; Put in E5H or 0
 15159 00003397 8827                    	mov	[bx],ah ; 05/07/2019
 15160 00003399 8B1C                    	MOV	BX,[SI] 		; Get firclus pointer
 15161 0000339B 1F                      	POP	DS
 15162 0000339C 800E[2C05]10            	OR	byte [FOUNDDEL],FILEDELETED ; Deleted file
 15163                                  
 15164 000033A1 83FB02                  	CMP	BX,2
 15165 000033A4 720E                    	JB	short DELNXT		; File has invalid FIRCLUS (too small)
 15166                                  	;cmp	bx,[es:bp+0Dh] ; 25/07/2019
 15167 000033A6 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 15168 000033AA 7708                    	JA	short DELNXT		; File has invalid FIRCLUS (too big)
 15169                                  
 15170 000033AC E81D24                  	call	RELEASE 		; Free file data
 15171 000033AF 724E                    	JC	short No_fileJ
 15172                                  
 15173                                  ; DOS 3.3  FastOpen
 15174                                  
 15175 000033B1 E8BA00                  	CALL	FastOpen_Delete 	; delete the dir info in fastopen
 15176                                  
 15177                                  ; DOS 3.3  FastOpen
 15178                                  
 15179                                  DELNXT:
 15180 000033B4 C42E[4605]              	LES	BP,[THISDPB]		; Possible to get here without this set
 15181 000033B8 E8D815                  	call	GETENTRY		; Registers need to be reset
 15182 000033BB 7242                    	JC	short No_fileJ
 15183 000033BD E80C15                  	call	NEXTENT
 15184 000033C0 73AA                    	JNC	short DELFILE
 15185 000033C2 C42E[4605]              	LES	BP,[THISDPB]		; NEXTENT sets ES=DOSGROUP
 15186                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 15187 000033C6 268A4600                	MOV	AL,[ES:BP]
 15188 000033CA E8A12E                  	call	FLUSHBUF
 15189 000033CD 7230                    	JC	short No_fileJ
 15190                                  ;
 15191                                  ; Now we need to test FoundDel for our flags. The cases to consider are:
 15192                                  ;
 15193                                  ;   not found not deleted		file not found
 15194                                  ;   not found	  deleted		*** impossible ***
 15195                                  ;	found not deleted		access denied (read-only)
 15196                                  ;	found	  deleted		no error
 15197                                  ;
 15198 000033CF F606[2C05]10            	TEST	byte [FOUNDDEL],FILEDELETED ; did we delete a file?
 15199 000033D4 7422                    	JZ	short DelError		; no, figure out what's wrong.
 15200                                  ; We set VOLCHNG_FLAG to indicate that we have changed the volume label
 15201                                  ; and to force the DOS to issue a media check.
 15202 000033D6 F606[2805]08            	TEST	byte [ATTRIB],attr_volume_id
 15203 000033DB 7417                    	jz	short No_Set_Flag
 15204 000033DD 50                      	PUSH	AX
 15205 000033DE 06                      	PUSH	ES
 15206 000033DF 57                      	PUSH	DI
 15207 000033E0 C43E[5E05]              	LES	DI,[THISCDS]
 15208 000033E4 268A25                  	MOV	AH,[ES:DI]		; Get drive
 15209 000033E7 80EC41                  	SUB	AH,'A'                  ; Convert to 0-based
 15210 000033EA 8826[370A]              	mov	[VOLCHNG_FLAG],AH
 15211                                  	
 15212                                  	; MSDOS 6.0
 15213                                  	;XOR	BH,BH			;>32mb delete volume id from boot record ;AN000;
 15214                                  	;call	Set_Media_ID		;>32mb set volumme id to boot record	 ;AN000;
 15215                                  	 
 15216 000033EE E8E02A                  	call	FATREAD_CDS		; force media check
 15217 000033F1 5F                      	POP	DI
 15218 000033F2 07                      	POP	ES
 15219 000033F3 58                      	POP	AX
 15220                                  No_Set_Flag:
 15221 000033F4 E81EED                  	call	LcritDisk		; carry is clear
 15222 000033F7 C3                      	retn
 15223                                  DelError:
 15224 000033F8 F606[2C05]01            	TEST	byte [FOUNDDEL],FILEFOUND ; not deleted. Did we find file?
 15225 000033FD 7503                    	JNZ	short Del_access_errJ 	; yes. Access denied
 15226                                  No_fileJ:
 15227 000033FF E94BFF                  	JMP	No_file ; 10/08/2018 		; Nope
 15228                                  Del_access_errJ:
 15229 00003402 E95EFF                  	JMP	Del_access_err ; 10/08/2018
 15230                                  
 15231                                  ; 08/08/2018 - Retro DOS v3.0
 15232                                  
 15233                                  ;Break	<REN_DEL_Check - check for access for rename and delete>
 15234                                  ;---------------------------------------------------------------------------
 15235                                  ; Procedure Name : REN_DEL_Check
 15236                                  ;
 15237                                  ; Inputs:
 15238                                  ;	[THISDPB] set
 15239                                  ;	[CURBUF+2]:BX points to entry
 15240                                  ;	[CURBUF+2]:SI points to firclus field of entry
 15241                                  ;	[WFP_Start] points to name
 15242                                  ; Function:
 15243                                  ;	Check for Exclusive access on given file.
 15244                                  ;	  Used by RENAME, SET_FILE_INFO, and DELETE.
 15245                                  ; Outputs:
 15246                                  ;	ES:BP = [THISDPB]
 15247                                  ;	NOTE: The WFP string pointed to by [WFP_Start] Will be Modified.  The
 15248                                  ;		last element will be loaded from the directory entry.  This is
 15249                                  ;		so the name given to the sharer doesn't have any meta chars in
 15250                                  ;		it.
 15251                                  ;	Carry set if sharing violation, INT 24H generated
 15252                                  ;	    NOTE THAT AX IS NOT error_sharing_violation.
 15253                                  ;		This is because input AX is preserved.
 15254                                  ;		Caller must set the error if needed.
 15255                                  ;	Carry clear
 15256                                  ;		OK
 15257                                  ; AX,DS,BX,SI,DI preserved
 15258                                  ;---------------------------------------------------------------------------
 15259                                  
 15260                                  REN_DEL_Check:
 15261                                  
 15262 00003405 1E                      	PUSH	DS
 15263 00003406 57                      	PUSH	DI
 15264 00003407 50                      	PUSH	AX
 15265 00003408 53                      	PUSH	BX
 15266 00003409 56                      	PUSH	SI		; Save CURBUF pointers
 15267                                  	
 15268 0000340A 16                      	push	ss
 15269 0000340B 07                      	pop	es
 15270                                  
 15271                                  ;hkn; context ES will assume ES to DOSDATA
 15272                                  ;hkn; ASSUME	ES:DOSGROUP
 15273                                  
 15274                                  ;hkn; SS override
 15275 0000340C 368B3E[6E05]            	MOV	DI,[SS:WFP_START] ; ES:DI -> WFP
 15276 00003411 89DE                    	MOV	SI,BX
 15277                                  
 15278                                  ;hkn; SS override
 15279 00003413 368E1E[A005]            	MOV	DS,[SS:CURBUF+2] ; DS:SI -> entry (FCB style name)
 15280 00003418 89FB                    	MOV	BX,DI		; Set backup limit for skipback
 15281 0000341A 83C302                  	ADD	BX,2		; Skip over d: to point to leading '\'
 15282 0000341D E8EBEB                  	call	StrLen		; CX is length of ES:DI including NUL
 15283 00003420 49                      	DEC	CX		; Don't include nul in count
 15284 00003421 01CF                    	ADD	DI,CX		; Point to NUL at end of string
 15285 00003423 E8543B                  	call	SkipBack	; Back up one element
 15286 00003426 47                      	INC	DI		; Point to start of last element
 15287                                  
 15288                                  ;hkn; SS override
 15289                                  	; MSDOS 6.0
 15290                                  	;MOV	[SS:SAVE_BX],DI	;IFS. save for DOS_RENAME   ;AN000;
 15291                                  	;
 15292 00003427 E868FA                  	call	PackName	; Transfer name from entry to ASCIZ tail.
 15293 0000342A 5E                      	POP	SI		; Get back entry pointers
 15294 0000342B 5B                      	POP	BX
 15295 0000342C 53                      	PUSH	BX
 15296 0000342D 56                      	PUSH	SI		; Back on stack
 15297                                  	
 15298 0000342E 16                      	push	ss
 15299 0000342F 1F                      	pop	ds
 15300                                  
 15301                                  ;hkn; context DS will assume ES to DOSDATA
 15302                                  ;hkn; ASSUME	DS:DOSGROUP
 15303                                  
 15304                                  ;
 15305                                  ; Close the file if possible by us.
 15306                                  ;
 15307                                  ;if installed
 15308 00003430 FF1E[9000]              	Call	far [JShare+(13*4)] ; 13 = ShCloseFile
 15309                                  ;else
 15310                                  ;	Call	ShCloseFile
 15311                                  ;endif
 15312 00003434 8C1E[5C05]              	MOV	[THISSFT+2],DS
 15313                                  
 15314                                  ;hkn; AUXSTACK is in DOSDATA
 15315 00003438 C706[5A05][FB06]        	MOV	word [THISSFT],AUXSTACK-SF_ENTRY.size
 15316                                  				; Scratch space
 15317 0000343E 30E4                    	XOR	AH,AH		; Indicate file to DOOPEN (high bit off)
 15318 00003440 E80A20                  	call	DOOPEN		; Fill in SFT for share check
 15319 00003443 C43E[5A05]              	LES	DI,[THISSFT]
 15320 00003447 26C745021000            	MOV	word [ES:DI+SF_ENTRY.sf_mode],SHARING_DENY_BOTH
 15321                                  				; requires exclusive access
 15322                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],1 ; Pretend open
 15323 0000344D 26C7050100              	mov	word [ES:DI],1
 15324 00003452 E84842                  	call	ShareEnter
 15325 00003455 720D                    	jc	short CheckDone
 15326 00003457 C43E[5A05]              	LES	DI,[THISSFT]
 15327                                  	;MOV	word [ES:DI+SF_ENTRY.sf_ref_count],0
 15328 0000345B 26C7050000              	mov	word [ES:DI],0	; Pretend closed and free
 15329                                  	
 15330 00003460 E83542                  	call	ShareEnd	; Tell sharer we're done with THISSFT
 15331 00003463 F8                      	CLC
 15332                                  CheckDone:
 15333 00003464 C42E[4605]              	LES	BP,[THISDPB]
 15334 00003468 5E                      	POP	SI
 15335 00003469 5B                      	POP	BX
 15336 0000346A 58                      	POP	AX
 15337 0000346B 5F                      	POP	DI
 15338 0000346C 1F                      	POP	DS
 15339 0000346D C3                      	retn
 15340                                  
 15341                                  ;Break	<FastOpen_Delete - delete dir info in fastopen>
 15342                                  ;---------------------------------------------------------------------------
 15343                                  ; Procedure Name : FastOpen_Delete
 15344                                  ; Inputs:
 15345                                  ;	None
 15346                                  ; Function:
 15347                                  ;	Call FastOpen to delete the dir info.
 15348                                  ; Outputs:
 15349                                  ;	None
 15350                                  ;---------------------------------------------------------------------------
 15351                                  
 15352                                  FastOpen_Delete:
 15353 0000346E 9C                      	PUSHF			; save flag
 15354 0000346F 56                      	PUSH	SI		; save registers
 15355 00003470 53                      	PUSH	BX
 15356 00003471 50                      	PUSH	AX
 15357                                  ;hkn; SS override
 15358 00003472 8B36[6E05]              	MOV	SI,[WFP_START]	; ds:si points to path name
 15359 00003476 B003                    	MOV	AL,FONC_delete	; al = 3
 15360                                  fastinvoke:
 15361                                  ;hkn; FastTable is in DOSDATA
 15362 00003478 BB[750F]                	MOV	BX,FastTable+2
 15363 0000347B FF1F                    	CALL	far [BX]	; call fastopen
 15364 0000347D 58                      	POP	AX		; restore registers
 15365 0000347E 5B                      	POP	BX
 15366 0000347F 5E                      	POP	SI
 15367 00003480 9D                      	POPF			; restore flag
 15368 00003481 C3                      	retn
 15369                                  
 15370                                  ;Break	<FastOpen_Update - update dir info in fastopen>
 15371                                  ;---------------------------------------------------------------------------
 15372                                  ; Procedure Name : FastOpen_Update
 15373                                  ;
 15374                                  ; Inputs:
 15375                                  ;	DL     drive number (A=0,B=1,,,)
 15376                                  ;	CX     first cluster #
 15377                                  ;	AH     0 updates dir entry
 15378                                  ;	       1 updates CLUSNUM , BP = new CLUSNUM
 15379                                  ;	ES:DI  directory entry
 15380                                  ; Function:
 15381                                  ;	Call FastOpen to update the dir info.
 15382                                  ; Outputs:
 15383                                  ;	None
 15384                                  ;---------------------------------------------------------------------------
 15385                                  
 15386                                  FastOpen_Update:
 15387 00003482 9C                      	PUSHF			; save flag
 15388 00003483 56                      	PUSH	SI
 15389 00003484 53                      	PUSH	BX		; save regs
 15390 00003485 50                      	PUSH	AX
 15391 00003486 B004                    	MOV	AL,FONC_update	; al = 4
 15392 00003488 EBEE                    	JMP	short fastinvoke
 15393                                  
 15394                                  ;Break	<FastOpen_Rename - Rename directory>	   ; PTR 5622
 15395                                  ;---------------------------------------------------------------------------
 15396                                  ; PROCEDURE Name : FastOpen_Rename
 15397                                  ;
 15398                                  ; Inputs:
 15399                                  ;	 REN_WFP   = Path Name
 15400                                  ;	 NAME1	   = New Name
 15401                                  ; Function:
 15402                                  ;	Call FastOpen to rename the dir entry in the cache
 15403                                  ; Outputs:
 15404                                  ;	None
 15405                                  ;---------------------------------------------------------------------------
 15406                                  
 15407                                  FastOpen_Rename:
 15408                                  	; 08/08/2018 - Retro DOS v3.0
 15409                                  	; MSDOS 6.0
 15410                                  	;PUSHF			;AN001 save flag
 15411                                  	;PUSH	SI		;AN001 save registers
 15412                                  	;PUSH	DI		;AN001
 15413                                  	;PUSH	BX		;AN001
 15414                                  	;PUSH	AX		;AN001
 15415                                  	;
 15416                                  ;hkn; SS override
 15417                                  	;;MOV	SI,[SS:REN_WFP]	;AN001	;;AN001  ds:si-->Path name addrs
 15418                                  	;
 15419                                  	; ? - 08/08/2018 - Retro DOS v3.0
 15420                                  	;push	ss
 15421                                  	;pop	ds
 15422                                  	;mov	si,[REN_WFP]
 15423                                  	;
 15424                                  ;hkn; NAME1 is in DOSDATA
 15425                                  	;MOV	DI,NAME1	;;AN001  ds:di-->New name addrs
 15426                                  	;MOV	AL,FONC_Rename	;;AN001  al = 6
 15427                                  	;
 15428                                  ;hkn; FastTable is in DOSDATA
 15429                                  	;MOV	BX,FastTable+2
 15430                                  	;CALL	far [BX]	;;AN001  call fastopen
 15431                                  	;
 15432                                  	;POP	AX		; restore registers  ;AN001
 15433                                  	;POP	BX				     ;AN001
 15434                                  	;POP	DI				     ;AN001
 15435                                  	;POP	SI				     ;AN001
 15436                                  	;POPF			; restore flag	     ;AN001
 15437                                  	;retn					     ;AN001
 15438                                  
 15439                                  	; MSDOS 6.0
 15440                                  ;entry Fast_Dispatch		; future fastxxxx entry	;AN000;
 15441                                  Fast_Dispatch:
 15442                                  ;hkn; FastTable is in DOSDATA
 15443                                  	;MOV	SI,FastTable+2	; index to the	     ;AN000;
 15444                                  ;hkn; use SS override
 15445                                  	;CALL	far [SS:SI]	; RMFD call fastopen
 15446                                  	;retn
 15447                                  
 15448                                  ;============================================================================
 15449                                  ; RENAME.ASM, MSDOS 6.0, 1991
 15450                                  ;============================================================================
 15451                                  ; 08/08/2018 - Retro DOS v3.0
 15452                                  
 15453                                  ;	TITLE	DOS_RENAME - Internal RENAME call for MS-DOS
 15454                                  ;	NAME	DOS_RENAME
 15455                                  
 15456                                  ;**	Low level routine for renaming files
 15457                                  ;
 15458                                  ;	DOS_RENAME
 15459                                  ;
 15460                                  ;	Modification history:
 15461                                  ;
 15462                                  ;	    Created: ARR 30 March 1983
 15463                                  
 15464                                  ;----------------------------------------------------------------------------
 15465                                  ;
 15466                                  ; Procedure Name : DOS_RENAME
 15467                                  ;
 15468                                  ; Inputs:
 15469                                  ;	[WFP_START] Points to SOURCE WFP string ("d:/" must be first 3
 15470                                  ;		chars, NUL terminated)
 15471                                  ;	[CURR_DIR_END] Points to end of Current dir part of string [SOURCE]
 15472                                  ;		( = -1 if current dir not involved, else
 15473                                  ;		 Points to first char after last "/" of current dir part)
 15474                                  ;	[REN_WFP] Points to DEST WFP string ("d:/" must be first 3
 15475                                  ;		chars, NUL terminated)
 15476                                  ;	[THISCDS] Points to CDS being used
 15477                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15478                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15479                                  ; Function:
 15480                                  ;	Rename the specified file(s)
 15481                                  ;	NOTE: This routine uses most of AUXSTACK as a temp buffer.
 15482                                  ; Outputs:
 15483                                  ;	CARRY CLEAR
 15484                                  ;	    OK
 15485                                  ;	CARRY SET
 15486                                  ;	    AX is error code
 15487                                  ;		error_file_not_found
 15488                                  ;			No match for source, or dest path invalid
 15489                                  ;		error_not_same_device
 15490                                  ;			Source and dest are on different devices
 15491                                  ;		error_access_denied
 15492                                  ;			Directory specified (not simple rename),
 15493                                  ;			Device name given, Destination exists.
 15494                                  ;			NOTE: In third case some renames may have
 15495                                  ;			 been done if metas.
 15496                                  ;		error_path_not_found
 15497                                  ;			Bad path (not in curr dir part if present)
 15498                                  ;			SOURCE ONLY
 15499                                  ;		error_bad_curr_dir
 15500                                  ;			Bad path in current directory part of path
 15501                                  ;			SOURCE ONLY
 15502                                  ;		error_sharing_violation
 15503                                  ;			Deny both access required, generates an INT 24.
 15504                                  ; DS preserved, others destroyed
 15505                                  ;
 15506                                  ;----------------------------------------------------------------------------
 15507                                  
 15508                                  DOS_RENAME:
 15509                                  
 15510                                  ;hkn; DOS_RENAME is called from file.asm and fcbio.asm. DS has been set up
 15511                                  ;hkn; at this point to DOSDATA.
 15512                                  
 15513 0000348A E8E2EB                  	call	TestNet
 15514 0000348D 7306                    	JNC	short LOCAL_RENAME
 15515                                  
 15516                                  ;IF NOT Installed
 15517                                  ;	transfer NET_RENAME
 15518                                  ;ELSE
 15519                                  	;MOV	AX,(MultNET SHL 8) OR 17
 15520                                  	;INT	2FH
 15521                                  	;return
 15522                                  
 15523 0000348F B81111                  	mov     ax, 1111h
 15524 00003492 CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR - RENAME REMOTE FILE
 15525                                  			; SS = DS = DOS CS, 
 15526                                  			; SDA first filename pointer = offset of fully-qualified old name
 15527                                  			; SDA CDS pointer -> current directory
 15528                                  			; Return: CF set on error
 15529 00003494 C3                      	retn
 15530                                  ;ENDIF
 15531                                  
 15532                                  LOCAL_RENAME:
 15533 00003495 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 15534 0000349A 8B36[6E05]              	MOV	SI,[WFP_START]
 15535 0000349E 8B3E[7005]              	MOV	DI,[REN_WFP]
 15536 000034A2 8A04                    	MOV	AL,[SI]
 15537 000034A4 8A25                    	MOV	AH,[DI]
 15538 000034A6 0D2020                  	OR	AX,2020H		; Lower case
 15539 000034A9 38E0                    	CMP	AL,AH
 15540 000034AB 7405                    	JZ	short SAMEDRV
 15541 000034AD B81100                  	MOV	AX,error_not_same_device
 15542 000034B0 F9                      	STC
 15543 000034B1 C3                      	retn
 15544                                  
 15545                                  SAMEDRV:
 15546 000034B2 FF36[FA02]              	PUSH	WORD [DMAADD+2]
 15547 000034B6 FF36[F802]              	PUSH	WORD [DMAADD]
 15548 000034BA 8C1E[FA02]              	MOV	[DMAADD+2],DS
 15549                                  
 15550                                  ;hkn; RENAMEDMA is in DOSDATA
 15551 000034BE C706[F802][B605]        	MOV	WORD [DMAADD],RENAMEDMA
 15552 000034C4 C606[2D05]00            	MOV	byte [FOUND_DEV],0	; Rename fails on DEVS, assume not a dev
 15553 000034C9 E841EC                  	call	EcritDisk
 15554 000034CC E8B804                  	call	DOS_SEARCH_FIRST	; Sets [NoSetDir] to 1, [CURBUF+2]:BX
 15555                                  					;    points to entry
 15556 000034CF 7315                    	JNC	short Check_Dev
 15557 000034D1 83F812                  	CMP	AX,error_no_more_files
 15558 000034D4 7503                    	JNZ	short GOTERR
 15559 000034D6 B80200                  	MOV	AX,error_file_not_found
 15560                                  GOTERR:
 15561 000034D9 F9                      	STC
 15562                                  RENAME_POP:
 15563 000034DA 8F06[F802]              	POP	WORD [DMAADD]
 15564 000034DE 8F06[FA02]              	POP	WORD [DMAADD+2]
 15565 000034E2 E830EC                  	call	LcritDisk
 15566 000034E5 C3                      	retn
 15567                                  
 15568                                  Check_Dev:
 15569 000034E6 B80500                  	MOV	AX,error_access_denied	; Assume error
 15570                                  	;
 15571                                  	; MSDOS 6.0
 15572                                  	;PUSH	DS			      ;PTM.			    ;AN000;
 15573                                  	;LDS	SI,[DMAADD]		      ;PTM.  chek if source a dir   ;AN000;
 15574                                  	;;add	si,21
 15575                                  	;ADD	SI,find_buf.attr	      ;PTM.			    ;AN000;
 15576                                  	;;test	byte [si+11],10h
 15577                                  	;TEST byte [SI+dir_entry.dir_attr],attr_directory  ;PTM.	    ;AN000;
 15578                                  	;JZ	short notdir		      ;PTM.			    ;AN000;
 15579                                  	;MOV	SI,[REN_WFP]		      ;PTM.  if yes, make sure path ;AN000;
 15580                                  	;call	Check_Pathlen2		      ;PTM.   length < 67	    ;AN000;
 15581                                  ;notdir:
 15582                                  	;POP	DS			      ;PTM.			    ;AN000;
 15583                                  	;JA	short GOTERR		      ;PTM.			    ;AN000;
 15584                                  	;
 15585                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15586 000034E9 803E[2D05]00            	CMP	byte [FOUND_DEV],0
 15587 000034EE 75E9                    	JNZ	short GOTERR
 15588                                  ; At this point a source has been found. There is search continuation info (a
 15589                                  ; la DOS_SEARCH_NEXT) for the source at RENAMEDMA, together with the first
 15590                                  ; directory entry found.
 15591                                  ; [THISCDS], [THISDPB], and [THISDRV] are set and will remain correct
 15592                                  ; throughout the RENAME since it is known at this point that the source and
 15593                                  ; destination are both on the same device.
 15594                                  ; [SATTRIB] is also set.
 15595 000034F0 89DE                    	MOV	SI,BX
 15596 000034F2 83C61A                  	ADD	SI,dir_entry.dir_first
 15597 000034F5 E80DFF                  	call	REN_DEL_Check
 15598 000034F8 7305                    	JNC	short REN_OK1
 15599 000034FA B82000                  	MOV	AX,error_sharing_violation
 15600 000034FD EBDB                    	JMP	short RENAME_POP
 15601                                  
 15602                                  ;------------------------------------------------------------------------------
 15603                                  ; Check if the source is a file or directory. If file, delete the entry
 15604                                  ; from the Fastopen cache. If directory, rename it later
 15605                                  ;------------------------------------------------------------------------------
 15606                                  REN_OK1:				;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 15607                                  	; MSDOS 6.0
 15608                                  	;PUSH	SI
 15609                                  	;LDS	SI,[DMAADD]		;BN00X; PTM. check if source a dir ;AN000;
 15610                                  	;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		   ;AN000;
 15611                                  	;add	si,21
 15612                                  	;;test	byte [si+11],10h
 15613                                  	;TEST byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.   ;AN000;
 15614                                  	;JZ	short NOT_DIR1		;;BN00XPTM.			   ;AN000;
 15615                                  	;POP	SI			;BN00X
 15616                                  	;JMP	SHORT SWAP_SOURCE	;BN00X
 15617                                  	;
 15618                                  ;NOT_DIR1:				;;BN00X it is a file, delete the entry
 15619                                  	;POP	SI
 15620                                  	;
 15621                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 15622 000034FF E86CFF                  	call	FastOpen_Delete 	; delete dir info in fastopen DOS 3.3
 15623                                  
 15624                                  ;SWAP_SOURCE:
 15625                                  	; MSDOS 3.3
 15626                                  	;MOV	SI,[REN_WFP]
 15627                                  	;MOV	[WFP_START],SI
 15628                                  	; MSDOS 6.0
 15629 00003502 A1[6E05]                	MOV	AX,[WFP_START]		; Swap source and destination
 15630 00003505 8B36[7005]              	MOV	SI,[REN_WFP]		; Swap source and destination
 15631 00003509 8936[6E05]              	MOV	[WFP_START],SI		; WFP_START = Destination path
 15632 0000350D A3[7005]                	MOV	[REN_WFP],AX		; REN_WFP   = Source path
 15633                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15634 00003510 C706[7205]FFFF          	MOV	word [CURR_DIR_END],-1	; No current dir on dest
 15635 00003516 C706[3A05]FFE5          	MOV	WORD [CREATING],DIRFREE*256+0FFh  ; Creating, not DEL *.*
 15636                                  					; A rename is like a CREATE_NEW as far
 15637                                  					; as the destination is concerned.
 15638 0000351C E80C15                  	call	GetPathNoSet
 15639                                  ;   If this GETPATH fails due to file not found, we know all renames will work
 15640                                  ;   since no files match the destination name. If it fails for any other
 15641                                  ;   reason, the rename fails on a path not found, or whatever (also fails if
 15642                                  ;   we find a device or directory). If the GETPATH succeeds, we aren't sure
 15643                                  ;   if the rename should fail because we haven't built an explicit name by
 15644                                  ;   substituting for the meta chars in it. In this case the destination file
 15645                                  ;   spec with metas is in [NAME1] and the explicit source name is at RENAMEDMA
 15646                                  ;   in the directory entry part.
 15647 0000351F 7223                    	JC	short NODEST
 15648                                  	;; MSDOS 6.0
 15649                                  	;; JZ	short BAD_ACC 		; Dest string is a directory	;AC000;
 15650                                  	; !! MSDOS 3.3 !!
 15651 00003521 7404                    	JZ	short BAD_ACC ; !!	; Dest string is a directory
 15652                                  	;
 15653 00003523 08E4                    	OR	AH,AH			; Device?
 15654 00003525 7930                    	JNS	short SAVEDEST		; No, continue
 15655                                  BAD_ACC:
 15656 00003527 B80500                  	MOV	AX,error_access_denied
 15657 0000352A F9                      	STC
 15658                                  RENAME_CLEAN:
 15659 0000352B 9C                      	PUSHF				; Save carry state
 15660 0000352C 50                      	PUSH	AX			; and error code (if carry set)
 15661 0000352D A0[3305]                	MOV	AL,[THISDRV]
 15662 00003530 E83B2D                  	call	FLUSHBUF
 15663 00003533 58                      	POP	AX
 15664 00003534 803E[1403]00            	CMP	byte [FAILERR],0
 15665 00003539 7503                    	JNZ	short BAD_ERR		; User FAILed to I 24
 15666 0000353B 9D                      	POPF
 15667 0000353C EB9C                    	JMP	short RENAME_POP
 15668                                  
 15669                                  BAD_ERR:
 15670 0000353E 58                      	POP	AX			; Saved flags
 15671 0000353F B80300                  	MOV	AX,error_path_not_found
 15672 00003542 EB95                    	JMP	short GOTERR
 15673                                  
 15674                                  NODEST:
 15675 00003544 750B                    	JNZ	short BAD_PATH
 15676 00003546 803E[1403]00            	CMP	byte [FAILERR],0
 15677 0000354B 7504                    	JNZ	short BAD_PATH	; Search for dest failed because user FAILed on
 15678                                  				;	I 24
 15679 0000354D 08C9                    	OR	CL,CL
 15680 0000354F 7506                    	JNZ	short SAVEDEST
 15681                                  BAD_PATH:
 15682 00003551 B80300                  	MOV	AX,error_path_not_found
 15683 00003554 F9                      	STC
 15684 00003555 EB83                    	JMP	short RENAME_POP
 15685                                  
 15686                                  SAVEDEST:
 15687 00003557 16                      	push	ss
 15688 00003558 07                      	pop	es
 15689                                  
 15690                                  ;hkn; NAME1 & NAME2 is in DOSDATA
 15691 00003559 BF[1405]                	MOV	DI,NAME2
 15692 0000355C BE[0805]                	MOV	SI,NAME1
 15693                                  
 15694 0000355F B90B00                  	MOV	CX,11
 15695 00003562 F3A4                    	REP	MOVSB			; Save dest with metas at NAME2
 15696 00003564 A1[7E05]                	MOV	AX,[DIRSTART]
 15697 00003567 A3[2105]                	MOV	[DESTSTART],AX
 15698                                  BUILDDEST:
 15699 0000356A 16                      	push	ss
 15700 0000356B 07                      	pop	es			; needed due to JMP BUILDDEST below
 15701                                  
 15702                                  ;hkn; RENAMEDMA, NAME1, NAME2 in DOSDATA
 15703 0000356C BB[CB05]                	MOV	BX,RENAMEDMA+21		; Source of replace chars
 15704 0000356F BF[0805]                	MOV	DI,NAME1		; Real dest name goes here
 15705 00003572 BE[1405]                	MOV	SI,NAME2		; Raw dest
 15706                                  
 15707 00003575 B90B00                  	MOV	CX,11
 15708                                  	
 15709                                  	; MSDOS 6.0
 15710                                  	;CALL	NEW_RENAME		;IFS. replace ? chars	;AN000;
 15711                                  
 15712                                  	; MSDOS 3.3
 15713                                  
 15714                                  ; 08/08/2018 - Retro DOS v3.0
 15715                                  ; MSDOS 6.0 
 15716                                  ;---------------------------------------------------------------------------
 15717                                  ;Procedure: NEW_RENAME
 15718                                  ;
 15719                                  ;Input: DS:SI -> raw string with ?
 15720                                  ;	ES:DI -> destination string
 15721                                  ;	DS:BX -> source string
 15722                                  ;Function: replace ? chars of raw string with chars in source string and
 15723                                  ;	   put in destination string
 15724                                  ;Output: ES:DI-> new string
 15725                                  ;---------------------------------------------------------------------------
 15726                                  
 15727                                  NEW_RENAME:
 15728                                  NEWNAM:
 15729                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 341Ah
 15730 00003578 AC                      	LODSB
 15731 00003579 3C3F                    	CMP	AL,"?"
 15732 0000357B 7502                    	JNZ	short NOCHG
 15733 0000357D 8A07                    	MOV	AL,[BX] 		; Get replace char
 15734                                  NOCHG:
 15735 0000357F AA                      	STOSB
 15736 00003580 43                      	INC	BX			; Next replace char
 15737 00003581 E2F5                    	LOOP	NEWNAM
 15738                                  	; MSSOS 6.0
 15739                                  	;retn
 15740                                  
 15741                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15742 00003583 C606[2805]16            	MOV	byte [ATTRIB],attr_all	; Stop duplicates with any attributes
 15743 00003588 C606[3A05]FF            	MOV	byte [CREATING],0FFH
 15744 0000358D E84717                  	call	DEVNAME 		; Check if we built a device name
 15745 00003590 7395                    	JNC	short BAD_ACC
 15746 00003592 8B1E[2105]              	MOV	BX,[DESTSTART]
 15747 00003596 C42E[4605]              	LES	BP,[THISDPB]
 15748 0000359A E82714                  	call	SETDIRSRCH		; Reset search to start of dir
 15749 0000359D 7288                    	JC	short BAD_ACC 		; Screw up
 15750 0000359F E8D912                  	call	FINDENTRY		; See if new name already exists
 15751 000035A2 7383                    	JNC	short BAD_ACC 		; Error if found
 15752 000035A4 803E[1403]00            	CMP	byte [FAILERR],0
 15753 000035A9 752A                    	JNZ	short BAD_ACCJ		; Find failed because user FAILed to I 24
 15754 000035AB A1[2105]                	MOV	AX,[DESTSTART]		; DIRSTART of dest
 15755 000035AE 3B06[C505]              	CMP	AX,[RENAMEDMA+15]	; DIRSTART of source
 15756 000035B2 7453                    	JZ	short SIMPLE_RENAME	; If =, just give new name
 15757                                  
 15758 000035B4 A0[D605]                	MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr]
 15759 000035B7 A810                    	TEST	AL,attr_directory
 15760 000035B9 751A                    	JNZ	short BAD_ACCJ		; Can only do a simple rename on dirs,
 15761                                  					; otherwise the . and .. entries get
 15762                                  					; wiped.
 15763 000035BB A2[2805]                	MOV	[ATTRIB],AL
 15764 000035BE 8C1E[5C05]              	MOV	[THISSFT+2],DS
 15765                                  
 15766                                  ;hkn; AUXSTACK is in DOSDATA
 15767 000035C2 BE[FB06]                	MOV	SI,AUXSTACK-SF_ENTRY.size
 15768 000035C5 8936[5A05]              	MOV	[THISSFT],SI
 15769 000035C9 C744020200              	MOV	word [SI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 15770 000035CE 31C9                    	XOR	CX,CX			; Set "device ID" for call into makenode
 15771 000035D0 E80C1D                  	call	RENAME_MAKE		; This is in mknode
 15772 000035D3 7303                    	JNC	short GOT_DEST
 15773                                  BAD_ACCJ:
 15774 000035D5 E94FFF                  	JMP	BAD_ACC
 15775                                  
 15776                                  GOT_DEST:
 15777 000035D8 53                      	push	bx
 15778 000035D9 C43E[5A05]              	LES	DI,[THISSFT]		; RENAME_MAKE entered this into sharing
 15779 000035DD E8B840                  	call	ShareEnd		; we need to remove it.
 15780 000035E0 5B                      	pop	bx
 15781                                  ; A zero length entry with the correct new name has now been made at
 15782                                  ;   [CURBUF+2]:BX.
 15783 000035E1 C43E[9E05]              	LES	DI,[CURBUF]
 15784                                  
 15785                                  	; MSDOS 6.0
 15786                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 15787                                  	;				;LB. if already dirty		  ;AN000;
 15788                                  	;JNZ	short yesdirty1		;LB.  don't increment dirty count ;AN000;
 15789                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 15790                                  	
 15791 000035E5 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 15792                                  ;yesdirty1:
 15793 000035EA 89DF                    	MOV	DI,BX
 15794 000035EC 83C70B                  	ADD	DI,dir_entry.dir_attr	; Skip name
 15795                                  
 15796                                  ;hkn; RENAMEDMA is in DOSDATA
 15797 000035EF BE[D605]                	MOV	SI,RENAMEDMA+21+dir_entry.dir_attr
 15798 000035F2 B91500                  	MOV	CX,dir_entry.size-dir_entry.dir_attr ; mov cx,21
 15799 000035F5 F3A4                    	REP	MOVSB
 15800 000035F7 E85100                  	CALL	GET_SOURCE
 15801 000035FA 724B                    	JC	short RENAME_OVER
 15802 000035FC 89DF                    	MOV	DI,BX
 15803 000035FE 8E06[A005]              	MOV	ES,[CURBUF+2]
 15804 00003602 B0E5                    	MOV	AL,DIRFREE
 15805 00003604 AA                      	STOSB				; "free" the source
 15806 00003605 EB13                    	JMP	SHORT DIRTY_IT
 15807                                  
 15808                                  SIMPLE_RENAME:
 15809 00003607 E84100                  	CALL	GET_SOURCE		; Get the source back
 15810 0000360A 723B                    	JC	short RENAME_OVER
 15811 0000360C 89DF                    	MOV	DI,BX
 15812 0000360E 8E06[A005]              	MOV	ES,[CURBUF+2]
 15813                                  
 15814                                  ;hkn; NAME1 is in DOSDATA
 15815 00003612 BE[0805]                	MOV	SI,NAME1		; New Name
 15816 00003615 B90B00                  	MOV	CX,11
 15817 00003618 F3A4                    	REP	MOVSB
 15818                                  DIRTY_IT:
 15819 0000361A 8B3E[9E05]              	MOV	DI,[CURBUF]
 15820                                  
 15821                                  	; MSDOS 6.0
 15822                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 15823                                  	;				;LB. if already dirty		  ;AN000;
 15824                                  	;JNZ	short yesdirty2		;LB.  don't increment dirty count ;AN000;
 15825                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 15826                                  	
 15827 0000361E 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 15828                                  ;------------------------------------------------------------------------------
 15829                                  ; Check if the source is a directory of file. If directory rename it to the
 15830                                  ; the new name in the Fastopen cache buffer.  If file name it has been
 15831                                  ; previously deleted.
 15832                                  ;------------------------------------------------------------------------------
 15833                                  ;yesdirty2:
 15834                                  	; MSDOS 6.0
 15835                                  	;PUSH	SI
 15836                                  	;LDS	SI,[DMAADD]		;;BN00XPTM. chek if source a dir ;AN000;
 15837                                  	;ADD	SI,find_buf.attr	;;BN00XPTM.P5520		;AN000;
 15838                                  	;TEST	byte [SI+dir_entry.dir_attr],attr_directory ;;BN00XPTM.	;AN000;
 15839                                  	;JZ	short NOT_DIR2		;;BN00XPTM.			;AN000;
 15840                                  	;call	FASTOPEN_RENAME		;;BN00X rename dir entry in fastopen
 15841                                  	;POP	SI
 15842                                  	;JMP	SHORT NOT_DIRTY1
 15843                                  ;NOT_DIR2:				;;BN00X it is a file, delete the entry
 15844                                  	;POP	SI
 15845                                  ;NOT_DIRTY1:				;;BN00X
 15846                                  NEXT_SOURCE:
 15847                                  ;hkn; RENAMEDMA is in DOSDATA
 15848 00003623 BE[B705]                	MOV	SI,RENAMEDMA+1		;Name
 15849                                  ;
 15850                                  ; WARNING! Rename_Next leaves the disk critical section *ALWAYS*. We need
 15851                                  ; to enter it before going to RENAME_Next.
 15852                                  ;
 15853 00003626 E8E4EA                  	call	EcritDisk
 15854 00003629 C606[3A05]00            	MOV	byte [CREATING],0 ; Correct setting for search (we changed it
 15855                                  				  ;  to FF when we made the prev new file).
 15856 0000362E E85704                  	call	RENAME_NEXT
 15857                                  ;
 15858                                  ; Note, now, that we have exited the previous ENTER and so are back to where
 15859                                  ; we were before.
 15860                                  ;
 15861 00003631 7214                    	JC	short RENAME_OVER
 15862 00003633 8D771A                  	LEA	SI,[BX+dir_entry.dir_first]
 15863 00003636 E8CCFD                  	call	REN_DEL_Check
 15864 00003639 7306                    	JNC	short REN_OK2
 15865 0000363B B82000                  	MOV	AX,error_sharing_violation
 15866 0000363E E9EAFE                  	JMP	RENAME_CLEAN ; 10/08/2018
 15867                                  
 15868                                  ;------------------------------------------------------------------------------
 15869                                  ; Check if file or directory. If file, delete file from the Fastopen cache,
 15870                                  ; if directory, rename directory name in the Fastopen cache.
 15871                                  ;-----------------------------------------------------------------------------
 15872                                  REN_OK2:
 15873                                  	; MSDOS 6.0
 15874                                  	;MOV	AL,[RENAMEDMA+21+dir_entry.dir_attr] ; PTR P5622
 15875                                  	;TEST	AL,attr_directory	;;BN00X directory
 15876                                  	;JZ	short Ren_Directory	;;BN00X no - file, delete it
 15877                                  	
 15878                                  	; MSDOS 3.3 (& MSDOS 6.0)
 15879 00003641 E82AFE                  	call	FastOpen_Delete 	;;BN00X delete dir info in fastopen DOS 3.3
 15880 00003644 E923FF                  	JMP	BUILDDEST		;;BN00X
 15881                                  
 15882                                  	; MSDOS 6.0
 15883                                  ;Ren_Directory:
 15884                                  	;call	FASTOPEN_RENAME 	;;BN00X delete dir info in fastopen DOS 3.3
 15885                                  	;JMP	BUILDDEST
 15886                                  
 15887                                  RENAME_OVER:
 15888 00003647 F8                      	CLC
 15889 00003648 E9E0FE                  	JMP	RENAME_CLEAN ; 10/08/2018
 15890                                  
 15891                                  ;----------------------------------------------------------------------------
 15892                                  ; Procedure: GET_SOURCE
 15893                                  ;
 15894                                  ; Inputs:
 15895                                  ;	RENAMEDMA has source info
 15896                                  ; Function:
 15897                                  ;	Re-find the source
 15898                                  ; Output:
 15899                                  ;	[CURBUF] set
 15900                                  ;	[CURBUF+2]:BX points to entry
 15901                                  ;	Carry set if error (currently user FAILed to I 24)
 15902                                  ; DS preserved, others destroyed
 15903                                  ;----------------------------------------------------------------------------
 15904                                  
 15905                                  GET_SOURCE:
 15906 0000364B 8B1E[C505]              	MOV	BX,[RENAMEDMA+15]	; DirStart
 15907 0000364F C42E[4605]              	LES	BP,[THISDPB]
 15908 00003653 E86E13                  	call	SETDIRSRCH
 15909 00003656 7209                    	JC	short gs_ret_label	; retc
 15910 00003658 E85B16                  	call	STARTSRCH
 15911 0000365B A1[C305]                	MOV	AX,[RENAMEDMA+13]	; Lastent
 15912 0000365E E83513                  	call	GETENT
 15913                                  
 15914                                  gs_ret_label:
 15915 00003661 C3                      	retn
 15916                                  
 15917                                  ;============================================================================
 15918                                  ; FINFO.ASM, MSDOS 6.0, 1991
 15919                                  ;============================================================================
 15920                                  ; 08/08/2018 - Retro DOS v3.0
 15921                                  
 15922                                  ;**	Low level routines for returning file information and setting file
 15923                                  ;	attributes
 15924                                  ;
 15925                                  ;	GET_FILE_INFO
 15926                                  ;	SET_FILE_ATTRIBUTE
 15927                                  ;
 15928                                  ;	Modification history:
 15929                                  ;
 15930                                  ;	    Created: ARR 30 March 1983
 15931                                  ;
 15932                                  ;	M025: Return access_denied if attempting to set
 15933                                  ;	      attribute of root directory.
 15934                                  ;
 15935                                  
 15936                                  ;SUBTTL GET_FILE_INFO -- Get File Information
 15937                                  
 15938                                  ;---------------------------------------------------------------------------
 15939                                  ; Procedure Name : GET_FILE_INFO
 15940                                  ;
 15941                                  ; Inputs:
 15942                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 15943                                  ;		terminated)
 15944                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 15945                                  ;		( = -1 if current dir not involved, else
 15946                                  ;		 Points to first char after last "/" of current dir part)
 15947                                  ;	[THISCDS] Points to CDS being used
 15948                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 15949                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 15950                                  ; Function:
 15951                                  ;	Get Information about a file
 15952                                  ; Returns:
 15953                                  ;	CARRY CLEAR
 15954                                  ;	    AX = Attribute of file
 15955                                  ;	    CX = Time stamp of file
 15956                                  ;	    DX = Date stamp of file
 15957                                  ;	    BX:DI = Size of file (32 bit)
 15958                                  ;	CARRY SET
 15959                                  ;	    AX is error code
 15960                                  ;		error_file_not_found
 15961                                  ;			Last element of path not found
 15962                                  ;		error_path_not_found
 15963                                  ;			Bad path (not in curr dir part if present)
 15964                                  ;		error_bad_curr_dir
 15965                                  ;			Bad path in current directory part of path
 15966                                  ; DS preserved, others destroyed
 15967                                  ;---------------------------------------------------------------------------
 15968                                  
 15969                                  GET_FILE_INFO:
 15970                                  
 15971                                  ;hkn; get_file_info is called from file.asm and fcbio.asm. DS has been set 
 15972                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 15973                                  
 15974 00003662 E80AEA                  	call	TestNet
 15975 00003665 7306                    	JNC	short LOCAL_INFO
 15976                                  
 15977                                  ;IF NOT Installed
 15978                                  ;	transfer NET_GET_FILE_INFO
 15979                                  ;ELSE
 15980                                  ;	MOV	AX,(MultNET SHL 8) OR 15
 15981                                  ;	INT	2FH
 15982                                  ;	return
 15983                                  
 15984 00003667 B80F11                  	mov     ax, 110Fh
 15985 0000366A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET REMOTE FILE'S ATTRIBUTES
 15986                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 15987                                  			; SDA CDS pointer -> current directory
 15988                                  			; Return: CF set on error, AX = file attributes
 15989 0000366C C3                      	retn
 15990                                  ;ENDIF
 15991                                  
 15992                                  LOCAL_INFO:
 15993 0000366D E89DEA                  	call	EcritDisk
 15994 00003670 C606[1603]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 15995                                  	; MSDOS 6.0
 15996                                  	;call	Get_FAST_PATH
 15997                                  	; MSDOS 3.3
 15998 00003675 E8AD13                  	call	GETPATH
 15999                                  info_check:
 16000 00003678 7313                    	JNC	short info_check_dev
 16001                                  NO_PATH:
 16002 0000367A 750C                    	JNZ	short bad_path1
 16003 0000367C 08C9                    	OR	CL,CL
 16004 0000367E 7408                    	JZ	short bad_path1
 16005                                  info_no_file:
 16006 00003680 B80200                  	MOV	AX,error_file_not_found
 16007                                  BadRet:
 16008 00003683 F9                      	STC
 16009                                  JustRet:
 16010 00003684 E88EEA                  	call	LcritDisk
 16011 00003687 C3                      	retn
 16012                                  
 16013                                  bad_path1:
 16014 00003688 B80300                  	MOV	AX,error_path_not_found
 16015 0000368B EBF6                    	jmp	short BadRet
 16016                                  
 16017                                  info_check_dev:
 16018 0000368D 08E4                    	OR	AH,AH
 16019 0000368F 78EF                    	JS	short info_no_file	; device
 16020                                  
 16021                                  	; MSDOS 6.0
 16022                                  ;SR;
 16023                                  ; If root dir then CurBuf == -1. Check for this case and return subdir attr
 16024                                  ;for a root dir
 16025                                  ;
 16026 00003691 833E[9E05]FF            	cmp	word [CURBUF],-1	;is it a root dir?
 16027 00003696 7507                    	jne	short not_root		;no, CurBuf ptr is valid
 16028                                  
 16029 00003698 30E4                    	xor	ah,ah
 16030 0000369A B010                    	mov	al,attr_directory
 16031 0000369C F8                      	clc
 16032 0000369D EBE5                    	jmp	short JustRet
 16033                                  
 16034                                  not_root:
 16035                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16036 0000369F 1E                      	PUSH	DS
 16037 000036A0 8E1E[A005]              	MOV	DS,[CURBUF+2]
 16038 000036A4 89DE                    	MOV	SI,BX
 16039 000036A6 31DB                    	XOR	BX,BX			; Assume size=0 (dir)
 16040 000036A8 89DF                    	MOV	DI,BX
 16041 000036AA 8B4C16                  	MOV	CX,[SI+dir_entry.dir_time]
 16042 000036AD 8B5418                  	MOV	DX,[SI+dir_entry.dir_date]
 16043 000036B0 30E4                    	XOR	AH,AH
 16044 000036B2 8A440B                  	MOV	AL,[SI+dir_entry.dir_attr]
 16045 000036B5 A810                    	TEST	AL,attr_directory
 16046 000036B7 7506                    	JNZ	short NO_SIZE
 16047 000036B9 8B7C1C                  	MOV	DI,[SI+dir_entry.dir_size_l]
 16048 000036BC 8B5C1E                  	MOV	BX,[SI+dir_entry.dir_size_h]
 16049                                  NO_SIZE:
 16050 000036BF 1F                      	POP	DS
 16051 000036C0 F8                      	CLC
 16052 000036C1 EBC1                    	jmp	short JustRet
 16053                                  
 16054                                  ;Break	<SET_FILE_ATTRIBUTE -- Set File Attribute>
 16055                                  ;-------------------------------------------------------------------------------
 16056                                  ; Procedure Name : SET_FILE_ATTRIBUTE
 16057                                  ; Inputs:
 16058                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16059                                  ;		terminated)
 16060                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16061                                  ;		( = -1 if current dir not involved, else
 16062                                  ;		 Points to first char after last "/" of current dir part)
 16063                                  ;	[THISCDS] Points to CDS being used
 16064                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16065                                  ;	[SATTRIB] is attribute of search (determines what files may be found)
 16066                                  ;	AX is new attributes to give to file
 16067                                  ; Function:
 16068                                  ;	Set File Attributes
 16069                                  ; Returns:
 16070                                  ;	CARRY CLEAR
 16071                                  ;	    No error
 16072                                  ;	CARRY SET
 16073                                  ;	    AX is error code
 16074                                  ;		error_file_not_found
 16075                                  ;			Last element of path not found
 16076                                  ;		error_path_not_found
 16077                                  ;			Bad path (not in curr dir part if present)
 16078                                  ;		error_bad_curr_dir
 16079                                  ;			Bad path in current directory part of path
 16080                                  ;		error_access_denied
 16081                                  ;			Attempt to set an attribute which cannot be set
 16082                                  ;			(attr_directory, attr_volume_ID)
 16083                                  ;		error_sharing_violation
 16084                                  ;			Sharing mode of file did not allow the change
 16085                                  ;			(this request requires exclusive write/read access)
 16086                                  ;			(INT 24H generated)
 16087                                  ; DS preserved, others destroyed
 16088                                  ;----------------------------------------------------------------------------
 16089                                  
 16090                                  SET_FILE_ATTRIBUTE:
 16091                                  
 16092                                  ;hkn; set_file_attr is called from file.asm. DS has been set 
 16093                                  ;hkn; to DOSDATA at this point. So DOSassume is OK.
 16094                                  
 16095 000036C3 A9D8FF                  	TEST	AX,~attr_changeable ; 0FFD8h
 16096 000036C6 7414                    	JZ	short set_look
 16097                                  _BAD_ACC:
 16098 000036C8 C606[EF02]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk
 16099 000036CD C606[F302]07            	MOV	byte [EXTERR_CLASS],errCLASS_Apperr
 16100 000036D2 C606[F202]04            	MOV	byte [EXTERR_ACTION],errACT_Abort
 16101 000036D7 B80500                  	MOV	AX,error_access_denied
 16102 000036DA F9                      	STC
 16103 000036DB C3                      	retn
 16104                                  
 16105                                  set_look:
 16106 000036DC E890E9                  	call	TestNet
 16107 000036DF 7308                    	JNC	short LOCAL_SET
 16108                                  
 16109                                  ;IF NOT Installed
 16110                                  ;	transfer NET_SEQ_SET_FILE_ATTRIBUTE
 16111                                  ;ELSE
 16112 000036E1 50                      	PUSH	AX
 16113                                  	
 16114                                  	;MOV	AX,(MultNET SHL 8) OR 14
 16115                                  	;INT	2FH
 16116                                  
 16117 000036E2 B80E11                  	mov     ax, 110Eh
 16118 000036E5 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SET REMOTE FILE'S ATTRIBUTES
 16119                                  			; SS = DOS CS, SDA first filename pointer -> fully-qualified name of file
 16120                                  			; SDA CDS pointer -> current directory
 16121                                  			; STACK: WORD new file attributes
 16122                                  			; Return: CF set on error
 16123                                  
 16124 000036E7 5B                      	POP	BX			; clean stack
 16125 000036E8 C3                      	retn
 16126                                  ;ENDIF
 16127                                  
 16128                                  LOCAL_SET:
 16129 000036E9 E821EA                  	call	EcritDisk
 16130 000036EC 50                      	PUSH	AX			; Save new attributes
 16131 000036ED C606[1603]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 16132 000036F2 E83013                  	call	GETPATH 		; get path through fastopen if there	 ;AC000;
 16133 000036F5 7303                    	JNC	short set_check_device
 16134 000036F7 5B                      	POP	BX			; Clean stack (don't zap AX)
 16135 000036F8 EB80                    	JMP	short NO_PATH
 16136                                  
 16137                                  set_check_device:
 16138 000036FA 08E4                    	OR	AH,AH
 16139 000036FC 7906                    	JNS	short set_check_share
 16140 000036FE 58                      	POP	AX
 16141 000036FF E813EA                  	call	LcritDisk
 16142 00003702 EBC4                    	JMP	short _BAD_ACC 		; device
 16143                                  
 16144                                  set_check_share:
 16145 00003704 58                      	POP	AX			; Get new attributes
 16146                                  
 16147                                  	; MSDOS 6.0
 16148 00003705 833E[9E05]FF            	cmp	word [CURBUF], -1	; M025: Q: is this the root dir
 16149 0000370A 740A                    	je	short cannot_set_root	; M025: Y: return error
 16150                                  
 16151                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16152 0000370C E8F6FC                  	call	REN_DEL_Check
 16153 0000370F 730B                    	JNC	short set_do
 16154 00003711 B82000                  	MOV	AX,error_sharing_violation
 16155 00003714 EB30                    	jmp	short OK_BYE
 16156                                  
 16157                                  	; MSDOS 6.0
 16158                                  cannot_set_root:			; M025:
 16159 00003716 B80500                  	mov	ax, error_access_denied	; M025: return error is attempting
 16160 00003719 F9                      	stc				; M025: to set attr. of root
 16161 0000371A EB2A                    	jmp	short OK_BYE		; M025:
 16162                                  
 16163                                  set_do:
 16164                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16165 0000371C C43E[9E05]              	LES	DI,[CURBUF]
 16166 00003720 2680670BD8              	AND	BYTE [ES:BX+dir_entry.dir_attr],~attr_changeable ; 0D8h
 16167 00003725 2608470B                	OR	BYTE [ES:BX+dir_entry.dir_attr],AL
 16168                                  
 16169                                  	; MSDOS 6.0
 16170                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 16171                                  	;				;LB. if already dirty		  ;AN000;
 16172                                  	;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 16173                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 16174                                  	
 16175 00003729 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 16176                                  ;yesdirty3:
 16177 0000372E A0[3305]                	MOV	AL,[THISDRV]
 16178                                  ;;;; 10/1/86 F.C update fastopen cache
 16179 00003731 52                      	PUSH	DX
 16180 00003732 57                      	PUSH	DI
 16181 00003733 B400                    	MOV	AH,0		  ; dir entry update
 16182 00003735 88C2                    	MOV	DL,AL		  ; drive number A=0,B=1,,
 16183 00003737 89DF                    	MOV	DI,BX		  ; ES:DI -> dir entry
 16184 00003739 E846FD                  	call	FastOpen_Update
 16185 0000373C 5F                      	POP	DI
 16186 0000373D 5A                      	POP	DX
 16187                                  ;;;; 9/11/86 F.C update fastopen cache
 16188 0000373E E82D2B                  	call	FLUSHBUF
 16189 00003741 7303                    	JNC	short OK_BYE
 16190 00003743 B80200                  	MOV	AX,error_file_not_found
 16191                                  OK_BYE:
 16192 00003746 E8CCE9                  	call	LcritDisk
 16193 00003749 C3                      	retn
 16194                                  
 16195                                  	; MSDOS 6.0
 16196                                  ;GET_FAST_PATH:
 16197                                  ;hkn; use SS override for FastOpenFlg
 16198                                  	;OR	byte [FastOpenFlg],FastOpen_Set
 16199                                  	;				;FO. trigger fastopen	;AN000;
 16200                                  	;call	GETPATH
 16201                                  	;PUSHF			 	;FO.			;AN000;
 16202                                  	;AND	byte [FastOpenFlg],Fast_yes 
 16203                                  	;				;FO. clear all fastopen flags ;AN000;
 16204                                  	;POPF				;FO.			;AN000;
 16205                                  	;retn
 16206                                  
 16207                                  ;============================================================================
 16208                                  ; DUP.ASM, MSDOS 6.0, 1991
 16209                                  ;============================================================================
 16210                                  ; 08/08/2018 - Retro DOS v3.0
 16211                                  
 16212                                  ;**	Low level DUP routine for use by EXEC when creating a new process. Exports
 16213                                  ;	  the DUP to the server machine and increments the SFT ref count
 16214                                  ;
 16215                                  ;	DOS_DUP
 16216                                  ;
 16217                                  ;	Modification history:
 16218                                  ;
 16219                                  ;	  Created: ARR 30 March 1983
 16220                                  
 16221                                  ;BREAK <DOS_DUP -- DUP SFT across network>
 16222                                  ;---------------------------------------------------------------------------
 16223                                  ; Procedure Name : DOS_DUP
 16224                                  ;
 16225                                  ; Inputs:
 16226                                  ;	[THISSFT] set to the SFT for the file being DUPed
 16227                                  ;		(a non net SFT is OK, in this case the ref
 16228                                  ;		 count is simply incremented)
 16229                                  ; Function:
 16230                                  ;	Signal to the devices that a logical open is occurring
 16231                                  ; Returns:
 16232                                  ;	ES:DI point to SFT
 16233                                  ;    Carry clear
 16234                                  ;	SFT ref_count is incremented
 16235                                  ; Registers modified: None.
 16236                                  ; NOTE:
 16237                                  ;	This routine is called from $CREATE_PROCESS_DATA_BLOCK at DOSINIT
 16238                                  ;	time with SS NOT DOSGROUP. There will be no Network handles at
 16239                                  ;	that time.
 16240                                  ;---------------------------------------------------------------------------
 16241                                  
 16242                                  DOS_DUP:
 16243 0000374A 2EC43E[5A05]            	LES	DI,[CS:THISSFT]
 16244                                  
 16245                                  	;Entry	Dos_Dup_Direct
 16246                                  DOS_Dup_Direct:
 16247 0000374F E832E9                  	call	IsSFTNet
 16248 00003752 7503                    	JNZ	short DO_INC
 16249 00003754 E85619                  	call	DEV_OPEN_SFT
 16250                                  DO_INC:
 16251                                  	;INC	word [ES:DI+SF_ENTRY.sf_ref_count]
 16252 00003757 26FF05                  	inc	word [ES:DI]		; Clears carry (if this ever wraps
 16253                                  					;   we're in big trouble anyway)
 16254 0000375A C3                      	retn
 16255                                  
 16256                                  ;============================================================================
 16257                                  ; CREATE.ASM, MSDOS 6.0, 1991
 16258                                  ;============================================================================
 16259                                  ; 08/08/2018 - Retro DOS v3.0
 16260                                  
 16261                                  ;TITLE	DOS_CREATE/DOS_CREATE_NEW - Internal CREATE calls for MS-DOS
 16262                                  ;NAME	DOS_CREATE
 16263                                  
 16264                                  ;**	Internal Create and Create new to create a local or NET file and SFT.
 16265                                  ;
 16266                                  ;	DOS_CREATE
 16267                                  ;	DOS_CREATE_NEW
 16268                                  ;	SET_MKND_ERR
 16269                                  ;	SET_Media_ID
 16270                                  ;	SET_EXT_Mode
 16271                                  ;
 16272                                  ;	Revision history:
 16273                                  ;
 16274                                  ;	    A000 version 4.00	  Jan. 1988
 16275                                  ;	    A001  D490 -- Change IOCTL subfunctios from 63h,43h to 66h, 46h
 16276                                  
 16277                                  ;Installed = TRUE
 16278                                  
 16279                                  ;	i_need	THISSFT,DWORD
 16280                                  ;	i_need	THISCDS,DWORD
 16281                                  ;	I_need	EXTERR,WORD
 16282                                  ;	I_Need	ExtErr_locus,BYTE
 16283                                  ;	I_need	JShare,DWORD
 16284                                  ;	I_need	VOLCHNG_FLAG,BYTE
 16285                                  ;	I_need	SATTRIB,BYTE
 16286                                  ;	I_need	CALLVIDM,DWORD
 16287                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000; extended open
 16288                                  ;	I_need	NAME1,BYTE			  ;AN000;
 16289                                  ;	I_need	NO_NAME_ID,BYTE 		  ;AN000;
 16290                                  ;	I_need	Packet_Temp,WORD		  ;AN000;
 16291                                  ;	I_need	DOS34_FLAG,WORD 		  ;AN000;
 16292                                  ;	I_need	SAVE_BX,WORD			  ;AN000;
 16293                                  
 16294                                  ;***	DOS_CREATE - Create a File
 16295                                  ;----------------------------------------------------------------------------
 16296                                  ;	DOS_Create is called to create the specified file, truncating
 16297                                  ;	the old one if it exists.
 16298                                  ;
 16299                                  ;
 16300                                  ;	ENTRY	AX is Attribute to create
 16301                                  ;		(ds) = DOSDATA
 16302                                  ;		[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16303                                  ;			terminated)
 16304                                  ;		[CURR_DIR_END] Points to end of Current dir part of string
 16305                                  ;			( = -1 if current dir not involved, else
 16306                                  ;			 Points to first char after last "/" of current dir part)
 16307                                  ;		[THISCDS] Points to CDS being used
 16308                                  ;			(Low word = -1 if NUL CDS (Net direct request))
 16309                                  ;		[THISSFT] Points to SFT to fill in if file created
 16310                                  ;			(sf_mode field set so that FCB may be detected)
 16311                                  ;		[SATTRIB] Is attribute of search, determines what files can be found
 16312                                  ;
 16313                                  ;	EXIT	sf_ref_count is NOT altered
 16314                                  ;		CARRY CLEAR
 16315                                  ;		    THISSFT filled in.
 16316                                  ;			sf_mode = unchanged for FCB, sharing_compat + open_for_both
 16317                                  ;		CARRY SET
 16318                                  ;		    AX is error code
 16319                                  ;			error_path_not_found
 16320                                  ;				Bad path (not in curr dir part if present)
 16321                                  ;			error_bad_curr_dir
 16322                                  ;				Bad path in current directory part of path
 16323                                  ;			error_access_denied
 16324                                  ;				Attempt to re-create read only file , or
 16325                                  ;				create a second volume id or create a dir
 16326                                  ;			error_sharing_violation
 16327                                  ;				The sharing mode was correct but not allowed
 16328                                  ;				generates an INT 24
 16329                                  ;	USES	all but DS
 16330                                  ;----------------------------------------------------------------------------
 16331                                  
 16332                                  DOS_CREATE:
 16333                                  
 16334                                  ;hkn; dispatched to from file.asm and fcbio.asm. DS set up to DOSDATA at 
 16335                                  ;hkn; this point.
 16336                                  
 16337 0000375B 30E4                    	XOR	AH,AH		; Truncate is OK
 16338                                  
 16339                                  ;	Enter here from Dos_Create_New
 16340                                  ;
 16341                                  ;	(ah) = 0 iff truncate OK
 16342                                  
 16343                                  Create_inter:
 16344 0000375D A8C0                    	TEST	AL,~(attr_all+attr_ignore+attr_volume_id) ; 80h
 16345                                  				; Mask out any meaningless bits
 16346 0000375F 750C                    	JNZ	short AttErr
 16347 00003761 A808                    	TEST	AL,attr_volume_id
 16348 00003763 7402                    	JZ	short NoReset
 16349                                  	;
 16350                                  	; MSDOS 6.0
 16351                                  	;OR	[DOS34_FLAG],DBCS_VOLID      ;AN000;FOR dbcs volid
 16352                                  	;
 16353 00003765 B008                    	MOV	AL,attr_volume_id
 16354                                  NoReset:
 16355 00003767 0C20                    	OR	AL,attr_archive ; File changed
 16356 00003769 A850                    	TEST	AL,attr_directory+attr_device
 16357 0000376B 740A                    	JZ	short ATT_OK
 16358                                  AttErr:
 16359 0000376D B80500                  	MOV	AX,5		; Attribute problem
 16360 00003770 C606[EF02]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk
 16361 00003775 EB3D                    	JMP	SHORT SET_MKND_ERR ; Gotta use MKDIR to make dirs, NEVER allow
 16362                                  				   ;	attr_device to be set.
 16363                                  ATT_OK:
 16364 00003777 C43E[5A05]              	LES	DI,[THISSFT]
 16365 0000377B 06                      	PUSH	ES
 16366 0000377C C436[5E05]              	LES	SI,[THISCDS]
 16367 00003780 83FEFF                  	CMP	SI,-1
 16368 00003783 7509                    	JNE	short TEST_RE_NET
 16369                                  
 16370                                  ;	No CDS, it must be redirected.
 16371                                  
 16372 00003785 07                      	POP	ES
 16373                                  
 16374                                  	; MSDOS 6.0
 16375                                  ;Extended open hooks
 16376                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
 16377                                  	;JZ	short NOEXTOP 		    ;AN000;EO. no, do normal
 16378                                  ;IFS_extopen:				    ;AN000;EO.
 16379                                  	;PUSH	AX			    ;AN000;EO. pass create attr
 16380                                  	;;MOV	AX,(MultNET SHL 8) OR 46    ;AN000;EO. issue extended open verb
 16381                                  	;mov	ax,112Eh
 16382                                  	;INT	2FH			    ;AN000;EO.
 16383                                  	;POP	BX			    ;AN000;EO. trash bx
 16384                                  	;MOV	byte [EXTOPEN_ON],0	    ;AN000;EO.
 16385                                  	;retn				    ;AN000;EO.
 16386                                  ;NOEXTOP:				    ;AN000;
 16387                                  ;Extended open hooks
 16388                                  
 16389                                  ;IF NOT Installed
 16390                                  ;	transfer NET_SEQ_CREATE
 16391                                  ;ELSE
 16392 00003786 50                      	PUSH	AX
 16393                                  
 16394                                  	;MOV	AX,(MultNET SHL 8) OR 24
 16395                                  	;INT	2FH
 16396                                  
 16397 00003787 B81811                  	mov     ax,1118h
 16398 0000378A CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE FILE
 16399                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 16400                                  			; SDA first filename pointer -> fully-qualified name of file
 16401                                  			; STACK: WORD file creation mode???
 16402                                  
 16403 0000378C 5B                      	POP	BX			; BX is trashed anyway
 16404 0000378D C3                      	retn
 16405                                  ;ENDIF
 16406                                  
 16407                                  ;	We have a CDS. See if it's network
 16408                                  
 16409                                  TEST_RE_NET:
 16410 0000378E 26F744430080            	TEST	word [ES:SI+curdir.flags],curdir_isnet
 16411 00003794 07                      	POP	ES
 16412 00003795 7408                    	JZ	short LOCAL_CREATE
 16413                                  
 16414                                  	; MSDOS 6.0
 16415                                  	;CALL	Set_EXT_mode		    ;AN000;EO.
 16416                                  	;JC	SHORT dochk		    ;AN000;EO.
 16417                                  	;OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both ;IFS.
 16418                                  
 16419                                  ;Extended open hooks
 16420                                  ;dochk:
 16421                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;AN000;EO. from extended open
 16422                                  	;JNZ	short IFS_extopen	    ;AN000;EO. yes, issue extended open
 16423                                  ;Extended open hooks
 16424                                  
 16425                                  ;IF NOT Installed
 16426                                  ;	transfer NET_CREATE
 16427                                  ;ELSE
 16428 00003797 50                      	PUSH	AX
 16429                                  	
 16430                                  	;MOV	AX,(MultNET SHL 8) OR 23
 16431                                  	;INT	2FH
 16432                                  	
 16433 00003798 B81711                  	mov     ax,1117h
 16434 0000379B CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CREATE/TRUNCATE REMOTE FILE
 16435                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 16436                                  			; SDA first filename pointer -> fully-qualified name of file to open
 16437                                  			; SDA CDS pointer -> current directory
 16438                                  			; Return: CF set on error
 16439                                  
 16440 0000379D 5B                      	POP	BX			; BX is trashed anyway
 16441                                  ;nomore:
 16442 0000379E C3                      	retn
 16443                                  ;ENDIF
 16444                                  
 16445                                  ;**	It's a local create. We have a local CDS for it.
 16446                                  
 16447                                  LOCAL_CREATE:
 16448                                  	; MSDOS 6.0
 16449                                  	;CALL	Set_EXT_mode	;AN000;EO. set mode if from extended open
 16450                                  	;JC	short setdone	;AN000;EO.
 16451                                  	
 16452                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16453 0000379F 26834D0202              	OR	word [ES:DI+SF_ENTRY.sf_mode],SHARING_COMPAT+open_for_both
 16454                                  ;setdone:
 16455 000037A4 E866E9                  	call	EcritDisk
 16456 000037A7 E80F1B                  	call	MakeNode
 16457 000037AA 730E                    	JNC	short Create_ok
 16458 000037AC C606[370A]FF            	mov	byte [VOLCHNG_FLAG],-1	; indicate no change in volume label
 16459 000037B1 E861E9                  	call	LcritDisk
 16460                                  
 16461                                  	;entry	SET_MKND_ERR
 16462                                  SET_MKND_ERR:
 16463                                  
 16464                                  ;	Looks up MakeNode errors and converts them. AL is MakeNode
 16465                                  ;	error, SI is GETPATH bad spot return if path_not_found error.
 16466                                  
 16467                                  ;hkn; CRTERRTAB is in TABLE seg (DOSCODE)
 16468 000037B4 BB[3B13]                	MOV     BX,CRTERRTAB
 16469 000037B7 D7                      	XLAT
 16470                                  	;XLAT	byte [CS:BX]
 16471                                  CreatBadRet:
 16472 000037B8 F9                      	STC
 16473 000037B9 C3                      	retn
 16474                                  
 16475                                  ; We have just created a new file. This results in the truncation of old
 16476                                  ; files. We must inform the sharer to slash all the open SFT's for this
 16477                                  ; file to the current size.
 16478                                  
 16479                                  ; If we created a volume id on the diskette, set the VOLCHNG_FLAG to logical
 16480                                  ; drive number to force a Build BPB after Media Check.
 16481                                  
 16482                                  ;;; FASTOPEN 8/29/86
 16483                                  Create_ok:
 16484 000037BA E8B1FC                  	call	FastOpen_Delete
 16485                                  ;;; FASTOPEN 8/29/86
 16486 000037BD A0[2A05]                	mov	al,[SATTRIB]
 16487 000037C0 A808                    	test	al,attr_volume_id
 16488 000037C2 7417                    	jz	short NoVolLabel
 16489 000037C4 C43E[5E05]              	LES	DI,[THISCDS]
 16490                                  	;mov	ah,[ES:DI+curdir.text]	; get drive letter
 16491 000037C8 268A25                  	mov	ah,[ES:DI] ; 09/08/2018
 16492 000037CB 80EC41                  	sub	ah,'A'                  ; convert to drive letter
 16493 000037CE 8826[370A]              	mov	[VOLCHNG_FLAG],ah	;Set flag to indicate volid change
 16494                                  	
 16495                                  	; MSDOS 6.0
 16496                                  	;MOV	BH,1			;AN000;>32mb set volume id to boot record
 16497                                  	;CALL	Set_Media_ID		;AN000;>32mb
 16498                                  	
 16499 000037D2 E838E9                  	call	EcritDisk
 16500 000037D5 E8F926                  	call	FATREAD_CDS		; force a media check
 16501 000037D8 E83AE9                  	call	LcritDisk
 16502                                  
 16503                                  NoVolLabel:
 16504 000037DB B80200                  	MOV	ax,2
 16505 000037DE C43E[5A05]              	LES	DI,[THISSFT]
 16506                                  ;if installed
 16507                                  	;call	JShare + 14 * 4
 16508 000037E2 FF1E[9400]              	call	far [JShare+(14*4)] ; 14 = ShSU
 16509                                  ;else
 16510                                  ;	Call	ShSU
 16511                                  ;endif
 16512 000037E6 E82CE9                  	call	LcritDisk
 16513 000037E9 E9D800                  	jmp	SET_SFT_MODE
 16514                                  
 16515                                  ;---------------------------------------------------------------------------
 16516                                  ; Procedure Name : Dos_Create_New
 16517                                  ;
 16518                                  ; Inputs:
 16519                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16520                                  ;		terminated)
 16521                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16522                                  ;		( = -1 if current dir not involved, else
 16523                                  ;		 Points to first char after last "/" of current dir part)
 16524                                  ;	[THISCDS] Points to CDS being used
 16525                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16526                                  ;	[THISSFT] Points to SFT to fill in if file created
 16527                                  ;		(sf_mode field set so that FCB may be detected)
 16528                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16529                                  ;	AX is Attribute to create
 16530                                  ; Function:
 16531                                  ;	Try to create the specified file truncating an old one that exists
 16532                                  ; Outputs:
 16533                                  ;	sf_ref_count is NOT altered
 16534                                  ;	CARRY CLEAR
 16535                                  ;	    THISSFT filled in.
 16536                                  ;		sf_mode = sharing_compat + open_for_both for Non-FCB SFT
 16537                                  ;	CARRY SET
 16538                                  ;	    AX is error code
 16539                                  ;		error_path_not_found
 16540                                  ;			Bad path (not in curr dir part if present)
 16541                                  ;		error_bad_curr_dir
 16542                                  ;			Bad path in current directory part of path
 16543                                  ;		error_access_denied
 16544                                  ;			Create a second volume id or create a dir
 16545                                  ;		error_file_exists
 16546                                  ;			Already a file by this name
 16547                                  ; DS preserved, others destroyed
 16548                                  ;---------------------------------------------------------------------------
 16549                                  
 16550                                  DOS_Create_New:
 16551 000037EC B401                    	MOV	AH,1		; Truncate is NOT OK
 16552 000037EE E96CFF                  	JMP	Create_inter
 16553                                  
 16554                                  ; MSDOS 6.0
 16555                                  ;---------------------------------------------------------------------------
 16556                                  ; Procedure Name : Set_Media_ID
 16557                                  ;
 16558                                  ; Inputs:
 16559                                  ;	NAME1= Volume ID
 16560                                  ;	BH= 0, delete volume id
 16561                                  ;	    1, set new volume id
 16562                                  ;	DS= DOSGROUP
 16563                                  ; Function:
 16564                                  ;	Set Volume ID to DOS 4.00 Boot record.
 16565                                  ; Outputs:
 16566                                  ;	CARRY CLEAR
 16567                                  ;	    volume id set
 16568                                  ;	CARRY SET
 16569                                  ;	    AX is error code
 16570                                  ;---------------------------------------------------------------------------
 16571                                  ;
 16572                                  ;procedure   Set_Media_ID,NEAR
 16573                                  ;	DOSAssume   <DS>,"SetMedID"
 16574                                  ;
 16575                                  ;	PUSH	AX		;AN000;;>32mb
 16576                                  ;	PUSH	ES		;AN000;;>32mb
 16577                                  ;	PUSH	DI		;AN000;;>32mb
 16578                                  ;
 16579                                  ;	INC	AH		;AN000;;>32mb  bl=drive #
 16580                                  ;	MOV	BL,AH		;AN000;;>32mb  bl=drive # (A=1,B=2,,,)
 16581                                  ;	MOV	AL,0DH		;AN000;;>32mb  generic IOCTL
 16582                                  ;	MOV	CX,0866H	;AN001;;>32mb  get media id
 16583                                  ;
 16584                                  ;hkn; PACKET_TEMP is in DOSDATA
 16585                                  ;	MOV	DX,OFFSET DOSDATA:PACKET_TEMP	;AN000;>32mb
 16586                                  ;
 16587                                  ;	PUSH	BX		;AN000;;>32mb
 16588                                  ;	PUSH	DX		;AN000;;>32mb
 16589                                  ;	XOR	BH,BH		;AN000;;>32mb
 16590                                  ;
 16591                                  ;	invoke	$IOCTL		;AN000;;>32mb
 16592                                  ;	POP	DX		;AN000;;>32mb
 16593                                  ;	POP	BX		;AN000;;>32mb
 16594                                  ;	JC	geterr		;AN000;;>32mb
 16595                                  ;
 16596                                  ;	OR	BH,BH		;AN000;;>32mb delete volume id
 16597                                  ;	JZ	NoName		;AN000;>32mb yes
 16598                                  ;
 16599                                  ;hkn; NAME1 is in DOSDATA
 16600                                  ;	MOV	SI,OFFSET DOSDATA:NAME1   ;AN000;>32mb
 16601                                  ;
 16602                                  ;	JMP	SHORT doset	;AN000;>32mb yes
 16603                                  ;Noname: 			;AN000;
 16604                                  ;
 16605                                  ;hkn; NO_NAME_ID is in DOSDATA
 16606                                  ;	MOV	SI,OFFSET DOSDATA:NO_NAME_ID  ;AN000;>32mb
 16607                                  ;
 16608                                  ;doset:					       ;AN000;
 16609                                  ;	MOV	DI,DX		;AN000;;>32mb
 16610                                  ;	ADD	DI,MEDIA_LABEL	;AN000;;>32mb
 16611                                  ;
 16612                                  ;hkn; ES & DS must point to SS
 16613                                  ;hkn;	PUSH	CS		;AN000;;>32mb  move new volume id to packet
 16614                                  ;	PUSH	SS		;AN000;;>32mb  move new volume id to packet
 16615                                  ;
 16616                                  ;	POP	DS		;AN000;;>32mb
 16617                                  ;
 16618                                  ;hkn;	PUSH	CS		;AN000;;>32mb
 16619                                  ;	PUSH	SS		;AN000;;>32mb
 16620                                  ;
 16621                                  ;	POP	ES		;AN000;;>32mb
 16622                                  ;	MOV	CX,11		;AN000;;>32mb
 16623                                  ;	REP	MOVSB		;AN000;;>32mb
 16624                                  ;	MOV	CX,0846H	;AN001;;>32mb
 16625                                  ;	MOV	AL,0DH		;AN000;;>32mb
 16626                                  ;	XOR	BH,BH		;AN000;;>32mb
 16627                                  ;	invoke	$IOCTL		;AN000;;>32mb  set volume id
 16628                                  ;geterr: 			;AN000;
 16629                                  ;
 16630                                  ;hkn;	PUSH	CS		;AN000;>32mb
 16631                                  ;	PUSH	SS		;AN000;>32mb
 16632                                  ;
 16633                                  ;	POP	DS		;AN000;>32mb   ds= dosgroup
 16634                                  ;
 16635                                  ;	POP	DI		;AN000;;>32mb
 16636                                  ;	POP	ES		;AN000;;>32mb
 16637                                  ;	POP	AX		;AN000;;>32mb
 16638                                  ;	return			;AN000;>32mb
 16639                                  ;
 16640                                  ;EndProc Set_Media_ID		;AN000;
 16641                                  
 16642                                  ; MSDOS 6.0
 16643                                  ;---------------------------------------------------------------------------
 16644                                  ; Procedure Name : Set_EXT_mode
 16645                                  ;
 16646                                  ; Inputs:
 16647                                  ;	[EXTOPEN_ON]= flag for extended open
 16648                                  ;	SAVE_BX= mode specified in Extended Open
 16649                                  ; Function:
 16650                                  ;	Set mode in ThisSFT
 16651                                  ; Outputs:
 16652                                  ;	carry set,mode is set if from Extended Open
 16653                                  ;	carry clear, mode not set yet
 16654                                  ;---------------------------------------------------------------------------
 16655                                  ;
 16656                                  ;procedure   Set_EXT_mode,NEAR
 16657                                  ;
 16658                                  ;hkn; SS override
 16659                                  ;	TEST	[EXTOPEN_ON],ext_open_on    ;AN000;EO. from extended open
 16660                                  ;	JZ	NOTEX			    ;AN000;EO. no, do normal
 16661                                  ;	PUSH	AX			    ;AN000;EO.
 16662                                  ;
 16663                                  ;hkn; SS override
 16664                                  ;	MOV	AX,[SAVE_BX]		    ;AN000;EO.
 16665                                  ;	OR	ES:[DI.sf_mode],AX	    ;AN000;EO.
 16666                                  ;	POP	AX			    ;AN000;EO.
 16667                                  ;	STC				    ;AN000;EO.
 16668                                  ;NOTEX:					    ;AN000;
 16669                                  ;	return				    ;AN000;EO.
 16670                                  ;
 16671                                  ;EndProc Set_EXT_mode			    ;AN000;
 16672                                  
 16673                                  ;============================================================================
 16674                                  ; OPEN.ASM, MSDOS 6.0, 1991
 16675                                  ;============================================================================
 16676                                  ; 08/08/2018 - Retro DOS v3.0
 16677                                  
 16678                                  ;	TITLE	DOS_OPEN - Internal OPEN call for MS-DOS
 16679                                  ;	NAME	DOS_OPEN
 16680                                  
 16681                                  ;**	OPEN.ASM - File Open
 16682                                  ;----------------------------------------------------------------------------
 16683                                  ;	Low level routines for openning a file from a file spec.
 16684                                  ;	Also misc routines for sharing errors
 16685                                  ;
 16686                                  ;	DOS_Open
 16687                                  ;	Check_Access_AX
 16688                                  ;	SHARE_ERROR
 16689                                  ;	SET_SFT_MODE
 16690                                  ;	Code_Page_Mismatched_Error		   ; DOS 4.00
 16691                                  ;
 16692                                  ;	Revision history:
 16693                                  ;
 16694                                  ;	    Created: ARR 30 March 1983
 16695                                  ;	    A000	version 4.00   Jan. 1988
 16696                                  ;
 16697                                  ;	M034 - The value in save_bx must be pushed on to the stack for
 16698                                  ; 	       remote extended opens and not save_cx.
 16699                                  ;
 16700                                  ;	M035 - if open made from exec then we must set the appropriate bits
 16701                                  ;	       on the stack before calling off to the redir.
 16702                                  ;	M042 - Bit 11 of DOS34_FLAG set indicates that the redir knows how 
 16703                                  ;	       to handle open from exec. In this case set the appropriate bit
 16704                                  ;	       else do not.
 16705                                  ;----------------------------------------------------------------------------	
 16706                                  
 16707                                  ;Installed = TRUE
 16708                                  
 16709                                  ;	i_need	NoSetDir,BYTE
 16710                                  ;	i_need	THISSFT,DWORD
 16711                                  ;	i_need	THISCDS,DWORD
 16712                                  ;	i_need	CURBUF,DWORD
 16713                                  ;	i_need	CurrentPDB,WORD
 16714                                  ;	i_need	CURR_DIR_END,WORD
 16715                                  ;	I_need	RetryCount,WORD
 16716                                  ;	I_need	Open_Access,BYTE
 16717                                  ;	I_need	fSharing,BYTE
 16718                                  ;	i_need	JShare,DWORD
 16719                                  ;	I_need	FastOpenFlg,byte
 16720                                  ;	I_need	EXTOPEN_ON,BYTE 		  ;AN000;; DOS 4.00
 16721                                  ;	I_need	ALLOWED,BYTE			  ;AN000;; DOS 4.00
 16722                                  ;	I_need	EXTERR,WORD			  ;AN000;; DOS 4.00
 16723                                  ;	I_need	EXTERR_LOCUS,BYTE		  ;AN000;; DOS 4.00
 16724                                  ;	I_need	EXTERR_ACTION,BYTE		  ;AN000;; DOS 4.00
 16725                                  ;	I_need	EXTERR_CLASS,BYTE		  ;AN000;; DOS 4.00
 16726                                  ;	I_need	CPSWFLAG,BYTE			  ;AN000;; DOS 4.00
 16727                                  ;	I_need	EXITHOLD,DWORD			  ;AN000;; DOS 4.00
 16728                                  ;	I_need	THISDPB,DWORD			  ;AN000;; DOS 4.00
 16729                                  ;	I_need	SAVE_CX,WORD			  ;AN000;; DOS 4.00
 16730                                  ;	I_need	SAVE_BX,WORD			  ;M034
 16731                                  ;
 16732                                  ;	I_need	DOS_FLAG,BYTE
 16733                                  ;	I_need	DOS34_FLAG,WORD			  ;M042
 16734                                  
 16735                                  ;Break	<DOS_Open - internal file access>
 16736                                  ;---------------------------------------------------------------------------
 16737                                  ; Procedure Name : DOS_Open
 16738                                  ;
 16739                                  ; Inputs:
 16740                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 16741                                  ;		terminated)
 16742                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 16743                                  ;		( = -1 if current dir not involved, else
 16744                                  ;		 Points to first char after last "/" of current dir part)
 16745                                  ;	[THISCDS] Points to CDS being used
 16746                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 16747                                  ;	[THISSFT] Points to SFT to fill in if file found
 16748                                  ;		(sf_mode field set so that FCB may be detected)
 16749                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 16750                                  ;	AX is Access and Sharing mode
 16751                                  ;	  High NIBBLE of AL (Sharing Mode)
 16752                                  ;		sharing_compat	   file is opened in compatibility mode
 16753                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 16754                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 16755                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 16756                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 16757                                  ;	  Low NIBBLE of AL (Access Mode)
 16758                                  ;		open_for_read	file is opened for reading
 16759                                  ;		open_for_write	file is opened for writing
 16760                                  ;		open_for_both	file is opened for both reading and writing.
 16761                                  ;
 16762                                  ;	  For FCB SFTs AL should = sharing_compat + open_for_both
 16763                                  ;		(not checked)
 16764                                  ; Function:
 16765                                  ;	Try to open the specified file
 16766                                  ; Outputs:
 16767                                  ;	sf_ref_count is NOT altered
 16768                                  ;	CARRY CLEAR
 16769                                  ;	    THISSFT filled in.
 16770                                  ;	CARRY SET
 16771                                  ;	    AX is error code
 16772                                  ;		error_file_not_found
 16773                                  ;			Last element of path not found
 16774                                  ;		error_path_not_found
 16775                                  ;			Bad path (not in curr dir part if present)
 16776                                  ;		error_bad_curr_dir
 16777                                  ;			Bad path in current directory part of path
 16778                                  ;		error_invalid_access
 16779                                  ;			Bad sharing mode or bad access mode or bad combination
 16780                                  ;		error_access_denied
 16781                                  ;			Attempt to open read only file for writting, or
 16782                                  ;			open a directory
 16783                                  ;		error_sharing_violation
 16784                                  ;			The sharing mode was correct but not allowed
 16785                                  ;			generates an INT 24 on compatibility mode SFTs
 16786                                  ; DS preserved, others destroyed
 16787                                  ;----------------------------------------------------------------------------
 16788                                  
 16789                                  DOS_OPEN:
 16790                                  	; DS has been set up to DOSDATA in file.asm and fcbio2.asm. 
 16791                                  
 16792 000037F1 C606[1603]00            	MOV	byte [NoSetDir],0
 16793 000037F6 E80001                  	CALL	Check_Access_AX
 16794 000037F9 721C                    	JC	short do_ret_label		    ; retc
 16795                                  
 16796 000037FB C43E[5A05]              	LES	DI,[THISSFT]
 16797 000037FF 30E4                    	XOR	AH,AH
 16798                                  
 16799                                  	; sleaze! move only access/sharing mode in. Leave sf_isFCB unchanged
 16800                                  
 16801 00003801 26884502                	MOV	[ES:DI+SF_ENTRY.sf_mode],AL ; For moment do this on FCBs too
 16802 00003805 06                      	PUSH	ES
 16803 00003806 C436[5E05]              	LES	SI,[THISCDS]
 16804                                  	; 18/08/2018
 16805 0000380A 83FEFF                  	CMP	SI,-1
 16806 0000380D 7509                    	JNZ	short TEST_RE_NET1
 16807 0000380F 07                      	POP	ES
 16808                                  
 16809                                  	; MSDOS 6.0
 16810                                  ;Extended open hooks
 16811                                  	;TEST	byte [EXTOPEN_ON],ext_open_on	;FT. from extnded open		;AN000;
 16812                                  	;JZ	short NOEXTOP 		    ;FT. no, do normal			;AN000;
 16813                                  IFS_extopen:									;AN000;
 16814                                  	;MOV	AL,[SAVE_BX]		    ; M034 - save_bx has original bx  
 16815                                  	;				    ; with which call was made. This
 16816                                  	;				    ; has the open access bits. 
 16817                                  	;;;MOV	AL,[SAVE_CX]		    ; M034 - FT. al= create attribute
 16818                                  	;
 16819                                  	;PUSH	AX			    ;FT. pass create attr to IFS	;AN000;
 16820                                  	;;MOV	AX,(MultNET SHL 8) OR 46    ;FT. issue extended open verb	;AN000;
 16821                                  	;mov	ax,(MultNET*256)+46 
 16822                                  	;INT	2FH			    ;FT.				;AN000;
 16823                                  	;POP	BX			    ;FT. trash bx			;AN000;
 16824                                  	;MOV	byte [EXTOPEN_ON],0	    ;FT.				;AN000;
 16825                                  
 16826                                  ;do_ret_label:
 16827                                  	;retn				    ;FT.				;AN000;
 16828                                  ;NOEXTOP:
 16829                                  ;Extended open hooks
 16830                                  	;
 16831                                  ;IF NOT Installed
 16832                                  	;transfer NET_SEQ_OPEN
 16833                                  ;ELSE
 16834                                  	;
 16835                                  do_net_int2f:
 16836                                  	;
 16837                                  	;test	byte [DOS_FLAG],EXECOPEN ; Q: was this open call made from exec
 16838                                  	;jz	short not_exec_open	; N: just do net open
 16839                                  	;				; Y: check to see if redir is aware
 16840                                  	;				;    of this 
 16841                                  	;
 16842                                  	;				; M042 - start
 16843                                  	;test	word [DOS34_FLAG],EXEC_AWARE_REDIR
 16844                                  	;				; Q: does this redir know how to 
 16845                                  	;				;    this
 16846                                  	;jz	short not_exec_open	; N: just do net open
 16847                                  	;				; Y: set bit 3 of access byte and 
 16848                                  	;				;    set sharing mode to DENY_WRITE
 16849                                  	;				; M042 - end
 16850                                  	;
 16851                                  	; NOTE: This specific mode has not been set for the code assembled
 16852                                  	; under the "NOT Installed" conditional. Currently Installed is 
 16853                                  	; always one.
 16854                                  	;				; M035 - set the bits on the stack
 16855                                  	;mov	AL,SHARING_DENY_WRITE+EXEC_OPEN
 16856                                  	;
 16857                                  ;not_exec_open:
 16858                                  
 16859                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16860 00003810 50                      	PUSH	AX
 16861                                  
 16862                                  	;MOV	AX,(MultNET SHL 8) OR 22
 16863                                  	;INT	2FH
 16864                                  
 16865 00003811 B81611                  	mov     ax,1116h
 16866 00003814 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - OPEN EXISTING REMOTE FILE
 16867                                  			; ES:DI -> uninitialized SFT, SS = DOS CS
 16868                                  			; SDA first filename pointer -> fully-qualified name of file to open
 16869                                  			; STACK: WORD file open mode
 16870                                  			; Return: CF set on error
 16871                                  
 16872 00003816 5B                      	POP	BX			; clean stack
 16873                                  do_ret_label: ; 09/08/2018
 16874 00003817 C3                      	retn
 16875                                  ;ENDIF
 16876                                  
 16877                                  TEST_RE_NET1:
 16878 00003818 26F744430080            	TEST	word [ES:SI+curdir.flags],curdir_isnet
 16879                                  	; 18/08/2018
 16880 0000381E 07                      	POP	ES
 16881                                  	;JZ	short LOCAL_OPEN
 16882                                  
 16883 0000381F 75EF                    	jnz	short do_net_int2f ; (*)
 16884                                  
 16885                                  ;Extended open hooks
 16886                                  	; MSDOS 6.0
 16887                                  	;TEST	byte [EXTOPEN_ON],ext_open_on ;FT. from extended open	;AN000;
 16888                                  	;JNZ	short IFS_extopen	      ;FT. isuue extended open	;AN000;
 16889                                  ;Extended open hooks
 16890                                  
 16891                                  ;IF NOT Installed
 16892                                  ;	transfer NET_OPEN
 16893                                  ;ELSE
 16894                                  	;jmp	short do_net_int2f (*)
 16895                                  ;ENDIF
 16896                                  
 16897                                  LOCAL_OPEN:
 16898                                  	; MSDOS 3.3 (& MSDOS 6.0)
 16899 00003821 E8E9E8                  	call	EcritDisk
 16900                                  
 16901                                  ; DOS 3.3 FastOPen 6/16/86
 16902                                  
 16903 00003824 800E[A40F]05            	OR	byte [FastOpenFlg],FastOpen_Set+Special_Fill_Set ; only open can
 16904                                  
 16905 00003829 E8F911                  	call	GETPATH
 16906                                  
 16907                                  ; DOS 3.3 FastOPen 6/16/86
 16908                                  
 16909 0000382C 731E                    	JNC	short Open_found
 16910 0000382E 7512                    	JNZ	short bad_path2
 16911 00003830 08C9                    	OR	CL,CL
 16912 00003832 740E                    	JZ	short bad_path2
 16913                                  
 16914                                  OpenFNF:
 16915 00003834 B80200                  	MOV	AX,error_file_not_found
 16916                                  
 16917                                  OpenBadRet:
 16918                                  ;hkn; FastOpenFlg is in DOSDATA use SS override
 16919                                  	; 12/08/2018
 16920                                  	;mov	byte [cs:FastOpenFlg],0 ; IBMDOS.COM (MSDOS 3.3) offset 36CAh
 16921                                  	; MSDOS 6.0
 16922 00003837 368026[A40F]80          	AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 16923 0000383D F9                      	STC
 16924 0000383E E8D4E8                  	call	LcritDisk
 16925                                  	;JMP	Clear_FastOpen ; 10/08/2018
 16926 00003841 C3                      	retn 	; 08/09/2018
 16927                                  
 16928                                  bad_path2:
 16929 00003842 B80300                  	MOV	AX,error_path_not_found
 16930 00003845 EBF0                    	JMP	short OpenBadRet
 16931                                  
 16932                                  Open_Bad_Access:
 16933 00003847 B80500                  	MOV	AX,error_access_denied
 16934 0000384A EBEB                    	JMP	short OpenBadRet
 16935                                  
 16936                                  Open_found:
 16937 0000384C 74F9                    	JZ	short Open_Bad_Access 	; test for directories
 16938 0000384E 08E4                    	OR	AH,AH
 16939 00003850 783F                    	JS	short open_ok		; Devices don't have attributes
 16940 00003852 8E06[A005]              	MOV	ES,[CURBUF+2]		; get buffer location
 16941 00003856 268A470B                	MOV	AL,[ES:BX+dir_entry.dir_attr]
 16942 0000385A A808                    	TEST	AL,attr_volume_id	; can't open volume ids
 16943 0000385C 75E9                    	JNZ	short Open_Bad_Access
 16944 0000385E A801                    	TEST	AL,attr_read_only	; check write on read only
 16945 00003860 742F                    	JZ	short open_ok
 16946                                  ;
 16947                                  ; The file is marked READ-ONLY. We verify that the open mode allows access to
 16948                                  ; the read-only file. Unfortunately, with FCB's and net-FCB's we cannot
 16949                                  ; determine at the OPEN time if such access is allowed. Thus, we defer such
 16950                                  ; processing until the actual write operation:
 16951                                  ;
 16952                                  ; If FCB, then we change the mode to be read_only.
 16953                                  ; If net_FCB, then we change the mode to be read_only.
 16954                                  ; If not open for read then error.
 16955                                  ;
 16956 00003862 1E                      	push	ds
 16957 00003863 56                      	push	si
 16958 00003864 C536[5A05]              	LDS	SI,[THISSFT]
 16959 00003868 8B4C02                  	MOV	CX,[SI+SF_ENTRY.sf_mode]
 16960 0000386B F7C10080                	TEST	CX,sf_isFCB		; is it FCB?
 16961 0000386F 750A                    	JNZ	short ResetAccess	; yes, reset the access
 16962 00003871 88CA                    	MOV	DL,CL
 16963 00003873 80E2F0                  	AND	DL,SHARING_MASK
 16964 00003876 80FA70                  	CMP	DL,SHARING_NET_FCB	; is it net FCB?
 16965 00003879 7508                    	JNZ	short NormalOpen	; no
 16966                                  ResetAccess:
 16967 0000387B 83E1F0                  	AND	CX,~access_mask	;0FFF0h	; clear access
 16968                                  ;	OR	CX,open_for_read	; stick in open_for_read
 16969 0000387E 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],CX
 16970 00003881 EB0C                    	JMP	SHORT FillSFT
 16971                                  ;
 16972                                  ; The SFT is normal.  See if the requested access is open_for_read
 16973                                  ;
 16974                                  NormalOpen:
 16975 00003883 80E10F                  	AND	CL,access_mask	;0Fh	; remove extras
 16976 00003886 80F900                  	CMP	CL,open_for_read	; is it open for read?
 16977 00003889 7404                    	JZ	short FillSFT
 16978 0000388B 5E                      	pop	si
 16979 0000388C 1F                      	pop	ds
 16980 0000388D EBB8                    	JMP	short Open_Bad_Access
 16981                                  ;
 16982                                  ; All done, restore registers and fill the SFT.
 16983                                  ;
 16984                                  FillSFT:
 16985 0000388F 5E                      	pop	si
 16986 00003890 1F                      	pop	ds
 16987                                  open_ok:
 16988 00003891 E8B91B                  	call	DOOPEN			; Fill in SFT
 16989                                  
 16990                                  ;hkn; FastOpenFlg is in DOSDATA. use SS override
 16991                                  	;12/08/2018
 16992                                  	;AND	BYTE [SS:FastOpenFlg],Fast_yes    ;; DOS 3.3
 16993 00003894 8026[A40F]80            	and	byte [FastOpenFlg],Fast_yes	
 16994                                  
 16995                                  	; MSDOS 6.0
 16996                                  	;CALL	DO_SHARE_CHECK
 16997                                  	;JNC	short SHARE_OK
 16998                                  	;call	LcritDisk
 16999                                  	;JMP	short Clear_FastOpen	
 17000                                  
 17001                                  	; MSDOS 3.3
 17002                                  DO_SHARE_CHECK:
 17003 00003899 8B0E[1A00]              	MOV	CX,[RetryCount]		; Get # tries to do
 17004                                  OpenShareRetry:
 17005 0000389D 51                      	push	cx			; Save number left to do
 17006 0000389E E8CC3D                  	call	SHARE_CHECK		; Final Check
 17007 000038A1 59                      	pop	cx			; CX = # left
 17008 000038A2 7312                    	JNC	short SHARE_OK		; No problem with access
 17009 000038A4 E883E7                  	call	Idle
 17010 000038A7 E2F4                    	LOOP	OpenShareRetry		; One more retry used up
 17011                                  OpenShareFail:
 17012 000038A9 C43E[5A05]              	LES	DI,[THISSFT]
 17013 000038AD E82B00                  	call	SHARE_ERROR
 17014 000038B0 73E7                    	JNC	short DO_SHARE_CHECK	; User wants more retry
 17015                                  	
 17016                                  	;12/08/2018
 17017                                  	;mov	byte [ss:FastOpenFlg],0
 17018                                  	;08/09/2018
 17019                                  	;mov	byte [FastOpenFlg],0
 17020 000038B2 E860E8                  	call	LcritDisk
 17021                                  	;JMP	short Clear_FastOpen
 17022 000038B5 C3                      	retn
 17023                                  
 17024                                  SHARE_OK:
 17025                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17026 000038B6 B80300                  	MOV	AX,3
 17027 000038B9 C43E[5A05]              	LES	DI,[THISSFT]
 17028                                  ;if installed
 17029                                  	;call	JShare + 14 * 4
 17030 000038BD FF1E[9400]              	call	far [JShare+(14*4)]  ; 14 = ShSU
 17031                                  ;else
 17032                                  ;	Call	ShSU
 17033                                  ;endif
 17034 000038C1 E851E8                  	call	LcritDisk
 17035                                  	
 17036                                  	;FallThru Set_SFT_Mode
 17037                                  
 17038                                  ;----------------------------------------------------------------------------
 17039                                  ; Procedure Name : SET_SFT_MODE
 17040                                  ;
 17041                                  ; Finish SFT initialization for new reference. Set the correct mode.
 17042                                  ;
 17043                                  ;   Inputs:
 17044                                  ;	ThisSFT points to SFT
 17045                                  ;
 17046                                  ;   Outputs:
 17047                                  ;	Carry clear
 17048                                  ;   Registers modified: AX.
 17049                                  ;---------------------------------------------------------------------------
 17050                                  
 17051                                  ;hkn; called from create. DS already set up to DOSDATA.
 17052                                  
 17053                                  SET_SFT_MODE:
 17054 000038C4 C43E[5A05]              	LES	DI,[THISSFT]
 17055 000038C8 E8E217                  	call	DEV_OPEN_SFT
 17056 000038CB 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB ; Clears carry
 17057 000038D1 7407                    	JZ	short Clear_FastOpen	; sf_mode correct (retz)
 17058 000038D3 A1[FC02]                	MOV	AX,[CurrentPDB]
 17059 000038D6 26894531                	MOV	[ES:DI+SF_ENTRY.sf_PID],AX ; For FCB sf_PID=PDB
 17060                                  
 17061                                  Clear_FastOpen:
 17062 000038DA C3                      	retn			       ;;;;; DOS 3.3
 17063                                  
 17064                                  ;----------------------------------------------------------------------------
 17065                                  ; Procedure Name : SHARE_ERROR
 17066                                  ;
 17067                                  ; Called on sharing violations. ES:DI points to SFT. AX has error code
 17068                                  ; If SFT is FCB or compatibility mode gens INT 24 error.
 17069                                  ; Returns carry set AX=error_sharing_violation if user says ignore (can't
 17070                                  ; really ignore).  Carry clear
 17071                                  ; if user wants a retry. ES, DI, DS preserved
 17072                                  ;---------------------------------------------------------------------------
 17073                                  
 17074                                  SHARE_ERROR:
 17075 000038DB 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 17076 000038E1 750C                    	JNZ	short _HARD_ERR
 17077 000038E3 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 17078 000038E7 80E1F0                  	AND	CL,SHARING_MASK
 17079 000038EA 80F900                  	CMP	CL,SHARING_COMPAT
 17080 000038ED 7505                    	JNE	short _NO_HARD_ERR
 17081                                  _HARD_ERR:
 17082 000038EF E8803D                  	call	SHARE_VIOLATION
 17083                                  	;retnc				; User wants retry
 17084 000038F2 73E6                    	jnc	short Clear_FastOpen
 17085                                  _NO_HARD_ERR:
 17086 000038F4 B82000                  	MOV	AX,error_sharing_violation
 17087 000038F7 F9                      	STC
 17088 000038F8 C3                      	retn
 17089                                  
 17090                                  ; MSDOS 6.0
 17091                                  ;----------------------------------------------------------------------------
 17092                                  ; Procedure Name : DO_SHARE_CHECK
 17093                                  ;
 17094                                  ; Input: THISDPB, WFP_Start, THISSFT set
 17095                                  ; Functions: check file sharing mode is valid
 17096                                  ; Output: carry set, error
 17097                                  ;	  carry clear, share ok
 17098                                  ;----------------------------------------------------------------------------
 17099                                  ;
 17100                                  ;DO_SHARE_CHECK:
 17101                                  ;	call	EcritDisk		; enter critical section
 17102                                  ;OPN_RETRY:
 17103                                  ;	MOV	CX,[RetryCount]		; Get # tries to do
 17104                                  ;OpenShareRetry:
 17105                                  ;	push	cx			; Save number left to do
 17106                                  ;	call	SHARE_CHECK		; Final Check
 17107                                  ;	pop	cx			; CX = # left
 17108                                  ;	JNC	short Share_Ok2		; No problem with access
 17109                                  ;	call	Idle
 17110                                  ;	LOOP	OpenShareRetry		; One more retry used up
 17111                                  ;OpenShareFail:
 17112                                  ;	LES	DI,[THISSFT]
 17113                                  ;	call	SHARE_ERROR
 17114                                  ;	JNC	short OPN_RETRY		; User wants more retry
 17115                                  ;Share_Ok2:
 17116                                  ;	call	LcritDisk		; leave critical section
 17117                                  ;	retn
 17118                                  
 17119                                  ;-----------------------------------------------------------------------------
 17120                                  ; Procedure Name : Check_Access
 17121                                  ;
 17122                                  ; Inputs:
 17123                                  ;	AX is mode
 17124                                  ;	  High NIBBLE of AL (Sharing Mode)
 17125                                  ;		sharing_compat	   file is opened in compatibility mode
 17126                                  ;		sharing_deny_none  file is opened Multi reader, Multi writer
 17127                                  ;		sharing_deny_read  file is opened Only reader, Multi writer
 17128                                  ;		sharing_deny_write file is opened Multi reader, Only writer
 17129                                  ;		sharing_deny_both  file is opened Only reader, Only writer
 17130                                  ;	  Low NIBBLE of AL (Access Mode)
 17131                                  ;		open_for_read	file is opened for reading
 17132                                  ;		open_for_write	file is opened for writing
 17133                                  ;		open_for_both	file is opened for both reading and writing.
 17134                                  ; Function:
 17135                                  ;	Check this access mode for correctness
 17136                                  ; Outputs:
 17137                                  ;	[open_access] = AL input
 17138                                  ;	Carry Clear
 17139                                  ;		Mode is correct
 17140                                  ;		AX unchanged
 17141                                  ;	Carry Set
 17142                                  ;		Mode is bad
 17143                                  ;		AX = error_invalid_access
 17144                                  ; No other registers effected
 17145                                  ;----------------------------------------------------------------------------
 17146                                  
 17147                                  Check_Access_AX:
 17148                                  
 17149 000038F9 A2[2B05]                	MOV	[OPEN_ACCESS],AL
 17150 000038FC 53                      	PUSH	BX
 17151                                  
 17152                                  ;	If sharing, then test for special sharing mode for FCBs
 17153                                  
 17154 000038FD 88C3                    	MOV	BL,AL
 17155 000038FF 80E3F0                  	AND	BL,SHARING_MASK
 17156 00003902 803E[2F05]FF            	CMP	byte [FSHARING],-1
 17157 00003907 7505                    	JNZ	short CheckShareMode	; not through server call, must be ok
 17158 00003909 80FB70                  	CMP	BL,SHARING_NET_FCB
 17159 0000390C 7405                    	JZ	short CheckAccessMode	; yes, we have an FCB
 17160                                  CheckShareMode:
 17161 0000390E 80FB40                  	CMP	BL,40h			; is this a good sharing mode?
 17162 00003911 770D                    	JA	short Make_Bad_Access
 17163                                  CheckAccessMode:
 17164 00003913 88C3                    	MOV	BL,AL
 17165 00003915 80E30F                  	AND	BL,access_mask
 17166 00003918 80FB02                  	CMP	BL,2
 17167 0000391B 7703                    	JA	short Make_Bad_Access
 17168 0000391D 5B                      	POP	BX
 17169 0000391E F8                      	CLC
 17170 0000391F C3                      	retn
 17171                                  
 17172                                  Make_Bad_Access:
 17173 00003920 B80C00                  	MOV	AX,error_invalid_access
 17174 00003923 5B                      	POP	BX
 17175 00003924 F9                      	STC
 17176 00003925 C3                      	retn
 17177                                  
 17178                                  ;============================================================================
 17179                                  ; DINFO.ASM, MSDOS 6.0, 1991
 17180                                  ;============================================================================
 17181                                  ; 08/08/2018 - Retro DOS v3.0
 17182                                  
 17183                                  ;**	Low level routine for returning disk drive information from a local
 17184                                  ;	  or NET device
 17185                                  ;
 17186                                  ;	DISK_INFO
 17187                                  ;
 17188                                  ;	  Modification history:
 17189                                  ;
 17190                                  ;		Created: ARR 30 March 1983
 17191                                  
 17192                                  ;	Break	<DISK_INFO -- Get Disk Drive Information>
 17193                                  ;---------------------------------------------------------------------------
 17194                                  ; Procedure Name : DISK_INFO
 17195                                  ;
 17196                                  ; Inputs:
 17197                                  ;	[THISCDS] Points to the Macro List Structure of interest
 17198                                  ;		(It MAY NOT be NUL, error not detected)
 17199                                  ; Function:
 17200                                  ;	Get Interesting Drive Information
 17201                                  ; Returns:
 17202                                  ;	DX = Number of free allocation units
 17203                                  ;	BX = Total Number of allocation units on disk
 17204                                  ;	CX = Sector size
 17205                                  ;	AL = Sectors per allocation unit
 17206                                  ;	AH = FAT ID BYTE
 17207                                  ;	Carry set if error (currently user FAILed to I 24)
 17208                                  ; Segs except ES preserved, others destroyed
 17209                                  ;----------------------------------------------------------------------------
 17210                                  
 17211                                  ;hkn; called from getset.asm and misc.asm. DS has already been set up to 
 17212                                  ;hkn; DOSDATA. 
 17213                                  
 17214                                  DISK_INFO:
 17215                                  	; 08/08/2018 - Retro DOS v3.0
 17216                                  	; IBM DOS.COM (MSDOS 3.3, 1987) - Offset 37C5h
 17217                                  
 17218 00003926 E846E7                  	call	TestNet
 17219 00003929 7306                    	JNC	short LOCAL_DSK_INFO
 17220                                  
 17221                                  ;IF NOT Installed
 17222                                  ;	transfer NET_DISK_INFO
 17223                                  ;ELSE
 17224                                  	;MOV	AX,(MultNET SHL 8) OR 12
 17225                                  	;INT	2FH
 17226                                  	;return
 17227                                  
 17228 0000392B B80C11                  	mov     ax,110Ch
 17229 0000392E CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - GET DISK SPACE
 17230                                  			; ES:DI -> current directory
 17231                                  			; Return: AL = sectors per cluster, BX = total clusters
 17232                                  			; CX = bytes per sector, DX = number of available clusters
 17233 00003930 C3                      	retn
 17234                                  ;ENDIF
 17235                                  
 17236                                  LOCAL_DSK_INFO:
 17237 00003931 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 17238 00003936 E8D4E7                  	call	EcritDisk
 17239 00003939 E89525                  	call	FATREAD_CDS		; perform media check.
 17240 0000393C 7241                    	JC	short CRIT_LEAVE
 17241 0000393E BB0200                  	MOV	BX,2
 17242 00003941 E8EB23                  	call	UNPACK			; Get first FAT sector into CURBUF
 17243 00003944 7239                    	JC	short CRIT_LEAVE
 17244 00003946 C536[9E05]              	LDS	SI,[CURBUF]
 17245 0000394A 8A6414                  	MOV	AH,[SI+BUFINSIZ]	; get FAT ID BYTE
 17246                                  
 17247                                  ;hkn; SS is DOSDATA
 17248 0000394D 16                      	push	ss
 17249 0000394E 1F                      	pop	ds
 17250 0000394F 268B4E0D                	MOV	CX,[ES:BP+DPB.MAX_CLUSTER]
 17251                                  ;
 17252                                  ; Examine the current free count.  If it indicates that we have an invalid
 17253                                  ; count, do the expensive calculation.
 17254                                  ;
 17255 00003953 268B561F                	MOV	DX,[ES:BP+DPB.FREE_CNT] ; get free count
 17256 00003957 83FAFF                  	CMP	DX,-1			; is it valid?
 17257 0000395A 7404                    	JZ	short DoScan
 17258                                  ;
 17259                                  ; Check to see if it is in a reasonalbe range.	If so, trust it and return.
 17260                                  ; Otherwise, we need to blast out an internal error message and then recompute
 17261                                  ; the count.
 17262                                  ;
 17263 0000395C 39CA                    	CMP	DX,CX			; is it in a reasonable range?
 17264 0000395E 7223                    	JB	short GotVal		; yes, trust it.
 17265                                  DoScan:
 17266 00003960 31D2                    	XOR	DX,DX
 17267 00003962 49                      	DEC	CX
 17268                                  SCANFREE:
 17269 00003963 E8C923                  	call	UNPACK
 17270 00003966 7217                    	JC	short CRIT_LEAVE
 17271 00003968 7501                    	JNZ	short NOTFREECLUS
 17272 0000396A 42                      	INC	DX			; A free one
 17273                                  NOTFREECLUS:
 17274 0000396B 43                      	INC	BX			; Next cluster
 17275 0000396C E2F5                    	LOOP	SCANFREE
 17276 0000396E 4B                      	DEC	BX			; BX was next cluster.	Convert to
 17277                                  ReturnVals:
 17278 0000396F 4B                      	DEC	BX			; count
 17279 00003970 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK] 
 17280 00003974 FEC0                    	INC	AL			; Sectors/cluster
 17281 00003976 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE] ; Bytes/sector
 17282 0000397A 2689561F                	MOV	[ES:BP+DPB.FREE_CNT],DX
 17283 0000397E F8                      	CLC
 17284                                  CRIT_LEAVE:
 17285 0000397F E893E7                  	call	LcritDisk
 17286 00003982 C3                      	retn
 17287                                  ;
 17288                                  ; We have correctly computed everything previously. Load up registers for
 17289                                  ; return.
 17290                                  ;
 17291                                  GotVal: 
 17292 00003983 89CB                    	MOV	BX,CX			; get cluster count
 17293 00003985 EBE8                    	JMP	short ReturnVals
 17294                                  
 17295                                  ;============================================================================
 17296                                  ; ISEARCH.ASM, MSDOS 6.0, 1991
 17297                                  ;============================================================================
 17298                                  ; 22/07/2018 - Retro DOS v3.0
 17299                                  
 17300                                  ;	TITLE	DOS_SEARCH - Internal SEARCH calls for MS-DOS
 17301                                  ;	NAME	DOS_SEARCH
 17302                                  
 17303                                  ;**	Low level routines for doing local and NET directory searches
 17304                                  ;
 17305                                  ;	DOS_SEARCH_FIRST
 17306                                  ;	DOS_SEARCH_NEXT
 17307                                  ;	RENAME_NEXT
 17308                                  ;
 17309                                  ;	Revision history:
 17310                                  ;
 17311                                  ;	    Created: ARR 30 March 1983
 17312                                  ;	    A000	version 4.00  Jan. 1988
 17313                                  ;	    A001	PTM 3564 -- search for fastopen
 17314                                  
 17315                                  ;Installed = TRUE
 17316                                  
 17317                                  ;--------------------------------------------------------------------------
 17318                                  ;
 17319                                  ; Procedure Name : DOS_SEARCH_FIRST
 17320                                  ;
 17321                                  ; Inputs:
 17322                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 17323                                  ;		terminated)
 17324                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 17325                                  ;		( = -1 if current dir not involved, else
 17326                                  ;		 Points to first char after last "/" of current dir part)
 17327                                  ;	[THISCDS] Points to CDS being used
 17328                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 17329                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 17330                                  ;	[DMAADD] Points to 53 byte buffer
 17331                                  ; Function:
 17332                                  ;	Initiate a search for the given file spec
 17333                                  ; Outputs:
 17334                                  ;	CARRY CLEAR
 17335                                  ;	    The 53 bytes ot DMAADD are filled in as follows:
 17336                                  ;
 17337                                  ;	LOCAL
 17338                                  ;	    Drive Byte (A=1, B=2, ...) High bit clear
 17339                                  ;		NEVER STORE DRIVE BYTE AFTER  found_it
 17340                                  ;	    11 byte search name with Meta chars in it
 17341                                  ;	    Search Attribute Byte, attribute of search
 17342                                  ;	    WORD LastEnt value
 17343                                  ;	    WORD DirStart
 17344                                  ;	    4 byte pad
 17345                                  ;	    32 bytes of the directory entry found
 17346                                  ;	NET
 17347                                  ;	    21 bytes First byte has high bit set
 17348                                  ;	    32 bytes of the directory entry found
 17349                                  ;
 17350                                  ;	CARRY SET
 17351                                  ;	    AX = error code
 17352                                  ;		error_no_more_files
 17353                                  ;			No match for this file
 17354                                  ;		error_path_not_found
 17355                                  ;			Bad path (not in curr dir part if present)
 17356                                  ;		error_bad_curr_dir
 17357                                  ;			Bad path in current directory part of path
 17358                                  ; DS preserved, others destroyed
 17359                                  ;---------------------------------------------------------------------------
 17360                                  
 17361                                  DOS_SEARCH_FIRST:
 17362                                  	; IBMDOS.COM (MSDOS 3.3 kernel) - Offset 3826h
 17363                                  
 17364 00003987 C43E[5E05]              	LES	DI,[THISCDS]
 17365 0000398B 83FFFF                  	CMP	DI,-1
 17366 0000398E 7506                    	JNZ	short TEST_RE_NET2
 17367                                  
 17368                                  ;IF NOT Installed
 17369                                  ;	transfer NET_SEQ_SEARCH_FIRST
 17370                                  ;ELSE
 17371                                  	;mov	ax,1119h
 17372 00003990 B81911                  	MOV	AX,(MultNET<<8)|25
 17373 00003993 CD2F                    	INT	2Fh
 17374 00003995 C3                      	retn
 17375                                  ;ENDIF
 17376                                  
 17377                                  TEST_RE_NET2:
 17378                                  	;test	word [es:di+43h],8000h
 17379 00003996 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 17380 0000399C 7406                    	JZ	short LOCAL_SEARCH_FIRST
 17381                                  
 17382                                  ;IF NOT Installed
 17383                                  ;	transfer NET_SEARCH_FIRST
 17384                                  ;ELSE
 17385                                  	;mov	ax,111Bh
 17386 0000399E B81B11                  	MOV	AX,(MultNET<<8)|27
 17387 000039A1 CD2F                    	INT	2FH
 17388 000039A3 C3                      	retn
 17389                                  ;ENDIF
 17390                                  
 17391                                  LOCAL_SEARCH_FIRST:
 17392 000039A4 E866E7                  	call	EcritDisk
 17393                                  	; MSDOS 6.0
 17394                                  	;TEST	word [DOS34_FLAG],SEARCH_FASTOPEN ;AN000;
 17395                                  	;JZ	short NOFN			;AN000;
 17396                                  	;OR	byte [FastOpenflg],Fastopen_Set	;AN000;
 17397                                  ;NOFN:						;AN000;
 17398 000039A7 C606[1603]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17399                                  	; MSDOS 6.0
 17400                                  	;CALL	CHECK_QUESTION		;AN000;;FO. is '?' in path
 17401                                  	;JNC	short norm_GETPATH	;AN000;;FO. no
 17402                                  	;AND	byte [FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
 17403                                  ;norm_GETPATH:
 17404 000039AC E87610                  	call	GETPATH
 17405                                  	; BX = offset NAME1
 17406                                  ;_getdone:
 17407 000039AF 7313                    	JNC	short find_check_dev
 17408 000039B1 750C                    	JNZ	short bad_path3
 17409 000039B3 08C9                    	OR	CL,CL
 17410 000039B5 7408                    	JZ	short bad_path3
 17411                                  find_no_more:
 17412                                  	;mov	ax,12h
 17413 000039B7 B81200                  	MOV	AX,error_no_more_files
 17414                                  BadBye:
 17415                                  	; MSDOS 6.0
 17416                                  	;AND	[SS:FastOpenflg],Fast_yes  ;AN000;;FO. reset fastopen
 17417                                  
 17418 000039BA F9                      	STC
 17419 000039BB E857E7                  	call	LcritDisk
 17420 000039BE C3                      	retn
 17421                                  
 17422                                  bad_path3:
 17423                                  	;mov	ax,3
 17424 000039BF B80300                  	MOV	AX,error_path_not_found
 17425 000039C2 EBF6                    	JMP	short BadBye
 17426                                  
 17427                                  find_check_dev:
 17428 000039C4 08E4                    	OR	AH,AH
 17429 000039C6 790A                    	JNS	short found_entry
 17430 000039C8 C706[1203]FFFF          	MOV	word [LASTENT],-1	; Cause DOS_SEARCH_NEXT to fail
 17431 000039CE FE06[2D05]              	INC	byte [FOUND_DEV]	; Tell DOS_RENAME we found a device
 17432                                  found_entry:
 17433                                  ;
 17434                                  ; We set the physical drive byte here Instead of after found_it; Doing
 17435                                  ; a search-next may not have wfp_start set correctly
 17436                                  ;
 17437 000039D2 C43E[F802]              	LES	DI,[DMAADD]
 17438 000039D6 8B36[6E05]              	MOV	SI,[WFP_START]		; get pointer to beginning
 17439 000039DA AC                      	LODSB
 17440 000039DB 2C40                    	SUB	AL,'A'-1                ; logical drive
 17441 000039DD AA                      	STOSB				; High bit not set (local)
 17442                                  found_it:
 17443 000039DE C43E[F802]              	LES	DI,[DMAADD]
 17444 000039E2 47                      	INC	DI
 17445                                  
 17446                                  	; MSDOS 6.0
 17447                                  	;PUSH	DS				  ;FO.;AN001; save ds
 17448                                  	;TEST	byte [Fastopenflg],Set_For_Search ;FO.;AN001; from fastopen
 17449                                  	;JZ	short notfast 			  ;FO.;AN001;
 17450                                  	;MOV	SI,BX				  ;FO.;AN001;
 17451                                  	;MOV	DS,[CURBUF+2]			  ;FO.;AN001;
 17452                                  	;JMP	SHORT movmov			  ;FO.;AN001;
 17453                                  
 17454                                  notfast:
 17455 000039E3 BE[0805]                	MOV	SI,NAME1		; find_buf 2 = formatted name
 17456                                  movmov:
 17457                                  ; Special E5 code
 17458 000039E6 A4                      	MOVSB
 17459 000039E7 26807DFF05              	CMP	BYTE [ES:DI-1],5
 17460 000039EC 7505                    	JNZ	short NOTKANJB
 17461 000039EE 26C645FFE5              	MOV	BYTE [ES:DI-1],0E5H
 17462                                  NOTKANJB:
 17463 000039F3 B90A00                  	MOV	CX,10
 17464 000039F6 F3A4                    	REP	MOVSB
 17465                                  
 17466                                  	; 08/09/2018
 17467                                  	;POP	DS			;FO.;AN001; restore ds
 17468                                  
 17469 000039F8 A0[2805]                	MOV	AL,[ATTRIB]
 17470 000039FB AA                      	STOSB
 17471 000039FC 50                      	PUSH	AX			; Save AH device info
 17472 000039FD A1[1203]                	MOV	AX,[LASTENT]
 17473 00003A00 AB                      	STOSW
 17474 00003A01 A1[7E05]                	MOV	AX,[DIRSTART]
 17475 00003A04 AB                      	STOSW
 17476                                  ; 4 bytes of 21 byte cont structure left for NET stuff
 17477 00003A05 83C704                  	ADD	DI,4
 17478 00003A08 58                      	POP	AX			; Recover AH device info
 17479 00003A09 08E4                    	OR	AH,AH
 17480 00003A0B 7813                    	JS	short DOSREL		; Device entry is DOSGROUP relative
 17481 00003A0D 833E[9E05]FF            	CMP	WORD [CURBUF],-1
 17482 00003A12 7508                    	JNZ	short OKSTORE
 17483                                  
 17484                                  	; MSDOS 6.0
 17485                                  	;TEST	byte [FastOPenFlg],Set_For_Search
 17486                                  					;AN000;;FO. from fastopen and is good
 17487                                  	;JNZ	short OKSTORE		;AN000;;FO.
 17488                                  
 17489                                  	; The user has specified the root directory itself, rather than some
 17490                                  	; contents of it. We can't "find" that.
 17491 00003A14 26C745F8FFFF            	MOV	WORD [ES:DI-8],-1	; Cause DOS_SEARCH_NEXT to fail by
 17492                                  					;   stuffing a -1 at Lastent
 17493 00003A1A EB9B                    	JMP	short find_no_more
 17494                                  
 17495                                  OKSTORE:
 17496 00003A1C 8E1E[A005]              	MOV	DS,[CURBUF+2]
 17497                                  DOSREL:
 17498                                  	; BX = offset NAME1 (from GETPATH)
 17499 00003A20 89DE                    	MOV	SI,BX			; SI-> start of entry
 17500                                  
 17501                                  ; NOTE: DOS_RENAME depends on BX not being altered after this point
 17502                                  
 17503                                  	;mov	cx,32
 17504 00003A22 B92000                  	MOV	CX,dir_entry.size
 17505                                  ;;;;; 7/29/86
 17506 00003A25 89F8                    	MOV	AX,DI			; save the 1st byte addr
 17507 00003A27 F3A4                    	REP	MOVSB
 17508 00003A29 89C7                    	MOV	DI,AX			; restore 1st byte addr
 17509 00003A2B 26803D05                	CMP	BYTE [ES:DI],05H	; special char check
 17510 00003A2F 7504                    	JNZ	short NO05
 17511 00003A31 26C605E5                	MOV	BYTE [ES:DI],0E5H	; convert it back to E5
 17512                                  NO05:
 17513                                  
 17514                                  ;;;;; 7/29/86
 17515                                  
 17516                                  ;hkn; FastOpenflg is in DOSDATA use SS
 17517                                  	; MSDOS 6.0
 17518                                  	;AND	byte [SS:FastOpenflg],Fast_yes ;AN000;;FO. reset fastopen
 17519                                  	;push	ss
 17520                                  	;pop	ds
 17521                                  	;AND	byte [FastOpenflg],Fast_yes
 17522                                  
 17523                                  ;hkn; SS is DOSDATA
 17524 00003A35 16                      	push	ss
 17525 00003A36 1F                      	pop	ds
 17526 00003A37 F8                      	CLC
 17527 00003A38 E8DAE6                  	call	LcritDisk
 17528 00003A3B C3                      	retn
 17529                                  
 17530                                  ;BREAK <DOS_SEARCH_NEXT - scan for subsequent matches>
 17531                                  ;----------------------------------------------------------------------------
 17532                                  ;
 17533                                  ; Procedure Name : DOS_SEARCH_NEXT
 17534                                  ;
 17535                                  ; Inputs:
 17536                                  ;	[DMAADD] Points to 53 byte buffer returned by DOS_SEARCH_FIRST
 17537                                  ;	    (only first 21 bytes must have valid information)
 17538                                  ; Function:
 17539                                  ;	Look for subsequent matches
 17540                                  ; Outputs:
 17541                                  ;	CARRY CLEAR
 17542                                  ;	    The 53 bytes at DMAADD are updated for next call
 17543                                  ;		(see DOS_SEARCH_FIRST)
 17544                                  ;	CARRY SET
 17545                                  ;	    AX = error code
 17546                                  ;		error_no_more_files
 17547                                  ;			No more files to find
 17548                                  ; DS preserved, others destroyed
 17549                                  ;---------------------------------------------------------------------------
 17550                                  
 17551                                  ;hkn; called from search.asm. DS already set up at this point.
 17552                                  
 17553                                  DOS_SEARCH_NEXT:
 17554 00003A3C C43E[F802]              	LES	DI,[DMAADD]
 17555 00003A40 268A05                  	MOV	AL,[ES:DI]
 17556 00003A43 A880                    	TEST	AL,80H			; Test for NET
 17557 00003A45 7406                    	JZ	short LOCAL_SEARCH_NEXT
 17558                                  ;IF NOT Installed
 17559                                  ;	transfer NET_SEARCH_NEXT
 17560                                  ;ELSE
 17561                                  	;mov	ax,111Ch
 17562 00003A47 B81C11                  	MOV	AX,(MultNET<<8)|28
 17563 00003A4A CD2F                    	INT	2FH  ; Multiplex - NETWORK REDIRECTOR - FINDNEXT
 17564                                  		     ; SS = DS = DOS CS, [DTA] = 21-byte findfirst search data
 17565                                  		     ; Return: CF set on error, AX = DOS error code
 17566                                  		     ; CF clear if successful
 17567 00003A4C C3                      	retn
 17568                                  ;ENDIF
 17569                                  
 17570                                  LOCAL_SEARCH_NEXT:
 17571                                  	;AL is drive A=1
 17572                                  	;mov	byte [EXTERR_LOCUS],2
 17573 00003A4D C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 17574 00003A52 E8B8E6                  	call	EcritDisk
 17575                                  
 17576                                  ;hkn; DummyCDS is in DOSDATA
 17577 00003A55 C706[5E05][B704]        	MOV     word [THISCDS],DUMMYCDS
 17578                                  ;hkn; Segment address is DOSDATA - use ds
 17579                                  ;hkn;	MOV     WORD [THISCDS+2],CS
 17580 00003A5B 8C1E[6005]              	mov	[THISCDS+2],DS
 17581                                  
 17582 00003A5F 0440                    	ADD	AL,'A'-1
 17583 00003A61 E89931                  	call	InitCDS
 17584                                  
 17585                                  ;	call	GETTHISDRV		; Set CDS pointer
 17586                                  
 17587 00003A64 7236                    	JC	short No_files		; Bogus drive letter
 17588 00003A66 C43E[5E05]              	LES	DI,[THISCDS]		; Get CDS pointer
 17589                                  	;les	bp,[es:di+45h]
 17590 00003A6A 26C46D45                	LES	BP,[ES:DI+curdir.devptr]; Get DPB pointer
 17591 00003A6E E821DD                  	call	GOTDPB			; [THISDPB] = ES:BP
 17592                                  
 17593 00003A71 268A4600                	mov	al,[ES:BP]
 17594                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[ES:BP+0]
 17595 00003A75 A2[3305]                	mov	[THISDRV],AL
 17596                                  	;mov	word [CREATING], 0E500h
 17597 00003A78 C706[3A05]00E5          	MOV	WORD [CREATING],(DIRFREE*256)+0
 17598 00003A7E C606[1603]01            	MOV	byte [NoSetDir],1	; if we find a dir, don't change to it
 17599 00003A83 C536[F802]              	LDS	SI,[DMAADD]
 17600 00003A87 AC                      	LODSB				; Drive Byte
 17601                                  
 17602                                  	;entry	RENAME_NEXT		; Entry used by DOS_RENAME
 17603                                  RENAME_NEXT:
 17604                                  	;context ES
 17605 00003A88 16                      	push	ss
 17606 00003A89 07                      	pop	es			; THIS BLOWS ES:BP POINTER TO DPB
 17607                                  
 17608                                  ;hkn; NAME1 is in DOSDATA
 17609 00003A8A BF[0805]                	MOV	DI,NAME1
 17610                                  
 17611 00003A8D B90B00                  	MOV	CX,11
 17612 00003A90 F3A4                    	REP	MOVSB			; Search name
 17613 00003A92 AC                      	LODSB				; Attribute
 17614                                  
 17615                                  ;hkn; SS override
 17616 00003A93 36A2[2805]              	MOV	[SS:ATTRIB],AL
 17617 00003A97 AD                      	LODSW				; LastEnt
 17618 00003A98 09C0                    	OR	AX,AX
 17619 00003A9A 7903                    	JNS	short cont_load
 17620                                  No_files:
 17621 00003A9C E918FF                  	JMP	find_no_more
 17622                                  
 17623                                  cont_load:
 17624 00003A9F 50                      	PUSH	AX			; Save LastEnt
 17625 00003AA0 AD                      	LODSW				; DirStart
 17626 00003AA1 89C3                    	MOV	BX,AX
 17627                                  
 17628                                  ;hkn; SS is DOSDATA
 17629                                  	;context DS
 17630 00003AA3 16                      	push	ss
 17631 00003AA4 1F                      	pop	ds
 17632 00003AA5 C42E[4605]              	LES	BP,[THISDPB]		; Recover ES:BP
 17633                                  	;invoke	SetDirSrch
 17634 00003AA9 E8180F                  	call	SETDIRSRCH
 17635 00003AAC 7303                    	JNC	short SEARCH_GOON
 17636 00003AAE 58                      	POP	AX			; Clean stack
 17637 00003AAF EBEB                    	JMP	short No_files
 17638                                  
 17639                                  SEARCH_GOON:
 17640 00003AB1 E80212                  	call	STARTSRCH
 17641 00003AB4 58                      	POP	AX
 17642 00003AB5 E8DE0E                  	call	GETENT
 17643 00003AB8 72E2                    	JC	short No_files
 17644 00003ABA E80F0E                  	call	NEXTENT
 17645 00003ABD 72DD                    	JC	short No_files
 17646 00003ABF 30E4                    	XOR	AH,AH			; If Search_Next, can't be a DEV
 17647 00003AC1 E91AFF                  	JMP	found_it ; 10/08/2018
 17648                                  
 17649                                  ; MSDOS 6.0
 17650                                  ;---------------------------------------------------------------------------
 17651                                  ;
 17652                                  ; Procedure Name : CHECK_QUESTION
 17653                                  ;
 17654                                  ; Input: [WFP_START]= pointer to final path
 17655                                  ; Function: check '?' char
 17656                                  ; Output: carry clear, if no '?'
 17657                                  ;	 carry set, if '?' exists
 17658                                  ;---------------------------------------------------------------------------
 17659                                  
 17660                                  ;CHECK_QUESTION:
 17661                                  ;;hkn;	wfp_start is in DOSDATA;hkn;	MOV     WORD PTR ThisCDS+2,CS
 17662                                  ;;hkn;	PUSH	CS			;AN000;;FO.
 17663                                  ;	push	ss
 17664                                  ;
 17665                                  ;	POP	DS			;AN000;;FO. ds:si -> final path
 17666                                  ;	MOV	SI,[WFP_START]		;AN000;;FO.
 17667                                  ;getnext:				;AN000;
 17668                                  ;	LODSB				;AN000;;FO. get char
 17669                                  ;	OR	AL,AL			;AN000;;FO. is it null
 17670                                  ;	JZ	short NO_Question	;AN000;;FO. yes
 17671                                  ;	CMP	AL,'?'                  ;AN000;;FO. is '?'
 17672                                  ;	JNZ	short getnext 		;AN000;;FO. no
 17673                                  ;	STC				;AN000;;FO.
 17674                                  ;NO_Question:				;AN000;
 17675                                  ;	retn				;AN000;;FO.
 17676                                  
 17677                                  ;============================================================================
 17678                                  ; ABORT.ASM, MSDOS 6.0, 1991
 17679                                  ;============================================================================
 17680                                  ; 23/07/2018 - Retro DOS v3.0
 17681                                  
 17682                                  ;**
 17683                                  ;
 17684                                  ; Internal Abort call closes all handles and FCBs associated with a process.
 17685                                  ;  If process has NET resources a close all is sent out over the net.
 17686                                  ;
 17687                                  ;   DOS_ABORT
 17688                                  ;
 17689                                  ;   Modification history:
 17690                                  ;
 17691                                  ;       Created: ARR 30 March 1983
 17692                                  ;
 17693                                  ;	M038	SR	10/16/90	Free SFT with the PSP of the process
 17694                                  ;				being terminated only if it is busy.
 17695                                  ;
 17696                                  
 17697                                  ;Break   <DOS_ABORT -- CLOSE all files for process>
 17698                                  ;--------------------------------------------------------------------------
 17699                                  ;
 17700                                  ; Procedure Name : DOS_ABORT
 17701                                  ;
 17702                                  ; Inputs:
 17703                                  ;       [CurrentPDB] set to PID of process aborting
 17704                                  ; Function:
 17705                                  ;       Close all files and free all SFTs for this PID
 17706                                  ; Returns:
 17707                                  ;       None
 17708                                  ; All destroyed except stack
 17709                                  ;---------------------------------------------------------------------------
 17710                                  
 17711                                  DOS_ABORT:
 17712 00003AC4 368E06[FC02]            	MOV     ES,[SS:CurrentPDB]	; SS override
 17713 00003AC9 268B0E3200              	MOV     CX,[ES:PDB.JFN_Length]  ; Number of JFNs
 17714                                  reset_free_jfn:
 17715 00003ACE 89CB                    	MOV     BX,CX
 17716 00003AD0 51                      	PUSH    CX
 17717 00003AD1 4B                      	DEC     BX                      ; get jfn (start with last one)
 17718                                  
 17719 00003AD2 E83436                  	CALL	_$CLOSE
 17720 00003AD5 59                      	POP     CX
 17721 00003AD6 E2F6                    	LOOP    reset_free_jfn          ; and do 'em all
 17722                                  ;
 17723                                  ; Note:  We do need to explicitly close FCBs. Reasons are as follows: If we
 17724                                  ; are running in the no-sharing no-network environment, we are simulating the
 17725                                  ; 2.0 world and thus if the user doesn't close the file, that is his problem
 17726                                  ; BUT...  the cache remains in a state with garbage that may be reused by the
 17727                                  ; next process.  We scan the set and blast the ref counts of the FCBs we own.
 17728                                  ;
 17729                                  ; If sharing is loaded, then the following call to close process will
 17730                                  ; correctly close all FCBs.  We will then need to walk the list AFTER here.
 17731                                  ;
 17732                                  ; Finally, the following call to NET_Abort will cause an EOP to be sent to all
 17733                                  ; known network resources.  These resources are then responsible for cleaning
 17734                                  ; up after this process.
 17735                                  ;
 17736                                  ; Sleazy, eh?
 17737                                  ;
 17738                                  	;context DS			; SS is DOSDATA
 17739 00003AD8 16                      	push	ss
 17740 00003AD9 1F                      	pop	ds  ; 09/09/2018
 17741                                  
 17742                                  	;CallInstall Net_Abort, MultNET, 29
 17743 00003ADA B81D11                  	mov	ax, 111Dh
 17744 00003ADD CD2F                    	int     2Fh 	; Multiplex - NETWORK REDIRECTOR 
 17745                                  			;	    - CLOSE ALL REMOTE FILES FOR PROCESS
 17746                                  			; DS???, SS = DOS CS
 17747                                  ;if installed
 17748 00003ADF FF1E[6C00]              	call	far [JShare+(4*4)]	; 4 = MFTCloseP
 17749                                  ;else
 17750                                  ;	call 	mftCloseP
 17751                                  ;endif
 17752                                  
 17753                                  ; Scan the FCB cache for guys that belong to this process and zap their ref
 17754                                  ; counts.
 17755                                  					; SS override
 17756 00003AE3 36C43E[4000]            	les     di,[ss:SFTFCB]		; grab the pointer to the table
 17757                                  	;mov	cx,[es:di+4]
 17758 00003AE8 268B4D04                	mov     cx,[es:di+SFT.SFCount]
 17759 00003AEC E317                    	jcxz    FCBScanDone
 17760                                  	;lea	di,[di+6]
 17761 00003AEE 8D7D06                  	LEA     DI,[DI+SFT.SFTable]	; point at table
 17762 00003AF1 36A1[0603]              	mov     ax,[SS:PROC_ID]		; SS override
 17763                                  FCBTest:
 17764                                  	;cmp	[es:di+31h],ax
 17765 00003AF5 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax ; is this one of ours
 17766 00003AF9 7505                    	jnz	short FCBNext		; no, skip it
 17767 00003AFB 26C7050000              	mov	word [es:di],0
 17768                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0  ; yes, blast ref count
 17769                                  FCBNext:
 17770 00003B00 83C73B                  	add     di,SF_ENTRY.size
 17771 00003B03 E2F0                    	loop    FCBTest
 17772                                  FCBScanDone:
 17773                                  
 17774                                  ;
 17775                                  ; Walk the SFT to eliminate all busy SFT's for this process.
 17776                                  ;
 17777 00003B05 31DB                    	XOR     BX,BX
 17778                                  Scan:
 17779 00003B07 53                      	push    bx
 17780 00003B08 E84E30                  	call	SFFromSFN
 17781 00003B0B 5B                      	pop     bx
 17782 00003B0C 7301                    	jnc     short Scan1
 17783 00003B0E C3                      	retn
 17784                                  
 17785                                  ;M038
 17786                                  ; Do what the comment above says, check for busy state
 17787                                  ;
 17788                                  Scan1:
 17789                                  	;cmp	word [es:di],0
 17790                                  	;jz	short scan_next  ; MSDOS 3.3
 17791                                  	; MSDOS 6.0
 17792 00003B0F 26833DFF                	cmp	word [es:di],sf_busy ; -1
 17793                                  	;cmp	word [es:di+SF_ENTRY.sf_ref_count],sf_busy
 17794                                  				; Is Sft busy? ;M038
 17795 00003B13 7519                    	jnz	short scan_next
 17796                                  ;
 17797                                  ; we have a SFT that is busy. See if it is for the current process
 17798                                  ;
 17799 00003B15 36A1[0603]              	mov     ax,[SS:PROC_ID]		; SS override
 17800                                  	;cmp	[es:di+31h],ax
 17801 00003B19 26394531                	cmp	[es:di+SF_ENTRY.sf_PID],ax
 17802 00003B1D 750F                    	jnz	short scan_next
 17803 00003B1F 36A1[0803]              	mov     ax,[SS:USER_ID]		; SS override
 17804                                  	;cmp	[es:di+2Fh],ax
 17805 00003B23 2639452F                	cmp	[es:di+SF_ENTRY.sf_UID],ax
 17806 00003B27 7505                    	jnz	short scan_next
 17807                                  ;
 17808                                  ; This SFT is labelled as ours.
 17809                                  ;
 17810 00003B29 26C7050000              	mov	word [es:di],0
 17811                                  	;mov	word [es:di+SF_ENTRY.sf_ref_count],0
 17812                                  scan_next:
 17813 00003B2E 43                      	inc     bx
 17814 00003B2F EBD6                    	jmp     short Scan
 17815                                  
 17816                                  
 17817                                  ;============================================================================
 17818                                  ; CLOSE.ASM, MSDOS 6.0, 1991
 17819                                  ;============================================================================
 17820                                  ; 23/07/2018 - Retro DOS v3.0
 17821                                  
 17822                                  ;**	Internal Close and Commit calls to close a local or NET SFT.
 17823                                  ;
 17824                                  ;	DOS_CLOSE
 17825                                  ;	DOS_COMMIT
 17826                                  ;	FREE_SFT
 17827                                  ;	SetSFTTimes
 17828                                  ;
 17829                                  ;	Revision history:
 17830                                  ;
 17831                                  ;	   AN000  version 4.00	Jan. 1988
 17832                                  ;	   A005   PTM 3718 --- lost clusters when fastopen installed
 17833                                  ;	   A011   PTM 4766 --- C2 fastopen problem
 17834                                  
 17835                                  ;Installed = TRUE
 17836                                  
 17837                                  ;Break <DOS_CLOSE -- CLOSE FILE from SFT>
 17838                                  ;---------------------------------------------------------------------------
 17839                                  ;
 17840                                  ; Procedure Name : DOS_CLOSE
 17841                                  ;
 17842                                  ; Inputs:
 17843                                  ;	[THISSFT] set to the SFT for the file being used
 17844                                  ; Function:
 17845                                  ;	Close the indicated file via the SFT
 17846                                  ; Returns:
 17847                                  ;	sf_ref_count decremented otherwise
 17848                                  ;	ES:DI point to SFT
 17849                                  ;	Carry set if error
 17850                                  ;	    AX has error code
 17851                                  ; DS preserved, others destroyed
 17852                                  ;---------------------------------------------------------------------------
 17853                                  
 17854                                  ;hkn; DOS_CLOSE called from fcbio.asm and handle.asm. DS alreday set up.
 17855                                  
 17856                                  ; 24/07/2019 - Retro DOS v3.2
 17857                                  ; 18/05/2019 - Retro DOS v4.0
 17858                                  ; DOSCODE:6E2Eh (MSDOS 6.21, MSDOS.SYS)
 17859                                  
 17860                                  ; 23/07/2018 - IBMDOS.COM (MSDOS 3.3), 1987 - Offset 39D0h
 17861                                  
 17862                                  DOS_CLOSE:
 17863 00003B31 C43E[5A05]              	LES	DI,[THISSFT]
 17864                                  	;mov	bx,[ES:DI+5]
 17865 00003B35 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 17866                                  
 17867                                  ; Network closes are handled entirely by the net code.
 17868                                  
 17869                                  	;test	bx,8000h
 17870 00003B39 F7C30080                	TEST	BX,sf_isnet
 17871 00003B3D 7406                    	JZ	short LocalClose
 17872                                  
 17873                                  	;CallInstall Net_Close,MultNET,6
 17874 00003B3F B80611                  	mov     ax,1106h
 17875 00003B42 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CLOSE REMOTE FILE
 17876                                  			; ES:DI -> SFT
 17877                                  			; SFT DPB field -> DPB of drive containing file
 17878                                  			; Return: CF set on error, AX = DOS error code
 17879                                  			; CF clear if successful
 17880 00003B44 C3                      	retn
 17881                                  
 17882                                  ; All closes release the sharing information.
 17883                                  ; No commit releases sharing information
 17884                                  ;
 17885                                  ; All closes decrement the ref count.
 17886                                  ; No commit decrements the ref count.
 17887                                  
 17888                                  LocalClose:
 17889 00003B45 E8C5E5                  	call	EcritDisk
 17890 00003B48 E85C01                  	CALL	SetSFTTimes
 17891 00003B4B E8DB00                  	CALL	FREE_SFT		; dec ref count or mark as busy
 17892                                  
 17893                                  ;hkn; SS is DOSDATA
 17894                                  	;Context DS
 17895 00003B4E 16                      	push	ss
 17896 00003B4F 1F                      	pop	ds
 17897                                  
 17898 00003B50 50                      	push	ax
 17899 00003B51 53                      	push	bx
 17900 00003B52 E8433B                  	call	ShareEnd
 17901 00003B55 5B                      	pop	bx
 17902 00003B56 58                      	pop	ax
 17903                                  ;
 17904                                  ; Commit enters here. AX from commit MUST be <> 1, BX is flags word
 17905                                  ;
 17906                                  CloseEntry:
 17907 00003B57 50                      	PUSH	AX
 17908                                  ;
 17909                                  ; File clean or device does not get stamped nor disk looked at.
 17910                                  ;
 17911                                  	;test	bx,0C0h
 17912 00003B58 F7C3C000                	TEST	BX,devid_file_clean+devid_device
 17913 00003B5C 7403                    	JZ	short rdir
 17914 00003B5E E9B500                  	JMP	FREE_SFT_OK		; either clean or device
 17915                                  ;
 17916                                  ; Retrieve the directory entry for the file
 17917                                  ;
 17918                                  rdir:
 17919 00003B61 E8D200                  	CALL	DirFromSFT
 17920                                  	;mov	al,5
 17921 00003B64 B005                    	MOV	AL,error_access_denied
 17922 00003B66 7303                    	JNC	short clook
 17923 00003B68 E9AC00                  	JMP	CloseFinish		; pretend the close worked.
 17924                                  clook:
 17925                                  ;
 17926                                  ; ES:DI points to entry
 17927                                  ; DS:SI points to SFT
 17928                                  ; ES:BX points to buffer header
 17929                                  ;
 17930 00003B6B 57                      	push	di
 17931 00003B6C 56                      	push	si
 17932                                  	;lea	si,[si+20h]
 17933 00003B6D 8D7420                  	LEA	SI,[SI+SF_ENTRY.sf_name]
 17934                                  ;
 17935                                  ; ES:DI point to directory entry
 17936                                  ; DS:SI point to unpacked name
 17937                                  ;
 17938 00003B70 E8B0E4                  	call	XCHGP
 17939                                  ;
 17940                                  ; ES:DI point to unpacked name
 17941                                  ; DS:SI point to directory entry
 17942                                  ;
 17943 00003B73 E8B40D                  	call	MetaCompare
 17944 00003B76 E8AAE4                  	call	XCHGP
 17945 00003B79 5E                      	pop	si
 17946 00003B7A 5F                      	pop	di
 17947 00003B7B 740C                    	JZ	short CLOSE_GO		; Name OK
 17948                                  Bye:	
 17949 00003B7D 89F7                    	MOV	DI,SI
 17950 00003B7F 1E                      	PUSH	DS
 17951 00003B80 07                      	POP	ES			; ES:DI points to SFT
 17952 00003B81 16                      	PUSH	SS
 17953 00003B82 1F                      	POP	DS
 17954 00003B83 F9                      	STC
 17955                                  	;mov	al,2
 17956 00003B84 B002                    	MOV	AL,error_file_not_found
 17957 00003B86 E98E00                  	JMP	CloseFinish ; 24/07/2019
 17958                                  
 17959                                  	; 24/07/2019 - Retro DOS v4.0
 17960                                  	; 18/05/2019 - Retro DOS v4.0
 17961                                  CLOSE_GO:
 17962                                  	; MSDOS 6.0
 17963                                  	;test	word [si+2],8000h
 17964 00003B89 F744020080              	TEST	word [SI+SF_ENTRY.sf_mode],sf_isFCB ; FCB ?
 17965 00003B8E 740D                    	JZ	short nofcb		; no, set dir attr, sf_attr
 17966                                  	; MSDOS 3.3 & MSDOS 6.0
 17967                                  	;mov	ch,[es:di+0Bh]
 17968 00003B90 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]
 17969                                  	;mov	al,[si+4]
 17970 00003B94 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr]
 17971                                  
 17972                                  ;hkn; SS override
 17973 00003B97 36A2[2805]              	MOV	[SS:ATTRIB],AL
 17974                                  	; MSDOS 3.3
 17975                                  	;;call	MatchAttributes
 17976                                  	;;JNZ	short Bye		; attributes do not match
 17977                                  	; 18/05/2019
 17978 00003B9B EB07                    	JMP	SHORT setattr		;FT.
 17979                                  nofcb:
 17980                                  	; MSDOS 6.0
 17981                                  	;mov	al,[si+4]
 17982 00003B9D 8A4404                  	MOV	AL,[SI+SF_ENTRY.sf_attr] ;FT.		;AN000;
 17983 00003BA0 2688450B                	MOV	[ES:DI+dir_entry.dir_attr],AL ;FT.	;AN000;
 17984                                  setattr:
 17985                                  	; MSDOS 3.3 (& MSDOS 6.0)
 17986                                  	;or	byte [es:di+0Bh],20h
 17987 00003BA4 26804D0B20              	OR	BYTE [ES:DI+dir_entry.dir_attr],attr_archive ;Set archive
 17988                                  	; MSDOS 6.0
 17989                                  	;mov	ax,[es:di+1Ah]
 17990 00003BA9 268B451A                	MOV	AX,[ES:DI+dir_entry.dir_first] ;AN011
 17991                                  					;F.O. save old first cluster
 17992                                  ;hkn; SS override
 17993 00003BAD 36A3[C90F]              	MOV	[SS:OLD_FIRSTCLUS],AX	;AN011;F.O. save old first cluster
 17994                                  
 17995                                  	;mov	ax,[si+0Bh]
 17996 00003BB1 8B440B                  	MOV	AX,[SI+SF_ENTRY.sf_firclus]
 17997                                  	;mov	[es:di+1Ah],ax
 17998 00003BB4 2689451A                	MOV	[ES:DI+dir_entry.dir_first],AX	;Set firclus pointer
 17999                                  	;mov	ax,[si+11h]
 18000 00003BB8 8B4411                  	MOV	AX,[SI+SF_ENTRY.sf_size]
 18001                                  	;mov	[es:di+1Ch],ax
 18002 00003BBB 2689451C                	MOV	[ES:DI+dir_entry.dir_size_l],AX	;Set size
 18003                                  	;mov	ax,[si+13h]
 18004 00003BBF 8B4413                  	MOV	AX,[SI+SF_ENTRY.sf_size+2]
 18005                                  	;mov	[es:di+1Eh],ax
 18006 00003BC2 2689451E                	MOV	[ES:DI+dir_entry.dir_size_h],AX
 18007                                  	;mov	ax,[si+0Fh]
 18008 00003BC6 8B440F                  	MOV	AX,[SI+SF_ENTRY.sf_date]
 18009                                  	;mov	[es:di+18h],ax
 18010 00003BC9 26894518                	MOV	[ES:DI+dir_entry.dir_date],AX	;Set date
 18011                                  	;mov	ax,[si+0Dh]
 18012 00003BCD 8B440D                  	MOV	AX,[SI+SF_ENTRY.sf_time]
 18013                                  	;mov	[es:di+16h],ax
 18014 00003BD0 26894516                	MOV	[ES:DI+dir_entry.dir_time],AX	;Set time
 18015                                  
 18016                                  	; MSDOS 6.0
 18017                                  ;; File Tagging
 18018                                  	;TEST	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty  
 18019                                  	;			  ;LB. if already dirty		    ;AN000;
 18020                                  	;JNZ	short yesdirty4	  ;LB.  don't increment dirty count ;AN000;
 18021                                  	; 02/06/2019
 18022                                  	;call	INC_DIRTY_COUNT   ;LB.				    ;AN000;
 18023                                  	;
 18024                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18025                                  	;or	byte [es:bx+5],40h
 18026 00003BD4 26804F0540              	OR	byte [ES:BX+BUFFINFO.buf_flags],buf_dirty ;Buffer dirty
 18027                                  ;yesdirty4:
 18028 00003BD9 1E                      	push	ds
 18029 00003BDA 56                      	push	si
 18030                                  	; MSDOS 6.0
 18031                                  	;mov	cx,[si+0Bh]
 18032 00003BDB 8B0E0B00                	MOV	CX,[SF_ENTRY.sf_firclus] ; do this for Fastopen
 18033                                  ;hkn; SS override
 18034 00003BDF 36A0[3305]              	MOV	AL,[SS:THISDRV]
 18035                                  	; MSDOS 3.3 
 18036                                  	;push	ss
 18037                                  	;pop	ds
 18038                                  	;MOV	AL,[THISDRV]
 18039                                  ;;; 10/1/86  update fastopen cache
 18040                                  	; MSDOS 3.3 & MSDOS 6.0
 18041 00003BE3 52                      	PUSH	DX
 18042 00003BE4 B400                    	MOV	AH,0			; dir entry update
 18043 00003BE6 88C2                    	MOV	DL,AL			; drive number A=0, B=1,,,
 18044                                  	; MSDOS 6.0
 18045 00003BE8 09C9                    	OR	CX,CX			;AN005; first cluster 0; may be truncated
 18046 00003BEA 750D                    	JNZ	short do_update2	;AN005; no, do update
 18047 00003BEC B403                    	MOV	AH,3			;AN005; do a delete cache entry
 18048                                  	;mov	di,[si+1Bh]
 18049 00003BEE 8B7C1B                  	MOV	DI,[SI+SF_ENTRY.sf_dirsec] ;AN005; cx:di = dir sector
 18050                                  	;mov	cx,[si+1Dh]
 18051 00003BF1 8B4C1D                  	MOV	CX,[SI+SF_ENTRY.sf_dirsec+2] ;AN005;
 18052                                  	;mov	dh,[si+1Fh]
 18053 00003BF4 8A741F                  	MOV	DH,[SI+SF_ENTRY.sf_dirpos] ;AN005; dh= dir pos
 18054 00003BF7 EB0E                    	JMP	SHORT do_update 	;AN011;F.O.
 18055                                  do_update2:
 18056                                  ;hkn; SS override fort OLD_FIRSTCLUS
 18057                                  	; 
 18058 00003BF9 363B0E[C90F]            	CMP	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O. same as old first clusetr?
 18059 00003BFE 7407                    	JZ	short do_update		;AN011;F.O. yes
 18060 00003C00 B402                    	MOV	AH,2			;AN011;F.O. delete the old entry
 18061 00003C02 368B0E[C90F]            	MOV	CX,[SS:OLD_FIRSTCLUS]	;AN011;F.O.
 18062                                  do_update:				;AN005;
 18063                                  ;hkn; SS is DOSDATA
 18064                                  	;Context DS
 18065 00003C07 16                      	push	ss
 18066 00003C08 1F                      	pop	ds	
 18067                                  	; MSDOS 3.3 & MSDOS 6.0
 18068 00003C09 E876F8                  	call	FastOpen_Update 	; invoke fastopen
 18069 00003C0C 5A                      	POP	DX
 18070                                  
 18071                                  ;;; 10/1/86  update fastopen cache
 18072 00003C0D E85E26                  	call	FLUSHBUF		; flush all relevant buffers
 18073 00003C10 5F                      	pop	di
 18074 00003C11 07                      	pop	es
 18075                                  	;mov	al,5
 18076 00003C12 B005                    	MOV	AL,error_access_denied
 18077 00003C14 7201                    	JC	short CloseFinish
 18078                                  FREE_SFT_OK:
 18079 00003C16 F8                      	CLC				; signal no error.
 18080                                  CloseFinish:
 18081                                  
 18082                                  ; Indicate to the device that the SFT is being closed.
 18083                                  
 18084                                  ;;;; 7/21/86
 18085 00003C17 9C                      	PUSHF				; save flag from DirFromSFT
 18086 00003C18 E89914                  	call	DEV_CLOSE_SFT
 18087 00003C1B 9D                      	POPF
 18088                                  ;;;; 7/21/86
 18089                                  ;
 18090                                  ; See if the ref count indicates that we have busied the SFT. If so, mark the
 18091                                  ; SFT as being free. Note that we do NOT need to be in critSFT as we are ONLY
 18092                                  ; going to be moving from busy to free.
 18093                                  ;
 18094 00003C1C 59                      	POP	CX			; get old ref count
 18095 00003C1D 9C                      	PUSHF
 18096 00003C1E 49                      	DEC	CX			; if cx != 1
 18097 00003C1F 7503                    	JNZ	short NoFree		; then do NOT free SFT
 18098 00003C21 26890D                  	mov	[es:di],cx
 18099                                  	;MOV	[ES:DI+SF_ENTRY.sf_ref_Count],CX ; mov [es:di+0],cx
 18100                                  NoFree:
 18101 00003C24 E8EEE4                  	call	LcritDisk
 18102 00003C27 9D                      	POPF
 18103 00003C28 C3                      	retn
 18104                                  
 18105                                  ;---------------------------------------------------------------------------
 18106                                  ;
 18107                                  ; Procedure Name : FREE_SFT
 18108                                  ;
 18109                                  ; ES:DI -> SFT. Decs sft_ref_count. If the count goes to 0, mark it as busy.
 18110                                  ; Flags preserved. Return old ref count in AX
 18111                                  ;
 18112                                  ; Note that busy is indicated by the SFT ref count being -1.
 18113                                  ;
 18114                                  ;---------------------------------------------------------------------------
 18115                                  
 18116                                  FREE_SFT:
 18117 00003C29 9C                      	PUSHF		; Save carry state
 18118 00003C2A 268B05                  	mov	ax,[es:di]
 18119                                  	;MOV	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 18120 00003C2D 48                      	DEC	AX
 18121 00003C2E 7501                    	JNZ	short SetCount
 18122 00003C30 48                      	DEC	AX
 18123                                  SetCount:
 18124 00003C31 268705                  	xchg	ax,[es:di]
 18125                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 18126 00003C34 9D                      	POPF
 18127 00003C35 C3                      	retn
 18128                                  
 18129                                  ;----------------------------------------------------------------------------
 18130                                  ;
 18131                                  ; Procedure Name : DirFromSFT
 18132                                  ;
 18133                                  ;   DirFromSFT - locate a directory entry given an SFT.
 18134                                  ;
 18135                                  ;   Inputs:	ES:DI point to SFT
 18136                                  ;		DS = DOSDATA
 18137                                  ;   Outputs:
 18138                                  ;		EXTERR_LOCUS = errLOC_Disk
 18139                                  ;		CurBuf points to buffer
 18140                                  ;		Carry Clear -> operation OK
 18141                                  ;		    ES:DI point to entry
 18142                                  ;		    ES:BX point to buffer
 18143                                  ;		    DS:SI point to SFT
 18144                                  ;		Carry SET   -> operation failed
 18145                                  ;		    registers trashified
 18146                                  ;   Registers modified: ALL
 18147                                  ;----------------------------------------------------------------------------
 18148                                  
 18149                                  	; 23/07/2019 - Retro DOS v3.2
 18150                                  DirFromSFT:
 18151                                  	;mov	byte [EXTERR_LOCUS],2
 18152 00003C36 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18153 00003C3B 06                      	push	es
 18154 00003C3C 57                      	push	di
 18155                                  	; MSDOS 3.3
 18156                                  	;;mov	dx,[es:di+1Dh]
 18157                                  	;MOV	dx,[ES:DI+SF_ENTRY.sf_dirsec]
 18158                                  	; MSDOS 6.0
 18159                                  	;mov	dx,[es:[di+1Dh]
 18160 00003C3D 268B551D                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec+2]  ;F.C. >32mb
 18161 00003C41 8916[B005]              	MOV	[HIGH_SECTOR],DX		 ;F.C. >32mb
 18162                                  	;mov	dx,[es:di+1Bh]
 18163 00003C45 268B551B                	MOV	DX,[ES:DI+SF_ENTRY.sf_dirsec]
 18164                                  	; 19/05/2019
 18165 00003C49 FF36[B005]              	PUSH	word [HIGH_SECTOR]	;F.C. >32mb
 18166                                  	; MSDOS 3.3 & MSDOS 6.0
 18167 00003C4D 52                      	PUSH	DX
 18168 00003C4E E86E22                  	call	FATREAD_SFT		; ES:BP points to DPB, [THISDRV] set
 18169                                  					; [THISDPB] set
 18170 00003C51 5A                      	POP	DX
 18171 00003C52 8F06[B005]              	POP	word [HIGH_SECTOR]	;F.C. >32mb
 18172 00003C56 7225                    	JC	short PopDone
 18173 00003C58 30C0                    	XOR	AL,AL			; Pre read
 18174                                  	;mov	byte [ALLOWED],18h
 18175 00003C5A C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 18176 00003C5F E83E25                  	call	GETBUFFR
 18177 00003C62 7219                    	JC	short PopDone
 18178 00003C64 5E                      	pop	si
 18179 00003C65 1F                      	pop	ds			; Get back SFT pointer
 18180                                  
 18181                                  ;hkn; SS override
 18182 00003C66 36C43E[9E05]            	LES	DI,[SS:CURBUF]
 18183                                  	;or	byte [es:di+5],4
 18184 00003C6B 26804D0504              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 18185 00003C70 89FB                    	MOV	BX,DI			; ES:BX point to buffer header
 18186                                  	;;lea	di,[di+16] ; MSDOS 3.3
 18187                                  	;lea	di,[di+20] ; MSDOS 6.0
 18188 00003C72 8D7D14                  	LEA	DI,[DI+BUFINSIZ] 	; Point to buffer
 18189                                  	;mov	al,32
 18190 00003C75 B020                    	MOV	AL,dir_entry.size
 18191                                  	;mul	byte [si+1Fh] ; MSDOS 6.0
 18192 00003C77 F6641F                  	MUL	byte [SI+SF_ENTRY.sf_dirpos]
 18193 00003C7A 01C7                    	ADD	DI,AX			; Point at the entry
 18194 00003C7C C3                      	retn				; carry is clear
 18195                                  PopDone:
 18196 00003C7D 5F                      	pop	di
 18197 00003C7E 07                      	pop	es
 18198                                  PopDone_retn:
 18199 00003C7F C3                      	retn
 18200                                  
 18201                                  ;----------------------------------------------------------------------------
 18202                                  ;
 18203                                  ;**	DOS_Commit - UPdate Directory Entries
 18204                                  ;
 18205                                  ;	ENTRY	same as DOS_CLOSE (??? BUGBUG - update this jgl)
 18206                                  ;		(DS) = DOSGROUP
 18207                                  ;	EXIT	Same as DOS_CLOSE except ref_count field is not altered
 18208                                  ;	USES	all but DS
 18209                                  ;
 18210                                  ;----------------------------------------------------------------------------
 18211                                  ;
 18212                                  
 18213                                  DOS_COMMIT:
 18214                                  	;hkn; called from srvcall. DS already set up.
 18215 00003C80 C43E[5A05]              	LES	DI,[THISSFT]
 18216                                  	;mov	bx,[es:di+5]
 18217 00003C84 268B5D05                	MOV	BX,[ES:DI+SF_ENTRY.sf_flags]
 18218                                  	;test	bx,0C0h
 18219 00003C88 F7C3C000                	TEST	BX,devid_file_clean+devid_device ;Clears carry
 18220 00003C8C 75F1                    	jnz	short PopDone_retn
 18221                                  	;test	bx,8000h
 18222 00003C8E F7C30080                	TEST	BX,sf_isnet
 18223 00003C92 7406                    	JZ	short LOCAL_COMMIT
 18224                                  
 18225                                  ;IF NOT Installed
 18226                                  ;	transfer NET_COMMIT
 18227                                  ;ELSE
 18228                                  	;mov	ax,1107h
 18229 00003C94 B80711                  	MOV	AX,(MultNET<<8)|7
 18230 00003C97 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - COMMIT REMOTE FILE
 18231                                  			; ES:DI -> SFT
 18232                                  			; SFT DPB field -> DPB of drive containing file
 18233                                  			; Return: CF set on error, AX = DOS error code
 18234                                  			; CF clear if successful
 18235 00003C99 C3                      	retn
 18236                                  ;ENDIF
 18237                                  
 18238                                  ;
 18239                                  ; Perform local commit operation by doing a close but not releaseing the SFT.
 18240                                  ; There are three ways we can do this.	One is to enter a critical section to
 18241                                  ; protect a potential free. The second is to increment the ref count to mask
 18242                                  ; the close decrementing.
 18243                                  ;
 18244                                  ; The proper way is to let the caller's of close decide if a decrement should
 18245                                  ; be done.  We do this by providing another entry into close after the
 18246                                  ; decrement and after the share information release.
 18247                                  ;
 18248                                  LOCAL_COMMIT:
 18249 00003C9A E870E4                  	call	EcritDisk
 18250                                  	; MSDOS 6.0
 18251                                  	;call	EcritDisk	;PTM.
 18252 00003C9D E80700                  	call	SetSFTTimes
 18253 00003CA0 B8FFFF                  	MOV	AX,-1
 18254 00003CA3 E8B1FE                  	call	CloseEntry
 18255                                  	; MSDOS 6.0
 18256                                  	;PUSHF			;PTM.				;AN000;
 18257                                  	;call	DEV_OPEN_SFT	;PTM.  increment device count	;AN000;
 18258                                  	;POPF			;PTM.				;AN000;
 18259                                  	;call	LcritDisk	;PTM.				;AN000;
 18260                                  localcommit_retn:
 18261 00003CA6 C3                      	retn
 18262                                  
 18263                                  ;Break	<SetSFTTimes - signal a change in the times for an SFT>
 18264                                  ;----------------------------------------------------------------------------
 18265                                  ;
 18266                                  ; Procedure Name : SetSFTTimes
 18267                                  ;
 18268                                  ;   SetSFTTimes - Examine the flags for a SFT and set the time appropriately.
 18269                                  ;   Reflect these times in other SFT's for the same file.
 18270                                  ;
 18271                                  ;   Inputs:	ES:DI point to SFT
 18272                                  ;		BX = sf_flags set apprpriately
 18273                                  ;   Outputs:	Set sft times to current time iff File & dirty & !nodate
 18274                                  ;   Registers modified: All except ES:DI, BX, AX
 18275                                  ;
 18276                                  ;----------------------------------------------------------------------------
 18277                                  
 18278                                  SetSFTTimes:
 18279                                  ;	File clean or device does not get stamped nor disk looked at.
 18280                                  	
 18281                                  	;test	bx,0C0h
 18282 00003CA7 F7C3C000                	TEST	BX,devid_file_clean+devid_device
 18283                                  	;retnz				; clean or device => no timestamp
 18284 00003CAB 75F9                    	jnz	short localcommit_retn
 18285                                  
 18286                                  ;	file and dirty. See if date is good
 18287                                  
 18288                                  	;test	bx,4000h
 18289 00003CAD F7C30040                	TEST	BX,sf_close_nodate
 18290                                  	;retnz				; nodate => no timestamp
 18291 00003CB1 75F3                    	jnz	short localcommit_retn
 18292                                  
 18293 00003CB3 50                      	push	ax
 18294 00003CB4 53                      	push	bx
 18295 00003CB5 E89CDC                  	call	DATE16			; Date/Time to AX/DX
 18296                                  	;mov	[es:di+0Fh],ax
 18297 00003CB8 2689450F                	MOV	[ES:DI+SF_ENTRY.sf_date],AX
 18298                                  	;mov	[es:di+0Dh],dx
 18299 00003CBC 2689550D                	MOV	[ES:DI+SF_ENTRY.sf_time],DX
 18300 00003CC0 31C0                    	XOR	AX,AX
 18301                                  ;if installed
 18302                                  	;call	JShare + 14 * 4
 18303 00003CC2 FF1E[9400]              	call	far [JShare+(14*4)]	; 14 = ShSU
 18304                                  ;else
 18305                                  ;	call	ShSU
 18306                                  ;endif
 18307 00003CC6 5B                      	pop	bx
 18308 00003CC7 58                      	pop	ax
 18309 00003CC8 C3                      	retn
 18310                                  
 18311                                  ;============================================================================
 18312                                  ; DIRCALL.ASM, MSDOS 6.0, 1991
 18313                                  ;============================================================================
 18314                                  ; 23/07/2018 - Retro DOS v3.0
 18315                                  
 18316                                  ;TITLE DIRCALL - Directory manipulation internal calls
 18317                                  ;NAME  DIRCALL
 18318                                  
 18319                                  ;**	Low level directory manipulation routines for making removing and
 18320                                  ;	  verifying local or NET directories
 18321                                  ;
 18322                                  ;	DOS_MKDIR
 18323                                  ;	DOS_CHDIR
 18324                                  ;	DOS_RMDIR
 18325                                  ;
 18326                                  ;	Modification history:
 18327                                  ;
 18328                                  ;		Created: ARR 30 March 1983
 18329                                  
 18330                                  ;BREAK <DOS_MkDir - Make a directory entry>
 18331                                  ;---------------------------------------------------------------------------
 18332                                  ;
 18333                                  ; Procedure Name : DOS_MkDir
 18334                                  ;
 18335                                  ; Inputs:
 18336                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18337                                  ;		terminated)
 18338                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18339                                  ;		( = -1 if current dir not involved, else
 18340                                  ;		 Points to first char after last "/" of current dir part)
 18341                                  ;	[THISCDS] Points to CDS being used
 18342                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18343                                  ; Function:
 18344                                  ;	Make a new directory
 18345                                  ; Returns:
 18346                                  ;	Carry Clear
 18347                                  ;		No error
 18348                                  ;	Carry Set
 18349                                  ;	    AX is error code
 18350                                  ;		error_path_not_found
 18351                                  ;			Bad path (not in curr dir part if present)
 18352                                  ;		error_bad_curr_dir
 18353                                  ;			Bad path in current directory part of path
 18354                                  ;		error_access_denied
 18355                                  ;			Already exists, device name
 18356                                  ; DS preserved, Others destroyed
 18357                                  ;---------------------------------------------------------------------------
 18358                                  
 18359                                  ;hkn; called from path.asm. DS already set up.
 18360                                  
 18361                                  DOS_MKDIR:
 18362 00003CC9 E8A3E3                  	call	TestNet
 18363 00003CCC 7314                    	JNC	short LOCAL_MKDIR
 18364                                  
 18365                                  ;IF NOT Installed
 18366                                  ;	transfer NET_MKDIR
 18367                                  ;ELSE
 18368                                  	;mov	ax,1103h
 18369 00003CCE B80311                  	MOV	AX,(MultNET<<8)|3
 18370 00003CD1 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - MAKE REMOTE DIRECTORY
 18371                                  			; SS = DOS CS
 18372                                  			; SDA first filename pointer -> fully-qualified directory name
 18373                                  			; SDA CDS pointer -> current directory
 18374                                  			; Return: CF set on error, AX = DOS error code
 18375                                  			; CF clear if successful
 18376 00003CD3 C3                      	retn
 18377                                  ;ENDIF
 18378                                  
 18379                                  NODEACCERRJ:
 18380                                  	;mov	ax,5
 18381 00003CD4 B80500                  	MOV	AX,error_access_denied
 18382                                  _BadRet:
 18383 00003CD7 F9                      	STC
 18384 00003CD8 E83AE4                  	call	LcritDisk
 18385 00003CDB C3                      	retn
 18386                                  
 18387                                  PATHNFJ:
 18388 00003CDC E836E4                  	call	LcritDisk
 18389 00003CDF E9D2FA                  	jmp	SET_MKND_ERR	; Map the MakeNode error and return
 18390                                  
 18391                                  LOCAL_MKDIR:
 18392 00003CE2 E828E4                  	call	EcritDisk
 18393                                  ;
 18394                                  ; MakeNode requires an SFT to fiddle with. We Use a temp spot (RENBUF)
 18395                                  ;
 18396 00003CE5 8C16[5C05]              	MOV	[THISSFT+2],SS
 18397                                  
 18398                                  ;hkn; DOSDATA
 18399 00003CE9 C706[5A05][0204]        	MOV	WORD [THISSFT],RENBUF
 18400                                  
 18401                                  ;  NOTE: Need WORD PTR because MASM takes type of
 18402                                  ;   TempSFT (byte) instead of type of sf_mft (word).
 18403                                  
 18404                                  	;mov	word [RENBUF+33h],0 ; MSDOS 6.0
 18405 00003CEF C706[3504]0000          	MOV	WORD [RENBUF+SF_ENTRY.sf_MFT],0
 18406                                  				; make sure SHARER won't complain.
 18407                                  	;mov	al,10h
 18408 00003CF5 B010                    	MOV	AL,attr_directory
 18409 00003CF7 E8BF15                  	call	MakeNode
 18410 00003CFA 72E0                    	JC	short PATHNFJ
 18411 00003CFC 83F803                  	CMP	AX,3
 18412 00003CFF 74D3                    	JZ	short NODEACCERRJ ; Can't make a device into a directory
 18413 00003D01 C42E[4605]              	LES	BP,[THISDPB]	; Makenode zaps this
 18414 00003D05 C53E[9E05]              	LDS	DI,[CURBUF]
 18415 00003D09 29FE                    	SUB	SI,DI
 18416 00003D0B 56                      	PUSH	SI		; Pointer to dir_first
 18417                                  	; 22/07/2019 - Retro DOS v3.2
 18418                                  	; MSDOS 6.0
 18419                                  	;push	word [di+8]
 18420 00003D0C FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;F.C. >32mb
 18421                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18422                                  	;push	word [di+6]
 18423 00003D0F FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Sector of new node
 18424 00003D12 16                      	push	ss
 18425 00003D13 1F                      	pop	ds
 18426 00003D14 FF36[7E05]              	PUSH	word [DIRSTART]	; Parent for .. entry
 18427 00003D18 31C0                    	XOR	AX,AX
 18428 00003D1A A3[7E05]                	MOV	[DIRSTART],AX	; Null directory
 18429 00003D1D E8D614                  	call	NEWDIR
 18430 00003D20 7264                    	JC	short NODEEXISTSPOPDEL ; No room
 18431 00003D22 E8710C                  	call	GETENT		; First entry
 18432 00003D25 725F                    	JC	short NODEEXISTSPOPDEL ; Screw up
 18433 00003D27 C43E[9E05]              	LES	DI,[CURBUF]
 18434                                  
 18435                                  	; MSDOS 6.0
 18436                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 18437                                  	;			 ;LB. if already dirty		    ;AN000;
 18438                                  	;JNZ	short yesdirty5	 ;LB.   don't increment dirty count ;AN000;
 18439                                  	;call	INC_DIRTY_COUNT  ;LB.				    ;AN000;
 18440                                  	
 18441                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18442                                  	;or	byte [es:di+5],40h
 18443 00003D2B 26804D0540              	OR	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 18444                                  ;yesdirty5:
 18445                                  	;add	di,16
 18446 00003D30 83C714                  	ADD	DI,BUFINSIZ	; Point at buffer
 18447 00003D33 B82E20                  	MOV	AX,202EH	; ". "
 18448 00003D36 8B16[7E05]              	MOV	DX,[DIRSTART]	; Point at itself
 18449 00003D3A E85815                  	call	SETDOTENT
 18450 00003D3D B82E2E                  	MOV	AX,2E2EH	; ".."
 18451 00003D40 5A                      	POP	DX		; Parent
 18452 00003D41 E85115                  	call	SETDOTENT
 18453 00003D44 C42E[4605]              	LES	BP,[THISDPB]
 18454                                  	;mov	byte [ALLOWED],18h
 18455 00003D48 C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 18456 00003D4D 5A                      	POP	DX		; Entry sector
 18457                                  	; 23/07/2019
 18458                                  	; MSDOS 6.0
 18459 00003D4E 8F06[B005]              	POP	word [HIGH_SECTOR] ;F.C. >32mb
 18460                                  
 18461 00003D52 30C0                    	XOR	AL,AL		; Pre read
 18462 00003D54 E84924                  	call	GETBUFFR
 18463 00003D57 725A                    	JC	short NODEEXISTSP
 18464 00003D59 8B16[7E05]              	MOV	DX,[DIRSTART]
 18465 00003D5D C53E[9E05]              	LDS	DI,[CURBUF]
 18466                                  	;or	byte [di+5],4
 18467 00003D61 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 18468 00003D65 5E                      	POP	SI		; dir_first pointer
 18469 00003D66 01FE                    	ADD	SI,DI
 18470 00003D68 8914                    	MOV	[SI],DX
 18471 00003D6A 31D2                    	XOR	DX,DX
 18472 00003D6C 895402                  	MOV	[SI+2],DX	; Zero size
 18473 00003D6F 895404                  	MOV	[SI+4],DX
 18474                                  DIRUP:
 18475                                  	; MSDOS 6.0
 18476                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 18477                                  	;			 ;LB. if already dirty 		   ;AN000;
 18478                                  	;JNZ	short yesdirty2	 ;LB.  don't increment dirty count ;AN000;
 18479                                  	;call	INC_DIRTY_COUNT  ;LB.				   ;AN000;
 18480                                  	
 18481                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18482                                  	;or	byte [di+5],40h
 18483 00003D72 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty	; Dirty buffer
 18484                                  ;yesdirty2:
 18485 00003D76 16                      	push	ss
 18486 00003D77 1F                      	pop	ds
 18487 00003D78 268A4600                	mov	al,[es:bp]
 18488                                  	; 18/05/2019
 18489                                  	;MOV	AL,[ES:BP+DPB.DRIVE]  ; mov al,[es:bp+0]
 18490 00003D7C E8EF24                  	call	FLUSHBUF
 18491                                  	;mov	ax,5
 18492 00003D7F B80500                  	MOV	AX,error_access_denied
 18493 00003D82 E890E3                  	call	LcritDisk
 18494 00003D85 C3                      	retn
 18495                                  
 18496                                  NODEEXISTSPOPDEL:
 18497 00003D86 5A                      	POP	DX		; Parent
 18498 00003D87 5A                      	POP	DX		; Entry sector
 18499                                  	; 23/07/2019
 18500                                  	; MSDOS 6.0 
 18501 00003D88 8F06[B005]              	POP	word [HIGH_SECTOR] ; F.C. >32mb
 18502 00003D8C C42E[4605]              	LES	BP,[THISDPB]
 18503                                  	;mov	byte [ALLOWED],18h
 18504 00003D90 C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 18505 00003D95 30C0                    	XOR	AL,AL		; Pre read
 18506 00003D97 E80624                  	call	GETBUFFR
 18507 00003D9A 7217                    	JC	short NODEEXISTSP
 18508 00003D9C C53E[9E05]              	LDS	DI,[CURBUF]
 18509                                  	;or	byte [di+5],4
 18510 00003DA0 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 18511 00003DA4 5E                      	POP	SI		; dir_first pointer
 18512 00003DA5 01FE                    	ADD	SI,DI
 18513                                  	;sub	si,1Ah ; 26
 18514 00003DA7 83EE1A                  	SUB	SI,dir_entry.dir_first	;Point back to start of dir entry
 18515 00003DAA C604E5                  	MOV	BYTE [SI],0E5h	; Free the entry
 18516 00003DAD E8C2FF                  	CALL	DIRUP		; Error doesn't matter since erroring anyway
 18517                                  NODEEXISTS:
 18518 00003DB0 E921FF                  	JMP	NODEACCERRJ ; 10/08/2018
 18519                                  
 18520                                  NODEEXISTSP:
 18521 00003DB3 5E                      	POP	SI		; Clean stack
 18522 00003DB4 EBFA                    	JMP	short NODEEXISTS
 18523                                  
 18524                                  ;BREAK <DOS_ChDir -- Verify a directory>
 18525                                  ;----------------------------------------------------------------------------
 18526                                  ;
 18527                                  ; Procedure Name : DOS_ChDir
 18528                                  ;
 18529                                  ; Inputs:
 18530                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18531                                  ;		terminated)
 18532                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18533                                  ;		( = -1 if current dir not involved, else
 18534                                  ;		 Points to first char after last "/" of current dir part)
 18535                                  ;	[THISCDS] Points to CDS being used May not be NUL
 18536                                  ; Function:
 18537                                  ;	Validate the path for potential new current directory
 18538                                  ; Returns:
 18539                                  ;	NOTE:
 18540                                  ;	    [SATTRIB] is modified by this call
 18541                                  ;	Carry Clear
 18542                                  ;	    CX is cluster number of the DIR, LOCAL CDS ONLY
 18543                                  ;		Caller must NOT set ID fields on a NET CDS.
 18544                                  ;	Carry Set
 18545                                  ;	    AX is error code
 18546                                  ;		error_path_not_found
 18547                                  ;			Bad path
 18548                                  ;		error_access_denied
 18549                                  ;			device or file name
 18550                                  ; DS preserved, Others destroyed
 18551                                  ;----------------------------------------------------------------------------
 18552                                  
 18553                                  ;hkn; called from path.asm and dir2.asm. DS already set up.
 18554                                  
 18555                                  DOS_CHDIR:
 18556 00003DB6 E8B6E2                  	call	TestNet
 18557 00003DB9 7306                    	JNC	short LOCAL_CHDIR
 18558                                  
 18559                                  ;IF NOT Installed
 18560                                  ;	transfer NET_CHDIR
 18561                                  ;ELSE
 18562                                  	;mov	ax,1105h
 18563 00003DBB B80511                  	MOV	AX,(MultNET<<8)|5
 18564 00003DBE CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - CHDIR
 18565                                  			; SS = DOS CS
 18566                                  			; SDA first filename pointer -> fully-qualified directory name
 18567                                  			; SDA CDS pointer -> current directory
 18568                                  			; Return: CF set on error, AX = DOS error code
 18569                                  			; CF clear if successful
 18570 00003DC0 C3                      	retn
 18571                                  ;ENDIF
 18572                                  
 18573                                  LOCAL_CHDIR:
 18574 00003DC1 E849E3                  	call	EcritDisk
 18575                                  	; MSDOS 6.0
 18576                                  	;TEST	word [ES:DI+curdir.flags],curdir_splice ;PTM.
 18577                                  	;JZ	short nojoin			   ;PTM.
 18578                                  	;MOV	word [ES:DI+curdir.ID],0FFFFH	   ;PTM.
 18579                                  ;nojoin:
 18580                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18581 00003DC4 C606[1603]00            	MOV	byte [NoSetDir],0 ; FALSE
 18582                                  	;mov	byte [SATTRIB],16h
 18583 00003DC9 C606[2A05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 18584                                  				; Dir calls can find these
 18585                                  ; DOS 3.3  6/24/86 FastOpen
 18586 00003DCE 800E[A40F]01            	OR	byte [FastOpenFlg],FastOpen_Set	   ; set fastopen flag
 18587 00003DD3 E84F0C                  	call	GETPATH
 18588                                  	;PUSHF							;AN000;
 18589                                  	;AND	byte [FastOpenFlg],Fast_yes	   ; clear it all ;AC000;
 18590                                  	;POPF							;AN000;
 18591                                  ; DOS 3.3  6/24/86 FastOpen
 18592                                  
 18593                                  	; MSDOS 3.3
 18594 00003DD6 C606[A40F]00            	mov	byte [FastOpenFlg],0
 18595                                  	;mov	ax,3
 18596 00003DDB B80300                  	MOV	AX,error_path_not_found
 18597 00003DDE 7207                    	JC	short ChDirDone
 18598 00003DE0 753B                    	JNZ	short NOTDIRPATH	; Path not a DIR
 18599 00003DE2 8B0E[7E05]              	MOV	CX,[DIRSTART]		; Get cluster number
 18600 00003DE6 F8                      	CLC
 18601                                  ChDirDone:
 18602 00003DE7 E82BE3                  	call	LcritDisk
 18603 00003DEA C3                      	retn
 18604                                  
 18605                                  ;BREAK <DOS_RmDir -- Remove a directory>
 18606                                  ;----------------------------------------------------------------------------
 18607                                  ;
 18608                                  ; Procedure Name : DOS_RmDir
 18609                                  ;
 18610                                  ; Inputs:
 18611                                  ;	[WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 18612                                  ;		terminated)
 18613                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 18614                                  ;		( = -1 if current dir not involved, else
 18615                                  ;		 Points to first char after last "/" of current dir part)
 18616                                  ;	[THISCDS] Points to CDS being used
 18617                                  ;		(Low word = -1 if NUL CDS (Net direct request))
 18618                                  ; Function:
 18619                                  ;	Remove a directory
 18620                                  ;	NOTE: Attempt to remove current directory must be detected by caller
 18621                                  ; Returns:
 18622                                  ;	NOTE:
 18623                                  ;	    [SATTRIB] is modified by this call
 18624                                  ;	Carry Clear
 18625                                  ;		No error
 18626                                  ;	Carry Set
 18627                                  ;	    AX is error code
 18628                                  ;		error_path_not_found
 18629                                  ;			Bad path (not in curr dir part if present)
 18630                                  ;		error_bad_curr_dir
 18631                                  ;			Bad path in current directory part of path
 18632                                  ;		error_access_denied
 18633                                  ;			device or file name, root directory
 18634                                  ;			Bad directory ('.' '..' messed up)
 18635                                  ; DS preserved, Others destroyed
 18636                                  ;----------------------------------------------------------------------------
 18637                                  
 18638                                  ;hkn; called from path.asm. DS already set up.
 18639                                  
 18640                                  DOS_RMDIR:
 18641 00003DEB E881E2                  	call	TestNet
 18642 00003DEE 7306                    	JNC	short LOCAL_RMDIR
 18643                                  
 18644                                  ;IF NOT Installed
 18645                                  ;	transfer NET_RMDIR
 18646                                  ;ELSE
 18647                                  	;mov	ax,1101h
 18648 00003DF0 B80111                  	MOV	AX,(MultNET<<8)|1
 18649 00003DF3 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - REMOVE REMOTE DIRECTORY
 18650                                  			; SS = DOS CS
 18651                                  			; SDA first filename pointer -> fully-qualified directory name
 18652                                  			; SDA CDS pointer -> current directory
 18653                                  			; Return: CF set on error, AX = DOS error code
 18654                                  			; CF clear if successful
 18655 00003DF5 C3                      	retn
 18656                                  ;ENDIF
 18657                                  
 18658                                  LOCAL_RMDIR:
 18659 00003DF6 E814E3                  	call	EcritDisk
 18660 00003DF9 C606[1603]00            	MOV	byte [NoSetDir],0
 18661                                  	;mov	byte [SATTRIB],16h
 18662 00003DFE C606[2A05]16            	MOV	byte [SATTRIB],attr_directory+attr_system+attr_hidden
 18663                                  					; Dir calls can find these
 18664 00003E03 E81F0C                  	call	GETPATH
 18665 00003E06 720C                    	JC	short NOPATH		; Path not found
 18666 00003E08 7513                    	JNZ	short NOTDIRPATH	; Path not a DIR
 18667 00003E0A 8B3E[7E05]              	MOV	DI,[DIRSTART]
 18668 00003E0E 09FF                    	OR	DI,DI			; Root ?
 18669 00003E10 750E                    	JNZ	short rmdir_get_buf	; No
 18670 00003E12 EB09                    	JMP	SHORT NOTDIRPATH
 18671                                  
 18672                                  NOPATH:
 18673                                  	;mov	ax,3
 18674 00003E14 B80300                  	MOV	AX,error_path_not_found
 18675 00003E17 E9BDFE                  	JMP	_BadRet
 18676                                  
 18677                                  NOTDIRPATHPOP:
 18678                                  	; 23/07/2019 - Retro DOS v3.2
 18679                                  	; MSDOS 6.0
 18680 00003E1A 58                      	POP	AX			  ;F.C. >32mb
 18681 00003E1B 58                      	POP	AX
 18682                                  NOTDIRPATHPOP2:
 18683 00003E1C 58                      	POP	AX
 18684                                  NOTDIRPATH:
 18685 00003E1D E9B4FE                  	JMP	NODEACCERRJ
 18686                                  
 18687                                  rmdir_get_buf:
 18688 00003E20 C53E[9E05]              	LDS	DI,[CURBUF]
 18689 00003E24 29FB                    	SUB	BX,DI		; Compute true offset
 18690 00003E26 53                      	PUSH	BX		; Save entry pointer
 18691                                  
 18692                                  	; 22/07/2019 - Retro DOS v3.2
 18693                                  	
 18694                                  	; MSDOS 6.0
 18695                                  	;push	word [di+8]
 18696 00003E27 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2] ;F.C. >32mb
 18697                                  	
 18698                                  	; MSDOS 3.3 (& MSDOS 6.0)
 18699                                  	;push	word [di+6]
 18700 00003E2A FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector] ; Save sector number
 18701                                  
 18702                                  ;hkn; SS is DOSDATA
 18703                                  	;context DS
 18704 00003E2D 16                      	push	ss
 18705 00003E2E 1F                      	pop	ds
 18706                                  	;context ES
 18707 00003E2F 16                      	push	ss
 18708 00003E30 07                      	pop	es
 18709                                  
 18710                                  ;hkn; NAME1 is in DOSDATA
 18711 00003E31 BF[0805]                	MOV	DI,NAME1
 18712 00003E34 B03F                    	MOV	AL,'?'
 18713 00003E36 B90B00                  	MOV	CX,11
 18714 00003E39 F3AA                    	REP	STOSB
 18715 00003E3B 30C0                    	XOR	AL,AL
 18716 00003E3D AA                      	STOSB				; Nul terminate it
 18717 00003E3E E8750E                  	call	STARTSRCH		; Set search
 18718 00003E41 E84F0B                  	call	GETENTRY		; Get start of directory
 18719 00003E44 72D4                    	JC	short NOTDIRPATHPOP	; Screw up
 18720 00003E46 8E1E[A005]              	MOV	DS,[CURBUF+2]
 18721 00003E4A 89DE                    	MOV	SI,BX
 18722 00003E4C AD                      	LODSW
 18723                                  	;CMP	AX,(' ' SHL 8) OR '.'   ; First entry '.'?
 18724 00003E4D 3D2E20                  	cmp	ax,202Eh ; ". "
 18725 00003E50 75C8                    	JNZ	short NOTDIRPATHPOP	; Nope
 18726                                  	;add     si,30
 18727 00003E52 83C61E                  	ADD	SI,dir_entry.size-2 ; Next entry
 18728 00003E55 AD                      	LODSW
 18729                                  	;CMP	AX,('.' SHL 8) OR '.'   ; Second entry '..'?
 18730                                  	;cmp	ax, '..'
 18731 00003E56 3D2E2E                  	cmp	ax,2E2Eh
 18732 00003E59 75BF                    	JNZ	short NOTDIRPATHPOP	; Nope
 18733                                  
 18734                                  ;hkn; SS is DOSDATA
 18735                                  	;context DS
 18736 00003E5B 16                      	push	ss
 18737 00003E5C 1F                      	pop	ds
 18738 00003E5D C706[1203]0200          	MOV	word [LASTENT],2	; Skip . and ..
 18739 00003E63 E82D0B                  	call	GETENTRY		; Get next entry
 18740 00003E66 72B2                    	JC	short NOTDIRPATHPOP	; Screw up
 18741                                  	;mov	byte [ATTRIB],16h
 18742 00003E68 C606[2805]16            	MOV	byte [ATTRIB],attr_directory+attr_hidden+attr_system
 18743 00003E6D E8220A                  	call	SRCH			; Do a search
 18744 00003E70 73A8                    	JNC	short NOTDIRPATHPOP	; Found another entry!
 18745 00003E72 803E[1403]00            	CMP	byte [FAILERR],0
 18746 00003E77 75A1                    	JNZ	short NOTDIRPATHPOP	; Failure of search due to I 24 FAIL
 18747 00003E79 C42E[4605]              	LES	BP,[THISDPB]
 18748 00003E7D 8B1E[7E05]              	MOV	BX,[DIRSTART]
 18749 00003E81 E84819                  	call	RELEASE 		; Release data in sub dir
 18750 00003E84 7294                    	JC	short NOTDIRPATHPOP	; Screw up
 18751 00003E86 5A                      	POP	DX			; Sector # of entry
 18752                                  	; 23/07/2019
 18753 00003E87 8F06[B005]              	POP	word [HIGH_SECTOR]	; F.C. >32mb
 18754                                  	;mov	byte [ALLOWED],18h
 18755 00003E8B C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 18756 00003E90 30C0                    	XOR	AL,AL			; Pre read
 18757 00003E92 E80B23                  	call	GETBUFFR		; Get sector back
 18758 00003E95 7285                    	JC	short NOTDIRPATHPOP2	; Screw up
 18759 00003E97 C53E[9E05]              	LDS	DI,[CURBUF]
 18760                                  	;or	byte [di+5],4
 18761 00003E9B 804D0504                	OR	byte [DI+BUFFINFO.buf_flags],buf_isDIR
 18762 00003E9F 5B                      	POP	BX			; Pointer to start of entry
 18763 00003EA0 01FB                    	ADD	BX,DI			; Corrected
 18764 00003EA2 C607E5                  	MOV	BYTE [BX],0E5h		; Free the entry
 18765                                  
 18766                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 18767 00003EA5 1E                      	PUSH	DS
 18768                                  
 18769                                  ;hkn; SS is DOSDATA
 18770                                  	;context DS
 18771 00003EA6 16                      	push	ss
 18772 00003EA7 1F                      	pop	ds
 18773                                  
 18774                                  	; 23/07/2019 - Retro DOS v3.2
 18775                                  
 18776                                  	; MSDOS 6.0
 18777 00003EA8 E8C3F5                  	call	FastOpen_Delete 	; call fastopen to delete an entry
 18778                                  
 18779                                  ;	; MSDOS 3.3
 18780                                  ;_FastOpen_Delete:
 18781                                  ;	push	ax
 18782                                  ;	mov	si,[WFP_START]
 18783                                  ;	mov	bx,FastTable
 18784                                  ;	;mov	al,3  ; FONC_delete
 18785                                  ;	mov	al,FONC_delete
 18786                                  ;	call	far [BX+2]  ; FastTable+2
 18787                                  ;	pop	ax
 18788                                  
 18789 00003EAB 1F                      	POP	DS
 18790                                  ;DOS 3.3 FastOpen  6/16/86  F.C.
 18791                                  
 18792 00003EAC E9C3FE                  	JMP	DIRUP			; In MKDIR, dirty buffer and flush
 18793                                  
 18794                                  ;============================================================================
 18795                                  ; DISK.ASM, MSDOS 6.0, 1991
 18796                                  ;============================================================================
 18797                                  ; 23/07/2018 - Retro DOS v3.0 
 18798                                  
 18799                                  ;	TITLE	DISK - Disk utility routines
 18800                                  ;	NAME	Disk
 18801                                  
 18802                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 18803                                  ;
 18804                                  ;	SWAPCON
 18805                                  ;	SWAPBACK
 18806                                  ;	DOS_READ
 18807                                  ;	DOS_WRITE
 18808                                  ;	get_io_sft
 18809                                  ;	DirRead
 18810                                  ;	FIRSTCLUSTER
 18811                                  ;	SET_BUF_AS_DIR
 18812                                  ;	FATSecRd
 18813                                  ;	DREAD
 18814                                  ;	CHECK_WRITE_LOCK
 18815                                  ;	CHECK_READ_LOCK
 18816                                  ;
 18817                                  ;	Revision history:
 18818                                  ;
 18819                                  ;		A000   version 4.00  Jan. 1988
 18820                                  ;
 18821                                  ;----------------------------------------------------------------------------
 18822                                  ;
 18823                                  ; M065 : B#5276. On raw read/write of a block of characters if a critical
 18824                                  ;		error happens, DOS retries the entire block assuming that
 18825                                  ;		zero characters were transferred. Modified the code to take
 18826                                  ;		into account the number of characters transfered before
 18827                                  ;		retrying the operation.
 18828                                  ;
 18829                                  ;----------------------------------------------------------------------------
 18830                                  ;
 18831                                  
 18832                                  ;Installed = TRUE
 18833                                  
 18834                                  ;Break	<SwapCon, Swap Back - Old-style I/O to files>
 18835                                  
 18836                                  ; **** Drivers for file input from devices ****
 18837                                  ;----------------------------------------------------------------------------
 18838                                  ;   Indicate that there is no more I/O occurring through another SFT outside
 18839                                  ;   of handles 0 and 1
 18840                                  ;
 18841                                  ;   Inputs:	DS is DOSDATA
 18842                                  ;   Outputs:	CONSWAP is set to false.
 18843                                  ;   Registers modified: none
 18844                                  ;----------------------------------------------------------------------------
 18845                                  
 18846                                  ; IBMDOS.COM (MSDOS 3.3) - Offset 3CF8h
 18847                                  
 18848                                  SWAPBACK:
 18849 00003EAF C606[2103]00            	MOV	BYTE [CONSWAP],0	; signal no conswaps
 18850 00003EB4 C3                      	retn
 18851                                  
 18852                                  ;----------------------------------------------------------------------------
 18853                                  ;
 18854                                  ; Procedure Name : SWAPCON
 18855                                  ;
 18856                                  ;   Copy ThisSFT to CONSFT for use by the 1-12 primitives.
 18857                                  ;
 18858                                  ;   Inputs:	ThisSFT as the sft of the desired file
 18859                                  ;		DS is DOSDATA
 18860                                  ;   Outputs:	CONSWAP is set.  CONSFT = ThisSFT.
 18861                                  ;   Registers modified: none
 18862                                  ;--------------------------------------------------------------------------
 18863                                  
 18864                                  SWAPCON:
 18865                                  	; MSDOS 3.3
 18866                                  	;push	es
 18867                                  	;push	di
 18868                                  	;mov	byte [CONSWAP],1
 18869                                  	;les	di,[THISSFT]
 18870                                  	;mov	word [CONSFT],di
 18871                                  	;mov	word [CONSFT+2],es
 18872                                  	;pop	di
 18873                                  	;pop	es
 18874                                  	;retn
 18875                                  
 18876                                  	; MSDOS 6.0
 18877 00003EB5 C606[2103]01            	mov	byte [CONSWAP],1	; ConSwap = TRUE
 18878 00003EBA 50                      	push	ax
 18879 00003EBB A1[5A05]                	mov	ax,[THISSFT]
 18880 00003EBE A3[A205]                	mov	[CONSFT],ax
 18881 00003EC1 A1[5C05]                	mov	ax,[THISSFT+2]
 18882 00003EC4 A3[A405]                	mov	[CONSFT+2],ax
 18883 00003EC7 58                      	pop	ax
 18884 00003EC8 C3                      	retn
 18885                                  
 18886                                  ;Break	<DOS_READ -- MAIN READ ROUTINE AND DEVICE IN ROUTINES>
 18887                                  ;-----------------------------------------------------------------------------
 18888                                  ;
 18889                                  ; Inputs:
 18890                                  ;	ThisSFT set to the SFT for the file being used
 18891                                  ;	[DMAADD] contains transfer address
 18892                                  ;	CX = No. of bytes to read
 18893                                  ;	DS = DOSDATA
 18894                                  ; Function:
 18895                                  ;	Perform read operation
 18896                                  ; Outputs:
 18897                                  ;    Carry clear
 18898                                  ;	SFT Position and cluster pointers updated
 18899                                  ;	CX = No. of bytes read
 18900                                  ;	ES:DI point to SFT
 18901                                  ;    Carry set
 18902                                  ;	AX is error code
 18903                                  ;	CX = 0
 18904                                  ;	ES:DI point to SFT
 18905                                  ; DS preserved, all other registers destroyed
 18906                                  ;
 18907                                  ;-----------------------------------------------------------------------------
 18908                                  
 18909                                  ;hkn; called from fcbio.asm, handle.asm and dev.asm. DS is be set up.
 18910                                  
 18911                                  DOS_READ:
 18912 00003EC9 C43E[5A05]              	LES	DI,[THISSFT]
 18913                                  
 18914                                  ; Verify that the sft has been opened in a mode that allows reading.
 18915                                  
 18916                                  	;mov	al,[es:di+2]
 18917 00003ECD 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 18918                                  	;and	al,0Fh
 18919 00003ED1 240F                    	AND	AL,access_mask
 18920                                  	;cmp	al,1
 18921 00003ED3 3C01                    	CMP	AL,open_for_write
 18922 00003ED5 7503                    	JNE	short READ_NO_MODE		;Is read or both
 18923 00003ED7 E96805                  	jmp	SET_ACC_ERR
 18924                                  
 18925                                  READ_NO_MODE:
 18926 00003EDA E83F04                  	call	SETUP
 18927 00003EDD E30B                    	JCXZ	NoIORet 		; no bytes to read - fast return
 18928 00003EDF E8A2E1                  	call	IsSFTNet
 18929 00003EE2 7408                    	JZ	short LOCAL_READ
 18930                                  
 18931                                  ;IF NOT Installed
 18932                                  ;	transfer NET_READ
 18933                                  ;ELSE
 18934                                  	;mov	ax,1108h
 18935 00003EE4 B80811                  	MOV	AX,(MultNET<<8)|8
 18936 00003EE7 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - READ FROM REMOTE FILE
 18937                                  			; ES:DI -> SFT
 18938                                  			; SFT DPB field -> DPB of drive containing file
 18939                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 18940                                  			; Return: CF set on error, CX = bytes read
 18941 00003EE9 C3                      	retn
 18942                                  ;ENDIF
 18943                                  
 18944                                  ; The user ended up requesting 0 bytes of input. We do nothing for this case
 18945                                  ; except return immediately.
 18946                                  
 18947                                  NoIORet:
 18948 00003EEA F8                      	CLC
 18949 00003EEB C3                      	retn
 18950                                  
 18951                                  LOCAL_READ:
 18952                                  	; 31/07/2019
 18953                                  	;test	word [es:di+5],80h
 18954                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device  ; Check for named device I/O
 18955 00003EEC 26F6450580              	test	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 18956 00003EF1 750F                    	JNZ	short READDEV
 18957                                  
 18958                                  	;mov	byte [EXTERR_LOCUS],2
 18959 00003EF3 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 18960 00003EF8 E812E2                  	call	EcritDisk
 18961 00003EFB E80005                  	call	DISKREAD
 18962                                  
 18963                                  critexit:
 18964 00003EFE E814E2                  	call	LcritDisk
 18965 00003F01 C3                      	retn
 18966                                  
 18967                                  ; We are reading from a device. Examine the status of the device to see if we
 18968                                  ; can short-circuit the I/O. If the device in the EOF state or if it is the
 18969                                  ; null device, we can safely indicate no transfer.
 18970                                  
 18971                                  READDEV:
 18972                                  	;mov	byte [EXTERR_LOCUS],4
 18973 00003F02 C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 18974                                  	;mov	bl,[es:di+5]
 18975 00003F07 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 18976 00003F0B C43E[F802]              	LES	DI,[DMAADD]
 18977                                  	;test	bl,40h
 18978 00003F0F F6C340                  	test	BL,devid_device_EOF	; End of file?
 18979 00003F12 7407                    	JZ	short ENDRDDEVJ3
 18980                                  	;test	bl,4
 18981 00003F14 F6C304                  	test	BL,devid_device_null	; NUL device?
 18982 00003F17 7405                    	JZ	short TESTRAW 		; NO
 18983 00003F19 30C0                    	XOR	AL,AL			; Indicate EOF by setting zero
 18984                                  ENDRDDEVJ3:
 18985                                  	;JMP	ENDRDDEVJ2
 18986 00003F1B E9C800                  	jmp	ENDRDDEV ; 31/07/2019
 18987                                  
 18988                                  ;
 18989                                  ; We need to hit the device. Figure out if we do a raw read or we do the
 18990                                  ; bizarre std_con_string_input.
 18991                                  ;
 18992                                  TESTRAW:
 18993                                  	;test	bl,20h
 18994 00003F1E F6C320                  	test	BL,devid_device_raw	; Raw mode?
 18995 00003F21 7508                    	JNZ	short DVRDRAW 		; Yes, let the device do all local editing
 18996                                  	;test	bl,1
 18997 00003F23 F6C301                  	test	BL,devid_device_con_in	; Is it console device?
 18998 00003F26 7451                    	JZ	short NOTRDCON
 18999 00003F28 E9F000                  	JMP	READCON
 19000                                  
 19001                                  DVRDRAW:
 19002 00003F2B 06                      	PUSH	ES
 19003 00003F2C 1F                      	POP	DS			; Xaddr to DS:DI
 19004                                  
 19005                                  	; MSDOS 6.0
 19006                                  ;SR;
 19007                                  ;Check for win386 presence -- if present, do polled read of characters
 19008                                  ;
 19009                                  	;test	byte [ss:IsWIN386],1
 19010                                  	;jz	short ReadRawRetry	;not present
 19011                                  	;test	bl,devid_device_con_in	;is it console device
 19012                                  	;jz	short ReadRawRetry	;no, do normal read
 19013                                  	;jmp	do_polling		;yes, do win386 polling loop
 19014                                  
 19015                                  ReadRawRetry:
 19016 00003F2D 89FB                    	MOV	BX,DI			; DS:BX transfer addr
 19017 00003F2F 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 19018 00003F31 89C2                    	MOV	DX,AX			; Start at 0
 19019 00003F33 E86E12                  	call	SETREAD
 19020 00003F36 1E                      	PUSH	DS			; Save Seg part of Xaddr
 19021                                  
 19022                                  ;hkn; SS override
 19023 00003F37 36C536[5A05]            	LDS	SI,[SS:THISSFT]
 19024 00003F3C E8F011                  	call	DEVIOCALL
 19025 00003F3F 89FA                    	MOV	DX,DI			; DS:DX is preserved by INT 24
 19026 00003F41 B486                    	MOV	AH,86H			; Read error
 19027                                  
 19028                                  ;hkn; SS override
 19029 00003F43 368B3E[2703]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 19030                                  	; MSDOS 3.3
 19031                                  	;test	di,8000h
 19032                                  	;jz	short CRDROK
 19033                                  	; MSDOS 6.0
 19034 00003F48 09FF                    	or	di,di
 19035 00003F4A 7923                    	jns	short CRDROK		; no errors
 19036                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19037 00003F4C E8BD1B                  	call	CHARHARD
 19038 00003F4F 89D7                    	MOV	DI,DX			; DS:DI is Xaddr
 19039                                  
 19040                                  	; 25/07/2019 - Retro DOS v3.2
 19041                                  	
 19042                                  	; MSDOS 6.0
 19043 00003F51 36033E[3603]            	add	di,[ss:CALLSCNT]	; update ptr and count to reflect the	M065
 19044 00003F56 362B0E[3603]            	sub	cx,[ss:CALLSCNT]	; number of chars xferred		M065
 19045                                  
 19046                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19047 00003F5B 08C0                    	OR	AL,AL
 19048 00003F5D 7410                    	JZ	short CRDROK		; Ignore
 19049 00003F5F 3C03                    	CMP	AL,3
 19050 00003F61 7403                    	JZ	short CRDFERR 		; fail.
 19051 00003F63 1F                      	POP	DS			; Recover saved seg part of Xaddr
 19052                                  	; 19/05/2019
 19053 00003F64 EBC7                    	JMP	short ReadRawRetry	; Retry
 19054                                  ;
 19055                                  ; We have encountered a device-driver error. We have informed the user of it
 19056                                  ; and he has said for us to fail the system call.
 19057                                  ;
 19058                                  CRDFERR:
 19059 00003F66 5F                      	POP	DI			; Clean stack
 19060                                  DEVIOFERR:
 19061                                  
 19062                                  ;hkn; SS override
 19063 00003F67 36C43E[5A05]            	LES	DI,[SS:THISSFT]
 19064 00003F6C E9D104                  	jmp	SET_ACC_ERR_DS
 19065                                  CRDROK:
 19066 00003F6F 5F                      	POP	DI			; Chuck saved seg of Xaddr
 19067 00003F70 89D7                    	MOV	DI,DX
 19068                                  
 19069                                  ;hkn; SS override
 19070 00003F72 36033E[3603]            	ADD	DI,[ss:CALLSCNT]	; Amount transferred
 19071 00003F77 EBA2                    	JMP	SHORT ENDRDDEVJ3
 19072                                  
 19073                                  ; We are going to do a cooked read on some character device. There is a
 19074                                  ; problem here, what does the data look like? Is it a terminal device, line
 19075                                  ; CR line CR line CR, or is it file data, line CR LF line CR LF? Does it have
 19076                                  ; a ^Z at the end which is data, or is the ^Z not data?  In any event we're
 19077                                  ; going to do this: Read in pieces up to CR (CRs included in data) or ^z (^z
 19078                                  ; included in data). this "simulates" the way con works in cooked mode
 19079                                  ; reading one line at a time. With file data, however, the lines will look
 19080                                  ; like, LF line CR. This is a little weird.
 19081                                  
 19082                                  NOTRDCON:
 19083 00003F79 8CC0                    	MOV	AX,ES
 19084 00003F7B 8ED8                    	MOV	DS,AX
 19085 00003F7D 89FB                    	MOV	BX,DI
 19086 00003F7F 31D2                    	XOR	DX,DX
 19087 00003F81 89D0                    	MOV	AX,DX
 19088 00003F83 51                      	PUSH	CX
 19089 00003F84 B90100                  	MOV	CX,1
 19090 00003F87 E81A12                  	call	SETREAD
 19091 00003F8A 59                      	POP	CX
 19092                                  
 19093                                  ;hkn; SS override
 19094 00003F8B 36C536[5A05]            	LDS	SI,[SS:THISSFT]
 19095                                  	;lds	si,[si+7]
 19096 00003F90 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 19097                                  DVRDLP:
 19098 00003F93 E8A219                  	call	DSKSTATCHK
 19099 00003F96 E89911                  	call	DEVIOCALL2
 19100 00003F99 57                      	PUSH	DI		; Save "count" done
 19101 00003F9A B486                    	MOV	AH,86H
 19102                                  
 19103                                  ;hkn; SS override
 19104 00003F9C 368B3E[2703]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 19105                                  	
 19106                                  	; MSDOS 3.3
 19107                                  	;test	di,8000h
 19108                                  	;jz	short CRDOK
 19109                                  	; MSDOS 6.0
 19110 00003FA1 09FF                    	or	di,di
 19111 00003FA3 7917                    	jns	short CRDOK
 19112                                  	
 19113 00003FA5 E8641B                  	call	CHARHARD
 19114 00003FA8 5F                      	POP	DI
 19115                                  
 19116                                  ;hkn; SS override
 19117 00003FA9 36C706[3603]0100        	MOV	word [SS:CALLSCNT],1
 19118 00003FB0 3C01                    	CMP	AL,1
 19119 00003FB2 74DF                    	JZ	short DVRDLP		;Retry
 19120 00003FB4 3C03                    	CMP	AL,3
 19121 00003FB6 74AF                    	JZ	short DEVIOFERR		; FAIL
 19122 00003FB8 30C0                    	XOR	AL,AL			; Ignore, Pick some random character
 19123 00003FBA EB12                    	JMP	SHORT DVRDIGN
 19124                                  
 19125                                  CRDOK:
 19126 00003FBC 5F                      	POP	DI
 19127                                  
 19128                                  ;hkn; SS override
 19129 00003FBD 36833E[3603]01          	CMP	word [SS:CALLSCNT],1
 19130                                  	;JNZ	short ENDRDDEVJ2
 19131 00003FC3 7521                    	jnz	short ENDRDDEV ; 24/07/2019
 19132 00003FC5 1E                      	PUSH	DS
 19133                                  
 19134                                  ;hkn; SS override
 19135 00003FC6 368E1E[3403]            	MOV	DS,[SS:CALLXAD+2]
 19136 00003FCB 8A05                    	MOV	AL,[DI]			; Get the character we just read
 19137 00003FCD 1F                      	POP	DS
 19138                                  DVRDIGN:
 19139                                  
 19140                                  ;hkn; SS override
 19141 00003FCE 36FF06[3203]            	INC	WORD [SS:CALLXAD]	; Next character
 19142 00003FD3 36C706[2703]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 19143 00003FDA 47                      	INC	DI			; Next character
 19144 00003FDB 3C1A                    	CMP	AL,1AH			; ^Z?
 19145                                  	;JZ	short ENDRDDEVJ2	; Yes, done zero set (EOF)
 19146 00003FDD 7407                    	jz	short ENDRDDEV ; 31/07/2019	
 19147 00003FDF 3C0D                    	CMP	AL,c_CR 		; CR?
 19148 00003FE1 E0B0                    	LOOPNZ	DVRDLP			; Loop if no, else done
 19149 00003FE3 40                      	INC	AX			; Resets zero flag so NOT EOF, unless
 19150                                  					;  AX=FFFF which is not likely
 19151                                  ENDRDDEVJ2:
 19152 00003FE4 EB00                    	JMP	short ENDRDDEV		;changed short to long for win386
 19153                                  
 19154                                  	;  MSDOS 6.0
 19155                                  ;;SR;
 19156                                  ;;Polling code for raw read on CON when WIN386 is present
 19157                                  ;;
 19158                                  ;;At this point -- ds:di is transfer address
 19159                                  ;;		  cx is count
 19160                                  ;;
 19161                                  ;
 19162                                  ;do_polling:
 19163                                  ;	mov	bx,di			;ds:bx is Xfer address
 19164                                  ;	xor	ax,ax
 19165                                  ;	mov	dx,ax
 19166                                  ;	call	setread			;prepare device packet
 19167                                  ;
 19168                                  ;do_io:
 19169                                  ;;
 19170                                  ;;Change read to a NON-DESTRUCTIVE READ, NO WAIT
 19171                                  ;;
 19172                                  ;	mov	byte ptr es:[bx+2],DEVRDND	;Change command code
 19173                                  ;	push	ds
 19174                                  ;	lds	si,[THISSFT]		;get device header
 19175                                  ;	call	deviocall		;call device driver
 19176                                  ;	pop	ds
 19177                                  ;	
 19178                                  ;	test	es:[bx.REQSTAT],STERR	;check if error
 19179                                  ;	jz	check_busy		;no
 19180                                  ;
 19181                                  ;	push	ds
 19182                                  ;	mov	dx,di
 19183                                  ;	invoke 	charhard		;invoke int 24h handler
 19184                                  ;	mov	di,dx
 19185                                  ;	or	al,al
 19186                                  ;	jz	pop_done_read		;ignore by user, assume read done
 19187                                  ;	cmp	al,3
 19188                                  ;	jz	devrderr		;user asked to fail
 19189                                  ;	pop	ds
 19190                                  ;	jmp	do_io			;user asked to retry
 19191                                  ;
 19192                                  ;check_busy:
 19193                                  ;	test	es:[bx.REQSTAT],0200h	;see if busy bit set
 19194                                  ;	jnz	no_char			;yes, no character available
 19195                                  ;;
 19196                                  ;;Character is available. Read in 1 character at a time until all characters
 19197                                  ;;are read in or no character is available
 19198                                  ;;
 19199                                  ;	mov	byte ptr es:[bx+2],DEVRD	;command code is READ now
 19200                                  ;	mov	word ptr es:[bx+18],1		;change count to 1 character
 19201                                  ;	push	ds
 19202                                  ;	lds	si,[THISSFT]
 19203                                  ;	call	deviocall
 19204                                  ;
 19205                                  ;	mov	dx,di
 19206                                  ;	mov	ah,86h
 19207                                  ;	mov	di,es:[bx.REQSTAT]	;get returned status
 19208                                  ;	test	di,STERR		;was there an error during read?
 19209                                  ;	jz	next_char		;no,read next character
 19210                                  ;
 19211                                  ;	invoke	charhard		;invoke int 24h handler
 19212                                  ;	mov	di,dx			;restore di
 19213                                  ;	or	al,al			;
 19214                                  ;	jz	pop_done_read		;ignore by user,assume read is done
 19215                                  ;	cmp	al,3
 19216                                  ;	jz	devrderr		;user issued a 'fail',indicate error
 19217                                  ;	pop	ds
 19218                                  ;	jmp	do_io			;user issued a retry
 19219                                  ;
 19220                                  ;next_char:
 19221                                  ;	pop	ds
 19222                                  ;	mov	di,dx
 19223                                  ;	dec	cx			;decrement count
 19224                                  ;	jcxz	done_read		;all characters read in
 19225                                  ;	inc	word ptr es:[bx+14]	;update transfer address
 19226                                  ;	jmp	do_io			;read next character in
 19227                                  ;
 19228                                  ;devrderr:
 19229                                  ;	pop	di			;discard segment address
 19230                                  ;	les	di,[THISSFT]
 19231                                  ;	transfer SET_ACC_ERR_DS		;indicate error
 19232                                  ;
 19233                                  ;no_char:
 19234                                  ;;
 19235                                  ;;Since no character is available, we let win386 switch the VM out
 19236                                  ;;
 19237                                  ;	push	ax
 19238                                  ;	mov	ah,84h
 19239                                  ;	int	2ah			;indicate idle to WIN386
 19240                                  ;;
 19241                                  ;;When control returns from WIN386, we continue the raw read
 19242                                  ;;
 19243                                  ;	pop	ax
 19244                                  ;	jmp	do_io
 19245                                  ;
 19246                                  ;pop_done_read:
 19247                                  ;	pop	ds
 19248                                  ;done_read:
 19249                                  ;	add	di,[CALLSCNT]
 19250                                  ;	jmp	ENDRDDEVJ3	;jump back to normal DOS raw read exit
 19251                                  
 19252                                  	; 31/07/2019 - Retro DOS v3.2
 19253                                  	; 04/05/2019 - Retro DOS v4.0
 19254                                  ENDRDDEV:
 19255 00003FE6 16                      	push	ss
 19256 00003FE7 1F                      	pop	ds
 19257 00003FE8 EB1F                    	jmp	short endrddev1
 19258                                  
 19259                                  TRANBUF:
 19260 00003FEA AC                      	LODSB
 19261 00003FEB AA                      	STOSB
 19262 00003FEC 3C0D                    	CMP	AL,c_CR 	; Check for carriage return
 19263 00003FEE 7503                    	JNZ	short NORMCH
 19264 00003FF0 C6040A                  	MOV	BYTE [SI],c_LF
 19265                                  NORMCH:
 19266 00003FF3 3C0A                    	CMP	AL,c_LF
 19267 00003FF5 E0F3                    	LOOPNZ	TRANBUF
 19268 00003FF7 7507                    	JNZ	short ENDRDCON
 19269 00003FF9 31F6                    	XOR	SI,SI		; Cause a new buffer to be read
 19270 00003FFB E815E4                  	call	OUTT		; Transmit linefeed
 19271 00003FFE 0C01                    	OR	AL,1		; Clear zero flag--not end of file
 19272                                  ENDRDCON:
 19273                                  
 19274                                  ;hkn; SS is DOSDATA
 19275 00004000 16                      	push	ss
 19276 00004001 1F                      	pop	ds
 19277 00004002 E8AAFE                  	CALL	SWAPBACK
 19278 00004005 8936[2200]              	MOV	[CONTPOS],SI
 19279                                  ;ENDRDDEV:
 19280                                  ;hkn; SS is DOSDATA
 19281                                  ;	push	ss
 19282                                  ;	pop	ds
 19283                                  endrddev1:	; 31/07/2019
 19284 00004009 893E[7405]              	MOV	[NEXTADD],DI
 19285 0000400D 7509                    	JNZ	short SETSFTC 	; Zero set if Ctrl-Z found in input
 19286 0000400F C43E[5A05]              	LES	DI,[THISSFT]
 19287                                  	;and	byte [es:di+5],0BFh
 19288 00004013 26806505BF              	AND	BYTE [ES:DI+SF_ENTRY.sf_flags],~devid_device_EOF 
 19289                                  					; Mark as no more data available
 19290                                  SETSFTC:
 19291                                  	; 31/07/2019
 19292                                  	;call	SETSFT
 19293                                  	;retn
 19294 00004018 E92305                  	jmp	SETSFT
 19295                                  
 19296                                  READCON:
 19297 0000401B E897FE                  	CALL	SWAPCON
 19298 0000401E 8B36[2200]              	MOV	SI,[CONTPOS]
 19299 00004022 09F6                    	OR	SI,SI
 19300 00004024 75C4                    	JNZ	short TRANBUF
 19301 00004026 803E[4702]80            	CMP	BYTE [CONBUF],128
 19302 0000402B 7406                    	JZ	short GETBUF
 19303 0000402D C706[4702]80FF          	MOV	WORD [CONBUF],0FF80H ; Set up 128-byte buffer with no template
 19304                                  GETBUF:
 19305 00004033 51                      	PUSH	CX
 19306 00004034 06                      	PUSH	ES
 19307 00004035 57                      	PUSH	DI
 19308                                  
 19309                                  ;hkn; CONBUF is in DOSDATA
 19310 00004036 BA[4702]                	MOV	DX,CONBUF
 19311                                  
 19312 00004039 E857E1                  	call	_$STD_CON_STRING_INPUT	; Get input buffer
 19313 0000403C 5F                      	POP	DI
 19314 0000403D 07                      	POP	ES
 19315 0000403E 59                      	POP	CX
 19316                                  
 19317                                  ;hkn; CONBUF is in DOSDATA
 19318 0000403F BE[4902]                	MOV	SI,CONBUF+2
 19319                                  
 19320 00004042 803C1A                  	CMP	BYTE [SI],1AH	; Check for Ctrl-Z in first character
 19321 00004045 75A3                    	JNZ	short TRANBUF
 19322 00004047 B01A                    	MOV	AL,1AH
 19323 00004049 AA                      	STOSB
 19324 0000404A 4F                      	DEC	DI
 19325 0000404B B00A                    	MOV	AL,c_LF
 19326 0000404D E8C3E3                  	call	OUTT		; Send linefeed
 19327 00004050 31F6                    	XOR	SI,SI
 19328 00004052 EBAC                    	JMP	short ENDRDCON
 19329                                  
 19330                                  ; 24/07/2018 - Retro DOS v3.0
 19331                                  
 19332                                  ;Break	<DOS_WRITE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES>
 19333                                  ;---------------------------------------------------------------------------
 19334                                  ;
 19335                                  ; Procedure Name : DOS_WRITE
 19336                                  ;
 19337                                  ; Inputs:
 19338                                  ;	ThisSFT set to the SFT for the file being used
 19339                                  ;	[DMAADD] contains transfer address
 19340                                  ;	CX = No. of bytes to write
 19341                                  ; Function:
 19342                                  ;	Perform write operation
 19343                                  ;	NOTE: If CX = 0 on input, file is truncated or grown
 19344                                  ;		to current sf_position
 19345                                  ; Outputs:
 19346                                  ;    Carry clear
 19347                                  ;	SFT Position and cluster pointers updated
 19348                                  ;	CX = No. of bytes written
 19349                                  ;	ES:DI point to SFT
 19350                                  ;    Carry set
 19351                                  ;	AX is error code
 19352                                  ;	CX = 0
 19353                                  ;	ES:DI point to SFT
 19354                                  ; DS preserved, all other registers destroyed
 19355                                  ;---------------------------------------------------------------------------
 19356                                  
 19357                                  ;hkn; called from fcbio2.asm, handle.asm and dev.asm. DS is set up at this 
 19358                                  ;hkn; point to DOSDATA.
 19359                                  
 19360                                  DOS_WRITE:
 19361 00004054 C43E[5A05]              	LES	DI,[THISSFT]
 19362                                  	;mov	al,[ES:DI+2]
 19363 00004058 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 19364                                  	;and	al,0Fh
 19365 0000405C 240F                    	AND	AL,access_mask
 19366                                  	;cmp	al,0
 19367 0000405E 3C00                    	CMP	AL,open_for_read
 19368 00004060 7503                    	JNE	short Check_FCB_RO		 ;Is write or both
 19369                                  BadMode:
 19370 00004062 E9DD03                  	jmp	SET_ACC_ERR
 19371                                  
 19372                                  ;
 19373                                  ; NOTE: The following check for writting to a Read Only File is performed
 19374                                  ;	    ONLY on FCBs!!!!
 19375                                  ;	We ALLOW writes to Read Only files via handles to allow a CREATE
 19376                                  ;	    of a read only file which can then be written to.
 19377                                  ;	This is OK because we are NOT ALLOWED to OPEN a RO file via handles
 19378                                  ;	    for writting, or RE-CREATE an EXISTING RO file via handles. Thus,
 19379                                  ;	    CREATing a NEW RO file, or RE-CREATing an existing file which
 19380                                  ;	    is NOT RO to be RO, via handles are the only times we can write
 19381                                  ;	    to a read-only file.
 19382                                  ;
 19383                                  Check_FCB_RO:
 19384                                  	; 25/07/2019 - Retro DOS v3.2
 19385                                  	;;test	word [es:di+2],8000h
 19386                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 19387                                  	;JZ	short WRITE_NO_MODE	; Not an FCB
 19388                                  	
 19389                                  	;test	byte [es:di+3],80h
 19390 00004065 26F6450380              	TEST	byte [ES:DI+SF_ENTRY.sf_mode+1],(sf_isFCB>>8)
 19391 0000406A 7407                    	JZ	short WRITE_NO_MODE	; Not an FCB
 19392                                  
 19393                                  	;test	byte [es:di+4],1
 19394 0000406C 26F6450401              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_read_only
 19395 00004071 75EF                    	JNZ	short BadMode 		; Can't write to Read_Only files via FCB
 19396                                  WRITE_NO_MODE:
 19397 00004073 E8A602                  	call	SETUP
 19398 00004076 E80BE0                  	call	IsSFTNet
 19399 00004079 7406                    	JZ	short LOCAL_WRITE
 19400                                  
 19401                                  ;IF NOT Installed
 19402                                  ;	transfer NET_WRITE
 19403                                  ;ELSE
 19404                                  	;mov	ax,1109h
 19405 0000407B B80911                  	MOV	AX,(MultNET<<8)|9
 19406 0000407E CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - WRITE TO REMOTE FILE
 19407                                  			; ES:DI -> SFT
 19408                                  			; SFT DPB field -> DPB of drive containing file
 19409                                  			; CX = number of bytes, SS = DOS CS, SDA DTA field -> user buffer
 19410                                  			; Return: CF set on error, CX = bytes written
 19411 00004080 C3                      	retn
 19412                                  ;ENDIF
 19413                                  
 19414                                  LOCAL_WRITE:
 19415                                  	; 25/07/2019
 19416                                  	;;test	word [es:di+5],80h
 19417                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 19418                                  	;jnz	short WRTDEV
 19419                                  
 19420                                  	;test	byte [es:di+5],80h
 19421 00004081 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device ; Check for named device I/O
 19422 00004086 755D                    	jnz	short WRTDEV
 19423                                  
 19424                                  	;mov	byte [EXTERR_LOCUS],2
 19425 00004088 C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 19426 0000408D E87DE0                  	call	EcritDisk
 19427                                  
 19428 00004090 E8D904                  	call	DISKWRITE
 19429                                  
 19430                                  	; MSDOS 6.0
 19431                                  ;; Extended Open
 19432                                  	;JC	short nocommit
 19433                                  	;LES	DI,[THISSFT]
 19434                                  	;TEST	word [ES:DI+SF_ENTRY.sf_mode],auto_commit_write
 19435                                  	;JZ	short nocommit
 19436                                  	;PUSH	CX
 19437                                  	;call	DOS_COMMIT
 19438                                  	;POP	CX
 19439                                  ;nocommit:
 19440                                  ;; Extended Open
 19441 00004093 E87FE0                  	call	LcritDisk
 19442 00004096 C3                      	retn
 19443                                  
 19444                                  DVWRTRAW:
 19445 00004097 31C0                    	XOR	AX,AX			; Media Byte, unit = 0
 19446 00004099 E83B11                  	call	SETWRITE
 19447 0000409C 1E                      	PUSH	DS			; Save seg of transfer
 19448                                  
 19449                                  ;hkn; SS override
 19450 0000409D 36C536[5A05]            	LDS	SI,[SS:THISSFT]
 19451 000040A2 E88A10                  	call	DEVIOCALL		; DS:SI -> DEVICE
 19452                                  
 19453 000040A5 89FA                    	MOV	DX,DI			; Offset part of Xaddr saved in DX
 19454 000040A7 B487                    	MOV	AH,87H
 19455                                  
 19456                                  ;hkn; SS override
 19457 000040A9 368B3E[2703]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 19458                                  
 19459                                  	; MSDOS 3.3
 19460                                  	;test	di,8000h
 19461                                  	;jz	short CWRTROK
 19462                                  
 19463                                  	; MSDOS 6.0
 19464 000040AE 09FF                    	or	di,di
 19465 000040B0 7920                    	jns	short CWRTROK
 19466                                  	
 19467                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19468 000040B2 E8571A                  	call	CHARHARD
 19469                                  
 19470                                  	; 25/07/2019 - Retro DOS v3.2
 19471                                  
 19472                                  	; MSDOS 6.0
 19473 000040B5 362B0E[3603]            	sub	cx,[ss:CALLSCNT]	; update ptr & count to reflect	M065
 19474 000040BA 89D3                    	mov	bx,dx			; number of chars xferred	M065
 19475 000040BC 36031E[3603]            	add	bx,[ss:CALLSCNT]	;				M065
 19476 000040C1 89DF                    	mov	di,bx			;				M065
 19477                                  	
 19478                                  	; MSDOS 3.3
 19479                                  	;MOV	BX,DX			; Recall transfer addr		M065
 19480                                  
 19481                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19482 000040C3 08C0                    	OR	AL,AL
 19483 000040C5 740B                    	JZ	short CWRTROK 		; Ignore
 19484 000040C7 3C03                    	CMP	AL,3
 19485 000040C9 7403                    	JZ	short CWRFERR
 19486 000040CB 1F                      	POP	DS			; Recover saved seg of transfer
 19487 000040CC EBC9                    	JMP	short DVWRTRAW		; Try again
 19488                                  
 19489                                  CWRFERR:
 19490 000040CE 58                      	POP	AX			; Chuck saved seg of transfer
 19491 000040CF E994FE                  	JMP	CRDFERR 		; Will pop one more stack element
 19492                                  
 19493                                  CWRTROK:
 19494 000040D2 58                      	POP	AX			; Chuck saved seg of transfer
 19495 000040D3 1F                      	POP	DS
 19496 000040D4 A1[3603]                	MOV	AX,[CALLSCNT]		; Get actual number of bytes transferred
 19497                                  ENDWRDEV:
 19498 000040D7 C43E[5A05]              	LES	DI,[THISSFT]
 19499 000040DB 89C1                    	MOV	CX,AX
 19500                                  	;call	ADDREC
 19501                                  	;retn
 19502                                  	; 25/07/2019
 19503 000040DD E97F04                  	jmp	ADDREC
 19504                                  
 19505                                  WRTNUL:
 19506 000040E0 89CA                    	MOV	DX,CX			;Entire transfer done
 19507                                  WRTCOOKJ:
 19508 000040E2 E98D00                  	JMP	WRTCOOKDONE
 19509                                  
 19510                                  WRTDEV:
 19511                                  	;mov	byte [EXTERR_LOCUS],4
 19512 000040E5 C606[EF02]04            	MOV	byte [EXTERR_LOCUS],errLOC_SerDev
 19513                                  	;or	byte [es:di+5],40h
 19514 000040EA 26804D0540              	OR	BYTE [ES:DI+SF_ENTRY.sf_flags],devid_device_EOF
 19515                                  					; Reset EOF for input
 19516                                  	;mov	bl,[es:di+5]
 19517 000040EF 268A5D05                	MOV	BL,[ES:DI+SF_ENTRY.sf_flags]
 19518 000040F3 31C0                    	XOR	AX,AX
 19519 000040F5 E3E0                    	JCXZ	ENDWRDEV		; problem of creating on a device.
 19520 000040F7 1E                      	PUSH	DS
 19521 000040F8 88D8                    	MOV	AL,BL
 19522 000040FA C51E[F802]              	LDS	BX,[DMAADD]		; Xaddr to DS:BX
 19523 000040FE 89DF                    	MOV	DI,BX			; Xaddr to DS:DI
 19524 00004100 31D2                    	XOR	DX,DX			; Set starting point
 19525                                  	;test	al,20h
 19526 00004102 A820                    	test	AL,devid_device_raw	; Raw?
 19527                                  	;JZ	short TEST_DEV_CON
 19528                                  	;JMP	DVWRTRAW
 19529 00004104 7591                    	jnz	short DVWRTRAW
 19530                                  
 19531                                  TEST_DEV_CON:
 19532                                  	;test	al,2
 19533 00004106 A802                    	test	AL,devid_device_con_out ; Console output device?
 19534 00004108 756E                    	jnz	short WRITECON
 19535                                  	;test	al,4
 19536 0000410A A804                    	test	AL,devid_device_null
 19537 0000410C 75D2                    	JNZ	short WRTNUL
 19538 0000410E 89D0                    	MOV	AX,DX
 19539 00004110 803F1A                  	CMP	BYTE [BX],1Ah		; ^Z?
 19540 00004113 74CD                    	JZ	short WRTCOOKJ		; Yes, transfer nothing
 19541 00004115 51                      	PUSH	CX
 19542 00004116 B90100                  	MOV	CX,1
 19543 00004119 E8BB10                  	call	SETWRITE
 19544 0000411C 59                      	POP	CX
 19545                                  
 19546                                  ;hkn; SS override
 19547 0000411D 36C536[5A05]            	LDS	SI,[SS:THISSFT]
 19548                                  ;
 19549                                  ;SR; Removed X25 support from here
 19550                                  ;
 19551                                  	;lds	si,[si+7]
 19552 00004122 C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 19553                                  DVWRTLP:
 19554 00004125 E81018                  	call	DSKSTATCHK
 19555 00004128 E80710                  	call	DEVIOCALL2
 19556 0000412B 57                      	PUSH	DI
 19557 0000412C B487                    	MOV	AH,87H
 19558                                  
 19559                                  ;hkn; SS override
 19560 0000412E 368B3E[2703]            	MOV	DI,[SS:DEVCALL_REQSTAT]
 19561                                  	
 19562                                  	; MSDOS 3.3
 19563                                  	;test	di,8000h
 19564                                  	;jz	short CWROK
 19565                                  
 19566                                  	; MSDOS 6.0
 19567 00004133 09FF                    	or	di,di
 19568 00004135 7916                    	jns	short CWROK
 19569                                  	
 19570                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19571 00004137 E8D219                  	call	CHARHARD
 19572 0000413A 5F                      	POP	DI
 19573                                  
 19574                                  ;hkn; SS override
 19575 0000413B 36C706[3603]0100        	MOV	word [SS:CALLSCNT],1
 19576 00004142 3C01                    	CMP	AL,1
 19577 00004144 74DF                    	JZ	short DVWRTLP 	; Retry
 19578 00004146 08C0                    	OR	AL,AL
 19579 00004148 740C                    	JZ	short DVWRTIGN	; Ignore
 19580                                  	; 10/08/2018
 19581 0000414A E919FE                  	JMP	CRDFERR 	; Fail, pops one stack element
 19582                                  
 19583                                  CWROK:
 19584 0000414D 5F                      	POP	DI
 19585                                  
 19586                                  ;hkn; SS override
 19587 0000414E 36833E[3603]00          	CMP	word [SS:CALLSCNT],0
 19588 00004154 741C                    	JZ	short WRTCOOKDONE
 19589                                  DVWRTIGN:
 19590 00004156 42                      	INC	DX
 19591                                  
 19592                                  ;hkn; SS override for CALLXAD
 19593 00004157 36FF06[3203]            	INC	WORD [SS:CALLXAD]
 19594 0000415C 47                      	INC	DI
 19595 0000415D 1E                      	PUSH	DS
 19596 0000415E 368E1E[3403]            	MOV	DS,[SS:CALLXAD+2]
 19597 00004163 803D1A                  	CMP	BYTE [DI],1Ah	; ^Z?
 19598 00004166 1F                      	POP	DS
 19599 00004167 7409                    	JZ	short WRTCOOKDONE
 19600                                  
 19601                                  ;hkn; SS override
 19602 00004169 36C706[2703]0000        	MOV	word [SS:DEVCALL_REQSTAT],0
 19603 00004170 E2B3                    	LOOP	DVWRTLP
 19604                                  WRTCOOKDONE:
 19605 00004172 89D0                    	MOV	AX,DX
 19606 00004174 1F                      	POP	DS
 19607 00004175 E95FFF                  	JMP	ENDWRDEV ; 10/08/2018
 19608                                  
 19609                                  WRITECON:
 19610 00004178 1E                      	PUSH	DS
 19611                                  
 19612                                  ;hkn; SS is DOSDATA
 19613 00004179 16                      	push	ss
 19614 0000417A 1F                      	pop	ds
 19615 0000417B E837FD                  	CALL	SWAPCON
 19616 0000417E 1F                      	POP	DS
 19617 0000417F 89DE                    	MOV	SI,BX
 19618 00004181 51                      	PUSH	CX
 19619                                  WRCONLP:
 19620 00004182 AC                      	LODSB
 19621 00004183 3C1A                    	CMP	AL,1Ah		; ^Z?
 19622 00004185 7405                    	JZ	short CONEOF
 19623 00004187 E889E2                  	call	OUTT
 19624 0000418A E2F6                    	LOOP	WRCONLP
 19625                                  CONEOF:
 19626 0000418C 58                      	POP	AX			; Count
 19627 0000418D 29C8                    	SUB	AX,CX			; Amount actually written
 19628 0000418F 1F                      	POP	DS
 19629 00004190 E81CFD                  	CALL	SWAPBACK
 19630 00004193 E941FF                  	JMP	ENDWRDEV
 19631                                  
 19632                                  ;---------------------------------------------------------------------------
 19633                                  ;
 19634                                  ; Procedure Name : get_io_sft
 19635                                  ;
 19636                                  ;   Convert JFN number in BX to sf_entry in DS:SI We get the normal SFT if
 19637                                  ;   CONSWAP is FALSE or if the handle desired is 2 or more.  Otherwise, we
 19638                                  ;   retrieve the sft from ConSFT which is set by SwapCon.
 19639                                  ;
 19640                                  ;---------------------------------------------------------------------------
 19641                                  
 19642                                  GET_IO_SFT:
 19643                                  	;test	byte [SS:CONSWAP],0FFh
 19644 00004196 36803E[2103]00          	cmp	byte [SS:CONSWAP],0			;smr;SS Override
 19645 0000419C 7512                    	JNZ	short GetRedir
 19646                                  GetNormal:
 19647 0000419E 16                      	push	ss
 19648 0000419F 1F                      	pop	ds
 19649 000041A0 06                      	PUSH	ES
 19650 000041A1 57                      	PUSH	DI
 19651 000041A2 E89E29                  	call	SFFromHandle
 19652 000041A5 7206                    	JC	short RET44P
 19653 000041A7 8CC6                    	MOV	SI,ES
 19654 000041A9 8EDE                    	MOV	DS,SI
 19655 000041AB 89FE                    	MOV	SI,DI
 19656                                  RET44P:
 19657 000041AD 5F                      	POP	DI
 19658 000041AE 07                      	POP	ES
 19659 000041AF C3                      	retn
 19660                                  GetRedir:
 19661 000041B0 83FB01                  	CMP	BX,1
 19662 000041B3 77E9                    	JA	short GetNormal
 19663 000041B5 36C536[A205]            	LDS	SI,[SS:CONSFT]
 19664 000041BA F8                      	CLC
 19665                                  get_io_sft_retn:
 19666 000041BB C3                      	retn
 19667                                  
 19668                                  ;Break	<DIRREAD -- READ A DIRECTORY SECTOR>
 19669                                  ;---------------------------------------------------------------------------
 19670                                  ;
 19671                                  ; Procedure Name : DIRREAD
 19672                                  ;
 19673                                  ; Inputs:
 19674                                  ;	AX = Directory block number (relative to first block of directory)
 19675                                  ;	ES:BP = Base of drive parameters
 19676                                  ;	[DIRSEC] = First sector of first cluster of directory
 19677                                  ;	[CLUSNUM] = Next cluster
 19678                                  ;	[CLUSFAC] = Sectors/Cluster
 19679                                  ; Function:
 19680                                  ;	Read the directory block into [CURBUF].
 19681                                  ; Outputs:
 19682                                  ;	[NXTCLUSNUM] = Next cluster (after the one skipped to)
 19683                                  ;	[SECCLUSPOS] Set
 19684                                  ;	ES:BP unchanged
 19685                                  ;	[CURBUF] Points to Buffer with dir sector
 19686                                  ;	Carry set if error (user said FAIL to I 24)
 19687                                  ; DS preserved, all other registers destroyed.
 19688                                  ;---------------------------------------------------------------------------
 19689                                  
 19690                                  ;hkn; called from dir.asm. DS already set up to DOSDATA.
 19691                                  
 19692                                  DIRREAD:
 19693                                  
 19694                                  ; Note that ClusFac is the sectors per cluster. This is NOT necessarily
 19695                                  ; the same as what is in the DPB! In the case of the root directory, we have
 19696                                  ; ClusFac = # sectors in the root directory. The root directory is detected
 19697                                  ; by DIRStart = 0.
 19698                                  
 19699 000041BC 31D2                    	XOR	DX,DX
 19700 000041BE 833E[7E05]00            	CMP	word [DIRSTART],0
 19701 000041C3 7503                    	jnz	short SubDir
 19702 000041C5 92                      	XCHG	AX,DX
 19703 000041C6 EB0C                    	JMP	short DoRead
 19704                                  
 19705                                  ; Convert the sector number in AX into cluster and sector-within-cluster pair
 19706                                  
 19707                                  SubDir:
 19708 000041C8 88C2                    	MOV	DL,AL
 19709                                  	;and	dl,[es:bp+4]
 19710 000041CA 26225604                	AND	DL,[ES:BP+DPB.CLUSTER_MASK]
 19711                                  
 19712                                  ;	(DX) = sector-in-cluster
 19713                                  
 19714                                  	;mov	cl,[es:bp+5]
 19715 000041CE 268A4E05                	MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 19716 000041D2 D3E8                    	SHR	AX,CL
 19717                                  
 19718                                  ;	(DX) = position in cluster
 19719                                  ;	(AX) = number of clusters to skip
 19720                                  
 19721                                  DoRead:
 19722 000041D4 8816[3005]              	MOV	[SECCLUSPOS],DL
 19723 000041D8 89C1                    	MOV	CX,AX
 19724 000041DA 88D4                    	MOV	AH,DL
 19725                                  
 19726                                  ;	(CX) = number of clusters to skip.
 19727                                  ;	(AH) = remainder
 19728                                  
 19729                                  	; 04/05/2019 - Retro DOS v4.0
 19730                                  	; 23/07/2019 - Retro DOS v3.2
 19731                                  
 19732                                  	; MSDOS 6.0
 19733 000041DC 8B16[7C05]              	MOV	DX,[DIRSEC+2]	     	  ;>32mb
 19734 000041E0 8916[B005]              	MOV	[HIGH_SECTOR],DX	  ;>32mb
 19735 000041E4 8B16[7A05]              	MOV	DX,[DIRSEC]
 19736 000041E8 00E2                    	ADD	DL,AH
 19737 000041EA 80D600                  	ADC	DH,0
 19738 000041ED 8316[B005]00            	ADC	word [HIGH_SECTOR],0	  ;>32mb
 19739                                  
 19740 000041F2 8B1E[7805]              	MOV	BX,[CLUSNUM]
 19741 000041F6 891E[9805]              	MOV	[NXTCLUSNUM],BX
 19742 000041FA E319                    	JCXZ	FIRSTCLUSTER
 19743                                  SKPCLLP:
 19744 000041FC E8301B                  	call	UNPACK
 19745 000041FF 72BA                    	jc	short get_io_sft_retn
 19746 00004201 87DF                    	XCHG	BX,DI
 19747 00004203 E8121B                  	call	IsEOF			; test for eof based on fat size
 19748 00004206 7302                    	JAE	short HAVESKIPPED
 19749 00004208 E2F2                    	LOOP	SKPCLLP
 19750                                  HAVESKIPPED:
 19751 0000420A 891E[9805]              	MOV	[NXTCLUSNUM],BX
 19752 0000420E 89FA                    	MOV	DX,DI
 19753 00004210 88E3                    	MOV	BL,AH
 19754 00004212 E8DF14                  	call	FIGREC
 19755                                  
 19756                                  	;entry	FIRSTCLUSTER
 19757                                  
 19758                                  FIRSTCLUSTER:
 19759                                  	;mov	byte [ALLOWED],18h
 19760 00004215 C606[1503]18            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 19761 0000421A 30C0                    	XOR	AL,AL		; Indicate pre-read
 19762 0000421C E8811F                  	call	GETBUFFR
 19763 0000421F 729A                    	jc	short get_io_sft_retn
 19764                                  
 19765                                  	;entry	SET_BUF_AS_DIR
 19766                                  
 19767                                  SET_BUF_AS_DIR:
 19768                                  
 19769                                  ;	Set the type of CURBUF to be a directory sector.
 19770                                  ;	Only flags are modified.
 19771                                  
 19772 00004221 1E                      	PUSH	DS
 19773 00004222 56                      	PUSH	SI
 19774 00004223 C536[9E05]              	LDS	SI,[CURBUF]
 19775                                  	;or	byte [si+5],4
 19776 00004227 804C0504                	OR	byte [SI+BUFFINFO.buf_flags],buf_isDIR	; Clears carry
 19777 0000422B 5E                      	POP	SI
 19778 0000422C 1F                      	POP	DS
 19779                                  dirread_retn:
 19780 0000422D C3                      	retn
 19781                                  
 19782                                  ;Break	<FATSECRD -- READ A FAT SECTOR>
 19783                                  ;----------------------------------------------------------------------------
 19784                                  ;
 19785                                  ; Procedure Name : FATSECRD
 19786                                  ; Inputs:
 19787                                  ;	Same as DREAD
 19788                                  ;	DS:BX = Transfer address
 19789                                  ;	CX = Number of sectors
 19790                                  ;	DX = Absolute record number
 19791                                  ;	ES:BP = Base of drive parameters
 19792                                  ; Function:
 19793                                  ;	Calls BIOS to perform FAT read.
 19794                                  ; Outputs:
 19795                                  ;	Same as DREAD
 19796                                  ;---------------------------------------------------------------------------
 19797                                  
 19798                                  	; 04/05/2019 - Retro DOS v4.0
 19799                                  	; 23/07/2019 - REtro DOS v3.2
 19800                                  FATSECRD:
 19801                                  ;hkn; SS override
 19802                                  	;mov	byte [ss:ALLOWED],18h
 19803 0000422E 36C606[1503]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 19804 00004234 89CF                    	MOV	DI,CX
 19805                                  	;mov	cl,[es:bp+8]
 19806 00004236 268A4E08                	MOV	CL,[ES:BP+DPB.FAT_COUNT]
 19807                                  	; MSDOS 3.3
 19808                                  	;;mov	al,[es:bp+0Fh]
 19809                                  	;MOV	AL,[ES:BP+DPB.FAT_SIZE] 
 19810                                  	;XOR	AH,AH
 19811                                  	; MSDOS 6.0
 19812                                  	;mov	ax,[es:bp+0Fh]
 19813 0000423A 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE] ;>32mb
 19814 0000423E 30ED                    	XOR	CH,CH	
 19815 00004240 52                      	PUSH	DX
 19816                                  NXTFAT:
 19817                                  	; MSDOS 6.0
 19818                                  ;hkn; SS override
 19819 00004241 36C706[B005]0000        	MOV	word [SS:HIGH_SECTOR],0	;>32mb FAT sectors cannot exceed
 19820 00004248 51                      	PUSH	CX			;32mb
 19821 00004249 50                      	PUSH	AX
 19822 0000424A 89F9                    	MOV	CX,DI
 19823 0000424C E85B00                  	call	DSKREAD
 19824 0000424F 58                      	POP	AX
 19825 00004250 59                      	POP	CX
 19826 00004251 7420                    	JZ	short RET41P		; Carry clear
 19827 00004253 01C2                    	ADD	DX,AX
 19828 00004255 E2EA                    	LOOP	NXTFAT
 19829 00004257 5A                      	POP	DX
 19830 00004258 89F9                    	MOV	CX,DI
 19831                                  
 19832                                  ; NOTE FALL THROUGH
 19833                                  
 19834                                  ;Break	<DREAD -- DO A DISK READ>
 19835                                  ;---------------------------------------------------------------------------
 19836                                  ;
 19837                                  ; Procedure Name : DREAD
 19838                                  ;
 19839                                  ; Inputs:
 19840                                  ;	DS:BX = Transfer address
 19841                                  ;	CX = Number of sectors
 19842                                  ;	DX = Absolute record number	      (LOW)
 19843                                  ;	[HIGH_SECTOR]= Absolute record number (HIGH)
 19844                                  ;	ES:BP = Base of drive parameters
 19845                                  ;	[ALLOWED] must be set in case call to HARDERR needed
 19846                                  ; Function:
 19847                                  ;	Calls BIOS to perform disk read. If BIOS reports
 19848                                  ;	errors, will call HARDERRRW for further action.
 19849                                  ; Outputs:
 19850                                  ;	Carry set if error (currently user FAILED to INT 24)
 19851                                  ; DS,ES:BP preserved. All other registers destroyed.
 19852                                  ;---------------------------------------------------------------------------
 19853                                  
 19854                                  	;entry	DREAD
 19855                                  DREAD:
 19856 0000425A E84D00                  	call	DSKREAD
 19857 0000425D 74CE                    	jz	short dirread_retn	; Carry clear
 19858                                  ;hkn; SS override
 19859 0000425F 36C606[3205]00          	MOV	BYTE [SS:READOP],0
 19860 00004265 E89A00                  	call	HARDERRRW
 19861 00004268 3C01                    	CMP	AL,1		; Check for retry
 19862 0000426A 74EE                    	JZ	short DREAD
 19863 0000426C 3C03                    	CMP	AL,3		; Check for FAIL
 19864 0000426E F8                      	CLC
 19865 0000426F 7501                    	JNZ	short NO_CAR		; Ignore
 19866 00004271 F9                      	STC
 19867                                  NO_CAR:
 19868 00004272 C3                      	retn
 19869                                  RET41P: 
 19870 00004273 5A                      	POP	DX
 19871 00004274 C3                      	retn
 19872                                  
 19873                                  ; 24/07/2018 - Retro DOS v3.0
 19874                                  
 19875                                  ;Break	<CHECK_WRITE_LOCK>
 19876                                  ;---------------------------------------------------------------------------
 19877                                  ;
 19878                                  ; Procedure Name : CHECK_WRITE_LOCK
 19879                                  ;
 19880                                  ; Inputs:
 19881                                  ;	output of SETUP
 19882                                  ;	ES:DI -> SFT
 19883                                  ; Function:
 19884                                  ;	check write lock
 19885                                  ; Outputs:
 19886                                  ;	Carry set if error
 19887                                  ;	Carry clear if ok
 19888                                  ;
 19889                                  ;----------------------------------------------------------------------------
 19890                                  
 19891                                  CHECK_WRITE_LOCK:
 19892                                  	; MSDOS 6.0
 19893                                  	;test	byte [es:di+4],8
 19894 00004275 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 19895                                  	;JZ	short write_cont			     ;no
 19896                                  	;call	SET_ACC_ERR_DS		;
 19897                                  	;retn
 19898                                  	;jnz	SET_ACC_ERR_DS
 19899                                  	; 19/08/2018
 19900 0000427A 7403                    	jz	short write_cont
 19901 0000427C E9C101                  	jmp	SET_ACC_ERR_DS
 19902                                  write_cont:				;
 19903 0000427F 51                      	PUSH	CX			;save reg
 19904 00004280 09C9                    	OR	CX,CX			;
 19905 00004282 7501                    	JNZ	short Not_Truncate	;
 19906 00004284 49                      	dec	cx			;(cx) = -1; check for lock on whole file
 19907                                  Not_Truncate:				;
 19908 00004285 B080                    	MOV	AL,80H			;check write access
 19909 00004287 E8A233                  	call	LOCK_CHECK		;check lock
 19910 0000428A 59                      	POP	CX			;restore reg
 19911 0000428B 7305                    	JNC	short WRITE_OK		;lock ok
 19912 0000428D E86701                  	call	WRITE_LOCK_VIOLATION	;issue I24
 19913 00004290 73ED                    	JNC	short write_cont	;retry
 19914                                  WRITE_OK:				;
 19915 00004292 C3                      	retn				;
 19916                                  
 19917                                  ;Break	<CHECK_READ_LOCK>
 19918                                  ;---------------------------------------------------------------------------
 19919                                  ;
 19920                                  ; Procedure Name : CHECK_READ_LOC
 19921                                  ;
 19922                                  ; Inputs:
 19923                                  ;	ES:DI -> SFT
 19924                                  ;	output of SETUP
 19925                                  ; Function:
 19926                                  ;	check read lock
 19927                                  ; Outputs:
 19928                                  ;	Carry set if error
 19929                                  ;	Carry clear if ok
 19930                                  ;----------------------------------------------------------------------------
 19931                                  
 19932                                  CHECK_READ_LOCK:
 19933                                  	; MSDOS 6.0
 19934                                  	;test	byte [es:di+4],8
 19935 00004293 26F6450408              	TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id ;volume id
 19936                                  	;JZ	short do_retry			   	     ; no
 19937                                  	;call	SET_ACC_ERR		;
 19938                                  	;retn
 19939                                  	;jnz	SET_ACC_ERR
 19940                                  	; 28/07/2019
 19941 00004298 7403                    	jz	short do_retry
 19942 0000429A E9A501                  	jmp	SET_ACC_ERR
 19943                                  do_retry:				;
 19944 0000429D 30C0                    	xor	al,al			;check read access
 19945 0000429F E88A33                  	call	LOCK_CHECK		;check lock
 19946 000042A2 7305                    	JNC	short READLOCK_OK 	;lock ok
 19947 000042A4 E82901                  	call	READ_LOCK_VIOLATION	;issue I24
 19948 000042A7 73F4                    	JNC	short do_retry		;retry
 19949                                  READLOCK_OK:				;
 19950 000042A9 C3                      	retn				;
 19951                                  
 19952                                  ;============================================================================
 19953                                  ; DISK2.ASM, MSDOS 6.0, 1991
 19954                                  ;============================================================================
 19955                                  ; 24/07/2018 - Retro DOS v3.0 
 19956                                  
 19957                                  ;	TITLE	DISK2 - Disk utility routines
 19958                                  ;	NAME	Disk2
 19959                                  
 19960                                  ;**	Low level Read and write routines for local SFT I/O on files and devs
 19961                                  ;
 19962                                  ;	DskRead
 19963                                  ;	DWRITE
 19964                                  ;	DSKWRITE
 19965                                  ;	HarderrRW
 19966                                  ;	SETUP
 19967                                  ;	BREAKDOWN
 19968                                  ;	READ_LOCK_VIOLATION
 19969                                  ;	WRITE_LOCK_VIOLATION
 19970                                  ;	DISKREAD
 19971                                  ;	SET_ACC_ERR_DS
 19972                                  ;	SET_ACC_ERR
 19973                                  ;	SETSFT
 19974                                  ;	SETCLUS
 19975                                  ;	AddRec
 19976                                  ;
 19977                                  ;	Revision history:
 19978                                  ;
 19979                                  ;		AN000 version 4.00 Jan. 1988
 19980                                  ;		M039 DB 10/17/90 - Disk read/write optimization
 19981                                  
 19982                                  ;Break	<DSKREAD -- PHYSICAL DISK READ>
 19983                                  ;---------------------------------------------------------------------------
 19984                                  ;
 19985                                  ; Procedure Name : DSKREAD
 19986                                  ;
 19987                                  ; Inputs:
 19988                                  ;	DS:BX = Transfer addr
 19989                                  ;	CX = Number of sectors
 19990                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 19991                                  ;	DX = Absolute record number	       (LOW)
 19992                                  ;	ES:BP = Base of drive parameters
 19993                                  ; Function:
 19994                                  ;	Call BIOS to perform disk read
 19995                                  ; Outputs:
 19996                                  ;	DI = CX on entry
 19997                                  ;	CX = Number of sectors unsuccessfully transfered
 19998                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 19999                                  ;	Zero set if OK (from BIOS) (carry clear)
 20000                                  ;	Zero clear if error (carry clear)
 20001                                  ; SI Destroyed, others preserved
 20002                                  ;---------------------------------------------------------------------------
 20003                                  
 20004                                  DSKREAD:
 20005 000042AA 51                      	PUSH	CX
 20006                                  	;mov	ah,[es:bp+16h]
 20007                                  	;mov	ah,[es:bp+17h] ; MSDOS 6.0 ; 26/07/2019
 20008 000042AB 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 20009                                  	;mov	al,[es:bp+1]
 20010 000042AF 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 20011 000042B3 53                      	PUSH	BX
 20012 000042B4 06                      	PUSH	ES
 20013 000042B5 E8EC0E                  	call	SETREAD
 20014 000042B8 EB27                    	JMP	short DODSKOP
 20015                                  
 20016                                  ;Break	<DWRITE -- SEE ABOUT WRITING>
 20017                                  ;--------------------------------------------------------------------------
 20018                                  ;
 20019                                  ; Procedure Name : DWRITE
 20020                                  ;
 20021                                  ; Inputs:
 20022                                  ;	DS:BX = Transfer address
 20023                                  ;	CX = Number of sectors
 20024                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 20025                                  ;	DX = Absolute record number	       (LOW)
 20026                                  ;	ES:BP = Base of drive parameters
 20027                                  ;	[ALLOWED] must be set in case HARDERR called
 20028                                  ; Function:
 20029                                  ;	Calls BIOS to perform disk write. If BIOS reports
 20030                                  ;	errors, will call HARDERRRW for further action.
 20031                                  ; Output:
 20032                                  ;	Carry set if error (currently, user FAILed to I 24)
 20033                                  ; BP preserved. All other registers destroyed.
 20034                                  ;----------------------------------------------------------------------------
 20035                                  
 20036                                  
 20037                                  	;entry	DWRITE
 20038                                  DWRITE:
 20039 000042BA E81600                  	CALL	DSKWRITE
 20040 000042BD 7413                    	jz	short dw_ret_label	; Carry clear (retz)
 20041                                  
 20042                                  ;hkn; SS override
 20043 000042BF 36C606[3205]01          	MOV	BYTE [SS:READOP],1
 20044 000042C5 E83A00                  	call	HARDERRRW
 20045 000042C8 3C01                    	CMP	AL,1		; Check for retry
 20046 000042CA 74EE                    	JZ	short DWRITE
 20047 000042CC 3C03                    	CMP	AL,3		; Check for FAIL
 20048 000042CE F8                      	CLC
 20049 000042CF 7501                    	JNZ	short NO_CAR2 	; Ignore
 20050 000042D1 F9                      	STC
 20051                                  NO_CAR2:
 20052                                  dw_ret_label:
 20053 000042D2 C3                      	retn
 20054                                  
 20055                                  ;Break	<DSKWRITE -- PHYSICAL DISK WRITE>
 20056                                  ;---------------------------------------------------------------------------
 20057                                  ;
 20058                                  ; Procedure Name : DSKWRITE
 20059                                  ;
 20060                                  ; Inputs:
 20061                                  ;	DS:BX = Transfer addr
 20062                                  ;	CX = Number of sectors
 20063                                  ;	DX = Absolute record number	       (LOW)
 20064                                  ;	[HIGH_SECTOR] = Absolute record number (HIGH)
 20065                                  ;	ES:BP = Base of drive parameters
 20066                                  ; Function:
 20067                                  ;	Call BIOS to perform disk read
 20068                                  ; Outputs:
 20069                                  ;	DI = CX on entry
 20070                                  ;	CX = Number of sectors unsuccessfully transfered
 20071                                  ;	AX = Status word as returned by BIOS (error code in AL if error)
 20072                                  ;	Zero set if OK (from BIOS) (carry clear)
 20073                                  ;	Zero clear if error (carry clear)
 20074                                  ; SI Destroyed, others preserved
 20075                                  ;
 20076                                  ;----------------------------------------------------------------------------
 20077                                  
 20078                                  	;entry	DSKWRITE
 20079                                  DSKWRITE:
 20080 000042D3 51                      	PUSH	CX
 20081                                  	;mov	ah,[es:bp+16h]
 20082                                  	;mov	ah,[es:bp+17h] ; MSDOS 6.0
 20083 000042D4 268A6617                	MOV	AH,[ES:BP+DPB.MEDIA]
 20084                                  	;mov	al,[es:bp+1]
 20085 000042D8 268A4601                	MOV	AL,[ES:BP+DPB.UNIT]
 20086 000042DC 53                      	PUSH	BX
 20087 000042DD 06                      	PUSH	ES
 20088 000042DE E8F60E                  	call	SETWRITE
 20089                                  DODSKOP:
 20090 000042E1 8CD9                    	MOV	CX,DS		; Save DS
 20091 000042E3 1F                      	POP	DS		; DS:BP points to DPB
 20092 000042E4 1E                      	PUSH	DS
 20093                                  	;lds	si,[ds:bp+12h]
 20094                                  	;lds	si,[ds:bp+13h] ; MSDOS 6.0 ; 26/07/2019
 20095 000042E5 3EC57613                	LDS	SI,[ds:BP+DPB.DRIVER_ADDR] ; 07/09/2018
 20096 000042E9 E8460E                  	call	DEVIOCALL2
 20097 000042EC 8ED9                    	MOV	DS,CX		; Restore DS
 20098 000042EE 07                      	POP	ES		; Restore ES
 20099 000042EF 5B                      	POP	BX
 20100                                  
 20101                                  ;hkn; SS override
 20102 000042F0 368B0E[3603]            	MOV	CX,[SS:CALLSCNT] ; Number of sectors transferred
 20103 000042F5 5F                      	POP	DI
 20104 000042F6 29F9                    	SUB	CX,DI
 20105 000042F8 F7D9                    	NEG	CX		; Number of sectors not transferred
 20106                                  
 20107                                  ;hkn; SS override
 20108 000042FA 36A1[2703]              	MOV	AX,[SS:DEVCALL_REQSTAT]
 20109                                  	;test	ax,8000h
 20110 000042FE A90080                  	test	AX,STERR
 20111 00004301 C3                      	retn
 20112                                  
 20113                                  ;Break	<HardErrRW - map extended errors and call harderr>
 20114                                  ;---------------------------------------------------------------------------
 20115                                  ;
 20116                                  ; Procedure Name : HardErrRW
 20117                                  ;
 20118                                  ; Inputs:
 20119                                  ;	AX is error code from read or write
 20120                                  ;	Other registers set as per HARDERR
 20121                                  ; Function:
 20122                                  ;	Checks the error code for special extended
 20123                                  ;	errors and maps them if needed. Then invokes
 20124                                  ;	Harderr
 20125                                  ; Outputs:
 20126                                  ;	Of HARDERR
 20127                                  ; AX may be modified prior to call to HARDERR.
 20128                                  ; No other registers altered.
 20129                                  ;
 20130                                  ;---------------------------------------------------------------------------
 20131                                  
 20132                                  HARDERRRW:
 20133                                  	;cmp	al,0Fh
 20134 00004302 3C0F                    	CMP	AL,error_I24_wrong_disk
 20135 00004304 7512                    	JNZ	short DO_ERR				; Nothing to do
 20136                                  
 20137                                  	; MSDOS 3.3
 20138                                  	;push	ds
 20139                                  	;push	si
 20140                                  	;lds	si,[ss:CALLVIDRW]
 20141                                  	;mov	[ss:EXTERRPT+2], ds
 20142                                  	;mov	[ss:EXTERRPT], si
 20143                                  	;pop	si
 20144                                  	;pop	ds
 20145                                  
 20146                                  	; MSDOS 6.0
 20147 00004306 50                      	push	ax
 20148 00004307 36A1[3A03]              	mov	ax,[SS:CALLVIDRW]		; get ptr lo  ;smr;SS Override
 20149 0000430B 36A3[F402]              	mov	[ss:EXTERRPT],ax		; set ext err ptr lo
 20150 0000430F 36A1[3C03]              	mov	ax,[SS:CALLVIDRW+2]		; get ptr hi from dev
 20151 00004313 36A3[F602]              	mov	[ss:EXTERRPT+2],ax		; set ext err ptr hi
 20152 00004317 58                      	pop	ax
 20153                                  DO_ERR:
 20154 00004318 E80F18                  	call	HARDERR
 20155 0000431B C3                      	retn
 20156                                  
 20157                                  ; 24/07/2018 - Retro DOS v3.0
 20158                                  
 20159                                  ;Break	<SETUP -- SETUP A DISK READ OR WRITE FROM USER>
 20160                                  ;----------------------------------------------------------------------------
 20161                                  ;
 20162                                  ; Procedure Name : SETUP
 20163                                  ;
 20164                                  ; Inputs:
 20165                                  ;	ES:DI point to SFT (value also in THISSFT)
 20166                                  ;	DMAAdd contains transfer address
 20167                                  ;	CX = Byte count
 20168                                  ;	DS = DOSDATA
 20169                                  ;   WARNING Stack must be clean, two ret addrs on stack, 1st of caller,
 20170                                  ;		2nd of caller of caller.
 20171                                  ; Outputs:
 20172                                  ;	    CX = byte count
 20173                                  ;	    [THISDPB] = Base of drive parameters if file
 20174                                  ;		      = Pointer to device header if device or NET
 20175                                  ;	    ES:DI Points to SFT
 20176                                  ;	    [NEXTADD] = Displacement of disk transfer within segment
 20177                                  ;	    [TRANS] = 0 (No transfers yet)
 20178                                  ;	    BytPos = Byte position in file
 20179                                  ;
 20180                                  ;	The following fields are relevant to local files (not devices) only:
 20181                                  ;
 20182                                  ;	    SecPos = Position of first sector (local files only)
 20183                                  ;	    [BYTSECPOS] = Byte position in first sector (local files only)
 20184                                  ;	    [CLUSNUM] = First cluster (local files only)
 20185                                  ;	    [SECCLUSPOS] = Sector within first cluster (local files only)
 20186                                  ;	    [THISDRV] = Physical unit number (local files only)
 20187                                  ;
 20188                                  ;      RETURNS ONE LEVEL UP WITH:
 20189                                  ;	   CX = 0
 20190                                  ;	   CARRY = Clear
 20191                                  ;	IF AN ERROR IS DETECTED
 20192                                  ; All other registers destroyed
 20193                                  ;----------------------------------------------------------------------------
 20194                                  
 20195                                  ;hkn; called from disk.asm. DS has been set up to DOSDATA.
 20196                                  
 20197                                  SETUP:
 20198                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 411Bh
 20199                                  
 20200                                  	;lds 	si,[es:di+7]
 20201 0000431C 26C57507                	LDS	SI,[ES:DI+SF_ENTRY.sf_devptr]
 20202                                  
 20203                                  ;hkn; SS override
 20204 00004320 368C1E[4805]            	MOV	[SS:THISDPB+2],DS
 20205                                  
 20206                                  ;hkn; SS is DOSDATA
 20207 00004325 16                      	push	ss
 20208 00004326 1F                      	pop	ds
 20209                                  
 20210 00004327 8936[4605]              	MOV	[THISDPB],SI
 20211                                  
 20212 0000432B 8B1E[F802]              	MOV	BX,[DMAADD]
 20213 0000432F 891E[7405]              	MOV	[NEXTADD],BX		;Set NEXTADD to start of Xaddr
 20214 00004333 C606[3105]00            	MOV	BYTE [TRANS],0		;No transferes
 20215                                  	;mov	ax,[es:di+15h]
 20216 00004338 268B4515                	MOV	AX,[ES:DI+SF_ENTRY.sf_position]
 20217                                  	;mov	dx,[es:di+17h]
 20218 0000433C 268B5517                	MOV	DX,[ES:DI+SF_ENTRY.sf_position+2]
 20219 00004340 8916[8C05]              	MOV	[BYTPOS+2],DX	;Set it
 20220 00004344 A3[8A05]                	MOV	[BYTPOS],AX
 20221                                  	;test	word [es:di+5],8080h
 20222 00004347 26F745058080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet+devid_device
 20223 0000434D 753C                    	JNZ	short NOSETSTUFF	;Following not done on devs or NET
 20224 0000434F 06                      	PUSH	ES
 20225 00004350 C42E[4605]              	LES	BP,[THISDPB]		;Point at the DPB
 20226                                  	;mov	bl,[es:bp+0]
 20227                                  	;MOV	BL,[ES:BP+DPB.drive]
 20228 00004354 268A5E00                	mov	bl,[es:bp]
 20229 00004358 881E[3305]              	MOV	[THISDRV],BL		;Set THISDRV
 20230                                  	;mov	bx,[es:bp+2]
 20231 0000435C 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 20232                                  
 20233                                  	; 24/07/2019 - Retro DOS v3.2
 20234                                  
 20235                                  	;; MSDOS 3.3
 20236                                  	;cmp	dx,bx
 20237                                  	;jnb	short EOFERR
 20238                                  	;div	bx
 20239                                  	;mov	[SECPOS],ax
 20240                                  	;mov	[BYTSECPOS],dx
 20241                                  	;mov	dx,ax
 20242                                  	;;and	al,[es:bp+4]
 20243                                  	;AND	AL,[ES:BP+DPB.CLUSTER_MASK]
 20244                                  	;mov	[SECCLUSPOS],al
 20245                                  	;mov	ax,cx
 20246                                  	;;mov	cl,[es:bp+5]
 20247                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 20248                                  	;shr	dx,cl
 20249                                  	;mov	[CLUSNUM],dx
 20250                                  	;pop	es
 20251                                  	;mov	cx,ax
 20252                                  
 20253                                  	; 04/05/2019 - Retro DOS v4.0
 20254                                  
 20255                                  	; MSDOS 6.0
 20256                                  ;M039: Optimized this section.
 20257 00004360 51                              PUSH    CX			;SHR32 and DIV32 use CX.
 20258 00004361 E8E104                  	call	DIV32			;DX:AX/BX = CX:AX + DX (rem)
 20259 00004364 8916[8805]              	MOV	[BYTSECPOS],DX
 20260 00004368 A3[8005]                	MOV	[SECPOS],AX
 20261 0000436B 890E[8205]              	MOV	[SECPOS+2],CX
 20262 0000436F 89CA                    	MOV	DX,CX
 20263                                  
 20264 00004371 89C3                    	MOV	BX,AX
 20265                                  	;and	bl,[es:bp+4]
 20266 00004373 26225E04                	AND	BL,[ES:BP+DPB.CLUSTER_MASK]
 20267 00004377 881E[3005]              	MOV	[SECCLUSPOS],BL
 20268                                  
 20269 0000437B E8EE04                  	call	SHR32			;(DX:AX SHR dpb_cluster_shift)
 20270 0000437E 59                      	POP	CX			;CX = byte count.
 20271 0000437F 751F                    	JNZ	short EOFERR		;cluster number above 64k
 20272                                  	;cmp	ax,[es:bp+0Dh]
 20273 00004381 263B460D                	CMP	AX,[ES:BP+DPB.MAX_CLUSTER] ;>32mb  if > disk size ;AN000;
 20274 00004385 7719                    	JA	short EOFERR		   ;>32mb  then EOF       ;AN000;
 20275                                  
 20276 00004387 A3[7805]                	MOV	[CLUSNUM],AX
 20277 0000438A 07                      	POP	ES			; ES:DI point to SFT
 20278                                  ;M039
 20279                                  
 20280                                  NOSETSTUFF:
 20281 0000438B 89C8                    	MOV	AX,CX		; AX = Byte count.
 20282 0000438D 0306[F802]              	ADD	AX,[DMAADD]	 ; See if it will fit in one segment
 20283 00004391 730C                    	JNC	short setup_OK		; Must be less than 64K
 20284 00004393 A1[F802]                	MOV	AX,[DMAADD]
 20285 00004396 F7D8                    	NEG	AX		; Amount of room left in segment (know
 20286                                  				;    less than 64K since max value of CX
 20287                                  				;    is FFFF).
 20288 00004398 7501                    	JNZ	short NoDec
 20289 0000439A 48                      	DEC	AX
 20290                                  NoDec:
 20291 0000439B 89C1                    	MOV	CX,AX		; Can do this much
 20292 0000439D E304                    	JCXZ	NOROOM		; Silly user gave Xaddr of FFFF in segment
 20293                                  setup_OK:
 20294 0000439F C3                      	retn
 20295                                  
 20296                                  EOFERR:
 20297 000043A0 07                      	POP	ES		; ES:DI point to SFT
 20298 000043A1 31C9                    	XOR	CX,CX		; No bytes read
 20299                                  ;;;;;;;;;;; 7/18/86
 20300                                  	; 24/07/2019 - Retro DOS v3.2
 20301                                  	; MSDOS 3.3
 20302                                  	;MOV	BYTE [DISK_FULL],1 ; set disk full flag
 20303                                  ;;;;;;;;;;;
 20304                                  NOROOM:
 20305 000043A3 5B                      	POP	BX		; Kill return address
 20306 000043A4 F8                      	CLC
 20307 000043A5 C3                      	retn			; RETURN TO CALLER OF CALLER
 20308                                  
 20309                                  ;Break	<BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES>
 20310                                  ;---------------------------------------------------------------------------
 20311                                  ;
 20312                                  ; Procedure Name : BREAKDOWN
 20313                                  ;
 20314                                  ; Inputs:
 20315                                  ;	CX = Length of disk transfer in bytes
 20316                                  ;	ES:BP = Base of drive parameters
 20317                                  ;	[BYTSECPOS] = Byte position within first sector
 20318                                  ;	DS = DOSDATA
 20319                                  ; Outputs:
 20320                                  ;	[BYTCNT1] = Bytes to transfer in first sector
 20321                                  ;	[SECCNT] = No. of whole sectors to transfer
 20322                                  ;	[BYTCNT2] = Bytes to transfer in last sector
 20323                                  ; AX, BX, DX destroyed. No other registers affected.
 20324                                  ;---------------------------------------------------------------------------
 20325                                  
 20326                                  BREAKDOWN:
 20327 000043A6 A1[8805]                	MOV	AX,[BYTSECPOS]
 20328 000043A9 89CB                    	MOV	BX,CX
 20329 000043AB 09C0                    	OR	AX,AX
 20330 000043AD 740E                    	JZ	short SAVFIR	; Partial first sector?
 20331                                  	;sub	ax,[es:bp+2]
 20332 000043AF 262B4602                	SUB	AX,[ES:BP+DPB.SECTOR_SIZE]
 20333 000043B3 F7D8                    	NEG	AX		; Max number of bytes left in first sector
 20334 000043B5 29C3                    	SUB	BX,AX		; Subtract from total length
 20335 000043B7 7304                    	JAE	short SAVFIR
 20336 000043B9 01D8                    	ADD	AX,BX		; Don't use all of the rest of the sector
 20337 000043BB 31DB                    	XOR	BX,BX		; And no bytes are left
 20338                                  SAVFIR:
 20339 000043BD A3[8E05]                	MOV	[BYTCNT1],AX
 20340 000043C0 89D8                    	MOV	AX,BX
 20341 000043C2 31D2                    	XOR	DX,DX
 20342                                  	;div	word [ES:BP+2]
 20343 000043C4 26F77602                	DIV	word [ES:BP+DPB.SECTOR_SIZE]  ; How many whole sectors?
 20344 000043C8 A3[9205]                	MOV	[SECCNT],AX
 20345 000043CB 8916[9005]              	MOV	[BYTCNT2],DX	; Bytes remaining for last sector
 20346                                  	; MSDOS 3.3
 20347                                  ;	OR	DX,[BYTCNT1]	; SMR ONESECTORFIX BUGBUG
 20348                                  ;	retnz			; NOT (BYTCNT1 = BYTCNT2 = 0)
 20349                                  ;	CMP	AX,1
 20350                                  ;	retnz
 20351                                  ;	MOV	AX,[ES:BP+DPB.SECTOR_SIZE] ; Buffer EXACT one sector I/O
 20352                                  ;	MOV	[BYTCNT2],AX
 20353                                  ;	MOV	[SECCNT],DX	; DX = 0
 20354                                  _RET45:
 20355 000043CF C3                      	retn
 20356                                  
 20357                                  ;----------------------------------------------------------------------------
 20358                                  ;
 20359                                  ; Procedure Name : READ_LOCK_VIOLATION
 20360                                  ;
 20361                                  ; ES:DI points to SFT. This entry used by NET_READ
 20362                                  ; Carry set if to return error (CX=0,AX=error_sharing_violation).
 20363                                  ; Else do retrys.
 20364                                  ; ES:DI,DS,CX preserved
 20365                                  ;
 20366                                  ;----------------------------------------------------------------------------
 20367                                  
 20368                                  READ_LOCK_VIOLATION:
 20369 000043D0 C606[3205]00            	MOV	byte [READOP],0
 20370                                  ERR_ON_CHECK:
 20371                                  	;test	word [es:di+2],8000h
 20372 000043D5 26F745020080            	TEST	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 20373 000043DB 750E                    	JNZ	short HARD_ERR
 20374 000043DD 51                      	PUSH	CX
 20375 000043DE 268A4D02                	MOV	CL,[ES:DI+SF_ENTRY.sf_mode]
 20376                                  	;and	cl,0F0h
 20377 000043E2 80E1F0                  	AND	CL,SHARING_MASK
 20378                                  	;cmp	cl,0
 20379 000043E5 80F900                  	CMP	CL,SHARING_COMPAT
 20380 000043E8 59                      	POP	CX
 20381 000043E9 7505                    	JNE	short NO_HARD_ERR
 20382                                  HARD_ERR:
 20383 000043EB E85232                  	call	LOCK_VIOLATION
 20384 000043EE 73DF                    	jnc	short _RET45		; User wants Retrys
 20385                                  NO_HARD_ERR:
 20386 000043F0 31C9                    	XOR	CX,CX			;No bytes transferred
 20387                                  	;mov	ax,21h
 20388 000043F2 B82100                  	MOV	AX,error_lock_violation
 20389 000043F5 F9                      	STC
 20390 000043F6 C3                      	retn
 20391                                  
 20392                                  ;----------------------------------------------------------------------------
 20393                                  ;
 20394                                  ; Procedure Name : WRITE_LOCK_VIOLATION
 20395                                  ;
 20396                                  ; Same as READ_LOCK_VIOLATION except for READOP.
 20397                                  ; This entry used by NET_WRITE
 20398                                  ;
 20399                                  ;----------------------------------------------------------------------------
 20400                                  
 20401                                  WRITE_LOCK_VIOLATION:
 20402 000043F7 C606[3205]01            	MOV	byte [READOP],1
 20403 000043FC EBD7                    	JMP	short ERR_ON_CHECK
 20404                                  
 20405                                  ; 22/07/2019 - Retro DOS v3.2
 20406                                  
 20407                                  ;Break	<DISKREAD -- PERFORM USER DISK READ>
 20408                                  ;----------------------------------------------------------------------------
 20409                                  ;
 20410                                  ; Procedure Name : DISKREAD
 20411                                  ;
 20412                                  ; Inputs:
 20413                                  ;	Outputs of SETUP
 20414                                  ; Function:
 20415                                  ;	Perform disk read
 20416                                  ; Outputs:
 20417                                  ;    Carry clear
 20418                                  ;	CX = No. of bytes read
 20419                                  ;	ES:DI point to SFT
 20420                                  ;	SFT offset and cluster pointers updated
 20421                                  ;    Carry set
 20422                                  ;	CX = 0
 20423                                  ;	ES:DI point to SFT
 20424                                  ;	AX has error code
 20425                                  ;----------------------------------------------------------------------------
 20426                                  
 20427                                  ;hkn; called from disk.asm. DS already set up.
 20428                                  
 20429                                  DISKREAD:
 20430                                  	;mov	ax,[es:di+11h]
 20431 000043FE 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]
 20432                                  	;mov	bx,[es:di+13h]
 20433 00004402 268B5D13                	MOV	BX,[ES:DI+SF_ENTRY.sf_size+2]
 20434 00004406 2B06[8A05]              	SUB	AX,[BYTPOS]
 20435 0000440A 1B1E[8C05]              	SBB	BX,[BYTPOS+2]
 20436 0000440E 7226                    	JB	short RDERR		;Read starts past EOF
 20437 00004410 750A                    	JNZ	short ENUF		;More than 64k to EOF
 20438 00004412 09C0                    	OR	AX,AX
 20439 00004414 7420                    	JZ	short RDERR		;Read starts at EOF
 20440 00004416 39C8                    	CMP	AX,CX
 20441 00004418 7302                    	JAE	short ENUF		;I/O fits
 20442 0000441A 89C1                    	MOV	CX,AX			;Limit read to up til EOF
 20443                                  ENUF:
 20444                                  	; MSDOS 3.3
 20445                                  	;test	byte [es:di+4],8
 20446                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 20447                                  	;jnz	short SET_ACC_ERR
 20448                                  	;call	LOCK_CHECK
 20449                                  	;jnb	short _READ_OK
 20450                                  	;call	READ_LOCK_VIOLATION
 20451                                  	;jnb	short ENUF
 20452                                  	;retn
 20453                                  
 20454                                  	; MSDOS 6.0
 20455 0000441C E874FE                  	call	CHECK_READ_LOCK		;IFS. check read lock	;AN000;
 20456 0000441F 7301                    	JNC	short _READ_OK 		; There are no locks
 20457 00004421 C3                      	retn
 20458                                  
 20459                                  _READ_OK:
 20460 00004422 C42E[4605]              	LES	BP,[THISDPB]
 20461 00004426 E87DFF                  	CALL	BREAKDOWN
 20462 00004429 8B0E[7805]              	MOV	CX,[CLUSNUM]
 20463 0000442D E82A11                  	call	FNDCLUS
 20464                                       	; MSDOS 6.0			;M022 conditional removed here
 20465 00004430 720E                    	JC	short SET_ACC_ERR_DS	; fix to take care of I24 fail
 20466                                  					; migrated from 330a - HKN
 20467 00004432 09C9                    	OR	CX,CX
 20468 00004434 7413                    	JZ	short SKIPERR
 20469                                  RDERR:
 20470 00004436 B40E                    	MOV	AH,0EH			;MS. read/data/fail ;AN000;
 20471 00004438 E90502                  	jmp	WRTERR22
 20472                                  
 20473                                  ;RDLASTJ: 
 20474                                  	;JMP	RDLAST                  ;M039
 20475                                  
 20476                                  SETSFTJ2: 
 20477 0000443B E90001                  	JMP	SETSFT
 20478                                  
 20479                                  CANOT_READ:
 20480                                  	; 22/07/2019 - Retro DOS v3.2
 20481                                  	; MSDOS 3.3
 20482                                  	;POP	CX		;M039.
 20483                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20484 0000443E 59                      	POP	CX              ;Clean stack.
 20485 0000443F 5B                      	POP	BX
 20486                                  
 20487                                  	;entry	SET_ACC_ERR_DS
 20488                                  SET_ACC_ERR_DS:
 20489                                  ;hkn; SS is DOSDATA
 20490                                  	;Context DS
 20491 00004440 16                      	push	ss
 20492 00004441 1F                      	pop	ds
 20493                                  
 20494                                  	;entry	SET_ACC_ERR
 20495                                  SET_ACC_ERR:
 20496 00004442 31C9                    	XOR	CX,CX
 20497                                  	;mov	ax,5
 20498 00004444 B80500                  	MOV	AX,error_access_denied
 20499 00004447 F9                      	STC
 20500 00004448 C3                      	retn
 20501                                  
 20502                                  SKIPERR:
 20503 00004449 8916[7605]              	MOV	[LASTPOS],DX
 20504 0000444D 891E[7805]              	MOV	[CLUSNUM],BX
 20505 00004451 833E[8E05]00            	CMP	word [BYTCNT1],0
 20506 00004456 7405                    	JZ	short RDMID
 20507                                  
 20508 00004458 E87511                  	call	BUFRD
 20509 0000445B 72E3                    	JC	short SET_ACC_ERR_DS
 20510                                  RDMID:
 20511 0000445D 833E[9205]00            	CMP	word [SECCNT],0
 20512 00004462 0F84BB00                	JZ	RDLAST ; 24/07/2019
 20513                                  
 20514 00004466 E8FA11                  	call	NEXTSEC
 20515 00004469 72D0                    	JC	short SETSFTJ2
 20516                                  
 20517 0000446B C606[3105]01            	MOV	BYTE [TRANS],1		; A transfer is taking place
 20518                                  ONSEC:
 20519 00004470 8A16[3005]              	MOV	DL,[SECCLUSPOS]	; (dx/DL = Extent start) ((dh = ?))
 20520 00004474 8B0E[9205]              	MOV	CX,[SECCNT]
 20521 00004478 8B1E[7805]              	MOV	BX,[CLUSNUM]
 20522                                  RDLP:
 20523 0000447C E81512                  	call	OPTIMIZE
 20524 0000447F 72BF                    	JC	short SET_ACC_ERR_DS
 20525                                  
 20526 00004481 57                      	PUSH	DI ; *****              ;DI = Next physical cluster.
 20527 00004482 50                      	PUSH	AX ; ****               ;AX = # of sectors remaining.
 20528 00004483 53                      	PUSH	BX ; ***		;[DMAADD+2]:BX = Transfer address.
 20529                                  	;mov	byte [ALLOWED],38h
 20530 00004484 C606[1503]38            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 20531 00004489 8E1E[FA02]              	MOV	DS,[DMAADD+2]
 20532                                  
 20533 0000448D 52                      	PUSH	DX ; **                 ;[HIGH_SECTOR]:DX = phys. sector #.
 20534 0000448E 51                      	PUSH	CX ; *                  ;CX = # of contiguous sectors to read.
 20535                                  
 20536                                  	; MSDOS 6.0
 20537                                  	;call	SET_RQ_SC_PARMS 	 ;LB. do this for SC ;AN000;
 20538                                  
 20539                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20540 0000448F E8C8FD                  	call	DREAD
 20541                                  
 20542                                  	; 22/07/2019 - Retro DOS v3.2
 20543                                  
 20544                                  	; MSDOS 6.0 
 20545 00004492 59                      	pop	cx ; *
 20546 00004493 5A                      	pop	dx ; **
 20547 00004494 2E8F06[B205]            	pop	WORD [cs:TEMP_VAR] ; *** ; pop word [ss:TEMP_VAR]
 20548 00004499 72A3                    	jc	short CANOT_READ
 20549                                  
 20550 0000449B 2E8C1E[B405]            	mov	[cs:TEMP_VAR2],ds  ; mov [ss:TEMP_VAR2],ds
 20551                                  
 20552                                  	; MSDOS 3.3 
 20553                                  	;pop	bx ; *
 20554                                  	;pop	dx ; **
 20555                                  	;jc	short CANOT_READ
 20556                                  	;add	bx,dx	; (bx = Extent end)
 20557                                  	
 20558 000044A0 268A4600                	mov	al,[es:bp] ; mov al,[es:bp+0]
 20559                                  	;mov	al,[ES:BP+DPB.DRIVE] 
 20560 000044A4 E8191C                  	call	SETVISIT
 20561                                  		; DS:DI = [BUFFHEAD] ; 22/07/2019
 20562                                  	; ->***
 20563                                  ;M039
 20564                                  	; MSDOS 6.0 
 20565                                  	;pop	cx ; *
 20566                                  	;pop	dx ; **
 20567                                  	;pop	WORD [ss:TEMP_VAR] ; ***
 20568                                  	;jc	short CANOT_READ
 20569                                  
 20570                                  	;mov	[ss:TEMP_VAR2],ds
 20571                                  
 20572                                  ;       CX = # of contiguous sectors read. (These constitute a block of
 20573                                  ;            sectors, also termed an "Extent".)
 20574                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 20575                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 20576                                  ;       ES:BP -> Drive Parameter Block (DPB).
 20577                                  ;
 20578                                  ;	The Buffer Queue must now be scanned: the contents of any dirty
 20579                                  ;	buffers must be "read" into the transfer memory block, so that the
 20580                                  ;       transfer memory reflects the most recent data.
 20581                                  
 20582                                  	;call    DskRdBufScan
 20583                                  
 20584                                  	;;Context DS
 20585                                  	;push	ss
 20586                                  	;pop	ds
 20587                                          
 20588                                  	;pop	cx ; ****
 20589                                          ;pop	bx ; *****
 20590                                  
 20591                                  ;       CX = # of sector remaining.
 20592                                  ;       BX = Next physical cluster.
 20593                                  ;M039
 20594                                  	; 25/07/2018 - Retro DOS v3.0
 20595                                  	; ***->
 20596                                  	; MSDOS 3.3
 20597                                  	; IBMDOS.COM (1987) - Offset 42BDh
 20598                                  bufq:
 20599                                  	; (MSDOS 3.3)
 20600                                  ;;	DX = Extent start.
 20601                                  ;;	BX = Extent end.
 20602                                  ;;      AL = Drive #.
 20603                                  ;;   DS:DI-> 1st buffer in queue.
 20604                                  	
 20605                                  	; 22/07/2019 - Retro DOS v3.2
 20606                                  	; (MSDOS 6.0, 'DskRdBufScan') 
 20607                                  
 20608 000044A7 2E8B1E[B005]            	mov     bx,[cs:HIGH_SECTOR]  ; mov bx,[ss:HIGH_SECTOR]
 20609 000044AC 89DE                    	mov     si,bx
 20610 000044AE 01D1                    	add     cx,dx
 20611 000044B0 83D600                  	adc     si,0
 20612                                  	
 20613                                  	; (MSDOS 6.0)
 20614                                  ;       BX:DX = Extent start.
 20615                                  ;       SI:CX = Extent end + 1.
 20616                                  ;          AL = Drive #.
 20617                                  ;       DS:DI-> 1st buffer in queue.
 20618                                  ;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 20619                                  
 20620                                  	;or	byte [di+5],20h
 20621 000044B3 804D0520                	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 20622                                  
 20623                                  	; 22/07/2019 - Retro DOS v3.2
 20624                                  
 20625                                  	;cmp	al,[di+4]	
 20626 000044B7 3A4504                  	cmp	al,[DI+BUFFINFO.buf_ID]	;Same drive?
 20627 000044BA 754C                    	jne	short bufq3		;  -no, jump.
 20628                                  				;Jump if Extent start > buffer sector.
 20629                                  	;cmp	bx,[di+8]
 20630 000044BC 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 20631 000044BF 7503                    	jne	short bufq01
 20632                                  	;cmp	dx,[di+6]
 20633 000044C1 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 20634                                  bufq01:
 20635 000044C4 7742                    	ja	short bufq3
 20636                                  				;Jump if Extent end <= buffer sector.
 20637                                  	;cmp	si,[di+8]
 20638 000044C6 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 20639 000044C9 7503                    	jne	short bufq02
 20640                                  	;cmp	cx,[di+6]
 20641 000044CB 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 20642                                  bufq02:
 20643 000044CE 7638                    	jna	short bufq3
 20644                                  
 20645                                  ;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 20646                                  ;	transfer memory; otherwise, just re-position it in the buffer queue
 20647                                  ;       as MRU (Most Recently Used).
 20648                                  
 20649                                  	;test	byte [di+5],40h
 20650 000044D0 F6450540                	test	byte [DI+BUFFINFO.buf_flags],buf_dirty ; Bit 6 = dirty flag
 20651 000044D4 742F                    	jz	short bufq2	; clear buffer, check the next buff sec
 20652                                  
 20653                                  	; 27/07/2019
 20654                                  	; MSDOS 6.0
 20655 000044D6 50                      	push	ax ; (drive number) ; 22/07/2019
 20656                                  
 20657                                  	; 22/07/2019 - Retro DOS v3.2
 20658                                  
 20659                                  	; MSDOS 3.3
 20660                                  	;pop	ax ; transfer address
 20661                                  	;push	ax
 20662                                  	;push	di
 20663                                  	;push	dx
 20664                                  	;;sub	dx,[di+6]
 20665                                  	;sub	dx,[DI+BUFFINFO.buf_sector]
 20666                                  	;neg	dx
 20667                                  
 20668                                  ;;      DX = offset (in sectors) of buffer sector within Transfer memory
 20669                                  ;;           block.
 20670                                  
 20671                                  	; MSDOS 6.0
 20672 000044D7 51                      	push	cx
 20673 000044D8 52                      	push	dx
 20674 000044D9 56                      	push	si
 20675 000044DA 57                      	push	di
 20676 000044DB 06                      	push	es
 20677                                  
 20678 000044DC 89D0                    	mov     ax,dx
 20679                                  	;sub	ax,[di+6]
 20680 000044DE 2B4506                  	sub	ax,[di+BUFFINFO.buf_sector]
 20681 000044E1 F7D8                    	neg	ax
 20682                                  
 20683                                  ;       AX = offset (in sectors) of buffer sector within Transfer memory
 20684                                  ;            block. (Note: the upper word of the sector # may be ignored
 20685                                  ;	     since no more than 64k bytes will ever be read. This 64k limit
 20686                                  ;            is imposed by the input parameters of the disk read operation.)
 20687                                  
 20688                                  	; MSDOS 3.3
 20689                                  	;mov	si,di
 20690                                  	;mov	di,ax
 20691                                  	;mov	ax,dx
 20692                                  	;;mov	cx,[es:bp+6]	
 20693                                  	;mov	cx,[ES:BP+DPB.SECTOR_SIZE] ; CX = sector size (in bytes).
 20694                                  	;mul	cx
 20695                                  	;add	di,ax
 20696                                  
 20697                                  	; 22/07/2019 - Retro DOS v3.2
 20698                                  
 20699                                  	; MSDOS 3.3
 20700                                  	;lea	si,[si+16] ; MSDOS 3.3
 20701                                  	;lea	si,[SI+BUFINSIZ] ;DS:SI -> buffer data.
 20702                                   	;shr	cx,1
 20703                                  	;push	es
 20704                                  	;mov	es,[SS:DMAADD+2]
 20705                                  
 20706                                  	; MSDOS 6.0
 20707                                  	;lea	si,[di+20]
 20708 000044E3 8D7514                  	lea	si,[di+BUFINSIZ]	;DS:SI -> buffer data.
 20709                                  	;mov	cx,[es:bp+2]
 20710 000044E6 268B4E02                	mov     cx,[es:bp+DPB.SECTOR_SIZE] ;CX = sector size (in bytes).
 20711 000044EA F7E1                    	mul     cx			;AX = offset (in bytes) of buf. sector
 20712                                  	;mov	di,[ss:TEMP_VAR]
 20713 000044EC 2E8B3E[B205]            	mov	di,[cs:TEMP_VAR] ; 22/07/2019
 20714 000044F1 01C7                    	add	di,ax
 20715                                  	;mov	es,[ss:TEMP_VAR2]
 20716 000044F3 2E8E06[B405]            	mov	es,[cs:TEMP_VAR2] ; 22/07/2019
 20717 000044F8 D1E9                    	shr	cx,1
 20718                                  
 20719                                  ;	   CX = sector size (in WORDs) ; CF=1 if odd # of bytes.
 20720                                  ;       DS:SI-> Buffer sector data.
 20721                                  ;       ES:DI-> Destination within Transfer memory block.
 20722                                  
 20723 000044FA F3A5                    	rep	movsw			;Copy buffer sector to Transfer memory
 20724                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 20725                                  	;rep	movsb                   ;Copy last byte.
 20726 000044FC 7301                    	jnc	short bufq1
 20727 000044FE A4                      	movsb
 20728                                  bufq1:
 20729                                  	; MSDOS 3.3
 20730                                  	;pop	es
 20731                                  	;pop	dx
 20732                                  	;pop	di
 20733                                  
 20734                                  	; 22/07/2019 - Retro DOS v3.2
 20735                                  
 20736                                  	; MSDOS 6.0
 20737 000044FF 07                      	pop	es
 20738 00004500 5F                      	pop	di
 20739 00004501 5E                      	pop	si
 20740 00004502 5A                      	pop	dx
 20741 00004503 59                      	pop	cx
 20742                                  
 20743                                  ;       DS:DI -> current buffer.
 20744                                  
 20745                                  	; MSDOS 3.3
 20746                                  	;mov	al,[es:bp]  ; mov al,[es:bp+0]
 20747                                  	;;mov	al,[ES:BP+DPB.DRIVE]
 20748                                  	
 20749                                  	; MSDOS 6.0
 20750 00004504 58                      	pop	ax ; (drive number) ; 22/07/2019
 20751                                  bufq2:
 20752                                  	; MSDOS 3.3
 20753 00004505 E8E51B                  	call	SCANPLACE
 20754                                  bufq3:
 20755                                  	; AL = drive number ; 27/07/2019
 20756                                  	; MSDOS 3.3
 20757 00004508 E8CE1B                  	call	SKIPVISIT
 20758 0000450B 759A                    	jnz	short bufq
 20759                                  	
 20760                                  	; 22/07/2019
 20761                                  
 20762                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20763                                  	;push	ss
 20764 0000450D 0E                      	push	cs
 20765 0000450E 1F                      	pop	ds
 20766                                  	
 20767                                  	; MSDOS 3.3
 20768                                  	;pop	cx ; ***
 20769                                  	;pop	cx ; ****
 20770                                  	;pop	bx ; *****
 20771                                  
 20772                                  	; MSDOS 6.0
 20773 0000450F 59                      	pop	cx ; ****
 20774 00004510 5B                              pop	bx ; *****
 20775                                  
 20776                                  ;       CX = # of sector remaining.
 20777                                  ;       BX = Next physical cluster.	
 20778                                  bufq4:
 20779 00004511 E30E                    	JCXZ	RDLAST
 20780 00004513 E80218                  	call	IsEOF			; test for eof on fat size
 20781 00004516 7326                    	JAE	short SETSFT
 20782 00004518 B200                    	MOV	DL,0
 20783 0000451A FF06[7605]              	INC	word [LASTPOS]		; We'll be using next cluster
 20784 0000451E E95BFF                  	JMP	RDLP
 20785                                  
 20786                                  RDLAST:
 20787 00004521 A1[9005]                	MOV	AX,[BYTCNT2]
 20788 00004524 09C0                    	OR	AX,AX
 20789 00004526 7416                    	JZ	short SETSFT
 20790 00004528 A3[8E05]                	MOV	[BYTCNT1],AX
 20791 0000452B E83511                  	call	NEXTSEC
 20792 0000452E 720E                    	JC	short SETSFT
 20793 00004530 C706[8805]0000          	MOV	word [BYTSECPOS],0
 20794 00004536 E89710                  	call	BUFRD
 20795                                  	; 10/08/2018
 20796 00004539 7303                    	JNC	short SETSFT
 20797 0000453B E902FF                  	JMP	SET_ACC_ERR_DS
 20798                                  
 20799                                  ;------------------------------------------------------------------------------
 20800                                  ;
 20801                                  ; Procedure Name : SETSFT
 20802                                  ; Inputs:
 20803                                  ;	[NEXTADD],[CLUSNUM],[LASTPOS] set to determine transfer size
 20804                                  ;		and set cluster fields
 20805                                  ; Function:
 20806                                  ;	Update [THISSFT] based on the transfer
 20807                                  ; Outputs:
 20808                                  ;	sf_position, sf_lstclus, and sf_cluspos updated
 20809                                  ;	ES:DI points to [THISSFT]
 20810                                  ;	CX No. of bytes transferred
 20811                                  ;	Carry clear
 20812                                  ;
 20813                                  ;----------------------------------------------------------------------------
 20814                                  
 20815                                  	;entry	SETSFT
 20816                                  
 20817                                  ; 26/07/2018 - Retro DOS v3.0
 20818                                  SETSFT:
 20819 0000453E C43E[5A05]              	LES	DI,[THISSFT]
 20820                                  
 20821                                  ; Same as SETSFT except ES:DI already points to SFT
 20822                                  	;entry	SETCLUS
 20823                                  SETCLUS:	
 20824 00004542 8B0E[7405]              	MOV	CX,[NEXTADD]
 20825 00004546 2B0E[F802]              	SUB	CX,[DMAADD]		; Number of bytes transfered
 20826                                  	;test	word [es:di+5],80h
 20827                                  	;TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 20828                                  	; 27/07/2019 - Retro DOS v3.2
 20829 0000454A 26F6450580              	TEST	byte [ES:DI+SF_ENTRY.sf_flags],devid_device
 20830 0000454F 750E                    	JNZ	short ADDREC		; don't set clusters if device
 20831 00004551 A1[7805]                	MOV	AX,[CLUSNUM]
 20832                                  	;mov	[es:di+1Bh],ax
 20833                                  	;mov	[es:di+35h],ax ; MSDOS 6.0
 20834 00004554 26894535                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX
 20835 00004558 A1[7605]                	MOV	AX,[LASTPOS]
 20836                                  	;mov	[es:di+19h],ax
 20837 0000455B 26894519                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],AX
 20838                                  
 20839                                  ;----------------------------------------------------------------------------
 20840                                  ;
 20841                                  ; Procedure : AddRec
 20842                                  ; Inputs:
 20843                                  ;	ES:DI points to SFT
 20844                                  ;	CX is No. Bytes transferred
 20845                                  ; Function:
 20846                                  ;	Update the SFT offset based on the transfer
 20847                                  ; Outputs:
 20848                                  ;	sf_position updated to point to first byte after transfer
 20849                                  ;	ES:DI points to SFT
 20850                                  ;	CX No. of bytes transferred
 20851                                  ;	Carry clear
 20852                                  ;----------------------------------------------------------------------------
 20853                                  
 20854                                  	;entry	AddRec
 20855                                  ADDREC:
 20856 0000455F E309                    	JCXZ	RET28		; If no records read,  don't change position
 20857                                  	;add	[es:di+15h],cx
 20858 00004561 26014D15                	ADD	[ES:DI+SF_ENTRY.sf_position],CX  ; Update current position
 20859                                  	;adc	word [es:di+17h], 0
 20860 00004565 2683551700              	ADC	WORD [ES:DI+SF_ENTRY.sf_position+2],0
 20861                                  RET28:	
 20862 0000456A F8                      	CLC
 20863 0000456B C3                      	retn
 20864                                  
 20865                                  ; 25/07/2018
 20866                                  ; MSDOS 6.0
 20867                                  ;Break   <DskRdBufScan -- Disk Read Buffer Scan>
 20868                                  ;----------------------------------------------------------------------------
 20869                                  ;
 20870                                  ; Procedure Name : DskRdBufScan
 20871                                  ;
 20872                                  ; Inputs:
 20873                                  ;       CX = # of contiguous sectors read.  (These constitute a block of
 20874                                  ;            sectors, also termed an "Extent".)
 20875                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 20876                                  ;       [TEMP_VAR2]:[TEMP_VAR] = Transfer address (destination data address).
 20877                                  ;       ES:BP -> Drive Parameter Block (DPB).
 20878                                  ;
 20879                                  ; Function:
 20880                                  ;	The Buffer Queue is scanned: the contents of any dirty buffers are
 20881                                  ;	"read" into the transfer memory block, so that the transfer memory
 20882                                  ;	reflects the most recent data.
 20883                                  ;
 20884                                  ; Outputs:
 20885                                  ;       Transfer memory updated as required.
 20886                                  ;
 20887                                  ; Uses:
 20888                                  ;       DS,AX,BX,CX,SI,DI destroyed.
 20889                                  ;       SS override for all global variables.
 20890                                  ;
 20891                                  ; Notes:
 20892                                  ;       FIRST_BUFF_ADDR is set-up to contain the LAST buffer to check, rather
 20893                                  ;	than the FIRST.
 20894                                  ;----------------------------------------------------------------------------
 20895                                  ;M039: Created
 20896                                  
 20897                                  ;procedure   DskRdBufScan,NEAR
 20898                                  ;
 20899                                  ;ASSUME  DS:NOTHING
 20900                                  ;
 20901                                  ;	cmp	[DirtyBufferCount],0	;Any dirty buffers?
 20902                                  ;	je	bufx			; -no, skip all work.
 20903                                  ;
 20904                                  ;       mov     bx,[HIGH_SECTOR]
 20905                                  ;       mov     si,bx
 20906                                  ;       add     cx,dx
 20907                                  ;       adc     si,0
 20908                                  ;
 20909                                  ;	call	GETCURHEAD		;DS:DI -> 1st buf in queue.
 20910                                  ;       mov     ax,[di].buf_prev
 20911                                  ;       mov     [FIRST_BUFF_ADDR],ax
 20912                                  ;
 20913                                  ;       Assert  ISDPB,<ES,BP>,"DISKREAD/bufchk"
 20914                                  ;	mov	al,es:[bp].dpb_drive
 20915                                  ;
 20916                                  ;;            BX:DX = Extent start.
 20917                                  ;;            SI:CX = Extent end + 1.
 20918                                  ;;               AL = Drive #.
 20919                                  ;;            DS:DI-> 1st buffer in queue.
 20920                                  ;;[FIRST_BUFF_ADDR] = Address offset of last buffer in queue.
 20921                                  ;
 20922                                  ;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
 20923                                  ;	jne     bufq1        		;  -no, jump.
 20924                                  ;
 20925                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20926                                  ;       ja	bufq1			;Jump if Extent start > buffer sector.
 20927                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 20928                                  ;       ja	bufq2                   ;Jump if Extent end >= buffer sector.
 20929                                  ;
 20930                                  ;bufq1:	cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
 20931                                  ;       mov     di,[di].buf_next        ; Set-up for next buffer.
 20932                                  ;       jne     bufq                    ; -no, do next buffer
 20933                                  ;
 20934                                  ;bufx:   return                          ;Exit.
 20935                                  ;
 20936                                  ;;       Buffer's sector is in Extent: if it is dirty, copy its contents to
 20937                                  ;;	transfer memory; otherwise, just re-position it in the buffer queue
 20938                                  ;;       as MRU (Most Recently Used).
 20939                                  ;
 20940                                  ;bufq2:	SaveReg <ax>
 20941                                  ;	testb   [di.buf_flags],buf_dirty ;Buffer dirty?
 20942                                  ;	jz      bufq3                    ; -no, jump.
 20943                                  ;
 20944                                  ;        SaveReg <cx,dx,si,di,es>
 20945                                  ;
 20946                                  ;	mov     ax,dx
 20947                                  ;	sub	ax, word ptr [di].buf_sector
 20948                                  ;	neg	ax
 20949                                  ;
 20950                                  ;;       AX = offset (in sectors) of buffer sector within Transfer memory
 20951                                  ;;            block. (Note: the upper word of the sector # may be ignored
 20952                                  ;;	     since no more than 64k bytes will ever be read. This 64k limit
 20953                                  ;;            is imposed by the input parameters of the disk read operation.)
 20954                                  ;
 20955                                  ;	lea	si,[di].BUFINSIZ	;DS:SI -> buffer data.
 20956                                  ;	mov     cx,es:[bp].dpb_sector_size ;CX = sector size (in bytes).
 20957                                  ;	mul     cx			;AX = offset (in bytes) of buf. sector
 20958                                  ;	mov     di,WORD PTR [TEMP_VAR]
 20959                                  ;	add	di,ax
 20960                                  ;	mov	es,WORD PTR [TEMP_VAR2]
 20961                                  ;	shr	cx,1
 20962                                  ;
 20963                                  ;;	   CX = sector size (in WORDs); CF=1 if odd # of bytes.
 20964                                  ;;       DS:SI-> Buffer sector data.
 20965                                  ;;       ES:DI-> Destination within Transfer memory block.
 20966                                  ;
 20967                                  ;	rep	movsw			;Copy buffer sector to Transfer memory
 20968                                  ;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 20969                                  ;	rep	movsb                   ;Copy last byte.
 20970                                  ;	RestoreReg <es,di,si,dx,cx>
 20971                                  ;
 20972                                  ;       DS:DI -> current buffer.
 20973                                  ;
 20974                                  ;bufq3:	mov     ax,di			;DS:AX -> Current buffer.
 20975                                  ;       invoke  SCANPLACE
 20976                                  ;       cmp	ax,[FIRST_BUFF_ADDR]    ;Last buffer?
 20977                                  ;       RestoreReg <ax>
 20978                                  ;       jnz    	bufq                   	; -no, jump.
 20979                                  ;       jmp     short bufx              ; -yes, exit.
 20980                                  ;
 20981                                  ;EndProc DskRdBufScan
 20982                                  
 20983                                  ; 23/07/2019 - Retro DOS v3.2 
 20984                                  
 20985                                  ;Break   <DISKWRITE -- PERFORM USER DISK WRITE>
 20986                                  ;----------------------------------------------------------------------------
 20987                                  ;
 20988                                  ; Procedure Name : DISKWRITE
 20989                                  ;
 20990                                  ; Inputs:
 20991                                  ;       Outputs of SETUP
 20992                                  ; Function:
 20993                                  ;       Perform disk write
 20994                                  ; Outputs:
 20995                                  ;    Carry clear
 20996                                  ;       CX = No. of bytes written
 20997                                  ;       ES:DI point to SFT
 20998                                  ;       SFT offset and cluster pointers updated
 20999                                  ;    Carry set
 21000                                  ;       CX = 0
 21001                                  ;       ES:DI point to SFT
 21002                                  ;       AX has error code
 21003                                  ;----------------------------------------------------------------------------
 21004                                  
 21005                                  ;hkn; called by DOS_WRITE. DS already set up at this point.
 21006                                  
 21007                                  DISKWRITE:
 21008                                  	; MSDOS 3.3
 21009                                  	; IBMDOS.COM - Offset 436Dh
 21010                                  	;;test	byte [es:di+4],8
 21011                                  	;TEST	byte [ES:DI+SF_ENTRY.sf_attr],attr_volume_id
 21012                                  	;jz	short write_cont
 21013                                  	;jmp	SET_ACC_ERR_DS
 21014                                  ;write_cont:
 21015                                  	;push	cx
 21016                                  	;or	cx, cx
 21017                                  	;jnz	short Not_Truncate
 21018                                  	;;mov	cx,-1
 21019                                  	;dec	cx
 21020                                  ;Not_Truncate:
 21021                                  	;call	LOCK_CHECK
 21022                                  	;pop	cx
 21023                                  	;jnb	short _WRITE_OK
 21024                                  	;call	WRITE_LOCK_VIOLATION
 21025                                  	;jnb	short DISKWRITE
 21026                                  	;retn
 21027                                  
 21028                                  	; MSDOS 6.0
 21029 0000456C E806FD                  	call	CHECK_WRITE_LOCK	;IFS. check write lock	;AN000;
 21030                                  	; 19/08/2018
 21031 0000456F 7304                    	JNC	short _WRITE_OK		;IFS. lock check ok	;AN000;
 21032 00004571 C3                      	retn
 21033                                  
 21034                                  WRTEOFJ:
 21035 00004572 E92102                  	JMP     WRTEOF
 21036                                  
 21037                                  _WRITE_OK:
 21038                                   	; 27/07/2018
 21039                                  	; IBMDOS.COM - Offset 438Eh
 21040                                  	
 21041                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21042                                  	;and	word [es:di+5],0BFBFh
 21043 00004575 26816505BFBF            	AND     word [ES:DI+SF_ENTRY.sf_flags],~(sf_close_nodate|devid_file_clean)
 21044                                  				; Mark file as dirty, clear no date on close
 21045                                  	
 21046                                  	; 04/05/2019 - Retro DOS v4.0	
 21047                                  	; 23/07/2019 - Retro DOS v3.2
 21048                                  
 21049                                  	; MSDOS 6.0
 21050                                  	; mov 	ax,[es:di+11h]
 21051 0000457B 268B4511                	MOV	AX,[ES:DI+SF_ENTRY.sf_size]		;M039
 21052 0000457F A3[B205]                        MOV	[TEMP_VAR],AX                           ;M039
 21053                                  	;mov	ax,[es:di+13h]
 21054 00004582 268B4513                	MOV	AX,[ES:DI+SF_ENTRY.sf_size+2]		;M039
 21055 00004586 A3[B405]                        MOV	[TEMP_VAR2],AX                          ;M039
 21056                                  
 21057                                  ;	TEMP_VAR2:TEMP_VAR = Current file size (sf_size);M039
 21058                                  
 21059                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21060 00004589 C42E[4605]              	LES     BP,[THISDPB]
 21061                                  
 21062 0000458D E816FE                  	call	BREAKDOWN
 21063                                  
 21064 00004590 A1[8A05]                	MOV     AX,[BYTPOS]
 21065 00004593 8B16[8C05]              	MOV     DX,[BYTPOS+2]
 21066 00004597 E3D9                    	JCXZ    WRTEOFJ                 ;Make the file length = sf_position
 21067 00004599 01C8                    	ADD     AX,CX
 21068 0000459B 83D200                  	ADC     DX,0                    ;DX:AX = last byte to write + 1.
 21069                                  
 21070                                  	;mov	bx,[es:bp+2]
 21071 0000459E 268B5E02                	MOV     BX,[ES:BP+DPB.SECTOR_SIZE]
 21072                                  
 21073                                  	; 23/07/2019 - Retro DOS v3.2
 21074                                  	; MSDOS 3.3
 21075                                  	;cmp	dx,bx
 21076                                  	;jnb	short WRTERR33
 21077                                  	;div	bx
 21078                                  	;mov	bx,ax
 21079                                  	;OR	DX,DX
 21080                                  	;JNZ	short CALCLUS
 21081                                  	;dec	ax
 21082                                  ;CALCLUS:
 21083                                  	; MSDOS 3.3
 21084                                  	;mov	cl,[es:bp+5]
 21085                                  	;MOV	CL,[ES:BP+DPB.CLUSTER_SHIFT]
 21086                                  	;shr	ax,cl
 21087                                  	;push	ax
 21088                                  	;push	dx
 21089                                  	;push	es
 21090                                  	;les	di,[THISSFT]
 21091                                  	;;mov	ax,[es:di+11h]
 21092                                  	;;mov	dx,[es:di+13h]
 21093                                  	;mov	ax,[ES:DI+SF_ENTRY.sf_size]
 21094                                  	;mov	dx,[ES:DI+SF_ENTRY.sf_size+2]
 21095                                  	;pop	es
 21096                                  	;;DX:AX = current file size (in bytes).
 21097                                  	;;div	word [es:bp+2]
 21098                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 21099                                  	;mov	cx,ax
 21100                                  	;or	dx,dx
 21101                                  	;jz	short NORND
 21102                                  	;inc	ax
 21103                                  ;NORND:
 21104                                  	; MSDOS 6.0
 21105 000045A2 E8A002                  	CALL	DIV32                   ;DX:AX/BX = CX:AX + DX (rem.).
 21106 000045A5 89C6                    	MOV	SI,AX
 21107 000045A7 890E[B005]                      MOV	[HIGH_SECTOR],CX
 21108                                  
 21109                                  ;       [HIGH_SECTOR]:SI = Last full sector to write.
 21110                                  
 21111 000045AB 09D2                    	OR	DX,DX
 21112 000045AD 52                      	PUSH	DX ; *			;M039: Free DX for use by SHR32
 21113 000045AE 89CA                    	MOV	DX,CX			;M039
 21114 000045B0 7506                    	JNZ	short CALCLUS
 21115 000045B2 83E801                  	SUB	AX,1                    ;AX must be zero base indexed	;AC000;
 21116 000045B5 83DA00                  	SBB	DX,0			;M039 ;F.C. >32mb		;AN000;
 21117                                  CALCLUS:
 21118                                  	; MSDOS 6.0
 21119 000045B8 E8B102                  	CALL	SHR32                   ;F.C. >32mb			;AN000;
 21120 000045BB 5A                      	POP	DX ; *
 21121                                  
 21122                                  ;       AX = Last cluster to write.
 21123                                  ;       DX = # of bytes in last sector to write (the "tail").
 21124                                  ;       BX = [ES:BP+DPB.SECTOR_SIZE]
 21125                                  
 21126 000045BC 50                      	PUSH	AX ; *2
 21127 000045BD 52                      	PUSH	DX ; *1
 21128                                  ;M039
 21129 000045BE 8B16[B405]              	mov	dx,[TEMP_VAR2]
 21130 000045C2 A1[B205]                	mov	ax,[TEMP_VAR]           ;DX:AX = current file size (in bytes).
 21131 000045C5 E87D02                  	call	DIV32           	;DX:AX/BX = CX:AX + DX (rem.)
 21132 000045C8 890E[B405]              	mov	[TEMP_VAR2],cx
 21133 000045CC 890E[8605]              	mov	[VALSEC+2],cx
 21134 000045D0 89C1                    	mov	cx,ax
 21135 000045D2 89F3                    	mov	bx,si
 21136                                  
 21137                                  ;       [HIGH_SECTOR]:BX = Last full sector to write.
 21138                                  ;          [VALSEC+2]:CX = Last full sector of current file.
 21139                                  ;         [TEMP_VAR2]:CX = Last full sector of current file.
 21140                                  ;                     DX = # of bytes in last sector of current file.
 21141                                  ;M039
 21142 000045D4 09D2                    	OR	DX,DX
 21143 000045D6 7408                    	JZ	short NORND
 21144 000045D8 83C001                  	ADD	AX,1            	;Round up if any remainder	;AC000;
 21145 000045DB 8316[8605]00            	ADC	word [VALSEC+2],0
 21146                                  NORND:	
 21147                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21148 000045E0 A3[8405]                	MOV     [VALSEC],AX
 21149                                  
 21150                                  ;       [VALSEC] = Last sector of current file.
 21151                                  
 21152 000045E3 31C0                    	XOR     AX,AX
 21153 000045E5 A3[9A05]                	MOV     [GROWCNT],AX
 21154 000045E8 A3[9C05]                	MOV     [GROWCNT+2],AX
 21155 000045EB 58                      	POP     AX ; *1 ; # of bytes in last sector to write (the "tail")
 21156                                  	
 21157                                  	; 23/07/2019 - Retro DOS v3.2
 21158                                  	
 21159                                  	; MSDOS 6.0
 21160 000045EC 8B3E[B005]              	MOV	DI,[HIGH_SECTOR]        ;F.C. >32mb			;AN000;
 21161 000045F0 3B3E[B405]              	CMP	DI,[TEMP_VAR2]		;M039; F.C. >32mb		;AN000;
 21162 000045F4 7264                    	JB	short NOGROW		;F.C. >32mb                     ;AN000;
 21163 000045F6 7408                    	JZ	short lowsec		;F.C. >32mb                     ;AN000;
 21164 000045F8 29CB                    	SUB	BX,CX                   ;F.C. >32mb                     ;AN000;
 21165 000045FA 1B3E[B405]              	SBB	DI,[TEMP_VAR2]   	;M039; F.C. >32mb di:bx no. of sectors ;AN000;
 21166 000045FE EB09                    	JMP	short yesgrow           ;F.C. >32mb                     ;AN000;
 21167                                  lowsec:
 21168 00004600 BF0000                  	MOV	DI,0			;F.C. >32mb
 21169                                  	; MSDOS 3.3 & MSDOS 6.0
 21170 00004603 29CB                    	SUB	BX,CX			; Number of full sectors
 21171 00004605 7253                    	JB	short NOGROW
 21172 00004607 7444                    	JZ	short TESTTAIL
 21173                                  yesgrow:
 21174                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21175 00004609 89D1                    	MOV     CX,DX
 21176 0000460B 93                      	XCHG    AX,BX
 21177                                  	;mul	word [es:bp+2]
 21178 0000460C 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]  ; Bytes of full sector growth
 21179                                  	
 21180                                  	; MSDOS 6.0
 21181 00004610 8916[B005]              	MOV	[HIGH_SECTOR],DX         ;F.C. >32mb save dx                    ;AN000;
 21182 00004614 A3[B405]                	MOV	[TEMP_VAR2],AX    	 ;M039; F.C. >32mb save ax		;AN000;
 21183 00004617 89F8                    	MOV	AX,DI                    ;F.C. >32mb                            ;AN000;
 21184                                  	;mul	word [es:bp+2]
 21185 00004619 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE] ;F.C. >32mb do higher word multiply ;AN000;
 21186                                  	
 21187 0000461D 0306[B005]              	ADD	AX,[HIGH_SECTOR]         ;F.C. >32mb add lower value            ;AN000;
 21188 00004621 89C2                    	MOV	DX,AX                    ;F.C. >32mb DX:AX is the result of     ;AN000;
 21189 00004623 A1[B405]                	MOV	AX,[TEMP_VAR2]    	 ;M039; F.C. >32mb a 32 bit multiply	;AN000;
 21190                                  
 21191                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21192 00004626 29C8                    	SUB     AX,CX			; Take off current "tail"
 21193 00004628 83DA00                  	SBB     DX,0			; 32-bit extension
 21194 0000462B 01D8                    	ADD     AX,BX			; Add on new "tail"
 21195 0000462D 83D200                  	ADC     DX,0			; ripple tim's head off
 21196 00004630 EB21                    	JMP     SHORT SETGRW
 21197                                  
 21198                                  HAVSTART:
 21199                                  	;int	3
 21200 00004632 89C1                    	MOV     CX,AX
 21201 00004634 E8430F                  	call	SKPCLP
 21202                                  	;JCXZ	DOWRTJ
 21203 00004637 E357                    	jcxz	DOWRT
 21204                                  
 21205 00004639 E8E410                  	call	ALLOCATE
 21206                                  	;JNC	short DOWRTJ
 21207 0000463C 7352                    	jnc	short DOWRT
 21208                                  
 21209                                  	;entry   WRTERR
 21210                                  WRTERR:
 21211 0000463E B40F                    	MOV     AH,0FH                          ;MS. write/data/fail/abort      ;AN000;
 21212                                  
 21213                                  	;entry WRTERR22
 21214                                  WRTERR22:
 21215 00004640 A0[3305]                	MOV     AL,[THISDRV]                    ;MS.                            ;AN000;
 21216                                  
 21217                                  	; 27/07/2018
 21218                                  WRTERR33:
 21219                                  	;MOV	CX,0                    	;No bytes transferred
 21220 00004643 31C9                    	XOR     CX,CX
 21221                                  					
 21222 00004645 C43E[5A05]              	LES     DI,[THISSFT]
 21223                                  	;CLC	; 19/05/2019
 21224 00004649 C3                      	retn
 21225                                  
 21226                                  ;DOWRTJ: 
 21227                                  ;	JMP     short DOWRT
 21228                                  
 21229                                  ACC_ERRWJ:
 21230                                  	; 10/08/2018
 21231                                  	;JMP	SET_ACC_ERRW
 21232 0000464A E9F3FD                  	jmp	SET_ACC_ERR_DS
 21233                                  
 21234                                  TESTTAIL:
 21235 0000464D 29D0                    	SUB     AX,DX
 21236 0000464F 7609                    	JBE	short NOGROW
 21237 00004651 31D2                    	XOR     DX,DX
 21238                                  SETGRW:
 21239 00004653 A3[9A05]                	MOV	[GROWCNT],AX
 21240 00004656 8916[9C05]              	MOV	[GROWCNT+2],DX
 21241                                  NOGROW:
 21242 0000465A 58                      	POP     AX	; *2 ; Last cluster to write
 21243 0000465B 8B0E[7805]              	MOV     CX,[CLUSNUM]    ; First cluster accessed
 21244 0000465F E8F80E                  	call	FNDCLUS
 21245 00004662 72E6                    	JC	short ACC_ERRWJ
 21246 00004664 891E[7805]              	MOV     [CLUSNUM],BX
 21247 00004668 8916[7605]              	MOV     [LASTPOS],DX
 21248                                  
 21249 0000466C 29D0                    	SUB     AX,DX           ; Last cluster minus current cluster
 21250 0000466E 7420                    	JZ	short DOWRT	; If we have last clus, we must have first
 21251 00004670 E3C0                    	JCXZ    HAVSTART        ; See if no more data
 21252 00004672 51                      	PUSH    CX              ; No. of clusters short of first
 21253 00004673 89C1                    	MOV     CX,AX
 21254 00004675 E8A810                  	call	ALLOCATE
 21255 00004678 59                      	POP     CX
 21256 00004679 72C3                    	JC	short WRTERR
 21257 0000467B 8B16[7605]              	MOV     DX,[LASTPOS]
 21258 0000467F 42                      	INC     DX
 21259 00004680 49                      	DEC     CX
 21260 00004681 7405                    	JZ	short NOSKIP
 21261 00004683 E8F40E                  	call	SKPCLP
 21262 00004686 72C2                    	JC	short ACC_ERRWJ
 21263                                  NOSKIP:
 21264 00004688 891E[7805]              	MOV     [CLUSNUM],BX
 21265 0000468C 8916[7605]              	MOV     [LASTPOS],DX
 21266                                  DOWRT:
 21267 00004690 833E[8E05]00            	CMP     word [BYTCNT1],0
 21268 00004695 7409                    	JZ	short WRTMID
 21269 00004697 8B1E[7805]              	MOV     BX,[CLUSNUM]
 21270 0000469B E8690F                  	call	BUFWRT
 21271 0000469E 72AA                    	JC	short ACC_ERRWJ
 21272                                  	;JC	short SET_ACC_ERRW
 21273                                  WRTMID:
 21274 000046A0 A1[9205]                	MOV     AX,[SECCNT]
 21275 000046A3 09C0                    	OR      AX,AX
 21276 000046A5 0F84B000                	JZ	WRTLAST ; 24/07/2019	;M039
 21277 000046A9 0106[8005]              	ADD     [SECPOS],AX
 21278                                  	; 23/07/2019 - Retro DOS v3.2
 21279                                  	; MSDOS 6.0
 21280 000046AD 8316[8205]00            	ADC	WORD [SECPOS+2],0	;F.C. >32mb 	;AN000;
 21281 000046B2 E8AE0F                  	call	NEXTSEC
 21282 000046B5 7293                    	JC	short ACC_ERRWJ
 21283                                  	;JC	short SET_ACC_ERRW	;M039
 21284 000046B7 C606[3105]01            	MOV     BYTE [TRANS],1		; A transfer is taking place
 21285 000046BC 8A16[3005]              	MOV     DL,[SECCLUSPOS] 	; (dx/DL = Extent start) ((dh = ?))
 21286 000046C0 8B1E[7805]              	MOV     BX,[CLUSNUM]
 21287 000046C4 8B0E[9205]              	MOV     CX,[SECCNT]
 21288                                  WRTLP:
 21289 000046C8 E8C90F                  	call	OPTIMIZE
 21290 000046CB 727D                    	JC	short SET_ACC_ERRW ; 24/07/2019
 21291                                  
 21292                                  ;M039
 21293                                  ;       DI = Next physical cluster.
 21294                                  ;       AX = # sectors remaining.
 21295                                  ;       [DMAADD+2]:BX = transfer address (source data address).
 21296                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 21297                                  ;	     sectors, also termed an "Extent".)
 21298                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 21299                                  ;       ES:BP -> Drive Parameter Block (DPB).
 21300                                  ;
 21301                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 21302                                  ;	are in Extent; they are being over-written.
 21303                                  
 21304 000046CD 57                      	push    di ; *5*
 21305 000046CE 50                      	push    ax ; *4*
 21306                                  
 21307                                          ; MSDOS 6.0
 21308                                  	;call	DskWrtBufPurge          ;DS trashed.
 21309                                  ;ASSUME DS:NOTHING
 21310                                  ;M039
 21311                                  	; MSDOS 3.3
 21312                                  	; IBMDOS.COM (1987) - Offset 4497h
 21313 000046CF 52                      	push	dx ; *3*
 21314 000046D0 53                      	push	bx ; *2*
 21315                                  
 21316                                  	;mov	al,[es:bp]
 21317                                  	;mov	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 21318                                  	
 21319                                  	;mov	bx,cx
 21320                                  	;add	bx,dx	; (bx = Extent end)
 21321                                  
 21322                                  	; MSDOS 3.3	
 21323                                  ;;	DX = Extent start.
 21324                                  ;;	BX = Extent end.
 21325                                  ;;	AL = Drive #.
 21326                                  
 21327                                  	; 23/07/2019 - Retro DOS v3.2
 21328                                  	; (MSDOS 6.0, 'DskWrtBufPurge')
 21329                                  
 21330                                  	;push	bx
 21331 000046D1 51                      	push	cx ; *1*
 21332                                  
 21333 000046D2 368B1E[B005]            	mov	bx,[ss:HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 21334 000046D7 89DE                    	mov	si,bx
 21335 000046D9 01D1                    	add	cx,dx
 21336 000046DB 83D600                  	adc	si,0                    ;SI:CX = Extent end + 1.
 21337                                  
 21338                                  	;;mov	al,[es:bp+0]
 21339                                  	;mov	al,[es:bp+DPB.DRIVE]
 21340 000046DE 268A4600                	mov	al,[es:bp]
 21341                                  
 21342                                  	; MSDOS 6.0
 21343                                  ;	BX:DX = Extent start.
 21344                                  ;	SI:CX = Extent end + 1.
 21345                                  ;	AL = Drive #
 21346                                  
 21347                                  	; MSDOS 3.3
 21348 000046E2 E8DB19                  	call	SETVISIT
 21349                                  		; DS:DI = [BUFFHEAD]
 21350                                  wbufq1:
 21351                                  	;or	byte [di+5],20h
 21352 000046E5 804D0520                	or	byte [DI+BUFFINFO.buf_flags],buf_visit ; Bit 5 = reserved
 21353                                  
 21354                                  	; 23/07/2019 - Retro DOS v3.2
 21355                                  
 21356                                  	;cmp	al,[di+4]	
 21357 000046E9 3A4504                  	cmp	al,[DI+BUFFINFO.buf_ID]
 21358 000046EC 751C                    	jne	short wbufq2		;Same drive?
 21359                                  					;  -no, jump.
 21360                                  	; MSDOS 3.3
 21361                                  	;;cmp	[di+6],dx
 21362                                  	;cmp	[DI+BUFFINFO.buf_sector],dx
 21363                                  	;jb	short wbufq2	; Jump if Extent start > buffer sector.	
 21364                                  	;;cmp	[di+6],bx
 21365                                  	;cmp	[DI+BUFFINFO.buf_sector],bx
 21366                                  	;jnb	short wbufq2	; Jump if Extent end <= buffer sector.
 21367                                  
 21368                                  	; MSDOS 6.0 (code modified in Retro DOS v3.2) ; 23/07/2019
 21369                                   	;cmp	bx,[di+8]
 21370 000046EE 3B5D08                  	cmp	bx,[di+BUFFINFO.buf_sector+2]
 21371 000046F1 7503                    	jne	short bufq04
 21372                                  	;cmp	dx,[di+6]
 21373 000046F3 3B5506                  	cmp	dx,[di+BUFFINFO.buf_sector]
 21374                                  bufq04:
 21375 000046F6 7712                    	ja	short wbufq2 	; Jump if Extent start > buffer sector.
 21376                                  
 21377                                  	;cmp	si,[di+8]
 21378 000046F8 3B7508                  	cmp	si,[di+BUFFINFO.buf_sector+2]
 21379 000046FB 7503                    	jne	short bufq05
 21380                                  	;cmp	cx,[di+6]
 21381 000046FD 3B4D06                  	cmp	cx,[di+BUFFINFO.buf_sector]
 21382                                  bufq05:
 21383 00004700 7608                    	jna	short wbufq2	; Jump if Extent end <= buffer sector.
 21384                                  
 21385                                  	; 23/07/2019
 21386                                  
 21387                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21388                                  
 21389                                  ;	Buffer's sector is in Extent, so free it; it is being over-written.
 21390                                  
 21391                                  	;mov	word [di+4],20FFh
 21392                                  	;mov	word [di+BUFFINFO.buf_ID],((buf_visit<<8)|0FFh)
 21393 00004702 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],20FFh
 21394                                  					; .buf_ID,    AL = FFh (Free buffer)
 21395                                  					; .buf_flags, AH = 0, reset/clear
 21396 00004707 E8E319                  	call	SCANPLACE
 21397                                  wbufq2:
 21398                                  	; AL = Drive #
 21399                                  	; MSDOS 3.3
 21400 0000470A E8CC19                  	call	SKIPVISIT
 21401 0000470D 75D6                    	jnz	short wbufq1  ; AL = Drive # ; 23/07/2019
 21402                                  
 21403                                  	; 23/07/2019 - Retro DOS v3.2
 21404                                  
 21405                                  	; MSDOS 6.0
 21406 0000470F 59                      	pop	cx ; *1* ; # of contiguous sectors to write
 21407                                  	;pop	bx 
 21408                                  
 21409                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21410 00004710 5B                      	pop	bx ; *2* ; [DMAADD+2]:BX = Transfer address (source data address)
 21411 00004711 5A                      	pop	dx ; *3* ; [HIGH_SECTOR]:DX = Extent start		
 21412                                  	
 21413                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21414                                  ;hkn; SS override for DMAADD and ALLOWED
 21415 00004712 368E1E[FA02]            	MOV     DS,[SS:DMAADD+2]
 21416                                  	;mov	byte [ss:ALLOWED],38h
 21417 00004717 36C606[1503]38          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL+Allowed_IGNORE
 21418                                  
 21419                                  ;	put logic from DWRITE in-line here so we can modify it
 21420                                  ;	for DISK FULL conditions.
 21421                                  
 21422                                  	; MSDOS 3.3
 21423                                  	;call	DWRITE
 21424                                  
 21425                                  ;DWRITE_OKAY:
 21426                                  
 21427                                  DWRITE_LUP:
 21428                                  	; 23/07/2019 - Retro DOS v3.2
 21429                                  
 21430                                  	; MSDOS 6.0
 21431 0000471D E8B3FB                  	call	DSKWRITE
 21432 00004720 7417                    	jz	short DWRITE_OKAY
 21433                                  
 21434                                  ;;	int	3
 21435 00004722 3C27                    	cmp	al,error_handle_Disk_Full	; compressed volume full?
 21436 00004724 7427                    	jz	short DWRITE_DISK_FULL
 21437                                  
 21438                                  ;;hkn; SS override
 21439 00004726 36C606[3205]01          	MOV	BYTE [SS:READOP],1
 21440 0000472C E8D3FB                  	call	HARDERRRW
 21441 0000472F 3C01                    	CMP	AL,1		; Check for retry
 21442 00004731 74EA                    	JZ	short DWRITE_LUP
 21443                                  
 21444                                  	; 29/07/2019 - Retro DOS v3.2
 21445                                  
 21446 00004733 3C03                    	CMP	AL,3		; Check for FAIL
 21447 00004735 F8                      	CLC
 21448 00004736 7501                    	JNZ	short DWRITE_OKAY ; Ignore
 21449 00004738 F9                      	STC
 21450                                  DWRITE_OKAY:
 21451                                  	; 29/07/2019
 21452                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21453 00004739 59                      	POP     CX ; *4*
 21454 0000473A 5B                      	POP	BX ; *5*
 21455                                  
 21456                                  ;       CX = # sectors remaining.
 21457                                  ;       BX = Next physical cluster.
 21458                                  
 21459                                  ;hkn; SS override
 21460                                          ;Context DS
 21461                                  	;push	ss
 21462                                  	;pop	ds
 21463 0000473B 720D                    	JC	short SET_ACC_ERRW
 21464                                  	; 16/12/2022
 21465 0000473D 16                      	push	ss
 21466 0000473E 1F                      	pop	ds
 21467 0000473F E318                    	JCXZ    WRTLAST
 21468                                  	;MOV	DL,0
 21469 00004741 30D2                    	xor	dl,dl ; 23/07/2019
 21470 00004743 FF06[7605]              	INC     word [LASTPOS]	; We'll be using next cluster
 21471 00004747 E97EFF                  	JMP	WRTLP
 21472                                  
 21473                                  	; 29/07/2019
 21474                                  SET_ACC_ERRW:
 21475 0000474A E9F3FC                  	jmp	SET_ACC_ERR_DS
 21476                                  
 21477                                  	; 23/07/2019 - Retro DOS v3.2
 21478                                  	; 09/08/2018
 21479                                  	; MSDOS 6.0
 21480                                  DWRITE_DISK_FULL:
 21481                                  	;;Context DS		;SQ 3-5-93 DS must be setup on return!
 21482                                  	; 16/12/2022 (BugFix)
 21483 0000474D 16                      	push	ss
 21484 0000474E 1F                      	pop	ds
 21485 0000474F 59                      	pop	cx		; unjunk stack
 21486 00004750 5B                      	pop	bx
 21487 00004751 C606[C20F]01            	mov	byte [DISK_FULL],1
 21488                                  	;stc
 21489 00004756 E9E5FE                  	jmp	WRTERR ; 24/07/2019 ; go to disk full exit
 21490                                  
 21491                                  ;SET_ACC_ERRW:
 21492                                  ;	jmp	SET_ACC_ERR_DS
 21493                                  
 21494                                  WRTLAST:
 21495 00004759 A1[9005]                	MOV     AX,[BYTCNT2]
 21496 0000475C 09C0                    	OR      AX,AX
 21497 0000475E 7413                    	JZ	short FINWRT
 21498 00004760 A3[8E05]                	MOV     [BYTCNT1],AX
 21499 00004763 E8FD0E                  	call	NEXTSEC
 21500 00004766 72E2                    	JC	short SET_ACC_ERRW
 21501 00004768 C706[8805]0000          	MOV     word [BYTSECPOS],0
 21502 0000476E E8960E                  	call	BUFWRT
 21503 00004771 72D7                    	JC	short SET_ACC_ERRW
 21504                                  FINWRT:
 21505 00004773 C43E[5A05]              	LES     DI,[THISSFT]
 21506 00004777 A1[9A05]                	MOV     AX,[GROWCNT]
 21507 0000477A 8B0E[9C05]              	MOV     CX,[GROWCNT+2]
 21508 0000477E 09C0                    	OR      AX,AX
 21509 00004780 7502                    	JNZ	short UPDATE_size
 21510 00004782 E30F                    	JCXZ    SAMSIZ
 21511                                  UPDATE_size:
 21512                                  	;add	[es:di+11h],ax
 21513 00004784 26014511                	ADD     [ES:DI+SF_ENTRY.sf_size],AX
 21514                                  	;adc	[es:di+13h],cx
 21515 00004788 26114D13                	ADC     [ES:DI+SF_ENTRY.sf_size+2],CX
 21516                                  ;
 21517                                  ; Make sure that all other SFT's see this growth also.
 21518                                  ;
 21519 0000478C B80100                  	MOV     AX,1
 21520                                  ;if installed
 21521                                  	;Call	JShare + 14 * 4
 21522 0000478F FF1E[9400]              	call    far [JShare+(14*4)]	; 14 = ShSU
 21523                                  ;else
 21524                                  ;	Call    ShSU
 21525                                  ;endif
 21526                                  
 21527                                  SAMSIZ:
 21528 00004793 E9ACFD                  	jmp	SETCLUS	; ES:DI already points to SFT
 21529                                  
 21530                                  WRTEOF:
 21531 00004796 89C1                    	MOV     CX,AX
 21532 00004798 09D1                    	OR      CX,DX
 21533 0000479A 746C                    	JZ	short KILLFIL
 21534 0000479C 83E801                  	SUB     AX,1
 21535 0000479F 83DA00                  	SBB     DX,0
 21536                                  
 21537                                  	; 23/07/2019 - Retro DOS v3.2
 21538                                  
 21539                                  	; MSDOS 3.3
 21540                                  	;;div	word [es:bp+2]
 21541                                  	;div	word [ES:BP+DPB.SECTOR_SIZE]
 21542                                  	;;mov	cl,[es:bp+5]
 21543                                  	;mov	cl,[ES:BP+DPB.CLUSTER_SHIFT] 
 21544                                  	;shr	ax,cl
 21545                                  
 21546                                  	; MSDOS 6.0
 21547 000047A2 53                      	PUSH	BX
 21548                                  	;mov	bx,[es:bp+2]
 21549 000047A3 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]    ;F.C. >32mb                       ;AN000;
 21550 000047A7 E89B00                  	CALL	DIV32                         ;F.C. >32mb                       ;AN000;
 21551 000047AA 5B                      	POP	BX			      ;F.C. >32mb			;AN000;
 21552 000047AB 89CA                    	MOV	DX,CX			      ;M039
 21553 000047AD 890E[B005]                      MOV	[HIGH_SECTOR],CX              ;M039: Probably extraneous, but not sure.
 21554 000047B1 E8B800                  	CALL	SHR32                         ;F.C. >32mb   
 21555                                  
 21556 000047B4 89C1                    	MOV     CX,AX
 21557 000047B6 E8A10D                  	call	FNDCLUS
 21558                                  SET_ACC_ERRWJ2:
 21559 000047B9 728F                    	JC	short SET_ACC_ERRW
 21560                                  
 21561 000047BB E326                    	JCXZ    RELFILE
 21562 000047BD E8600F                  	call	ALLOCATE
 21563 000047C0 721E                    	JC	short WRTERRJ              ;;;;;;;;; disk full
 21564                                  
 21565                                  UPDATE:
 21566 000047C2 C43E[5A05]              	LES	DI,[THISSFT]
 21567 000047C6 A1[8A05]                	MOV	AX,[BYTPOS]
 21568                                  	;mov	[es:di+11h],ax
 21569 000047C9 26894511                	MOV	[ES:DI+SF_ENTRY.sf_size],AX
 21570 000047CD A1[8C05]                	MOV	AX,[BYTPOS+2]
 21571                                  	;mov	[es:di+13h],ax
 21572 000047D0 26894513                	MOV	[ES:DI+SF_ENTRY.sf_size+2],AX
 21573                                  ;
 21574                                  ; Make sure that all other SFT's see this growth also.
 21575                                  ;
 21576 000047D4 B80200                  	MOV     AX,2
 21577                                  ;if installed
 21578                                  	;Call	JShare + 14 * 4
 21579 000047D7 FF1E[9400]              	call    far [JShare+(14*4)]	; 14 = ShSU
 21580                                  ;else
 21581                                  ;	Call    ShSU
 21582                                  ;endif
 21583 000047DB 31C9                    	XOR     CX,CX
 21584 000047DD E97FFD                  	jmp	ADDREC
 21585                                  
 21586                                  WRTERRJ: 
 21587 000047E0 E95BFE                  	JMP     WRTERR
 21588                                  
 21589                                  ;;;;;;;;;;;;;;;; 7/18/86
 21590                                  ;;;;;;;;;;;;;;;;
 21591                                  
 21592                                  RELFILE:
 21593                                  	; MSDOS 6.0
 21594 000047E3 06                      	PUSH    ES                    ;AN002; BL Reset Lstclus and cluspos to
 21595 000047E4 C43E[5A05]              	LES     DI,[THISSFT]          ;AN002; BL beginning of file if current
 21596 000047E8 263B5519                	CMP     DX,[ES:DI+SF_ENTRY.sf_cluspos]	;AN002; BL cluspos is past EOF.
 21597 000047EC 730E                    	JAE	short SKIPRESET	      		;AN002; BL
 21598 000047EE 26C745190000            	MOV     word [ES:DI+SF_ENTRY.sf_cluspos],0 ;AN002; BL
 21599 000047F4 268B550B                	MOV     DX,[ES:DI+SF_ENTRY.sf_firclus]	;AN002; BL
 21600 000047F8 26895535                	MOV     [ES:DI+SF_ENTRY.sf_lstclus],DX	;AN002; BL
 21601                                  SKIPRESET:                            		;AN002; BL
 21602 000047FC 07                      	POP     ES                    		;AN002; BL
 21603                                  ;
 21604 000047FD BAFFFF                  	MOV     DX,0FFFFH
 21605 00004800 E8CB0F                  	call	RELBLKS
 21606 00004803 73BD                    	jnc	short UPDATE
 21607                                  SET_ACC_ERRWJJ:
 21608                                  	;JC	short SET_ACC_ERRWJ2
 21609                                  	;JMP	SHORT UPDATE
 21610 00004805 E938FC                  	jmp	SET_ACC_ERR_DS
 21611                                  
 21612                                  KILLFIL:
 21613 00004808 31DB                    	XOR     BX,BX
 21614 0000480A 06                      	PUSH    ES
 21615 0000480B C43E[5A05]              	LES     DI,[THISSFT]
 21616 0000480F 26895D19                	mov	[es:di+19h],bx
 21617 00004813 26895D19                	MOV	[ES:DI+SF_ENTRY.sf_cluspos],BX
 21618                                  	;mov	[es:di+1Bh],bx
 21619                                  	;mov	[ers:di+35h],bx ; MSDOS 6.0
 21620 00004817 26895D35                	MOV	[ES:DI+SF_ENTRY.sf_lstclus],BX
 21621                                  	;xchg	bx,[es:di+0Bh]
 21622 0000481B 26875D0B                	XCHG    BX,[ES:DI+SF_ENTRY.sf_firclus]
 21623 0000481F 07                      	POP	ES
 21624                                  
 21625 00004820 09DB                    	OR	BX,BX
 21626                                  	;JZ	short UPDATEJ
 21627 00004822 749E                    	jz	short UPDATE
 21628                                  
 21629                                  ;; 10/23/86 FastOpen update
 21630 00004824 06                      	PUSH	ES              ; since first cluster # is 0
 21631 00004825 55                      	PUSH	BP              ; we must delete the old cache entry
 21632 00004826 50                      	PUSH	AX
 21633 00004827 51                      	PUSH	CX
 21634 00004828 52                      	PUSH	DX
 21635 00004829 C42E[4605]              	LES	BP,[THISDPB]             ; get current DPB
 21636 0000482D 268A5600                	mov	dl,[ES:BP] ; mov al,[es:bp+0]
 21637                                  	;MOV	DL,[ES:BP+DPB.DRIVE]	; get current drive
 21638 00004831 89D9                    	MOV	CX,BX                    ; first cluster #
 21639 00004833 B402                    	MOV	AH,2                     ; delete cache entry by drive:firclus
 21640 00004835 E84AEC                  	call	FastOpen_Update          ; call fastopen
 21641 00004838 5A                      	POP	DX
 21642 00004839 59                      	POP	CX
 21643 0000483A 58                      	POP	AX
 21644 0000483B 5D                      	POP	BP
 21645 0000483C 07                      	POP	ES
 21646                                  ;; 10/23/86 FastOpen update
 21647                                  
 21648 0000483D E88C0F                  	call	RELEASE
 21649 00004840 72C3                    	JC	short SET_ACC_ERRWJJ
 21650                                  UpDateJ:
 21651 00004842 E97DFF                  	JMP	UPDATE ; 10/08/2018
 21652                                  
 21653                                  ;Break   <DskWrtBufPurge -- Disk Write Buffer Purge>
 21654                                  ;----------------------------------------------------------------------------
 21655                                  ;
 21656                                  ; Procedure Name : DskWrtBufPurge
 21657                                  ;
 21658                                  ; Inputs:
 21659                                  ;       CX = # of contiguous sectors to write. (These constitute a block of
 21660                                  ;	     sectors, also termed an "Extent".)
 21661                                  ;       [HIGH_SECTOR]:DX = physical sector # of first sector in extent.
 21662                                  ;       ES:BP -> Drive Parameter Block (DPB).
 21663                                  ;
 21664                                  ; Function:
 21665                                  ;       Purge the Buffer Queue and the Secondary Cache of any buffers which
 21666                                  ;	are in Extent; they are being over-written.
 21667                                  ;
 21668                                  ; Outputs:
 21669                                  ;       (Same as Input.)
 21670                                  ; Uses:
 21671                                  ;       All registers except DS,AX,SI,DI preserved.
 21672                                  ;       SS override for all global variables.
 21673                                  ;----------------------------------------------------------------------------
 21674                                  ;M039: Created
 21675                                  
 21676                                  ;procedure   DskWrtBufPurge,NEAR
 21677                                  ;
 21678                                  ;ASSUME  DS:NOTHING
 21679                                  ;
 21680                                  ;       SaveReg <bx,cx>
 21681                                  ;       mov	bx,[HIGH_SECTOR]	;BX:DX = Extent start (sector #).
 21682                                  ;       mov     si,bx
 21683                                  ;       add     cx,dx
 21684                                  ;       adc     si,0                    ;SI:CX = Extent end + 1.
 21685                                  ;
 21686                                  ;	Assert  ISDPB,<ES,BP>,"DskWrtBufPurge"
 21687                                  ;	mov     al,es:[bp.dpb_drive]
 21688                                  ;
 21689                                  ;;      BX:DX = Extent start.
 21690                                  ;;      SI:CX = Extent end + 1.
 21691                                  ;;      AL = Drive #
 21692                                  ;
 21693                                  ;	cmp     [SC_CACHE_COUNT],0      ;Secondary cache in-use?
 21694                                  ;	je      nosc                    ; -no, jump.
 21695                                  ;
 21696                                  ;;      If any of the sectors to be written are in the secondary cache (SC),
 21697                                  ;;      invalidate the entire SC. (This is an optimization; we really only
 21698                                  ;;	need to invalidate those sectors which intersect, but that's slower.)
 21699                                  ;
 21700                                  ;       cmp     al,[CURSC_DRIVE]        ;Same drive?
 21701                                  ;       jne     nosc                    ; -no, jump.
 21702                                  ;
 21703                                  ;       push    ax
 21704                                  ;       mov     ax,[CURSC_SECTOR]
 21705                                  ;       mov     di,[CURSC_SECTOR+2]     ;DI:AX = SC start.
 21706                                  ;       Cmp32   si,cx,di,ax             ;Extent end < SC start?
 21707                                  ;       jbe     sc5                     ; -yes, jump.
 21708                                  ;       add     ax,[SC_CACHE_COUNT]
 21709                                  ;       adc     di,0                    ;DI:AX = SC end + 1.
 21710                                  ;       Cmp32   bx,dx,di,ax             ;Extent start > SC end?
 21711                                  ;       jae     sc5                     ; -yes, jump.
 21712                                  ;       mov     [SC_STATUS],0           ;Extent intersects SC: invalidate SC.
 21713                                  ;sc5:	pop     ax
 21714                                  ;
 21715                                  ;;	Free any buffered sectors which are in Extent; they are being over-
 21716                                  ;;	written.
 21717                                  ;
 21718                                  ;nosc:	invoke  GETCURHEAD              ;DS:DI -> first buffer in queue.
 21719                                  ;
 21720                                  ;bufq:	cmp     al,BYTE PTR [di.buf_ID] ;Same drive?
 21721                                  ;	jne     bufq5                   ; -no, jump.
 21722                                  ;
 21723                                  ;       Cmp32   bx,dx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 21724                                  ;       ja	bufq5			;Jump if Extent start > buffer sector.
 21725                                  ;       Cmp32   si,cx,<WORD PTR [di.buf_sector+2]>,<WORD PTR [di.buf_sector]>
 21726                                  ;       jbe	bufq5                   ;Jump if Extent end < buffer sector.
 21727                                  ;
 21728                                  ;;      Buffer's sector is in Extent, so free it; it is being over-written.
 21729                                  ;
 21730                                  ;       testb   [di.buf_flags],buf_dirty ;Buffer dirty?
 21731                                  ;       jz      bufq2                    ; -no, jump.
 21732                                  ;       invoke  DEC_DIRTY_COUNT          ; -yes, decrement dirty count.
 21733                                  ;bufq2: mov     WORD PTR [di.buf_ID],((buf_visit SHL 8) OR 0FFh)
 21734                                  ;
 21735                                  ;       invoke  SCANPLACE
 21736                                  ;       jmp     short bufq6
 21737                                  ;
 21738                                  ;bufq5: mov     di,[di.buf_next]
 21739                                  ;bufq6: cmp     di,[FIRST_BUFF_ADDR]    ;Scanned entire buffer queue?
 21740                                  ;       jne     bufq	                ; --no, go do next buffer.
 21741                                  ;
 21742                                  ;       RestoreReg <cx,bx>
 21743                                  ;       return
 21744                                  ;
 21745                                  ;EndProc DskWrtBufPurge
 21746                                  
 21747                                  ; 23/07/2019 - Retro DOS v3.2
 21748                                  
 21749                                  ;Break   <DIV32 -- PERFORM 32 BIT DIVIDE>
 21750                                  ;----------------------------------------------------------------------------
 21751                                  ;
 21752                                  ; Procedure Name : DIV32
 21753                                  ;
 21754                                  ; Inputs:
 21755                                  ;       DX:AX = 32 bit dividend   BX= divisor
 21756                                  ; Function:
 21757                                  ;       Perform 32 bit division:  DX:AX/BX = CX:AX + DX (rem.)
 21758                                  ; Outputs:
 21759                                  ;       CX:AX = quotient , DX= remainder
 21760                                  ; Uses:
 21761                                  ;       All registers except AX,CX,DX preserved.
 21762                                  ;----------------------------------------------------------------------------
 21763                                  ;M039: DIV32 optimized for divisor of 512 (common sector size).
 21764                                  
 21765                                  ; 04/05/2019 - Retro DOS v4.0
 21766                                  
 21767                                  ; DOSCODE:7C94h (MSDOS 6.21, MSDOS.SYS)
 21768                                  
 21769                                  DIV32:
 21770 00004845 81FB0002                	cmp	bx,512
 21771 00004849 7515                    	jne	short div5
 21772                                  
 21773 0000484B 89D1                    	mov	cx,dx
 21774 0000484D 89C2                    	mov	dx,ax           ; CX:AX = Dividend
 21775 0000484F 81E2FF01                	and	dx,(512-1)      ; DX = Remainder
 21776 00004853 88E0                    	mov	al,ah
 21777 00004855 88CC                    	mov	ah,cl
 21778 00004857 88E9                    	mov	cl,ch
 21779 00004859 30ED                    	xor	ch,ch
 21780 0000485B D1E9                    	shr	cx,1
 21781 0000485D D1D8                    	rcr	ax,1
 21782 0000485F C3                      	retn
 21783                                  div5:	
 21784 00004860 89C1                    	mov	cx,ax
 21785 00004862 89D0                    	mov	ax,dx
 21786 00004864 31D2                    	xor	dx,dx
 21787 00004866 F7F3                    	div	bx              ; 0:AX/BX
 21788 00004868 91                      	xchg	cx,ax
 21789 00004869 F7F3                    	div	bx              ; DX:AX/BX
 21790 0000486B C3                      	retn
 21791                                  
 21792                                  ; 23/07/2019 - Retro DOS v3.2
 21793                                  
 21794                                  ;Break   <SHR32 -- PERFORM 32 BIT SHIFT RIGHT>
 21795                                  ;----------------------------------------------------------------------------
 21796                                  ;
 21797                                  ; Procedure Name : SHR32
 21798                                  ;
 21799                                  ; Inputs:
 21800                                  ;	DX:AX = 32 bit sector number
 21801                                  ; Function:
 21802                                  ;       Perform 32 bit shift right
 21803                                  ; Outputs:
 21804                                  ;	AX = cluster number
 21805                                  ;	ZF = 1 if no error
 21806                                  ;	   = 0 if error (cluster number > 64k)
 21807                                  ; Uses:
 21808                                  ;       DX,CX
 21809                                  ;---------------------------------------------------------------------------
 21810                                  ; M017	- SHR32 rewritten for better performance
 21811                                  ; M039	- Additional optimization
 21812                                  
 21813                                  ; 04/05/2019 - Retro DOS v4.0
 21814                                  
 21815                                  ; DOSCODE:7CBBh (MSDOS 6.21, MSDOS.SYS)
 21816                                  
 21817                                  SHR32:
 21818                                  	;mov	cl,[es:bp+5]
 21819 0000486C 268A4E05                	mov	cl,[ES:BP+DPB.CLUSTER_SHIFT]
 21820 00004870 30ED                    	xor	ch,ch	    ;ZF=1
 21821 00004872 E306                    	jcxz	norota
 21822                                  
 21823                                  rotashft2:
 21824 00004874 D1EA                    	shr	dx,1	    ;ZF reflects state of DX.
 21825 00004876 D1D8                    	rcr	ax,1	    ;ZF not affected.
 21826 00004878 E2FA                    	loop	rotashft2
 21827                                  norota:
 21828 0000487A C3                      	retn
 21829                                  
 21830                                  ;============================================================================
 21831                                  ; DIR.ASM, MSDOS 6.0, 1991
 21832                                  ;============================================================================
 21833                                  ; 27/07/2018 - Retro DOS v3.0 
 21834                                  
 21835                                  ;	TITLE	DIR - Directory and path cracking
 21836                                  ;	NAME	Dir
 21837                                  
 21838                                  ;Break	<FINDENTRY -- LOOK FOR AN ENTRY>
 21839                                  ;---------------------------------------------------------------------------
 21840                                  ;
 21841                                  ; Procedure Name : FINDENTRY,SEARCH
 21842                                  ;
 21843                                  ; Inputs:
 21844                                  ;	[THISDPB] set
 21845                                  ;	[SECCLUSPOS] = 0
 21846                                  ;	[DIRSEC] = Starting directory sector number
 21847                                  ;	[CLUSNUM] = Next cluster of directory
 21848                                  ;	[CLUSFAC] = Sectors/Cluster
 21849                                  ;	[NAME1] = Name to look for
 21850                                  ; Function:
 21851                                  ;	Find file name in disk directory.
 21852                                  ;	"?" matches any character.
 21853                                  ; Outputs:
 21854                                  ;	Carry set if name not found
 21855                                  ;	ELSE
 21856                                  ;	Zero set if attributes match (always except when creating)
 21857                                  ;	AH = Device ID (bit 7 set if not disk)
 21858                                  ;	[THISDPB] = Base of drive parameters
 21859                                  ;	DS = DOSGROUP
 21860                                  ;	ES = DOSGROUP
 21861                                  ;	[CURBUF+2]:BX = Pointer into directory buffer
 21862                                  ;	[CURBUF+2]:SI = Pointer to First Cluster field in directory entry
 21863                                  ;	[CURBUF] has directory record with match
 21864                                  ;	[NAME1] has file name
 21865                                  ;	[LASTENT] is entry number of the entry
 21866                                  ; All other registers destroyed.
 21867                                  ;----------------------------------------------------------------------------
 21868                                  
 21869                                  ;hkn; called from rename.asm and dir2.asm. DS must be already set up at
 21870                                  ;hkn; this point.
 21871                                  
 21872                                  SEARCH:
 21873                                  	; 27/07/2018 - Retro DOS v3.0
 21874                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 45B3h 
 21875                                  	; 15/03/2018 - Retro DOS v2.0
 21876                                  
 21877                                  	;entry	FindEntry
 21878                                  FINDENTRY:
 21879 0000487B E83804                  	call	STARTSRCH
 21880 0000487E A0[2805]                	MOV	AL,[ATTRIB]
 21881                                  	;and	al,9Eh
 21882 00004881 24DE                    	AND	AL,~attr_ignore		; Ignore useless bits
 21883                                  	;cmp	al,8
 21884 00004883 3C08                    	CMP	AL,attr_volume_id	; Looking for vol ID only ?
 21885 00004885 7503                    	JNZ	short NOTVOLSRCH	; No
 21886 00004887 E87601                  	CALL	SETROOTSRCH		; Yes force search of root
 21887                                  NOTVOLSRCH:
 21888 0000488A E80601                  	CALL	GETENTRY
 21889 0000488D 7303                    	JNC	short SRCH
 21890 0000488F E99500                  	JMP	SETESRET
 21891                                  
 21892                                  	;entry	Srch
 21893                                  SRCH:
 21894 00004892 1E                      	PUSH	DS
 21895 00004893 8E1E[A005]              	MOV	DS,[CURBUF+2]
 21896                                  
 21897                                  ;	(DS:BX) = directory entry address
 21898                                  
 21899 00004897 8A27                    	mov	ah,[BX]
 21900                                  	;MOV	AH,[BX+dir_entry.dir_name] ; mov ah,[bx+0]
 21901 00004899 08E4                    	OR	AH,AH			; End of directory?
 21902 0000489B 743A                    	JZ	short FREE
 21903                                  
 21904                                  ;hkn; SS override
 21905 0000489D 363A26[3B05]            	CMP	AH,[SS:DELALL]		; Free entry?
 21906 000048A2 7433                    	JZ	short FREE
 21907                                  	;test	byte [bx+0Bh],8
 21908 000048A4 F6470B08                	TEST	byte [BX+dir_entry.dir_attr],attr_volume_id
 21909                                  					; Volume ID file?
 21910 000048A8 7405                    	JZ	short CHKFNAM 		; NO
 21911                                  
 21912                                  ;hkn; SS override
 21913 000048AA 36FE06[3805]            	INC	BYTE [SS:VOLID]
 21914                                  CHKFNAM:
 21915                                  ;	Context ES
 21916 000048AF 8CD6                    	MOV	SI,SS
 21917 000048B1 8EC6                    	MOV	ES,SI
 21918 000048B3 89DE                    	MOV	SI,BX
 21919                                  
 21920                                  ;hkn; NAME1 is in DOSDATA
 21921 000048B5 BF[0805]                	MOV	DI,NAME1
 21922                                  ;;;;; 7/29/86
 21923                                  
 21924                                  ;hkn; SS override for NAME1
 21925 000048B8 36803E[0805]E5          	CMP	BYTE [SS:NAME1],0E5H	; special char check
 21926 000048BE 7506                    	JNZ	short NO_E5
 21927 000048C0 36C606[0805]05          	MOV	BYTE [SS:NAME1],05H
 21928                                  NO_E5:
 21929                                  ;;;;; 7/29/86
 21930 000048C6 E86100                  	CALL	MetaCompare
 21931 000048C9 7428                    	JZ	short FOUND
 21932 000048CB 1F                      	POP	DS
 21933                                  
 21934                                  	;entry	NEXTENT
 21935                                  NEXTENT:
 21936 000048CC C42E[4605]              	LES	BP,[THISDPB]
 21937 000048D0 E86600                  	CALL	NEXTENTRY
 21938 000048D3 73BD                    	JNC	short SRCH
 21939 000048D5 EB50                    	JMP	SHORT SETESRET
 21940                                  
 21941                                  FREE:
 21942 000048D7 1F                      	POP	DS
 21943 000048D8 8B0E[1203]              	MOV	CX,[LASTENT]
 21944 000048DC 3B0E[9405]              	CMP	CX,[ENTFREE]
 21945 000048E0 7304                    	JAE	short TSTALL
 21946 000048E2 890E[9405]              	MOV	[ENTFREE],CX
 21947                                  TSTALL:
 21948 000048E6 3A26[3B05]              	CMP	AH,[DELALL]		; At end of directory?
 21949                                  NEXTENTJ:
 21950 000048EA 74E0                    	je	short NEXTENT 		; No - continue search
 21951 000048EC 890E[9605]              	MOV	[ENTLAST],CX
 21952 000048F0 F9                      	STC
 21953 000048F1 EB34                    	JMP	SHORT SETESRET
 21954                                  
 21955                                  FOUND:
 21956                                  ;
 21957                                  ; We have a file with a matching name. We must now consider the attributes:
 21958                                  ; ATTRIB	Action
 21959                                  ; ------	------
 21960                                  ; Volume_ID	Is Volume_ID in test?
 21961                                  ; Otherwise	If no create then Is ATTRIB+extra superset of test?
 21962                                  ;		If create then Is ATTRIB equal to test?
 21963                                  ;
 21964 000048F3 8A2C                    	MOV	CH,[SI] 		; Attributes of file
 21965 000048F5 1F                      	POP	DS
 21966 000048F6 8A26[2805]              	MOV	AH,[ATTRIB]		; Attributes of search
 21967                                  	;and	ah,9Eh
 21968 000048FA 80E4DE                  	AND	AH,~attr_ignore
 21969                                  	;lea	si,[si+15]
 21970 000048FD 8D740F                  	LEA	SI,[SI+dir_entry.dir_first-dir_entry.dir_attr]
 21971                                  					; point to first cluster field
 21972                                  	;test	ch,8
 21973 00004900 F6C508                  	TEST	CH,attr_volume_id	; Volume ID file?
 21974 00004903 7409                    	JZ	short check_one_volume_id ; Nope check other attributes
 21975                                  	;test	ah,8
 21976 00004905 F6C408                  	TEST	AH,attr_volume_id	; Can we find Volume ID?
 21977                                  	;JZ	short NEXTENTJ		; Nope, (not even $FCB_CREATE)
 21978 00004908 74C2                    	jz	short NEXTENT ; 19/05/2019
 21979 0000490A 30E4                    	XOR	AH,AH			; Set zero flag for $FCB_CREATE
 21980 0000490C EB11                    	JMP	SHORT RETFF		; Found Volume ID
 21981                                  check_one_volume_id:
 21982                                  	;CMP	ah,8
 21983 0000490E 80FC08                  	CMP	AH,attr_volume_id	; Looking only for Volume ID?
 21984                                  	;JZ	short NEXTENTJ		; Yes, continue search
 21985 00004911 74B9                    	je	short NEXTENT ; 19/05/2019
 21986 00004913 E8B403                  	CALL	MatchAttributes
 21987 00004916 7407                    	JZ	SHORT RETFF
 21988 00004918 F606[3A05]FF            	TEST	BYTE [CREATING],-1	; Pass back mismatch if creating
 21989                                  	;JZ	short NEXTENTJ		; Otherwise continue searching
 21990 0000491D 74AD                    	jz	short NEXTENT ; 19/05/2019
 21991                                  RETFF:
 21992 0000491F C42E[4605]              	LES	BP,[THISDPB]
 21993 00004923 268A6600                	MOV	AH,[ES:BP]
 21994                                  	;MOV	AH,[ES:BP+DPB.DRIVE]  ; mov ah,[es:bp+0]
 21995                                  SETESRET:
 21996 00004927 16                      	PUSH	SS
 21997 00004928 07                      	POP	ES
 21998 00004929 C3                      	retn
 21999                                  
 22000                                  ;----------------------------------------------------------------------------
 22001                                  ;
 22002                                  ; Procedure Name : MetaCompare
 22003                                  ;
 22004                                  ; Inputs:
 22005                                  ;	DS:SI -> 11 character FCB style name NO '?'
 22006                                  ;	    Typically this is a directory entry.  It MUST be in upper case
 22007                                  ;	ES:DI -> 11 character FCB style name with possible '?'
 22008                                  ;	    Typically this is a FCB or SFT.  It MUST be in upper case
 22009                                  ; Function:
 22010                                  ;	Compare FCB style names allowing for ? match to any char
 22011                                  ; Outputs:
 22012                                  ;	Zero if match else NZ
 22013                                  ; Destroys CX,SI,DI all others preserved
 22014                                  ;----------------------------------------------------------------------------
 22015                                  
 22016                                  MetaCompare:
 22017 0000492A B90B00                  	MOV	CX,11
 22018                                  WILDCRD:
 22019 0000492D F3A6                    	REPE	CMPSB
 22020 0000492F 7407                    	JZ	short MetaRet 		; most of the time we will fail.
 22021                                  CHECK_META:
 22022 00004931 26807DFF3F              	CMP	BYTE [ES:DI-1],"?"
 22023 00004936 74F5                    	JZ	short WILDCRD
 22024                                  MetaRet:
 22025 00004938 C3                       	retn				; Zero set, Match
 22026                                  
 22027                                  ;Break	<NEXTENTRY -- STEP THROUGH DIRECTORY>
 22028                                  ;----------------------------------------------------------------------------
 22029                                  ;
 22030                                  ; Procedure Name : NEXTENTRY
 22031                                  ;
 22032                                  ; Inputs:
 22033                                  ;	Same as outputs of GETENTRY, above
 22034                                  ; Function:
 22035                                  ;	Update BX, and [LASTENT] for next directory entry.
 22036                                  ;	Carry set if no more.
 22037                                  ;----------------------------------------------------------------------------
 22038                                  
 22039                                  NEXTENTRY:
 22040                                  	; 23/07/2019 - Retro DOS v3.2
 22041                                  	; 19/05/2019 - Retro DOS v4.0
 22042                                  	; DOSCODE:7D88h (MSDOS 6.21, MSDOS.SYS)
 22043                                  	; 27/07/2018 - Retro DOS v3.0
 22044                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 4671h 
 22045                                  	; 15/03/2018 - Retro DOS v2.0
 22046                                  
 22047 00004939 A1[1203]                	MOV	AX,[LASTENT]
 22048 0000493C 3B06[9605]              	CMP	AX,[ENTLAST]
 22049 00004940 7422                    	JZ	short NONE
 22050 00004942 40                      	INC	AX
 22051                                  	;ADD	BX,32
 22052 00004943 8D5F20                  	LEA	BX,[BX+32]
 22053 00004946 39D3                    	CMP	BX,DX
 22054 00004948 721C                    	JB	short HAVIT
 22055                                  	;jne	short HAVIT ; MSDOS 6.21 (DOSCODE:7D97h)
 22056 0000494A 8A1E[3005]              	MOV	BL,[SECCLUSPOS]
 22057 0000494E FEC3                    	INC	BL
 22058 00004950 3A1E[3405]              	CMP	BL,[CLUSFAC]
 22059 00004954 7215                    	JB	short SAMECLUS
 22060 00004956 8B1E[9805]              	MOV	BX,[NXTCLUSNUM]
 22061 0000495A E8BB13                  	call	IsEOF
 22062 0000495D 7305                    	JAE	short NONE
 22063                                  	; 23/07/2019
 22064 0000495F 83FB02                  	CMP	BX,2
 22065                                  	;JB	short NONE
 22066                                  	;JMP	short GETENT
 22067 00004962 7332                    	jnb	short GETENT
 22068                                  NONE:
 22069 00004964 F9                      	STC
 22070 00004965 C3                      	retn
 22071                                  HAVIT:
 22072 00004966 A3[1203]                	MOV	[LASTENT],AX
 22073 00004969 F8                      	CLC
 22074                                  nextentry_retn:
 22075 0000496A C3                      	retn
 22076                                  SAMECLUS:
 22077 0000496B 881E[3005]              	MOV	[SECCLUSPOS],BL
 22078 0000496F A3[1203]                	MOV	[LASTENT],AX
 22079 00004972 1E                      	PUSH	DS
 22080 00004973 C53E[9E05]              	LDS	DI,[CURBUF]
 22081                                  
 22082                                  	; 22/07/2019 - Retro DOS v3.2
 22083                                  	; MSDOS 6.0
 22084                                  	;mov	dx,[di+8]
 22085 00004977 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 22086                                  ;hkn; SS override
 22087                                  	;MOV	[ss:HIGH_SECTOR],DX		;AN000; >32mb
 22088 0000497A 2E8916[B005]            	mov	[cs:HIGH_SECTOR],dx ; 23/07/2019
 22089                                  	;mov	dx,[di+6]
 22090 0000497F 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector]	;AN000; >32mb
 22091                                  	;inc	dx  ; MSDOS 3.3
 22092 00004982 83C201                  	ADD	DX,1				;AN000; >32mb
 22093                                  	;ADC	word [ss:HIGH_SECTOR],0 		;AN000; >32mb
 22094 00004985 2E8316[B005]00          	adc	word [cs:HIGH_SECTOR],0 ; 23/07/2019
 22095 0000498B 1F                      	POP	DS
 22096 0000498C E886F8                  	call	FIRSTCLUSTER
 22097 0000498F 31DB                    	XOR	BX,BX
 22098 00004991 EB23                    	JMP	short SETENTRY
 22099                                  
 22100                                  ;----------------------------------------------------------------------------
 22101                                  ;
 22102                                  ; Procedure Name : GETENTRY
 22103                                  ;
 22104                                  ; Inputs:
 22105                                  ;	[LASTENT] has directory entry
 22106                                  ;	ES:BP points to drive parameters
 22107                                  ;	[DIRSEC],[CLUSNUM],[CLUSFAC],[ENTLAST] set for DIR involved
 22108                                  ; Function:
 22109                                  ;	Locates directory entry in preparation for search
 22110                                  ;	GETENT provides entry for passing desired entry in AX
 22111                                  ; Outputs:
 22112                                  ;	[CURBUF+2]:BX = Pointer to next directory entry in CURBUF
 22113                                  ;	[CURBUF+2]:DX = Pointer to first byte after end of CURBUF
 22114                                  ;	[LASTENT] = New directory entry number
 22115                                  ;	[NXTCLUSNUM],[SECCLUSPOS] set via DIRREAD
 22116                                  ;	Carry set if error (currently user FAILed to I 24)
 22117                                  ;----------------------------------------------------------------------------
 22118                                  
 22119                                  GETENTRY:
 22120                                  	; 27/07/2018 - Retro DOS v3.0
 22121 00004993 A1[1203]                	MOV	AX,[LASTENT]
 22122                                  
 22123                                  	;entry	GETENT
 22124                                  GETENT:
 22125 00004996 A3[1203]                	MOV	[LASTENT],AX
 22126                                  ;
 22127                                  ; Convert the entry number in AX into a byte offset from the beginning of the
 22128                                  ; directory.
 22129                                  ;
 22130 00004999 B105                    	mov	cl,5			; shift left by 5 = mult by 32
 22131 0000499B D3C0                    	rol	ax,cl			; keep hight order bits
 22132 0000499D 89C2                    	mov	dx,ax
 22133                                  	;and	ax,0FFE0h
 22134                                  	;;and	ax,~(32-1)		; mask off high order bits
 22135 0000499F 24E0                    	and	al,0E0h ; ~31 ; 19/05/2019
 22136 000049A1 83E21F                  	and	dx,1Fh
 22137                                  	;and	dx,32-1			; mask off low order bits
 22138                                  ;
 22139                                  ; DX:AX contain the byte offset of the required directory entry from the
 22140                                  ; beginning of the directory. Convert this to a sector number. Round the
 22141                                  ; sector size down to a multiple of 32.
 22142                                  ;
 22143                                  	;mov	bx,[es:bp+2]
 22144 000049A4 268B5E02                	MOV	BX,[ES:BP+DPB.SECTOR_SIZE]
 22145 000049A8 80E3E0                  	and	bl,0E0h
 22146                                  	;AND	BL,255-31		; Must be multiple of 32
 22147 000049AB F7F3                    	DIV	BX
 22148 000049AD 89D3                    	MOV	BX,DX			; Position within sector
 22149 000049AF 53                      	PUSH	BX
 22150 000049B0 E809F8                  	call	DIRREAD
 22151 000049B3 5B                      	POP	BX
 22152                                  	;retc
 22153 000049B4 72B4                    	jc	short nextentry_retn	
 22154                                  SETENTRY:
 22155 000049B6 8B16[9E05]              	MOV	DX,[CURBUF]
 22156                                  	;add	dx,16 ; MSDOS 3.3
 22157                                  	;add	dx,20 ; MSDOS 6.0 
 22158 000049BA 83C214                  	ADD	DX,BUFINSIZ
 22159 000049BD 01D3                    	ADD	BX,DX
 22160                                  	;add	dx,[es:bp+2]
 22161 000049BF 26035602                	ADD	DX,[ES:BP+DPB.SECTOR_SIZE]  ; Always clears carry
 22162 000049C3 C3                      	retn
 22163                                  
 22164                                  ; 23/07/2019 - Retro DOS v3.2
 22165                                  
 22166                                  ;Break	<SETDIRSRCH SETROOTSRCH -- Set Search environments>
 22167                                  ;----------------------------------------------------------------------------
 22168                                  ;
 22169                                  ; Procedure Name : SETDIRSRCH,SETROOTSRCH
 22170                                  ;
 22171                                  ; Inputs:
 22172                                  ;	BX cluster number of start of directory
 22173                                  ;	ES:BP Points to DPB
 22174                                  ;	DI next cluster number from fastopen extended info. DOS 3.3 only
 22175                                  ; Function:
 22176                                  ;	Set up a directory search
 22177                                  ; Outputs:
 22178                                  ;	[DIRSTART] = BX
 22179                                  ;	[CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
 22180                                  ;	Carry set if error (currently user FAILed to I 24)
 22181                                  ; destroys AX,DX,BX
 22182                                  ;----------------------------------------------------------------------------
 22183                                  
 22184                                  SETDIRSRCH:
 22185 000049C4 09DB                    	OR	BX,BX
 22186 000049C6 7438                    	JZ	short SETROOTSRCH
 22187 000049C8 891E[7E05]              	MOV	[DIRSTART],BX
 22188                                  	;mov	al,[es:bp+4]
 22189 000049CC 268A4604                	MOV	AL,[ES:BP+DPB.CLUSTER_MASK]
 22190 000049D0 FEC0                    	INC	AL
 22191 000049D2 A2[3405]                	MOV	[CLUSFAC],AL
 22192                                  
 22193                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 22194                                  	;SAVE	<SI>
 22195 000049D5 56                      	push	si
 22196                                  	;test	byte [FastOpenFlg],2
 22197 000049D6 F606[A40F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 22198 000049DB 7507                    	JNZ	short UNP_OK
 22199                                  
 22200                                  ; DOS 3.3 for FastOPen	F.C. 6/12/86
 22201                                  	;invoke	UNPACK
 22202 000049DD E84F13                  	call	UNPACK
 22203 000049E0 7302                    	JNC	short UNP_OK
 22204                                  	;RESTORE <SI>
 22205 000049E2 5E                      	pop	si
 22206                                  	;return
 22207 000049E3 C3                      	retn
 22208                                  
 22209                                  UNP_OK:
 22210 000049E4 893E[7805]              	MOV	[CLUSNUM],DI
 22211 000049E8 89DA                    	MOV	DX,BX
 22212 000049EA 30DB                    	XOR	BL,BL
 22213 000049EC 881E[3005]              	MOV	[SECCLUSPOS],BL
 22214                                  	;invoke	FIGREC
 22215 000049F0 E8010D                  	call	FIGREC
 22216                                  	;RESTORE <SI>
 22217 000049F3 5E                      	pop	si
 22218                                  	
 22219                                  	; 19/05/2019 - Retro DOS v4.0
 22220                                  	; 23/07/2019 - Retro DOS v3.2
 22221                                  
 22222                                  	; MSDOS 6.0
 22223                                  	;PUSH	DX			   ;AN000; >32mb
 22224                                  	;MOV	DX,[HIGH_SECTOR]	   ;AN000; >32mb
 22225                                  	;MOV	[DIRSEC+2],DX		   ;AN000; >32mb
 22226                                  	;POP	DX			   ;AN000; >32mb
 22227 000049F4 A1[B005]                	mov	ax,[HIGH_SECTOR]
 22228 000049F7 A3[7C05]                	mov	[DIRSEC+2],AX
 22229                                  	
 22230 000049FA 8916[7A05]              	MOV	[DIRSEC],DX
 22231 000049FE F8                      	CLC
 22232 000049FF C3                      	retn
 22233                                  
 22234                                  	;entry	SETROOTSRCH
 22235                                  SETROOTSRCH:
 22236 00004A00 31C0                    	XOR	AX,AX
 22237 00004A02 A3[7E05]                	MOV	[DIRSTART],AX
 22238 00004A05 A2[3005]                	MOV	[SECCLUSPOS],AL
 22239 00004A08 48                      	DEC	AX
 22240 00004A09 A3[7805]                	MOV	[CLUSNUM],AX
 22241                                  	;mov	ax,[es:bp+0Bh]
 22242 00004A0C 268B460B                	MOV	AX,[ES:BP+DPB.FIRST_SECTOR]
 22243                                  	; 19/05/2019
 22244                                  	;;mov	dx,[es:bp+10h] ; MSDOS 3.3
 22245                                  	;mov	dx,[es:bp+11h] ; MSDOS 6.0
 22246 00004A10 268B5611                	MOV	DX,[ES:BP+DPB.DIR_SECTOR]
 22247 00004A14 29D0                    	SUB	AX,DX
 22248 00004A16 A2[3405]                	MOV	[CLUSFAC],AL
 22249 00004A19 8916[7A05]              	MOV	[DIRSEC],DX		      ;F.C. >32mb
 22250                                  	; MSDOS 6.0
 22251 00004A1D C706[7C05]0000          	MOV	WORD [DIRSEC+2],0	      ;F.C. >32mb
 22252 00004A23 F8                      	CLC
 22253 00004A24 C3                      	retn
 22254                                  
 22255                                  ;============================================================================
 22256                                  ; DIR2.ASM, MSDOS 6.0, 1991
 22257                                  ;============================================================================
 22258                                  ; 27/07/2018 - Retro DOS v3.0 
 22259                                  
 22260                                  ;	TITLE	DIR2 - Directory and path cracking
 22261                                  ;	NAME	Dir2
 22262                                  
 22263                                  ;Break	<GETPATH -- PARSE A WFP>
 22264                                  ;----------------------------------------------------------------------------
 22265                                  ;
 22266                                  ; Procedure Name : GETPATH
 22267                                  ;
 22268                                  ; Inputs:
 22269                                  ;	[WFP_START] Points to WFP string ("d:\" must be first 3 chars, NUL
 22270                                  ;		terminated; d:/ (note forward slash) indicates a real device).
 22271                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 22272                                  ;		( = -1 if current dir not involved, else
 22273                                  ;		 Points to first char after last "/" of current dir part)
 22274                                  ;	[THISCDS] Points to CDS being used
 22275                                  ;	[SATTRIB] Is attribute of search, determines what files can be found
 22276                                  ;	[NoSetDir] set
 22277                                  ;	[THISDPB] set to DPB if disk otherwise garbage.
 22278                                  ; Function:
 22279                                  ;	Crack the path
 22280                                  ; Outputs:
 22281                                  ;	Sets EXTERR_LOCUS = errLOC_Disk if disk file
 22282                                  ;	Sets EXTERR_LOCUS = errLOC_Unk if char device
 22283                                  ;	ID1 field of [THISCDS] updated appropriately
 22284                                  ;	[ATTRIB] = [SATTRIB]
 22285                                  ;	ES:BP Points to DPB
 22286                                  ;	Carry set if bad path
 22287                                  ;	   SI Points to path element causing failure
 22288                                  ;	   Zero set
 22289                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 22290                                  ;	      start a search on the last directory
 22291                                  ;	      CL is zero if there is a bad name in the path
 22292                                  ;	      CL is non-zero if the name was simply not found
 22293                                  ;		 [ENTFREE] may have free spot in directory
 22294                                  ;		 [NAME1] is the name.
 22295                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 22296                                  ;	   Zero reset
 22297                                  ;	      File in middle of path or bad name in path or attribute mismatch
 22298                                  ;		or path too long or malformed path
 22299                                  ;	ELSE
 22300                                  ;	   [CurBuf] = -1 if root directory
 22301                                  ;	   [CURBUF] contains directory record with match
 22302                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 22303                                  ;	   [CURBUF+2]:SI Points into [CURBUF] to dir_first field for entry
 22304                                  ;	   AH = device ID
 22305                                  ;	      bit 7 of AH set if device SI and BX
 22306                                  ;	      will point DOSGROUP relative The firclus
 22307                                  ;	      field of the device entry contains the device pointer
 22308                                  ;	   [NAME1] Has name looked for
 22309                                  ;	   If last element is a directory zero is set and:
 22310                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 22311                                  ;	      are set up to start a search on it.
 22312                                  ;	      unless [NoSetDir] is non zero in which case the return is
 22313                                  ;	      like that for a file (except for zero flag)
 22314                                  ;	   If last element is a file zero is reset
 22315                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 22316                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 22317                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 22318                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 22319                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 22320                                  ; DS preserved, Others destroyed
 22321                                  ;---------------------------------------------------------------------------
 22322                                  
 22323                                  ;hkn; called from delete.asm, finfo.asm, mknode.asm and rename.asm.
 22324                                  ;hkn; DS already set up at this point.
 22325                                  
 22326                                  GETPATH:
 22327                                  	;mov	word [CREATING],0E500h
 22328 00004A25 C706[3A05]00E5          	MOV	WORD [CREATING],DIRFREE*256+0 ; Not Creating, not DEL *.*
 22329                                  
 22330                                  ; Same as GetPath only CREATING and DELALL already set
 22331                                  
 22332                                  	;entry	GetPathNoSet
 22333                                  GetPathNoSet:
 22334                                  	;mov	byte [EXTERR_LOCUS],2	
 22335 00004A2B C606[EF02]02            	MOV	byte [EXTERR_LOCUS],errLOC_Disk
 22336 00004A30 C706[9E05]FFFF          	MOV	word [CURBUF],-1	; initial setting
 22337                                  
 22338                                  ; See if the input indicates a device that has already been detected. If so,
 22339                                  ; go build the guy quickly. Otherwise, let findpath find the device.
 22340                                  
 22341 00004A36 8B3E[6E05]              	MOV	DI,[WFP_START]		; point to the beginning of the name
 22342                                  	;cmp	word [DI+1],5C3Ah
 22343                                  	;CMP	WORD [DI+1],'\' << 8 + ':'
 22344 00004A3A 817D013A5C              	cmp	word [DI+1],':\'
 22345 00004A3F 7438                    	JZ	short CrackIt
 22346                                  
 22347                                  ; Let ChkDev find it in the device list
 22348                                  
 22349 00004A41 83C703                  	ADD	DI,3
 22350                                  	; 18/08/2018
 22351                                  	;MOV	SI,DI			; let CHKDEV see the original name
 22352 00004A44 E8B000                  	CALL	CHKDEV
 22353 00004A47 722E                    	JC	short InternalError
 22354                                  Build_devJ:
 22355                                  
 22356 00004A49 A0[2A05]                	MOV	AL,[SATTRIB]
 22357 00004A4C A2[2805]                	MOV	[ATTRIB],AL
 22358                                  	;mov	byte [EXTERR_LOCUS],1
 22359 00004A4F C606[EF02]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; In the particular case of
 22360                                  					; "finding" a char device
 22361                                  					; set LOCUS to Unknown. This makes
 22362                                  					; certain idiotic problems reported
 22363                                  					; by a certain 3 letter OEM go away.
 22364                                  
 22365                                  ; Take name in name1 and pack it back into where wfp_start points. This
 22366                                  ; guarantees wfp_start pointing to a canonical representation of a device.
 22367                                  ; We are allowed to do this as GetPath is *ALWAYS* called before entering a
 22368                                  ; wfp into the share set.
 22369                                  ;
 22370                                  ; We copy chars from name1 to wfp_start remembering the position of the last
 22371                                  ; non-space seen +1.  This position is kept in DX.
 22372                                  
 22373                                  ;hkn; SS is DOSDATA
 22374 00004A54 16                      	push	ss
 22375 00004A55 07                      	pop	es
 22376                                  
 22377                                  ;hkn; NAME1 is in DOSDATA
 22378 00004A56 BE[0805]                	mov	si,NAME1
 22379 00004A59 8B3E[6E05]              	mov	di,[WFP_START]
 22380 00004A5D 89FA                    	mov	dx,di
 22381 00004A5F B90800                  	mov	cx,8			; 8 chars in device name
 22382                                  MoveLoop:
 22383 00004A62 AC                      	lodsb
 22384 00004A63 AA                      	stosb
 22385 00004A64 3C20                    	cmp	al," "
 22386 00004A66 7402                    	jz	short NoSave
 22387                                  
 22388 00004A68 89FA                    	mov	dx,di
 22389                                  NoSave:
 22390 00004A6A E2F6                    	loop	MoveLoop
 22391                                  ;
 22392                                  ; DX is the position of the last seen non-space + 1. We terminate the name
 22393                                  ; at this point.
 22394                                  ;
 22395 00004A6C 89D7                    	mov	di,dx
 22396 00004A6E C60500                  	mov	byte [di],0		; end of string
 22397 00004A71 E8C302                  	call	Build_device_ent	; Clears carry sets zero
 22398 00004A74 FEC0                    	INC	AL			; reset zero
 22399 00004A76 C3                      	retn
 22400                                  
 22401                                  InternalError:
 22402                                  InternalError_loop:
 22403 00004A77 EBFE                    	JMP	short InternalError_loop	; freeze
 22404                                  
 22405                                  ; Start off at the correct spot. Optimize if the current dir part is valid.
 22406                                  
 22407                                  CrackIt:
 22408 00004A79 8B36[7205]              	MOV	SI,[CURR_DIR_END]	; get current directory pointer
 22409 00004A7D 83FEFF                  	CMP	SI,-1			; valid?
 22410 00004A80 7503                    	JNZ	short LOOK_SING		; Yes, use it.
 22411 00004A82 8D7503                  	LEA	SI,[DI+3]		; skip D:\.
 22412                                  LOOK_SING:
 22413                                  	;mov	byte [ATTRIB],16h
 22414 00004A85 C606[2805]16            	MOV	byte [ATTRIB],attr_directory+attr_system+attr_hidden
 22415                                  					; Attributes to search through Dirs
 22416 00004A8A C43E[5E05]              	LES	DI,[THISCDS]
 22417 00004A8E B8FFFF                  	MOV	AX,-1
 22418                                  	;mov	bx,[es:di+73]
 22419 00004A91 268B5D49                	MOV	BX,[ES:DI+curdir.ID]
 22420 00004A95 8B36[7205]              	MOV	SI,[CURR_DIR_END]
 22421                                  
 22422                                  ; AX = -1
 22423                                  ; BX = cluster number of current directory.  THis number is -1 if the media
 22424                                  ;      has been uncertainly changed.
 22425                                  ; SI = offset in DOSGroup into path to end of current directory text.  This
 22426                                  ;      may be -1 if no current directory part has been used.
 22427                                  
 22428 00004A99 39C6                    	CMP	SI,AX			; if Current directory is not part
 22429 00004A9B 7440                    	JZ	short NO_CURR_D		; then we must crack from root
 22430 00004A9D 39C3                    	CMP	BX,AX			; is the current directory cluster valid
 22431                                  
 22432                                  ; DOS 3.3  6/25/86
 22433 00004A9F 743C                    	JZ	short NO_CURR_D		; no, crack form the root
 22434                                  	;test	byte [FastOpenFlg],1
 22435 00004AA1 F606[A40F]01            	TEST	byte [FastOpenFlg],FastOpen_Set ; for fastopen ?
 22436 00004AA6 7442                    	JZ	short GOT_SEARCH_CLUSTER	; no
 22437 00004AA8 06                      	PUSH	ES			; save registers
 22438 00004AA9 57                      	PUSH	DI
 22439 00004AAA 51                      	PUSH	CX
 22440 00004AAB FF74FF                  	PUSH	word [SI-1]		; save \ and 1st char of next element
 22441 00004AAE 56                      	PUSH	SI
 22442 00004AAF 53                      	PUSH	BX
 22443                                  
 22444 00004AB0 C644FF00                	MOV	BYTE [SI-1],0		; call fastopen to look up cur dir info
 22445 00004AB4 8B36[6E05]              	MOV	SI,[WFP_START]
 22446                                  
 22447                                  ;hkn; FastOpenTable, Dir_Info_Buff & FastOpen_Ext_Info are in DOSDATA
 22448 00004AB8 BB[730F]                	MOV	BX,FastOpenTable
 22449 00004ABB BF[840F]                	MOV	DI,Dir_Info_Buff
 22450 00004ABE B9[790F]                	MOV	CX,FastOpen_Ext_Info
 22451                                  	;mov	al,1
 22452 00004AC1 B001                    	MOV	AL,FONC_Look_up
 22453 00004AC3 1E                      	PUSH	DS
 22454 00004AC4 07                      	POP	ES
 22455                                  	;call	far [BX+2]
 22456 00004AC5 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching]
 22457 00004AC8 7208                    	JC	short GO_Chk_end1 	;fastopen not installed, or wrong drive.
 22458                                  					; Go to Got_Srch_cluster
 22459 00004ACA 803C00                  	CMP	BYTE [SI],0		;fastopen has current dir info?
 22460 00004ACD 7404                    	JE	short GO_Chk_end	;yes. Go to got_search_cluster
 22461 00004ACF F9                      	stc
 22462 00004AD0 EB01                    	jmp	short GO_Chk_end	;Go to No_Curr_D
 22463                                  GO_Chk_end1:
 22464 00004AD2 F8                      	clc
 22465                                  GO_Chk_end:				; restore registers
 22466 00004AD3 5B                      	POP	BX
 22467 00004AD4 5E                      	POP	SI
 22468 00004AD5 8F44FF                  	POP	word [SI-1]
 22469 00004AD8 59                      	POP	CX
 22470 00004AD9 5F                      	POP	DI
 22471 00004ADA 07                      	POP	ES
 22472 00004ADB 730D                    	JNC	short GOT_SEARCH_CLUSTER ; crack based on cur dir
 22473                                  
 22474                                  ; DOS 3.3  6/25/86
 22475                                  ;
 22476                                  ; We must cract the path beginning at the root. Advance pointer to beginning
 22477                                  ; of path and go crack from root.
 22478                                  
 22479                                  NO_CURR_D:
 22480 00004ADD 8B36[6E05]              	MOV	SI,[WFP_START]
 22481 00004AE1 8D7403                  	LEA	SI,[SI+3]		; Skip "d:/"
 22482 00004AE4 C42E[4605]              	LES	BP,[THISDPB]		; Get ES:BP
 22483 00004AE8 EB3D                    	JMP	short ROOTPATH
 22484                                  
 22485                                  ; We are able to crack from the current directory part. Go set up for search
 22486                                  ; of specified cluster.
 22487                                  
 22488                                  GOT_SEARCH_CLUSTER:
 22489 00004AEA C42E[4605]              	LES	BP,[THISDPB]		; Get ES:BP
 22490 00004AEE E8D3FE                  	call	SETDIRSRCH
 22491                                  	;JC	short SETFERR
 22492                                  	;JMP	short FINDPATH
 22493 00004AF1 7345                    	jnc	short FINDPATH ; 17/08/2018
 22494                                  SETFERR:
 22495 00004AF3 30C9                    	XOR	CL,CL			; set zero
 22496 00004AF5 F9                      	STC
 22497 00004AF6 C3                      	retn
 22498                                  
 22499                                  ;---------------------------------------------------------------------------
 22500                                  ;
 22501                                  ; Procedure Name : ChkDev
 22502                                  ;
 22503                                  ; Check to see if the name at DS:DI is a device. Returns carry set if not a
 22504                                  ;   device.
 22505                                  ; Blasts CX,SI,DI,AX,BX
 22506                                  ;---------------------------------------------------------------------------
 22507                                  
 22508                                  CHKDEV:
 22509 00004AF7 89FE                    	MOV	SI,DI
 22510 00004AF9 8CD7                    	MOV	DI,SS
 22511 00004AFB 8EC7                    	MOV	ES,DI
 22512                                  
 22513 00004AFD BF[0805]                	MOV	DI,NAME1
 22514 00004B00 B90900                  	MOV	CX,9
 22515                                  TESTLOOP:
 22516 00004B03 E8E80D                  	call	GETLET
 22517                                  
 22518 00004B06 3C2E                    	CMP	AL,'.'
 22519 00004B08 740E                    	JZ	short TESTDEVICE
 22520 00004B0A E81E0E                  	call	PATHCHRCMP
 22521 00004B0D 7407                    	JZ	short NOTDEV
 22522 00004B0F 08C0                    	OR	AL,AL
 22523 00004B11 7405                    	JZ	short TESTDEVICE
 22524                                  
 22525 00004B13 AA                      	STOSB
 22526 00004B14 E2ED                    	LOOP	TESTLOOP
 22527                                  NOTDEV:
 22528 00004B16 F9                      	STC
 22529 00004B17 C3                      	retn
 22530                                  
 22531                                  TESTDEVICE:
 22532 00004B18 83C102                  	ADD	CX,2
 22533 00004B1B B020                    	MOV	AL,' '
 22534 00004B1D F3AA                    	REP	STOSB
 22535 00004B1F 8CD0                    	MOV	AX,SS
 22536 00004B21 8ED8                    	MOV	DS,AX
 22537 00004B23 E8B101                  	call	DEVNAME
 22538 00004B26 C3                      	retn
 22539                                  
 22540                                  ;Break	<ROOTPATH, FINDPATH -- PARSE A PATH>
 22541                                  ;----------------------------------------------------------------------------
 22542                                  ;
 22543                                  ; Procedure Name : ROOTPATH,FINDPATH
 22544                                  ;
 22545                                  ; Inputs:
 22546                                  ;	Same as FINDPATH but,
 22547                                  ;	SI Points to asciz string of path which is assumed to start at
 22548                                  ;		the root (no leading '/').
 22549                                  ; Function:
 22550                                  ;	Search from root for path
 22551                                  ; Outputs:
 22552                                  ;	Same as FINDPATH but:
 22553                                  ;	If root directory specified, [CURBUF] and [NAME1] are NOT set, and
 22554                                  ;	[NoSetDir] is ignored.
 22555                                  ;----------------------------------------------------------------------------
 22556                                  
 22557                                  ROOTPATH:
 22558 00004B27 E8D6FE                  	call	SETROOTSRCH
 22559 00004B2A 803C00                  	CMP	BYTE [SI],0
 22560 00004B2D 7509                    	JNZ	short FINDPATH
 22561                                  
 22562                                  ; Root dir specified
 22563 00004B2F A0[2A05]                	MOV	AL,[SATTRIB]
 22564 00004B32 A2[2805]                	MOV	[ATTRIB],AL
 22565 00004B35 30E4                    	XOR	AH,AH			; Sets "device ID" byte, sets zero
 22566                                  					; (dir), clears carry.
 22567 00004B37 C3                      	retn
 22568                                  
 22569                                  ; Inputs:
 22570                                  ;	[ATTRIB] Set to get through directories
 22571                                  ;	[SATTRIB] Set to find last element
 22572                                  ;	ES:BP Points to DPB
 22573                                  ;	SI Points to asciz string of path (no leading '/').
 22574                                  ;	[SECCLUSPOS] = 0
 22575                                  ;	[DIRSEC] = Phys sec # of first sector of directory
 22576                                  ;	[CLUSNUM] = Cluster # of next cluster
 22577                                  ;	[CLUSFAC] = Sectors per cluster
 22578                                  ;	[NoSetDir] set
 22579                                  ;	[CURR_DIR_END] Points to end of Current dir part of string
 22580                                  ;		( = -1 if current dir not involved, else
 22581                                  ;		 Points to first char after last "/" of current dir part)
 22582                                  ;	[THISCDS] Points to CDS being used
 22583                                  ;	[CREATING] and [DELALL] set
 22584                                  ; Function:
 22585                                  ;	Parse path name
 22586                                  ; Outputs:
 22587                                  ;	ID1 field of [THISCDS] updated appropriately
 22588                                  ;	[ATTRIB] = [SATTRIB]
 22589                                  ;	ES:BP Points to DPB
 22590                                  ;	[THISDPB] = ES:BP
 22591                                  ;	Carry set if bad path
 22592                                  ;	   SI Points to path element causing failure
 22593                                  ;	   Zero set
 22594                                  ;	      [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
 22595                                  ;	      start a search on the last directory
 22596                                  ;	      CL is zero if there is a bad name in the path
 22597                                  ;	      CL is non-zero if the name was simply not found
 22598                                  ;		 [ENTFREE] may have free spot in directory
 22599                                  ;		 [NAME1] is the name.
 22600                                  ;		 CL = 81H if '*'s or '?' in NAME1, 80H otherwise
 22601                                  ;	   Zero reset
 22602                                  ;	      File in middle of path or bad name in path
 22603                                  ;		or path too long or malformed path
 22604                                  ;	ELSE
 22605                                  ;	   [CURBUF] contains directory record with match
 22606                                  ;	   [CURBUF+2]:BX Points into [CURBUF] to start of entry
 22607                                  ;	   [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
 22608                                  ;	   [NAME1] Has name looked for
 22609                                  ;	   AH = device ID
 22610                                  ;	      bit 7 of AH set if device SI and BX
 22611                                  ;	      will point DOSGROUP relative The firclus
 22612                                  ;	      field of the device entry contains the device pointer
 22613                                  ;	   If last element is a directory zero is set and:
 22614                                  ;	      [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
 22615                                  ;	      are set up to start a search on it,
 22616                                  ;	      unless [NoSetDir] is non zero in which case the return is
 22617                                  ;	      like that for a file (except for zero flag)
 22618                                  ;	   If last element is a file zero is reset
 22619                                  ;	      [DIRSEC],[CLUSNUM],[CLUSFAC],[NXTCLUSNUM],[SECCLUSPOS],
 22620                                  ;	      [LASTENT], [ENTLAST] are set to continue search of last
 22621                                  ;	      directory for furthur matches on NAME1 via the NEXTENT
 22622                                  ;	      entry point in FindEntry (or GETENT entry in GETENTRY in
 22623                                  ;	      which case [NXTCLUSNUM] and [SECCLUSPOS] need not be valid)
 22624                                  ; Destroys all other registers
 22625                                  
 22626                                      	;entry	FINDPATH
 22627                                  FINDPATH:
 22628 00004B38 06                      	PUSH	ES			; Save ES:BP
 22629 00004B39 56                      	PUSH	SI
 22630 00004B3A 89F7                    	MOV	DI,SI
 22631 00004B3C 8B0E[7E05]              	MOV	CX,[DIRSTART]		; Get start clus of dir being searched
 22632 00004B40 833E[7205]FF            	CMP	word [CURR_DIR_END],-1
 22633 00004B45 740E                    	JZ	short NOIDS		; No current dir part
 22634 00004B47 3B3E[7205]              	CMP	DI,[CURR_DIR_END]
 22635 00004B4B 7508                    	JNZ	short NOIDS		; Not to current dir end yet
 22636 00004B4D C43E[5E05]              	LES	DI,[THISCDS]
 22637                                  	;mov	[es:di+73],cx
 22638 00004B51 26894D49                	MOV	[ES:DI+curdir.ID],CX	; Set current directory currency
 22639                                  NOIDS:
 22640                                  
 22641                                  ; Parse the name off of DS:SI into NAME1. AL = 1 if there was a meta
 22642                                  ; character in the string. CX,DI may be destroyed.
 22643                                  ;
 22644                                  ;	invoke	NAMETRANS
 22645                                  ;	MOV	CL,AL
 22646                                  ;
 22647                                  ; The above is the slow method. The name has *already* been munged by
 22648                                  ; TransPath so no special casing needs to be done. All we do is try to copy
 22649                                  ; the name until ., \ or 0 is hit.
 22650                                  
 22651 00004B55 8CD0                    	MOV	AX,SS
 22652 00004B57 8EC0                    	MOV	ES,AX
 22653                                  
 22654                                  ;hkn; Name1 is in DOSDATA
 22655 00004B59 BF[0805]                	MOV	DI,NAME1
 22656 00004B5C B82020                  	MOV	AX,'  ' ; 2020h
 22657 00004B5F AA                      	STOSB
 22658 00004B60 AB                      	STOSW
 22659 00004B61 AB                      	STOSW
 22660 00004B62 AB                      	STOSW
 22661 00004B63 AB                      	STOSW
 22662 00004B64 AB                      	STOSW
 22663                                  
 22664                                  ;hkn; Name1 is in DOSDATA
 22665 00004B65 BF[0805]                	MOV	DI,NAME1
 22666 00004B68 30E4                    	XOR	AH,AH			; bits for CL
 22667                                  GetNam:
 22668                                  	;INC	CL			;AN000; KK incrment volid count
 22669 00004B6A AC                      	LODSB
 22670 00004B6B 3C2E                    	CMP	AL,'.'
 22671 00004B6D 7412                    	JZ	short _SetExt
 22672 00004B6F 08C0                    	OR	AL,AL
 22673 00004B71 7424                    	JZ	short _GetDone
 22674 00004B73 3C5C                    	CMP	AL,'\'
 22675 00004B75 7420                    	JZ	short _GetDone
 22676 00004B77 3C3F                    	CMP	AL,'?'
 22677 00004B79 7503                    	JNZ	short StoNam
 22678 00004B7B 80CC01                  	OR	AH,1
 22679                                  StoNam: 
 22680 00004B7E AA                      	STOSB
 22681 00004B7F EBE9                    	JMP	short GetNam
 22682                                  _SetExt:
 22683 00004B81 BF[1005]                	MOV	DI,NAME1+8
 22684                                  GetExt:
 22685 00004B84 AC                      	LODSB
 22686 00004B85 08C0                    	OR	AL,AL
 22687 00004B87 740E                    	JZ	short _GetDone
 22688 00004B89 3C5C                    	CMP	AL,'\'
 22689 00004B8B 740A                    	JZ	short _GetDone
 22690 00004B8D 3C3F                    	CMP	AL,'?'
 22691 00004B8F 7503                    	JNZ	short StoExt
 22692 00004B91 80CC01                  	OR	AH,1
 22693                                  StoExt: 
 22694 00004B94 AA                      	STOSB
 22695 00004B95 EBED                    	JMP	short GetExt
 22696                                  _GetDone:
 22697 00004B97 4E                      	DEC	SI
 22698 00004B98 88E1                    	MOV	CL,AH
 22699 00004B9A 80C980                  	OR	CL,80H
 22700 00004B9D 5F                      	POP	DI			; Start of this element
 22701 00004B9E 07                      	POP	ES			; Restore ES:BP
 22702 00004B9F 39FE                    	CMP	SI,DI
 22703 00004BA1 7503                    	JNZ	short check_device
 22704 00004BA3 E9D800                  	JMP	_BADPATH		; NUL parse (two delims most likely)
 22705                                  check_device:
 22706 00004BA6 56                      	PUSH	SI			; Start of next element
 22707 00004BA7 8A04                    	MOV	AL,[SI]
 22708 00004BA9 08C0                    	OR	AL,AL
 22709 00004BAB 7508                    	JNZ	short NOT_LAST
 22710                                  
 22711                                  ; for last element of the path switch to the correct search attributes
 22712                                  
 22713 00004BAD 8A3E[2A05]              	MOV	BH,[SATTRIB]
 22714 00004BB1 883E[2805]              	MOV	[ATTRIB],BH
 22715                                  
 22716                                  NOT_LAST:
 22717                                  
 22718                                  ; check name1 to see if we have a device...
 22719                                  
 22720 00004BB5 06                      	PUSH	ES			; Save ES:BP
 22721                                  
 22722                                  ;hkn; SS is DOSDATA
 22723                                  	;context ES
 22724 00004BB6 16                      	push	ss
 22725 00004BB7 07                      	pop	es
 22726 00004BB8 E81C01                  	call	DEVNAME 		; blast BX
 22727 00004BBB 07                      	POP	ES			; Restore ES:BP
 22728 00004BBC 720B                    	JC	short FindFile		; Not a device
 22729 00004BBE 08C0                    	OR	AL,AL			; Test next char again
 22730 00004BC0 7403                    	JZ	short GO_BDEV
 22731 00004BC2 E9BD00                  	JMP	FILEINPATH		; Device name in middle of path
 22732                                  
 22733                                  GO_BDEV:
 22734 00004BC5 5E                      	POP	SI			; Points to NUL at end of path
 22735 00004BC6 E980FE                  	JMP	Build_devJ
 22736                                  
 22737                                  FindFile:
 22738                                  ;;;; 7/28/86
 22739 00004BC9 803E[0805]E5            	CMP	BYTE [NAME1],0E5H	; if 1st char = E5
 22740 00004BCE 7505                    	JNZ	short NOE5		; no
 22741 00004BD0 C606[0805]05            	MOV	BYTE [NAME1],05H	; change it to 05
 22742                                  NOE5:
 22743                                  ;;;; 7/28/86
 22744 00004BD5 57                      	PUSH	DI			; Start of this element
 22745 00004BD6 06                      	PUSH	ES			; Save ES:BP
 22746 00004BD7 51                      	PUSH	CX			; CL return from NameTrans
 22747                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 22748                                  
 22749 00004BD8 E88302                  	CALL	LookupPath		; call fastopen to get dir entry
 22750 00004BDB 7303                    	JNC	short DIR_FOUND		; found dir entry
 22751                                  
 22752                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 22753 00004BDD E89BFC                  	call	FINDENTRY
 22754                                  DIR_FOUND:
 22755 00004BE0 59                      	POP	CX
 22756 00004BE1 07                      	POP	ES
 22757 00004BE2 5F                      	POP	DI
 22758 00004BE3 7303                    	JNC	short LOAD_BUF
 22759 00004BE5 E9BF00                  	JMP	BADPATHPOP
 22760                                  
 22761                                  LOAD_BUF:
 22762 00004BE8 C53E[9E05]              	LDS	DI,[CURBUF]
 22763                                  	;test	byte [bx+0Bh],10h
 22764 00004BEC F6470B10                	TEST	BYTE [BX+dir_entry.dir_attr],attr_directory
 22765 00004BF0 7503                    	JNZ	short GO_NEXT 		; DOS 3.3
 22766 00004BF2 E98D00                  	JMP	FILEINPATH		; Error or end of path
 22767                                  
 22768                                  ; if we are not setting the directory, then check for end of string
 22769                                  
 22770                                  GO_NEXT:
 22771                                  ;hkn; SS override
 22772 00004BF5 36803E[1603]00          	CMP	BYTE [SS:NoSetDir],0
 22773 00004BFB 7412                    	JZ	short SetDir
 22774 00004BFD 89FA                    	MOV	DX,DI			; Save pointer to entry
 22775 00004BFF 8CD9                    	MOV	CX,DS
 22776                                  
 22777                                  ;hkn; SS is DOSDATA
 22778                                  	;context DS
 22779 00004C01 16                      	push	ss
 22780 00004C02 1F                      	pop	ds
 22781 00004C03 5F                      	POP	DI			; Start of next element
 22782                                  	; MSDOS 6.0
 22783                                  	;TEST	byte [FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 22784                                  	;JZ	short nofast			; the FastOpen
 22785                                  	;TEST	byte [FastOpenFlg],Lookup_Success ; Lookup just happened
 22786                                  	;JZ	short nofast			; no
 22787                                  	;MOV	DI,[Next_Element_Start]	; no need to insert it again
 22788                                  ;nofast:
 22789 00004C04 803D00                  	CMP	BYTE [DI],0
 22790 00004C07 7501                    	JNZ	short NEXT_ONE		; DOS 3.3
 22791                                  	;JMP	_SETRET			; Got it
 22792 00004C09 C3                      	retn	; 05/09/2018
 22793                                  NEXT_ONE:
 22794 00004C0A 57                      	PUSH	DI			; Put start of next element back on stack
 22795 00004C0B 89D7                    	MOV	DI,DX
 22796 00004C0D 8ED9                    	MOV	DS,CX			; Get back pointer to entry
 22797                                  SetDir:
 22798 00004C0F 8B14                    	MOV	DX,[SI] 		; Dir_first
 22799                                  
 22800                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 22801 00004C11 1E                      	PUSH	DS		      ; save [curbuf+2]
 22802                                  ;hkn; SS is DOSDATA
 22803 00004C12 16                      	push	ss
 22804 00004C13 1F                      	pop	ds		      ; set DS Dosgroup
 22805                                  	;test	byte [FastOpenFlg],2
 22806 00004C14 F606[A40F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 22807 00004C19 7410                    	JZ	short DO_NORMAL	      ; fastopen not in memory or path not
 22808 00004C1B 89D3                    	MOV	BX,DX		      ; not found
 22809 00004C1D 8B3E[7805]              	MOV	DI,[CLUSNUM]	      ; clusnum was set in LookupPath
 22810 00004C21 50                      	PUSH	AX		      ; save device id (AH)
 22811 00004C22 E89FFD                  	call	SETDIRSRCH
 22812 00004C25 58                      	POP	AX		      ; restore device id (AH)
 22813 00004C26 83C402                  	ADD	SP,2		      ; pop ds in stack
 22814 00004C29 EB3D                    	JMP	short FAST_OPEN_SKIP
 22815                                  
 22816                                  DO_NORMAL:
 22817 00004C2B 1F                      	POP	DS			; DS = [curbuf + 2]
 22818                                  ;DOS 3.3 FastOPen 6/12/86 F.C.
 22819                                  
 22820 00004C2C 29FB                    	SUB	BX,DI			; Offset into sector of start of entry
 22821 00004C2E 29FE                    	SUB	SI,DI			; Offset into sector of dir_first
 22822 00004C30 53                      	PUSH	BX
 22823 00004C31 50                      	PUSH	AX
 22824 00004C32 56                      	PUSH	SI
 22825 00004C33 51                      	PUSH	CX
 22826                                  	;push	word [di+6]
 22827 00004C34 FF7506                  	PUSH	WORD [DI+BUFFINFO.buf_sector]	;AN000;>32mb
 22828                                  	; 22/07/2019 - Retro DOS v3.2
 22829                                  	; MSDOS 6.0
 22830                                  	;push	word [di+8]
 22831 00004C37 FF7508                  	PUSH	WORD [DI+BUFFINFO.buf_sector+2]	;AN000;>32mb
 22832 00004C3A 89D3                    	MOV	BX,DX
 22833                                  
 22834                                  ;hkn; SS is DOSDATA
 22835                                  	;context DS
 22836 00004C3C 16                      	push	ss
 22837 00004C3D 1F                      	pop	ds
 22838                                  	;invoke	SETDIRSRCH		; This uses UNPACK which might blow
 22839 00004C3E E883FD                  	call	SETDIRSRCH		; the entry sector buffer
 22840                                  	; MSDOS 6.0
 22841 00004C41 8F06[B005]              	POP	word [HIGH_SECTOR]
 22842 00004C45 5A                      	POP	DX
 22843 00004C46 720A                    	JC	short SKIP_GETB
 22844                                  	;mov	byte [ALLOWED],18h
 22845 00004C48 C606[1503]18            	MOV	byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 22846 00004C4D 30C0                    	XOR	AL,AL
 22847                                  	;invoke	GETBUFFR		; Get the entry buffer back
 22848 00004C4F E84E15                  	call	GETBUFFR
 22849                                  SKIP_GETB:
 22850 00004C52 59                      	POP	CX
 22851 00004C53 5E                      	POP	SI
 22852 00004C54 58                      	POP	AX
 22853 00004C55 5B                      	POP	BX
 22854 00004C56 7305                    	JNC	short SET_THE_BUF ; 19/05/2019
 22855 00004C58 5F                      	POP	DI			; Start of next element
 22856 00004C59 89FE                    	MOV	SI,DI			; Point with SI
 22857 00004C5B EB21                    	JMP	SHORT _BADPATH
 22858                                  
 22859                                  SET_THE_BUF:
 22860 00004C5D E8C1F5                  	call	SET_BUF_AS_DIR
 22861 00004C60 8B3E[9E05]              	MOV	DI,[CURBUF]
 22862 00004C64 01FE                    	ADD	SI,DI			; Get the offsets back
 22863 00004C66 01FB                    	ADD	BX,DI
 22864                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 22865                                  FAST_OPEN_SKIP:
 22866 00004C68 5F                      	POP	DI			; Start of next element
 22867 00004C69 E89602                  	CALL	InsertPath		; insert dir entry info
 22868                                  ; DOS 3.3 FastOpen 6/12/86  F.C.
 22869 00004C6C 8A05                    	MOV	AL,[DI]
 22870 00004C6E 08C0                    	OR	AL,AL
 22871 00004C70 7434                    	JZ	short _SETRET		; At end
 22872 00004C72 47                      	INC	DI			; Skip over "/"
 22873 00004C73 89FE                    	MOV	SI,DI			; Point with SI
 22874 00004C75 E8B30C                  	call	PATHCHRCMP
 22875 00004C78 7503                    	JNZ	short find_bad_name	; oops
 22876 00004C7A E9BBFE                  	JMP	FINDPATH		; Next element
 22877                                  
 22878                                  find_bad_name:
 22879 00004C7D 4E                      	DEC	SI			; Undo above INC to get failure point
 22880                                  _BADPATH:
 22881 00004C7E 30C9                    	XOR	CL,CL			; Set zero
 22882 00004C80 EB2C                    	JMP	SHORT BADPRET
 22883                                  
 22884                                  FILEINPATH:
 22885 00004C82 5F                      	POP	DI			; Start of next element
 22886                                  
 22887                                  ;hkn; SS is DOSDATA
 22888                                  	;context DS			; Got to from one place with DS gone
 22889 00004C83 16                      	push	ss
 22890 00004C84 1F                      	pop	ds
 22891                                  
 22892                                  ; DOS 3.3 FastOpen
 22893                                  	;test	byte [FastOpenFlg],1
 22894 00004C85 F606[A40F]01            	TEST	byte [FastOpenFlg],FastOpen_Set  ; do this here is we don't want to
 22895 00004C8A 740B                    	JZ	short NO_FAST		; device info to fastopen
 22896                                  	;test	byte [FastOpenFlg],2
 22897 00004C8C F606[A40F]02            	TEST	byte [FastOpenFlg],Lookup_Success
 22898 00004C91 7404                    	JZ	short NO_FAST
 22899 00004C93 8B3E[A50F]              	MOV	DI,[Next_Element_Start]  ; This takes care of one time lookup
 22900                                  					 ; success
 22901                                  NO_FAST:
 22902                                  ; DOS 3.3 FastOpen
 22903                                  
 22904 00004C97 8A05                    	MOV	AL,[DI]
 22905 00004C99 08C0                    	OR	AL,AL
 22906 00004C9B 7404                    	JZ	short INCRET
 22907 00004C9D 89FE                    	MOV	SI,DI			; Path too long
 22908 00004C9F EB0D                    	JMP	SHORT BADPRET
 22909                                  
 22910                                  INCRET:
 22911                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 22912                                  
 22913 00004CA1 E85E02                  	CALL   InsertPath		; insert dir entry info
 22914                                  
 22915                                  ; DOS 3.3 FasOpen 6/12/86  F.C.
 22916 00004CA4 FEC0                    	INC	AL			; Reset zero
 22917                                  _SETRET:
 22918 00004CA6 C3                      	retn
 22919                                  
 22920                                  BADPATHPOP:
 22921 00004CA7 5E                      	POP	SI			; Start of next element
 22922 00004CA8 8A04                    	MOV	AL,[SI]
 22923 00004CAA 89FE                    	MOV	SI,DI			; Start of bad element
 22924 00004CAC 08C0                    	OR	AL,AL			; zero if bad element is last, non-zero if path too long
 22925                                  BADPRET:
 22926 00004CAE A0[2A05]                	MOV	AL,[SATTRIB]
 22927 00004CB1 A2[2805]                	MOV	[ATTRIB],AL		; Make sure return correct
 22928 00004CB4 F9                      	STC
 22929 00004CB5 C3                      	retn
 22930                                  
 22931                                  ;Break	<STARTSRCH -- INITIATE DIRECTORY SEARCH>
 22932                                  ;---------------------------------------------------------------------------
 22933                                  ;
 22934                                  ; Procedure Name : STARTSRCH
 22935                                  ;
 22936                                  ; Inputs:
 22937                                  ;	[THISDPB] Set
 22938                                  ; Function:
 22939                                  ;	Set up a search for GETENTRY and NEXTENTRY
 22940                                  ; Outputs:
 22941                                  ;	ES:BP = Drive parameters
 22942                                  ;	Sets up LASTENT, ENTFREE=ENTLAST=-1, VOLID=0
 22943                                  ; Destroys ES,BP,AX
 22944                                  ;--------------------------------------------------------------------------
 22945                                  
 22946                                  STARTSRCH:
 22947 00004CB6 C42E[4605]              	LES	BP,[THISDPB]
 22948 00004CBA 31C0                    	XOR	AX,AX
 22949 00004CBC A3[1203]                	MOV	[LASTENT],AX
 22950 00004CBF A2[3805]                	MOV	[VOLID],AL		; No volume ID found
 22951 00004CC2 48                      	DEC	AX
 22952 00004CC3 A3[9405]                	MOV	[ENTFREE],AX
 22953 00004CC6 A3[9605]                	MOV	[ENTLAST],AX
 22954 00004CC9 C3                      	retn
 22955                                  
 22956                                  ;BREAK <MatchAttributes - the final check for attribute matching>
 22957                                  ;----------------------------------------------------------------------------
 22958                                  ; Procedure Name : MatchAttributes
 22959                                  ;
 22960                                  ; Input:    [Attrib] = attribute to search for
 22961                                  ;	    CH = found attribute
 22962                                  ; Output:   JZ <match>
 22963                                  ;	    JNZ <nomatch>
 22964                                  ; Registers modified: noneski
 22965                                  ;----------------------------------------------------------------------------
 22966                                  
 22967                                  MatchAttributes:
 22968 00004CCA 50                      	PUSH	AX
 22969                                  
 22970                                  ;hkn; SS override
 22971 00004CCB 36A0[2805]              	MOV	AL,[ss:ATTRIB]		; AL <- SearchSet
 22972 00004CCF F6D0                    	NOT	AL			; AL <- SearchSet'
 22973 00004CD1 20E8                    	AND	AL,CH			; AL <- SearchSet' and FoundSet
 22974                                  	;and	al,16h
 22975 00004CD3 2416                    	AND	AL,attr_all	; AL <- SearchSet' and FoundSet and Important
 22976                                  ;
 22977                                  ; the result is non-zero if an attribute is not in the search set
 22978                                  ; and in the found set and in the important set. This means that we do not
 22979                                  ; have a match. Do a JNZ <nomatch> or JZ <match>
 22980                                  ;
 22981 00004CD5 58                      	POP	AX
 22982 00004CD6 C3                      	retn
 22983                                  
 22984                                  ;Break <DevName - Look for name of device>
 22985                                  ;---------------------------------------------------------------------------
 22986                                  ;
 22987                                  ; Procedure Name : DevName
 22988                                  ;
 22989                                  ; Inputs:
 22990                                  ;	DS,ES:DOSDATA
 22991                                  ;	Filename in NAME1
 22992                                  ;	ATTRIB set so that we can error out if looking for Volume IDs
 22993                                  ; Function:
 22994                                  ;	Determine if file is in list of I/O drivers
 22995                                  ; Outputs:
 22996                                  ;	Carry set if not a device
 22997                                  ;	ELSE
 22998                                  ;	Zero flag set
 22999                                  ;	BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
 23000                                  ;	     bits 0-4 set from low byte of attribute word
 23001                                  ;	DEVPT = DWORD pointer to Device header of device
 23002                                  ; BX destroyed, others preserved
 23003                                  ;---------------------------------------------------------------------------
 23004                                  
 23005                                  DEVNAME:
 23006                                  	; 28/07/2018 - Retro DOS v3.0
 23007                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 49FBh
 23008                                  
 23009 00004CD7 56                      	PUSH	SI
 23010 00004CD8 57                      	PUSH	DI
 23011 00004CD9 51                      	PUSH	CX
 23012 00004CDA 50                      	PUSH	AX
 23013                                  
 23014                                  ; E5 special code
 23015 00004CDB FF36[0805]              	PUSH	WORD [NAME1]
 23016 00004CDF 803E[0805]05            	CMP	byte [NAME1],5
 23017 00004CE4 7505                    	JNZ	short NOKTR
 23018 00004CE6 C606[0805]E5            	MOV	byte [NAME1],0E5h
 23019                                  NOKTR:
 23020                                  	;test	byte [ATTRIB],8
 23021 00004CEB F606[2805]08            	TEST	byte [ATTRIB],attr_volume_id
 23022                                  					; If looking for VOL id don't find devs
 23023 00004CF0 7522                    	JNZ	short RET31
 23024                                  
 23025                                  ;hkn; NULDEV is in DOSDATA
 23026 00004CF2 BE[4800]                	MOV	SI,NULDEV
 23027                                  LOOKIO:
 23028                                  	;test	word [si+4],8000h
 23029 00004CF5 F744040080              	TEST	word [SI+SYSDEV.ATT],DEVTYP
 23030 00004CFA 7411                    	JZ	short SKIPDEV 		; Skip block devices (NET and LOCAL)
 23031 00004CFC 89F0                    	MOV	AX,SI
 23032                                  	;add	si,10
 23033 00004CFE 83C60A                  	ADD	SI,SYSDEV.NAME
 23034                                  
 23035                                  ;hkn; NAME1 is in DOSDATA
 23036 00004D01 BF[0805]                	MOV	DI,NAME1
 23037 00004D04 B90400                  	MOV	CX,4			; All devices are 8 letters
 23038 00004D07 F3A7                    	REPE	CMPSW			; Check for name in list
 23039 00004D09 89C6                    	MOV	SI,AX
 23040 00004D0B 7415                    	JZ	short IOCHK		; Found it?
 23041                                  SKIPDEV:
 23042 00004D0D C534                    	LDS	SI,[SI]			; Get address of next device
 23043 00004D0F 83FEFF                  	CMP	SI,-1			; At end of list?
 23044 00004D12 75E1                    	JNZ	short LOOKIO
 23045                                  RET31:	
 23046 00004D14 F9                      	STC				; Not found
 23047                                  RETNV:	
 23048 00004D15 8CD1                    	MOV	CX,SS
 23049 00004D17 8ED9                    	MOV	DS,CX
 23050                                  
 23051 00004D19 8F06[0805]              	POP	WORD [NAME1]
 23052 00004D1D 58                      	POP	AX
 23053 00004D1E 59                      	POP	CX
 23054 00004D1F 5F                      	POP	DI
 23055 00004D20 5E                      	POP	SI
 23056 00004D21 C3                      	RETN
 23057                                  
 23058                                  IOCHK:
 23059                                  ;hkn; SS override for DEVPT
 23060 00004D22 368C1E[5805]            	MOV	[SS:DEVPT+2],DS		; Save pointer to device
 23061                                  	;mov	bh,[si+4]
 23062 00004D27 8A7C04                  	MOV	BH,[SI+SYSDEV.ATT]
 23063 00004D2A 80CFC0                  	OR	BH,0C0h
 23064 00004D2D 80E7DF                  	and	bh,0DFh
 23065                                  	;AND	BH,~(020h)		; Clears Carry
 23066 00004D30 368936[5605]            	MOV	[SS:DEVPT],SI
 23067 00004D35 EBDE                    	JMP	short RETNV
 23068                                  
 23069                                  ;BREAK <Build_device_ent - Make a Directory entry>
 23070                                  ;---------------------------------------------------------------------------
 23071                                  ; Procedure Name : Build_device_ent
 23072                                  ;
 23073                                  ; Inputs:
 23074                                  ;	[NAME1] has name
 23075                                  ;	BH is attribute field (supplied by DEVNAME)
 23076                                  ;	[DEVPT] points to device header (supplied by DEVNAME)
 23077                                  ; Function:
 23078                                  ;	Build a directory entry for a device at DEVFCB
 23079                                  ; Outputs:
 23080                                  ;	BX points to DEVFCB
 23081                                  ;	SI points to dir_first field
 23082                                  ;	AH = input BH
 23083                                  ;	AL = 0
 23084                                  ;	dir_first = DEVPT
 23085                                  ;	Zero Set, Carry Clear
 23086                                  ; DS,ES,BP preserved, others destroyed
 23087                                  ;--------------------------------------------------------------------------
 23088                                  
 23089                                  Build_device_ent:
 23090 00004D37 B82020                  	MOV	AX,"  " ; 2020h
 23091                                  
 23092                                  ;hkn; DEVFCB is in DOSDATA
 23093 00004D3A BF[1005]                	MOV	DI,DEVFCB+8		; Point to extent field
 23094                                  
 23095                                  ;	Fill dir_ext	BUGBUG - use ERRNZs for this stuff!
 23096                                  
 23097 00004D3D AB                      	STOSW
 23098 00004D3E AA                      	STOSB				; Blank out extent field
 23099                                  	;mov	al,40h
 23100 00004D3F B040                    	MOV	AL,attr_device
 23101                                  
 23102                                  ;	Fill Dir_attr
 23103                                  
 23104 00004D41 AA                      	STOSB				; Set attribute field
 23105 00004D42 31C0                    	XOR	AX,AX
 23106 00004D44 B90A00                  	MOV	CX,10
 23107                                  
 23108                                  ; Fill dir_pad
 23109                                  
 23110 00004D47 F3AB                    	REP	STOSW			; Fill rest with zeros
 23111 00004D49 E808CC                  	call	DATE16
 23112                                  
 23113                                  ;hkn; DEVFCB is in DOSDATA
 23114 00004D4C BF[1E05]                	MOV	DI,DEVFCB+dir_entry.dir_time ; 09/08/2018
 23115 00004D4F 92                      	XCHG	AX,DX
 23116                                  
 23117                                  ; Fill dir_time
 23118                                  
 23119 00004D50 AB                      	STOSW
 23120 00004D51 92                      	XCHG	AX,DX
 23121                                  
 23122                                  ; Fill dir_date
 23123                                  
 23124 00004D52 AB                      	STOSW
 23125 00004D53 89FE                    	MOV	SI,DI			; SI points to dir_first field
 23126 00004D55 A1[5605]                	MOV	AX,[DEVPT]
 23127                                  
 23128                                  ; Fill dir_first
 23129                                  
 23130 00004D58 AB                      	STOSW				; Dir_first points to device
 23131 00004D59 A1[5805]                	MOV	AX,[DEVPT+2]
 23132                                  ;
 23133                                  ; Fill dir_size_l
 23134                                  ;
 23135 00004D5C AB                      	STOSW
 23136 00004D5D 88FC                    	MOV	AH,BH			; Put device atts in AH
 23137                                  
 23138                                  ;hkn; DEVFCB is in DOSDATA
 23139 00004D5F BB[0805]                	MOV	BX,DEVFCB
 23140 00004D62 30C0                    	XOR	AL,AL			; Set zero, clear carry
 23141 00004D64 C3                      	retn
 23142                                  
 23143                                  ;Break	<ValidateCDS - given a CDS, validate the media and the current directory>
 23144                                  ;----------------------------------------------------------------------------
 23145                                  ;
 23146                                  ;   ValidateCDS - Get current CDS. Splice it. Call FatReadCDS to check
 23147                                  ;   media. If media has been changed, do DOS_Chdir to validate path.
 23148                                  ;   If invalid, reset original CDS to root.
 23149                                  ;
 23150                                  ;   Inputs:	ThisCDS points to CDS of interest
 23151                                  ;		SS:DI points to temp buffer
 23152                                  ;   Outputs:	The current directory string is validated on the appropriate
 23153                                  ;		    drive
 23154                                  ;		ThisDPB changed
 23155                                  ;		ES:DI point to CDS
 23156                                  ;		Carry set if error (currently user FAILed to I 24)
 23157                                  ;   Registers modified: all
 23158                                  ;----------------------------------------------------------------------------
 23159                                  
 23160                                  ValidateCDS:
 23161                                  	; 28/07/2018 - Retro DOS v3.0
 23162                                  
 23163                                     %define  Temp	[bp-2]	; word
 23164                                     %define  SaveCDS	[bp-6]	; dword
 23165                                     %define  SaveCDSL	[bp-6]	; word
 23166                                     %define  SaveCDSH	[bp-4]	; word
 23167                                  
 23168                                  	;Enter
 23169 00004D65 55                      	push	bp
 23170 00004D66 89E5                    	mov	bp,sp
 23171 00004D68 83EC06                  	sub	sp,6
 23172                                  
 23173 00004D6B 897EFE                  	MOV	Temp,DI
 23174                                  
 23175                                  ;hkn; SS override
 23176 00004D6E 36C536[5E05]            	LDS	SI,[SS:THISCDS]
 23177 00004D73 8976FA                  	MOV	SaveCDSL,SI
 23178 00004D76 8C5EFC                  	MOV	SaveCDSH,DS
 23179                                  	;EnterCrit critDisk
 23180 00004D79 E891D3                  	call	EcritDisk
 23181                                  	;test	word [si+67],8000h
 23182 00004D7C F744430080              	TEST	word [SI+curdir.flags],curdir_isnet	; Clears carry
 23183 00004D81 7403                    	JZ	short _DoSplice
 23184 00004D83 E98900                  	JMP	FatFail
 23185                                  _DoSplice:
 23186 00004D86 30D2                    	XOR	DL,DL
 23187 00004D88 368616[1603]            	XCHG	DL,[SS:NoSetDir]
 23188                                  
 23189                                  ;hkn; SS is DOSDATA
 23190                                  	;Context ES
 23191 00004D8D 16                      	push	ss
 23192 00004D8E 07                      	pop	es
 23193                                  	;Invoke	FStrcpy
 23194 00004D8F E870D2                  	call	FStrCpy
 23195 00004D92 8B76FE                  	MOV	SI,Temp
 23196                                  
 23197                                  ;hkn; SS is DOSDATA
 23198                                  	;Context DS
 23199 00004D95 16                      	push	ss
 23200 00004D96 1F                      	pop	ds	
 23201                                  	;Invoke	Splice
 23202 00004D97 E88122                  	call	Splice
 23203                                  
 23204                                   ;hkn; SS is DOSDATA
 23205                                  	;Context DS			;   FatReadCDS (ThisCDS);
 23206 00004D9A 16                      	push	ss
 23207 00004D9B 1F                      	pop	ds
 23208 00004D9C 8816[1603]              	MOV	[NoSetDir],DL
 23209 00004DA0 C43E[5E05]              	LES	DI,[THISCDS]
 23210                                  	;SAVE	<BP>
 23211 00004DA4 55                      	push	bp
 23212                                  	;Invoke	FATREAD_CDS
 23213 00004DA5 E82911                  	call	FATREAD_CDS	
 23214                                  	;RESTORE <BP>
 23215 00004DA8 5D                      	pop	bp
 23216 00004DA9 7264                    	JC	short FatFail
 23217                                  
 23218 00004DAB C536[5E05]              	LDS	SI,[THISCDS]		;   if (ThisCDS->ID == -1) {
 23219                                  	;cmp	word [si+73], -1
 23220 00004DAF 837C49FF                	CMP	word [SI+curdir.ID],-1
 23221 00004DB3 754C                    	JNZ	short RestoreCDS
 23222                                  
 23223                                  ;hkn; SS is DOSDATA
 23224                                  	;Context ES
 23225 00004DB5 16                      	push	ss
 23226 00004DB6 07                      	pop	es
 23227                                  
 23228                                  ;hkn; SS override
 23229                                  	;SAVE	<wfp_Start>		;	t = wfp_Start;
 23230 00004DB7 36FF36[6E05]            	push	word [SS:WFP_START]
 23231                                  	;cmp	si,[bp-6]
 23232 00004DBC 3B76FA                  	CMP	SI,SaveCDSL		; if not spliced
 23233 00004DBF 750B                    	JNZ	short DoChdir
 23234                                  	;mov	di,[bp-2]
 23235 00004DC1 8B7EFE                  	MOV	DI,Temp
 23236                                  
 23237                                  ;hkn; SS override
 23238 00004DC4 36893E[6E05]            	MOV	[SS:WFP_START],DI	;	wfp_start = d;
 23239                                  	;Invoke	FStrCpy 		;	strcpy (d, ThisCDS->Text);
 23240 00004DC9 E836D2                  	call	FStrCpy
 23241                                  DoChdir:
 23242                                  ;hkn; SS is DOSDATA
 23243                                  	;Context DS
 23244 00004DCC 16                      	push	ss
 23245 00004DCD 1F                      	pop	ds
 23246                                  	;SAVE	<<WORD PTR SAttrib>,BP> ;	c = DOSChDir ();
 23247 00004DCE FF36[2A05]              	push	word [SATTRIB]
 23248 00004DD2 55                      	push	bp
 23249                                  	;Invoke	DOS_ChDir
 23250 00004DD3 E8E0EF                  	call	DOS_CHDIR
 23251                                  	;RESTORE <BP,BX,wfp_start>	;	wfp_Start = t;
 23252 00004DD6 5D                      	pop	bp
 23253 00004DD7 5B                      	pop	bx
 23254 00004DD8 8F06[6E05]              	pop	word [WFP_START]
 23255 00004DDC 881E[2A05]              	MOV	[SATTRIB],BL
 23256 00004DE0 C576FA                  	LDS	SI,SaveCDS
 23257 00004DE3 730F                    	JNC	short SetCluster	;	if (c == -1) {
 23258                                  
 23259                                  ;hkn; SS override for THISCDS
 23260 00004DE5 368936[5E05]            	MOV	[SS:THISCDS],SI		;	    ThisCDS = TmpCDS;
 23261 00004DEA 368C1E[6005]            	MOV	[SS:THISCDS+2],DS
 23262 00004DEF 31C9                    	XOR	CX,CX			;	    TmpCDS->text[3] = c = 0;
 23263 00004DF1 884C03                  	MOV	[SI+3],CL		;	    }
 23264                                  SetCluster:
 23265                                  	;mov	word [si+73],0FFFFh
 23266 00004DF4 C74449FFFF              	MOV	word [SI+curdir.ID],-1	;	TmpCDS->ID = -1;
 23267 00004DF9 36C536[5E05]            	LDS	SI,[SS:THISCDS]		;	ThisCDS->ID = c;
 23268                                  	; MSDOS 6.0
 23269                                  	;TEST	word [SI+curdir.flags],curdir_splice ;AN000;;MS. for Join and Subst
 23270                                  	;JZ	short setdirclus		     ;AN000;;MS.
 23271                                  	;MOV	CX,-1				     ;AN000;;MS.
 23272                                  setdirclus:
 23273                                  	;mov	[si+73],cx
 23274 00004DFE 894C49                  	MOV	[SI+curdir.ID],CX	;	}
 23275                                  RestoreCDS:
 23276 00004E01 C47EFA                  	LES	DI,SaveCDS
 23277 00004E04 36893E[5E05]            	MOV	[SS:THISCDS],DI
 23278 00004E09 368C06[6005]            	MOV	[SS:THISCDS+2],ES
 23279 00004E0E F8                      	CLC
 23280                                  FatFail:
 23281                                  	;LeaveCrit critDisk
 23282 00004E0F E803D3                  	call	LcritDisk
 23283                                  
 23284                                  	;les	di,[bp-6]
 23285 00004E12 C47EFA                  	LES	DI,SaveCDS
 23286                                  	;Leave
 23287 00004E15 89EC                    	mov	sp,bp
 23288 00004E17 5D                      	pop	bp
 23289 00004E18 C3                      	retn
 23290                                  
 23291                                  ; 28/07/2018 - Retro DOS v3.0
 23292                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - offset 43BDh
 23293                                  
 23294                                  ;Break	<CheckThisDevice - Check for being a device>
 23295                                  ;---------------------------------------------------------------------------
 23296                                  ;
 23297                                  ;   CheckThisDevice - Examine the area at DS:SI to see if there is a valid
 23298                                  ;   device specified. We will return carry if there is a device present. 
 23299                                  ;   The forms of devices we will recognize are:
 23300                                  ;
 23301                                  ;	[path]device
 23302                                  ;
 23303                                  ;   Note that the drive letter has *already* been removed. All other forms
 23304                                  ;   are not considered to be devices. If such a device is found we change
 23305                                  ;   the source pointer to point to the device component.
 23306                                  ;
 23307                                  ;   Inputs:	ES is DOSDATA
 23308                                  ;		DS:SI contains name
 23309                                  ;   Outputs:	ES is DOSDATA
 23310                                  ;		DS:SI point to name or device
 23311                                  ;		Carry flag set if device was found
 23312                                  ;		Carry flag reset otherwise
 23313                                  ;   Registers Modified: all except ES:DI, DS
 23314                                  ;----------------------------------------------------------------------------
 23315                                  
 23316                                  CheckThisDevice:
 23317 00004E19 57                      	push	di
 23318 00004E1A 56                      	push	si
 23319 00004E1B 89F7                    	MOV	DI,SI
 23320                                  ;
 23321                                  ; Check for presence of \dev\ (Dam multiplan!)
 23322                                  ;
 23323 00004E1D 8A04                    	MOV	AL,[SI]
 23324 00004E1F E8090B                  	call	PATHCHRCMP		; is it a path char?
 23325 00004E22 7517                    	JNZ	short ParseDev		; no, go attempt to parse device
 23326 00004E24 46                      	INC	SI			; simulate LODSB
 23327                                  ;
 23328                                  ; We have the leading path separator. Look for DEV part.
 23329                                  ;
 23330 00004E25 AD                      	LODSW
 23331 00004E26 0D2020                  	OR	AX,2020h
 23332 00004E29 3D6465                  	cmp	ax,"de"
 23333                                  	;CMP	AX,"e"<< 8 + "d"
 23334 00004E2C 752D                    	JNZ	short NotDevice		; not "de", assume not device
 23335 00004E2E AC                      	LODSB
 23336 00004E2F 0C20                    	OR	AL,20h
 23337 00004E31 3C76                    	CMP	AL,"v"                  ; Not "v", assume not device
 23338 00004E33 7526                    	JNZ	short NotDevice
 23339 00004E35 AC                      	LODSB
 23340 00004E36 E8F20A                  	call	PATHCHRCMP		; do we have the last path separator?
 23341 00004E39 7520                    	JNZ	short NotDevice		; no. go for it.
 23342                                  ;
 23343                                  ; DS:SI now points to a potential drive. Preserve them as NameTrans advances
 23344                                  ; SI and DevName may destroy DS.
 23345                                  ;
 23346                                  ParseDev:
 23347 00004E3B 1E                      	push	ds
 23348 00004E3C 56                      	push	si			; preserve the source pointer
 23349 00004E3D E8810A                  	call	NameTrans		; advance DS:SI
 23350 00004E40 803C00                  	CMP	BYTE [SI],0		; parse entire string?
 23351 00004E43 F9                      	STC				; simulate a Carry return from DevName
 23352 00004E44 750B                    	JNZ	short SkipSearch	; no parse. simulate a file return.
 23353                                  
 23354                                  ;hkn; SS is DOSDATA
 23355 00004E46 16                      	push	ss
 23356 00004E47 1F                      	pop	ds
 23357                                  
 23358                                  ; M026 - start - fix ported from ROMDOS2 for bug # 2849
 23359                                  ;
 23360                                  ; SR;
 23361                                  ; We have to set Attrib before invoking DevName. Otherwise, the value from
 23362                                  ; a previous DOS call is used and DevName thinks it is not a device if the
 23363                                  ; old call set the volume attribute bit.
 23364                                  ;
 23365 00004E48 A0[2A05]                	mov	al,[SATTRIB]
 23366 00004E4B A2[2805]                	mov	[ATTRIB],al		;set Attrib for DevName
 23367                                  
 23368                                  ; M026 - end
 23369                                  
 23370 00004E4E E886FE                  	call	DEVNAME
 23371                                  
 23372                                  SkipSearch:
 23373 00004E51 5E                      	pop	si
 23374 00004E52 1F                      	pop	ds
 23375                                  ;
 23376                                  ; SI points to the beginning of the potential device. If we have a device
 23377                                  ; then we do not change SI. If we have a file, then we reset SI back to the
 23378                                  ; original value. At this point Carry set indicates FILE.
 23379                                  ;
 23380                                  CheckReturn:
 23381 00004E53 5F                      	pop	di			; get original SI
 23382 00004E54 7302                    	JNC	short Check_Done	; if device then do not reset pointer
 23383 00004E56 89FE                    	MOV	SI,DI
 23384                                  Check_Done:
 23385 00004E58 5F                      	pop	di
 23386 00004E59 F5                      	CMC				; invert carry. Carry => device
 23387 00004E5A C3                      	retn
 23388                                  NotDevice:
 23389 00004E5B F9                      	STC
 23390 00004E5C EBF5                    	JMP	short CheckReturn
 23391                                  
 23392                                  ;BREAK <LookupPath - call fastopen to get dir entry info>
 23393                                  ;-----------------------------------------------------------------------------
 23394                                  ;
 23395                                  ; Procedure Name : LookupPath
 23396                                  ;
 23397                                  ; Output  DS:SI -> path name,
 23398                                  ;	  ES:DI -> dir entry info buffer
 23399                                  ;	  ES:CX -> extended dir info buffer
 23400                                  ;
 23401                                  ;	  carry flag clear : tables pointed by ES:DI and ES:CX are filled by
 23402                                  ;			     FastOpen, DS:SI points to char just one after
 23403                                  ;			     the last char of path name which is fully or
 23404                                  ;			     partially found in FastOPen
 23405                                  ;	  carry flag set : FastOpen not in memory or path name not found
 23406                                  ;
 23407                                  ;----------------------------------------------------------------------------
 23408                                  
 23409                                  LookupPath:
 23410                                  ;	PUSH	AX
 23411                                  
 23412                                  ;hkn; SS override
 23413                                  	;test	byte [ss:FastOpenFlg],1
 23414 00004E5E 36F606[A40F]01          	TEST	byte [ss:FastOpenFlg],FastOpen_Set  ; flg is set in DOSOPEN
 23415 00004E64 7503                    	JNZ	short FASTINST			    ; and this routine is
 23416                                  NOLOOK:
 23417 00004E66 E99700                  	JMP	NOLOOKUP			    ; executed once
 23418                                  
 23419                                  FASTINST:
 23420                                  ;hkn; SS override
 23421                                  	;test	byte [ss:FastOpenFlg],8
 23422 00004E69 36F606[A40F]08          	TEST	byte [ss:FastOpenFlg],No_Lookup	    ; no more lookup?
 23423 00004E6F 75F5                    	JNZ	short NOLOOK			    ; yes
 23424                                  
 23425 00004E71 BB[730F]                	MOV	BX,FastOpenTable		    ; get fastopen related tab
 23426                                  
 23427                                  ;hkn; SS override
 23428 00004E74 368B36[6E05]            	MOV	SI,[SS:WFP_START]		    ; si points to path name
 23429 00004E79 BF[840F]                	MOV	DI,Dir_Info_Buff
 23430 00004E7C B9[790F]                	MOV	CX,FastOpen_Ext_Info
 23431 00004E7F B001                    	MOV	AL,FONC_Look_up 		    ; al = 1
 23432 00004E81 1E                      	PUSH	DS
 23433 00004E82 07                      	POP	ES
 23434                                  
 23435                                  ;hkn; SS override
 23436                                  	;call	far [bx+2]
 23437 00004E83 FF5F02                  	CALL	far [BX+fastopen_entry.name_caching] ;call fastopen
 23438 00004E86 7267                    	JC	short NOTFOUND			    ; fastopen not in memory
 23439                                  
 23440 00004E88 8D5CFE                  	LEA	BX,[SI-2]
 23441                                  
 23442                                  ;hkn; SS override
 23443 00004E8B 363B1E[6E05]            	CMP	BX,[SS:WFP_START]		    ; path found ?
 23444 00004E90 745D                    	JZ	short NOTFOUND			    ; no
 23445                                  
 23446                                  	; 29/07/2019 - Retro DOS v3.2
 23447                                  	; MSDOS 6.0				    ; fully or partially found
 23448 00004E92 803C00                  	CMP	BYTE [SI],0			    ;AN000;FO.
 23449 00004E95 751A                    	JNZ	short parfnd			    ;AN000;FO.; partiallyfound
 23450 00004E97 51                      	PUSH	CX				    ;AN000;FO.; is attribute matched ?
 23451                                  
 23452                                  ;hkn; SS override for attrib/sattrib
 23453 00004E98 368A0E[2805]            	MOV	CL,[ss:ATTRIB]			    ;AN000;FO.;
 23454 00004E9D 368A2E[2A05]            	MOV	CH,[ss:SATTRIB]			    ;AN000;FO.; attrib=sattrib
 23455 00004EA2 36882E[2805]            	MOV	[ss:ATTRIB],CH			    ;AN000;FO.;
 23456 00004EA7 268A6D0B                	MOV	CH,[ES:DI+dir_entry.dir_attr]	    ;AN000;FO.;
 23457 00004EAB E81CFE                  	call	MatchAttributes			    ;AN000;FO.;
 23458                                  ;;;	MOV	[ss:ATTRIB],CL			    ;AN001;FO.; restore attrib
 23459 00004EAE 59                      	POP	CX				    ;AN000;FO.;
 23460 00004EAF 754F                    	JNZ	short NOLOOKUP			    ;AN000;FO.; not matched
 23461                                  parfnd:
 23462                                  
 23463                                  ;hkn; SS override
 23464 00004EB1 368936[A50F]            	MOV	[SS:Next_Element_Start],SI	    ; save si
 23465 00004EB6 89CB                    	MOV	BX,CX
 23466                                  	; MSDOS 6.0
 23467 00004EB8 8B4707                  	MOV	AX,[BX+FEI.lastent]		    ;AN000;;FO. restore lastentry
 23468                                  ;hkn; SS override for LASTENT, DIRSTART, CLUSNUM
 23469 00004EBB 36A3[1203]              	MOV	[SS:LASTENT],AX			    ;AN000;;FO.
 23470 00004EBF 8B4709                  	MOV	AX,[BX+FEI.dirstart]		    ;AN001;;FO. restore dirstart
 23471 00004EC2 36A3[7E05]              	MOV	[SS:DIRSTART],AX			    ;AN001;;FO.
 23472                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23473                                  	;mov	ax,[bx+3] ; MSDOS 3.3
 23474 00004EC6 8B4705                  	MOV	AX,[BX+FEI.clusnum]		    ; restore next cluster num
 23475 00004EC9 36A3[7805]              	MOV	[SS:CLUSNUM],AX			    ;
 23476                                  
 23477 00004ECD 06                      	PUSH	ES				    ; save ES
 23478                                  ;hkn; SS override
 23479 00004ECE 36C41E[4605]            	LES	BX,[SS:THISDPB]			    ; put drive id
 23480 00004ED3 268A27                  	mov	ah,[ES:BX] ; 15/08/2018
 23481                                  	;MOV	AH,[ES:BX+DPB.DRIVE]		    ; in AH for DOOPEN
 23482 00004ED6 07                      	POP	ES				    ; pop ES
 23483                                  ;SR;
 23484                                  ; We cannot have a root dir if we have come here. So, we zero out CurBuf to
 23485                                  ;indicate it is not a root dir
 23486                                  ;
 23487 00004ED7 36C706[9E05]0000        	mov	word [SS:CURBUF],0		    ; indicate not root dir
 23488                                  
 23489 00004EDE 368C06[A005]            	MOV	WORD [SS:CURBUF+2],ES		    ; [curbuf+2].bx points to
 23490 00004EE3 89FB                    	MOV	BX,DI				    ; start of entry
 23491                                  	;lea	si,[di+1Ah]
 23492 00004EE5 8D751A                  	LEA	SI,[DI+dir_entry.dir_first]	    ; [curbuf+2]:si points to
 23493                                  						    ; dir_first field in the
 23494                                  						    ; dir entry
 23495                                  ;hkn; SS override for FastOpenFlg
 23496                                  	;or	byte [ss:FastOpenFlg],2
 23497 00004EE8 36800E[A40F]12          	OR	byte [SS:FastOpenFlg],Lookup_Success+Set_For_Search
 23498                                  ;	POP	AX
 23499 00004EEE C3                      	RETN
 23500                                  NOTFOUND:
 23501 00004EEF 83F8FF                  	CMP	AX,-1				    ; not in memory ?
 23502 00004EF2 7506                    	JNZ	short Partial_Success 		    ; yes, in memory
 23503 00004EF4 36C606[A40F]00          	MOV	byte [SS:FastOpenFlg],0		    ; no more fastopen
 23504                                  Partial_Success:
 23505                                  	;and	byte [SS:FastOpenFlg],0FBh
 23506 00004EFA 368026[A40F]FB          	AND	byte [SS:FastOpenFlg],Special_Fill_Reset
 23507                                  NOLOOKUP:
 23508                                  ;	POP	AX
 23509 00004F00 F9                      	STC
 23510 00004F01 C3                      	RETN
 23511                                  
 23512                                  ;BREAK <InsertPath - call fastopen to insert dir entry info>
 23513                                  ;-----------------------------------------------------------------------------
 23514                                  ;
 23515                                  ; Procedure Name : InsertPath
 23516                                  ; Input:  FastOpen_Set flag set when from DOSOPEN otherwise 0
 23517                                  ;	  Lookup_Success flag set when got dir entry info from FASTOPEN
 23518                                  ;	  DS = DOSDATA
 23519                                  ; Output: FastOPen_Ext_Info is set and path dir info is inserted
 23520                                  ;
 23521                                  ;-----------------------------------------------------------------------------
 23522                                  
 23523                                  InsertPath:
 23524 00004F02 9C                      	PUSHF
 23525                                  ;hkn; SS override for FastOpenFlag
 23526                                  	;test	byte [SS:FastOpenFlg], 1
 23527 00004F03 36F606[A40F]01          	TEST	byte [SS:FastOpenFlg],FastOpen_Set ;only DOSOPEN can take advantage of
 23528 00004F09 7478                    	JZ	short GET_NEXT_ELEMENT		; the FastOpen
 23529                                  	;test	byte [ss:FastOpenFlg],2
 23530 00004F0B 36F606[A40F]02          	TEST	byte [SS:FastOpenFlg],Lookup_Success ; Lookup just happened
 23531 00004F11 740D                    	JZ	short INSERT_DIR_INFO		; no
 23532                                  	;and	byte [ss:FastOpenFlg],0FDh
 23533 00004F13 368026[A40F]FD          	AND	byte [SS:FastOpenFlg],Lookup_Reset  ; we got dir info from fastopen so
 23534 00004F19 368B3E[A50F]            	MOV	DI,[SS:Next_Element_Start]	; no need to insert it again
 23535 00004F1E EB5D                    	JMP	short GET_NEXT2
 23536                                  INSERT_DIR_INFO:				; save registers
 23537 00004F20 1E                      	PUSH	DS
 23538 00004F21 06                      	PUSH	ES
 23539 00004F22 53                      	PUSH	BX
 23540 00004F23 56                      	PUSH	SI
 23541 00004F24 57                      	PUSH	DI
 23542 00004F25 51                      	PUSH	CX
 23543 00004F26 50                      	PUSH	AX
 23544                                  
 23545                                  ;hkn; SS override
 23546 00004F27 36C53E[9E05]            	LDS	DI,[SS:CURBUF]			; DS:DI -> buffer header
 23547 00004F2C BE[790F]                	MOV	SI,FastOpen_Ext_Info
 23548                                  	;mov	ax,[di+6]
 23549 00004F2F 8B4506                  	MOV	AX,[DI+BUFFINFO.buf_sector]	; get directory sector
 23550                                  	; MSDOS 6.0
 23551                                  	;mov	[ss:si+1],ax
 23552 00004F32 36894401                	MOV	[SS:SI+FEI.dirsec],AX 		;AN000; >32mb save dir sector
 23553                                  	; 22/07/2019 - Retro DOS v3.2
 23554 00004F36 8B4508                  	MOV	AX,[DI+BUFFINFO.buf_sector+2]	;AN000; >32mb
 23555                                  
 23556                                  ;hkn; SS is DOSDATA
 23557 00004F39 16                      	push	ss
 23558 00004F3A 1F                      	pop	ds
 23559                                  	; MSDOS 3.3	
 23560                                  	;mov	[si+1],ax	
 23561                                  	;MOV	[SI+FEI.dirsec],AX
 23562                                  	; MSDOS 6.0
 23563                                  	;mov	[si+3],ax
 23564 00004F3B 894403                  	MOV	[SI+FEI.dirsec+2],AX  ;AN000;>32mb save high dir sector
 23565                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23566 00004F3E A1[7805]                	MOV	AX,[CLUSNUM]		; save next cluster number
 23567                                  	;;mov	[si+5],ax ; MSDOS 6.0
 23568                                  	;mov	[si+3],ax ; MSDOS 3.3
 23569 00004F41 894405                  	MOV	[SI+FEI.clusnum],AX
 23570                                  ; MSDOS 6.0
 23571 00004F44 A1[1203]                	MOV	AX,[LASTENT]		;AN000;FO. save lastentry for search first
 23572                                  	;mov	[si+7],ax
 23573 00004F47 894407                  	MOV	[SI+FEI.lastent],AX	;AN000;FO.
 23574 00004F4A A1[7E05]                	MOV	AX,[DIRSTART]		;AN001;FO. save  for search first
 23575                                  	;mov	[si+9],ax
 23576 00004F4D 894409                  	MOV	[SI+FEI.dirstart],AX	;AN001;FO.
 23577                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23578 00004F50 89D8                    	MOV	AX,BX
 23579                                  	;;add	di,16  ; MSDOS 3.3
 23580                                  	;add	di,20  ; MSDOS 6.0
 23581 00004F52 83C714                  	ADD	DI,BUFINSIZ		; DS:DI -> start of data in buffer
 23582 00004F55 29F8                    	SUB	AX,DI			; AX=BX relative to start of sector
 23583                                  	;mov	cl,32
 23584 00004F57 B120                    	MOV	CL,dir_entry.size
 23585 00004F59 F6F1                    	DIV	CL
 23586                                  	;MOV	[SI+FEI.dirpos],AL	; save directory entry # in buffer
 23587 00004F5B 8804                    	mov	[si],al
 23588                                  
 23589 00004F5D 1E                      	PUSH	DS
 23590 00004F5E 07                      	POP	ES
 23591                                  
 23592 00004F5F 8E1E[A005]              	MOV	DS,[CURBUF+2]
 23593 00004F63 89DF                    	MOV	DI,BX			; DS:DI -> dir entry info
 23594                                  	;cmp	word [di+1Ah],0
 23595 00004F65 837D1A00                	CMP	word [DI+dir_entry.dir_first],0 
 23596                                  					; never insert info when file is empty
 23597 00004F69 740B                    	JZ	short SKIP_INSERT	; e.g. newly created file
 23598                                  
 23599 00004F6B 56                      	PUSH	SI			; ES:BX -> extended info
 23600 00004F6C 5B                      	POP	BX
 23601                                  
 23602                                  	;mov	al,2
 23603 00004F6D B002                    	MOV	AL,FONC_insert		; call fastopen insert operation
 23604 00004F6F BE[730F]                	MOV	SI,FastOpenTable
 23605                                  	;call	far [es:si+2]
 23606 00004F72 FF5C02                  	CALL	far [SI+fastopen_entry.name_caching]
 23607                                  
 23608 00004F75 F8                      	CLC
 23609                                  SKIP_INSERT:
 23610 00004F76 58                      	POP	AX
 23611 00004F77 59                      	POP	CX			; restore registers
 23612 00004F78 5F                      	POP	DI
 23613 00004F79 5E                      	POP	SI
 23614 00004F7A 5B                      	POP	BX
 23615 00004F7B 07                      	POP	ES
 23616 00004F7C 1F                      	POP	DS
 23617                                  GET_NEXT2:
 23618                                  	;or	[ss:FastOpenFlg],8
 23619 00004F7D 36800E[A40F]08          	OR	byte [SS:FastOpenFlg],No_Lookup
 23620                                  					; we got dir info from fastopen so
 23621                                  GET_NEXT_ELEMENT:
 23622 00004F83 9D                      	POPF
 23623 00004F84 C3                      	RETN
 23624                                  
 23625                                  ;============================================================================
 23626                                  ; DEV.ASM, MSDOS 6.0, 1991
 23627                                  ;============================================================================
 23628                                  ; 28/07/2018 - Retro DOS v3.0
 23629                                  
 23630                                  ; DEV.ASM: Retro DOS v2.0 - 14/03/2018
 23631                                  
 23632                                  ;TITLE   DEV - Device call routines
 23633                                  ;NAME    Dev
 23634                                  
 23635                                  ;Break	<IOFUNC -- DO FUNCTION 1-12 I/O>
 23636                                  ;----------------------------------------------------------------------------
 23637                                  ;
 23638                                  ; Procedure Name : IOFUNC
 23639                                  ;
 23640                                  ; Inputs:
 23641                                  ;	DS:SI Points to SFT
 23642                                  ;	AH is function code
 23643                                  ;		= 0 Input
 23644                                  ;		= 1 Input Status
 23645                                  ;		= 2 Output
 23646                                  ;		= 3 Output Status
 23647                                  ;		= 4 Flush
 23648                                  ;		= 5 Input Status - System WAIT invoked for K09 if no char
 23649                                  ;				   present.
 23650                                  ;	AL = character if output
 23651                                  ; Function:
 23652                                  ;	Perform indicated I/O to device or file
 23653                                  ; Outputs:
 23654                                  ;	AL is character if input
 23655                                  ;	If a status call
 23656                                  ;		zero set if not ready
 23657                                  ;		zero reset if ready (character in AL for input status)
 23658                                  ; For regular files:
 23659                                  ;	Input Status
 23660                                  ;		Gets character but restores position
 23661                                  ;		Zero set on EOF
 23662                                  ;	Input
 23663                                  ;		Gets character advances position
 23664                                  ;		Returns ^Z on EOF
 23665                                  ;	Output Status
 23666                                  ;		Always ready
 23667                                  ; AX altered, all other registers preserved
 23668                                  ;----------------------------------------------------------------------------
 23669                                  
 23670                                  IOFUNC:
 23671 00004F85 368C16[5603]            	MOV	[SS:IOXAD+2],SS		; SS override for IOXAD, IOSCNT, 
 23672                                  					; DEVIOBUF
 23673 00004F8A 36C706[5403][8003]      	MOV	WORD [SS:IOXAD],DEVIOBUF
 23674 00004F91 36C706[5803]0100        	MOV	WORD [SS:IOSCNT],1
 23675 00004F98 36A3[8003]              	MOV	WORD [SS:DEVIOBUF],AX
 23676                                  	;test	word [si+5],8000h
 23677 00004F9C F744050080              	TEST	word [SI+SF_ENTRY.sf_flags],sf_isnet
 23678 00004FA1 7403                    	JZ	short IOTO22		;AN000;
 23679 00004FA3 E98500                  	JMP	IOTOFILE		;AN000;
 23680                                  IOTO22:
 23681                                  	;test	word [si+5],80h ; 17/05/2019
 23682 00004FA6 F744058000              	TEST	word [SI+SF_ENTRY.sf_flags],devid_device 
 23683 00004FAB 7502                    	JNZ	short IOTO33		;AN000;
 23684 00004FAD EB7C                    	JMP	IOTOFILE		;AN000;
 23685                                  IOTO33:
 23686 00004FAF E884C6                  	call	save_world
 23687 00004FB2 8CDA                    	MOV	DX,DS
 23688 00004FB4 8CD3                    	MOV	BX,SS
 23689 00004FB6 8EDB                    	MOV	DS,BX
 23690 00004FB8 8EC3                    	MOV	ES,BX
 23691 00004FBA 31DB                    	XOR	BX,BX
 23692 00004FBC 80FC05                  	cmp	ah,5		    ; system wait enabled?
 23693 00004FBF 7504                    	jnz	short _no_sys_wait
 23694 00004FC1 81CB0004                	or	bx,0400H	    ; Set bit 10 in status word for driver
 23695                                  				    ; It is up to device driver to carry out
 23696                                  				    ; appropriate action.
 23697                                  _no_sys_wait:
 23698 00004FC5 891E[4903]              	MOV	[IOCALL_REQSTAT],BX
 23699 00004FC9 31DB                    	XOR	BX,BX
 23700 00004FCB 881E[5303]              	MOV	[IOMED],BL
 23701                                  
 23702 00004FCF 88E3                    	MOV	BL,AH		 	; get function
 23703 00004FD1 8AA7[4213]              	MOV	AH,[BX+LenTab]
 23704 00004FD5 D1E3                    	SHL	BX,1
 23705 00004FD7 8B8F[4813]              	MOV	CX,[BX+CmdTab]
 23706 00004FDB BB[4603]                	MOV	BX,IOCALL
 23707 00004FDE 8826[4603]              	MOV	[IOCALL_REQLEN],AH
 23708 00004FE2 882E[4803]              	MOV	[IOCALL_REQFUNC],CH
 23709                                  
 23710 00004FE6 8EDA                    	MOV	DS,DX
 23711 00004FE8 E84401                  	CALL	DEVIOCALL
 23712 00004FEB 368B3E[4903]            	MOV	DI,[SS:IOCALL_REQSTAT]	; SS override
 23713                                  	;test	di,8000h
 23714                                  	;jnz	short DevErr
 23715 00004FF0 21FF                    	and	di,di
 23716 00004FF2 7820                    	js	short DevErr
 23717                                  
 23718                                  OKDevIO:
 23719 00004FF4 8CD0                    	MOV	AX,SS
 23720 00004FF6 8ED8                    	MOV	DS,AX
 23721                                  
 23722                                  	;cmp	ch, 5
 23723 00004FF8 80FD05                  	CMP	CH,DEVRDND
 23724 00004FFB 7506                    	JNZ	short DNODRD
 23725 00004FFD A0[5303]                	MOV	AL,[IORCHR]
 23726 00005000 A2[8003]                	MOV	[DEVIOBUF],AL
 23727                                  
 23728                                  DNODRD: 
 23729 00005003 8A26[4A03]              	MOV	AH,[IOCALL_REQSTAT+1]
 23730 00005007 F6D4                    	NOT	AH			; Zero = busy, not zero = ready
 23731                                  	;and	ah,2
 23732 00005009 80E402                  	AND	AH,STBUI>>8
 23733                                  
 23734                                  QuickReturn:				;AN000; 2/13/KK
 23735 0000500C E814C6                  	call	restore_world
 23736                                  
 23737                                  	; SR;
 23738                                  	; We return ax = -1 if the user failed on I24. This is the case if 
 23739                                  	; IoStatFail = -1 (set after return from the I24)
 23740                                  	;
 23741                                  
 23742                                  	; MSDOS 6.0
 23743                                  	;pushf
 23744                                  	;mov	al,[ss:IoStatFail]	;assume fail error
 23745                                  	;cbw				;sign extend to word
 23746                                  	;cmp	ax,-1
 23747                                  	;jne	short not_fail_ret
 23748                                  	;inc	byte [ss:IoStatFail]
 23749                                  	;popf
 23750                                  	;retn
 23751                                  
 23752                                  ;not_fail_ret:
 23753 0000500F 36A1[8003]              	MOV	AX,[SS:DEVIOBUF]	;ss override
 23754                                  	;popf
 23755 00005013 C3                      	retn
 23756                                  
 23757                                  ;IOTOFILEJ:
 23758                                  ;	JMP	SHORT IOTOFILE
 23759                                  
 23760                                  DevErr:
 23761 00005014 88CC                    	MOV	AH,CL
 23762 00005016 E8F30A                  	call	CHARHARD
 23763 00005019 3C01                    	CMP	AL,1
 23764 0000501B 7506                    	JNZ	short NO_RETRY
 23765 0000501D E803C6                  	call	restore_world		
 23766 00005020 E962FF                  	JMP	IOFUNC	; 10/08/2018
 23767                                  
 23768                                  NO_RETRY:
 23769                                  
 23770                                  	; Know user must have wanted Ignore OR Fail. Make sure device shows ready
 23771                                  	; ready so that DOS doesn't get caught in a status loop when user 
 23772                                  	; simply wants to ignore the error.
 23773                                  	;
 23774                                  	; SR; If fail wanted by user set ax to special value (ax = -1). This 
 23775                                  	; should be checked by the caller on return
 23776                                  	;
 23777                                  
 23778                                  					; SS override
 23779 00005023 368026[4A03]FD          	and	byte [SS:IOCALL_REQSTAT+1],0FDh
 23780                                  	;AND	BYTE [SS:IOCALL_REQSTAT+1],~(STBUI >> 8)
 23781                                  
 23782                                  	; SR;
 23783                                  	; Check if user failed
 23784                                  	;
 23785                                  
 23786                                  	; MSDOS 6.0
 23787                                  	;cmp	al,3
 23788                                  	;jnz	short not_fail
 23789                                  	;dec	byte [ss:IoStatFail]	;set flag indicating fail on I24
 23790                                  ;not_fail:
 23791 00005029 EBC9                    	JMP	short OKDevIO
 23792                                  
 23793                                  IOTOFILE:
 23794 0000502B 08E4                    	OR	AH,AH
 23795 0000502D 7423                    	JZ	short IOIN
 23796 0000502F FECC                    	DEC	AH
 23797 00005031 7405                    	JZ	short IOIST
 23798 00005033 FECC                    	DEC	AH
 23799 00005035 7411                    	JZ	short IOUT
 23800 00005037 C3                      	retn				; NON ZERO FLAG FOR OUTPUT STATUS
 23801                                  
 23802                                  IOIST:
 23803                                  	;push	word [si+15h]
 23804 00005038 FF7415                  	PUSH	WORD [SI+SF_ENTRY.sf_position]   ; Save position
 23805                                  	;push	word [si+17h]
 23806 0000503B FF7417                  	PUSH	WORD [SI+SF_ENTRY.sf_position+2]
 23807 0000503E E81100                  	CALL	IOIN
 23808                                  	;pop	word [si+17h]
 23809 00005041 8F4417                  	POP	WORD [SI+SF_ENTRY.sf_position+2] ; Restore position
 23810                                  	;pop	word [si+15h]
 23811 00005044 8F4415                  	POP	WORD [SI+SF_ENTRY.sf_position]
 23812 00005047 C3                      	retn
 23813                                  
 23814                                  IOUT:
 23815 00005048 E81B00                  	CALL	SETXADDR
 23816 0000504B E806F0                  	call	DOS_WRITE
 23817 0000504E E84800                  	CALL	RESTXADDR	; If you change this into a jmp don't
 23818                                  IOUT_retn:
 23819 00005051 C3                      	retn			; come crying to me when things don't
 23820                                  				; work ARR
 23821                                  IOIN:
 23822 00005052 E81100                  	CALL	SETXADDR
 23823                                  					; SS override for DOS34_FLAG
 23824                                  	;OR	word [SS:DOS34_FLAG],Disable_EOF_I24	;AN000;
 23825 00005055 E871EE                  	CALL	DOS_READ
 23826                                  	;AND	word [SS:DOS34_FLAG],NO_Disable_EOF_I24 ;AN000;
 23827 00005058 09C9                    	OR	CX,CX			; Check EOF
 23828 0000505A E83C00                  	CALL	RESTXADDR
 23829                                  					; SS override
 23830 0000505D 36A0[8003]              	MOV	AL,[SS:DEVIOBUF]	; Get byte from trans addr
 23831 00005061 75EE                    	jnz	short IOUT_retn	
 23832 00005063 B01A                    	MOV	AL,1AH			; ^Z if no bytes
 23833 00005065 C3                      	retn
 23834                                  
 23835                                  SETXADDR:
 23836                                  					; SS override
 23837 00005066 368F06[3603]            	POP	WORD [SS:CALLSCNT]	; Return address
 23838                                  
 23839 0000506B E8C8C5                  	call	save_world
 23840                                  
 23841                                  					; SS override for DMAADD and THISSFT
 23842 0000506E 36FF36[F802]            	PUSH	WORD [SS:DMAADD]	; Save Disk trans addr
 23843 00005073 36FF36[FA02]            	PUSH	WORD [SS:DMAADD+2]
 23844 00005078 368C1E[5C05]            	MOV	[SS:THISSFT+2],DS
 23845                                  
 23846 0000507D 16                      	push	ss
 23847 0000507E 1F                      	pop	ds
 23848                                  
 23849 0000507F 8936[5A05]              	MOV	[THISSFT],SI		; Finish setting SFT pointer
 23850 00005083 8B0E[5603]              	MOV	CX,[IOXAD+2]
 23851 00005087 890E[FA02]              	MOV	[DMAADD+2],CX
 23852 0000508B 8B0E[5403]              	MOV	CX,[IOXAD]
 23853 0000508F 890E[F802]              	MOV	[DMAADD],CX		; Set byte trans addr
 23854 00005093 8B0E[5803]              	MOV	CX,[IOSCNT]		; ioscnt specifies length of buffer
 23855 00005097 EB0F                    	JMP	SHORT RESTRET		; RETURN ADDRESS
 23856                                  
 23857                                  RESTXADDR:
 23858 00005099 8F06[3603]              	POP	WORD [CALLSCNT]		; Return address
 23859 0000509D 8F06[FA02]              	POP	WORD [DMAADD+2]		; Restore Disk trans addr
 23860 000050A1 8F06[F802]              	POP	WORD [DMAADD]
 23861                                  
 23862 000050A5 E87BC5                  	call	restore_world
 23863                                  					; SS override
 23864                                  RESTRET:
 23865 000050A8 36FF26[3603]            	JMP	WORD [SS:CALLSCNT]	; Return address
 23866                                  
 23867                                  
 23868                                  ; 29/07/2018 - Retro DOS v3.0
 23869                                  ; IBMDOS.COM (1987) - Offset 4D82h
 23870                                  
 23871                                  ;Break <DEV_OPEN_SFT, DEV_CLOSE_SFT - OPEN or CLOSE A DEVICE>
 23872                                  
 23873                                  ;----------------------------------------------------------------------------
 23874                                  ;**	Dev_Open_SFT - Open the Device for an SFT
 23875                                  ;
 23876                                  ;	Dev_Open_SFT issues an open call to the device associated with
 23877                                  ;	the SFT.
 23878                                  ;
 23879                                  ;	ENTRY	(ES:DI) = SFT
 23880                                  ;	EXIT	none
 23881                                  ;	USES	all
 23882                                  ;----------------------------------------------------------------------------
 23883                                  
 23884                                  DEV_OPEN_SFT:
 23885 000050AD E886C5                  	call	save_world
 23886                                  	;mov	al,0Dh	
 23887 000050B0 B00D                    	MOV	AL,DEVOPN
 23888 000050B2 EB05                    	JMP	SHORT DO_OPCLS
 23889                                  
 23890                                  ;----------------------------------------------------------------------------
 23891                                  ; Procedure Name : DEV_CLOSE_SFT
 23892                                  ;
 23893                                  ; Inputs:
 23894                                  ;	ES:DI Points to SFT
 23895                                  ; Function:
 23896                                  ;	Issue a CLOSE call to the correct device
 23897                                  ; Outputs:
 23898                                  ;	None
 23899                                  ; ALL preserved
 23900                                  ;----------------------------------------------------------------------------
 23901                                  
 23902                                  DEV_CLOSE_SFT:
 23903 000050B4 E87FC5                  	call	save_world
 23904                                  	;mov	al,0Eh	
 23905 000050B7 B00E                    	MOV	AL,DEVCLS
 23906                                  
 23907                                  	; Main entry for device open and close. AL contains the function 
 23908                                  	; requested. Subtlety: if Sharing is NOT loaded then we do NOT issue 
 23909                                  	; open/close to block devices. This allows networks to function but 
 23910                                  	; does NOT hang up with bogus change-line code.
 23911                                  
 23912                                  	;entry	DO_OPCLS
 23913                                  DO_OPCLS:
 23914                                  	; Is the SFT for the net?  If so, no action necessary.
 23915                                  
 23916                                  	; MSDOS 3.3
 23917                                  	;call	IsSFTNet
 23918                                  	;jnz	short OPCLS_DONE
 23919                                  
 23920                                  	; MSDOS 6.0
 23921                                  	;test	word [es:di+5],8000h
 23922 000050B9 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 23923 000050BF 756A                    	JNZ	short OPCLS_DONE	; NOP on net SFTs
 23924 000050C1 30E4                    	XOR	AH,AH			; Unit
 23925                                  	;test	word [es:di+5],80h
 23926 000050C3 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 23927                                  	;les	di,[es:di+7]
 23928 000050C9 26C47D07                	LES	DI,[ES:DI+SF_ENTRY.sf_devptr] ; Get DPB or device
 23929 000050CD 7513                    	JNZ	short GOT_DEV_ADDR
 23930                                  
 23931                                  	; We are about to call device open/close on a block driver. If no 
 23932                                  	; sharing then just short circuit to done.
 23933                                  	
 23934                                  ;;;;;	invoke	CheckShare
 23935                                  
 23936                                  	; MSDOS 3.3
 23937                                  	;call	CheckShare	; cmp byte [cs:fShare],0
 23938                                  	;jz	short OPCLS_DONE
 23939                                  
 23940                                  	; MSDOS 6.0
 23941                                  					; SS override
 23942 000050CF 36803E[CF02]01          	CMP	byte [ss:fShare],1	;AN010; /NC or no SHARE
 23943 000050D5 7654                    	JBE	short OPCLS_DONE	;AN010; yes
 23944                                  
 23945                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23946                                  	;mov	ah,[es:di+1]
 23947 000050D7 268A6501                	MOV	AH,[ES:DI+DPB.UNIT]	; (ah) = unit
 23948 000050DB 268A0D                  	mov	cl,[es:di]
 23949                                  	;MOV	CL,[ES:DI+DPB.DRIVE]	; (cl) = drive
 23950                                  	;les	di,[es:di+12h]
 23951 000050DE 26C47D13                	LES	DI,[ES:DI+DPB.DRIVER_ADDR] ; Get device
 23952                                  GOT_DEV_ADDR:				; ES:DI -> device
 23953                                  	;test	word [es:di+4],800h
 23954 000050E2 26F745040008            	TEST	word [ES:DI+SYSDEV.ATT],DEVOPCL
 23955 000050E8 7441                    	JZ	short OPCLS_DONE	; Device can't
 23956 000050EA 06                      	PUSH	ES
 23957 000050EB 1F                      	POP	DS
 23958 000050EC 89FE                    	MOV	SI,DI			; DS:SI -> device
 23959                                  OPCLS_RETRY:
 23960                                  	;Context ES
 23961 000050EE 16                      	push	ss
 23962 000050EF 07                      	pop	es
 23963                                  					; DEVCALL is in DOSDATA
 23964 000050F0 BF[2403]                	MOV	DI,DEVCALL
 23965                                  
 23966 000050F3 89FB                    	MOV	BX,DI
 23967 000050F5 50                      	PUSH	AX
 23968                                  	;mov	al,13
 23969 000050F6 B00D                    	MOV	AL,DOPCLHL
 23970 000050F8 AA                      	STOSB				; Length
 23971 000050F9 58                      	POP	AX
 23972 000050FA 86E0                    	XCHG	AH,AL
 23973 000050FC AA                      	STOSB				; Unit
 23974 000050FD 86E0                    	XCHG	AH,AL
 23975 000050FF AA                      	STOSB				; Command
 23976 00005100 26C7050000              	MOV	WORD [ES:DI],0		; Status
 23977 00005105 50                      	PUSH	AX			; Save Unit,Command
 23978                                  	;invoke	DEVIOCALL2
 23979 00005106 E82900                  	call	DEVIOCALL2
 23980                                  
 23981                                  	;mov	di,[es:bx+3]
 23982 00005109 268B7F03                	MOV	DI,[ES:BX+SRHEAD.REQSTAT]
 23983                                  	;test	di,8000h
 23984                                  	;jz	short OPCLS_DONEP	
 23985 0000510D 21FF                    	and	di,di
 23986 0000510F 7919                    	jns	short OPCLS_DONEP	; No error
 23987                                  	;test	word [si+4],8000h
 23988                                  	; 22/11/2022 (!BugFix!)
 23989                                  	;TEST	word [ES:DI+SYSDEV.ATT],DEVTYP
 23990 00005111 F744040080              	test	word [SI+SYSDEV.ATT],DEVTYP ; 22/11/2022
 23991 00005116 7404                    	JZ	short BLKDEV
 23992 00005118 B486                    	MOV	AH,86H			; Read error in data, Char dev
 23993 0000511A EB04                    	JMP	SHORT HRDERR
 23994                                  
 23995                                  BLKDEV:
 23996 0000511C 88C8                    	MOV	AL,CL			; Drive # in AL
 23997 0000511E B406                    	MOV	AH,6			; Read error in data, Blk dev
 23998                                  HRDERR:
 23999                                  	;invoke	CHARHARD
 24000 00005120 E8E909                  	call	CHARHARD
 24001 00005123 3C01                    	CMP	AL,1
 24002 00005125 7503                    	JNZ	short OPCLS_DONEP	; IGNORE or FAIL
 24003                                  					;  Note that FAIL is essentually IGNORED
 24004 00005127 58                      	POP	AX			; Get back Unit, Command
 24005 00005128 EBC4                    	JMP	short OPCLS_RETRY
 24006                                  
 24007                                  OPCLS_DONEP:
 24008 0000512A 58                      	POP	AX			; Clean stack
 24009                                  OPCLS_DONE:
 24010 0000512B E8F5C4                  	call	restore_world
 24011 0000512E C3                      	retn
 24012                                  
 24013                                  ;Break	<DEVIOCALL, DEVIOCALL2 - CALL A DEVICE>
 24014                                  ;----------------------------------------------------------------------------
 24015                                  ;**	DevIoCall  - Call Device
 24016                                  ;
 24017                                  ;	ENTRY	DS:SI Points to device SFT
 24018                                  ;		ES:BX Points to request data
 24019                                  ;	EXIT	DS:SI -> Device driver
 24020                                  ;	USES	DS:SI,AX
 24021                                  ;----------------------------------------------------------------------------
 24022                                  ;**	DevIoCall2 - Call Device
 24023                                  ;
 24024                                  ;	ENTRY	DS:SI Points to DPB
 24025                                  ;		ES:BX Points to request data
 24026                                  ;	EXIT	DS:SI -> Device driver
 24027                                  ;	USES	DS:SI,AX
 24028                                  ;----------------------------------------------------------------------------
 24029                                  
 24030                                  DEVIOCALL:
 24031                                  					; SS override for CALLSSEC, 
 24032                                  	;lds	si,[si+7]		; CALLNEWSC, HIGH_SECTOR & CALLDEVAD
 24033 0000512F C57407                  	LDS	SI,[SI+SF_ENTRY.sf_devptr]
 24034                                  
 24035                                  	;entry	DEVIOCALL2
 24036                                  DEVIOCALL2:
 24037                                  	;EnterCrit critDevice
 24038 00005132 E8E8CF                  	call	EcritDevice
 24039                                  
 24040                                  	; 23/07/2019 - Retro DOS v3.2
 24041                                  
 24042                                  	; MSDOS 6.0
 24043                                  	;TEST	word [SI+SYSDEV.ATT],DEVTYP ;AN000; >32mb block device ?
 24044                                  	;test	byte [si+5],80h
 24045 00005135 F6440580                	test	byte [si+SYSDEV.ATT+1],(DEVTYP>>8) ; 80h
 24046 00005139 7548                    	jnz	short chardev2		;AN000; >32mb no
 24047                                  	
 24048                                  	;cmp	byte [es:bx+2],4
 24049 0000513B 26807F0204              	CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVRD  ;AN000; >32mb read ?
 24050 00005140 740E                    	JZ	short chkext		;AN000; >32mb   yes
 24051                                  	;cmp	byte [es:bx+2],8
 24052 00005142 26807F0208              	CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRT ;AN000; >32mb write ?
 24053 00005147 7407                    	JZ	short chkext		;AN000; >32mb   yes
 24054                                  	;cmp	byte [es:bx+2],9
 24055 00005149 26807F0209              	CMP	byte [ES:BX+SRHEAD.REQFUNC],DEVWRTV
 24056                                  					;AN000; >32mb write/verify ?
 24057 0000514E 7533                    	JNZ	short chardev2		;AN000; >32mb no
 24058                                  chkext:
 24059                                  	;CALL	RW_SC			;AN000;LB. use secondary cache if there
 24060                                  	;JC	short dev_exit		;AN000;LB. done
 24061                                  
 24062                                  	;test	byte [si+4],2
 24063 00005150 F6440402                	TEST	byte [SI+SYSDEV.ATT],EXTDRVR ;AN000;>32mb extended driver?
 24064 00005154 741D                    	JZ	short chksector		;AN000;>32mb   no
 24065 00005156 26800708                	ADD	BYTE [ES:BX],8		;AN000;>32mb   make length to 30
 24066 0000515A 36A1[3803]              	MOV	AX,[SS:CALLSSEC]	;AN000;>32mb
 24067 0000515E 36C706[3803]FFFF        	MOV	word [SS:CALLSSEC],-1	;AN000;>32mb   old sector  =-1
 24068 00005165 36A3[3E03]              	MOV	[SS:CALLNEWSC],AX	;AN000;>32mb   new sector  =
 24069 00005169 36A1[B005]              	MOV	AX,[SS:HIGH_SECTOR]	;AN000; >32mb  low sector,high sector
 24070 0000516D 36A3[4003]              	MOV	[SS:CALLNEWSC+2],AX	;AN000; >32mb
 24071 00005171 EB10                    	JMP	short chardev2		;AN000; >32mb
 24072                                  chksector:				;AN000; >32mb
 24073 00005173 36833E[B005]00          	CMP	word [SS:HIGH_SECTOR],0	;AN000; >32mb   if >32mb
 24074 00005179 7408                    	JZ	short chardev2		;AN000; >32mb   then fake error
 24075                                  	;mov	word [es:bx+3],8107h
 24076 0000517B 26C747030781            	MOV	word [ES:BX+SRHEAD.REQSTAT],STERR+STDON+error_I24_not_DOS_disk 
 24077                                  					;AN000; >32mb
 24078 00005181 EB1D                    	JMP	SHORT dev_exit		;AN000; >32mb
 24079                                  
 24080                                  chardev2:				;AN000;
 24081                                  
 24082                                  	; As above only DS:SI points to device header on entry, and DS:SI is 
 24083                                  	; preserved
 24084                                  
 24085                                  	;mov	ax,[si+6]
 24086 00005183 8B4406                  	MOV	AX,[SI+SYSDEV.STRAT]
 24087 00005186 36A3[4203]              	MOV	[SS:CALLDEVAD],AX
 24088 0000518A 368C1E[4403]            	MOV	[SS:CALLDEVAD+2],DS
 24089 0000518F 36FF1E[4203]            	CALL	far [SS:CALLDEVAD]
 24090                                  	;mov	ax,[si+8]
 24091 00005194 8B4408                  	MOV	AX,[SI+SYSDEV.INT]
 24092 00005197 36A3[4203]              	MOV	[SS:CALLDEVAD],AX
 24093 0000519B 36FF1E[4203]            	CALL	far [SS:CALLDEVAD]
 24094                                  	; MSDOS 6.0
 24095                                  	;CALL	VIRREAD 		;AN000;LB. move data from SC to buffer
 24096                                  	;JC	short chardev2		;AN000;LB. bad sector or exceeds max sec
 24097                                  dev_exit:
 24098                                  	;LeaveCrit critDevice
 24099 000051A0 E882CF                  	call	LcritDevice
 24100 000051A3 C3                      	retn
 24101                                  
 24102                                  ;Break	<SETREAD, SETWRITE -- SET UP HEADER BLOCK>
 24103                                  ;---------------------------------------------------------------------------
 24104                                  ;
 24105                                  ; Procedure Name : SETREAD, SETWRITE
 24106                                  ;
 24107                                  ; Inputs:
 24108                                  ;	DS:BX = Transfer Address
 24109                                  ;	CX = Record Count
 24110                                  ;	DX = Starting Record
 24111                                  ;	AH = Media Byte
 24112                                  ;	AL = Unit Code
 24113                                  ; Function:
 24114                                  ;	Set up the device call header at DEVCALL
 24115                                  ; Output:
 24116                                  ;	ES:BX Points to DEVCALL
 24117                                  ; No other registers effected
 24118                                  ;
 24119                                  ;---------------------------------------------------------------------------
 24120                                  
 24121                                  SETREAD:
 24122 000051A4 57                      	PUSH	DI
 24123 000051A5 51                      	PUSH	CX
 24124 000051A6 50                      	PUSH	AX
 24125 000051A7 B104                    	MOV	CL,DEVRD ; mov cl,4
 24126                                  SETCALLHEAD:
 24127 000051A9 B016                    	MOV	AL,DRDWRHL ; mov al,16h
 24128 000051AB 16                      	PUSH	SS
 24129 000051AC 07                      	POP	ES
 24130                                  					; DEVCALL is in DOSDATA
 24131 000051AD BF[2403]                	MOV	DI,DEVCALL
 24132                                  
 24133 000051B0 AA                      	STOSB				; length
 24134 000051B1 58                      	POP	AX
 24135 000051B2 AA                      	STOSB				; Unit
 24136 000051B3 50                      	PUSH	AX
 24137 000051B4 88C8                    	MOV	AL,CL
 24138 000051B6 AA                      	STOSB				; Command code
 24139 000051B7 31C0                    	XOR	AX,AX
 24140 000051B9 AB                      	STOSW				; Status
 24141 000051BA 83C708                  	ADD	DI,8			; Skip link fields
 24142 000051BD 58                      	POP	AX
 24143 000051BE 86E0                    	XCHG	AH,AL
 24144 000051C0 AA                      	STOSB				; Media byte
 24145 000051C1 86C4                    	XCHG	AL,AH
 24146 000051C3 50                      	PUSH	AX
 24147 000051C4 89D8                    	MOV	AX,BX
 24148 000051C6 AB                      	STOSW
 24149 000051C7 8CD8                    	MOV	AX,DS
 24150 000051C9 AB                      	STOSW				; Transfer addr
 24151 000051CA 59                      	POP	CX			; Real AX
 24152 000051CB 58                      	POP	AX			; Real CX
 24153 000051CC AB                      	STOSW				; Count
 24154 000051CD 92                      	XCHG	AX,DX			; AX=Real DX, DX=real CX, CX=real AX
 24155 000051CE AB                      	STOSW				; Start
 24156 000051CF 91                      	XCHG	AX,CX
 24157 000051D0 87D1                    	XCHG	DX,CX
 24158 000051D2 5F                      	POP	DI
 24159                                  					; DEVCALL is in DOSDATA
 24160 000051D3 BB[2403]                	MOV	BX,DEVCALL
 24161 000051D6 C3                      	retn
 24162                                  
 24163                                  	;entry	SETWRITE
 24164                                  SETWRITE:
 24165                                  
 24166                                  ; Inputs:
 24167                                  ;	DS:BX = Transfer Address
 24168                                  ;	CX = Record Count
 24169                                  ;	DX = Starting Record
 24170                                  ;	AH = Media Byte
 24171                                  ;	AL = Unit Code
 24172                                  ; Function:
 24173                                  ;	Set up the device call header at DEVCALL
 24174                                  ; Output:
 24175                                  ;	ES:BX Points to DEVCALL
 24176                                  ; No other registers effected
 24177                                  
 24178 000051D7 57                      	PUSH	DI
 24179 000051D8 51                      	PUSH	CX
 24180 000051D9 50                      	PUSH	AX
 24181 000051DA B108                    	MOV	CL,DEVWRT ; mov cl,8
 24182 000051DC 36020E[CB02]            	ADD	CL,[SS:VERFLG]		; SS override
 24183 000051E1 EBC6                    	JMP	SHORT SETCALLHEAD
 24184                                  
 24185                                  ;Break	<RW_SC -- Read Write Secondary Cache>
 24186                                  ;---------------------------------------------------------------------------
 24187                                  ;
 24188                                  ; Procedure Name : RW_SC
 24189                                  ;
 24190                                  ; Inputs:
 24191                                  ;	 [SC_CACHE_COUNT]= secondary cache count
 24192                                  ;	 [SC_STATUS]= SC validity status
 24193                                  ;	 [SEQ_SECTOR]= last sector read
 24194                                  ; Function:
 24195                                  ;	Read from or write through secondary cache
 24196                                  ; Output:
 24197                                  ;	ES:BX Points to DEVCALL
 24198                                  ;	carry clear, I/O is not done
 24199                                  ;		     [SC_FLAG]=1 if continuos sectors will be read
 24200                                  ;	carry set, I/O is done
 24201                                  ;
 24202                                  ;----------------------------------------------------------------------------
 24203                                  
 24204                                  ;procedure   RW_SC,NEAR		;AN000;
 24205                                  ;
 24206                                  ;	; SS override for all variables used.
 24207                                  ;
 24208                                  ;	CMP	[SC_CACHE_COUNT],0	;AN000;LB. secondary cache exists?
 24209                                  ;	JZ	scexit4 		;AN000;LB. no, do nothing
 24210                                  ;	CMP	[CALLSCNT],1		;AN000;LB. sector count = 1 (buffer I/O)
 24211                                  ;	JNZ	scexit4 		;AN000;LB. no, do nothing
 24212                                  ;	PUSH	CX			    ;AN000;;LB.
 24213                                  ;	PUSH	DX			    ;AN000;;LB. yes
 24214                                  ;	PUSH	DS			    ;AN000;;LB. save registers
 24215                                  ;	PUSH	SI			    ;AN000;;LB.
 24216                                  ;	PUSH	ES			    ;AN000;;LB.
 24217                                  ;	PUSH	DI			    ;AN000;;LB.
 24218                                  ;	MOV	DX,WORD PTR [CALLSSEC]	    ;AN000;;LB.  starting sector
 24219                                  ;	CMP	BYTE PTR [DEVCALL.REQFUNC],DEVRD ;AN000;LB. read ?
 24220                                  ;	JZ	doread			    ;AN000;LB. yes
 24221                                  ;	CALL	INVALIDATE_SC		    ;AN000;LB. invalidate SC
 24222                                  ;	JMP	scexit2 		    ;AN000;LB. back to normal
 24223                                  ;scexit4:				    ;AN000;
 24224                                  ;	CLC				    ;AN000;LB. I/O not done yet
 24225                                  ;	return				    ;AN000;LB.
 24226                                  ;doread: 				    ;AN000;
 24227                                  ;	CALL	SC2BUF			    ;AN000;LB. check if in SC
 24228                                  ;	JC	readSC			    ;AN000;LB.
 24229                                  ;	MOV	[DEVCALL.REQSTAT],STDON     ;AN000;LB. fake done and ok
 24230                                  ;	STC				    ;AN000;LB. set carry
 24231                                  ;	JMP	short saveseq 		    ;AN000;LB. save seq. sector #
 24232                                  ;readSC: 				    ;AN000;
 24233                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
 24234                                  ;	MOV	CX,WORD PTR [CALLSSEC]	    ;AN000;;LB. saved sequential sector
 24235                                  ;	SUB	CX,WORD PTR [SEQ_SECTOR]    ;AN000;;LB. number
 24236                                  ;	SBB	AX,WORD PTR [SEQ_SECTOR+2]  ;AN000;;LB.
 24237                                  ;	CMP	AX,0			    ;AN000;;LB. greater than 64K
 24238                                  ;	JNZ	saveseq2		    ;AN000;;LB. yes,save seq. sector #
 24239                                  ;chklow: 						
 24240                                  ;	CMP	CX,1			    ;AN000;;LB. <= 1
 24241                                  ;	JA	saveseq2		    ;AN000;;LB. no, not sequential
 24242                                  ;	MOV	[SC_STATUS],-1		    ;AN000;;LB. prsume all SC valid
 24243                                  ;	MOV	AX,[SC_CACHE_COUNT]	    ;AN000;;LB. yes, sequential
 24244                                  ;	MOV	[CALLSCNT],AX		    ;AN000;;LB. read continuous sectors
 24245                                  ;readsr:
 24246                                  ;	MOV	AX,WORD PTR [CALLXAD+2]     ;AN000;;LB. save buffer addr
 24247                                  ;	MOV	[TEMP_VAR2],AX		    ;AN000;;LB. in temp vars
 24248                                  ;	MOV	AX,WORD PTR [CALLXAD]	    ;AN000;;LB.
 24249                                  ;	MOV	[TEMP_VAR],AX		    ;AN000;;LB.
 24250                                  ;						
 24251                                  ;	MOV	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;LB. use SC cache addr as
 24252                                  ;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;LB. transfer addr
 24253                                  ;	MOV	AX,WORD PTR [SC_CACHE_PTR+2] ;AN000;LB.
 24254                                  ;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;LB.
 24255                                  ;	MOV	[SC_FLAG],1		    ;AN000;LB. flag it for later;
 24256                                  ;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
 24257                                  ;	MOV	[CURSC_DRIVE],AL	    ;AN000;;LB. set current drive
 24258                                  ;	MOV	AX,WORD PTR [CALLSSEC]	    ;AN000;;LB. current sector
 24259                                  ;	MOV	[CURSC_SECTOR],AX	    ;AN000;;LB. set current sector
 24260                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB.
 24261                                  ;	MOV	[CURSC_SECTOR+2],AX	    ;AN000;;LB.
 24262                                  ;saveseq2:				    ;AN000;
 24263                                  ;	CLC				    ;AN000;LB. clear carry
 24264                                  ;saveseq:				    ;AN000;	
 24265                                  ;	MOV	AX,[HIGH_SECTOR]	    ;AN000;LB. save current sector #
 24266                                  ;	MOV	WORD PTR [SEQ_SECTOR+2],AX  ;AN000;LB. for access mode ref.
 24267                                  ;	MOV	AX,[CALLSSEC]		    ;AN000;LB.	
 24268                                  ;	MOV	WORD PTR [SEQ_SECTOR],AX    ;AN000;LB.	
 24269                                  ;	JMP	short scexit 		    ;AN000;LB.	
 24270                                  ;						
 24271                                  ;scexit2:				    ;AN000;LB.
 24272                                  ;	CLC				    ;AN000;LB.	clear carry
 24273                                  ;scexit: 				    ;AN000;		
 24274                                  ;	POP	DI			    ;AN000;;LB.
 24275                                  ;	POP	ES			    ;AN000;;LB. restore registers
 24276                                  ;	POP	SI			    ;AN000;;LB.
 24277                                  ;	POP	DS			    ;AN000;;LB.
 24278                                  ;	POP	DX			    ;AN000;;LB.
 24279                                  ;	POP	CX			    ;AN000;;LB.
 24280                                  ;	return				    ;AN000;;LB.
 24281                                  ;							
 24282                                  ;EndProc RW_SC				    ;AN000;
 24283                                  
 24284                                  ;Break	<IN_SC -- check if in secondary cache>
 24285                                  ;--------------------------------------------------------------------------
 24286                                  ;
 24287                                  ; Procedure Name : IN_SC
 24288                                  ;
 24289                                  ; Inputs:  [SC_DRIVE]= requesting drive
 24290                                  ;	   [CURSC_DRIVE]= current SC drive
 24291                                  ;	   [CURSC_SECTOR] = starting scetor # of SC
 24292                                  ;	   [SC_CACHE_COUNT] = SC count
 24293                                  ;	   [HIGH_SECTOR]:DX= sector number
 24294                                  ; Function:
 24295                                  ;	Check if the sector is in secondary cache
 24296                                  ; Output:
 24297                                  ;	carry clear, in SC
 24298                                  ;	   CX= the index in the secondary cache
 24299                                  ;	carry set, not in SC
 24300                                  ;
 24301                                  ;---------------------------------------------------------------------------
 24302                                  
 24303                                  ;procedure   IN_SC,NEAR		    ;AN000;
 24304                                  ;
 24305                                  ;	; SS override for all variables used
 24306                                  ;
 24307                                  ;	MOV	AL,[SC_DRIVE]		    ;AN000;;LB. current drive
 24308                                  ;	CMP	AL,[CURSC_DRIVE]	    ;AN000;;LB. same as SC drive
 24309                                  ;	JNZ	outrange2		    ;AN000;;LB. no
 24310                                  ;	MOV	AX,WORD PTR [HIGH_SECTOR]   ;AN000;;LB. subtract sector num from
 24311                                  ;	MOV	CX,DX			    ;AN000;;LB. secondary starting sector
 24312                                  ;	SUB	CX,WORD PTR [CURSC_SECTOR]    ;AN000;;LB. number
 24313                                  ;	SBB	AX,WORD PTR [CURSC_SECTOR+2]  ;AN000;;LB.
 24314                                  ;	CMP	AX,0			    ;AN000;;LB. greater than 64K
 24315                                  ;	JNZ	outrange2		    ;AN000;;LB. yes
 24316                                  ;	CMP	CX,[SC_CACHE_COUNT]	    ;AN000;;LB. greater than SC count
 24317                                  ;	JAE	outrange2		    ;AN000;;LB. yes
 24318                                  ;	CLC				    ;AN000;;LB. clear carry
 24319                                  ;	JMP	short inexit		    ;AN000;;LB. in SC
 24320                                  ;outrange2:				    ;AN000;;LB. set carry
 24321                                  ;	STC				    ;AN000;;LB.
 24322                                  ;inexit: 				    ;AN000;;LB.
 24323                                  ;	return				    ;AN000;;LB.
 24324                                  ;
 24325                                  ;EndProc IN_SC				    ;AN000;
 24326                                  
 24327                                  ;Break	<INVALIDATE_SC - invalide secondary cache>
 24328                                  ;---------------------------------------------------------------------------
 24329                                  ;
 24330                                  ; Procedure Name : Invalidate_Sc
 24331                                  ;
 24332                                  ; Inputs:  [SC_DRIVE]= requesting drive
 24333                                  ;	   [CURSC_DRIVE]= current SC drive
 24334                                  ;	   [CURSC_SECTOR] = starting scetor # of SC
 24335                                  ;	   [SC_CACHE_COUNT] = SC count
 24336                                  ;	   [SC_STAUS] = SC status word
 24337                                  ;	   [HIGH_SECTOR]:DX= sector number
 24338                                  ;
 24339                                  ; Function:
 24340                                  ;	invalidate secondary cache if in there
 24341                                  ; Output:
 24342                                  ;	[SC_STATUS] is updated
 24343                                  ;---------------------------------------------------------------------------
 24344                                  
 24345                                  ;procedure   INVALIDATE_SC,NEAR	    ;AN000;
 24346                                  ;
 24347                                  ;	; SS override for all variables used
 24348                                  ;
 24349                                  ;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 24350                                  ;	JC	outrange		    ;AN000;;LB. no
 24351                                  ;	MOV	AX,1			    ;AN000;;LB. invalidate the sector
 24352                                  ;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 24353                                  ;	NOT	AX			    ;AN000;;LB.
 24354                                  ;	AND	[SC_STATUS],AX		    ;AN000;;LB. save the status
 24355                                  ;outrange:				    ;AN000;;LB.
 24356                                  ;	return				    ;AN000;;LB.
 24357                                  ;
 24358                                  ;EndProc INVALIDATE_SC			    ;AN000;
 24359                                  
 24360                                  
 24361                                  ;Break	<VIRREAD- virtually read data into buffer>
 24362                                  ;--------------------------------------------------------------------------
 24363                                  ;
 24364                                  ; Procedure Name : SC_FLAG
 24365                                  ;
 24366                                  ; Inputs:  SC_FLAG = 0 , no sectors were read into SC
 24367                                  ;		     1, continous sectors were read into SC
 24368                                  ; Function:
 24369                                  ;	   Move data from SC to buffer
 24370                                  ; Output:
 24371                                  ;	 carry clear, data is moved to buffer
 24372                                  ;	 carry set, bad sector or exceeds maximum sector
 24373                                  ;	   SC_FLAG =0
 24374                                  ;	   CALLSCNT=1
 24375                                  ;	   SC_STATUS= -1 if succeeded
 24376                                  ;     
 24377                                  ;		       0 if failed
 24378                                  ;--------------------------------------------------------------------------
 24379                                  
 24380                                  ;procedure   VIRREAD,NEAR	    ;AN000;
 24381                                  ;
 24382                                  ;	; SS override for all variables used
 24383                                  ;
 24384                                  ;	CMP	[SC_FLAG],0		    ;AN000;;LB.  from SC fill
 24385                                  ;	JZ	sc2end			    ;AN000;;LB.  no
 24386                                  ;	MOV	AX,[TEMP_VAR2]		    ;AN000;;LB. restore buffer addr
 24387                                  ;	MOV	WORD PTR [CALLXAD+2],AX     ;AN000;;LB.
 24388                                  ;	MOV	AX,[TEMP_VAR]		    ;AN000;;LB.
 24389                                  ;	MOV	WORD PTR [CALLXAD],AX	    ;AN000;;LB.
 24390                                  ;	MOV	[SC_FLAG],0		    ;AN000;;LB.  reset sc_flag
 24391                                  ;	MOV	[CALLSCNT],1		    ;AN000;;LB.  one sector transferred
 24392                                  ;
 24393                                  ;	TESTB	[DEVCALL.REQSTAT],STERR     ;AN000;;LB.  error?
 24394                                  ;	JNZ	scerror 		    ;AN000;;LB. yes
 24395                                  ;	PUSH	DS			    ;AN000;;LB.
 24396                                  ;	PUSH	SI			    ;AN000;;LB.
 24397                                  ;	PUSH	ES			    ;AN000;;LB.
 24398                                  ;	PUSH	DI			    ;AN000;;LB.
 24399                                  ;	PUSH	DX			    ;AN000;;LB.
 24400                                  ;	PUSH	CX			    ;AN000;;LB.
 24401                                  ;	XOR	CX,CX			    ;AN000;;LB. we want first sector in SC
 24402                                  ;	CALL	SC2BUF2 		    ;AN000;;LB. move data from SC to buffer
 24403                                  ;	POP	CX			    ;AN000;;LB.
 24404                                  ;	POP	DX			    ;AN000;;LB.
 24405                                  ;	POP	DI			    ;AN000;;LB.
 24406                                  ;	POP	ES			    ;AN000;;LB.
 24407                                  ;	POP	SI			    ;AN000;;LB.
 24408                                  ;	POP	DS			    ;AN000;;LB.
 24409                                  ;	JMP	SHORT sc2end		    ;AN000;;LB. return
 24410                                  ;
 24411                                  ;scerror:				    ;AN000;
 24412                                  ;	MOV	[CALLSCNT],1		    ;AN000;;LB. reset sector count to 1
 24413                                  ;	MOV	[SC_STATUS],0		    ;AN000;;LB. invalidate all SC sectors
 24414                                  ;	MOV	[CURSC_DRIVE],-1	    ;AN000;;LB. invalidate drive
 24415                                  ;	STC				    ;AN000;;LB. carry set
 24416                                  ;	return				    ;AN000;;LB.
 24417                                  ;
 24418                                  ;sc2end: 				    ;AN000;
 24419                                  ;	CLC				    ;AN000;;LB. carry clear
 24420                                  ;	return				    ;AN000;;LB.
 24421                                  ;
 24422                                  ;EndProc VIRREAD 			    ;AN000;
 24423                                  
 24424                                  ;Break	<SC2BUF- move data from SC to buffer>
 24425                                  ;----------------------------------------------------------------------------
 24426                                  ;
 24427                                  ; Procedure Name : SC2BUF
 24428                                  ;
 24429                                  ; Inputs:  [SC_STATUS] = SC validity status
 24430                                  ;	   [SC_SECTOR_SIZE] = request sector size
 24431                                  ;	   [SC_CACHE_PTR] = pointer to SC
 24432                                  ; Function:
 24433                                  ;	   Move data from SC to buffer
 24434                                  ; Output:
 24435                                  ;	   carry clear, in SC  and data is moved
 24436                                  ;	   carry set, not in SC and data is not moved
 24437                                  ;---------------------------------------------------------------------------
 24438                                  
 24439                                  ;procedure   SC2BUF,NEAR 	    ;AN000;
 24440                                  ;
 24441                                  ;	; SS override for all variables used
 24442                                  ;
 24443                                  ;	CALL	IN_SC			    ;AN000;;LB. in secondary cache
 24444                                  ;	JC	noSC			    ;AN000;;LB. no
 24445                                  ;	MOV	AX,1			    ;AN000;;LB. check if valid sector
 24446                                  ;	SHL	AX,CL			    ;AN000;;LB. in the secondary cache
 24447                                  ;	TEST	[SC_STATUS],AX		    ;AN000;;LB.
 24448                                  ;	JZ	noSC			    ;AN000;;LB. invalid
 24449                                  ;entry SC2BUF2				    ;AN000;
 24450                                  ;	MOV	AX,CX			    ;AN000;;LB. times index with
 24451                                  ;	MUL	[SC_SECTOR_SIZE]	    ;AN000;;LB. sector size
 24452                                  ;	ADD	AX,WORD PTR [SC_CACHE_PTR]  ;AN000;;LB. add SC starting addr
 24453                                  ;	ADC	DX,WORD PTR [SC_CACHE_PTR+2];AN000;;LB.
 24454                                  ;	MOV	DS,DX			    ;AN000;    ;LB. DS:SI-> SC sector addr
 24455                                  ;	MOV	SI,AX			    ;AN000;    ;LB.
 24456                                  ;	MOV	ES,WORD PTR [CALLXAD+2]     ;AN000;    ;LB. ES:DI-> buffer addr
 24457                                  ;	MOV	DI,WORD PTR [CALLXAD]	    ;AN000;    ;LB.
 24458                                  ;	MOV	CX,[SC_SECTOR_SIZE]	    ;AN000;    ;LB. count= sector size
 24459                                  ;	SHR	CX,1			    ;AN000;    ;LB. may use DWORD move for 386
 24460                                  ;entry MOVWORDS				    ;AN000;
 24461                                  ;	CMP	[DDMOVE],0		    ;AN000;    ;LB. 386 ?
 24462                                  ;	JZ	nodd			    ;AN000;    ;LB. no
 24463                                  ;	SHR	CX,1			    ;AN000;    ;LB. words/2
 24464                                  ;	DB	66H			    ;AN000;    ;LB. use double word move
 24465                                  ;nodd:
 24466                                  ;	REP	MOVSW			    ;AN000;    ;LB. move to buffer
 24467                                  ;	CLC				    ;AN000;    ;LB. clear carry
 24468                                  ;	return				    ;AN000;    ;LB. exit
 24469                                  ;noSC:					    ;AN000;
 24470                                  ;	STC				    ;AN000;    ;LB. set carry
 24471                                  ;sexit:					    ;AN000;
 24472                                  ;	return				    ;AN000;    ;LB.
 24473                                  ;
 24474                                  ;EndProc SC2BUF
 24475                                  
 24476                                  
 24477                                  ;============================================================================
 24478                                  ; MKNODE.ASM, MSDOS 6.0, 1991
 24479                                  ;============================================================================
 24480                                  ; 29/07/2018 - Retro DOS v3.0
 24481                                  
 24482                                  ;	TITLE	MKNODE - Node maker
 24483                                  ;	NAME	MKNODE
 24484                                  
 24485                                  ;**	MKNODE.ASM
 24486                                  ;
 24487                                  ;	Low level routines for making a new local file system node
 24488                                  ;	and filling in an SFT from a directory entry
 24489                                  ;
 24490                                  ;	BUILDDIR
 24491                                  ;	SETDOTENT
 24492                                  ;	MakeNode
 24493                                  ;	NEWENTRY
 24494                                  ;	FREEENT
 24495                                  ;	NEWDIR
 24496                                  ;	DOOPEN
 24497                                  ;	RENAME_MAKE
 24498                                  ;	CHECK_VIRT_OPEN
 24499                                  ;
 24500                                  ;	Revision history:
 24501                                  ;
 24502                                  ;	 AN000	version 4.0  Jan. 1988
 24503                                  ;	 A004	PTM 3680  --- Make SFT NAME field offset same as 3.30
 24504                                  
 24505                                  ;Break   <BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES>
 24506                                  ;----------------------------------------------------------------------------
 24507                                  ;
 24508                                  ; Procedure Name : BUILDDIR,NEWDIR
 24509                                  ;
 24510                                  ; Inputs:
 24511                                  ;       ES:BP Points to DPB
 24512                                  ;       [THISSFT] Set if using NEWDIR entry point
 24513                                  ;               (used by ALLOCATE)
 24514                                  ;       [LASTENT] current last valid entry number in directory if no free
 24515                                  ;               entries
 24516                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 24517                                  ; Function:
 24518                                  ;       Grow directory if no free entries and not root
 24519                                  ; Outputs:
 24520                                  ;       CARRY SET IF FAILURE
 24521                                  ;       ELSE
 24522                                  ;          AX entry number of new entry
 24523                                  ;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
 24524                                  ;               AX = first entry of new dir
 24525                                  ;       GETENT should be called to set [LASTENT]
 24526                                  ;
 24527                                  ;----------------------------------------------------------------------------
 24528                                  
 24529                                  BUILDDIR:
 24530                                  	; 23/07/2019 - Retro DOS v3.2
 24531                                  	; 29/07/2018 - Retro DOS v3.0
 24532                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 4E66h
 24533                                  
 24534 000051E3 A1[9405]                        MOV     AX,[ENTFREE]
 24535 000051E6 83F8FF                          CMP     AX,-1
 24536 000051E9 7402                            JZ	short CHECK_IF_ROOT
 24537 000051EB F8                              CLC
 24538 000051EC C3                              retn
 24539                                  
 24540                                  CHECK_IF_ROOT:
 24541 000051ED 833E[7E05]00                    CMP     word [DIRSTART],0
 24542 000051F2 7502                            JNZ	short NEWDIR
 24543 000051F4 F9                              STC
 24544                                  builddir_retn:
 24545 000051F5 C3                              retn				; Can't grow root
 24546                                  
 24547                                  	;entry   NEWDIR
 24548                                  NEWDIR:        
 24549 000051F6 8B1E[7E05]              	MOV     BX,[DIRSTART]
 24550 000051FA 09DB                            OR      BX,BX
 24551 000051FC 7405                            JZ	short NULLDIR
 24552 000051FE E8F705                  	call	GETEOF
 24553 00005201 72F2                            jc	short builddir_retn	; Screw up
 24554                                  NULLDIR:
 24555 00005203 B90100                          MOV     CX,1
 24556 00005206 E81705                  	call	ALLOCATE
 24557 00005209 72EA                            jc	short  builddir_retn
 24558 0000520B 8B16[7E05]                      MOV     DX,[DIRSTART]
 24559 0000520F 09D2                            OR      DX,DX
 24560 00005211 750D                            JNZ	short ADDINGDIR
 24561 00005213 E8AEF7                  	call	SETDIRSRCH
 24562 00005216 72DD                            jc	short  builddir_retn
 24563 00005218 C706[1203]FFFF                  MOV     word [LASTENT],-1
 24564 0000521E EB2B                            JMP     SHORT GOTDIRREC
 24565                                  ADDINGDIR:
 24566 00005220 53                              PUSH    BX
 24567 00005221 8B1E[7805]                      MOV     BX,[CLUSNUM]
 24568 00005225 E8F00A                          call	IsEOF
 24569 00005228 5B                              POP     BX
 24570 00005229 7219                            JB	short NOTFIRSTGROW
 24571                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 24572 0000522B 891E[7805]                      MOV     [CLUSNUM],BX
 24573 0000522F 51                              PUSH    CX
 24574 00005230 50                              PUSH    AX
 24575 00005231 55                              PUSH    BP
 24576 00005232 B401                            MOV     AH,1			; CLUSNUM update
 24577                                  	;mov	dl,[es:bp+0]
 24578 00005234 268A5600                	mov	dl,[ES:BP] ; 09/09/2018
 24579                                          ;MOV	DL,[ES:BP+DPB.DRIVE]	; drive #
 24580 00005238 8B0E[7E05]                      MOV     CX,[DIRSTART]		; first cluster #
 24581 0000523C 89DD                            MOV     BP,BX 			; CLUSNUM
 24582 0000523E E841E2                  	call	FastOpen_Update
 24583 00005241 5D                              POP     BP
 24584 00005242 58                              POP     AX
 24585 00005243 59                              POP     CX
 24586                                  
 24587                                  ;;;; 10/17/86 update CLUSNUM in the fastopen cache
 24588                                  NOTFIRSTGROW:
 24589 00005244 89DA                            MOV     DX,BX
 24590 00005246 30DB                            XOR     BL,BL
 24591 00005248 E8A904                  	call	FIGREC
 24592                                  GOTDIRREC:
 24593                                  	;mov	cl,[es:bp+4]
 24594 0000524B 268A4E04                        MOV     CL,[ES:BP+DPB.CLUSTER_MASK]
 24595 0000524F FEC1                            INC     CL
 24596 00005251 30ED                            XOR     CH,CH
 24597                                  ZERODIR:
 24598 00005253 51                              PUSH    CX
 24599                                  	;mov	byte [ALLOWED],18h
 24600 00005254 C606[1503]18                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 24601 00005259 B0FF                            MOV     AL,0FFH
 24602 0000525B E8420F                          call	GETBUFFR
 24603 0000525E 7302                            JNC	short GET_SSIZE
 24604 00005260 59                              POP     CX
 24605 00005261 C3                              retn
 24606                                  
 24607                                  GET_SSIZE:
 24608                                  	;mov	cx,[es:bp+2]
 24609 00005262 268B4E02                        MOV     CX,[ES:BP+DPB.SECTOR_SIZE]
 24610 00005266 06                              PUSH    ES
 24611 00005267 C43E[9E05]                      LES     DI,[CURBUF]
 24612                                  	;or	byte [es:di+5],4
 24613 0000526B 26804D0504                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDIR
 24614 00005270 57                              PUSH    DI
 24615                                  	;;add	di,16	; MSDOS 3.3
 24616                                  	;add	di,20	; MSDOS 6.0
 24617 00005271 83C714                          ADD     DI,BUFINSIZ
 24618 00005274 31C0                            XOR     AX,AX
 24619 00005276 D1E9                            SHR     CX,1
 24620 00005278 F3AB                            REP     STOSW
 24621 0000527A 7301                            JNC	short EVENZ
 24622 0000527C AA                              STOSB
 24623                                  EVENZ:
 24624 0000527D 5F                              POP     DI
 24625                                  
 24626                                  	; MSDOS 6.0
 24627                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 24628                                  	;				;LB. if already dirty		  ;AN000;
 24629                                          ;JNZ	short yesdirty7		;LB.  don't increment dirty count ;AN000;
 24630                                          ;call	INC_DIRTY_COUNT		;LB. 				  ;AN000;
 24631                                          
 24632                                  	;or	byte [es:di+5],40h
 24633 0000527E 26804D0540              	OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty
 24634                                  ;yesdirty7:
 24635 00005283 07                              POP	ES
 24636 00005284 59                              POP	CX
 24637                                  
 24638                                  	; 19/05/2019 - Retro DOS v4.0
 24639                                  	; 23/07/2019 - Retro DOS v3.2
 24640                                  
 24641                                  	; MSDOS 3.3
 24642                                  	;INC	DX
 24643                                  
 24644                                  	; MSDOS 6.0
 24645 00005285 83C201                  	add	dx,1
 24646 00005288 8316[B005]00            	adc	word [HIGH_SECTOR],0
 24647                                  
 24648 0000528D E2C4                    	LOOP    ZERODIR
 24649                                  
 24650 0000528F A1[1203]                        MOV     AX,[LASTENT]
 24651 00005292 40                              INC     AX
 24652 00005293 F8                              CLC
 24653 00005294 C3                              retn
 24654                                  
 24655                                  ;--------------------------------------------------------------------------
 24656                                  ;
 24657                                  ; Procedure Name : SETDOTENT
 24658                                  ;
 24659                                  ; set up a . or .. directory entry for a directory.
 24660                                  ;
 24661                                  ;   Inputs:     ES:DI point to the beginning of a directory entry.
 24662                                  ;               AX contains ". " or ".."
 24663                                  ;               DX contains first cluster of entry
 24664                                  ;
 24665                                  ;----------------------------------------------------------------------------
 24666                                  
 24667                                  SETDOTENT:
 24668                                  ;	Fill in name field
 24669 00005295 AB                              STOSW
 24670 00005296 B90400                          MOV     CX,4
 24671 00005299 B82020                          MOV     AX,"  " ; 2020h
 24672 0000529C F3AB                            REP     STOSW
 24673 0000529E AA                              STOSB
 24674                                  
 24675                                  ;	Set up attribute
 24676                                  	;mov	al, 10h
 24677 0000529F B010                            MOV     AL,attr_directory
 24678 000052A1 AA                              STOSB
 24679                                  
 24680                                  ;	Initialize time and date of creation
 24681 000052A2 83C70A                          ADD     DI,10
 24682 000052A5 8B36[5A05]                      MOV     SI,[THISSFT]
 24683                                  	;mov	ax,[si+0Dh]
 24684 000052A9 8B440D                          MOV     AX,[SI+SF_ENTRY.sf_time]
 24685 000052AC AB                              STOSW
 24686                                  	;mov	ax,[si+0Fh]
 24687 000052AD 8B440F                          MOV     AX,[SI+SF_ENTRY.sf_date]
 24688 000052B0 AB                      	STOSW
 24689                                  
 24690                                  ;	Set up first cluster field
 24691 000052B1 89D0                            MOV     AX,DX
 24692 000052B3 AB                              STOSW
 24693                                  
 24694                                  ;	0 file size
 24695 000052B4 31C0                            XOR     AX,AX
 24696 000052B6 AB                              STOSW
 24697 000052B7 AB                              STOSW
 24698 000052B8 C3                              retn
 24699                                  
 24700                                  ;Break   <MAKENODE -- CREATE A NEW NODE>
 24701                                  ;---------------------------------------------------------------------------
 24702                                  ;
 24703                                  ; Procedure Name : MakeNode
 24704                                  ;
 24705                                  ; Inputs:
 24706                                  ;       AL - attribute to create
 24707                                  ;       AH = 0 if it is ok to truncate a file already by this name
 24708                                  ;	AH != 0 if truncation not allowed (prexisting file is an error)
 24709                                  ;               (AH ignored on dirs and devices)
 24710                                  ;
 24711                                  ;        NOTE: When making a DIR or volume ID, AH need not be set since
 24712                                  ;               a name already existant is ALWAYS an error in these cases.
 24713                                  ;
 24714                                  ;       [WFP_START] Points to WFP string ("d:/" must be first 3 chars, NUL
 24715                                  ;               terminated)
 24716                                  ;       [CURR_DIR_END] Points to end of Current dir part of string
 24717                                  ;               ( = -1 if current dir not involved, else
 24718                                  ;                Points to first char after last "/" of current dir part)
 24719                                  ;       [THISCDS] Points to CDS being used
 24720                                  ;       [THISSFT] Points to an empty SFT. EXCEPT sf_mode filled in.
 24721                                  ; Function:
 24722                                  ;       Make a new node
 24723                                  ; Outputs:
 24724                                  ;       Sets EXTERR_LOCUS = errLOC_Disk or errLOC_Unk via GetPathNoset
 24725                                  ;       CARRY SET IF ERROR
 24726                                  ;          AX = 1 A node by this name exists and is a directory
 24727                                  ;          AX = 2 A new node could not be created
 24728                                  ;          AX = 3 A node by this name exists and is a disk file
 24729                                  ;               (AH was NZ on input)
 24730                                  ;          AX = 4 Bad Path
 24731                                  ;               SI return from GetPath maintained
 24732                                  ;          AX = 5 Attribute mismatch
 24733                                  ;          AX = 6 Sharing Violation
 24734                                  ;               (INT 24 generated ALWAYS since create is always compat mode
 24735                                  ;          AX = 7 file not found for Extended Open (not exists and fails)
 24736                                  ;       ELSE
 24737                                  ;          AX = 0       Disk Node
 24738                                  ;          AX = 3       Device Node (error in some cases)
 24739                                  ;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
 24740                                  ;               containing new node.
 24741                                  ;          [CURBUF+2]:BX Points to entry
 24742                                  ;          [CURBUF+2]:SI Points to entry.dir_first
 24743                                  ;          [THISSFT] is filled in
 24744                                  ;               sf_mode = unchanged.
 24745                                  ;          Attribute byte in entry is input AL
 24746                                  ; DS preserved, others destroyed
 24747                                  ;
 24748                                  ;-------------------------------------------------------------------------
 24749                                  
 24750                                  MakeNode:
 24751                                  	;mov	word [CREATING],0E5FFh
 24752 000052B9 C706[3A05]FFE5          	MOV	WORD [CREATING],DIRFREE*256 + 0FFh ; Creating, not DEL *.*
 24753 000052BF 50                              PUSH    AX              ; Save AH value
 24754 000052C0 C606[1603]00            	MOV	byte [NoSetDir],0
 24755 000052C5 A2[2A05]                	MOV	[SATTRIB],AL
 24756 000052C8 E860F7                  	call	GetPathNoSet
 24757 000052CB 88CA                            MOV     DL,CL           ; Save CL info
 24758 000052CD 89C1                            MOV     CX,AX           ; Device ID to CH
 24759 000052CF 58                              POP     AX              ; Get back AH
 24760 000052D0 7316                            JNC	short make_exists ; File existed
 24761 000052D2 7505                            JNZ	short make_err_4 ; Path bad
 24762 000052D4 80FA80                          CMP     DL,80h          ; Check "CL" return from GETPATH
 24763 000052D7 7406                            JZ	short make_type	; Name simply not found, and no metas
 24764                                  make_err_4:
 24765 000052D9 B004                            MOV     AL,4            ; case 1 bad path
 24766                                  make_err_ret:
 24767 000052DB 30E4                            XOR     AH,AH
 24768 000052DD F9                              STC
 24769                                  make_retn:
 24770 000052DE C3                              retn
 24771                                  
 24772                                          ;entry	RENAME_MAKE     ; Used by DOS_RENAME to "copy" a node
 24773                                  RENAME_MAKE:
 24774                                  make_type:
 24775                                  ;Extended Open hooks
 24776                                  	; MSDOS 6.0
 24777                                  	;TESTB	EXTOPEN_ON,ext_open_on	;FT. from extended open		;AN000;
 24778                                  	;JZ	make_type2		;FT. no				;AN000;
 24779                                  	;OR	EXTOPEN_ON,ext_file_not_exists ;FT. set for extended open ;AN000;
 24780                                  	;TESTB	EXTOPEN_FLAG,0F0H	;FT. not exists and fails	;AN000;
 24781                                  	;JNZ    make_type2		;FT. no				;AN000;
 24782                                  	;STC				;FT. set carry			;AN000;
 24783                                  	;MOV    AX,7			;FT. file not found		;AN000;
 24784                                  	;return				;FT.				;AN000;
 24785                                  ;	Extended Open hooks
 24786                                  
 24787                                  make_type2:
 24788 000052DF C43E[5A05]                      LES     DI,[THISSFT]
 24789 000052E3 31C0                            XOR     AX,AX           ; nothing exists Disk Node
 24790 000052E5 F9                              STC                     ; Not found
 24791 000052E6 EB5A                            JMP     short make_new
 24792                                  
 24793                                  ; The node exists. It may be either a device, directory or file:
 24794                                  ;   Zero set => directory
 24795                                  ;   High bit of CH on => device
 24796                                  ;   else => file
 24797                                  
 24798                                  make_exists:
 24799 000052E8 7448                            JZ	short make_exists_dir
 24800 000052EA B003                            MOV     AL,3            ; file exists type 3  (error or device node)
 24801                                  	;test	byte [ATTRIB],18h
 24802 000052EC F606[2805]18            	TEST	byte [ATTRIB],attr_volume_id+attr_directory
 24803 000052F1 753B                            JNZ	short make_err_ret_5
 24804                                  				; Cannot already exist as Disk or Device Node
 24805                                                                  ;       if making DIR or Volume ID
 24806 000052F3 08ED                            OR      CH,CH
 24807 000052F5 781A                            JS	short make_share ; No further checks on attributes if device
 24808 000052F7 08E4                            OR      AH,AH
 24809 000052F9 75E0                            JNZ	short make_err_ret ; truncating NOT OK (AL = 3)
 24810 000052FB 51                              PUSH    CX              ; Save device ID
 24811 000052FC 8E06[A005]                      MOV     ES,[CURBUF+2]
 24812                                  	;mov	ch,[es:bx+0Bh]
 24813 00005300 268A6F0B                        MOV     CH,[ES:BX+dir_entry.dir_attr] ; Get file attributes
 24814                                  	;test	ch,1
 24815 00005304 F6C501                  	test	CH,attr_read_only
 24816 00005307 7524                            JNZ	short make_err_ret_5P ; Cannot create on read only files
 24817 00005309 E8BEF9                  	call	MatchAttributes
 24818 0000530C 59                              POP     CX              ; Devid back in CH
 24819 0000530D 751F                            JNZ	short make_err_ret_5 ; Attributes not ok
 24820 0000530F 30C0                            XOR     AL,AL           ; AL = 0, Disk Node
 24821                                  make_share:
 24822 00005311 30E4                            XOR     AH,AH
 24823 00005313 50                              PUSH    AX              ; Save Disk or Device node
 24824 00005314 51                              PUSH    CX              ; Save Device ID
 24825 00005315 88EC                            MOV     AH,CH           ; Device ID to AH
 24826 00005317 E83301                          CALL    DOOPEN          ; Fill in SFT for share check
 24827 0000531A C43E[5A05]                      LES     DI,[THISSFT]
 24828 0000531E 56                      	push	si
 24829 0000531F 53                      	push	bx		; Save CURBUF pointers
 24830 00005320 E87A23                  	call	ShareEnter
 24831 00005323 7350                            jnc	short MakeEndShare
 24832                                  
 24833                                  ; User failed request.
 24834 00005325 5B                      	pop	bx
 24835 00005326 5E                      	pop	si
 24836 00005327 59                      	pop	cx
 24837 00005328 58                      	pop	ax
 24838                                  
 24839                                  Make_Share_ret:
 24840 00005329 B006                            MOV     AL,6
 24841 0000532B EBAE                            JMP	short make_err_ret
 24842                                  
 24843                                  make_err_ret_5P:
 24844 0000532D 59                              POP     CX              ; Get back device ID
 24845                                  make_err_ret_5:
 24846 0000532E B005                            MOV     AL,5            ; Attribute mismatch
 24847 00005330 EBA9                            JMP     make_err_ret
 24848                                  
 24849                                  make_exists_dir:
 24850 00005332 B001                            MOV     AL,1            ; exists as directory, always an error
 24851 00005334 EBA5                            JMP     make_err_ret
 24852                                  
 24853                                  make_save:
 24854 00005336 50                              PUSH    AX              ; Save whether Disk or File
 24855 00005337 89C8                            MOV     AX,CX           ; Device ID to AH
 24856 00005339 E86A00                          CALL    NEWENTRY
 24857 0000533C 58                              POP     AX              ; 0 if Disk, 3 if File
 24858 0000533D 739F                            jnc	short make_retn
 24859 0000533F B002                            MOV     AL,2            ; create failed case 2
 24860                                  make_save_retn:
 24861 00005341 C3                              retn
 24862                                  
 24863                                  make_new:
 24864 00005342 E8F1FF                          call    make_save
 24865 00005345 72FA                            jc	short make_save_retn	; case 2 fail
 24866 00005347 F606[2805]10            	test	BYTE [ATTRIB],attr_directory
 24867 0000534C 75F3                            jnz	short make_save_retn	; Don't "open" directories, so don't
 24868                                                                  ;   tell the sharer about them
 24869 0000534E 50                      	push	ax
 24870 0000534F 53                      	push	bx
 24871 00005350 56                      	push	si		
 24872 00005351 E84923                          call	ShareEnter
 24873 00005354 5E                      	pop	si
 24874 00005355 5B                      	pop	bx
 24875 00005356 58                      	pop	ax
 24876 00005357 73E8                    	jnc	short make_save_retn
 24877                                  ;
 24878                                  ; We get here by having the user FAIL a share problem. Typically a failure of
 24879                                  ; this nature is an out-of-space or an internal error. We clean up as best as
 24880                                  ; possible: delete the newly created directory entry and return share_error.
 24881                                  ;
 24882 00005359 50                              PUSH    AX
 24883 0000535A C43E[9E05]                      LES     DI,[CURBUF]
 24884                                  	;mov	byte [es:bx],0E5h
 24885 0000535E 26C607E5                	MOV	BYTE [ES:BX],DIRFREE	; nuke newly created entry.
 24886                                  	
 24887                                  	; MSDOS 6.0
 24888                                  	;TEST	byte [ES:DI+BUFFINFO.buf_flags],buf_dirty  
 24889                                  	;				;LB. if already dirty		  ;AN000;
 24890                                          ;JNZ	short yesdirty3		;LB.  don't increment dirty count ;AN000;
 24891                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 24892                                  	;or	byte [es:di+5],40h
 24893 00005362 26804D0540                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_dirty ; flag buffer as dirty
 24894                                  ;yesdirty3:
 24895 00005367 C42E[4605]                      LES     BP,[THISDPB]
 24896 0000536B 268A4600                        mov	al,[ES:BP]
 24897                                  	;MOV	AL,[ES:BP+DPB.DRIVE]	; get drive for flush
 24898 0000536F E8FC0E                          call	FLUSHBUF		; write out buffer.
 24899 00005372 58                              POP     AX
 24900 00005373 EBB4                            jmp	short Make_Share_ret
 24901                                  ;
 24902                                  ; We have found an existing file. We have also entered it into the share set.
 24903                                  ; At this point we need to call newentry to correctly address the problem of
 24904                                  ; getting rid of old data (create an existing file) or creating a new
 24905                                  ; directory entry (create a new file). Unfortunately, this operation may
 24906                                  ; result in an INT 24 that the user doesn't return from, thus locking the file
 24907                                  ; irretrievably into the share set. The correct solution is for us to LEAVE
 24908                                  ; the share set now, do the operation and then reassert the share access.
 24909                                  ;
 24910                                  ; We are allowed to do this! There is no window! After all, we are in
 24911                                  ; critDisk here and for someone else to get in, they must enter critDisk also.
 24912                                  ;
 24913                                  MakeEndShare:
 24914 00005375 C43E[5A05]                      LES     DI,[THISSFT]		; grab SFT
 24915 00005379 31C0                            XOR     AX,AX
 24916 0000537B E88FCD                  	call	EcritSFT
 24917 0000537E 268705                  	xchg	AX,[ES:DI]
 24918                                  	;XCHG	AX,[ES:DI+SF_ENTRY.sf_ref_count]
 24919 00005381 50                      	push	ax
 24920 00005382 57                      	push	di
 24921 00005383 06                      	push	es
 24922 00005384 9C                              PUSHF
 24923 00005385 E81023                          call	ShareEnd                ; remove sharing
 24924 00005388 9D                              POPF
 24925 00005389 07                      	pop	es
 24926 0000538A 5F                      	pop	di
 24927 0000538B 268F05                          pop	word [ES:DI]	
 24928                                  	;pop	word [ES:DI+SF_ENTRY.sf_ref_count]
 24929 0000538E E884CD                  	call	LcritSFT
 24930 00005391 5B                      	pop	bx
 24931 00005392 5E                      	pop	si
 24932 00005393 59                      	pop	cx
 24933 00005394 58                      	pop	ax
 24934 00005395 E89EFF                          CALL    make_save
 24935                                  
 24936                                  ; If the user failed, we do not reenter into the sharing set.
 24937                                  
 24938 00005398 72A7                            jc	short make_save_retn	; bye if error
 24939 0000539A 50                      	push	ax
 24940 0000539B 53                      	push	bx
 24941 0000539C 56                      	push	si
 24942 0000539D 9C                              PUSHF
 24943 0000539E E8FC22                          call	ShareEnter
 24944 000053A1 9D                              POPF
 24945 000053A2 5E                      	pop	si
 24946 000053A3 5B                      	pop	bx
 24947 000053A4 58                      	pop	ax
 24948                                  
 24949                                  ; If Share_check fails, then we have an internal ERROR!!!!!
 24950                                  
 24951                                  makeendshare_retn:
 24952 000053A5 C3                              retn
 24953                                  
 24954                                  ;---------------------------------------------------------------------------
 24955                                  ;
 24956                                  ; Procedure Name : NEWENTRY
 24957                                  ;
 24958                                  ; Inputs:
 24959                                  ;       [THISSFT] set
 24960                                  ;       [THISDPB] set
 24961                                  ;       [LASTENT] current last valid entry number in directory if no free
 24962                                  ;               entries
 24963                                  ;       [VOLID] set if a volume ID was found during search
 24964                                  ;	Attrib Contains attributes for new file
 24965                                  ;       [DIRSTART] Points to first cluster of dir (0 means root)
 24966                                  ;       CARRY FLAG INDICATES STATUS OF SEARCH FOR FILE
 24967                                  ;               NC means file existed (device)
 24968                                  ;               C  means file did not exist
 24969                                  ;       AH = Device ID byte
 24970                                  ;       If FILE
 24971                                  ;           [CURBUF+2]:BX points to start of directory entry
 24972                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 24973                                  ;       If device
 24974                                  ;           DS:BX points to start of "fake" directory entry
 24975                                  ;           DS:SI points to dir_first of "fake" directory entry
 24976                                  ;               (has DWORD pointer to device header)
 24977                                  ; Function:
 24978                                  ;       Make a new directory entry
 24979                                  ;       If an old one existed it is truncated first
 24980                                  ; Outputs:
 24981                                  ;       Carry set if error
 24982                                  ;               Can't grow dir, atts didn't match, attempt to make 2nd
 24983                                  ;               vol ID, user FAILed to I 24
 24984                                  ;       else
 24985                                  ;               outputs of DOOPEN
 24986                                  ; DS, BX, SI preserved (meaning on SI BX, not value), others destroyed
 24987                                  ;
 24988                                  ;----------------------------------------------------------------------------
 24989                                  
 24990                                  NEWENTRY:
 24991 000053A6 C42E[4605]                      LES     BP,[THISDPB]
 24992 000053AA 7316                            JNC	short EXISTENT	
 24993 000053AC 803E[1403]00                    CMP     byte [FAILERR],0
 24994 000053B1 F9                              STC
 24995 000053B2 75F1                            jnz	short makeendshare_retn	; User FAILed, node might exist
 24996 000053B4 E82CFE                          CALL    BUILDDIR        ; Try to build dir
 24997 000053B7 72EC                            jc	short makeendshare_retn	; Failed
 24998 000053B9 E8DAF5                          call	GETENT          ; Point at that free entry
 24999 000053BC 72E7                            jc	short makeendshare_retn	; Failed
 25000 000053BE EB0E                            JMP     SHORT FREESPOT
 25001                                  
 25002                                  ERRRET3:
 25003 000053C0 F9                              STC
 25004                                  newentry_retn:
 25005 000053C1 C3                              retn
 25006                                  
 25007                                  EXISTENT:
 25008 000053C2 08E4                            OR      AH,AH           ; Check if file is I/O device
 25009 000053C4 7903                            JNS	short NOT_DEV1
 25010 000053C6 E98400                          JMP     DOOPEN          ; If so, proceed with open
 25011                                  
 25012                                  NOT_DEV1:
 25013 000053C9 E82301                          call	FREEENT		; Free cluster chain
 25014 000053CC 72F3                            jc	short newentry_retn ; Failed
 25015                                  FREESPOT:
 25016                                  	;test	byte [ATTRIB],8
 25017 000053CE F606[2805]08            	test	BYTE [ATTRIB],attr_volume_id
 25018 000053D3 7407                            JZ	short NOTVOLID
 25019 000053D5 803E[3805]00                    CMP     BYTE [VOLID],0
 25020 000053DA 75E4                            JNZ	short ERRRET3	; Can't create a second volume ID
 25021                                  NOTVOLID:
 25022 000053DC 8E06[A005]                      MOV     ES,[CURBUF+2]
 25023 000053E0 89DF                            MOV     DI,BX
 25024                                  
 25025 000053E2 BE[0805]                        MOV     SI,NAME1
 25026                                  
 25027 000053E5 B90500                          MOV     CX,5
 25028 000053E8 F3A5                            REP     MOVSW
 25029 000053EA A4                              MOVSB                   ; Move name into dir entry
 25030 000053EB A0[2805]                	MOV	AL,[ATTRIB]
 25031 000053EE AA                      	STOSB                   ; Attributes
 25032                                  
 25033                                  ;; File Tagging for Create DOS 4.00
 25034 000053EF B105                            MOV     CL,5            ;FT. assume normal FBUGBUG	;AN000;
 25035                                  ;; File Tagging for Create DOS 4.00
 25036                                  
 25037 000053F1 31C0                            XOR     AX,AX
 25038 000053F3 F3AB                            REP     STOSW           ; Zero pad
 25039 000053F5 E85CC5                          call	DATE16
 25040 000053F8 92                              XCHG    AX,DX
 25041 000053F9 AB                              STOSW                   ; dir_time
 25042 000053FA 92                              XCHG    AX,DX
 25043 000053FB AB                              STOSW                   ; dir_date
 25044 000053FC 31C0                            XOR     AX,AX
 25045 000053FE 57                              PUSH    DI              ; Correct SI input value
 25046                                  				; 	(recomputed for new buffer)
 25047 000053FF AB                              STOSW                   ; Zero dir_first and size
 25048 00005400 AB                              STOSW
 25049 00005401 AB                              STOSW
 25050                                  updnxt:
 25051 00005402 8B36[9E05]              	MOV	SI,[CURBUF]
 25052                                  
 25053                                  	; MSDOS 6.0
 25054                                  	;TEST	byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 25055                                  	;			;LB. if already dirty		  ;AN000;
 25056                                          ;JNZ	short yesdirty9	;LB.  don't increment dirty count ;AN000;
 25057                                          ;call	INC_DIRTY_COUNT	;LB.				  ;AN000;
 25058                                          
 25059                                  	;or	byte [es:si+5],40h
 25060 00005406 26804C0540              	OR      byte [ES:SI+BUFFINFO.buf_flags],buf_dirty
 25061                                  ;yesdirty9:
 25062 0000540B C42E[4605]                      LES     BP,[THISDPB]
 25063 0000540F 268A4600                	MOV	AL,[ES:BP]	; mov al,[es:bp+0] 
 25064                                          ;MOV	AL,[ES:BP+DPB.DRIVE] ; Sets AH value again (in AL)
 25065 00005413 50                              PUSH    AX
 25066 00005414 53                              PUSH    BX
 25067                                  
 25068                                  ; If we have a file, we need to increment the open ref. count so that
 25069                                  ; we have some protection against invalid media changes if an Int 24
 25070                                  ; error occurs.
 25071                                  ; Do nothing for a device.
 25072                                  
 25073 00005415 06                      	push	es
 25074 00005416 57                      	push	di
 25075 00005417 C43E[5A05]                      LES     DI,[THISSFT]
 25076                                  	;test	word [es:di+5],80h
 25077 0000541B 26F745058000            	TEST	word [ES:DI+SF_ENTRY.sf_flags],devid_device
 25078 00005421 751A                            jnz	short GotADevice
 25079 00005423 1E                      	push	ds
 25080 00005424 53                      	push	bx
 25081 00005425 C51E[4605]                      LDS     BX,[THISDPB]
 25082                                  	;mov	[es:di+7],bx
 25083 00005429 26895D07                        MOV     [ES:DI+SF_ENTRY.sf_devptr],BX
 25084 0000542D 8CDB                            MOV     BX,DS
 25085                                  	;mov	[es:di+9],bx
 25086 0000542F 26895D09                        MOV     [ES:DI+SF_ENTRY.sf_devptr+2],BX
 25087 00005433 5B                      	pop	bx
 25088 00005434 1F                      	pop	ds ; need to use DS for segment later on
 25089 00005435 E875FC                  	call	DEV_OPEN_SFT    ; increment ref. count
 25090 00005438 C606[380A]01                    mov	byte [VIRTUAL_OPEN],1; set flag
 25091                                  GotADevice:
 25092 0000543D 5F                      	pop	di
 25093 0000543E 07                      	pop	es
 25094                                  
 25095 0000543F E82C0E                          call	FLUSHBUF
 25096 00005442 E8F900                          Call    CHECK_VIRT_OPEN ; decrement ref. count                          ;AN000;
 25097 00005445 5B                              POP     BX
 25098 00005446 58                              POP     AX
 25099 00005447 5E                              POP     SI              ; Get SI input back
 25100 00005448 88C4                            MOV     AH,AL           ; Get I/O driver number back
 25101 0000544A 7301                            jnc	short DOOPEN    ; Failed
 25102 0000544C C3                      	retn
 25103                                  
 25104                                  ;NOTE FALL THROUGH
 25105                                  
 25106                                  	; 24/07/2019 - Retro DOS v3.2
 25107                                  ; DOOPEN
 25108                                  ;----------------------------------------------------------------------------
 25109                                  ;
 25110                                  ; Inputs:
 25111                                  ;       [THISDPB] points to DPB if file
 25112                                  ;       [THISSFT] points to SFT being used
 25113                                  ;       AH = Device ID byte
 25114                                  ;       If FILE
 25115                                  ;           [CURBUF+2]:BX points to start of directory entry
 25116                                  ;           [CURBUF+2]:SI points to dir_first of directory entry
 25117                                  ;       If device
 25118                                  ;           DS:BX points to start of "fake" directory entry
 25119                                  ;           DS:SI points to dir_first of "fake" directory entry
 25120                                  ;               (has DWORD pointer to device header)
 25121                                  ; Function:
 25122                                  ;       Fill in SFT from dir entry
 25123                                  ; Outputs:
 25124                                  ;       CARRY CLEAR
 25125                                  ;       sf_ref_count and sf_mode fields not altered
 25126                                  ;       sf_flags high byte = 0
 25127                                  ;       sf_flags low byte = AH except
 25128                                  ;       sf_flags Bit 6 set (not dirty or not EOF)
 25129                                  ;       sf_attr sf_date sf_time sf_name set from entry
 25130                                  ;       sf_position = 0
 25131                                  ;       If device
 25132                                  ;           sf_devptr = dword at dir_first (pointer to device header)
 25133                                  ;           sf_size = 0
 25134                                  ;       If file
 25135                                  ;           sf_firclus sf_size set from entry
 25136                                  ;           sf_devptr = [THISDPB]
 25137                                  ;           sf_cluspos = 0
 25138                                  ;           sf_lstclus = sf_firclus
 25139                                  ;           sf_dirsec sf_dirpos set
 25140                                  ; DS,SI,BX preserved, others destroyed
 25141                                  ;
 25142                                  ;----------------------------------------------------------------------------
 25143                                  
 25144                                  	;entry	DOOPEN
 25145                                  DOOPEN:
 25146                                  ;	Generate and store attribute
 25147                                  
 25148 0000544D 88E6                            MOV     DH,AH           ; AH to different place
 25149 0000544F C43E[5A05]                      LES     DI,[THISSFT]
 25150                                  	;add	di,4
 25151 00005453 83C704                          ADD     DI,SF_ENTRY.sf_attr ; Skip ref_count and mode fields
 25152 00005456 30C0                            XOR     AL,AL           ; Assume it's a device, devices have an
 25153                                                                  ;   attribute of 0 (for R/O testing etc).
 25154 00005458 08F6                            OR      DH,DH           ; See if our assumption good.
 25155 0000545A 7807                            JS	short DEV_SFT1	; If device DS=DOSGROUP
 25156 0000545C 8E1E[A005]                      MOV     DS,[CURBUF+2]
 25157                                  	;mov	al,[BX+0Bh]
 25158 00005460 8A470B                          MOV     AL,[BX+dir_entry.dir_attr]
 25159                                  				; If file, get attrib from dir entry
 25160                                  DEV_SFT1:
 25161 00005463 AA                              STOSB                   ; sf_attr, ES:DI -> sf_flags
 25162                                  
 25163                                  ;	Generate and store flags word
 25164                                  
 25165 00005464 31C0                            XOR     AX,AX
 25166 00005466 88F0                            MOV     AL,DH
 25167                                  	;or	al,40h
 25168 00005468 0C40                            OR      AL,devid_file_clean
 25169 0000546A AB                              STOSW                   ; sf_flags, ES:DI -> sf_devptr
 25170                                  
 25171                                  ;	Generate and store device pointer
 25172                                  
 25173 0000546B 1E                              PUSH    DS
 25174                                  	;lds	ax,[bx+1Ah]
 25175 0000546C C5471A                          LDS     AX,[BX+dir_entry.dir_first] ; Assume device
 25176 0000546F 08F6                            OR      DH,DH
 25177 00005471 7805                            JS	short DEV_SFT2
 25178                                  
 25179                                  ;hkn; SS override
 25180 00005473 36C506[4605]                    LDS     AX,[SS:THISDPB]	; Was file
 25181                                  DEV_SFT2:
 25182 00005478 AB                              STOSW 			; store offset
 25183 00005479 8CD8                            MOV     AX,DS
 25184 0000547B 1F                              POP     DS
 25185 0000547C AB                      	STOSW			; store segment
 25186                                  				; ES:DI -> sf_firclus
 25187                                  
 25188                                  ;	Generate pointer to, generate and store first cluster 
 25189                                  ;	(irrelevant for devices)
 25190                                  
 25191 0000547D 56                              PUSH    SI              ; Save pointer to dir_first
 25192                                  
 25193 0000547E A5                              MOVSW                   ; dir_first -> sf_firclus
 25194                                                                  ; DS:SI -> dir_size_l, ES:DI -> sf_time
 25195                                  
 25196                                  ;	Copy time/date of last modification
 25197                                  
 25198                                  	;sub	si,6
 25199 0000547F 83EE06                          SUB     SI,dir_entry.dir_size_l - dir_entry.dir_time 
 25200                                  				; DS:SI->dir_time
 25201 00005482 A5                              MOVSW                   ; dir_time -> sf_time
 25202                                                                  ; DS:SI -> dir_date, ES:DI -> sf_date
 25203 00005483 A5                              MOVSW                   ; dir_date -> sf_date
 25204                                                                  ; DS:SI -> dir_first, ES:DI -> sf_size
 25205                                  
 25206                                  ;	Generate and store file size (0 for devices)
 25207                                  
 25208 00005484 AD                              LODSW                   ; skip dir_first, DS:SI -> dir_size_l
 25209 00005485 AD                              LODSW                   ; dir_size_l in AX , DS:SI -> dir_size_h
 25210 00005486 89C1                            MOV     CX,AX           ; dir_size_l in CX
 25211 00005488 AD                              LODSW                   ; dir_size_h (size AX:CX), DS:SI -> ????
 25212 00005489 08F6                            OR      DH,DH
 25213 0000548B 7904                            JNS	short FILE_SFT1
 25214 0000548D 31C0                            XOR     AX,AX
 25215 0000548F 89C1                            MOV     CX,AX           ; Devices are open ended
 25216                                  FILE_SFT1:
 25217 00005491 91                              XCHG    AX,CX
 25218 00005492 AB                              STOSW                   ; Low word of sf_size
 25219 00005493 91                              XCHG    AX,CX
 25220 00005494 AB                              STOSW                   ; High word of sf_size
 25221                                                                  ; ES:DI -> sf_position
 25222                                  ; Initialize position to 0
 25223                                  
 25224 00005495 31C0                            XOR     AX,AX
 25225 00005497 AB                              STOSW
 25226 00005498 AB                              STOSW                   ; sf_position
 25227                                                                  ; ES:DI -> sf_cluspos
 25228                                  
 25229                                  ; Generate cluster optimizations for files
 25230                                  
 25231 00005499 08F6                            OR      DH,DH
 25232 0000549B 7843                            JS	short DEV_SFT3
 25233 0000549D AB                              STOSW                   ; sf_cluspos ; 1Ah
 25234                                  	;mov	ax,[bx+1Ah]
 25235 0000549E 8B471A                          MOV     AX,[BX+dir_entry.dir_first]
 25236                                  
 25237                                  	; 24/07/2019 - Retro DOS v3.2
 25238                                  
 25239                                  	; 19/05/2019
 25240                                  	; MSDOS 3.3
 25241                                  	;STOSW 			; sf_lstclus ; 1Bh
 25242                                  	; MSDOS 6.0
 25243 000054A1 57                              PUSH	DI              ;AN004; save dirsec offset
 25244                                  	;sub	di,1Bh
 25245 000054A2 83EF1B                          SUB	DI,SF_ENTRY.sf_dirsec	;AN004; es:di -> SFT
 25246                                  	;mov	[es:di+35h],ax
 25247 000054A5 26894535                        MOV	[ES:DI+SF_ENTRY.sf_lstclus],AX	;AN004; save it
 25248 000054A9 5F                              POP	DI              ;AN004; restore dirsec offset
 25249                                  
 25250                                  ; DOS 3.3  FastOpen  6/13/86
 25251                                  
 25252 000054AA 1E                      	PUSH	DS
 25253                                  
 25254                                  ;hkn; SS is DOSDATA
 25255 000054AB 16                      	push	ss
 25256 000054AC 1F                      	pop	ds
 25257                                  	;test	byte [FastOpenFlg],4
 25258 000054AD F606[A40F]04            	TEST	byte [FastOpenFlg],Special_Fill_Set
 25259 000054B2 7411                    	JZ	short Not_FastOpen
 25260                                  
 25261                                  ;hkn; FastOpen_Ext_Info is in DOSDATA
 25262 000054B4 BE[790F]                        MOV     SI,FastOpen_Ext_Info
 25263                                  
 25264                                  	; 24/07/2019 - Retro DOS v3.2
 25265                                  
 25266                                  	;mov	ax,[si+1]
 25267 000054B7 8B4401                          MOV     AX,[SI+FEI.dirsec]
 25268 000054BA AB                              STOSW                   ; sf_dirsec
 25269                                  	; MSDOS 6.0
 25270                                  	;mov	ax,[si+3]
 25271 000054BB 8B4403                          MOV	AX,[SI+FEI.dirsec+2]
 25272                                  				;;; changed for >32mb
 25273 000054BE AB                              STOSW                   ; sf_dirsec
 25274                                  	; 19/08//2018
 25275 000054BF 8A04                    	mov	al,[SI]
 25276                                          ;MOV	AL,[SI+FEI.dirpos] ; mov al,[SI+0]
 25277 000054C1 AA                              STOSB                   ; sf_dirpos
 25278 000054C2 1F                              POP	DS
 25279 000054C3 EB19                            JMP     short Next_Name
 25280                                  
 25281                                  ; DOS 3.3  FastOpen  6/13/86
 25282                                  
 25283                                  Not_FastOpen:
 25284                                          ;POP     DS		; normal path
 25285                                  
 25286                                  ;hkn; SS override
 25287                                  	;MOV	SI,[SS:CURBUF]	; DS:SI->buffer header
 25288                                  	; 28/07/2019
 25289 000054C5 8B36[9E05]              	mov	si,[CURBUF]
 25290 000054C9 1F                      	pop	ds
 25291                                  
 25292                                  	;mov	ax,[si+6]
 25293 000054CA 8B4406                          MOV     AX,[SI+BUFFINFO.buf_sector]     ;F.C. >32mb ;AN000;
 25294 000054CD AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 25295                                  	
 25296                                  	; 22/07/2019 - Retro DOS v3.2
 25297                                          ; MSDOS 6.0
 25298                                  	;mov	ax,[si+8]
 25299 000054CE 8B4408                  	MOV	AX,[SI+BUFFINFO.buf_sector+2]	;F.C. >32mb ;AN000;
 25300 000054D1 AB                              STOSW                   ; sf_dirsec     ;F.C. >32mb ;AN000;
 25301                                          
 25302 000054D2 89D8                    	MOV     AX,BX
 25303                                  	;;add	si,16	; MSDOS 3.3	
 25304                                  	;add	si,20	; MSDOS 6.0
 25305 000054D4 83C614                          ADD     SI,BUFINSIZ     ; DS:SI-> start of data in buffer
 25306 000054D7 29F0                            SUB     AX,SI           ; AX = BX relative to start of sector
 25307                                          ;mov	cl,32
 25308 000054D9 B120                    	MOV     CL,dir_entry.size
 25309 000054DB F6F1                            DIV     CL
 25310 000054DD AA                              STOSB                   ; sf_dirpos
 25311                                  
 25312                                  Next_Name:
 25313 000054DE EB03                            JMP     SHORT FILE_SFT2
 25314                                  
 25315                                  DEV_SFT3:
 25316                                  	;add	di,7
 25317 000054E0 83C707                          ADD     DI,SF_ENTRY.sf_name-SF_ENTRY.sf_cluspos
 25318                                  FILE_SFT2:
 25319                                  ;
 25320                                  ; Copy in the object's name
 25321                                  ;
 25322 000054E3 89DE                            MOV     SI,BX           ; DS:SI points to dir_name
 25323 000054E5 B90B00                          MOV     CX,11
 25324 000054E8 F3A4                            REP     MOVSB           ; sf_name
 25325 000054EA 5E                              POP     SI              ; recover DS:SI -> dir_first
 25326                                  
 25327                                  ;hkn; SS is DOSDATA
 25328 000054EB 16                              push	ss
 25329 000054EC 1F                      	pop	ds
 25330 000054ED F8                              CLC
 25331 000054EE C3                              retn
 25332                                  
 25333                                  ;---------------------------------------------------------------------------
 25334                                  ;
 25335                                  ; Procedure Name : FREEENT
 25336                                  ;
 25337                                  ; Inputs:
 25338                                  ;       ES:BP -> DPB
 25339                                  ;       [CURBUF] Set
 25340                                  ;       [CURBUF+2]:BX points to directory entry
 25341                                  ;       [CURBUF+2]:SI points to above dir_first
 25342                                  ; Function:
 25343                                  ;       Free the cluster chain for the entry if present
 25344                                  ; Outputs:
 25345                                  ;       Carry set if error (currently user FAILed to I 24)
 25346                                  ;       (NOTE dir_firclus and dir_size_l/h are wrong)
 25347                                  ; DS BX SI ES BP preserved (BX,SI in meaning, not value) others destroyed
 25348                                  ;---------------------------------------------------------------------------
 25349                                  
 25350                                  FREEENT:
 25351 000054EF 1E                              PUSH    DS
 25352 000054F0 C53E[9E05]                      LDS     DI,[CURBUF]
 25353 000054F4 8B0C                            MOV     CX,[SI]         ; Get pointer to clusters
 25354                                  	; 22/07/2019 - Retro DOS v3.2
 25355                                  	; MSDOS 6.0
 25356 000054F6 8B5508                  	MOV	DX,[DI+BUFFINFO.buf_sector+2]  ;F.C. >32mb	;AN000;
 25357                                  ;hkn; SS override
 25358 000054F9 368916[B005]            	MOV	[SS:HIGH_SECTOR],DX		;F.C. >32mb	;AN000;
 25359 000054FE 8B5506                          MOV     DX,[DI+BUFFINFO.buf_sector]
 25360 00005501 1F                              POP     DS
 25361 00005502 83F902                  	CMP	CX,2
 25362 00005505 7235                            JB	short RET1	; Was 0 length file (or mucked Firclus if CX=1)
 25363                                  	;cmp	cx,[es:bp+0Dh]
 25364 00005507 263B4E0D                        CMP     CX,[ES:BP+DPB.MAX_CLUSTER]
 25365 0000550B 772F                            JA	short RET1	; Treat like zero length file (firclus mucked)
 25366 0000550D 29FB                            SUB     BX,DI
 25367 0000550F 53                              PUSH    BX              ; Save offset
 25368 00005510 FF36[B005]              	PUSH	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 25369 00005514 52                              PUSH    DX              ; Save sector number
 25370 00005515 89CB                            MOV     BX,CX
 25371 00005517 E8B202                          call	RELEASE         ; Free any data allocated
 25372 0000551A 5A                              POP     DX
 25373 0000551B 8F06[B005]                      POP	word [HIGH_SECTOR] ;F.C. >32mb	;AN000;
 25374 0000551F 7302                            JNC	short GET_BUF_BACK
 25375 00005521 5B                              POP     BX
 25376                                  freeent_retn:
 25377 00005522 C3                              retn			; Screw up
 25378                                  
 25379                                  GET_BUF_BACK:
 25380                                  	;mov	byte [ALLOWED],18h
 25381 00005523 C606[1503]18                    MOV     byte [ALLOWED],Allowed_RETRY+Allowed_FAIL
 25382 00005528 30C0                            XOR     AL,AL
 25383 0000552A E8730C                  	call	GETBUFFR        ; Get sector back
 25384 0000552D 5B                              POP     BX              ; Get offset back
 25385 0000552E 72F2                            jc	short freeent_retn
 25386 00005530 E8EEEC                  	call	SET_BUF_AS_DIR
 25387 00005533 031E[9E05]                      ADD     BX,[CURBUF]	; Correct it for new buffer
 25388 00005537 89DE                            MOV     SI,BX
 25389                                  	;add	si,1Ah
 25390 00005539 83C61A                          ADD     SI,dir_entry.dir_first	; Get corrected SI
 25391                                  RET1:
 25392 0000553C F8                              CLC
 25393 0000553D C3                              retn
 25394                                  
 25395                                  ;---------------------------------------------------------------------------
 25396                                  ;
 25397                                  ; Procedure Name : CHECK_VIRT_OPEN
 25398                                  ;
 25399                                  ; CHECK_VIRT_OPEN checks to see if we had performed a "virtual open" (by
 25400                                  ; examining the flag [VIRTUAL_OPEN] to see if it is 1). If we did, then
 25401                                  ; it calls Dev_Close_SFT to decrement the ref. count. It also resets the
 25402                                  ; flag [VIRTUAL_OPEN].
 25403                                  ; No registers affected (including flags).
 25404                                  ; On input, [THISSFT] points to current SFT.
 25405                                  ;
 25406                                  ;---------------------------------------------------------------------------
 25407                                  
 25408                                  CHECK_VIRT_OPEN:
 25409 0000553E 50                      	        PUSH    AX
 25410 0000553F 9F                              lahf                    ; preserve flags
 25411 00005540 803E[380A]00                    CMP     byte [VIRTUAL_OPEN],0
 25412 00005545 7410                            JZ	short ALL_CLOSED
 25413 00005547 C606[380A]00                    mov     byte [VIRTUAL_OPEN],0	; reset flag
 25414 0000554C 06                      	push	es
 25415 0000554D 57                      	push	di
 25416 0000554E C43E[5A05]                      LES     DI,[THISSFT]
 25417 00005552 E85FFB                          call	DEV_CLOSE_SFT
 25418 00005555 5F                      	pop	di
 25419 00005556 07                      	pop	es
 25420                                  
 25421                                  ALL_CLOSED:
 25422 00005557 9E                              sahf                    ; restore flags
 25423 00005558 58                              POP     AX
 25424 00005559 C3                              retn
 25425                                  
 25426                                  ;============================================================================
 25427                                  ; ROM.ASM, MSDOS 6.0, 1991
 25428                                  ;============================================================================
 25429                                  ; 29/07/2018 - Retro DOS v3.0
 25430                                  
 25431                                  ;	TITLE	ROM - Miscellaneous routines
 25432                                  ;	NAME	ROM
 25433                                  
 25434                                  ;**	Misc Low level routines for doing simple FCB computations, Cache
 25435                                  ;       reads and writes, I/O optimization, and FAT allocation/deallocation
 25436                                  ;
 25437                                  ;	SKPCLP
 25438                                  ;	FNDCLUS
 25439                                  ;	BUFSEC
 25440                                  ;	BUFRD
 25441                                  ;	BUFWRT
 25442                                  ;	NEXTSEC
 25443                                  ;	OPTIMIZE
 25444                                  ;	FIGREC
 25445                                  ;	ALLOCATE
 25446                                  ;	RESTFATBYT
 25447                                  ;	RELEASE
 25448                                  ;	RELBLKS
 25449                                  ;	GETEOF
 25450                                  ;
 25451                                  ;	Modification history:
 25452                                  ;
 25453                                  ;		Created: ARR 30 March 1983
 25454                                  ;               M039: DB 10/25/90 - Disk read/write optimization.
 25455                                  
 25456                                  ;Break   <FNDCLUS -- Skip over allocation units>
 25457                                  ;--------------------------------------------------------------------------
 25458                                  ;
 25459                                  ; Procedure Name : FNDCLUS
 25460                                  ;
 25461                                  ; Inputs:
 25462                                  ;       CX = No. of clusters to skip
 25463                                  ;       ES:BP = Base of drive parameters
 25464                                  ;       [THISSFT] point to SFT
 25465                                  ; Outputs:
 25466                                  ;       BX = Last cluster skipped to
 25467                                  ;       CX = No. of clusters remaining (0 unless EOF)
 25468                                  ;       DX = Position of last cluster
 25469                                  ;       Carry set if error (currently user FAILed to I 24)
 25470                                  ; DI destroyed. No other registers affected.
 25471                                  ;--------------------------------------------------------------------------
 25472                                  
 25473                                  	; 26/07/2019 - Retro DOS v3.2
 25474                                  	; 20/05/2019 - Retro DOS v4.0
 25475                                  FNDCLUS:
 25476 0000555A 06                      	PUSH	ES
 25477 0000555B C43E[5A05]                      LES     DI,[THISSFT]		; setup addressability to SFT
 25478                                  	;;mov	bx,[es:di+1Bh] ; MSDOS 3.3
 25479                                  	;mov	bx,[es:di+35h] ; MSDOS 6.0
 25480 0000555F 268B5D35                	MOV	BX,[ES:DI+SF_ENTRY.sf_lstclus]
 25481                                  	;mov	dx,[es:di+19h]
 25482 00005563 268B5519                        MOV     DX,[ES:DI+SF_ENTRY.sf_cluspos]
 25483 00005567 09DB                    	OR	BX,BX
 25484 00005569 7424                    	JZ	short NOCLUS
 25485                                  
 25486 0000556B 29D1                            SUB     CX,DX
 25487 0000556D 7308                            JNB	short FINDIT
 25488                                  
 25489 0000556F 01D1                            ADD     CX,DX
 25490 00005571 31D2                            XOR     DX,DX
 25491                                  	;mov	bx,[es:di+0Bh]
 25492 00005573 268B5D0B                        MOV     BX,[ES:DI+SF_ENTRY.sf_firclus]
 25493                                  FINDIT:
 25494 00005577 07                              POP	ES
 25495 00005578 E313                    	JCXZ	RET9
 25496                                  
 25497                                  	;entry	SKPCLP
 25498                                  SKPCLP:
 25499 0000557A E8B207                  	call	UNPACK
 25500 0000557D 7214                            jc	short fndclus_retn	; retc
 25501                                  	
 25502                                  	; 09/09/2018
 25503                                  
 25504                                  	; MSDOS 3.3
 25505                                  	;push	bx
 25506                                  	;mov	bx,di
 25507                                  	;call	IsEOF
 25508                                  	;pop	bx	
 25509                                  	;jae	short RET9
 25510                                  
 25511                                  	; 20/05/2019 - Retro DOS v4.0
 25512                                  
 25513                                  	; MSDOS 6.0
 25514 0000557F 87DF                    	xchg	bx,di
 25515 00005581 E89407                  	call	IsEOF
 25516 00005584 87DF                    	xchg	bx,di
 25517 00005586 7305                    	jae	short RET9
 25518                                  
 25519 00005588 87DF                            XCHG    BX,DI
 25520 0000558A 42                              INC     DX
 25521 0000558B E2ED                    	LOOP	SKPCLP			; RMFS
 25522                                  RET9:	
 25523 0000558D F8                      	CLC
 25524 0000558E C3                              retn
 25525                                  NOCLUS:
 25526 0000558F 07                              POP	ES
 25527 00005590 41                              INC	CX
 25528 00005591 4A                              DEC	DX
 25529 00005592 F8                              CLC
 25530                                  
 25531                                  fndclus_retn:
 25532 00005593 C3                              retn
 25533                                  
 25534                                  ;Break  <BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER>
 25535                                  ;--------------------------------------------------------------------------
 25536                                  ;
 25537                                  ; Procedure Name : BUFSEC
 25538                                  ;
 25539                                  ; Inputs:
 25540                                  ;       AH = priority of buffer
 25541                                  ;       AL = 0 if buffer must be read, 1 if no pre-read needed
 25542                                  ;       ES:BP = Base of drive parameters
 25543                                  ;       [CLUSNUM] = Physical cluster number
 25544                                  ;       [SECCLUSPOS] = Sector position of transfer within cluster
 25545                                  ;       [BYTCNT1] = Size of transfer
 25546                                  ; Function:
 25547                                  ;       Insure specified sector is in buffer, flushing buffer before
 25548                                  ;       read if necessary.
 25549                                  ; Outputs:
 25550                                  ;       ES:DI = Pointer to buffer
 25551                                  ;       SI = Pointer to transfer address
 25552                                  ;       CX = Number of bytes
 25553                                  ;       [NEXTADD] updated
 25554                                  ;       [TRANS] set to indicate a transfer will occur
 25555                                  ;       Carry set if error (user FAILed to I 24)
 25556                                  ;--------------------------------------------------------------------------
 25557                                  
 25558                                  BUFSEC:
 25559 00005594 8B16[7805]                      MOV     DX,[CLUSNUM]
 25560 00005598 8A1E[3005]                      MOV     BL,[SECCLUSPOS]
 25561                                  	;mov	byte [ALLOWED],38h
 25562 0000559C C606[1503]38                    MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY+Allowed_IGNORE
 25563 000055A1 E85001                          CALL    FIGREC
 25564 000055A4 E8F90B                  	call	GETBUFFR
 25565 000055A7 72EA                            jc	short fndclus_retn
 25566                                  
 25567 000055A9 C606[3105]01                    MOV     BYTE [TRANS],1	; A transfer is taking place
 25568 000055AE 8B36[7405]                      MOV     SI,[NEXTADD]
 25569 000055B2 89F7                            MOV     DI,SI
 25570 000055B4 8B0E[8E05]                      MOV     CX,[BYTCNT1]
 25571 000055B8 01CF                            ADD     DI,CX
 25572 000055BA 893E[7405]                      MOV     [NEXTADD],DI
 25573 000055BE C43E[9E05]                      LES     DI,[CURBUF]
 25574                                  	;or	byte [es:di+5],8
 25575 000055C2 26804D0508                      OR      byte [ES:DI+BUFFINFO.buf_flags],buf_isDATA
 25576                                  	;lea	di,[di+16] ; MSDOS 3.3 
 25577                                  	;lea	di,[di+20] ; MSDOS 6.0 ; 26/07/2019
 25578 000055C7 8D7D14                          LEA     DI,[DI+BUFINSIZ]        ; Point to buffer
 25579 000055CA 033E[8805]                      ADD     DI,[BYTSECPOS]
 25580 000055CE F8                              CLC
 25581 000055CF C3                              retn
 25582                                  
 25583                                  ;Break   <BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE>
 25584                                  
 25585                                  ;---------------------------------------------------------------------------
 25586                                  ;
 25587                                  ; Procedure Name : BUFRD
 25588                                  ;
 25589                                  ; Do a partial sector read via one of the system buffers
 25590                                  ; ES:BP Points to DPB
 25591                                  ; Carry set if error (currently user FAILed to I 24)
 25592                                  ;
 25593                                  ; DS - set to DOSDATA
 25594                                  ;
 25595                                  ;----------------------------------------------------------------------------
 25596                                  
 25597                                  BUFRD:
 25598 000055D0 06                              PUSH	ES
 25599 000055D1 31C0                            xor	ax,ax			; pre-read sector
 25600 000055D3 E8BEFF                          CALL    BUFSEC
 25601 000055D6 7303                            JNC	short BUF_OK
 25602                                  
 25603                                  BUF_IO_FAIL:				; this label used by BUFWRT also
 25604 000055D8 07                              POP	ES
 25605 000055D9 EB29                            JMP     SHORT RBUFPLACED
 25606                                  
 25607                                  BUF_OK:
 25608 000055DB 8CC3                            MOV     BX,ES
 25609 000055DD 8E06[FA02]                      MOV     ES,[DMAADD+2]
 25610 000055E1 8EDB                            MOV     DS,BX
 25611 000055E3 87FE                    	XCHG    DI,SI
 25612 000055E5 D1E9                            SHR     CX,1
 25613                                  ;M039
 25614                                  	; MSDOS 3.3
 25615 000055E7 7301                    	JNC	short EVENRD
 25616 000055E9 A4                      	MOVSB
 25617                                  EVENRD:
 25618 000055EA F3A5                    	REP     MOVSW
 25619                                  
 25620                                  ;	   CX = # of whole WORDs; CF=1 if odd # of bytes.
 25621                                  ;       DS:SI-> Source within Buffer.
 25622                                  ;       ES:DI-> Destination within Transfer memory block.
 25623                                  
 25624                                  	; MSDOS 6.0
 25625                                  ;	rep	movsw			;Copy Buffer to Transfer memory.
 25626                                  ;	adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 25627                                  ;	rep	movsb                   ;Copy last byte.
 25628                                  ;M039
 25629                                  
 25630 000055EC 07                              POP	ES
 25631                                  ;hkn; SS override
 25632 000055ED 36C53E[9E05]                    LDS     DI,[SS:CURBUF]
 25633                                  	;lea	bx,[di+16]
 25634                                  	;lea	bx,[di+20] ; MSDOS 6.0
 25635 000055F2 8D5D14                  	LEA     BX,[DI+BUFINSIZ]
 25636 000055F5 29DE                            SUB     SI,BX                   ; Position in buffer
 25637 000055F7 E8FF0A                          call	PLACEBUF
 25638                                  	;cmp	si,[es:bp+2]
 25639 000055FA 263B7602                	CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Read Last byte?
 25640 000055FE 7203                            JB	short RBUFPLACEDC	; No, leave buf where it is
 25641                                  
 25642                                  ;M039
 25643                                  	; MSDOS 3.3
 25644 00005600 E8540B                  	call	PLACEHEAD               ; Make it prime candidate for chucking
 25645                                                                          ;  even though it is MRU.
 25646                                          ; MSDOS 6.0
 25647                                  	;MOV	[BufferQueue],DI	; Make it prime candidate for
 25648                                  ;M039					; chucking even though it is MRU.
 25649                                  
 25650                                  RBUFPLACEDC:
 25651 00005603 F8                              CLC
 25652                                  RBUFPLACED:
 25653 00005604 16                      	push	ss
 25654 00005605 1F                      	pop	ds
 25655 00005606 C3                              retn
 25656                                  
 25657                                  ;----------------------------------------------------------------------------
 25658                                  ;
 25659                                  ; Procedure : BUFWRT
 25660                                  ;
 25661                                  ; Do a partial sector write via one of the system buffers
 25662                                  ; ES:BP Points to DPB
 25663                                  ; Carry set if error (currently user FAILed to I 24)
 25664                                  ;
 25665                                  ; DS - set to DOSDATA
 25666                                  ;
 25667                                  ;----------------------------------------------------------------------------
 25668                                  
 25669                                  	; 24/07/2019 - Retro DOS v3.2
 25670                                  	; 20/05/2019 - Retro DOS v4.0
 25671                                  BUFWRT:
 25672 00005607 A1[8005]                        MOV     AX,[SECPOS]
 25673                                          ; MSDOS 6.0
 25674 0000560A 83C001                  	ADD	AX,1            	; Set for next sector
 25675 0000560D A3[8005]                        MOV	[SECPOS],AX 		;F.C. >32mb	;AN000;
 25676 00005610 8316[8205]00                    ADC	word [SECPOS+2],0	;F.C. >32mb	;AN000;
 25677 00005615 A1[8205]                        MOV	AX,[SECPOS+2]		;F.C. >32mb	;AN000;
 25678 00005618 3B06[8605]                      CMP	AX,[VALSEC+2]		;F.C. >32mb	;AN000;
 25679 0000561C B001                            MOV	AL,1			;F.C. >32mb	;AN000;
 25680 0000561E 770F                            JA	short NOREAD		;F.C. >32mb	;AN000;
 25681 00005620 720B                            JB	short _doread		;F.C. >32mb	;AN000;
 25682 00005622 A1[8005]                        MOV	AX,[SECPOS]		;F.C. >32mb	;AN000;
 25683                                  
 25684                                  	; MSDOS 3.3
 25685                                  	;INC	AX
 25686                                  	;MOV	[SECPOS],AX ; 09/09/2018
 25687                                  
 25688                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25689 00005625 3B06[8405]                      CMP     AX,[VALSEC]		; Has sector been written before?
 25690 00005629 B001                            MOV     AL,1
 25691 0000562B 7702                            JA	short NOREAD		; Skip preread if SECPOS>VALSEC
 25692                                  _doread:
 25693 0000562D 30C0                            XOR     AL,AL
 25694                                  NOREAD:
 25695 0000562F 06                              PUSH	ES
 25696 00005630 E861FF                          CALL    BUFSEC
 25697 00005633 72A3                    	JC	short BUF_IO_FAIL
 25698 00005635 8E1E[FA02]                      MOV     DS,[DMAADD+2]
 25699 00005639 D1E9                            SHR     CX,1
 25700                                  ;M039
 25701                                  	; MSDOS 3.3
 25702                                  	;JNC	short EVENWRT ; 09/09/2018
 25703                                  	;MOVSB
 25704                                  ;EVENWRT:
 25705                                  	;REP	MOVSW
 25706                                  
 25707                                  ;	CX = # of whole WORDs; CF=1 if odd # of bytes.
 25708                                  ;       DS:SI-> Source within Transfer memory block.
 25709                                  ;       ES:DI-> Destination within Buffer.
 25710                                  
 25711                                  	; MSDOS 6.0
 25712 0000563B F3A5                    	rep	movsw			;Copy Transfer memory to Buffer.
 25713                                  	;adc	cx,0                    ;CX=1 if odd # of bytes, else CX=0.
 25714                                  	;rep	movsb                   ;Copy last byte.
 25715 0000563D 7301                    	jnc	short EVENWRT ; **** 20/05/2019
 25716 0000563F A4                      	movsb ; ****
 25717                                  ;M039
 25718                                  EVENWRT: ; ****
 25719 00005640 07                              POP	ES
 25720                                  
 25721                                  ;hkn; SS override
 25722 00005641 36C51E[9E05]                    LDS     BX,[SS:CURBUF]
 25723                                  
 25724                                  	; MSDOS 6.0
 25725                                          ;TEST	byte [BX+BUFFINFO.buf_flags],buf_dirty
 25726                                  	;				;LB. if already dirty		  ;AN000;
 25727                                          ;JNZ	short yesdirty10	;LB.  don't increment dirty count ;AN000;
 25728                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 25729                                  	
 25730                                  	;or	byte [bx+5],40h
 25731 00005646 804F0540                        OR	byte [BX+BUFFINFO.buf_flags],buf_dirty
 25732                                  ;yesdirty10:
 25733                                  	;;lea	si,[bx+16]
 25734                                  	;lea	si,[bx+20] ; MSDOS 6.0
 25735 0000564A 8D7714                          LEA     SI,[BX+BUFINSIZ]
 25736 0000564D 29F7                            SUB     DI,SI                   ; Position in buffer
 25737                                  ;M039
 25738                                  	; 24/07/2019 - Retro DOS v3.2
 25739                                  	; MSDOS 3.3
 25740 0000564F 89FE                    	MOV     SI,DI
 25741 00005651 89DF                    	MOV     DI,BX
 25742 00005653 E8A30A                  	call	PLACEBUF
 25743                                  	;cmp	si,[es:bp+2]
 25744 00005656 263B7602                	CMP     SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 25745 0000565A 7203                    	JB	short WBUFPLACED	; No, leave buf where it is
 25746 0000565C E8F80A                  	call	PLACEHEAD               ; Make it prime candidate for chucking
 25747                                                                          ;  even though it is MRU.
 25748                                  	; MSDOS 6.0
 25749                                  	;CMP	SI,[ES:BP+DPB.SECTOR_SIZE] ; Written last byte?
 25750                                          ;JB	short WBUFPLACED	; No, leave buf where it is
 25751                                          ;MOV	[ss:BufferQueue],BX	; Make it prime candidate for
 25752                                  					; chucking even though it is MRU.
 25753                                  ;M039
 25754                                  
 25755                                  WBUFPLACED:
 25756 0000565F F8                              CLC
 25757 00005660 16                      	push	ss
 25758 00005661 1F                      	pop	ds
 25759 00005662 C3                              retn
 25760                                  
 25761                                  ;Break   <NEXTSEC -- Compute next sector to read or write>
 25762                                  ;---------------------------------------------------------------------------
 25763                                  ;
 25764                                  ; Procedure Name : NEXTSEC
 25765                                  ;
 25766                                  ; Compute the next sector to read or write
 25767                                  ; ES:BP Points to DPB
 25768                                  ;
 25769                                  ;---------------------------------------------------------------------------
 25770                                  
 25771                                  NEXTSEC:
 25772 00005663 F606[3105]FF            	test	byte [TRANS],0FFh ; -1 
 25773 00005668 7426                            JZ	short CLRET
 25774                                  
 25775 0000566A A0[3005]                        MOV     AL,[SECCLUSPOS]
 25776 0000566D FEC0                            INC     AL
 25777                                  	;cmp	al,[es:bp+4]
 25778 0000566F 263A4604                        CMP     AL,[ES:BP+DPB.CLUSTER_MASK]
 25779 00005673 7618                            JBE	short SAVPOS
 25780                                  
 25781 00005675 8B1E[7805]                      MOV     BX,[CLUSNUM]
 25782 00005679 E89C06                          call	IsEOF
 25783 0000567C 7314                            JAE	short NONEXT
 25784                                  
 25785 0000567E E8AE06                          call	UNPACK
 25786 00005681 720F                            JC	short NONEXT
 25787                                  clusgot:
 25788 00005683 893E[7805]                      MOV     [CLUSNUM],DI
 25789 00005687 FF06[7605]                      INC     word [LASTPOS]
 25790 0000568B B000                            MOV     AL,0
 25791                                  SAVPOS:
 25792 0000568D A2[3005]                        MOV     [SECCLUSPOS],AL
 25793                                  CLRET:
 25794 00005690 F8                              CLC
 25795 00005691 C3                              retn
 25796                                  NONEXT:
 25797 00005692 F9                              STC
 25798 00005693 C3                              retn
 25799                                  
 25800                                  ;Break	<OPTIMIZE -- DO A USER DISK REQUEST WELL>
 25801                                  ;----------------------------------------------------------------------------
 25802                                  ;
 25803                                  ; Procedure Name : OPTIMIZE
 25804                                  ;
 25805                                  ; Inputs:
 25806                                  ;       BX = Physical cluster
 25807                                  ;       CX = No. of records
 25808                                  ;       DL = sector within cluster
 25809                                  ;       ES:BP = Base of drives parameters
 25810                                  ;       [NEXTADD] = transfer address
 25811                                  ; Outputs:
 25812                                  ;       AX = No. of records remaining
 25813                                  ;       BX = Transfer address
 25814                                  ;       CX = No. or records to be transferred
 25815                                  ;       DX = Physical sector address            (LOW)
 25816                                  ;       [HIGH_SECTOR] = Physical sector address (HIGH)
 25817                                  ;       DI = Next cluster
 25818                                  ;       [CLUSNUM] = Last cluster accessed
 25819                                  ;       [NEXTADD] updated
 25820                                  ;       Carry set if error (currently user FAILed to I 24)
 25821                                  ; ES:BP unchanged. Note that segment of transfer not set.
 25822                                  ;
 25823                                  ;---------------------------------------------------------------------------
 25824                                  
 25825                                  OPTIMIZE:
 25826 00005694 52                      	PUSH    DX
 25827 00005695 53                              PUSH    BX
 25828                                  	;mov	al,[es:bp+4]
 25829 00005696 268A4604                        MOV     AL,[ES:BP+DPB.CLUSTER_MASK]
 25830 0000569A FEC0                            INC     AL              ; Number of sectors per cluster
 25831 0000569C 88C4                            MOV     AH,AL
 25832 0000569E 28D0                            SUB     AL,DL           ; AL = Number of sectors left in first cluster
 25833 000056A0 89CA                            MOV     DX,CX
 25834 000056A2 B90000                          MOV     CX,0
 25835                                  OPTCLUS:
 25836                                  ; AL has number of sectors available in current cluster
 25837                                  ; AH has number of sectors available in next cluster
 25838                                  ; BX has current physical cluster
 25839                                  ; CX has number of sequential sectors found so far
 25840                                  ; DX has number of sectors left to transfer
 25841                                  ; ES:BP Points to DPB
 25842                                  ; ES:SI has FAT pointer
 25843                                  
 25844                                  do_norm3:
 25845 000056A5 E88706                          call	UNPACK
 25846 000056A8 7237                            JC	short OP_ERR
 25847                                  clusgot2:
 25848 000056AA 00C1                    	ADD	CL,AL
 25849 000056AC 80D500                          ADC     CH,0
 25850 000056AF 39D1                            CMP     CX,DX
 25851 000056B1 7333                            JAE	short BLKDON
 25852 000056B3 88E0                            MOV     AL,AH
 25853 000056B5 43                              INC     BX
 25854 000056B6 39DF                            CMP     DI,BX
 25855 000056B8 74EB                            JZ	short OPTCLUS
 25856 000056BA 4B                              DEC     BX
 25857                                  FINCLUS:
 25858 000056BB 891E[7805]                      MOV     [CLUSNUM],BX    ; Last cluster accessed
 25859 000056BF 29CA                            SUB     DX,CX           ; Number of sectors still needed
 25860 000056C1 52                              PUSH    DX
 25861 000056C2 89C8                            MOV     AX,CX
 25862                                  	;mul	word[ES:BP+2]
 25863 000056C4 26F76602                        MUL	word [ES:BP+DPB.SECTOR_SIZE] 
 25864                                  				; Number of sectors times sector size
 25865 000056C8 8B36[7405]                      MOV     SI,[NEXTADD]
 25866 000056CC 01F0                            ADD     AX,SI           ; Adjust by size of transfer
 25867 000056CE A3[7405]                        MOV     [NEXTADD],AX
 25868 000056D1 58                              POP     AX              ; Number of sectors still needed
 25869 000056D2 5A                              POP     DX              ; Starting cluster
 25870 000056D3 29D3                            SUB     BX,DX           ; Number of new clusters accessed
 25871 000056D5 011E[7605]                      ADD     [LASTPOS],BX
 25872 000056D9 5B                              POP     BX              ; BL = sector postion within cluster
 25873 000056DA E81700                  	call	FIGREC
 25874 000056DD 89F3                            MOV     BX,SI
 25875 000056DF F8                      	CLC
 25876 000056E0 C3                              retn
 25877                                  OP_ERR:
 25878 000056E1 83C404                          ADD     SP,4
 25879 000056E4 F9                      	STC
 25880 000056E5 C3                              retn
 25881                                  BLKDON:
 25882 000056E6 29D1                            SUB     CX,DX           ; Number of sectors in cluster we don't want
 25883 000056E8 28CC                            SUB     AH,CL           ; Number of sectors in cluster we accepted
 25884 000056EA FECC                            DEC     AH              ; Adjust to mean position within cluster
 25885 000056EC 8826[3005]                      MOV     [SECCLUSPOS],AH
 25886 000056F0 89D1                            MOV     CX,DX           ; Anyway, make the total equal to the request
 25887 000056F2 EBC7                            JMP     SHORT FINCLUS
 25888                                  
 25889                                  ;Break	<FIGREC -- Figure sector in allocation unit>
 25890                                  ;---------------------------------------------------------------------------
 25891                                  ;
 25892                                  ; Procedure Name : FIGREC
 25893                                  ;
 25894                                  ; Inputs:
 25895                                  ;       DX = Physical cluster number
 25896                                  ;       BL = Sector position within cluster
 25897                                  ;       ES:BP = Base of drive parameters
 25898                                  ; Outputs:
 25899                                  ;       DX = physical sector number           (LOW)
 25900                                  ;       [HIGH_SECTOR] Physical sector address (HIGH)
 25901                                  ; No other registers affected.
 25902                                  ;
 25903                                  ;---------------------------------------------------------------------------
 25904                                  
 25905                                  FIGREC:
 25906                                  	; 24/07/2019 - Retro DOS v3.2
 25907                                  	; 20/05/2019 - Retro DOS v4.0
 25908 000056F4 51                              PUSH    CX
 25909                                  	;mov	cl,[es:bp+5]
 25910 000056F5 268A4E05                        MOV     CL,[ES:BP+DPB.CLUSTER_SHIFT]
 25911 000056F9 4A                              DEC     DX
 25912 000056FA 4A                              DEC     DX
 25913                                  
 25914                                  	; MSDOS 3.3
 25915                                  	;SHL	DX,CL
 25916                                  
 25917                                  ;hkn; SS override HIGH_SECTOR
 25918                                  	; MSDOS 6.0
 25919                                  	;MOV	word [SS:HIGH_SECTOR],0		;F.C. >32mb
 25920 000056FB 2EC706[B005]0000        	mov	word [cs:HIGH_SECTOR],0	
 25921 00005702 08C9                    	OR	CL,CL				;F.C. >32mb
 25922 00005704 740C                    	JZ	short noshift			;F.C. >32mb
 25923 00005706 30ED                    	XOR	CH,CH 				;F.C. >32mb
 25924                                  rotleft:					;F.C. >32mb
 25925 00005708 F8                      	CLC					;F.C. >32mb
 25926 00005709 D1D2                    	RCL	DX,1				;F.C. >32mb
 25927                                  	; 10/06/2019
 25928                                  	;RCL	word [ss:HIGH_SECTOR],1		;F.C. >32mb
 25929 0000570B 2ED116[B005]            	rcl	word [cs:HIGH_SECTOR],1
 25930 00005710 E2F6                    	LOOP	rotleft				;F.C. >32mb
 25931                                  noshift:
 25932                                  	; MSDOS 3.3 & MSDOS 6.0
 25933 00005712 08DA                            OR      DL,BL
 25934                                  	;add	dx,[es:bp+0Bh]
 25935 00005714 2603560B                        ADD     DX,[ES:BP+DPB.FIRST_SECTOR]
 25936                                  	; MSDOS 6.0
 25937                                  	; 10/06/2019
 25938                                          ;ADC	word [ss:HIGH_SECTOR],0		;F.C. >32mb
 25939 00005718 2E8316[B005]00          	adc	word [cs:HIGH_SECTOR],0
 25940                                  	; MSDOS 3.3 & MSDOS 6.0        
 25941 0000571E 59                      	POP     CX
 25942                                  figrec_retn:
 25943 0000571F C3                              retn
 25944                                  
 25945                                  ; 30/07/2018 - Retro DOS v3.0
 25946                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 
 25947                                  
 25948                                  ;Break   <ALLOCATE -- Assign disk space>
 25949                                  ;---------------------------------------------------------------------------
 25950                                  ;
 25951                                  ; Procedure Name : ALLOCATE - Allocate Disk Space
 25952                                  ;
 25953                                  ;   ALLOCATE is called to allocate disk clusters. The new clusters are
 25954                                  ;   FAT-chained onto the end of the existing file.
 25955                                  ;
 25956                                  ;   The DPB contains the cluster # of the last free cluster allocated
 25957                                  ;   (dpb_next_free). We start at this cluster and scan towards higher
 25958                                  ;   numbered clusters, looking for the necessary free blocks.
 25959                                  ;
 25960                                  ;   Once again, fancy terminology gets in the way of corrct coding. When
 25961                                  ;   using next_free, start scanning AT THAT POINT and not the one following it.
 25962                                  ;   This fixes the boundary condition bug when only free = next_free = 2.
 25963                                  ;
 25964                                  ;       If we get to the end of the disk without satisfaction:
 25965                                  ;
 25966                                  ;           if (dpb_next_free == 2) then we've scanned the whole disk.
 25967                                  ;               return (insufficient_disk_space)
 25968                                  ;           ELSE
 25969                                  ;               dpb_next_free = 2; start scan over from the beginning.
 25970                                  ;
 25971                                  ;   Note that there is no multitasking interlock. There is no race when
 25972                                  ;   examining the entrys in an in-core FAT block since there will be no
 25973                                  ;   context switch. When UNPACK context switches while waiting for a FAT read
 25974                                  ;   we are done with any in-core FAT blocks, so again there is no race. The
 25975                                  ;   only special concern is that V2 and V3 MSDOS left the last allocated
 25976                                  ;   cluster as "00"; marking it EOF only when the entire alloc request was
 25977                                  ;   satisfied. We can't allow another activation to think this cluster is
 25978                                  ;   free, so we give it a special temporary mark to show that it is, indeed,
 25979                                  ;   allocated.
 25980                                  ;
 25981                                  ;   Note that when we run out of space this algorithem will scan from
 25982                                  ;   dpb_next_free to the end, then scan from cluster 2 through the end,
 25983                                  ;   redundantly scanning the later part of the disk. This only happens when
 25984                                  ;   we run out of space, so sue me.
 25985                                  ;
 25986                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 25987                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 25988                                  ;                                                                          ;
 25989                                  ;   The use of FATBYT and RESTFATBYT is somewhat mysterious. Here is the
 25990                                  ;   explanation:
 25991                                  ;
 25992                                  ;   In the NUL file case (sf_firclus currently 0) ALLOCATE is called with
 25993                                  ;   entry BX = 0. What needs to be done in this case is to stuff the cluster
 25994                                  ;   number of the first cluster allocated in sf_firclus when the ALLOCATE is
 25995                                  ;   complete. THIS VALUE IS SAVED TEMPORARILY IN CLUSTER 0, HENCE THE CURRENT
 25996                                  ;   VALUE IN CLUSTER 0 MUST BE SAVED AND RESTORED. This is a side effect of
 25997                                  ;   the fact that PACK and UNPACK don't treat requests for clusters 0 and 1 as
 25998                                  ;   errors. This "stuff" is done by the call to PACK which is right before
 25999                                  ;   the
 26000                                  ;           LOOP   findfre         ; alloc more if needed
 26001                                  ;   instruction when the first cluster is allocated to the nul file. The
 26002                                  ;   value is recalled from cluster 0 and stored at sf_firclus at ads4:
 26003                                  ;
 26004                                  ;   This method is obviously useless (because it is non-reentrant) for
 26005                                  ;   multitasking, and will have to be changed. Storing the required value on
 26006                                  ;   the stack is recommended. Setting sf_firclus at the PACK of cluster 0
 26007                                  ;   (instead of actually doing the PACK) is BAD because it doesn't handle
 26008                                  ;   problems with INT 24 well.
 26009                                  ;
 26010                                  ;            C  A  V  E  A  T     P  A  T  T  E  R  S  O  N                ;
 26011                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
 26012                                  ;                                                                          ;
 26013                                  ;       ENTRY   BX = Last cluster of file (0 if null file)
 26014                                  ;               CX = No. of clusters to allocate
 26015                                  ;               ES:BP = Base of drive parameters
 26016                                  ;               [THISSFT] = Points to SFT
 26017                                  ;
 26018                                  ;       EXIT    'C' set if insufficient space
 26019                                  ;                 [FAILERR] can be tested to see the reason for failure
 26020                                  ;                 CX = max. no. of clusters that could be added to file
 26021                                  ;               'C' clear if space allocated
 26022                                  ;                 BX = First cluster allocated
 26023                                  ;                 FAT is fully updated
 26024                                  ;                 sf_FIRCLUS field of SFT set if file was null
 26025                                  ;
 26026                                  ;       USES    ALL but SI, BP
 26027                                  
 26028                                  ;callmagic  proc near
 26029                                  ;       push    ds                             ;push segment of routine 
 26030                                  ;       push    Offset MagicPatch              ;push offset for routine
 26031                                  ;       retf                                   ;simulate jmp far
 26032                                  ;                                              ;far return address is on
 26033                                  ;                                              ;stack, so far return from
 26034                                  ;                                              ;call will return this routine
 26035                                  ;callmagic  endp
 26036                                  
 26037                                  ALLOCATE:
 26038                                  	; 10/09/2018
 26039                                  ;BEGIN MAGICDRV MODIFICATIONS
 26040                                  ;
 26041                                  ;7/5/92 scottq
 26042                                  ;
 26043                                  ;This is the disk compression patch location which allows
 26044                                  ;the disk compression software to fail allocations if the
 26045                                  ;FAT would allows allocation, but the free space for compressed
 26046                                  ;data would not.
 26047                                  ;        
 26048                                  ;;;	call    far ptr MAGICPATCH
 26049                                  ;;; We cannot do a far call since we cannot have fix-ups[romdos,hidos],
 26050                                  ;;; but we do know the segment and offset of the routine
 26051                                  ;;; so simulate a far call to dosdata:magicpatch
 26052                                  ;;; note dosassume above, so DS -> dosdata
 26053                                  
 26054                                  	; MSDOS 6.0
 26055                                          ;clc				;clear carry so we fall through
 26056                                  	;				;if no patch is present
 26057                                  	;push	cs			;push segment for far return
 26058                                          ;call	callmagic		;this is a near call
 26059                                          ;jnc	short Regular_Allocate_Path
 26060                                  	;jmp	Disk_Full_Return ; 10/09/2018 !
 26061                                  
 26062                                  ;Regular_Allocate_Path:
 26063                                  ;END MAGICDRV MODIFICATIONS
 26064                                  
 26065 00005720 53                              PUSH    BX                      ; save (bx)
 26066 00005721 31DB                            XOR     BX,BX
 26067 00005723 E80906                  	call	UNPACK
 26068 00005726 893E[5205]                      MOV     [FATBYT],DI             ; save correct cluster 0 value
 26069 0000572A 5B                              POP     BX
 26070 0000572B 72F2                            jc	short figrec_retn	; abort if error   [INTERR?]
 26071                                  
 26072 0000572D 51                              PUSH    CX
 26073 0000572E 53                              PUSH    BX
 26074                                  
 26075 0000572F 89DA                            MOV     DX,BX
 26076                                  	;mov	bx,[es:bp+1Ch]
 26077                                  	;mov	bx,[es:bp+1Dh]	; MSDOS 6.0
 26078 00005731 268B5E1D                        mov     bx,[ES:BP+DPB.NEXT_FREE]
 26079 00005735 83FB02                          cmp     bx,2
 26080 00005738 7709                            ja	short FINDFRE
 26081                                  
 26082                                  ;   couldn't find enough free space beyond dpb_next_free, or dpb_next_free is
 26083                                  ;   <2 or >dpb_max_clus. Reset it and restart the scan
 26084                                  
 26085                                  ads1:
 26086                                  	;mov	word [es:bp+1Ch],2
 26087                                  	;mov	word [es:bp+1Dh],2 ; MSDOS 6.0
 26088 0000573A 26C7461D0200                    mov     word [ES:BP+DPB.NEXT_FREE],2
 26089 00005740 BB0100                          mov     bx,1                    ; Counter next instruction so first
 26090                                                                          ;       cluster examined is 2
 26091                                  
 26092                                  ;   Scanning both forwards and backwards for a free cluster
 26093                                  ;
 26094                                  ;       (BX) = forwards scan pointer
 26095                                  ;       (CX) = clusters remaining to be allocated
 26096                                  ;       (DX) = current last cluster in file
 26097                                  ;       (TOS) = last cluster of file
 26098                                  
 26099                                  FINDFRE:
 26100 00005743 43                              INC     BX
 26101                                  	;cmp	bx,[es:bp+0Dh]
 26102 00005744 263B5E0D                        CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 26103 00005748 7757                    	ja	short ads7	; at end of disk
 26104 0000574A E8E205                          call	UNPACK          ; check out this cluster
 26105 0000574D 722F                            jc	short ads4	; FAT error             [INTERR?]
 26106 0000574F 75F2                            jnz	short FINDFRE	; not free, keep on truckin
 26107                                  
 26108                                  ;   Have found a free cluster. Chain it to the file
 26109                                  ;
 26110                                  ;       (BX) = found free cluster #
 26111                                  ;       (DX) = current last cluster in file
 26112                                  
 26113                                  	;mov	[es:bp+1Ch],bx
 26114                                  	;mov	[es:bp+1Dh],bx ; MSDOS 6.0
 26115 00005751 26895E1D                        mov	[ES:BP+DPB.NEXT_FREE],bx ; next time start search here
 26116 00005755 92                              xchg    ax,dx           ; save (dx) in ax
 26117 00005756 BA0100                          mov     dx,1            ; mark this free guy as "1"
 26118 00005759 E82706                  	call	PACK            ; set special "temporary" mark
 26119 0000575C 7220                            jc	short ads4	; FAT error             [INTERR?]
 26120                                  	;cmp	word [es:bp+1Eh],-1
 26121                                          ;cmp	word [es:bp+1Fh],-1 ; MSDOS 6.0
 26122 0000575E 26837E1FFF                      CMP	word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 26123 00005763 7404                            JZ	short NO_ALLOC	; No
 26124                                  	;dec	word [es:bp+1Eh]
 26125                                          ;dec	word [es:bp+1Fh] ; MSDOS 6.0
 26126 00005765 26FF4E1F                        DEC     word [ES:BP+DPB.FREE_CNT] ; Reduce free count by 1
 26127                                  NO_ALLOC:
 26128 00005769 92                              xchg    ax,dx           ; (dx) = current last cluster in file
 26129 0000576A 87DA                            XCHG    BX,DX
 26130 0000576C 89D0                            MOV     AX,DX
 26131 0000576E E81206                  	call	PACK            ; link free cluster onto file
 26132                                                                  ;  CAVEAT.. On Nul file, first pass stuffs
 26133                                                                  ;    cluster 0 with FIRCLUS value.
 26134 00005771 720B                            jc	short ads4	; FAT error [INTERR?]
 26135 00005773 93                              xchg    BX,AX           ; (BX) = last one we looked at
 26136 00005774 89DA                            mov     dx,bx           ; (dx) = current end of file
 26137 00005776 E2CB                            LOOP    FINDFRE         ; alloc more if needed
 26138                                  
 26139                                  ;   We've successfully extended the file. Clean up and exit
 26140                                  ;
 26141                                  ;       (BX) = last cluster in file
 26142                                  
 26143 00005778 BAFFFF                          MOV     DX,0FFFFH
 26144 0000577B E80506                  	call	PACK            ; mark last cluster EOF
 26145                                  
 26146                                  ;   Note that FAT errors jump here to clean the stack and exit. This saves us
 26147                                  ;   2 whole bytes.  Hope its worth it...
 26148                                  ;
 26149                                  ;       'C' set iff error
 26150                                  ;       calling (BX) and (CX) pushed on stack
 26151                                  
 26152                                  ads4:   
 26153 0000577E 5B                      	POP     BX
 26154 0000577F 59                              POP     CX              ; Don't need this stuff since we're successful
 26155 00005780 729D                            jc	short figrec_retn
 26156 00005782 E8AA05                          call	UNPACK          ; Get first cluster allocated for return
 26157                                                                  ; CAVEAT... In nul file case, UNPACKs cluster 0.
 26158 00005785 7298                            jc	short figrec_retn
 26159 00005787 E83200                  	call	RESTFATBYT      ; Restore correct cluster 0 value
 26160 0000578A 7293                            jc	short figrec_retn
 26161 0000578C 87DF                            XCHG    BX,DI           ; (DI) = last cluster in file upon our entry
 26162 0000578E 09FF                            OR      DI,DI           ; clear 'C'
 26163 00005790 758D                    	jnz	short figrec_retn ; we were extending an existing file
 26164                                  
 26165                                  ;   We were doing the first allocation for a new file. Update the SFT cluster
 26166                                  ;   info
 26167                                  dofastk:
 26168 00005792 06                              PUSH	ES
 26169 00005793 C43E[5A05]                      LES     DI,[THISSFT]
 26170                                  	;mov	[es:di+0Bh],bx
 26171 00005797 26895D0B                        MOV     [ES:DI+SF_ENTRY.sf_firclus],BX
 26172                                  	;mov	[es:di+1Bh],bx
 26173                                  	;mov	[es:di+35h],bx ; MSDOS 6.0
 26174 0000579B 26895D35                        MOV     [ES:DI+SF_ENTRY.sf_lstclus],BX
 26175 0000579F 07                              POP	ES
 26176 000057A0 C3                              retn
 26177                                  
 26178                                  ;** we're at the end of the disk, and not satisfied. See if we've scanned ALL
 26179                                  ;   of the disk...
 26180                                  
 26181                                  ads7:   
 26182 000057A1 26837E1D02              	cmp	word [ES:BP+DPB.NEXT_FREE],2
 26183 000057A6 7592                    	jnz	short ads1	; start scan from front of disk
 26184                                  
 26185                                  ;   Sorry, we've gone over the whole disk, with insufficient luck. Lets give
 26186                                  ;   the space back to the free list and tell the caller how much he could have
 26187                                  ;   had.  We have to make sure we remove the "special mark" we put on the last
 26188                                  ;   cluster we were able to allocate, so it doesn't become orphaned.
 26189                                  ;
 26190                                  ;       (CX) = clusters remaining to be allocated
 26191                                  ;       (TOS) = last cluster of file (before call to ALLOCATE)
 26192                                  ;       (TOS+1) = # of clusters wanted to allocate
 26193                                  
 26194 000057A8 5B                              POP     BX              ; (BX) = last cluster of file
 26195 000057A9 BAFFFF                          MOV     DX,0FFFFH
 26196 000057AC E81F00                  	call	RELBLKS         ; give back any clusters just alloced
 26197 000057AF 58                              POP     AX              ; No. of clusters requested
 26198                                                                  ; Don't "retc". We are setting Carry anyway,
 26199                                                                  ;   Alloc failed, so proceed with return CX
 26200                                                                  ;   setup.
 26201 000057B0 29C8                            SUB     AX,CX           ; AX=No. of clusters allocated
 26202 000057B2 E80700                  	call	RESTFATBYT      ; Don't "retc". We are setting Carry anyway,
 26203                                                                  ;   Alloc failed.
 26204                                  ;Disk_Full_Return:               ;label added for magic patch 8-6-92 scottq
 26205                                          ; MSDOS 6.0
 26206 000057B5 C606[C20F]01            	MOV	byte [DISK_FULL],1 ;MS. indicating disk full
 26207 000057BA F9                              STC
 26208 000057BB C3                              retn
 26209                                  
 26210                                  ;-----------------------------------------------------------------------
 26211                                  ;
 26212                                  ; Procedure Name : RESTFATBYT
 26213                                  ;
 26214                                  ; SEE ALLOCATE CAVEAT
 26215                                  ;       Carry set if error (currently user FAILed to I 24)
 26216                                  ;-----------------------------------------------------------------------
 26217                                  
 26218                                  RESTFATBYT:
 26219 000057BC 53                              PUSH    BX
 26220 000057BD 52                              PUSH    DX
 26221 000057BE 57                              PUSH    DI
 26222 000057BF 31DB                            XOR     BX,BX
 26223 000057C1 8B16[5205]                      MOV     DX,[FATBYT]
 26224 000057C5 E8BB05                  	call	PACK
 26225 000057C8 5F                              POP     DI
 26226 000057C9 5A                              POP     DX
 26227 000057CA 5B                              POP     BX
 26228                                  RELEASE_flush:
 26229 000057CB C3                      	retn
 26230                                  
 26231                                  ;Break	<RELEASE -- DEASSIGN DISK SPACE>
 26232                                  ;---------------------------------------------------------------------------
 26233                                  ;
 26234                                  ; Procedure Name : RELEASE
 26235                                  ;
 26236                                  ; Inputs:
 26237                                  ;       BX = Cluster in file
 26238                                  ;       ES:BP = Base of drive parameters
 26239                                  ; Function:
 26240                                  ;       Frees cluster chain starting with [BX]
 26241                                  ;       Carry set if error (currently user FAILed to I 24)
 26242                                  ; AX,BX,DX,DI all destroyed. Other registers unchanged.
 26243                                  ;
 26244                                  ;-----------------------------------------------------------------------------
 26245                                  
 26246                                  RELEASE:
 26247 000057CC 31D2                            XOR     DX,DX
 26248                                  
 26249                                  	;entry	RELBLKS
 26250                                  RELBLKS:
 26251                                  
 26252                                  ;   Enter here with DX=0FFFFH to put an end-of-file mark in the first cluster
 26253                                  ;   and free the rest in the chain.
 26254                                  
 26255 000057CE E85E05                  	call	UNPACK
 26256 000057D1 72F8                    	jc	short RELEASE_flush
 26257 000057D3 74F6                    	jz	short RELEASE_flush
 26258 000057D5 89F8                            MOV     AX,DI
 26259 000057D7 52                              PUSH    DX
 26260 000057D8 E8A805                  	call	PACK
 26261 000057DB 5A                              POP     DX
 26262 000057DC 72ED                    	jc	short RELEASE_flush
 26263 000057DE 09D2                            OR      DX,DX
 26264 000057E0 750B                            JNZ	short NO_DEALLOC	; Was putting EOF mark
 26265                                  	;cmp	word [es:bp+1Eh],-1
 26266 000057E2 26837E1FFF              	CMP     word [ES:BP+DPB.FREE_CNT],-1 ; Free count valid?
 26267 000057E7 7404                            JZ	short NO_DEALLOC	; No
 26268 000057E9 26FF461F                        INC	word [ES:BP+DPB.FREE_CNT] ; Increase free count by 1
 26269                                  NO_DEALLOC:
 26270 000057ED 89C3                            MOV     BX,AX
 26271 000057EF 48                              dec     ax              ; check for "1"
 26272 000057F0 74D9                    	jz	short RELEASE_flush	; is last cluster of incomplete chain
 26273 000057F2 E82305                  	call	IsEOF
 26274 000057F5 72D5                            JB	short RELEASE	; Carry clear if JMP not taken
 26275                                  
 26276                                  ;RELEASE_flush:
 26277                                  	; MSDOS 6.0
 26278                                  	;mov	al,[es:bp]
 26279                                  	;;MOV	AL,[ES:BP+DPB.DRIVE]
 26280                                  	;push	si		; FLUSHBUF may trash these and we guarantee
 26281                                  	;push	cx		;  them to be preserved.
 26282                                  	;push	es
 26283                                  	;push	bp
 26284                                  	;call	FLUSHBUF	; commit buffers for this drive
 26285                                  	;pop	bp
 26286                                  	;pop	es
 26287                                  	;pop	cx
 26288                                  	;pop	si
 26289                                  RET12:
 26290 000057F7 C3                      	retn
 26291                                  
 26292                                  ;Break	<GETEOF -- Find the end of a file>
 26293                                  ;------------------------------------------------------------------------
 26294                                  ;
 26295                                  ; Procedure Name : GETEOF
 26296                                  ;
 26297                                  ; Inputs:
 26298                                  ;       ES:BP Points to DPB
 26299                                  ;       BX = Cluster in a file
 26300                                  ;       DS = CS
 26301                                  ; Outputs:
 26302                                  ;       BX = Last cluster in the file
 26303                                  ;       Carry set if error (currently user FAILed to I 24)
 26304                                  ; DI destroyed. No other registers affected.
 26305                                  ;
 26306                                  ;--------------------------------------------------------------------------
 26307                                  
 26308                                  GETEOF:
 26309 000057F8 E83405                  	call	UNPACK
 26310 000057FB 72FA                            jc	short RET12
 26311 000057FD 53                              PUSH    BX
 26312 000057FE 89FB                            MOV     BX,DI
 26313 00005800 E81505                  	call	IsEOF
 26314 00005803 5B                              POP     BX
 26315 00005804 73F1                            JAE     short RET12
 26316 00005806 89FB                            MOV     BX,DI
 26317 00005808 EBEE                            JMP     short GETEOF
 26318                                  
 26319                                  ;============================================================================
 26320                                  ; FCB.ASM, MSDOS 6.0, 1991
 26321                                  ;============================================================================
 26322                                  ; 30/07/2018 - Retro DOS v3.0
 26323                                  
 26324                                  ;	TITLE	FCB - FCB parse calls for MSDOS
 26325                                  ;	NAME	FCB
 26326                                  
 26327                                  ;**	FCB.ASM -  Low level routines for parsing names into FCBs and analyzing
 26328                                  ;		   filename characters
 26329                                  ;
 26330                                  ;	MakeFcb
 26331                                  ;	NameTrans
 26332                                  ;	PATHCHRCMP
 26333                                  ;	GetLet
 26334                                  ;	UCase
 26335                                  ;	GetLet3
 26336                                  ;	GetCharType
 26337                                  ;	TESTKANJ
 26338                                  ;	NORMSCAN
 26339                                  ;	DELIM
 26340                                  ;
 26341                                  ;	Revision history:
 26342                                  ;
 26343                                  ;		A000  version 4.00  Jan. 1988
 26344                                  ;	
 26345                                  ;	M048 - access FILE_UCASE_TAB using DS rather than SS.
 26346                                  
 26347                                  TableLook	EQU -1
 26348                                  
 26349                                  SCANSEPARATOR	EQU	1
 26350                                  DRVBIT		EQU	2
 26351                                  NAMBIT		EQU	4
 26352                                  EXTBIT		EQU	8
 26353                                  
 26354                                  ;
 26355                                  ;----------------------------------------------------------------------------
 26356                                  ;
 26357                                  ; Procedure : MakeFcb
 26358                                  ;
 26359                                  ;----------------------------------------------------------------------------
 26360                                  ;
 26361                                  
 26362                                  MAKEFCB:
 26363                                  ;hkn; SS override
 26364 0000580A 36C606[1803]00          	MOV	BYTE [SS:SpaceFlag],0
 26365 00005810 30D2                    	XOR	DL,DL		; Flag--not ambiguous file name
 26366                                  	;test	al,2
 26367 00005812 A802                    	test	AL,DRVBIT	; Use current drive field if default?
 26368 00005814 7504                    	JNZ	short DEFDRV
 26369 00005816 26C60500                	MOV	BYTE [ES:DI],0	; No - use default drive
 26370                                  DEFDRV:
 26371 0000581A 47                      	INC	DI
 26372 0000581B B90800                  	MOV	CX,8
 26373                                  	;test	al,4
 26374 0000581E A804                    	test	AL,NAMBIT	; Use current name fields as default?
 26375 00005820 93                      	XCHG	AX,BX		; Save bits in BX
 26376 00005821 B020                    	MOV	AL," "
 26377 00005823 7404                    	JZ	short FILLB	; If not, go fill with blanks
 26378 00005825 01CF                    	ADD	DI,CX
 26379 00005827 31C9                    	XOR	CX,CX		; Don't fill any
 26380                                  FILLB:
 26381 00005829 F3AA                    	REP	STOSB
 26382 0000582B B103                    	MOV	CL,3
 26383 0000582D F6C308                  	test	BL,EXTBIT	; Use current extension as default
 26384 00005830 7404                    	JZ	short FILLB2
 26385 00005832 01CF                    	ADD	DI,CX
 26386 00005834 31C9                    	XOR	CX,CX
 26387                                  FILLB2:
 26388 00005836 F3AA                    	REP	STOSB
 26389 00005838 91                      	XCHG	AX,CX		; Put zero in AX
 26390 00005839 AB                      	STOSW
 26391 0000583A AB                      	STOSW			; Initialize two words after to zero
 26392 0000583B 83EF10                  	SUB	DI,16		; Point back at start
 26393                                  	;test	bl,1
 26394 0000583E F6C301                  	test	BL,SCANSEPARATOR; Scan off separators if not zero
 26395 00005841 7409                    	JZ	short SKPSPC
 26396 00005843 E87300                  	CALL	SCANB		; Peel off blanks and tabs
 26397 00005846 E8CA00                  	CALL	DELIM		; Is it a one-time-only delimiter?
 26398 00005849 7504                    	JNZ	short NOSCAN
 26399 0000584B 46                      	INC	SI		; Skip over the delimiter
 26400                                  SKPSPC:
 26401 0000584C E86A00                  	CALL	SCANB		; Always kill preceding blanks and tabs
 26402                                  NOSCAN:
 26403 0000584F E89C00                  	CALL	GETLET
 26404 00005852 7616                    	JBE	short NODRV	; Quit if termination character
 26405 00005854 803C3A                  	CMP	BYTE [SI],":"	; Check for potential drive specifier
 26406 00005857 7511                    	JNZ	short NODRV
 26407 00005859 46                      	INC	SI		; Skip over colon
 26408 0000585A 2C40                    	SUB	AL,"@"          ; Convert drive letter to drive number (A=1)
 26409 0000585C 7607                    	JBE	short BADDRV	; Drive letter out of range
 26410                                  
 26411 0000585E 50                      	PUSH	AX
 26412 0000585F E83E14                  	call	GetVisDrv
 26413 00005862 58                      	POP	AX
 26414 00005863 7302                    	JNC	short HAVDRV
 26415                                  
 26416                                  	; MSDOS 6.0
 26417                                  ;hkn; SS override
 26418                                  	;CMP	byte [SS:DrvErr],error_not_DOS_disk
 26419                                  	;				; if not FAT drive ;AN000;
 26420                                  	;JZ	short HAVDRV		; assume ok	   ;AN000;
 26421                                  BADDRV:
 26422 00005865 B2FF                    	MOV	DL,-1
 26423                                  HAVDRV:
 26424 00005867 AA                      	STOSB			; Put drive specifier in first byte
 26425 00005868 46                      	INC	SI
 26426 00005869 4F                      	DEC	DI		; Counteract next two instructions
 26427                                  NODRV:
 26428 0000586A 4E                      	DEC	SI		; Back up
 26429 0000586B 47                      	INC	DI		; Skip drive byte
 26430                                  
 26431                                  	;entry	NORMSCAN
 26432                                  NORMSCAN:
 26433 0000586C B90800                  	MOV	CX,8
 26434 0000586F E81300                  	CALL	GETWORD 	; Get 8-letter file name
 26435 00005872 803C2E                  	CMP	BYTE [SI],"."
 26436 00005875 7507                    	JNZ	short NODOT
 26437 00005877 46                      	INC	SI		; Skip over dot if present
 26438                                  
 26439                                  	; MSDOS 6.0
 26440                                  ;hkn; SS override
 26441                                  	;TEST	word [SS:DOS34_FLAG],DBCS_VOLID2	;AN000;
 26442                                  	;JZ	short VOLOK				;AN000;
 26443                                  	;MOVSB			; 2nd byte of DBCS	;AN000;
 26444                                  	;MOV	CX,2					;AN000;
 26445                                  	;JMP	SHORT contvol				;AN000;
 26446                                  ;VOLOK:
 26447 00005878 B90300                  	MOV	CX,3		; Get 3-letter extension
 26448                                  contvol:
 26449 0000587B E80D00                  	CALL	MUSTGETWORD
 26450                                  NODOT:
 26451 0000587E 88D0                    	MOV	AL,DL
 26452                                  
 26453                                  	; MSDOS 6.0
 26454                                  	;and	word [ss:DOS34_FLAG],~DBCS_VOLID2 ; ### BUG FIX ###
 26455                                  
 26456 00005880 C3                      	retn
 26457                                  
 26458                                  NONAM:
 26459 00005881 01CF                    	ADD	DI,CX
 26460 00005883 4E                      	DEC	SI
 26461 00005884 C3                      	retn
 26462                                  
 26463                                  GETWORD:
 26464 00005885 E86600                  	CALL	GETLET		
 26465 00005888 76F7                    	JBE	short NONAM	; Exit if invalid character
 26466 0000588A 4E                      	DEC	SI
 26467                                  
 26468                                  ;	UGH!!! Horrible bug here that should be fixed at some point:
 26469                                  ;	If the name we are scanning is longer than CX, we keep on reading!
 26470                                  
 26471                                  MUSTGETWORD:
 26472 0000588B E86000                  	CALL	GETLET
 26473                                  
 26474                                  ;	If spaceFlag is set then we allow spaces in a pathname
 26475                                  
 26476                                  ;IF NOT TABLELOOK
 26477 0000588E 7223                    	JB	short FILLNAM
 26478                                  ;ENDIF
 26479 00005890 750C                    	JNZ	short MustCheckCX
 26480                                  
 26481                                  ;hkn; SS override
 26482 00005892 36F606[1803]FF          	test	BYTE [SS:SpaceFlag],0FFh
 26483 00005898 7419                    	JZ	short FILLNAM
 26484 0000589A 3C20                    	CMP	AL," "
 26485 0000589C 7515                    	JNZ	short FILLNAM
 26486                                  
 26487                                  MustCheckCX:
 26488 0000589E E3EB                    	JCXZ	MUSTGETWORD
 26489 000058A0 49                      	DEC	CX
 26490 000058A1 3C2A                    	CMP	AL,"*"          ; Check for ambiguous file specifier
 26491 000058A3 7504                    	JNZ	short NOSTAR
 26492 000058A5 B03F                    	MOV	AL,"?"
 26493 000058A7 F3AA                    	REP	STOSB
 26494                                  NOSTAR:
 26495 000058A9 AA                      	STOSB
 26496 000058AA 3C3F                    	CMP	AL,"?"
 26497 000058AC 75DD                    	JNZ	short MUSTGETWORD
 26498 000058AE 80CA01                  	OR	DL,1		; Flag ambiguous file name
 26499 000058B1 EBD8                    	JMP	short MUSTGETWORD
 26500                                  FILLNAM:
 26501 000058B3 B020                    	MOV	AL," "
 26502 000058B5 F3AA                    	REP	STOSB
 26503 000058B7 4E                      	DEC	SI
 26504 000058B8 C3                      	retn
 26505                                  
 26506                                  SCANB:
 26507 000058B9 AC                      	LODSB
 26508 000058BA E86200                  	CALL	SPCHK
 26509 000058BD 74FA                    	JZ	short SCANB
 26510 000058BF 4E                      	DEC	SI
 26511                                  scanb_retn:
 26512 000058C0 C3                      	retn
 26513                                  
 26514                                  ;----------------------------------------------------------------------------
 26515                                  ;
 26516                                  ; Procedure Name : NameTrans
 26517                                  ;
 26518                                  ; NameTrans is used by FindPath to scan off an element of a path. We must
 26519                                  ; allow spaces in pathnames
 26520                                  ;
 26521                                  ;   Inputs:	DS:SI points to start of path element
 26522                                  ;   Outputs:	Name1 has unpacked name, uppercased
 26523                                  ;		ES = DOSGroup
 26524                                  ;		DS:SI advanced after name
 26525                                  ;   Registers modified: DI,AX,DX,CX
 26526                                  ;
 26527                                  ;----------------------------------------------------------------------------
 26528                                  
 26529                                  NameTrans:
 26530                                  ;hkn; SS override
 26531 000058C1 36C606[1803]01          	MOV	BYTE [SS:SpaceFlag],1
 26532 000058C7 16                      	push	ss
 26533 000058C8 07                      	pop	es
 26534                                  
 26535                                  ;hkn; NAME1 is in DOSDATA
 26536 000058C9 BF[0805]                	MOV	DI,NAME1
 26537 000058CC 57                      	PUSH	DI
 26538 000058CD B82020                  	MOV	AX,'  '
 26539 000058D0 B90500                  	MOV	CX,5
 26540 000058D3 AA                      	STOSB
 26541 000058D4 F3AB                    	REP	STOSW		; Fill "FCB" at NAME1 with spaces
 26542 000058D6 30C0                    	XOR	AL,AL		; Set stuff for NORMSCAN
 26543 000058D8 88C2                    	MOV	DL,AL
 26544 000058DA AA                      	STOSB
 26545 000058DB 5F                      	POP	DI
 26546                                  
 26547 000058DC E88DFF                  	CALL	NORMSCAN
 26548                                  
 26549                                  ;hkn; SS override for NAME1
 26550 000058DF 36803E[0805]E5          	CMP	byte [SS:NAME1],0E5H
 26551 000058E5 75D9                    	jnz	short scanb_retn
 26552 000058E7 36C606[0805]05          	MOV	byte [SS:NAME1],5 ; Magic name translation
 26553 000058ED C3                      	retn
 26554                                  
 26555                                  ;Break	<GETLET, DELIM -- CHECK CHARACTERS AND CONVERT>
 26556                                  
 26557                                  ;----------------------------------------------------------------------------
 26558                                  ;
 26559                                  ; Procedure Names : GetLet, UCase, GetLet3
 26560                                  ;
 26561                                  ; These routines take a character, convert it to upper case, and check
 26562                                  ; for delimiters.  Three different entry points:
 26563                                  ;	GetLet -  DS:[SI] = character to convert
 26564                                  ;	UCase  -  AL = character to convert
 26565                                  ;	GetLet3 - AL = character
 26566                                  ;		  [BX] = translation table to use
 26567                                  ;
 26568                                  ;	Exit (in all cases) : AL = upper case character
 26569                                  ;			      CY set if char is control char other than TAB
 26570                                  ;			      ZF set if char is a delimiter
 26571                                  ;	Uses : AX, flags
 26572                                  ;
 26573                                  ; NOTE: This routine exists in a fast table lookup version, and a slow
 26574                                  ; inline version.  Return with carry set is only possible in the inline
 26575                                  ; version.  The table lookup version is the one in use.
 26576                                  ;
 26577                                  ;----------------------------------------------------------------------------
 26578                                  
 26579                                  
 26580                                  ; This entry point has character at [SI]
 26581                                  
 26582                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5517h
 26583                                  GETLET:	
 26584 000058EE AC                      	LODSB
 26585                                  
 26586                                  ; This entry point has character in AL
 26587                                  
 26588                                  	;entry	UCase
 26589                                  UCase:	
 26590                                  	; 09/08/2018
 26591                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5518h
 26592                                  _UCase:
 26593 000058EF 53                      	PUSH	BX
 26594 000058F0 BB[4811]                	MOV	BX,FILE_UCASE_TAB+2
 26595                                  
 26596                                  ; Convert the character in AL to upper case
 26597                                  
 26598                                  gl_0:
 26599 000058F3 3C61                    	CMP	AL,"a"
 26600 000058F5 720E                    	JB	short gl_2	; Already upper case, go check type
 26601 000058F7 3C7A                    	CMP	AL,"z"
 26602 000058F9 7702                    	JA	short gl_1
 26603 000058FB 2C20                    	SUB	AL,20H		; Convert to upper case
 26604                                  
 26605                                  ; Map European character to upper case
 26606                                  
 26607                                  gl_1:
 26608 000058FD 3C80                    	CMP	AL,80H
 26609 000058FF 7204                    	JB	short gl_2	; Not EuroChar, go check type
 26610 00005901 2C80                    	SUB	AL,80H		; translate to upper case with this index
 26611                                  
 26612                                  	; M048 - Start 
 26613                                  	; Lantastic call Ucase thru int 2f without setting SS to DOSDATA.
 26614                                  	; So we shall set up DS and to access FILE_UCASE_TAB in BX and also 
 26615                                  	; preserve it.
 26616                                  	;
 26617                                  
 26618                                  	;push	ds
 26619                                  	;push	cs
 26620                                  	;pop	ds
 26621                                  
 26622                                  	; 09/08/2018
 26623                                  	;XLAT	BYTE [CS:BX]	; ds as file_ucase_tab is in DOSDATA
 26624 00005903 2ED7                    	CS	XLAT
 26625                                  
 26626                                  	;pop	ds
 26627                                  
 26628                                  	; M048 - End
 26629                                  
 26630                                  ; Now check the type
 26631                                  
 26632                                  ;If TableLook
 26633                                  
 26634                                  gl_2:
 26635 00005905 50                      	PUSH	AX
 26636                                  	
 26637                                  	; MSDOS 6.0
 26638                                  	;CALL	GetCharType	; returns type flags in AL
 26639                                  	
 26640                                  	; MSDOS 3.3
 26641 00005906 BB[5413]                	mov	bx,CharType
 26642                                  	; 09/08/2018
 26643                                  	;xlat	byte [cs:bx]
 26644 00005909 2ED7                    	cs	xlat	
 26645                                  
 26646                                  	;test	al,1	
 26647 0000590B A801                    	TEST	AL,FCHK 	; test for normal character
 26648 0000590D 58                      	POP	AX
 26649 0000590E 5B                      	POP	BX
 26650 0000590F C3                      	RETN
 26651                                  
 26652                                  ; This entry has character in AL and lookup table in BX
 26653                                  
 26654                                  	; MSDOS 6.0
 26655                                  ;	;entry GetLet3
 26656                                  GETLET3: ; 10/08/2018
 26657 00005910 53                      	PUSH	BX
 26658 00005911 EBE0                    	JMP	short gl_0
 26659                                  
 26660                                  ;ELSE
 26661                                  ;
 26662                                  ;gl_2:
 26663                                  ;	POP	BX
 26664                                  ;	CMP	AL,"."
 26665                                  ;	retz
 26666                                  ;	CMP	AL,'"'
 26667                                  ;	retz
 26668                                  ;	CALL	PATHCHRCMP
 26669                                  ;	retz
 26670                                  ;	CMP	AL,"["
 26671                                  ;	retz
 26672                                  ;	CMP	AL,"]"
 26673                                  ;	retz
 26674                                  ;ENDIF
 26675                                  
 26676                                  ;---------------------------------------------------------------------
 26677                                  ;
 26678                                  ; DELIM - check if character is a delimiter
 26679                                  ;	Entry : AX = character to check
 26680                                  ;	Exit  : ZF set if character is not a delimiter
 26681                                  ;	Uses  : Flags
 26682                                  ;
 26683                                  ;--------------------------------------------------------------------
 26684                                  
 26685                                  	;entry	DELIM
 26686                                  DELIM:
 26687                                  ;IF TableLook
 26688 00005913 50                      	PUSH	AX
 26689                                  
 26690                                  	; MSDOS 6.0
 26691                                  	;CALL	GetCharType
 26692                                  	
 26693                                  	; MSDOS 3.3
 26694 00005914 53                      	push	bx
 26695 00005915 BB[5413]                	mov	bx,CharType
 26696                                  	;09/08/2018
 26697                                  	;xlat	byte [cs:bx]
 26698 00005918 2ED7                    	cs	xlat
 26699 0000591A 5B                      	pop	bx
 26700                                  
 26701                                  	;test	al,2
 26702 0000591B A802                    	TEST	AL,FDELIM
 26703 0000591D 58                      	POP	AX
 26704 0000591E C3                      	RETN
 26705                                  ;ELSE
 26706                                  ;	CMP	AL,":"
 26707                                  ;	retz
 26708                                  ;
 26709                                  ;	CMP	AL,"<"
 26710                                  ;	retz
 26711                                  ;	CMP	AL,"|"
 26712                                  ;	retz
 26713                                  ;	CMP	AL,">"
 26714                                  ;	retz
 26715                                  ;
 26716                                  ;	CMP	AL,"+"
 26717                                  ;	retz
 26718                                  ;	CMP	AL,"="
 26719                                  ;	retz
 26720                                  ;	CMP	AL,";"
 26721                                  ;	retz
 26722                                  ;	CMP	AL,","
 26723                                  ;	retz
 26724                                  ;ENDIF
 26725                                  
 26726                                  ;-------------------------------------------------------------------------
 26727                                  ;
 26728                                  ;  SPCHK - checks to see if a character is a space or equivalent
 26729                                  ;	Entry : AL = character to check
 26730                                  ;	Exit  : ZF set if character is a space
 26731                                  ;	Uses  : flags
 26732                                  ;
 26733                                  ;-------------------------------------------------------------------------
 26734                                  
 26735                                  	;entry SPCHK
 26736                                  SPCHK:
 26737                                  ;IF TableLook
 26738 0000591F 50                      	PUSH	AX
 26739                                  
 26740                                  	; MSDOS 6.0
 26741                                  	;CALL	GetCharType
 26742                                  	
 26743                                  	; MSDOS 3.3
 26744 00005920 53                      	push	bx
 26745 00005921 BB[5413]                	mov	bx,CharType
 26746                                  	; 09/08/2018
 26747                                  	;xlat	byte [cs:bx]
 26748 00005924 2ED7                    	cs	xlat
 26749 00005926 5B                      	pop	bx
 26750                                  
 26751                                  	;test	al,4
 26752 00005927 A804                    	TEST	AL,FSPCHK
 26753 00005929 58                      	POP	AX
 26754 0000592A C3                      	RETN
 26755                                  ;ELSE
 26756                                  ;	CMP	AL,9		; Filter out tabs too
 26757                                  ;	retz
 26758                                  ;; WARNING! " " MUST be the last compare
 26759                                  ;	CMP	AL," "
 26760                                  ;	return
 26761                                  ;ENDIF
 26762                                  
 26763                                  ; MSDOS 6.0
 26764                                  ;-------------------------------------------------------------------------
 26765                                  ;
 26766                                  ;  GetCharType - return flag bits indicating character type
 26767                                  ;	Bits are defined in DOSSYM.INC. Uses lookup table
 26768                                  ;	defined above at label CharType.
 26769                                  ;
 26770                                  ;	Entry : AL = character to return type flags for
 26771                                  ;	Exit  : AL = type flags
 26772                                  ;	Uses  : AL, flags
 26773                                  ;
 26774                                  ;-------------------------------------------------------------------------
 26775                                  ;
 26776                                  ;GetCharType:
 26777                                  ;	cmp	al,CharType_last	; beyond end of table?
 26778                                  ;	jae	short gct_90		; return standard value
 26779                                  ;
 26780                                  ;	push	bx
 26781                                  ;	mov	bx,CharType		; load lookup table
 26782                                  ;	shr	al,1			; adjust for half-byte table entry size
 26783                                  ;	;xlat	cs:[bx] 		; get flags
 26784                                  ;	cs	xlat	
 26785                                  ;	pop	bx
 26786                                  ;
 26787                                  ; carry clear from previous shift means we want the low nibble.  Otherwise
 26788                                  ; we have to shift the flags down to the low nibble
 26789                                  ;
 26790                                  ;	jnc	short gct_80		; carry clear, no shift needed
 26791                                  ;
 26792                                  ;	shr	al,1			; we want high nibble, shift it down
 26793                                  ;	shr	al,1
 26794                                  ;	shr	al,1
 26795                                  ;	shr	al,1
 26796                                  ;
 26797                                  ;gct_80:
 26798                                  ;	and	al,0Fh			; clear the unused nibble
 26799                                  ;	retn
 26800                                  ;
 26801                                  ;gct_90:
 26802                                  ;	mov	al,0Fh			; set all flags
 26803                                  ;	retn
 26804                                  
 26805                                  ;----------------------------------------------------------------------------
 26806                                  ;
 26807                                  ; Procedure : PATHCHRCMP
 26808                                  ;
 26809                                  ;----------------------------------------------------------------------------
 26810                                  
 26811                                  PATHCHRCMP:
 26812 0000592B 3C2F                    	CMP	AL,'/'
 26813 0000592D 7606                    	JBE	short PathRet
 26814 0000592F 3C5C                    	CMP	AL,'\'
 26815 00005931 C3                      	retn
 26816                                  GotFor:
 26817 00005932 B05C                    	MOV	AL,'\'
 26818 00005934 C3                      	retn
 26819                                  PathRet:
 26820 00005935 74FB                    	JZ	short GotFor
 26821 00005937 C3                      	retn
 26822                                  
 26823                                  ;============================================================================
 26824                                  ; MSCRTLC.ASM, MSDOS 6.0, 1991
 26825                                  ;============================================================================
 26826                                  ; 30/07/2018 - Retro DOS v3.0
 26827                                  
 26828                                  ; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11, CTRLC.ASM, 1983)
 26829                                  
 26830                                  ;**	MSCTRLC.ASM - ^C and error handler for MSDOS
 26831                                  
 26832                                  ;	TITLE	Control C detection, Hard error and EXIT routines
 26833                                  ;	NAME	IBMCTRLC
 26834                                  
 26835                                  ;**	Low level routines for detecting special characters on CON input,
 26836                                  ;	the ^C exit/int code, the Hard error INT 24 code, the
 26837                                  ;	process termination code, and the INT 0 divide overflow handler.
 26838                                  ;
 26839                                  ;	FATAL
 26840                                  ;	FATAL1
 26841                                  ;	reset_environment
 26842                                  ;	DSKSTATCHK
 26843                                  ;	SPOOLINT
 26844                                  ;	STATCHK
 26845                                  ;	CNTCHAND
 26846                                  ;	DIVOV
 26847                                  ;	CHARHARD
 26848                                  ;	HardErr
 26849                                  ;
 26850                                  ;	Revision history:
 26851                                  ;
 26852                                  ;	    AN000	version 4.0   Jan 1988
 26853                                  ;	    A002	PTM    -- dir >lpt3 hangs
 26854                                  ;	    A003	PTM 3957- fake version for IBMCAHE.COM
 26855                                  ;
 26856                                  ; 	M011: NEC's 8086 clone chip uses Intel's undocumented bit number in
 26857                                  ;	      flags register. In order to return to user normally DOS used to
 26858                                  ;	      move F202 into flags, which sets bit number 1 in flags uncondit-
 26859                                  ;	      ionally. Now it is modified to maintain the state of bit 1.
 26860                                  ;
 26861                                  ; 	M024: suppressed fail and ignore options if not in the middle of int 
 26862                                  ;	      24 and if Ctrl P or ctrl printscrn is pressed in routine 
 26863                                  ;	      charhard.
 26864                                  
 26865                                  
 26866                                  	; MSDOS 6.0
 26867                                  ;		public	LowInt23Addr		
 26868                                  ;LowInt23Addr	LABEL	DWORD
 26869                                  ;	DW	offset DOSDATA:LowInt23, 0
 26870                                  ;
 26871                                  ;		public	LowInt24Addr
 26872                                  ;LowInt24Addr	LABEL	DWORD
 26873                                  ;	DW	offset DOSDATA:LowInt24, 0
 26874                                  ;
 26875                                  ;		public	LowInt28Addr
 26876                                  ;LowInt28Addr	LABEL	DWORD
 26877                                  ;	DW	offset DOSDATA:LowInt28, 0
 26878                                  
 26879                                  ;Break	<Checks for ^C in CON I/O>
 26880                                  
 26881                                  ;---------------------------------------------------------------------------
 26882                                  ;
 26883                                  ; Procedure Name : DSKSTATCHK
 26884                                  ;
 26885                                  ; Check for ^C if only one level in
 26886                                  ;
 26887                                  ;---------------------------------------------------------------------------
 26888                                  
 26889                                          ;procedure   DSKSTATCHK,NEAR ; Check for ^C if only one level in
 26890                                  
 26891                                  DSKSTATCHK:        
 26892                                  	;CMP	BYTE [INDOS],1
 26893 00005938 36803E[ED02]01                  CMP     BYTE [SS:INDOS],1 ; 15/03/2018
 26894                                  	;retnz			; Do NOTHING
 26895 0000593E 7534                    	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         
 26896                                  
 26897 00005940 51                      	PUSH    CX
 26898 00005941 06                              PUSH    ES
 26899 00005942 53                              PUSH    BX
 26900 00005943 1E                              PUSH    DS
 26901 00005944 56                              PUSH    SI
 26902                                          
 26903                                  	;PUSH	CS
 26904                                          ;POP	ES
 26905                                          ;PUSH	CS
 26906                                          ;POP	DS
 26907                                  
 26908 00005945 8CD3                    	MOV	BX, SS		; SS is DOSDATA. ES:BX must be set up
 26909 00005947 8EC3                    	MOV	ES, BX		; for deviocall2
 26910 00005949 8EDB                    	MOV	DS, BX
 26911                                  
 26912                                  	; 09/09/2018
 26913 0000594B C606[5E03]05                    MOV     BYTE [DSKSTCOM],DEVRDND
 26914 00005950 C606[5C03]0E                    MOV     BYTE [DSKSTCALL],DRDNDHL
 26915 00005955 C706[5F03]0000          	mov	word [DSKSTST],0
 26916                                  
 26917 0000595B BB[5C03]                        MOV     BX,DSKSTCALL
 26918 0000595E C536[3200]                      LDS     SI,[BCON]
 26919 00005962 E8CDF7                          CALL	DEVIOCALL2
 26920                                   	; 15/03/2018
 26921                                  	;test	word [ss:DSKSTST],200h
 26922                                          ;TEST	WORD [SS:DSKSTST],STBUI
 26923                                  	; 28/07/2019
 26924 00005965 36F606[6003]02          	test	byte [ss:DSKSTST+1],(STBUI>>8) ; 2
 26925                                  	;JNZ	SHORT ZRET		; No characters available
 26926                                  	; 30/07/2018
 26927 0000596B 7408                    	jz	short _GotCh
 26928                                  ;ZRET:
 26929 0000596D 30C0                            XOR     AL,AL                   ; Set zero
 26930                                  RET36:
 26931 0000596F 5E                              POP     SI
 26932 00005970 1F                              POP     DS
 26933 00005971 5B                              POP     BX
 26934 00005972 07                              POP     ES
 26935 00005973 59                              POP     CX
 26936                                  _RET37:
 26937 00005974 C3                              RETN
 26938                                  
 26939                                  _GotCh:
 26940 00005975 36A0[6903]                      MOV     AL,[SS:DSKCHRET]	; SS override
 26941                                  
 26942 00005979 3C03                            CMP     AL,"C"-"@" ; cmp al,3
 26943 0000597B 75F2                            JNZ     SHORT RET36
 26944 0000597D 36C606[5E03]04                  MOV     BYTE [SS:DSKSTCOM],DEVRD
 26945 00005983 36C606[5C03]16                  MOV     BYTE [SS:DSKSTCALL],DRDWRHL
 26946 00005989 36880E[6903]                    MOV     [SS:DSKCHRET],CL
 26947                                  	; 09/09/2018
 26948 0000598E 36C706[5F03]0000        	MOV	word [SS:DSKSTST],0
 26949 00005995 36C706[6E03]0100        	MOV	word [SS:DSKSTCNT],1
 26950 0000599C E893F7                  	CALL	DEVIOCALL2              ; Eat the ^C
 26951 0000599F 5E                              POP     SI
 26952 000059A0 1F                              POP     DS
 26953 000059A1 5B                              POP     BX                      ; Clean stack
 26954 000059A2 07                              POP     ES
 26955 000059A3 59                              POP     CX
 26956 000059A4 E9BF00                          JMP	CNTCHAND ; 10/08/2018
 26957                                  
 26958                                  NOSTOP:
 26959                                  	; MSDOS 6.0
 26960                                  	;CMP	AL,"P"-"@"
 26961                                  	;JNZ	short check_next
 26962                                  				    	; SS override
 26963                                  	;CMP	BYTE [SS:Scan_Flag],0	; ALT_Q ?
 26964                                  	;JZ	short INCHKJ		; no
 26965                                  	;retn
 26966                                  ;check_next:
 26967                                  	;;IF	NOT TOGLPRN
 26968                                  	;CMP	AL,"N"-"@"
 26969                                  	;JZ	short INCHKJ
 26970                                  	;;ENDIF
 26971                                  
 26972                                  	;CMP	AL,"C"-"@"
 26973                                  	;JZ	short INCHKJ
 26974                                  ;check_end:
 26975                                  	;retn
 26976                                  
 26977                                  	; MSDOS 3.3
 26978 000059A7 3C10                            CMP     AL,"P"-"@"  ; cmp al,16	
 26979 000059A9 7405                            JZ	short INCHKJ
 26980                                  
 26981                                  	; 15/04/2018
 26982                                          ;;IF	NOT TOGLPRN
 26983                                          ;CMP	AL,"N"-"@"
 26984                                          ;JZ	SHORT INCHKJ
 26985                                          ;;ENDIF
 26986                                  
 26987 000059AB 3C03                            CMP     AL,"C"-"@"  ; cmp al,3	
 26988 000059AD 7401                            JZ	short INCHKJ
 26989 000059AF C3                      	RETN
 26990                                  
 26991                                  	; 08/09/2018
 26992                                  INCHKJ:	; 10/08/2018
 26993 000059B0 E98F00                  	JMP	INCHK
 26994                                  
 26995                                  ;----------------------------------------------------------------------------
 26996                                  ;
 26997                                  ; Procedure Name : SpoolInt
 26998                                  ;
 26999                                  ; SpoolInt - signal processes that the DOS is truly idle.  We are allowed to
 27000                                  ; do this ONLY if we are working on a 1-12 system call AND if we are not in
 27001                                  ; the middle of an INT 24.
 27002                                  ;
 27003                                  ;----------------------------------------------------------------------------
 27004                                  
 27005                                  SPOOLINT:
 27006 000059B3 9C                              PUSHF
 27007                                  	; 15/03/2018
 27008 000059B4 36803E[2203]00                  CMP     BYTE [SS:IDLEINT],0	; SS override
 27009 000059BA 7414                            JZ      SHORT POPFRET
 27010 000059BC 36803E[EC02]00                  CMP     BYTE [SS:ERRORMODE],0
 27011 000059C2 750C                            JNZ     SHORT POPFRET		;No spool ints in error mode
 27012                                  
 27013                                  	; 30/07/2018
 27014                                  
 27015                                  	; Note that we are going to allow an external program to issue system 
 27016                                  	; calls at this time.  We MUST preserve IdleInt across this.
 27017                                  
 27018                                  
 27019 000059C4 36FF36[2203]            	PUSH	WORD [SS:IDLEINT]
 27020                                   
 27021                                  	; MSDOS 6.0
 27022                                  	;cmp	byte [SS:DosHasHMA],0	; Q: is dos running in HMA (M021)
 27023                                  	;jne	short do_low_int28	; Y: the int must be done from low mem
 27024                                  	;INT	int_spooler		; N: Execute user int 28 handler
 27025                                  	;jmp	short spool_ret_addr
 27026                                  
 27027                                  ;do_low_int28:
 27028                                  	;call	far [SS:LowInt28Addr]
 27029                                  
 27030                                  ;spool_ret_addr:
 27031                                  
 27032 000059C9 CD28                            INT     int_spooler		; INT 28h
 27033                                  
 27034 000059CB 368F06[2203]            	POP	WORD [SS:IDLEINT]
 27035                                  
 27036                                  POPFRET:
 27037 000059D0 9D                              POPF
 27038                                  _RET18:  
 27039 000059D1 C3                      	RETN
 27040                                  
 27041                                  ;----------------------------------------------------------------------------
 27042                                  ;
 27043                                  ; Procedure Name : STATCHK
 27044                                  ;
 27045                                  ;----------------------------------------------------------------------------
 27046                                  
 27047                                  STATCHK:
 27048 000059D2 E863FF                          CALL	DSKSTATCHK              ; Allows ^C to be detected under
 27049                                                                          ; input redirection
 27050 000059D5 53                              PUSH    BX
 27051 000059D6 31DB                            XOR     BX,BX
 27052 000059D8 E8BBE7                          CALL	GET_IO_SFT
 27053 000059DB 5B                              POP     BX
 27054 000059DC 72F3                            JC      SHORT _RET18
 27055 000059DE B401                            MOV     AH,1
 27056 000059E0 E8A2F5                          CALL	IOFUNC
 27057 000059E3 74CE                            JZ      SHORT SPOOLINT
 27058 000059E5 3C13                            CMP     AL,'S'-'@'
 27059 000059E7 75BE                            JNZ     SHORT NOSTOP
 27060                                  
 27061                                  	; MSDOS 6.0			; SS override
 27062                                  	;CMP	BYTE [SS:Scan_Flag],0	; AN000; ALT_R ?
 27063                                  	;JNZ	short check_end		; AN000; yes
 27064                                  
 27065 000059E9 30E4                            XOR     AH,AH
 27066 000059EB E897F5                          CALL	IOFUNC                  ; Eat Cntrl-S
 27067 000059EE EB4B                            JMP     SHORT PAUSOSTRT
 27068                                  
 27069                                  PRINTOFF:
 27070                                  PRINTON:
 27071 000059F0 36F616[CA02]            	NOT	BYTE [SS:PFLAG] ; 14/03/2018
 27072                                  
 27073                                  	; 30/07/2018 - Retro DOS v3.0
 27074 000059F5 53                      	PUSH	BX
 27075 000059F6 BB0400                  	MOV	BX,4
 27076 000059F9 E89AE7                  	call	GET_IO_SFT
 27077 000059FC 5B                      	POP	BX
 27078 000059FD 72D2                    	jc	short _RET18
 27079 000059FF 06                      	PUSH	ES
 27080 00005A00 57                      	PUSH	DI
 27081 00005A01 1E                      	PUSH	DS
 27082 00005A02 07                      	POP	ES
 27083 00005A03 89F7                    	MOV	DI,SI			; ES:DI -> SFT
 27084                                  	;test	word [es:di+5],800h
 27085 00005A05 26F745050008            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_net_spool
 27086 00005A0B 7418                    	JZ	short NORM_PR 		; Not redirected, echo is OK
 27087                                  
 27088                                  	;Callinstall NetSpoolEchoCheck,MultNet,38,<AX>,<AX> 
 27089                                  					; See if allowed
 27090 00005A0D 50                      	push	ax
 27091 00005A0E B82611                  	mov	ax, 1126h
 27092 00005A11 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 27093                                  			; Return: CF set on error, AX = error code
 27094                                  			; STACK unchanged
 27095 00005A13 58                      	pop	ax
 27096                                  
 27097 00005A14 730F                    	JNC	short NORM_PR 		; Echo is OK
 27098                                  
 27099                                  					; SS override
 27100 00005A16 36C606[CA02]00          	MOV	BYTE [SS:PFLAG],0	; If not allowed, disable echo
 27101                                  
 27102                                  	;Callinstall NetSpoolClose,MultNet,36,<AX>,<AX> ; and close
 27103                                  
 27104 00005A1C 50                      	push    ax
 27105 00005A1D B82411                  	mov     ax,1124h
 27106 00005A20 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - ???
 27107                                  			; ES:DI -> SFT, SS = DOS CS
 27108 00005A22 58                      	pop     ax
 27109                                  
 27110 00005A23 EB10                    	JMP	SHORT RETP6
 27111                                  
 27112                                  NORM_PR:
 27113 00005A25 36803E[CA02]00          	CMP	BYTE [SS:PFLAG],0	; SS override
 27114 00005A2B 7505                    	JNZ	short PRNOPN
 27115 00005A2D E884F6                  	call	DEV_CLOSE_SFT
 27116 00005A30 EB03                    	JMP	SHORT RETP6
 27117                                  
 27118                                  PRNOPN:
 27119 00005A32 E878F6                  	call	DEV_OPEN_SFT
 27120                                  RETP6:
 27121 00005A35 5F                      	POP	DI
 27122 00005A36 07                      	POP	ES
 27123                                  
 27124                                  STATCHK_RETN:
 27125 00005A37 C3                              RETN
 27126                                  
 27127                                  PAUSOLP:
 27128 00005A38 E878FF                          CALL    SPOOLINT
 27129                                  PAUSOSTRT:
 27130 00005A3B B401                            MOV     AH,1
 27131 00005A3D E845F5                          CALL	IOFUNC
 27132 00005A40 74F6                            JZ      SHORT PAUSOLP
 27133                                  INCHK:
 27134 00005A42 53                              PUSH    BX
 27135 00005A43 31DB                            XOR     BX,BX
 27136 00005A45 E84EE7                          CALL	GET_IO_SFT
 27137 00005A48 5B                              POP     BX
 27138 00005A49 72EC                            JC      SHORT STATCHK_RETN ; 30/07/2018
 27139 00005A4B 30E4                            XOR     AH,AH
 27140 00005A4D E835F5                          CALL	IOFUNC
 27141                                  	; 30/07/2018
 27142                                  	; MSDOS 3.3
 27143 00005A50 3C10                            CMP     AL,'P'-'@' ;cmp al,16
 27144 00005A52 750E                            JNZ	SHORT NOPRINT
 27145                                  
 27146 00005A54 36803E[C10F]00          	cmp	byte [SS:SCAN_FLAG],0
 27147 00005A5A 7494                    	JZ	SHORT PRINTON	
 27148 00005A5C 36C606[C10F]00          	mov	byte [ss:SCAN_FLAG],0
 27149                                  
 27150                                  	; MSDOS 6.0
 27151                                  	;CMP	AL,"P"-"@"
 27152                                  	;;;;;  7/14/86	ALT_Q key fix
 27153                                  	;JZ	short PRINTON		; no! must be CTRL_P
 27154                                  
 27155                                  NOPRINT:	
 27156                                  	;IF	NOT TOGLPRN
 27157                                  	;CMP	AL,"N"-"@"
 27158                                  	;JZ	short PRINTOFF
 27159                                  	;ENDIF
 27160 00005A62 3C03                    	CMP	AL,"C"-"@" ; cmp al,3 
 27161                                  	;retnz
 27162 00005A64 75D1                    	jnz	short STATCHK_RETN
 27163                                  
 27164                                  ;	!! NOTE: FALL THROUGH !!
 27165                                  
 27166                                  ;---------------------------------------------------------------------------
 27167                                  ;
 27168                                  ; Procedure Name : CNTHAND ( CTRLC_C HANDLER )
 27169                                  ;
 27170                                  ; "^C" and CR/LF is printed.  Then the user registers are restored and the
 27171                                  ; user CTRL-C handler is executed.  At this point the top of the stack has 1)
 27172                                  ; the interrupt return address should the user CTRL-C handler wish to allow
 27173                                  ; processing to continue; 2) the original interrupt return address to the code
 27174                                  ; that performed the function call in the first place.	If the user CTRL-C
 27175                                  ; handler wishes to continue, it must leave all registers unchanged and RET
 27176                                  ; (not IRET) with carry CLEAR.	If carry is SET then an terminate system call
 27177                                  ; is simulated.
 27178                                  ;
 27179                                  ;---------------------------------------------------------------------------
 27180                                  
 27181                                  CNTCHAND:
 27182                                  	; MSDOS 6.0			; SS override
 27183                                  					; AN002; from RAWOUT
 27184                                  	;TEST	word [SS:Dos34_Flag],CTRL_BREAK_FLAG  
 27185                                  	;JNZ	short around_deadlock 	; AN002;
 27186                                  
 27187 00005A66 B003                            MOV     AL,3			; Display "^C"
 27188 00005A68 E842CA                          CALL	BUFOUT
 27189 00005A6B E8E2C8                          CALL	CRLF
 27190                                  ;around_deadlock:
 27191 00005A6E 16                              PUSH    SS
 27192 00005A6F 1F                              POP     DS
 27193 00005A70 803E[2103]00                    CMP     BYTE [CONSWAP],0
 27194 00005A75 7403                            JZ      SHORT NOSWAP
 27195 00005A77 E835E4                          CALL	SWAPBACK
 27196                                  NOSWAP:
 27197 00005A7A FA                      	CLI				; Prepare to play with stack
 27198 00005A7B 8E16[4205]              	MOV	SS,[USER_SS]		; User stack now restored
 27199 00005A7F 8B26[4005]              	MOV	SP,[USER_SP]
 27200 00005A83 E89DBB                          CALL	restore_world       ; User registers now restored
 27201                                  
 27202                                  	; 30/07/2018 - Retro DOS v3.0 
 27203                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56ACh)
 27204                                          ; 14/03/2018 - Retro DOS v2.0
 27205 00005A86 2EC606[ED02]00          	MOV     BYTE [CS:INDOS],0	
 27206 00005A8C 2EC606[EC02]00                  MOV     BYTE [CS:ERRORMODE],0
 27207 00005A92 2E8926[FE02]                    MOV     [CS:ConC_Spsave],SP
 27208 00005A97 F8                      	clc	;30/07/2018
 27209 00005A98 CD23                            INT     int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
 27210                                  	;int	23h	; DOS - CONTROL "C" EXIT ADDRESS
 27211                                  			; Return: return via RETF 2 with CF set
 27212                                  			; DOS will abort program with errorlevel 0
 27213                                  			; else
 27214                                  			; interrupted DOS call continues
 27215                                  
 27216                                  	; 30/07/2018 
 27217                                  
 27218                                  	; MSDOS 3.3 (IBMDOS.COM - Offset 56C0h)
 27219                                  
 27220                                  ; The user has returned to us.	The circumstances we allow are:
 27221                                  ;
 27222                                  ;   IRET	We retry the operation by redispatching the system call
 27223                                  ;   CLC/RETF	POP the stack and retry
 27224                                  ;   ... 	Exit the current process with ^C exit
 27225                                  ;
 27226                                  ; User's may RETURN to us and leave interrupts on. 
 27227                                  ; Turn 'em off just to be sure
 27228                                  
 27229 00005A9A FA                      	CLI
 27230                                  
 27231 00005A9B 2EA3[0403]              	MOV	[CS:USER_IN_AX],ax	; save the AX
 27232 00005A9F 9C                      	PUSHF				; and the flags (maybe new call)
 27233 00005AA0 58                      	POP	AX
 27234                                  
 27235                                  ; See if the input stack is identical to the output stack
 27236                                  
 27237 00005AA1 2E3B26[FE02]                    CMP	SP,[CS:ConC_Spsave]
 27238 00005AA6 7507                    	JNZ     SHORT ctrlc_try_new ; current SP not the same as saved SP
 27239                                  
 27240                                  ; Repeat the operation by redispatching the system call.
 27241                                  
 27242                                  ctrlc_repeat:
 27243 00005AA8 2EA1[0403]                      MOV     AX,[CS:USER_IN_AX]
 27244                                  	;transfer COMMAND           ; Repeat command otherwise
 27245                                  COMMANDJ:
 27246 00005AAC E939BA                  	JMP	COMMAND
 27247                                  
 27248                                  ; The current SP is NOT the same as the input SP. Presume that he 
 27249                                  ; RETF'd leaving some flags on the stack and examine the input
 27250                                  
 27251                                  ctrlc_try_new:
 27252 00005AAF 83C402                  	ADD	SP,2			; pop those flags
 27253                                  	;test	ax,1
 27254 00005AB2 A90100                  	TEST	AX,f_Carry		; did he return with carry?
 27255 00005AB5 74F1                    	JZ	short ctrlc_repeat	; no carry set, just retry
 27256                                  
 27257                                  	; Well...  time to abort the user.  
 27258                                  	; Signal a ^C exit and use the EXIT system call..
 27259                                  
 27260                                  ctrlc_abort:
 27261                                          ;MOV	AX,(EXIT SHL 8) + 0
 27262 00005AB7 B8004C                          MOV	AX, (EXIT*256) + 0  ; 4C00h
 27263 00005ABA 2EC606[1703]FF          	mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
 27264                                          ;transfer COMMAND	    ; give up by faking $EXIT
 27265                                  	;JMP	SHORT COMMANDJ
 27266 00005AC0 E925BA                  	JMP	COMMAND
 27267                                  
 27268                                  ;Break	<DIVISION OVERFLOW INTERRUPT>
 27269                                  ;----------------------------------------------------------------------------
 27270                                  ;
 27271                                  ; Procedure Name : DIVOV
 27272                                  ;
 27273                                  ; Default handler for division overflow trap
 27274                                  ;
 27275                                  ;----------------------------------------------------------------------------
 27276                                  
 27277                                  DIVOV: 
 27278                                  	; 30/07/2018
 27279                                  	; 07/07/2018 - Retro DOS v3.0
 27280 00005AC3 BE[FA12]                	mov	si,DIVMES
 27281 00005AC6 2E8B1E[0D13]            	mov	bx,[cs:DivMesLen]
 27282 00005ACB 8CC8                    	mov     ax,cs
 27283 00005ACD 8ED0                    	mov	ss,ax
 27284 00005ACF BC[3607]                	mov     sp,AUXSTACK
 27285 00005AD2 E80200                  	call	RealDivOv
 27286                                  	;call	_outmes ; MSDOS 6.0
 27287 00005AD5 EBE0                    	jmp	short ctrlc_abort  ; Use Ctrl-C abort on divide overflow
 27288                                  
 27289                                  ; 30/07/2018
 27290                                  
 27291                                  ; MSDOS 6.0
 27292                                  ;---------------------------------------------------------------------------
 27293                                  ;
 27294                                  ; Procedure Name : OutMes
 27295                                  ;
 27296                                  ;
 27297                                  ; OutMes: perform message output
 27298                                  ; Inputs:   SS:SI points to message
 27299                                  ;	    BX has message length
 27300                                  ; Outputs:  message to BCON
 27301                                  ;
 27302                                  ;Actually, cs:si points to the message now. The segment address is filled in
 27303                                  ;at init. time ([dskchret+2]). This will be temporarily changed to DOSCODE. 
 27304                                  ;NB. This procedure is called only from DIVOV. -SR
 27305                                  ;
 27306                                  ;---------------------------------------------------------------------------
 27307                                  
 27308                                  ;MSDOS 3.3
 27309                                  ;---------------------------------------------------------------------------
 27310                                  ; RealDivOv: perform actual divide overflow stuff.
 27311                                  ; Inputs:   none
 27312                                  ; Outputs:  message to BCON
 27313                                  ;---------------------------------------------------------------------------
 27314                                  
 27315                                  	; 30/07/2018
 27316                                  	; MSDOS 6.0
 27317                                  ;_OUTMES:
 27318                                  	;MSDOS 3.3
 27319                                  RealDivOv:
 27320                                  	 
 27321                                  	; 07/07/2018 - Retro DOS v3.0
 27322                                          ;Context ES
 27323                                          ;push	ss ; 30/07/2018
 27324 00005AD7 0E                      	PUSH	CS			; get ES addressability
 27325 00005AD8 07                      	POP	ES
 27326                                          ;Context DS
 27327                                  	;push	ss ; 30/07/2018
 27328 00005AD9 0E                      	PUSH	CS			; get DS addressability
 27329 00005ADA 1F                      	POP	DS
 27330 00005ADB C606[5E03]08                    MOV     BYTE [DSKSTCOM],DEVWRT
 27331 00005AE0 C606[5C03]16                    MOV     BYTE [DSKSTCALL],DRDWRHL
 27332 00005AE5 C706[5F03]0000                  MOV     WORD [DSKSTST],0
 27333                                  	; BX = [DivMesLen] = 19
 27334 00005AEB 891E[6E03]                      MOV     [DSKSTCNT],BX
 27335 00005AEF BB[5C03]                        MOV     BX,DSKSTCALL
 27336                                          ;MOV     [DSKCHRET+1],SI	; transfer address (need an EQU)
 27337                                  	; 08/09/2018
 27338 00005AF2 8936[6A03]              	mov	[DEVIOBUF_PTR],si
 27339                                  	; MSDOS 6.0
 27340                                  					; CS is used for string, fill in 
 27341                                  					; segment address 
 27342                                  	;MOV	[DskChRet+3],CS
 27343                                  
 27344 00005AF6 C536[3200]                      LDS     SI,[BCON]
 27345 00005AFA E835F6                          CALL	DEVIOCALL2
 27346                                  	; 14/03/2018
 27347                                          ;MOV     WORD [CS:DSKCHRET+1],DEVIOBUF
 27348                                  	; 08/09/2018
 27349 00005AFD 2EC706[6A03][8003]      	mov	word [CS:DEVIOBUF_PTR],DEVIOBUF
 27350 00005B04 2EC706[6E03]0100                MOV     WORD [CS:DSKSTCNT],1
 27351 00005B0B C3                              RETN
 27352                                  
 27353                                  ;Break	<CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER>
 27354                                  ;---------------------------------------------------------------------------
 27355                                  ;
 27356                                  ; Procedure Name : CHARHARD
 27357                                  ;
 27358                                  ;
 27359                                  ; Character device error handler
 27360                                  ; Same function as HARDERR
 27361                                  ;
 27362                                  ;---------------------------------------------------------------------------
 27363                                  
 27364                                  CHARHARD:
 27365                                  	; 30/07/2018
 27366                                  	; 08/07/2018 - Retro DOS v3.0
 27367                                  
 27368                                  	; MSDOS 6.0
 27369                                  ;		   			; M024 - start
 27370                                  ;	cmp	byte ptr [ERRORMODE], 0	; Q: are we in the middle of int 24
 27371                                  ;	jne	@f			; Y: allow fail
 27372                                  ;
 27373                                  ;	OR	AH, Allowed_RETRY	; assume ctrl p
 27374                                  ;
 27375                                  ;	test	byte ptr [PFLAG], -1	; Q: has ctrl p been pressed
 27376                                  ;	jnz	ctrlp			; Y: 
 27377                                  ;@@:					; M024 - end
 27378                                  
 27379                                  ; Character device error handler
 27380                                  ; Same function as HARDERR
 27381                                  
 27382                                  	;or	ah,38h
 27383 00005B0C 80CC38                  	or	ah,Allowed_IGNORE+Allowed_RETRY+Allowed_FAIL
 27384                                  ;ctrlp:			; SS override for Allowed and EXITHOLD
 27385 00005B0F 368826[1503]            	mov	[SS:ALLOWED],ah
 27386                                  
 27387                                  	; 15/03/2018
 27388 00005B14 368C06[3E05]                    MOV     [SS:EXITHOLD+2],ES
 27389 00005B19 36892E[3C05]                    MOV     [SS:EXITHOLD],BP
 27390 00005B1E 56                              PUSH    SI
 27391                                  	;and	di,0FFh
 27392 00005B1F 81E7FF00                        AND     DI,STECODE
 27393 00005B23 8CDD                            MOV     BP,DS                   ;Device pointer is BP:SI
 27394 00005B25 E86400                          CALL    FATALC
 27395 00005B28 5E                              POP     SI
 27396                                  	;return
 27397 00005B29 C3                              RETN
 27398                                  
 27399                                  ;---------------------------------------------------------------------------
 27400                                  ;
 27401                                  ; Procedure Name : HardErr
 27402                                  ;
 27403                                  ; Hard disk error handler. Entry conditions:
 27404                                  ;	DS:BX = Original disk transfer address
 27405                                  ;	DX = Original logical sector number
 27406                                  ;	CX = Number of sectors to go (first one gave the error)
 27407                                  ;	AX = Hardware error code
 27408                                  ;	DI = Original sector transfer count	
 27409                                  ;	ES:BP = Base of drive parameters
 27410                                  ;	[READOP] = 0 for read, 1 for write
 27411                                  ;	Allowed Set with allowed responses to this error (other bits MUST BE 0)
 27412                                  ; Output:
 27413                                  ;	[FAILERR] will be set if user responded FAIL
 27414                                  ;
 27415                                  ;--------------------------------------------------------------------------
 27416                                  
 27417                                  HARDERR:
 27418                                  	; 30/07/2018
 27419                                  	; 08/07/2018 - Retro DOS v3.0
 27420 00005B2A 97                      	XCHG    AX,DI                   ; Error code in DI, count in AX
 27421                                          ;and	di,0FFh
 27422 00005B2B 81E7FF00                	AND     DI,STECODE              ; And off status bits
 27423                                          ;CMP	DI,WRECODE		; Write Protect Error?
 27424                                  	;cmp	di,0
 27425 00005B2F 83FF00                  	cmp	DI,error_I24_write_protect ; Write Protect Error?
 27426 00005B32 750A                            JNZ     short NOSETWRPERR
 27427 00005B34 50                              PUSH    AX
 27428                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 27429                                          ;MOV	AL,[ES:BP+0]
 27430 00005B35 268A4600                	mov	al,[ES:BP]
 27431                                          	; 15/03/2018
 27432 00005B39 36A2[EE02]                      MOV     [SS:WPERR],AL		; Flag drive with WP error
 27433 00005B3D 58                              POP     AX
 27434                                  NOSETWRPERR:
 27435 00005B3E 29C8                            SUB     AX,CX                   ; Number of sectors successfully transferred
 27436 00005B40 01C2                            ADD     DX,AX                   ; First sector number to retry
 27437 00005B42 52                              PUSH    DX
 27438                                  	; 08/07/2018
 27439                                          ;MUL	word [ES:BP+2] 		; Number of bytes transferred
 27440 00005B43 26F76602                	MUL	word [ES:BP+DPB.SECTOR_SIZE]
 27441 00005B47 5A                              POP     DX
 27442 00005B48 01C3                            ADD     BX,AX                   ; First address for retry
 27443 00005B4A 30E4                            XOR     AH,AH                   ; Flag disk section in error
 27444                                          ;CMP	DX,[ES:BP+6] 		; In reserved area?
 27445 00005B4C 263B5606                	CMP	DX,[ES:BP+DPB.FIRST_FAT]
 27446 00005B50 721A                            JB      SHORT ERRINT
 27447 00005B52 FEC4                            INC     AH                      ; Flag for FAT
 27448                                          ;CMP	DX,[ES:BP+10H] 		; In FAT?
 27449 00005B54 263B5611                	CMP	DX,[ES:BP+DPB.DIR_SECTOR]   
 27450 00005B58 7308                    	JAE	short TESTDIR 		; No
 27451                                  		 ; Err in FAT must force recomp of freespace
 27452                                  	;mov	word[ES:BP+1Eh],-1
 27453 00005B5A 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1
 27454 00005B60 EB0A                    	JMP	SHORT ERRINT
 27455                                  TESTDIR:
 27456 00005B62 FEC4                            INC     AH
 27457                                          ;CMP	DX,[ES:BP+0BH]		; In directory?
 27458 00005B64 263B560B                	CMP	DX,[ES:BP+DPB.FIRST_SECTOR] 
 27459 00005B68 7202                            JB      SHORT ERRINT
 27460 00005B6A FEC4                            INC     AH                      ; Must be in data area
 27461                                  ERRINT:
 27462 00005B6C D0E4                            SHL     AH,1                    ; Make room for read/write bit
 27463 00005B6E 360A26[3205]                    OR      AH,[SS:READOP] ; 15/03/2018
 27464                                  
 27465                                  	; 15/08/2018
 27466                                  					; SS override for allowed and EXITHOLD
 27467 00005B73 360A26[1503]            	OR	AH,[SS:ALLOWED]		; Set the allowed_ bits
 27468                                  
 27469                                          ;entry   FATAL
 27470                                  FATAL:
 27471                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 27472                                          ;MOV	AL,[ES:BP+0]		; Get drive number
 27473 00005B78 268A4600                	MOV	AL,[ES:BP]        
 27474                                  
 27475                                  	;entry   FATAL1
 27476                                  FATAL1:  
 27477                                  	; 15/03/2018      
 27478 00005B7C 368C06[3E05]            	MOV     [SS:EXITHOLD+2],ES
 27479 00005B81 36892E[3C05]                    MOV     [SS:EXITHOLD],BP	; The only things we preserve	
 27480                                  	;LES	SI,[ES:BP+12H]
 27481 00005B86 26C47613                	LES	SI,[ES:BP+DPB.DRIVER_ADDR]
 27482 00005B8A 8CC5                            MOV     BP,ES                   ; BP:SI points to the device involved
 27483                                  
 27484                                  	; DI has the INT-24-style extended error. We now map the error code 
 27485                                  	; for this into the normalized get extended error set by using the 
 27486                                  	; ErrMap24 table as a translate table. Note that we translate ONLY 
 27487                                  	; the device returned codes and leave all others beyond the look up 
 27488                                  	; table alone.
 27489                                  
 27490                                  	; 08/07/2018 - Retro DOS v3.0
 27491                                  FATALC:
 27492 00005B8C E86701                  	call	SET_I24_EXTENDED_ERROR
 27493                                  	;cmp	di,0Ch
 27494 00005B8F 83FF0C                  	CMP	DI,error_I24_gen_failure
 27495 00005B92 7603                    	JBE	short GOT_RIGHT_CODE	; Error codes above gen_failure get
 27496 00005B94 BF0C00                  	MOV	DI,error_I24_gen_failure; mapped to gen_failure. Real codes
 27497                                  					;  Only come via GetExtendedError
 27498                                  ;**
 27499                                  ;
 27500                                  ; Entry point used by REDIRector on Network I 24 errors.
 27501                                  ;
 27502                                  ;	ASSUME	DS:NOTHING,ES:NOTHING,SS:DOSDATA
 27503                                  ;
 27504                                  ; ALL I 24 regs set up. ALL Extended error info SET. ALLOWED Set.
 27505                                  ;     EXITHOLD set for restore of ES:BP.
 27506                                  ;
 27507                                  	;entry	NET_I24_ENTRY
 27508                                  NET_I24_ENTRY:
 27509                                  GOT_RIGHT_CODE:
 27510 00005B97 36803E[EC02]00          	CMP     BYTE [SS:ERRORMODE],0	; No INT 24s if already INT 24
 27511 00005B9D 7404                            JZ	SHORT NoSetFail
 27512 00005B9F B003                    	MOV	AL,3
 27513 00005BA1 EB51                    	JMP	short FailRet
 27514                                  NoSetFail:
 27515 00005BA3 368926[4405]                    MOV     [SS:CONTSTK],SP		; SS override
 27516 00005BA8 16                              PUSH	SS
 27517 00005BA9 07                              POP	ES
 27518                                      
 27519                                  	; Wango!!! We may need to free some user state info... In 
 27520                                  	; particular, we may have locked down a JFN for a user and he may 
 27521                                  	; NEVER return to us. Thus,we need to free it here and then 
 27522                                  	; reallocate it when we come back.
 27523                                  
 27524 00005BAA 36833E[6605]FF          	CMP	word [SS:SFN],-1
 27525 00005BB0 740C                    	JZ	short _NoFree
 27526 00005BB2 1E                      	push	ds
 27527 00005BB3 56                      	push	si
 27528 00005BB4 36C536[6A05]            	LDS	SI,[SS:PJFN]
 27529 00005BB9 C604FF                  	MOV	BYTE [SI],0FFH
 27530 00005BBC 5E                      	pop	si
 27531 00005BBD 1F                      	pop	ds
 27532                                  
 27533                                  _NoFree:
 27534 00005BBE FA                      	CLI
 27535                                  					; Prepare to play with stack
 27536 00005BBF 36FE06[EC02]                    INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
 27537 00005BC4 36FE0E[ED02]                    DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
 27538 00005BC9 368E16[4205]                    MOV     SS,[SS:USER_SS]
 27539 00005BCE 268B26[4005]                    MOV     SP,[ES:USER_SP]         ; User stack pointer restored
 27540                                  	;int	24h	
 27541 00005BD3 CD24                            INT     int_fatal_abort         ; Fatal error interrupt vector, must preserve ES
 27542 00005BD5 268926[4005]                    MOV     [ES:USER_SP],SP         ; restore our stack
 27543 00005BDA 268C16[4205]                    MOV     [ES:USER_SS],SS
 27544 00005BDF 8CC5                            MOV     BP,ES
 27545 00005BE1 8ED5                            MOV     SS,BP
 27546 00005BE3 368B26[4405]                    MOV     SP,[SS:CONTSTK]
 27547 00005BE8 36FE06[ED02]                    INC     BYTE [SS:INDOS]		; Back in the DOS
 27548 00005BED 36C606[EC02]00                  MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
 27549 00005BF3 FB                              STI
 27550                                  FailRet:
 27551 00005BF4 36C42E[3C05]                    LES     BP,[SS:EXITHOLD]
 27552                                  	
 27553                                  	; 08/07/2018
 27554                                  
 27555                                  	; Triage the user's reply.
 27556                                  
 27557 00005BF9 3C01                    	CMP	AL,1
 27558 00005BFB 7235                    	JB	short CheckIgnore	; 0 => ignore
 27559 00005BFD 743D                    	JZ	short CheckRetry	; 1 => retry
 27560 00005BFF 3C03                    	CMP	AL,3			; 3 => fail
 27561 00005C01 7543                    	JNZ	short DoAbort 		; 2, invalid => abort
 27562                                  
 27563                                  	; The reply was fail.  See if we are allowed to fail.
 27564                                  
 27565                                  				; SS override for ALLOWED, EXTOPEN_ON, 
 27566                                  				; ALLOWED, FAILERR, WPERR, SFN, pJFN
 27567                                  	;test	byte [ss:ALLOWED],8
 27568 00005C03 36F606[1503]08          	test	byte [ss:ALLOWED],Allowed_FAIL ; Can we?
 27569 00005C09 743B                    	jz	short DoAbort	; No, do abort
 27570                                  DoFail:
 27571 00005C0B B003                    	MOV	AL,3		; just in case...
 27572                                  				; AN000;EO. I24 error disabled
 27573                                  	;(MSDOS 6.0, MSCTRLC.ASM, 1991)
 27574                                  	;test	byte [ss:EXTOPEN_ON],EXT_OPEN_I24_OFF 
 27575                                  	;jnz	short Cleanup 		; AN000;EO. no
 27576                                  	
 27577 00005C0D 36FE06[1403]            	inc	byte [SS:FAILERR]	; Tell everybody
 27578                                  
 27579                                  CleanUp:
 27580 00005C12 36C606[EE02]FF          	MOV	byte [SS:WPERR],-1
 27581 00005C18 36833E[6605]FF          	CMP	word [SS:SFN],-1
 27582                                  	;jnz	short CleanUp2
 27583                                  	;retn
 27584 00005C1E 7411                    	jz	short Cleanup_retn ; 08/07/2018 - Retro DOS v3.0
 27585                                  ;CleanUp2:
 27586 00005C20 1E                      	push	ds
 27587 00005C21 56                      	push	si
 27588 00005C22 50                      	push	ax
 27589 00005C23 36A1[6605]              	MOV	AX,[ss:SFN]
 27590 00005C27 36C536[6A05]            	LDS	SI,[ss:PJFN]
 27591 00005C2C 8804                    	MOV	[SI],AL
 27592 00005C2E 58                      	pop	ax
 27593 00005C2F 5E                      	pop	si
 27594 00005C30 1F                      	pop	ds
 27595                                  Cleanup_retn:
 27596 00005C31 C3                      	retn
 27597                                  
 27598                                  	; The reply was IGNORE. See if we are allowed to ignore.
 27599                                  
 27600                                  CheckIgnore:
 27601                                  	;test	byte [ss:ALLOWED],20h
 27602 00005C32 36F606[1503]20          	test	byte [ss:ALLOWED],Allowed_IGNORE ; Can we?
 27603 00005C38 74D1                    	jz	short DoFail			 ; No, do fail
 27604 00005C3A EBD6                    	jmp	short CleanUp
 27605                                  
 27606                                  	; The reply was RETRY. See if we are allowed to retry.
 27607                                  
 27608                                  CheckRetry:
 27609                                  	;test	byte [ss:ALLOWED],10h
 27610 00005C3C 36F606[1503]10          	test	byte [ss:ALLOWED],Allowed_RETRY	; Can we?
 27611 00005C42 74C7                    	jz	short DoFail			; No, do fail
 27612 00005C44 EBCC                    	JMP	short CleanUp
 27613                                  
 27614                                  	; The reply was ABORT.
 27615                                  
 27616                                  DoAbort:
 27617 00005C46 16                      	push	ss
 27618 00005C47 1F                      	pop	ds
 27619                                  
 27620 00005C48 803E[2103]00            	CMP	byte [CONSWAP],0
 27621 00005C4D 7403                    	JZ	short NOSWAP2
 27622 00005C4F E85DE2                  	call	SWAPBACK
 27623                                  NOSWAP2:
 27624                                  	; See if we are to truly abort. If we are in the process of aborting, 
 27625                                  	; turn this abort into a fail.
 27626                                  
 27627                                  	;test	byte [fAborting],0FFh
 27628                                  	;jnz	short DoFail
 27629                                  
 27630 00005C52 803E[2303]00            	cmp	byte [fAborting],0
 27631 00005C57 75B2                    	JNZ	short DoFail
 27632                                  
 27633                                  	; Set return code
 27634                                  
 27635 00005C59 C606[3905]02            	MOV	BYTE [EXIT_TYPE],EXIT_HARD_ERROR
 27636 00005C5E 30C0                    	XOR	AL,AL
 27637                                  
 27638                                  	; we are truly aborting the process. Go restore information from 
 27639                                  	; the PDB as necessary.
 27640                                  
 27641 00005C60 E9A00B                  	jmp	exit_inner
 27642                                  
 27643                                  ;**
 27644                                  ;
 27645                                  ; reset_environment checks the DS value against the CurrentPDB. If they are
 27646                                  ; different, then an old-style return is performed. If they are the same,
 27647                                  ; then we release jfns and restore to parent. We still use the PDB at DS:0 as
 27648                                  ; the source of the terminate addresses.
 27649                                  ;
 27650                                  ; Some subtlety: We are about to issue a bunch of calls that *may* generate
 27651                                  ; INT 24s. We *cannot* allow the user to restart the abort process; we may
 27652                                  ; end up aborting the wrong process or turn a terminate/stay/resident into a
 27653                                  ; normal abort and leave interrupt handlers around. What we do is to set a
 27654                                  ; flag that will indicate that if any abort code is seen, we just continue the
 27655                                  ; operation. In essence, we dis-allow the abort response.
 27656                                  ;
 27657                                  ; output:   none.
 27658                                  ;
 27659                                  	;entry	reset_environment
 27660                                  	
 27661                                  reset_environment:
 27662                                  	; 30/07/2018 - Retro DOS v3.0
 27663                                  	; IBMDOS.COM (MSDOS 3.3) - Offset 588Ah 
 27664                                  
 27665                                  ;***	invoke	Reset_Version		; AN007 ;MS. reset version number
 27666                                  
 27667 00005C63 1E                      	PUSH	DS			; save PDB of process
 27668                                  
 27669                                  	; There are no critical sections in force. Although we may enter 
 27670                                  	; here with critical sections locked down, they are no longer 
 27671                                  	; relevant. We may safely free all allocated resources.
 27672                                  
 27673 00005C64 B482                    	MOV	AH,82h
 27674                                  		; Microsoft Networks - END DOS CRITICAL SECTIONS 0 THROUGH 7
 27675                                  	;int	2Ah 	
 27676 00005C66 CD2A                    	INT	int_IBM
 27677                                  
 27678                                  					; SS override
 27679 00005C68 36C606[2303]FF          	MOV	byte [SS:fAborting],-1	; signal abort in progress
 27680                                  
 27681                                  					; DOS 4.00 doesn't need it
 27682                                  	;CallInstall NetResetEnvironment, MultNET, 34  
 27683                                  					; Allow REDIR to clear some stuff
 27684                                  					; On process exit.
 27685 00005C6E B82211                  	mov     ax, 1122h
 27686 00005C71 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PROCESS TERMINATION HOOK
 27687                                  			; SS = DOS CS
 27688                                  	;mov	al,22h	
 27689 00005C73 B022                    	MOV	AL,int_terminate
 27690 00005C75 E884C0                  	call	_$GET_INTERRUPT_VECTOR	; and who to go to
 27691                                  
 27692 00005C78 59                      	POP	CX			; get ThisPDB
 27693 00005C79 06                      	push	es
 27694 00005C7A 53                      	push	bx			; save return address
 27695                                  
 27696 00005C7B 368B1E[FC02]            	MOV	BX,[SS:CurrentPDB] 	; get currentPDB
 27697 00005C80 8EDB                    	MOV	DS,BX
 27698 00005C82 A11600                  	MOV	AX,[PDB.PARENT_PID]	; get parentPDB
 27699                                  
 27700                                  	; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
 27701                                  	; Only free handles if AX <> BX and BX = CX and [exit_code].upper 
 27702                                  	; is not Exit_keep_process
 27703                                  	
 27704 00005C85 39D8                    	CMP	AX,BX
 27705 00005C87 7418                    	JZ	short reset_return	; parentPDB = CurrentPDB
 27706 00005C89 39CB                    	CMP	BX,CX
 27707 00005C8B 7514                    	JNZ	short reset_return	; CurrentPDB <> ThisPDB
 27708 00005C8D 50                      	PUSH	AX			; save parent
 27709                                  
 27710                                  					; SS override
 27711                                  	;cmp	byte [SS:EXIT_TYPE],3
 27712 00005C8E 36803E[3905]03          	CMP	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS ; 15/08/2018
 27713 00005C94 7406                    	JZ	short reset_to_parent 	; keeping this process
 27714                                  
 27715                                  	; We are truly removing a process. Free all allocation blocks 
 27716                                  	; belonging to this PDB
 27717                                  
 27718                                  	;invoke	arena_free_process
 27719 00005C96 E8A10B                  	call	arena_free_process
 27720                                  
 27721                                  	; Kill off remainder of this process. Close file handles and signal 
 27722                                  	; to relevant network folks that this process is dead. Remember that 
 27723                                  	; CurrentPDB is STILL the current process!
 27724                                  
 27725                                  	;invoke	DOS_ABORT
 27726 00005C99 E828DE                  	call	DOS_ABORT
 27727                                  
 27728                                  reset_to_parent:
 27729                                  					; SS override
 27730 00005C9C 368F06[FC02]            	POP	word [SS:CurrentPDB]	; set up process as parent
 27731                                  
 27732                                  reset_return:				; come here for normal return
 27733                                  	;Context DS			; DS is used to refer to DOSDATA  
 27734 00005CA1 16                      	push	ss
 27735 00005CA2 1F                      	pop	ds	
 27736                                  
 27737 00005CA3 B0FF                    	MOV	AL,-1
 27738                                  
 27739                                  	; make sure that everything is clean In this case ignore any errors, 
 27740                                  	; we cannot "FAIL" the abort, the program being aborted is dead.
 27741                                  
 27742                                  	;EnterCrit critDisk
 27743 00005CA5 E865C4                  	call	EcritDisk
 27744                                  	;invoke	FLUSHBUF
 27745 00005CA8 E8C305                  	call	FLUSHBUF
 27746                                  	;LeaveCrit critDisk
 27747 00005CAB E867C4                  	call	LcritDisk
 27748                                  
 27749                                  	; Decrement open ref. count if we had done a virtual open earlier.
 27750                                  
 27751 00005CAE E88DF8                  	call	CHECK_VIRT_OPEN
 27752 00005CB1 FA                      	CLI
 27753 00005CB2 C606[ED02]00            	MOV	BYTE [INDOS],0		; Go to known state
 27754 00005CB7 C606[EE02]FF            	MOV	BYTE [WPERR],-1		; Forget about WP error
 27755 00005CBC C606[2303]00            	MOV	byte [fAborting],0	; let aborts occur
 27756 00005CC1 8F06[3C05]              	POP	WORD [EXITHOLD]
 27757 00005CC5 8F06[3E05]              	POP	WORD [EXITHOLD+2]
 27758                                  
 27759                                  	; Snake into multitasking... Get stack from CurrentPDB person
 27760                                  
 27761 00005CC9 8E1E[FC02]              	MOV	DS,[CurrentPDB]
 27762 00005CCD 8E163000                	MOV	SS,[PDB.USER_STACK+2]
 27763 00005CD1 8B262E00                	MOV	SP,[PDB.USER_STACK]
 27764                                  
 27765 00005CD5 E84BB9                  	call	restore_world
 27766                                  
 27767                                  	; MSDOS 6.0
 27768                                  	;push	ax			; set up ds, but save ds in TEMPSEG 
 27769                                  	;mov	ax, ds			; and not on stack.
 27770                                  	;getdseg <ds>			; ds -> dosdata
 27771                                  	;mov	TempSeg, ax
 27772                                  	;pop	ax
 27773                                  					; set up ds to DOSDATA
 27774 00005CD8 2EA3[4005]              	MOV	[CS:USER_SP],AX
 27775                                  
 27776 00005CDC 58                      	POP	AX			; suck off CS:IP of interrupt...
 27777 00005CDD 58                      	POP	AX
 27778 00005CDE 58                      	POP	AX
 27779                                  
 27780                                  ; M011 : BEGIN
 27781                                  
 27782                                  	; MSDOS 3.3
 27783                                  ;	MOV	AX,0F202h	; STI
 27784                                  
 27785                                  	; MSDOS 6.0
 27786 00005CDF 9F                      	LAHF
 27787 00005CE0 86E0                    	XCHG	AH, AL
 27788 00005CE2 2402                    	AND	AL, 02
 27789 00005CE4 B4F2                    	MOV	AH, 0F2h
 27790                                  
 27791                                  ; M011 : END
 27792                                  
 27793                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27794 00005CE6 50                      	PUSH	AX
 27795                                   
 27796 00005CE7 2EFF36[3E05]            	PUSH	word [CS:EXITHOLD+2]
 27797 00005CEC 2EFF36[3C05]            	PUSH	word [CS:EXITHOLD]
 27798                                  
 27799 00005CF1 2EA1[4005]              	MOV	AX,[CS:USER_SP]
 27800                                  
 27801                                  	; MSDOS 6.0
 27802                                  	;mov	ds,TempSeg	; restore ds
 27803                                  
 27804 00005CF5 CF                      	IRET			; Long return back to user terminate address
 27805                                  
 27806                                  ;---------------------------------------------------------------------------
 27807                                  ;
 27808                                  ; Procedure Name : SET_I24_EXTENDED_ERROR
 27809                                  ;
 27810                                  ; This routine handles extended error codes.
 27811                                  ; Input : DI = error code from device
 27812                                  ; Output: All EXTERR fields are set
 27813                                  ;
 27814                                  ;--------------------------------------------------------------------------
 27815                                  
 27816                                  SET_I24_EXTENDED_ERROR:
 27817 00005CF6 50                      	PUSH	AX
 27818                                  					; ErrMap24End is in DOSDATA
 27819 00005CF7 B8[330E]                	MOV	AX,ErrMap24End
 27820 00005CFA 2D[230E]                	SUB	AX,ErrMap24
 27821                                  					; Change to dosdata to access 
 27822                                  					; ErrMap24 and EXTERR -SR
 27823                                  	; MSDOS 6.0
 27824                                  	;push	ds
 27825                                  	;getdseg <ds>			; ds ->dosdata
 27826                                  
 27827                                  	; AX is the index of the first unavailable error. Do not translate 
 27828                                  	; if greater or equal to AX.
 27829                                  
 27830 00005CFD 39C7                    	CMP	DI,AX
 27831 00005CFF 89F8                    	MOV	AX,DI
 27832 00005D01 7307                    	JAE	short NoTrans
 27833                                  
 27834 00005D03 2E8A85[230E]            	MOV	AL,[CS:DI+ErrMap24]
 27835 00005D08 30E4                    	XOR	AH,AH
 27836                                  NoTrans:
 27837 00005D0A 2EA3[F002]              	MOV	[CS:EXTERR],AX
 27838                                  	;pop	ds
 27839                                  	;assume	ds:nothing
 27840 00005D0E 58                      	POP	AX
 27841                                  
 27842                                  	; Now Extended error is set correctly. Translate it to get correct 
 27843                                  	; error locus class and recommended action.
 27844                                  
 27845 00005D0F 56                      	PUSH	SI
 27846                                  					; ERR_TABLE_24 is in DOSCODE 
 27847 00005D10 BE[D30D]                	MOV	SI,ERR_TABLE_24
 27848 00005D13 E8C8BA                  	call	CAL_LK			; Set other extended error fields
 27849 00005D16 5E                      	POP	SI
 27850 00005D17 C3                      	retn
 27851                                  
 27852                                  ;============================================================================
 27853                                  ; FAT.ASM, MSDOS 6.0, 1991
 27854                                  ;============================================================================
 27855                                  ; 30/07/2018 - Retro DOS v3.0
 27856                                  
 27857                                  ;	TITLE	FAT - FAT maintenance routines
 27858                                  ;	NAME	FAT
 27859                                  
 27860                                  ;**	FAT.ASM
 27861                                  ;
 27862                                  ;	Low level local device routines for performing disk change sequence,
 27863                                  ;	setting cluster validity, and manipulating the FAT
 27864                                  ;
 27865                                  ;	IsEof
 27866                                  ;	UNPACK
 27867                                  ;	PACK
 27868                                  ;	MAPCLUSTER
 27869                                  ;	FATREAD_SFT
 27870                                  ;	FATREAD_CDS
 27871                                  ;	FAT_operation
 27872                                  ;
 27873                                  ;	Revision history:
 27874                                  ;
 27875                                  ;	  AN000  version Jan. 1988
 27876                                  ;	   A001  PTM	      -- disk changed for look ahead buffers
 27877                                  ;
 27878                                  ;	M014 - if a request for pack\unpack cluster 0 is made we write\read
 27879                                  ;	       from CL0FATENTRY rather than disk.
 27880                                  ;
 27881                                  
 27882                                  ;Break <IsEOF - check the quantity in BX for EOF>
 27883                                  ;----------------------------------------------------------------------------
 27884                                  ;
 27885                                  ; Procedure Name : IsEOF
 27886                                  ;
 27887                                  ; IsEOF - check the fat value in BX for eof.
 27888                                  ;
 27889                                  ;   Inputs:	ES:BP point to DPB
 27890                                  ;		BX has fat value
 27891                                  ;   Outputs:	JAE eof
 27892                                  ;   Registers modified: none
 27893                                  ;
 27894                                  ;---------------------------------------------------------------------------
 27895                                  
 27896                                  IsEOF:
 27897                                  	;cmp	word [es:bp+0Dh],0FF6h
 27898 00005D18 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; is this 16 bit fat?
 27899 00005D1E 730B                    	JAE	short EOF16			; yes, check for eof there
 27900                                  
 27901                                  ;J.K. 8/27/86
 27902                                  ;Modified to accept 0FF0h as an eof. This is to handle the diskfull case
 27903                                  ;of any media that has "F0"(Other) as a MediaByte.
 27904                                  ;Hopely, this does not create any side effect for those who may use any value
 27905                                  ;other than "FF8-FFF" as an EOF for their own file.
 27906                                  
 27907 00005D20 81FBF00F                	cmp	bx,0FF0h
 27908 00005D24 7404                    	je	short IsEOF_other
 27909                                  
 27910 00005D26 81FBF80F                	CMP	BX,0FF8h		; do the 12 bit compare
 27911                                  IsEOF_other:
 27912 00005D2A C3                      	retn
 27913                                  EOF16:
 27914 00005D2B 83FBF8                  	CMP	BX,0FFF8h		; 16 bit compare
 27915 00005D2E C3                      	retn
 27916                                  
 27917                                  ;Break	<UNPACK -- UNPACK FAT ENTRIES>
 27918                                  ;---------------------------------------------------------------------------
 27919                                  ;
 27920                                  ; Procedur Name : UNPACK
 27921                                  ;
 27922                                  ; Inputs:
 27923                                  ;	BX = Cluster number (may be full 16-bit quantity)
 27924                                  ;	ES:BP = Base of drive parameters
 27925                                  ; Outputs:
 27926                                  ;	DI = Contents of FAT for given cluster (may be full 16-bit quantity)
 27927                                  ;	Zero set means DI=0 (free cluster)
 27928                                  ;	Carry set means error (currently user FAILed to I 24)
 27929                                  ; SI Destroyed, No other registers affected. Fatal error if cluster too big.
 27930                                  ;
 27931                                  ; NOTE: if BX = 0 then DI = contents of CL0FATENTRY
 27932                                  ;
 27933                                  ;----------------------------------------------------------------------------
 27934                                  
 27935                                  	; 25/07/2019 - Retro DOS v3.2
 27936                                  	; 20/05/2019 - Retro DOS v4.0
 27937                                  UNPACK:
 27938                                  	; MSDOS 6.0			; M014 - Start
 27939 00005D2F 09DB                    	or	bx,bx			; Q: are we unpacking cluster 0
 27940 00005D31 7507                    	jnz	short up_cont		; N: proceed with normal unpack
 27941 00005D33 8B3E[CB0F]              	mov	di,[CL0FATENTRY]	; Y: return value in CL0FATENTRY
 27942 00005D37 09FF                    	or	di,di 			; return z if di=0
 27943 00005D39 C3                      	retn				; done
 27944                                  up_cont:				; M014 - End
 27945                                  	; MSDOS 3.3 & MSDOS 6.0
 27946                                  	;cmp	bx,[es:bp+0Dh]
 27947 00005D3A 263B5E0D                	CMP	BX,[ES:BP+DPB.MAX_CLUSTER]
 27948 00005D3E 7726                    	JA	short HURTFAT
 27949 00005D40 E8CA00                  	CALL	MAPCLUSTER
 27950 00005D43 721E                    	jc	short _DoContext
 27951 00005D45 8B3D                    	MOV	DI,[DI]
 27952 00005D47 750E                    	JNZ	short High12		; MZ if high 12 bits, go get 'em
 27953 00005D49 268B760D                	MOV	SI,[ES:BP+DPB.MAX_CLUSTER] ; MZ is this 16-bit fat?
 27954 00005D4D 81FEF60F                	CMP	SI,4096-10
 27955 00005D51 720C                    	JB	short Unpack12		; MZ No, go 'AND' off bits
 27956 00005D53 09FF                    	OR	DI,DI			; MZ set zero condition code, clears carry
 27957 00005D55 EB0C                    	JMP	SHORT _DoContext 	; MZ go do context
 27958                                  High12:
 27959 00005D57 D1EF                    	SHR	DI,1
 27960 00005D59 D1EF                    	SHR	DI,1
 27961 00005D5B D1EF                    	SHR	DI,1
 27962 00005D5D D1EF                    	SHR	DI,1
 27963                                  Unpack12:
 27964 00005D5F 81E7FF0F                	AND	DI,0FFFh		; Clears carry
 27965                                  _DoContext:
 27966 00005D63 16                      	PUSH	SS
 27967 00005D64 1F                      	POP	DS
 27968 00005D65 C3                      	retn
 27969                                  HURTFAT:
 27970                                  	;;mov	word [es:bp+1Eh],0FFFFh
 27971                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 27972 00005D66 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 ; Err in FAT must force recomp of freespace
 27973 00005D6C 50                      	PUSH	AX
 27974 00005D6D B488                    	MOV	AH,Allowed_FAIL+80h ; 88h
 27975                                  
 27976                                  ;hkn; SS override
 27977 00005D6F 36C606[1503]08          	MOV	byte [SS:ALLOWED],Allowed_FAIL ; 8
 27978                                  ;
 27979                                  ; Signal Bad FAT to INT int_fatal_abort handler. We have an invalid cluster.
 27980                                  ;
 27981 00005D75 BFFF0F                  	MOV	DI,0FFFh		; In case INT int_fatal_abort returns (it shouldn't)
 27982 00005D78 E8FDFD                  	call	FATAL
 27983 00005D7B 3C03                    	CMP	AL,3
 27984 00005D7D F8                      	CLC
 27985 00005D7E 7501                    	JNZ	short OKU_RET 		; Try to ignore bad FAT
 27986 00005D80 F9                      	STC				; User said FAIL
 27987                                  OKU_RET:
 27988 00005D81 58                      	POP	AX
 27989                                  hurtfat_retn:
 27990 00005D82 C3                      	retn
 27991                                  
 27992                                  ;Break	<PACK -- PACK FAT ENTRIES>
 27993                                  ;----------------------------------------------------------------------------
 27994                                  ;
 27995                                  ; Procedure Name : PACK
 27996                                  ;
 27997                                  ; Inputs:
 27998                                  ;	BX = Cluster number
 27999                                  ;	DX = Data
 28000                                  ;	ES:BP = Pointer to drive DPB
 28001                                  ; Outputs:
 28002                                  ;	The data is stored in the FAT at the given cluster.
 28003                                  ;	SI,DX,DI all destroyed
 28004                                  ;	Carry set means error (currently user FAILed to I 24)
 28005                                  ;	No other registers affected
 28006                                  ;
 28007                                  ; NOTE: if BX = 0 then data in DX is atored in CL0FATENTRY.
 28008                                  ;
 28009                                  ;---------------------------------------------------------------------------
 28010                                  
 28011                                  	; 24/07/2019 - Retro DOS v3.2
 28012                                  	; 20/05/2019 - Retro DOS v4.0
 28013                                  PACK:
 28014                                  	; MSDOS 6.0			; M014 - start
 28015 00005D83 09DB                    	or	bx,bx			; Q: are we packing cluster 0
 28016 00005D85 7505                    	jnz	short p_cont		; N: proceed with normal pack
 28017 00005D87 8916[CB0F]              	mov	[CL0FATENTRY],dx	; Y: place value in CL0FATENTRY
 28018 00005D8B C3                      	retn				; done
 28019                                  p_cont:					; M014 - end
 28020                                  	; MSDOS 3.3 & MSDOS 6.0
 28021 00005D8C E87E00                  	CALL	MAPCLUSTER
 28022 00005D8F 72D2                    	JC	short _DoContext
 28023 00005D91 8B35                    	MOV	SI,[DI]
 28024 00005D93 740B                    	JZ	short ALIGNED 		; byte (not nibble) aligned
 28025 00005D95 51                      	PUSH	CX			; move data to upper 12 bits
 28026 00005D96 B104                    	MOV	CL,4
 28027 00005D98 D3E2                    	SHL	DX,CL
 28028 00005D9A 59                      	POP	CX
 28029 00005D9B 83E60F                  	AND	SI,0FH			; leave in original low 4 bits
 28030 00005D9E EB14                    	JMP	SHORT PACKIN
 28031                                  ALIGNED:
 28032                                  	;cmp	word [es:bp+0Dh],0FF6h
 28033 00005DA0 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ 16 bit fats?
 28034 00005DA6 730A                    	JAE	short Pack16		; MZ yes, go clobber original data
 28035 00005DA8 81E600F0                	AND	SI,0F000h		; MZ leave in upper 4 bits of original
 28036 00005DAC 81E2FF0F                	AND	DX,0FFFh		; MZ store only 12 bits
 28037 00005DB0 EB02                    	JMP	SHORT PACKIN		; MZ go store
 28038                                  Pack16:
 28039 00005DB2 31F6                    	XOR	SI,SI			; MZ no original data
 28040                                  PACKIN:
 28041 00005DB4 09D6                    	OR	SI,DX
 28042 00005DB6 8935                    	MOV	[DI],SI
 28043                                  
 28044                                  ;hkn; SS override
 28045 00005DB8 36C536[9E05]            	LDS	SI,[SS:CURBUF]
 28046                                  	; MSDOS 6.0
 28047                                  	;TEST	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 28048                                  					;LB. if already dirty		  ;AN000;
 28049                                  	;JNZ	short yesdirty11	;LB.  don't increment dirty count ;AN000;
 28050                                  	;call	INC_DIRTY_COUNT		;LB.				  ;AN000;
 28051                                  	
 28052                                  	;or	byte [si+5],40h
 28053 00005DBD 804C0540                	OR	byte [SI+BUFFINFO.buf_flags],buf_dirty  
 28054                                  ;yesdirty11:				;LB.				  ;AN000;
 28055                                  ;hkn; SS override
 28056 00005DC1 36803E[3505]00          	CMP	BYTE [SS:CLUSSPLIT],0	; 15/08/2018
 28057                                  ;hkn; SS is DOSDATA
 28058 00005DC7 16                      	push	ss
 28059 00005DC8 1F                      	pop	ds
 28060 00005DC9 74B7                    	jz	short hurtfat_retn	; Carry clear
 28061 00005DCB 50                      	PUSH	AX
 28062 00005DCC 53                      	PUSH	BX
 28063 00005DCD 51                      	PUSH	CX
 28064 00005DCE A1[4A05]                	MOV	AX,[CLUSSAVE]
 28065 00005DD1 8E1E[A005]              	MOV	DS,[CURBUF+2]
 28066                                  	;;add	si,16 ; MSDOS 3.3
 28067                                  	;add	si,20 ; MSDOS 6.0
 28068 00005DD5 83C614                  	ADD	SI,BUFINSIZ
 28069 00005DD8 8824                    	MOV	[SI],AH
 28070                                  ;hkn; SS is DOSDATA
 28071                                  	;Context DS
 28072 00005DDA 16                      	push	ss
 28073 00005DDB 1F                      	pop	ds
 28074                                  	
 28075 00005DDC 50                      	PUSH	AX
 28076                                  	
 28077                                  	; MSDOS 6.0
 28078 00005DDD 8B16[4E05]              	MOV	DX,[CLUSSEC+2]		;F.C. >32mb			;AN000;
 28079 00005DE1 8916[B005]              	MOV	[HIGH_SECTOR],DX	;F.C. >32mb			;AN000;
 28080                                  
 28081                                  	; MSDOS 3.3 & MSDOS 6.0
 28082 00005DE5 8B16[4C05]              	MOV	DX,[CLUSSEC]
 28083 00005DE9 BE0100                  	MOV	SI,1
 28084 00005DEC 30C0                    	XOR	AL,AL
 28085 00005DEE E8B103                  	call	GETBUFFRB
 28086 00005DF1 58                      	POP	AX
 28087 00005DF2 7213                    	JC	short POPP_RET
 28088 00005DF4 C53E[9E05]              	LDS	DI,[CURBUF]
 28089                                  	; MSDOS 6.0
 28090                                  	;TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty  
 28091                                  	;				;LB. if already dirty		  ;AN000;
 28092                                  	;JNZ	short yesdirty12	;LB.  don't increment dirty count ;AN000;
 28093                                  	;call	INC_DIRTY_COUNT 	;LB.				  ;AN000;
 28094                                  	
 28095                                  	;or	byte [di+5],40h
 28096 00005DF8 804D0540                	OR	byte [DI+BUFFINFO.buf_flags],buf_dirty 
 28097                                  ;yesdirty12:
 28098                                  	;;add	di,16
 28099                                  	;add	di,20 ; MSDOS 6.0
 28100 00005DFC 83C714                  	ADD	DI,BUFINSIZ
 28101 00005DFF 4F                      	DEC	DI
 28102                                  	;add	di,[es:bp+2]
 28103 00005E00 26037E02                	ADD	DI,[ES:BP+DPB.SECTOR_SIZE]
 28104 00005E04 8805                    	MOV	[DI],AL
 28105 00005E06 F8                      	CLC
 28106                                  POPP_RET:
 28107 00005E07 16                      	PUSH	SS
 28108 00005E08 1F                      	POP	DS
 28109 00005E09 59                      	POP	CX
 28110 00005E0A 5B                      	POP	BX
 28111 00005E0B 58                      	POP	AX
 28112 00005E0C C3                      	retn
 28113                                  
 28114                                  ; 31/07/2018 - Retro DOS v3.0
 28115                                  
 28116                                  ;Break	<MAPCLUSTER - BUFFER A FAT SECTOR>
 28117                                  ;---------------------------------------------------------------------------
 28118                                  ;
 28119                                  ; Procedure Name : MAPCLUSTER
 28120                                  ;
 28121                                  ; Inputs:
 28122                                  ;	ES:BP Points to DPB
 28123                                  ;	BX Is cluster number
 28124                                  ; Function:
 28125                                  ;	Get a pointer to the cluster
 28126                                  ; Outputs:
 28127                                  ;	DS:DI Points to contents of FAT for given cluster
 28128                                  ;	DS:SI Points to start of buffer
 28129                                  ;	Zero Not set if cluster data is in high 12 bits of word
 28130                                  ;	Zero set if cluster data is in low 12 or 16 bits
 28131                                  ;	Carry set if failed.
 28132                                  ; SI is destroyed.
 28133                                  ;
 28134                                  ;---------------------------------------------------------------------------
 28135                                  
 28136                                  	; 24/07/2019 - Retro DOS v3.2
 28137                                  	; 20/05/2019 - Retro DOS v4.0
 28138                                  	; DOSCODE:9601h (MSDOS 6.21, MSDOS.SYS)
 28139                                  MAPCLUSTER:
 28140                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5A15h
 28141 00005E0D C606[3505]00            	MOV	BYTE [CLUSSPLIT],0
 28142                                  	;SAVE	<AX,BX,CX,DX>
 28143 00005E12 50                      	push	ax
 28144 00005E13 53                      	push	bx
 28145 00005E14 51                      	push	cx
 28146 00005E15 52                      	push	dx
 28147 00005E16 89D8                    	MOV	AX,BX			; AX = BX
 28148 00005E18 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10  ; MZ 16 bit fat?
 28149 00005E1E 7302                    	JAE	short Map16		; MZ yes, do 16 bit algorithm
 28150 00005E20 D1E8                    	SHR	AX,1			; AX = BX/2
 28151                                  Map16:	
 28152                                  	; MSDOS 6.0			; MZ skip prev => AX=2*BX
 28153 00005E22 31FF                    	XOR	DI,DI ; *		; >32mb fat ;AN000;
 28154                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28155 00005E24 01D8                    	ADD	AX,BX			; AX = 1.5*fat = byte offset in fat
 28156 00005E26 11FF                    	ADC	DI,DI ; * MSDOS 6.0	; >32mb fat ;DI is zero before op;AN000;
 28157 00005E28 268B4E02                	MOV	CX,[ES:BP+DPB.SECTOR_SIZE]
 28158                                  
 28159                                  ;IF FastDiv
 28160                                  ;
 28161                                  ; Gross hack: 99% of all disks have 512 bytes per sector. We test for this
 28162                                  ; case and apply a really fast algorithm to get the desired results
 28163                                  ;
 28164                                  ; Divide method takes 157+4*4=173 (MOV and DIV)
 28165                                  ; Fast method takes 39+20*4=119
 28166                                  ;
 28167                                  ; This saves a bunch.
 28168                                  ;
 28169 00005E2C 81F90002                	CMP	CX,512			; 4	Is this 512 byte sector?
 28170 00005E30 7510                    	jne	short _DoDiv		; 4     for no jump
 28171 00005E32 89C2                    	MOV	DX,AX			; 2	get set for remainder
 28172 00005E34 81E2FF01                	AND	DX,512-1		; 4	Form remainder
 28173 00005E38 88E0                    	MOV	AL,AH			; 2     Quotient in formation in AL
 28174                                  	; MDOS 3.3
 28175                                  	;shr	al,1	
 28176                                  	; MDOS 6.0
 28177 00005E3A D1EF                    	shr	di,1			; 2
 28178 00005E3C D0D8                    	rcr	al,1			; 2
 28179                                  	; MDOS 3.3 (& MSDOS 6.0)
 28180 00005E3E 30E4                    	xor	ah,ah			; 3
 28181 00005E40 EB04                    	jmp	short DivDone		; 16
 28182                                  _DoDiv:
 28183                                  ;ENDIF
 28184                                  	; MSDOS 3.3
 28185                                  	;xor	dx,dx
 28186                                  	; MSDOS 6.0
 28187 00005E42 89FA                    	mov	dx,di			; 2
 28188                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 28189 00005E44 F7F1                    	DIV	CX			; 155 AX is FAT sector # DX is sector index
 28190                                  ;IF FastDiv
 28191                                  DivDone:
 28192                                  ;ENDIF
 28193                                  	;add	ax,[es:bp+6]
 28194 00005E46 26034606                	ADD	AX,[ES:BP+DPB.FIRST_FAT]
 28195 00005E4A 49                      	DEC	CX			; CX is sector size - 1
 28196                                  	;SAVE	<AX,DX,CX>
 28197 00005E4B 50                      	push	ax
 28198 00005E4C 52                      	push	dx
 28199 00005E4D 51                      	push	cx
 28200 00005E4E 89C2                    	MOV	DX,AX
 28201                                  
 28202                                  	; MSDOS 6.0
 28203 00005E50 C706[B005]0000          	MOV	word [HIGH_SECTOR],0 	;F.C. >32mb  low sector #
 28204                                  	; MDOS 3.3 (& MSDOS 6.0)
 28205 00005E56 30C0                    	XOR	AL,AL
 28206 00005E58 BE0100                  	MOV	SI,1
 28207                                  	;invoke	GETBUFFRB
 28208 00005E5B E84403                  	call	GETBUFFRB
 28209                                  	;RESTORE <CX,AX,DX>		; CX is sec siz-1, AX is offset in sec
 28210 00005E5E 59                      	pop	cx
 28211 00005E5F 58                      	pop	ax
 28212 00005E60 5A                      	pop	dx
 28213 00005E61 7257                    	JC	short MAP_POP
 28214                                  
 28215 00005E63 C536[9E05]              	LDS	SI,[CURBUF]
 28216                                  	;;lea	di,[si+16]
 28217                                  	;lea	di,[si+20] ; MSDOS 6.0
 28218 00005E67 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 28219 00005E6A 01C7                    	ADD	DI,AX
 28220 00005E6C 39C8                    	CMP	AX,CX
 28221 00005E6E 7537                    	JNZ	short MAPRET
 28222 00005E70 8A05                    	MOV	AL,[DI]
 28223                                  	;Context DS		 	;hkn; SS is DOSDATA
 28224 00005E72 16                      	push	ss
 28225 00005E73 1F                      	pop	ds	
 28226 00005E74 FE06[3505]              	INC	BYTE [CLUSSPLIT]
 28227 00005E78 A2[4A05]                	MOV	[CLUSSAVE],AL
 28228 00005E7B 8916[4C05]              	MOV	[CLUSSEC],DX
 28229                                  	; MSDOS 6.0
 28230 00005E7F C706[4E05]0000          	MOV	WORD [CLUSSEC+2],0      ;F.C. >32mb		;AN000;
 28231 00005E85 42                      	INC	DX
 28232 00005E86 C706[B005]0000          	MOV	word [HIGH_SECTOR],0	;F.C. >32mb FAT sector <32mb ;AN000;
 28233                                  	; MDOS 3.3 (& MSDOS 6.0)
 28234 00005E8C 30C0                    	XOR	AL,AL
 28235 00005E8E BE0100                  	MOV	SI,1
 28236                                  	;invoke	GETBUFFRB
 28237 00005E91 E80E03                  	call	GETBUFFRB
 28238 00005E94 7224                    	JC	short MAP_POP
 28239 00005E96 C536[9E05]              	LDS	SI,[CURBUF]
 28240 00005E9A 8D7C14                  	LEA	DI,[SI+BUFINSIZ]
 28241 00005E9D 8A05                    	MOV	AL,[DI]
 28242                                  	;Context DS			;hkn; SS is DOSDATA
 28243 00005E9F 16                      	push	ss
 28244 00005EA0 1F                      	pop	ds
 28245 00005EA1 A2[4B05]                	MOV	[CLUSSAVE+1],AL
 28246                                  
 28247                                  ;hkn; CLUSSAVE is in DOSDATA
 28248 00005EA4 BF[4A05]                	MOV	DI,CLUSSAVE
 28249                                  MAPRET:
 28250                                  	;RESTORE <DX,CX,BX>
 28251 00005EA7 5A                      	pop	dx
 28252 00005EA8 59                      	pop	cx
 28253 00005EA9 5B                      	pop	bx
 28254 00005EAA 31C0                    	XOR	AX,AX			; MZ allow shift to clear carry
 28255 00005EAC 26817E0DF60F            	CMP	word [ES:BP+DPB.MAX_CLUSTER],4096-10 ; MZ is this 16-bit fat?
 28256 00005EB2 7302                    	JAE	short MapSet		; MZ no, set flags
 28257 00005EB4 89D8                    	MOV	AX,BX
 28258                                  MapSet:
 28259 00005EB6 A801                    	TEST	AL,1			; set zero flag if not on boundary
 28260                                  	;RESTORE <AX>
 28261 00005EB8 58                      	pop	ax
 28262 00005EB9 C3                      	retn
 28263                                  
 28264                                  MAP_POP:
 28265                                  	;RESTORE <DX,CX,BX,AX>
 28266 00005EBA 5A                      	pop	dx
 28267 00005EBB 59                      	pop	cx
 28268 00005EBC 5B                      	pop	bx
 28269 00005EBD 58                      	pop	ax
 28270 00005EBE C3                      	retn
 28271                                  
 28272                                  ;Break	<FATREAD_SFT/FATREAD_CDS -- CHECK DRIVE GET FAT>
 28273                                  ;----------------------------------------------------------------------------
 28274                                  ;
 28275                                  ; Procedure Name : FATREAD_SFT
 28276                                  ;
 28277                                  ; Inputs:
 28278                                  ;	ES:DI points to an SFT for the drive of intrest (local only,
 28279                                  ;		giving a NET SFT will produce system crashing results).
 28280                                  ;	DS DOSDATA
 28281                                  ; Function:
 28282                                  ;	Can be used by an SFT routine (like CLOSE) to invalidate buffers
 28283                                  ;	if disk changed.
 28284                                  ;	In other respects, same as FATREAD_CDS.
 28285                                  ;	(note ES:DI destroyed!)
 28286                                  ; Outputs:
 28287                                  ;	Carry set if error (currently user FAILed to I 24)
 28288                                  ; NOTE: This routine may cause FATREAD_CDS to "miss" a disk change
 28289                                  ;	as far as invalidating curdir_ID is concerned.
 28290                                  ;	Since getting a true disk changed on this call is a screw up
 28291                                  ;	anyway, that's the way it goes.
 28292                                  ;
 28293                                  ;---------------------------------------------------------------------------
 28294                                  
 28295                                  FATREAD_SFT:
 28296 00005EBF 26C46D07                	LES	BP,[ES:DI+SF_ENTRY.sf_devptr]
 28297                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 28298 00005EC3 268A4600                	mov	AL,[ES:BP]
 28299 00005EC7 A2[3305]                	MOV	[THISDRV],AL
 28300 00005ECA E8C5B8                  	call	GOTDPB			;Set THISDPB
 28301 00005ECD E87A00                  	CALL	FAT_GOT_DPB
 28302                                  fatread_sft_retn:
 28303 00005ED0 C3                      	retn
 28304                                  
 28305                                  ;----------------------------------------------------------------------------
 28306                                  ;
 28307                                  ; Procedure Name : FATREAD_CDS
 28308                                  ;
 28309                                  ; Inputs:
 28310                                  ;	DS:DOSDATA
 28311                                  ;	ES:DI points to an CDS for the drive of intrest (local only,
 28312                                  ;		giving a NET or NUL CDS will produce system crashing results).
 28313                                  ; Function:
 28314                                  ;	If disk may have been changed, media is determined and buffers are
 28315                                  ;	flagged invalid. If not, no action is taken.
 28316                                  ; Outputs:
 28317                                  ;	ES:BP = Drive parameter block
 28318                                  ;	THISDPB = ES:BP
 28319                                  ;	THISDRV set
 28320                                  ;	Carry set if error (currently user FAILed to I 24)
 28321                                  ; DS preserved , all other registers destroyed
 28322                                  ;
 28323                                  ;---------------------------------------------------------------------------
 28324                                  
 28325                                  FATREAD_CDS:
 28326 00005ED1 06                      	PUSH	ES
 28327 00005ED2 57                      	PUSH	DI
 28328                                  	;les	bp,[es:di+45h]
 28329 00005ED3 26C46D45                	LES	BP,[ES:DI+curdir.devptr]
 28330                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; [es:bp+0]
 28331 00005ED7 268A4600                	mov	AL,[ES:BP]
 28332 00005EDB A2[3305]                	MOV	[THISDRV],AL
 28333 00005EDE E8B1B8                  	call	GOTDPB			;Set THISDPB
 28334 00005EE1 E86600                  	CALL	FAT_GOT_DPB
 28335 00005EE4 5F                      	POP	DI			;Get back CDS pointer
 28336 00005EE5 07                      	POP	ES
 28337 00005EE6 72E8                    	jc	short fatread_sft_retn
 28338 00005EE8 7539                    	JNZ	short NO_CHANGE		;Media NOT changed
 28339                                  
 28340                                  ;	Media changed. We now need to find all CDS structures which use this
 28341                                  ;	DPB and invalidate their ID pointers.
 28342                                  
 28343                                  MED_CHANGE:
 28344 00005EEA 31C0                    	XOR	AX,AX
 28345 00005EEC 48                      	DEC	AX			; AX = -1
 28346 00005EED 1E                      	PUSH	DS
 28347 00005EEE 8A0E[4700]              	MOV	CL,[CDSCOUNT]
 28348 00005EF2 30ED                    	XOR	CH,CH			; CX is number of structures
 28349                                  	;lds	si,[es:di+45h]
 28350 00005EF4 26C57545                	LDS	SI,[ES:DI+curdir.devptr] ; Find all CDS with this devptr
 28351                                  
 28352                                  ;hkn; SS override
 28353                                  
 28354                                  ;	Find all CDSs with this DevPtr
 28355                                  ;
 28356                                  ;	(ax) = -1
 28357                                  ;	(ds:si) = DevPtr
 28358                                  
 28359 00005EF8 36C43E[3C00]            	LES	DI,[SS:CDSADDR]		; (es:di) = CDS pointer
 28360                                  frcd20: 
 28361                                  	;test	word [es:di+43h],8000h
 28362 00005EFD 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 28363 00005F03 7518                    	JNZ	short frcd25		; Leave NET guys alone!!
 28364                                  
 28365                                  	; MSDOS 3.3
 28366                                  	;push	es
 28367                                  	;push	di
 28368                                  	;les	di,[es:di+45h]
 28369                                  	;;les	di,[ES:DI+curdir.devptr]
 28370                                  	;call	POINTCOMP
 28371                                  	;pop	di
 28372                                  	;pop	es
 28373                                  	;jnz	short frcd25
 28374                                  
 28375                                  	; MSDOS 6.0
 28376 00005F05 263B7545                	cmp	si,[ES:DI+curdir.devptr]
 28377 00005F09 7512                    	jne	short frcd25		; no match
 28378 00005F0B 8CDB                    	mov	bx,ds
 28379 00005F0D 263B5D47                	cmp	bx,[ES:DI+curdir.devptr+2]
 28380 00005F11 750A                    	jne	short frcd25		; CDS not for this drive
 28381                                  
 28382                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28383                                  	;test	[es:di+49h],ax
 28384 00005F13 26854549                	test	[ES:DI+curdir.ID],AX
 28385 00005F17 7404                    	JZ	short frcd25		; If root (0), leave root
 28386                                  	;mov	[es:di+49h],ax
 28387 00005F19 26894549                	MOV	[ES:DI+curdir.ID],AX	; else invalid
 28388                                  frcd25:	
 28389                                  	;add	di,81 ; MSDOS 3.3
 28390                                  	;add	di,88 ; MSDOS 6.0
 28391 00005F1D 83C751                  	ADD	DI,curdir.size	; 81	; Point to next CDS
 28392 00005F20 E2DB                    	LOOP	frcd20
 28393 00005F22 1F                      	POP	DS
 28394                                  NO_CHANGE:
 28395 00005F23 C42E[4605]              	LES	BP,[THISDPB]
 28396 00005F27 F8                      	CLC
 28397 00005F28 C3                      	retn
 28398                                  
 28399                                  ;Break	<Fat_Operation - miscellaneous fat stuff>
 28400                                  ;----------------------------------------------------------------------------
 28401                                  ;
 28402                                  ; Procedure Name : FAT_operation
 28403                                  ;
 28404                                  ;----------------------------------------------------------------------------
 28405                                  FAT_operation:
 28406                                  	; 24/07/2019 - Retro DOS v3.2
 28407                                  	; 31/07/2018 - Retro DOS v3.0
 28408                                  FATERR:
 28409                                  	;mov	word [es:bp+1Eh],-1
 28410                                  	;mov	word [es:bp+1Fh],-1 ; MSDOS 6.0
 28411 00005F29 26C7461FFFFF            	MOV	word [ES:BP+DPB.FREE_CNT],-1 
 28412                                  					; Err in FAT must force recomp of freespace
 28413                                  	;and	di,0FFh
 28414 00005F2F 81E7FF00                	AND	DI,STECODE		; Put error code in DI
 28415                                  	;mov	byte [ALLOWED],18h
 28416 00005F33 C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 28417                                  	;mov	ah,1Ah
 28418 00005F38 B41A                    	MOV	AH,2+Allowed_FAIL+Allowed_RETRY ; While trying to read FAT
 28419 00005F3A A0[3305]                	MOV	AL,[THISDRV]		; Tell which drive
 28420 00005F3D E83CFC                  	call	FATAL1
 28421 00005F40 C42E[4605]              	LES	BP,[THISDPB]
 28422 00005F44 3C03                    	CMP	AL,3
 28423 00005F46 7502                    	JNZ	short FAT_GOT_DPB	; User said retry
 28424 00005F48 F9                      	STC				; User said FAIL
 28425 00005F49 C3                      	retn
 28426                                  
 28427                                  FAT_GOT_DPB:
 28428                                  	;Context DS			;hkn; SS is DOSDATA
 28429 00005F4A 16                      	push	ss			
 28430 00005F4B 1F                      	pop	ds
 28431                                  	;mov	al,0Fh
 28432 00005F4C B00F                    	MOV	AL,DMEDHL
 28433                                  	;mov	al,[es:bp+1]
 28434 00005F4E 268A6601                	MOV	AH,[ES:BP+DPB.UNIT] 
 28435 00005F52 A3[2403]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018 
 28436 00005F55 C606[2603]01            	MOV	BYTE [DEVCALL_REQFUNC],DEVMDCH
 28437 00005F5A C706[2703]0000          	MOV	word [DEVCALL_REQSTAT],0
 28438                                  	;;mov	al,[es:bp+16h]
 28439                                  	;mov	al,[es:bp+17h] ; MSDOS 6.0
 28440 00005F60 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 28441 00005F64 A2[3103]                	MOV	[CALLMED],AL
 28442 00005F67 06                      	PUSH	ES
 28443 00005F68 1E                      	PUSH	DS
 28444                                  
 28445                                  ;hkn; DEVCALL is in DOSDATA
 28446 00005F69 BB[2403]                	MOV	BX,DEVCALL
 28447                                  	;;lds	si,[es:bp+12h]
 28448                                  	;lds	si,[es:bp+13h] ; MSDOS 6.0
 28449 00005F6C 26C57613                	LDS	SI,[ES:BP+DPB.DRIVER_ADDR] ; DS:SI Points to device header
 28450 00005F70 07                      	POP	ES			; ES:BX Points to call header
 28451 00005F71 E8BEF1                  	call	DEVIOCALL2
 28452                                  	;Context DS		 	;hkn; SS is DOSDATA
 28453 00005F74 16                      	push	ss
 28454 00005F75 1F                      	pop	ds
 28455 00005F76 07                      	POP	ES			; Restore ES:BP
 28456 00005F77 8B3E[2703]              	MOV	DI,[DEVCALL_REQSTAT]
 28457                                  	;test	di,8000h
 28458                                  	;jnz	short FATERR
 28459 00005F7B 09FF                    	or	di,di
 28460 00005F7D 78AA                    	js	short FATERR		; have error
 28461 00005F7F 30E4                    	XOR	AH,AH
 28462                                  	;xchg	ah,[es:bp+17h] ; MSDOS 3.3
 28463                                  	;xchg	ah,[es:bp+18h] ; MSDOS 6.0
 28464 00005F81 26866618                	XCHG	AH,[ES:BP+DPB.FIRST_ACCESS] ; Reset dpb_first_access
 28465 00005F85 A0[3305]                	MOV	AL,[THISDRV]		; Use physical unit number
 28466                                  ; See if we had changed volume id by creating one on the diskette
 28467 00005F88 3806[370A]              	cmp	[VOLCHNG_FLAG],AL
 28468 00005F8C 7508                    	jnz	short CHECK_BYT
 28469 00005F8E C606[370A]FF            	mov	byte [VOLCHNG_FLAG],-1
 28470 00005F93 E98800                  	jmp	GOGETBPB		; Need to get device driver to read in
 28471                                  					; new volume label.
 28472                                  CHECK_BYT:
 28473 00005F96 0A26[3203]              	OR	AH,[CALLRBYT]
 28474                                  	;JNS	short CHECK_ZR		; ns = 0 or 1
 28475                                  	;JMP	short NEWDSK
 28476 00005F9A 785D                    	js	short NEWDSK
 28477                                  CHECK_ZR:
 28478 00005F9C 743D                    	JZ	short CHKBUFFDIRT	; jump if I don't know
 28479 00005F9E F8                      	CLC
 28480 00005F9F C3                      	retn				; If Media not changed (NZ)
 28481                                  
 28482                                  DISK_CHNG_ERR:
 28483 00005FA0 06                      	PUSH	ES
 28484 00005FA1 55                      	PUSH	BP
 28485                                  	;;les	bp,[es:bp+12h]
 28486                                  	;les	bp,[es:bp+13h] ; MSDOS 6.0
 28487 00005FA2 26C46E13                	LES	BP,[ES:BP+DPB.DRIVER_ADDR] ; Get device pointer
 28488                                  	;test	word [es:bp+4],800h
 28489 00005FA6 26F746040008            	TEST	word [ES:BP+SYSDEV.ATT],DEVOPCL ; Did it set vol id?
 28490 00005FAC 5D                      	POP	BP
 28491 00005FAD 07                      	POP	ES
 28492 00005FAE 7426                    	JZ	short FAIL_OPJ2		; Nope, FAIL
 28493 00005FB0 1E                      	PUSH	DS			; Save buffer pointer for ignore
 28494 00005FB1 57                      	PUSH	DI
 28495 00005FB2 16                      	push	ss			;hkn; SS is DOSDATA
 28496 00005FB3 1F                      	pop	ds
 28497                                  	;mov	byte [ALLOWED],18h
 28498 00005FB4 C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 28499 00005FB9 06                      	PUSH	ES
 28500 00005FBA C43E[3303]              	LES	DI,[CALLVIDM]		; Get volume ID pointer
 28501 00005FBE 8C06[F602]              	MOV	[EXTERRPT+2],ES
 28502 00005FC2 07                      	POP	ES
 28503 00005FC3 893E[F402]              	MOV	[EXTERRPT],DI
 28504                                  	;mov	ax,0Fh
 28505 00005FC7 B80F00                  	MOV	AX,error_I24_wrong_disk
 28506 00005FCA C606[3205]01            	MOV	byte [READOP],1		; Write
 28507                                  	;invoke	HARDERR
 28508 00005FCF E858FB                  	call	HARDERR
 28509 00005FD2 5F                      	POP	DI			; Get back buffer for ignore
 28510 00005FD3 1F                      	POP	DS
 28511 00005FD4 3C03                    	CMP	AL,3
 28512                                  FAIL_OPJ2:
 28513 00005FD6 7416                    	JZ	short FAIL_OP
 28514 00005FD8 E96FFF                  	JMP	FAT_GOT_DPB		; Retry
 28515                                  
 28516                                  CHKBUFFDIRT:
 28517                                  	; 24/07/2019 - Retro DOS v3.2
 28518                                  
 28519                                  	; MSDOS 6.0
 28520                                  	;cmp	word [DirtyBufferCount],0	; any dirty buffers ? ;hkn;
 28521                                  	;je	short NEWDSK			; no, skip the check
 28522                                  	;call	GetCurHead			; get pointer to first buffer
 28523                                  
 28524                                  	; MSDOS 3.3
 28525 00005FDB C53E[3800]              	lds	di,[BUFFHEAD]
 28526                                  nbuffer:
 28527                                  	;cmp	al,[di+4]
 28528 00005FDF 384504                  	cmp	[di+BUFFINFO.buf_ID],al	; Unit OK ?
 28529 00005FE2 750E                    	jne	short lfnxt			; no, go for next buffer
 28530                                  	;test   byte [di+5],40h
 28531 00005FE4 F6450540                	TEST	byte [di+BUFFINFO.buf_flags],buf_dirty ; is the buffer dirty ?
 28532 00005FE8 7408                    	jz	short lfnxt			; no, go for next buffer
 28533                                  	;Context DS
 28534 00005FEA 16                      	push	ss
 28535 00005FEB 1F                      	pop	ds
 28536 00005FEC F8                      	clc
 28537 00005FED C3                      	retn
 28538                                  
 28539                                  FAIL_OP:					; This label & code is here
 28540                                  	;Context DS				;  for reachability
 28541 00005FEE 16                      	push	ss
 28542 00005FEF 1F                      	pop	ds
 28543 00005FF0 F9                      	STC
 28544 00005FF1 C3                      	retn
 28545                                  
 28546                                  lfnxt:
 28547                                  	; 24/07/2019 - Retro DOS v3.2
 28548                                  	; 20/05/2019 - Retro DOS v4.0
 28549                                  	; 15/08/2018
 28550                                  	;mov	di,[di]
 28551                                  	;mov	di,[di+BUFFINFO.buf_next]	; get next buffer
 28552                                  	;
 28553 00005FF2 C53D                    	lds	di,[di]
 28554                                  	;
 28555                                  	; MSDOS 6.0
 28556                                  	;cmp	[FIRST_BUFF_ADDR],di		; is this where we started ?;hkn;
 28557                                  	;jne	short nbuffer			; no, check this guy also
 28558                                  	; MSDOS 3.3
 28559 00005FF4 83FFFF                  	cmp	di,-1
 28560 00005FF7 75E6                    	jne	short nbuffer
 28561                                  
 28562                                  ; If no dirty buffers, assume Media changed
 28563                                  NEWDSK:
 28564                                  	;;mov	word [es:bp+1Eh],0FFFFh  ; MSDOS 3.3
 28565                                  	;mov	word [es:bp+1Fh],0FFFFh  ; MSDOS 6.0
 28566 00005FF9 26C7461FFFFF            	mov	word [ES:BP+DPB.FREE_CNT],-1	; Media changed, must
 28567                                  	; MSDOS 6.0				;  recompute
 28568                                  	;call	GetCurHead
 28569                                  	; MSDOS 3.3
 28570 00005FFF E8BE00                  	call	SETVISIT
 28571                                  nxbuffer:
 28572                                  	; MSDOS 3.3
 28573 00006002 804D0520                	or 	byte [di+5],20h
 28574                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28575                                  	;cmp	[di+4],al
 28576 00006006 384504                  	cmp	[DI+BUFFINFO.buf_ID],al		; This drive ?
 28577 00006009 750E                    	jne	short lfnxt2
 28578                                  	;test	byte [di+5],40h
 28579 0000600B F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 28580 0000600F 758F                    	jnz	short DISK_CHNG_ERR
 28581                                  	;mov	word [di+4],20FFh
 28582 00006011 C74504FF20              	mov	word [DI+BUFFINFO.buf_ID],(buf_visit*256)+0FFh ; free up
 28583 00006016 E8D400                  	call	SCANPLACE
 28584                                  	; MSDOS 6.0
 28585                                  	;jmp	short skpbuff
 28586                                  ;lfnxt2:
 28587                                  	;;mov	di,[di+BUFFINFO.buf_next]
 28588                                  	;mov	di,[di]
 28589                                  ;skpbuff:
 28590                                  	;cmp	di,[FIRST_BUFF_ADDR]					;hkn;
 28591                                  	;jne	short nxbuffer
 28592                                  
 28593                                  	;CMP	word [SC_CACHE_COUNT],0	;LB.  look ahead buffers ?	;AN001;
 28594                                  	;JZ	short GOGETBPB		;LB.  no			;AN001;
 28595                                  	;CMP	AL,[CURSC_DRIVE]	;LB.  same as changed drive	;AN001;
 28596                                  	;JNZ	short GOGETBPB		;LB.  no			;AN001;
 28597                                  	;MOV	byte [CURSC_DRIVE],-1	;LB.  invalidate look ahead buffers ;AN000;
 28598                                  lfnxt2:
 28599                                  	; MSDOS 3.3
 28600 00006019 E8BD00                  	call	SKIPVISIT
 28601 0000601C 75E4                    	jnz	short nxbuffer
 28602                                  GOGETBPB:
 28603                                  	; MSDOS 3.3 & MSDOS 6.0
 28604                                  	;;lds	di,[es:bp+12h]
 28605                                  	;lds	di,[es:bp+13h] ; MSDOS 6.0
 28606 0000601E 26C57E13                	LDS	DI,[ES:BP+DPB.DRIVER_ADDR]
 28607                                  	; 20/05/2019
 28608                                  	;test	word [di+4],2000h
 28609                                  	;TEST	word [DI+SYSDEV.ATT],ISFATBYDEV
 28610 00006022 F6450520                	TEST	byte [DI+SYSDEV.ATT+1],(ISFATBYDEV>>8)
 28611 00006026 7510                    	JNZ	short GETFREEBUF
 28612                                  	;context DS	    		;hkn; SS is DOSDATA
 28613 00006028 16                      	push	ss
 28614 00006029 1F                      	pop	ds
 28615 0000602A BB0200                  	MOV	BX,2
 28616 0000602D E8FFFC                  	CALL	UNPACK			; Read the first FAT sector into CURBUF
 28617                                  FAIL_OPJ:
 28618 00006030 72BC                    	JC	short FAIL_OP
 28619 00006032 C53E[9E05]              	LDS	DI,[CURBUF]
 28620 00006036 EB15                    	JMP	SHORT GOTGETBUF
 28621                                  
 28622                                  GETFREEBUF:
 28623                                  	; 24/07/2019 - Retro DOS v3.2
 28624 00006038 06                      	PUSH	ES			; Get a free buffer for BIOS to use
 28625 00006039 55                      	PUSH	BP
 28626                                  	; MSDOS 3.3
 28627 0000603A 36C53E[3800]            	LDS	DI,[SS:BUFFHEAD] ; 15/08/2018
 28628                                  	; 25/07/2019
 28629                                  	; MSDOS 6.0
 28630 0000603F 31D2                    	XOR	DX,DX			;LB.  fake to get 1st	  ;AN000;
 28631                                  ;hkn; SS override
 28632 00006041 368916[B005]            	MOV	[SS:HIGH_SECTOR],DX	;LB.  buffer addr	  ;AN000;
 28633                                  	;call	GETCURHEAD		;LB.			  ;AN000;
 28634                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28635 00006046 E87402                  	call	BUFWRITE
 28636 00006049 5D                      	POP	BP
 28637 0000604A 07                      	POP	ES
 28638                                  	;JC	short FAIL_OPJ
 28639 0000604B 72A1                    	jc	short FAIL_OP
 28640                                  GOTGETBUF:
 28641                                  	;;add	di,16
 28642                                  	;add	di,20 ; MSDOS 6.0
 28643 0000604D 83C714                  	ADD	DI,BUFINSIZ
 28644                                  
 28645                                  ;hkn; SS override
 28646 00006050 368C1E[3403]            	MOV	[SS:CALLXAD+2],DS
 28647                                  	;Context DS			;hkn; SS is DOSDATA
 28648 00006055 16                      	push	ss
 28649 00006056 1F                      	pop	ds
 28650 00006057 893E[3203]              	MOV	[CALLXAD],DI
 28651                                  	;mov	al,16h
 28652 0000605B B016                    	MOV	AL,DBPBHL
 28653                                  	;mov	ah,[es:bp+1]
 28654 0000605D 268A6601                	MOV	AH,[ES:BP+DPB.UNIT]
 28655 00006061 A3[2403]                	MOV	[DEVCALL_REQLEN],AX ; 09/09/2018
 28656 00006064 C606[2603]02            	MOV	BYTE [DEVCALL_REQFUNC],DEVBPB
 28657 00006069 C706[2703]0000          	MOV	word [DEVCALL_REQSTAT],0
 28658                                  	;mov	al,[es:bp+16h]
 28659 0000606F 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 28660 00006073 A2[3103]                	MOV	[CALLMED],AL
 28661 00006076 06                      	PUSH	ES
 28662 00006077 1E                      	PUSH	DS
 28663                                  	;;push	word [es:bp+14h]
 28664                                  	;push	word [es:bp+15h] ; MSDOS 6.0
 28665 00006078 26FF7615                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR+2]
 28666                                  	;;push	word [es:bp+12h]
 28667                                  	;push	word [es:bp+13h] ; MSDOS 6.0
 28668 0000607C 26FF7613                	PUSH	WORD [ES:BP+DPB.DRIVER_ADDR]
 28669                                  
 28670                                  ;hkn; DEVCALL is in DOSDATA
 28671 00006080 BB[2403]                	MOV	BX,DEVCALL
 28672 00006083 5E                      	POP	SI
 28673 00006084 1F                      	POP	DS			; DS:SI Points to device header
 28674 00006085 07                      	POP	ES			; ES:BX Points to call header
 28675                                  	;invoke	DEVIOCALL2
 28676 00006086 E8A9F0                  	call	DEVIOCALL2
 28677 00006089 07                      	POP	ES			; Restore ES:BP
 28678                                  	;Context DS
 28679 0000608A 16                      	push	ss		 	;hkn; SS is DOSDATA
 28680 0000608B 1F                      	pop	ds
 28681 0000608C 8B3E[2703]              	MOV	DI,[DEVCALL_REQSTAT]
 28682                                  	; MSDOS 3.3
 28683                                  	;test	di,8000h
 28684                                  	;jnz	short FATERRJ
 28685                                  	; MSDOS 6.0
 28686 00006090 09FF                    	or	di,di
 28687 00006092 7829                    	js	short FATERRJ 		; have error
 28688                                  	;;mov	al,[es:bp+16h]
 28689                                  	;mov	al,[es:bp+17h]  ; MSDOS 6.0
 28690 00006094 268A4617                	MOV	AL,[ES:BP+DPB.MEDIA]
 28691 00006098 C536[3603]              	LDS	SI,[CALLBPB]
 28692                                  	;;mov	word [es:bp+1Ch],0
 28693                                  	;mov	word [es:bp+1Dh],0 ; MSDOS 6.0
 28694 0000609C 26C7461D0000            	MOV	word [ES:BP+DPB.NEXT_FREE],0 ; recycle scanning pointer
 28695                                  	;invoke	$SETDPB
 28696 000060A2 E879BD                  	call	_$SETDPB
 28697                                  
 28698                                  ;hkn; SS override
 28699 000060A5 36C53E[3203]            	LDS	DI,[SS:CALLXAD]		; Get back buffer pointer
 28700                                  	;mov	al,[es:bp+8]
 28701 000060AA 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]
 28702                                  
 28703                                  	; 24/07/2019 - Retro DOS v3.2
 28704                                  
 28705                                  	; MSDOS 3.3
 28706                                  	;;mov	ah,[es:bp+0Fh]
 28707                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 28708                                  	;;mov	[DI-8],ax
 28709                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AX
 28710                                  
 28711                                  	; MSDOS 6.0
 28712                                  	;mov	[di-0Ah],al
 28713 000060AE 8845F6                  	MOV	[DI+BUFFINFO.buf_wrtcnt-BUFINSIZ],AL  
 28714                                  					;>32mb	  ;AN000;
 28715                                  	;mov	ax,[es:bp+0Fh]
 28716 000060B1 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]	;>32mb
 28717                                  	;mov	[di-9h],ax			  ;AC000;
 28718 000060B5 8945F7                  	MOV	[DI+BUFFINFO.buf_wrtcntinc-BUFINSIZ],AX 
 28719                                  
 28720                                  	;Context DS			;hkn; SS is DOSDATA
 28721 000060B8 16                      	push	ss
 28722 000060B9 1F                      	pop	ds
 28723 000060BA 30C0                    	XOR	AL,AL			;Media changed (Z), Carry clear
 28724 000060BC C3                      	retn
 28725                                  
 28726                                  FATERRJ: 
 28727 000060BD E969FE                  	JMP	FATERR
 28728                                  
 28729                                  ;============================================================================
 28730                                  ; STDBUF.ASM
 28731                                  ;============================================================================
 28732                                  ; Retro DOS v2.0 - 12/03/2018
 28733                                  
 28734                                  ;
 28735                                  ; Standard buffer management for MSDOS
 28736                                  ;
 28737                                  
 28738                                  ;.xlist
 28739                                  ;.xcref
 28740                                  ;INCLUDE STDSW.ASM
 28741                                  ;.cref
 28742                                  ;.list
 28743                                  
 28744                                  ;TITLE	STDBUF - MSDOS buffer management
 28745                                  ;NAME	STDBUF
 28746                                  
 28747                                  ;INCLUDE BUF.ASM
 28748                                  
 28749                                  ;============================================================================
 28750                                  ; BUF.ASM
 28751                                  ;============================================================================
 28752                                  ; 31/07/2018 - Retro DOS v3.0
 28753                                  ; Retro DOS v2.0 - 12/03/2018
 28754                                  
 28755                                  ;
 28756                                  ; buffer management for MSDOS
 28757                                  ;
 28758                                  
 28759                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 28760                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 28761                                  
 28762                                  ;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS
 28763                                  
 28764                                  SETVISIT:
 28765                                  	; 31/07/2018 - Retro DOS v3.0
 28766                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CAFh
 28767                                  ; Inputs:
 28768                                  ;       None
 28769                                  ; Function:
 28770                                  ;       Set up a scan of I/O buffers
 28771                                  ; Outputs:
 28772                                  ;       All visit flags = 0
 28773                                  ;               NOTE: This pre-scan is needed because a hard disk error
 28774                                  ;                     may cause a scan to stop in the middle leaving some
 28775                                  ;                     visit flags set, and some not set.
 28776                                  ;       DS:DI Points to [BUFFHEAD]
 28777                                  ; No other registers altered
 28778                                  
 28779 000060C0 36C53E[3800]                    LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 28780 000060C5 50                      	PUSH    AX
 28781                                          ;;XOR	AX,AX	  ;; MSDOS 2.11
 28782                                  	;mov	al,0DFh
 28783 000060C6 B0DF                    	mov	al,~buf_visit
 28784                                  SETLOOP:
 28785                                          ;;MOV	[DI+7],AL ;; MSDOS 2.11
 28786                                  	;and	[DI+5],al
 28787 000060C8 204505                  	AND	[DI+BUFFINFO.buf_flags],AL
 28788 000060CB C53D                            LDS     DI,[DI]
 28789 000060CD 83FFFF                          CMP     DI,-1
 28790 000060D0 75F6                            JNZ     SHORT SETLOOP
 28791 000060D2 58                              POP     AX ; 09/09/2018
 28792 000060D3 36C53E[3800]            	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
 28793                                  SVISIT_RETN:
 28794 000060D8 C3                              RETN
 28795                                  
 28796                                  SKIPVISIT:
 28797                                  	; 31/07/2018 - Retro DOS v3.0
 28798                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5CC8h
 28799                                  
 28800                                  ; Inputs:
 28801                                  ;       DS:DI Points to a buffer
 28802                                  ; Function:
 28803                                  ;       Skip visited buffers
 28804                                  ; Outputs:
 28805                                  ;       DS:DI Points to next unvisited buffer
 28806                                  ;       Zero is set if skip to LAST buffer
 28807                                  ; No other registers altered
 28808                                  
 28809 000060D9 83FFFF                          CMP     DI,-1
 28810                                          ;retz
 28811 000060DC 74FA                            JZ	SHORT SVISIT_RETN  ; zf = 1 
 28812                                  
 28813                                  	;;CMP	BYTE [DI+7],1 ;; MSDOS 2.11
 28814                                          ;;;retnz
 28815                                          ;;JNZ	SHORT SVISIT_RETN
 28816                                  
 28817                                  	;test	byte [di+5],20h
 28818 000060DE F6450520                	TEST	byte [DI+BUFFINFO.buf_flags],buf_visit	
 28819 000060E2 7505                    	JNZ	short SKIPLOOP
 28820                                  	
 28821 000060E4 50                      	push	ax
 28822 000060E5 0C01                    	or	al,1
 28823 000060E7 58                      	pop	ax
 28824                                  		; zf = 0
 28825 000060E8 C3                      	retn	
 28826                                  
 28827                                  SKIPLOOP:
 28828 000060E9 C53D                    	LDS     DI,[DI]
 28829 000060EB EBEC                            JMP     SHORT SKIPVISIT
 28830                                  
 28831                                  ;============================================================================
 28832                                  ; BUF.ASM, MSDOS 6.0, 1991
 28833                                  ;============================================================================
 28834                                  ; 31/07/2018 - Retro DOS v3.0
 28835                                  
 28836                                  ;	TITLE	BUF - MSDOS buffer management
 28837                                  ;	NAME	BUF
 28838                                  
 28839                                  ;**	BUF.ASM - Low level routines for buffer cache management
 28840                                  ;
 28841                                  ;	GETCURHEAD
 28842                                  ;	ScanPlace
 28843                                  ;	PLACEBUF
 28844                                  ;	PLACEHEAD
 28845                                  ;	PointComp
 28846                                  ;	GETBUFFR
 28847                                  ;	GETBUFFRB
 28848                                  ;	FlushBuf
 28849                                  ;	BufWrite
 28850                                  ;	SET_RQ_SC_PARMS
 28851                                  ;
 28852                                  ;	Revision history:
 28853                                  ;
 28854                                  ;		AN000  version 4.00  Jan. 1988
 28855                                  ;		A004   PTM 3765 -- Disk reset failed
 28856                                  ;		M039 DB 10/17/90 - Disk write optimization
 28857                                  ;		I001   5.0 PTR 722211 - Preserve CY when in buffer in HMA
 28858                                  
 28859                                  ;Break	<GETCURHEAD -- Get current buffer header>
 28860                                  ;----------------------------------------------------------------------------
 28861                                  ; Procedure Name : GetCurHead
 28862                                  ; Inputs:
 28863                                  ;	 No Inputs
 28864                                  ; Function:
 28865                                  ;	Returns the pointer to the first buffer in Queue
 28866                                  ;	and updates FIRST_BUFF_ADDR
 28867                                  ;       and invalidates LASTBUFFER (recency pointer)
 28868                                  ; Outputs:
 28869                                  ;	DS:DI = pointer to the first buffer in Queue
 28870                                  ;	FIRST_BUFF_ADDR = offset ( DI ) of First buffer in Queue
 28871                                  ;       LASTBUFFER = -1
 28872                                  ; No other registers altered
 28873                                  ;----------------------------------------------------------------------------
 28874                                  
 28875                                  ;procedure   GETCURHEAD,NEAR
 28876                                  ;
 28877                                  ;	lds	di, BufferQueue		; Pointer to the first buffer;smr;SS Override
 28878                                  ;	mov	word ptr [LastBuffer],-1; invalidate last buffer;smr;SS Override
 28879                                  ;	mov	[FIRST_BUFF_ADDR],di	;save first buffer addr;smr;SS Override
 28880                                  ;	ret
 28881                                  ;
 28882                                  ;EndProc GETCURHEAD
 28883                                  
 28884                                  ;Break	<SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL>
 28885                                  ;----------------------------------------------------------------------------
 28886                                  ; Procedure Name : ScanPlace
 28887                                  ; Inputs:
 28888                                  ;	Same as PLACEBUF
 28889                                  ; Function:
 28890                                  ;	Save scan location and call PLACEBUF
 28891                                  ; Outputs:
 28892                                  ;	DS:DI Points to saved scan location
 28893                                  ; All registers, except DS:DI, preserved.
 28894                                  ;----------------------------------------------------------------------------
 28895                                  ;M039: Rewritten to preserve registers.
 28896                                  
 28897                                  SCANPLACE:
 28898                                  	; 31/07/2018 - Retro DOS v3.0
 28899                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 28900 000060ED 06                      	push	es
 28901 000060EE C435                    	les	si,[di]
 28902                                  	;les	si,[DI+BUFFINFO.buf_link]
 28903 000060F0 E80600                  	call	PLACEBUF
 28904 000060F3 06                      	push	es
 28905 000060F4 1F                      	pop	ds
 28906 000060F5 89F7                    	mov	di,si
 28907 000060F7 07                      	pop	es
 28908                                  scanplace_retn:
 28909 000060F8 C3                      	retn	
 28910                                  	
 28911                                  	; MSDOS 6.0
 28912                                  ;ScanPlace:
 28913                                  	;push	word [di+BUFFINFO.buf_next]	;Save scan location
 28914                                  	;call	PLACEBUF
 28915                                  	;pop	di
 28916                                  	;retn
 28917                                  
 28918                                  ;----------------------------------------------------------------------------
 28919                                  ; Procedure Name : PlaceBuf
 28920                                  ; Input:
 28921                                  ;	DS:DI points to buffer (DS->BUFFINFO array, DI=offset in array)
 28922                                  ; Function:
 28923                                  ;	Remove buffer from queue and re-insert it in proper place.
 28924                                  ; NO registers altered
 28925                                  ;----------------------------------------------------------------------------
 28926                                  
 28927                                  ;procedure   PLACEBUF,NEAR
 28928                                  
 28929                                  ;PLACEBUF:
 28930                                  	; 31/07/2018 - Retro DOS v3.0
 28931                                  
 28932                                  	; MSDOS 6.0
 28933                                  	;push	AX			;Save only regs we modify	;AN000;
 28934                                  	;push	BX							;AN000;
 28935                                  	;push	SI							;AN000;
 28936                                  	;mov	ax,[di].BUF_NEXT
 28937                                  	;mov	bx,word ptr[BufferQueue]	; bx = offset of head of list;smr;SS Override
 28938                                  	;
 28939                                  	;cmp	ax,bx				;Buf = last?		;AN000;
 28940                                  	;je	nret				;Yes, special case	;AN000;
 28941                                  	;cmp	di,bx				;Buf = first?		;AN000;
 28942                                  	;jne	not_first 			;Yes, special case	;AN000;
 28943                                  	;mov	word ptr [BufferQueue],ax	;smr;SS Override
 28944                                  	;jmp	short nret 			;Continue with repositioning;AN000;
 28945                                  ;not_first:
 28946                                  	;mov	SI,[DI].BUF_PREV		;No, SI = prior Buf	;AN000;
 28947                                  	;mov	[SI].BUF_NEXT,AX		; ax has di->buf_next	;AN000;
 28948                                  	;xchg	si, ax
 28949                                  	;mov	[SI].BUF_PREV,AX		;			;AN000;
 28950                                  	;
 28951                                  	;mov	SI,[BX].BUF_PREV		;SI-> last buffer	;AN000;
 28952                                  	;mov	[SI].BUF_NEXT,DI		;Add Buf to end of list ;AN000;
 28953                                  	;mov	[BX].BUF_PREV,DI					;AN000;
 28954                                  	;mov	[DI].BUF_PREV,SI		;Update link in Buf too	;AN000;
 28955                                  	;mov	[DI].BUF_NEXT,BX					;AN000;
 28956                                  ;nret:									;AN000;
 28957                                  	;pop	SI							;AN000;
 28958                                  	;pop	BX							;AN000;
 28959                                  	;pop	AX							;AN000;
 28960                                  	;								;AN000;
 28961                                  	;cmp	[di.buf_ID],-1			; Buffer FREE?		;AN000;
 28962                                          ;jne	pbx                             ; M039: -no, jump.
 28963                                  	;mov	WORD PTR [BufferQueue],di	; M039: -yes, make it LRU.
 28964                                  ;pbx:	
 28965                                  ;	ret								;AN000;
 28966                                  
 28967                                  	; 31/07/2018 - Retro DOS v3.0
 28968                                  
 28969                                  	; MSDOS 3.3
 28970                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5DDCh
 28971                                  
 28972                                  PLACEBUF:
 28973                                  	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 28974                                  	
 28975 000060F9 E83AB5                          CALL	save_world
 28976 000060FC C40D                            LES     CX,[DI]
 28977 000060FE 83F9FF                          CMP     CX,-1           	; Buf is LAST?
 28978 00006101 744B                            JZ      SHORT NRET		; Buffer already last
 28979 00006103 8CC5                            MOV     BP,ES           	; Pointsave = Buf.nextbuf
 28980 00006105 1E                              PUSH    DS
 28981 00006106 07                              POP     ES              	; Buf is ES:DI
 28982                                  	; 15/03/2018
 28983 00006107 36C536[3800]                    LDS     SI,[SS:BUFFHEAD] 	; Curbuf = HEAD
 28984 0000610C E88200                          CALL    POINTCOMP       	; Buf == HEAD?
 28985 0000610F 750C                            JNZ     SHORT BUFLOOP
 28986 00006111 36890E[3800]                    MOV     [SS:BUFFHEAD],CX
 28987 00006116 36892E[3A00]                    MOV     [SS:BUFFHEAD+2],BP	; HEAD = Pointsave
 28988 0000611B EB14                            JMP     SHORT LOOKEND
 28989                                  
 28990                                  BUFLOOP:
 28991                                  	; 31/07/2018
 28992 0000611D 8CD8                    	mov	ax,ds
 28993 0000611F 89F3                    	mov	bx,si
 28994                                  	;lds	si,[SI+BUFFINFO.buf_link]
 28995 00006121 C534                            LDS     SI,[SI]
 28996 00006123 E86B00                          CALL    POINTCOMP
 28997 00006126 75F5                            jnz	short BUFLOOP
 28998                                  	;
 28999 00006128 8ED8                    	mov	ds,ax
 29000 0000612A 89DE                    	mov	si,bx
 29001 0000612C 890C                    	mov	[SI],cx
 29002                                  	;mov	[SI+BUFFINFO.buf_link],cx   ; If Curbuf.nextbuf == buf
 29003 0000612E 896C02                  	mov	[SI+2],bp
 29004                                  	;mov	[SI+BUFFINFO.buf_link+2],bp ; Curbuf.nextbuf = Pointsave
 29005                                  LOOKEND:
 29006 00006131 8CD8                    	mov	ax,ds
 29007 00006133 89F3                    	mov	bx,si
 29008 00006135 C534                            LDS     SI,[SI]
 29009 00006137 83FEFF                          CMP     SI,-1
 29010 0000613A 75F5                            jnz     short LOOKEND
 29011                                  GOTHEEND:
 29012 0000613C 8ED8                            mov	ds,ax
 29013 0000613E 893F                    	mov	[BX],di
 29014 00006140 8C4702                          MOV     [BX+2],ES 		; Curbuf.nextbuf = Buf
 29015 00006143 26C705FFFF                      MOV     WORD [ES:DI],-1
 29016                                  	;mov	word [ES:DI+BUFFINFO.buf_link],-1
 29017 00006148 26C74502FFFF                    MOV     WORD [ES:DI+2],-1 	; Buf is LAST
 29018                                  	;mov	word [ES:DI+BUFFINFO.buf_link+2],-1
 29019                                  NRET:
 29020 0000614E E8D2B4                          CALL	restore_world
 29021                                  	
 29022                                  	;cmp	byte [di+4],-1
 29023 00006151 807D04FF                	cmp	byte [DI+BUFFINFO.buf_ID],-1  ; Free buffer ?
 29024 00006155 75A1                    	jnz     short scanplace_retn
 29025                                  
 29026                                  	; 26/07/2019
 29027                                  	;call	PLACEHEAD
 29028                                  	;retn
 29029                                  	;jmp	PLACEHEAD
 29030                                  
 29031                                  ;EndProc PLACEBUF
 29032                                  
 29033                                  ;M039 - Removed PLACEHEAD.
 29034                                  ;----------------------------------------------------------------------------
 29035                                  ; places buffer at head
 29036                                  ;  NOTE:::::: ASSUMES THAT BUFFER IS CURRENTLY THE LAST
 29037                                  ;	ONE IN THE LIST!!!!!!!
 29038                                  ; BUGBUG ---- this routine can be removed because it has only
 29039                                  ; BUGBUG ---- one instruction. This routine is called from
 29040                                  ; BUGBUG ---- 3 places. ( Size = 3*3+6 = 15 bytes )
 29041                                  ; BUGBUG ---- if coded in line = 3 * 5 = 15 bytes
 29042                                  ; BUGBUG ---- But kept as it is for modularity
 29043                                  ;----------------------------------------------------------------------------
 29044                                  ;procedure   PLACEHEAD,NEAR
 29045                                  ;	mov	word ptr [BufferQueue], di
 29046                                  ;	ret
 29047                                  ;EndProc PLACEHEAD
 29048                                  ;M039
 29049                                  
 29050                                  ;----------------------------------------------------------------------------
 29051                                  ; Procedure Name : PLACEHEAD
 29052                                  ;
 29053                                  ; SAME AS PLACEBUF except places buffer at head
 29054                                  ;----------------------------------------------------------------------------
 29055                                  
 29056                                  	; MSDOS 3.3 (Retro DOS v3.0)
 29057                                  	; 05/09/2018
 29058                                  	; MSDOS 2.11 (Retro DOS v2.0)
 29059                                  PLACEHEAD:
 29060                                  	; 31/07/2018 - Retro DOS v3.0
 29061                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D4Ah
 29062                                  
 29063 00006157 E8DCB4                          CALL	save_world
 29064 0000615A 1E                              PUSH	DS
 29065 0000615B 07                              POP	ES
 29066                                  	; 15/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
 29067 0000615C 36C536[3800]                    LDS     SI,[SS:BUFFHEAD]
 29068                                  	; 31/07/2018 - Retro DOS v3.0 (MSDOS 3.3)
 29069 00006161 E82D00                  	CALL	POINTCOMP
 29070 00006164 7427                            JZ      SHORT GOTHEEND2
 29071 00006166 268935                  	MOV	[ES:DI],SI
 29072                                  	;mov	[ES:DI+BUFFINFO.buf_link],si
 29073 00006169 268C5D02                        MOV	[ES:DI+2],DS
 29074                                  	;mov	[ES:DI+BUFFINFO.buf_link+2],ds
 29075 0000616D 36893E[3800]                    MOV	[SS:BUFFHEAD],DI
 29076 00006172 368C06[3A00]                    MOV	[SS:BUFFHEAD+2],ES
 29077                                  LOOKEND2:
 29078 00006177 8CD8                            mov	ax,ds
 29079 00006179 89F3                    	mov	bx,si
 29080                                  	;lds	si,[SI+BUFFINFO.buf_link]
 29081 0000617B C534                            LDS     SI,[SI]
 29082 0000617D E81100                          CALL    POINTCOMP
 29083 00006180 75F5                            JNZ	SHORT LOOKEND2 ; 05/09/2018
 29084 00006182 8ED8                            mov	ds,ax
 29085 00006184 C707FFFF                	mov	word [bx],-1
 29086                                  	;mov	word [BX+BUFFINFO.buf_link],-1
 29087 00006188 C74702FFFF              	mov	word [bx+2],-1
 29088                                  	;mov	word [BX+BUFFINFO.buf_link+2],-1
 29089                                  GOTHEEND2:
 29090 0000618D E893B4                         	call	restore_world
 29091                                  placehead_retn:
 29092 00006190 C3                      	retn
 29093                                  
 29094                                  ;Break	<POINTCOMP -- 20 BIT POINTER COMPARE>
 29095                                  ;----------------------------------------------------------------------------
 29096                                  ;
 29097                                  ; Procedure Name : PointComp
 29098                                  ; Inputs:
 29099                                  ;         DS:SI & ES:DI
 29100                                  ; Function:
 29101                                  ;          Checks for ((SI==DI) && (ES==DS))
 29102                                  ;	   Assumes that pointers are normalized for the
 29103                                  ;	   same segment
 29104                                  ;
 29105                                  ; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
 29106                                  ; DO NOT USE FOR < or >
 29107                                  ; No Registers altered
 29108                                  ;
 29109                                  ;----------------------------------------------------------------------------
 29110                                  
 29111                                  POINTCOMP:
 29112                                  	; 31/07/2018 - Retro DOS v3.0
 29113                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D84h
 29114 00006191 39FE                    	CMP	SI,DI
 29115                                  	;jnz	short _ret_label	; return if nz
 29116 00006193 75FB                    	jnz	short placehead_retn 
 29117 00006195 51                      	PUSH	CX
 29118 00006196 52                      	PUSH	DX
 29119 00006197 8CD9                    	MOV	CX,DS
 29120 00006199 8CC2                    	MOV	DX,ES
 29121 0000619B 39D1                    	CMP	CX,DX
 29122 0000619D 5A                      	POP	DX
 29123 0000619E 59                      	POP	CX
 29124                                  ;_ret_label:
 29125 0000619F C3                      	retn
 29126                                  
 29127                                  
 29128                                  ; 01/08/2018 - Retro DOS v3.0
 29129                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5D93h 
 29130                                  
 29131                                  ;Break	<GETBUFFR, GETBUFFRB -- GET A SECTOR INTO A BUFFER>
 29132                                  
 29133                                  ;**	GetBuffr - Get a non-FAT Sector into a Buffer
 29134                                  ;----------------------------------------------------------------------------
 29135                                  ;	GetBuffr does normal ( non-FAT ) sector buffering
 29136                                  ;	It gets the specified local sector into one of the I/O buffers
 29137                                  ;	and shuffles the queue
 29138                                  ; 
 29139                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 29140                                  ;		       ELSE no pre-read
 29141                                  ;		(DX) = Desired physical sector number	      (LOW)
 29142                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 29143                                  ;		(ES:BP) = Pointer to drive parameters
 29144                                  ;		ALLOWED set in case of INT 24
 29145                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 29146                                  ;		'C' clear if OK
 29147                                  ;		CURBUF Points to the Buffer for the sector
 29148                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 29149                                  ;	USES	AX, BX, CX, SI, DI, Flags
 29150                                  ;----------------------------------------------------------------------------
 29151                                  
 29152                                  ;**	GetBuffrb - Get a FAT Sector into a Buffer
 29153                                  ;----------------------------------------------------------------------------
 29154                                  ;	GetBuffr reads a sector from the FAT file system's FAT table.
 29155                                  ;	It gets the specified sector into one of the I/O buffers
 29156                                  ;	and shuffles the queue. We need a special entry point so that
 29157                                  ;	we can read the alternate FAT sector if the first read fails, also
 29158                                  ;	so we can mark the buffer as a FAT sector.
 29159                                  ; 
 29160                                  ;	ENTRY	(AL) = 0 means sector must be pre-read
 29161                                  ;		       ELSE no pre-read
 29162                                  ;		(DX) = Desired physical sector number	      (LOW)
 29163                                  ;		(SI) != 0
 29164                                  ;		HIGH_SECTOR = Desired physical sector number (HIGH)
 29165                                  ;		(ES:BP) = Pointer to drive parameters
 29166                                  ;		ALLOWED set in case of INT 24
 29167                                  ;	EXIT	'C' set if error (user FAIL response to INT24)
 29168                                  ;		'C' clear if OK
 29169                                  ;		CUR ddBUF Points to the Buffer for the sector
 29170                                  ;		    the buffer type bits OF buf_flags = 0, caller must set it
 29171                                  ;	USES	AX, BX, CX, SI, DI, Flags
 29172                                  ;----------------------------------------------------------------------------
 29173                                  
 29174                                  GETBUFFR:
 29175 000061A0 31F6                    	XOR	SI,SI
 29176                                  
 29177                                  ;	This entry point is called for FAT buffering with SI != 0
 29178                                  
 29179                                  GETBUFFRB:
 29180 000061A2 A3[5005]                	MOV	[PREREAD],AX			; save pre-read flag
 29181 000061A5 268A4600                	mov	al,[ES:BP]
 29182                                  	;MOV	AL,[ES:BP+DPB.DRIVE] ; mov al,[es:bp+0]
 29183 000061A9 C53E[1E00]              	LDS	DI,[LastBuffer]			; Get the recency pointer
 29184                                  	; 22/07/2019 - Retro DOS v3.2
 29185                                  	; MSDOS 6.0
 29186                                  ;hkn; SS override
 29187 000061AD 368B0E[B005]            	MOV	CX,[SS:HIGH_SECTOR]		; F.C. >32mb		;AN000;
 29188                                  
 29189                                  ;	See if this is the buffer that was most recently returned.
 29190                                  ;	A big performance win if it is.
 29191                                  
 29192 000061B2 83FFFF                  	CMP	DI,-1				; Recency pointer valid?
 29193 000061B5 7412                    	je	short getb5			; No
 29194                                  	;cmp	dx,[di+6]
 29195 000061B7 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 29196 000061BA 750D                    	JNZ	short getb5			; Wrong sector
 29197                                  	
 29198                                  	; 22/07/2019
 29199                                  	; MSDOS 6.0
 29200                                  	;cmp	cx,[di+8]
 29201 000061BC 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]	; F.C. >32mb		;AN000;
 29202 000061BF 7508                    	JNZ	short getb5			; F.C. >32mb		;AN000;
 29203                                  	
 29204                                  	;cmp	al,[di+4]
 29205 000061C1 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 29206                                  	;JZ	getb35				; Just asked for same buffer
 29207 000061C4 7503                    	jnz	short getb5
 29208                                  	;jmp	getb35
 29209                                  	; 28/07/2019
 29210 000061C6 E99800                  	jmp	getb35x 
 29211                                  
 29212                                  ;	It's not the buffer most recently returned. See if it's in the
 29213                                  ;	cache.
 29214                                  ;
 29215                                  ;	(cx:dx) = sector #
 29216                                  ;	(al) = drive #
 29217                                  ;	(si) = 0 iff non fat sector, != 0 if FAT sector read
 29218                                  ;	??? list may be incomplete ???
 29219                                  
 29220                                  getb5:	
 29221                                  	; MSDOS 6.0
 29222                                  	;CALL	GETCURHEAD			; get Q Head
 29223                                  	; MSDOS 3.3
 29224 000061C9 36C53E[3800]            	lds	di,[SS:BUFFHEAD]
 29225                                  getb10:	
 29226                                  	;cmp	dx,[di+6]
 29227 000061CE 3B5506                  	CMP	DX,[DI+BUFFINFO.buf_sector]
 29228 000061D1 750A                    	jne	short getb12			; wrong sector lo
 29229                                  	
 29230                                  	; 22/07/2019 - Retro DOS v3.2
 29231                                  	; MSDOS 6.0
 29232                                  	;cmp	cx,[di+8]
 29233 000061D3 3B4D08                  	CMP	CX,[DI+BUFFINFO.buf_sector+2]
 29234 000061D6 7505                    	jne	short getb12			; wrong sector hi
 29235                                  	
 29236                                  	;cmp	al,[di+4]
 29237 000061D8 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 29238 000061DB 745E                    	je	short getb25 ; 05/09/2018	; Found the requested sector
 29239                                  	; MSDOS 6.0
 29240                                  	;jne	short getb12
 29241                                  	;jmp	getb25
 29242                                  getb12:	
 29243                                  	; 22/07/2019 - Retro DOS v3.2
 29244                                  	; MSDOS 6.0
 29245                                  	;mov	DI,[DI+BUFFINFO.BUF_NEXT]
 29246                                  	;cmp	DI,[SS:FIRST_BUFF_ADDR]		; back at the front again?
 29247                                  	;jne	short getb10			; no, continue looking
 29248                                  
 29249                                  	; MSDOS 3.3
 29250                                  	;mov	di,[DI]
 29251                                  	;mov	di,[DI+BUFFINFO.buf_link]
 29252                                  	
 29253                                  	; 15/08/2018
 29254 000061DD C53D                    	lds	di,[di]
 29255                                  	;
 29256 000061DF 83FFFF                  	cmp	di,-1 ; 0FFFFh
 29257 000061E2 75EA                    	jne	short getb10
 29258 000061E4 36C53E[3800]            	lds	di,[SS:BUFFHEAD]		
 29259                                  
 29260                                  ;	The requested sector is not available in the buffers. DS:DI now points
 29261                                  ;	to the first buffer in the Queue. Flush the first buffer & read in the
 29262                                  ;	new sector into it.
 29263                                  ;
 29264                                  ;	BUGBUG - what goes on here? Isn't the first guy the most recently
 29265                                  ;	used guy? Shuld be for fast lookup. If he is, we shouldn't take
 29266                                  ;	him, we should take LRU. And the above lookup shouldn't be
 29267                                  ;	down a chain, but should be hashed.
 29268                                  ;
 29269                                  ;	(DS:DI) = first buffer in the queue
 29270                                  ;	(CX:DX) = sector # we want
 29271                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 29272                                  
 29273                                  ;hkn; SS override
 29274 000061E9 51                      	PUSH	cx ; 22/07/2019 (MSDOS 6.0)
 29275 000061EA 56                      	push	si
 29276 000061EB 52                      	push	dx
 29277 000061EC 55                      	push	bp
 29278 000061ED 06                      	push	es
 29279 000061EE E8CC00                  	CALL	BUFWRITE			; Write out the dirty buffer
 29280 000061F1 07                      	pop	es
 29281 000061F2 5D                      	pop	bp
 29282 000061F3 5A                      	pop	dx
 29283 000061F4 5E                      	pop	si
 29284 000061F5 368F06[B005]            	POP	word [SS:HIGH_SECTOR] ; 22/07/2019 (MSDOS 6.0)
 29285 000061FA 726F                    	jc	short getbx			; if got hard error
 29286                                  	
 29287                                  	; MSDOS 6.0
 29288                                  	;jnc	short getb13
 29289                                  	;jmp	getbx
 29290                                  ;getb13:
 29291                                  	; MSDOS 6.0
 29292                                  	;CALL	SET_RQ_SC_PARMS 		; set parms for secondary cache
 29293                                  
 29294                                  ;	We're ready to read in the buffer, if need be. If the caller
 29295                                  ;	wanted to just *write* the buffer then we'll skip reading it in.
 29296                                  
 29297 000061FC 30E4                    	XOR	AH,AH				; initial flags
 29298                                  ;hkn; SS override
 29299                                  	;test	byte [ss:PREREAD],0FFh
 29300                                  	;jnz	short getb20
 29301 000061FE 363826[5005]            	CMP	[SS:PREREAD],ah ; 0		; am to Read in the new sector?
 29302 00006203 751E                    	JNZ	short getb20			; no, we're done 
 29303                                  	;lea	bx,[di+16] ; MSDOS 3.3
 29304                                  	;lea	bx,[di+20] ; MSDOS 6.0
 29305 00006205 8D5D14                  	LEA	BX,[DI+BUFINSIZ]		; (ds:bx) = data address
 29306 00006208 B90100                  	MOV	CX,1
 29307 0000620B 56                      	push	si
 29308 0000620C 57                      	push	di
 29309 0000620D 52                      	push	dx
 29310                                  	
 29311                                  	; MSDOS 6.0
 29312                                  	;push	es ; ***
 29313                                  
 29314                                  ; Note: As far as I can tell, all disk reads into buffers go through
 29315                                  ;	this point. -mrw 10/88
 29316                                  	
 29317                                  	;cmp	byte [ss:BuffInHMA],0	; is buffers in HMA?
 29318                                  	;jz	short getb14
 29319                                  	;push	ds ; **
 29320                                  	;push	bx ; *
 29321                                  	;lds	bx,[ss:LoMemBuff]	; Then let's read it into scratch buff
 29322                                  ;getb14:
 29323                                  ;M039: Eliminated redundant HMA code.
 29324                                  
 29325                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29326 0000620E 09F6                    	OR	SI,SI			; FAT sector ?
 29327 00006210 7407                    	JZ	short getb15		
 29328                                  
 29329 00006212 E819E0                  	call	FATSECRD
 29330                                  	;mov	ah,2
 29331 00006215 B402                    	MOV	AH,buf_isFAT		; Set buf_flags
 29332                                  
 29333 00006217 EB05                    	JMP	SHORT getb17		; Buffer is marked free if read barfs
 29334                                  getb15:
 29335 00006219 E83EE0                  	call	DREAD			; Buffer is marked free if read barfs
 29336 0000621C B400                    	MOV	AH,0			; Set buf_flags to no type, DO NOT XOR!
 29337                                  getb17:	
 29338                                  	; MSDOS 6.0							  ;I001
 29339                                  	;pushf								  ;I001
 29340                                  	;cmp	byte [SS:BuffInHMA],0	; did we read into scratch buff ? ;I001
 29341                                  	;jz	short not_in_hma	; no				  ;I001
 29342                                  	;mov	cx,[ES:BP+DPB.SECTOR_SIZE]				  ;I001
 29343                                  	;shr	cx,1							  ;I001
 29344                                  	;popf				; Retrieve possible CY from DREAD ;I001
 29345                                  	;mov	si,bx							  ;I001
 29346                                  	;pop	di ; *	 						  ;I001
 29347                                  	;pop	es ; **							  ;I001
 29348                                  	;cld								  ;I001
 29349                                  	;pushf				; Preserve possible CY from DREAD ;I001
 29350                                  	;rep	movsw			; move the contents of scratch buf;I001
 29351                                  	;push	es							  ;I001
 29352                                  	;pop	ds							  ;I001
 29353                                  ;not_in_hma:								  ;I001
 29354                                  	;popf							 	  ;I001
 29355                                  	;pop	es ; ***	
 29356                                  	;
 29357 0000621E 5A                      	pop	dx
 29358 0000621F 5F                      	pop	di
 29359 00006220 5E                      	pop	si
 29360 00006221 7248                    	JC	short getbx
 29361                                  
 29362                                  ;	The buffer has the data setup in it (if we were to read)
 29363                                  ;	Setup the various buffer fields
 29364                                  ;
 29365                                  ;	(ds:di) = buffer address
 29366                                  ;	(es:bp) = DPB address
 29367                                  ;	(HIGH_SECTOR:DX) = sector #
 29368                                  ;	(ah) = BUF_FLAGS value
 29369                                  ;	(si) = 0 if non fat sector, != 0 if FAT sector read
 29370                                  
 29371                                  ;hkn; SS override
 29372                                  getb20:	
 29373                                  	; 22/07/2019 - Retro DOS v3.2
 29374                                  	; MSDOS 6.0
 29375 00006223 368B0E[B005]            	MOV	CX,[SS:HIGH_SECTOR]
 29376                                  	;mov	[di+8],cx
 29377 00006228 894D08                  	MOV	[DI+BUFFINFO.buf_sector+2],CX
 29378                                  	; MSDOS 3.3 (& MSDOS 6.0)	
 29379                                   	;mov	[di+6],dx
 29380 0000622B 895506                  	MOV	[DI+BUFFINFO.buf_sector],DX
 29381                                  	;mov	[di+0Ah],bp  ; MSDOS 3.3
 29382                                  	;mov	[di+0Dh],bp  ; MSDOS 6.0
 29383 0000622E 896D0D                  	MOV	[DI+BUFFINFO.buf_DPB],BP
 29384                                  	;mov	[di+0Ch],es
 29385                                  	;mov	[di+0Fh],es  ; MSDOS 6.0
 29386 00006231 8C450F                  	MOV	[DI+BUFFINFO.buf_DPB+2],ES
 29387 00006234 268A4600                	mov	al,[es:bp]
 29388                                  	;mov	al,[es:bp+0]
 29389                                  	;MOV	AL,[ES:BP+DPB.DRIVE]
 29390                                  	;mov	[di+4],ax
 29391 00006238 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX		; Set ID and Flags
 29392                                  getb25:	
 29393                                  	; 22/07/2019
 29394                                  	; MSDOS 6.0
 29395                                  	;mov	byte [di+0Ah],1
 29396 0000623B C6450A01                	MOV	byte [DI+BUFFINFO.buf_wrtcnt],1	; Default to not a FAT sector ;AC000;
 29397 0000623F 31C0                    	XOR	AX,AX
 29398                                  
 29399                                  	; MSDOS 3.3
 29400                                  	;mov	ax,1
 29401                                  
 29402 00006241 09F6                    	OR	SI,SI				; FAT sector ?
 29403 00006243 740B                    	JZ	short getb30
 29404                                  
 29405                                  	;mov	al,[es:bp+8]
 29406 00006245 268A4608                	MOV	AL,[ES:BP+DPB.FAT_COUNT]	; update number of copies of
 29407                                  	; MSDOS 6.0
 29408 00006249 88450A                  	MOV	[DI+BUFFINFO.buf_wrtcnt],AL	;  this sector present on disk
 29409                                  	;mov	ax,[es:bp+0Fh]
 29410 0000624C 268B460F                	MOV	AX,[ES:BP+DPB.FAT_SIZE]		; offset of identical FAT
 29411                                  						;  sectors
 29412                                  	; MSDOS 3.3
 29413                                  	;;mov	ah,[es:bp+0Fh]
 29414                                  	;MOV	AH,[ES:BP+DPB.FAT_SIZE]
 29415                                  
 29416                                  ;	BUGBUG - dos 6 can clean this up by not setting wrtcntinc unless wrtcnt
 29417                                  ;		is set
 29418                                  
 29419                                  getb30:	
 29420                                  	; MSDOS 3.3
 29421                                  	;mov	[di+8],ax ; 15/08/2018	
 29422                                  	;MOV	[DI+BUFFINFO.buf_wrtcnt],AX
 29423                                  
 29424                                  	; 22/07/2019 - Retro DOS v3.2
 29425                                  	; MSDOS 6.0
 29426                                  	;mov	[di+0Bh],ax
 29427 00006250 89450B                  	MOV	[DI+BUFFINFO.buf_wrtcntinc],AX
 29428                                  
 29429 00006253 E8A3FE                  	CALL	PLACEBUF
 29430                                  
 29431                                  ;hkn; SS override for next 4
 29432                                  getb35: 
 29433 00006256 368C1E[2000]            	MOV	[SS:LastBuffer+2],DS
 29434 0000625B 36893E[1E00]            	MOV	[SS:LastBuffer],DI
 29435 00006260 F8                      	CLC
 29436                                  getb35x: ; 28/07/2019
 29437 00006261 368C1E[A005]            	MOV	[SS:CURBUF+2],DS
 29438 00006266 36893E[9E05]            	MOV	[SS:CURBUF],DI
 29439                                  
 29440                                  ;	Return with 'C' set appropriately
 29441                                  ;
 29442                                  ;	(dx) = caller's original value
 29443                                  
 29444                                  getbx:	
 29445 0000626B 16                      	push	ss
 29446 0000626C 1F                      	pop	ds
 29447 0000626D C3                      	retn
 29448                                  
 29449                                  ;Break	<FLUSHBUF -- WRITE OUT DIRTY BUFFERS>
 29450                                  ;----------------------------------------------------------------------------
 29451                                  ; Input:
 29452                                  ;	DS = DOSGROUP
 29453                                  ;	AL = Physical unit number local buffers only
 29454                                  ;	   = -1 for all units and all remote buffers
 29455                                  ; Function:
 29456                                  ;	Write out all dirty buffers for unit, and flag them as clean
 29457                                  ;	Carry set if error (user FAILed to I 24)
 29458                                  ;	    Flush operation completed.
 29459                                  ; DS Preserved, all others destroyed (ES too)
 29460                                  ;----------------------------------------------------------------------------
 29461                                  
 29462                                  FLUSHBUF:
 29463                                  	; MSDOS 6.0
 29464                                  	;call	GetCurHead
 29465                                  	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 29466                                  	;jnz	short scan_buf_queue
 29467                                  	;cmp	word [DirtyBufferCount], 0			;hkn;
 29468                                  	;je	short end_scan
 29469                                  	
 29470                                  	; MSDOS 3.3
 29471                                  	;mov	ah,-1 ; 01/08/2018 - Retro DOS v3.0
 29472 0000626E C53E[3800]              	lds	di,[BUFFHEAD]
 29473                                  scan_buf_queue:
 29474 00006272 E81F00                  	call	CHECKFLUSH
 29475                                  	;push	ax  ; MSDOS 3.3
 29476                                  	; MSDOS 6.0
 29477 00006275 8A6504                  	mov	ah,[DI+BUFFINFO.buf_ID]
 29478 00006278 363826[EE02]            	cmp	[SS:WPERR],ah					;hkn;
 29479                                  	;je	short free_the_buf
 29480                                  	;TEST	word [DOS34_FLAG],FROM_DISK_RESET ; from disk reset ? ;hkn;
 29481                                  	;jz	short dont_free_the_buf
 29482                                  	; MSDOS 3.3
 29483                                  	;mov	al,[di+4]
 29484                                  	;mov	al,[DI+BUFFINFO.buf_ID]
 29485                                  	;cmp	[SS:WPERR],al					;hkn;
 29486                                  	; 15/08/2018
 29487 0000627D 7505                    	jne	short dont_free_the_buf	
 29488                                  free_the_buf:
 29489                                  	; MSDOS 6.0 (& MSDOS 3.3)
 29490 0000627F C74504FF00              	mov	word [DI+BUFFINFO.buf_ID],00FFh
 29491                                  dont_free_the_buf:
 29492                                  	;pop	ax  ; MSDOS 3.3 	   	
 29493                                  	
 29494                                  	; MSDOS 6.0
 29495                                  	;mov	di,[DI+BUFFINFO.buf_next] ; .buf_link
 29496                                  	;cmp	di,[SS:FIRST_BUFF_ADDR]				;hkn;
 29497                                  	;jne	short scan_buf_queue
 29498                                  
 29499                                  	; MSDOS 3.3
 29500                                  	;mov	di,[DI]
 29501                                  	;mov	di,[DI+BUFFINFO.buf_link] ; .buf_next
 29502                                  	;
 29503                                  	; 15/08/2018
 29504 00006284 C53D                    	lds	di,[di]
 29505                                  	;
 29506 00006286 83FFFF                  	cmp	di,-1 ; 0FFFFh
 29507 00006289 75E7                    	jnz	short scan_buf_queue 
 29508                                  
 29509                                  end_scan:
 29510 0000628B 16                      	push	ss
 29511 0000628C 1F                      	pop	ds
 29512                                  	; 01/08/2018 - Retro DOS v3.0
 29513                                  	;cmp	byte [FAILERR],0
 29514                                  	;jne	short bad_flush
 29515                                  	;retn
 29516                                  ;bad_flush:
 29517                                  	;stc
 29518                                  	;retn
 29519                                  	; 01/08/2018 - Retro DOS v3.0
 29520 0000628D 803E[1403]01            	cmp	byte [FAILERR],1
 29521 00006292 F5                      	cmc
 29522                                  flushbuf_retn:
 29523 00006293 C3                      	retn
 29524                                  
 29525                                  ;----------------------------------------------------------------------------
 29526                                  ;
 29527                                  ; Procedure Name : CHECKFLUSH
 29528                                  ;
 29529                                  ; Inputs : AL - Drive number, -1 means do not check for drive
 29530                                  ;	   DS:DI - pointer to buffer
 29531                                  ;
 29532                                  ; Function : Write out a buffer if it is dirty
 29533                                  ;
 29534                                  ; Carry set if problem (currently user FAILed to I 24)
 29535                                  ;
 29536                                  ;----------------------------------------------------------------------------
 29537                                  
 29538                                  CHECKFLUSH:
 29539                                  	; MSDOS 6.0
 29540 00006294 B4FF                    	mov	ah,-1 ; 01/08/2018 Retro DOS v3.0
 29541                                  	;cmp	[di+4],ah
 29542 00006296 386504                  	CMP	[DI+BUFFINFO.buf_ID],AH
 29543 00006299 74F8                    	jz	short flushbuf_retn	; Skip free buffer, carry clear
 29544 0000629B 38C4                    	CMP	AH,AL			; 
 29545 0000629D 7406                    	JZ	short DOBUFFER		; do this buffer
 29546                                  	;cmp	al,[di+4]
 29547 0000629F 3A4504                  	CMP	AL,[DI+BUFFINFO.buf_ID]
 29548 000062A2 F8                      	CLC
 29549 000062A3 75EE                    	jnz	short flushbuf_retn	; Buffer not for this unit or SFT
 29550                                  DOBUFFER:
 29551                                  	;test	byte [di+5],40h
 29552 000062A5 F6450540                	TEST	byte [DI+BUFFINFO.buf_flags],buf_dirty
 29553 000062A9 74E8                    	jz	short flushbuf_retn	; Buffer not dirty, carry clear by TEST
 29554 000062AB 50                      	PUSH	AX
 29555                                  	;push	word [di+4]
 29556 000062AC FF7504                  	PUSH	WORD [DI+BUFFINFO.buf_ID]
 29557 000062AF E80B00                  	CALL	BUFWRITE
 29558 000062B2 58                      	POP	AX
 29559 000062B3 7206                    	JC	short LEAVE_BUF		; Leave buffer marked free (lost).
 29560                                  	;and	ah,0BFh
 29561 000062B5 80E4BF                  	AND	AH,~buf_dirty		; Buffer is clean, clears carry
 29562                                  	;mov	[di+4],ax
 29563 000062B8 894504                  	MOV	[DI+BUFFINFO.buf_ID],AX
 29564                                  LEAVE_BUF:
 29565 000062BB 58                      	POP	AX			; Search info
 29566                                  checkflush_retn:
 29567 000062BC C3                      	retn
 29568                                  
 29569                                  ;Break	<BUFWRITE -- WRITE OUT A BUFFER IF DIRTY>
 29570                                  ;----------------------------------------------------------------------------
 29571                                  ;
 29572                                  ;	BufWrite writes a buffer to the disk, if it's dirty.
 29573                                  ;
 29574                                  ;	ENTRY	DS:DI Points to the buffer
 29575                                  ;
 29576                                  ;	EXIT	Buffer marked free
 29577                                  ;		Carry set if error (currently user FAILed to I 24)
 29578                                  ;
 29579                                  ;	USES	All buf DS:DI
 29580                                  ;		HIGH_SECTOR
 29581                                  ;----------------------------------------------------------------------------
 29582                                  
 29583                                  BUFWRITE:
 29584                                  	; 22/07/2019 - Retro DOS v3.2
 29585                                  	; 10/09/2018
 29586                                  	; 01/08/2018 - Retro DOS v3.0
 29587                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E94h
 29588 000062BD B8FF00                  	MOV	AX,00FFH
 29589                                  	;xchg	ax,[di+4]
 29590 000062C0 874504                  	XCHG	AX,[DI+BUFFINFO.buf_ID]	; Free, in case write barfs
 29591 000062C3 3CFF                    	CMP	AL,0FFH
 29592 000062C5 74F5                    	jz      short checkflush_retn	; Buffer is free, carry clear.
 29593                                  	;test	ah,40h
 29594 000062C7 F6C440                  	test	AH,buf_dirty
 29595 000062CA 74F0                    	jz      short checkflush_retn	; Buffer is clean, carry clear.
 29596                                  	; MSDOS 6.0
 29597                                  	;call	DEC_DIRTY_COUNT 	; LB. decrement dirty count
 29598                                  
 29599                                  ;hkn; SS override
 29600 000062CC 363A06[EE02]            	CMP	AL,[SS:WPERR]
 29601 000062D1 74E9                    	jz      short checkflush_retn	; If in WP error zap buffer
 29602                                  
 29603                                  ;hkn; SS override
 29604                                  	; 22/07/2019 - Retro DOS v3.2
 29605                                  	; MSDOS 6.0
 29606                                  	;MOV	[SS:SC_DRIVE],AL	;LB. set it for invalidation ;AN000;
 29607                                  	
 29608                                  	;;les	bp,[di+10] ; MSDOS 3.3
 29609                                  	;les	bp,[di+13] ; MSDOS 6.0
 29610 000062D3 C46D0D                  	LES	BP,[DI+BUFFINFO.buf_DPB]
 29611                                  	;;lea	bx,[di+16]
 29612                                  	;lea	bx,[di+20] ; MSDOS 6.0
 29613 000062D6 8D5D14                  	LEA	BX,[DI+BUFINSIZ]	; Point at buffer
 29614                                  	;mov	dx,[di+6]
 29615 000062D9 8B5506                  	MOV	DX,[DI+BUFFINFO.buf_sector] ;F.C. >32mb		;AN000;
 29616                                  	
 29617                                  	; MSDOS 6.0
 29618                                  	;mov	cx,[di+8]
 29619 000062DC 8B4D08                  	MOV	CX,[DI+BUFFINFO.buf_sector+2] ;F.C. >32mb	;AN000;
 29620                                  ;hkn; SS override
 29621 000062DF 36890E[B005]            	MOV	[SS:HIGH_SECTOR],CX	;F.C. >32mb		;AN000;
 29622 000062E4 8A4D0A                  	MOV	CL,[DI+BUFFINFO.buf_wrtcnt] ;>32mb		;AC000;
 29623                                  	; MSDOS 3.3
 29624                                  	;; mov	cx,[DI+8]
 29625                                  	;mov	cx,[DI+BUFFINFO.buf_wrtcnt]
 29626                                  	;MOV	AL,CH			; [DI+BUFFINFO.buf_wrtcntinc]
 29627 000062E7 30ED                    	XOR	CH,CH
 29628                                  	;;mov	ah,ch ; MSDOS 3.3
 29629                                  
 29630                                  ;hkn; SS override for ALLOWED
 29631                                  	;mov	byte [SS:ALLOWED],18h
 29632 000062E9 36C606[1503]18          	MOV	byte [SS:ALLOWED],Allowed_RETRY+Allowed_FAIL
 29633                                  	;test	byte [di+5],8
 29634                                  	; MSDOS 6.0 (& Retro DOS 3.0)
 29635                                  	;test	ah,8
 29636 000062EF F6C408                  	test	AH,buf_isDATA
 29637 000062F2 7406                    	JZ	short NO_IGNORE
 29638                                  	;or	byte [SS:ALLOWED],20h
 29639 000062F4 36800E[1503]20          	OR	byte [SS:ALLOWED],Allowed_IGNORE
 29640                                  NO_IGNORE:
 29641                                  	;xor	ah,ah ; 10/09/2018 (MSDOS 3.3, Retro DOS v3.0)
 29642                                  	; MSDOS 6.0
 29643                                  	;mov	ax,[di+11]
 29644 000062FA 8B450B                  	MOV	AX,[DI+BUFFINFO.buf_wrtcntinc]	;>32mb		;AC000;
 29645                                  
 29646 000062FD 57                      	PUSH	DI		; Save buffer pointer
 29647 000062FE 31FF                    	XOR	DI,DI		; Indicate failure
 29648                                  
 29649                                  	;push	ds
 29650                                  	;push	bx
 29651                                  WRTAGAIN:
 29652 00006300 57                      	push	di
 29653 00006301 51                      	push	cx
 29654 00006302 50                      	push	ax
 29655                                  	;MOV	CX,1
 29656 00006303 B101                    	mov	cl,1 ; 24/07/2019
 29657 00006305 53                      	push	bx
 29658 00006306 52                      	push	dx
 29659 00006307 1E                      	push	ds
 29660                                  
 29661                                  ; Note:  As far as I can tell, all disk reads into buffers go through this point.  -mrw 10/88
 29662                                  
 29663                                  	; MSDOS 6.0
 29664                                  	;cmp	byte [BuffInHMA],0
 29665                                  	;jz	short NBUFFINHMA
 29666                                  	;push	cx
 29667                                  	;push	es
 29668                                  	;mov	si,bx
 29669                                  	;mov	cx,[es:bp+DPB.SECTOR_SIZE]
 29670                                  	;shr	cx,1
 29671                                  	;les	di,[LoMemBuff]
 29672                                  	;mov	bx,di
 29673                                  	;cld
 29674                                  	;rep	movsw
 29675                                  	;push	es
 29676                                  	;pop	ds
 29677                                  	;pop	es
 29678                                  	;pop	cx
 29679                                  ;NBUFFINHMA:
 29680 00006308 E8AFDF                  	call	DWRITE		; Write out the dirty buffer
 29681 0000630B 1F                      	pop	ds
 29682 0000630C 5A                      	pop	dx
 29683 0000630D 5B                      	pop	bx
 29684 0000630E 58                      	pop	ax
 29685 0000630F 59                      	pop	cx
 29686 00006310 5F                      	pop	di
 29687 00006311 7201                    	JC	short NOSET
 29688 00006313 47                      	INC	DI		; If at least ONE write succeedes, the operation
 29689                                  NOSET:				;	succeedes.
 29690 00006314 01C2                    	ADD	DX,AX
 29691 00006316 E2E8                    	LOOP	WRTAGAIN
 29692                                  	;pop	bx
 29693                                  	;pop	ds
 29694 00006318 09FF                    	OR	DI,DI		; Clears carry
 29695 0000631A 7501                    	JNZ	short BWROK	; At least one write worked
 29696 0000631C F9                      	STC			; DI never got INCed, all writes failed.
 29697                                  BWROK:	
 29698 0000631D 5F                      	POP	DI
 29699 0000631E C3                      	retn
 29700                                  
 29701                                  ;**	Set_RQ_SC_Parms - Set Secondary Cache Parameters
 29702                                  ;----------------------------------------------------------------------------
 29703                                  ;	Set_RQ_SC_Parms sets the sector size and drive number value
 29704                                  ;	for the secondary cache. This updates SC_SECTOR_SIZE &
 29705                                  ;	SC_DRIVE even if SC is disabled to save the testing
 29706                                  ;	code and time
 29707                                  ;
 29708                                  ;	ENTRY	ES:BP = drive parameter block
 29709                                  ;
 29710                                  ;	EXIT	[SC_SECTOR_SIZE]= drive sector size
 29711                                  ;		[SC_DRIVE]= drive #
 29712                                  ;
 29713                                  ;	USES	Flags
 29714                                  ;----------------------------------------------------------------------------
 29715                                  
 29716                                  ;procedure   SET_RQ_SC_PARMS,NEAR
 29717                                  ;
 29718                                  ;;hkn; SS override for all variables used in this procedure.
 29719                                  ;
 29720                                  ;	SAVE	<ax>
 29721                                  ;
 29722                                  ;	MOV	ax,ES:[BP].DPB_SECTOR_SIZE	; save sector size
 29723                                  ;	MOV	SC_SECTOR_SIZE,ax
 29724                                  ;
 29725                                  ;	MOV	al,ES:[BP].DPB_DRIVE		; save drive #
 29726                                  ;	MOV	SC_DRIVE,al
 29727                                  ;
 29728                                  ;	RESTORE <ax>
 29729                                  ;
 29730                                  ;srspx:	return
 29731                                  ;
 29732                                  ;EndProc SET_RQ_SC_PARMS 			;LB. return
 29733                                  
 29734                                  ;Break	<INC_DIRTY_COUNT-increment dirty count>
 29735                                  ;----------------------------------------------------------------------------
 29736                                  ; Input:
 29737                                  ;	none
 29738                                  ; Function:
 29739                                  ;	increment dirty buffers count
 29740                                  ; Output:
 29741                                  ;	dirty buffers count is incremented
 29742                                  ;
 29743                                  ; All registers preserved
 29744                                  ;----------------------------------------------------------------------------
 29745                                  
 29746                                  ;procedure   INC_DIRTY_COUNT,NEAR
 29747                                  ;
 29748                                  ;; BUGBUG  ---- remove this routine
 29749                                  ;; BUGBUG ---- only one instruction is needed   (speed win, space loose)
 29750                                  ;	inc	[DirtyBufferCount]			;hkn;
 29751                                  ;	ret
 29752                                  ;EndProc INC_DIRTY_COUNT
 29753                                  
 29754                                  ;Break	<DEC_DIRTY_COUNT-decrement dirty count>
 29755                                  ;----------------------------------------------------------------------------
 29756                                  ; Input:
 29757                                  ;	none
 29758                                  ; Function:
 29759                                  ;	decrement dirty buffers count
 29760                                  ; Output:
 29761                                  ;	dirty buffers count is decremented
 29762                                  ;
 29763                                  ; All registers preserved
 29764                                  ;----------------------------------------------------------------------------
 29765                                  
 29766                                  ;procedure   DEC_DIRTY_COUNT,NEAR
 29767                                  ;	cmp	[DirtyBufferCount], 0	;hkn;
 29768                                  ;	jz	ddcx			; BUGBUG - shouldn't it be an
 29769                                  ;	dec	[DirtyBufferCount]	; error condition to underflow here? ;hkn;
 29770                                  ;ddcx:	ret
 29771                                  ;
 29772                                  ;EndProc DEC_DIRTY_COUNT
 29773                                  
 29774                                  ;============================================================================
 29775                                  ; MSPROC.ASM, MSDOS 6.0, 1991
 29776                                  ;============================================================================
 29777                                  ; 02/08/2018 - Retro DOS v3.0
 29778                                  
 29779                                  ; (15/04/2018 - RetrO DOS v2.0, MSDOS 2.11 - PROC.ASM - 1983)
 29780                                  
 29781                                  ; Pseudo EXEC system call for DOS
 29782                                  
 29783                                  ;	TITLE	MSPROC - process maintenance
 29784                                  ;	NAME	MSPROC
 29785                                  
 29786                                  ; =========================================================================
 29787                                  ;**	Process related system calls and low level routines for DOS 2.X.
 29788                                  ;	I/O specs are defined in DISPATCH.
 29789                                  ;
 29790                                  ;	$WAIT
 29791                                  ;	$EXEC
 29792                                  ;	$Keep_process
 29793                                  ;	Stay_resident
 29794                                  ;	$EXIT
 29795                                  ;	$ABORT
 29796                                  ;	abort_inner
 29797                                  ;
 29798                                  ;	Modification history:
 29799                                  ;
 29800                                  ;		Created: ARR 30 March 1983
 29801                                  ;		AN000	version 4.0 jan. 1988
 29802                                  ;		A007	PTM 3957 - fake vesrion for IBMCACHE.COM
 29803                                  ;		A008	PTM 4070 - fake version for MS WINDOWS
 29804                                  ;
 29805                                  ;		M000	added support for loading programs into UMBs 7/9/90
 29806                                  ;
 29807                                  ;		M004 - MS PASCAL 3.2 support. Please see under tag M003 in 
 29808                                  ;		       dossym.inc. 7/30/90
 29809                                  ;		M005 - Support for EXE programs with out STACK segment and 
 29810                                  ;		       with resident size < 64K - 256 bytes. A 256 byte 
 29811                                  ;		       stack is provided at the end of the program. Note that
 29812                                  ;		       only SP is changed.
 29813                                  ;		M020 - Fix for Rational bug for details see exepatch.asm
 29814                                  ;
 29815                                  ;		M028 - 4b04 implementation
 29816                                  ;
 29817                                  ;		M029 - Support for EXEs without stack rewritten. If EXE is
 29818                                  ;			in memory block >= 64K, sp = 0. If memory block
 29819                                  ;			obtained is <64K, point sp at the end of the memory
 29820                                  ;			block. For EXEs smaller than 64K, 256 bytes are still
 29821                                  ;			added for a stack segment which may be needed if it
 29822                                  ;			is loaded in low memory situations.
 29823                                  ;
 29824                                  ;		M030 - Fixing bug in EXEPACPATCH & changing 4b04 to 4b05
 29825                                  ;
 29826                                  ;		M040 - Bug #3052. The environment sizing code would flag a
 29827                                  ;			a bad environment if it reached 32767 bytes. Changed
 29828                                  ;			to allow 32768 bytes of environment.
 29829                                  ;
 29830                                  ;		M047 - Release the allocated UMB when we failed to load a 
 29831                                  ;		       COM file high. Also ensure that if the biggest block
 29832                                  ;		       into which we load the com file is less than 64K then
 29833                                  ;		       we provide atleast 256 bytes of stack to the user.
 29834                                  ;
 29835                                  ;		M050 - Made Lie table search CASE insensitive
 29836                                  ;
 29837                                  ;		M060 - Removed special version table from the kernal and
 29838                                  ;                      put it in a device drive which puts the address
 29839                                  ;                      in the DOS DATA area location UU_IFS_DOS_CALL
 29840                                  ;		       as a DWORD.
 29841                                  ;
 29842                                  ;		M063 - Modified UMB support. If the HIGH_ONLY bit is set on
 29843                                  ;		       entry do not try to load low if there is no space in
 29844                                  ;		       UMBs.
 29845                                  ;
 29846                                  ;		M068 - Support for copy protect apps. Call ChkCopyProt to 
 29847                                  ;		       set a20off_count. Set bit EXECA20BIT in DOS_FLAG. Also
 29848                                  ;		       change return address to LeaveDos if AL=5.
 29849                                  ;
 29850                                  ;               20-Jul-1992 bens    Added ifdef RESTRICTED_BUILD code that
 29851                                  ;                      controls building a version of MSDOS.SYS that only
 29852                                  ;                      runs programs from a fixed list (defined in the
 29853                                  ;                      file RESTRICT.INC).  Search for "RESTRICTED_BUILD"
 29854                                  ;                      for details.  This feature is used to build a
 29855                                  ;                      "special" version of DOS that can be handed out to
 29856                                  ;                      OEM/ISV customers as part of a "service" disk.
 29857                                  ;
 29858                                  ; =========================================================================
 29859                                  
 29860                                  ;SAVEXIT 	EQU	10
 29861                                  
 29862                                  ;BREAK	<$WAIT - return previous process error code>
 29863                                  ; =========================================================================
 29864                                  ;	$WAIT - Return previous process error code.
 29865                                  ;
 29866                                  ;	Assembler usage:
 29867                                  ;
 29868                                  ;	    MOV     AH, WaitProcess
 29869                                  ;	    INT     int_command
 29870                                  ;
 29871                                  ;	ENTRY	none
 29872                                  ;	EXIT	(ax) = exit code
 29873                                  ;	USES	all
 29874                                  ; =========================================================================
 29875                                  
 29876                                  _$WAIT:
 29877                                  	; 02/08/2018 - Retro DOS v3.0
 29878                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5E1h
 29879                                  
 29880 0000631F 31C0                    	xor	AX,AX
 29881 00006321 368706[0003]            	xchg	AX,[ss:exit_code]
 29882 00006326 E972B4                  	jmp	SYS_RET_OK
 29883                                  
 29884                                  ; =========================================================================
 29885                                  ;BREAK <$exec - load/go a program>
 29886                                  ;	EXEC.ASM - EXEC System Call
 29887                                  ;
 29888                                  ;
 29889                                  ; Assembler usage:
 29890                                  ;	    lds     DX, Name
 29891                                  ;	    les     BX, Blk
 29892                                  ;	    mov     AH, Exec
 29893                                  ;	    mov     AL, FUNC
 29894                                  ;	    int     INT_COMMAND
 29895                                  ;
 29896                                  ;	AL  Function
 29897                                  ;	--  --------
 29898                                  ;	 0  Load and execute the program.
 29899                                  ;	 1  Load, create  the  program	header	but  do  not
 29900                                  ;	    begin execution.
 29901                                  ;	 3  Load overlay. No header created.
 29902                                  ;
 29903                                  ;	    AL = 0 -> load/execute program
 29904                                  ;
 29905                                  ;	    +---------------------------+
 29906                                  ;	    | WORD segment address of	|
 29907                                  ;	    | environment.		|
 29908                                  ;	    +---------------------------+
 29909                                  ;	    | DWORD pointer to ASCIZ	|
 29910                                  ;	    | command line at 80h	|
 29911                                  ;	    +---------------------------+
 29912                                  ;	    | DWORD pointer to default	|
 29913                                  ;	    | FCB to be passed at 5Ch	|
 29914                                  ;	    +---------------------------+
 29915                                  ;	    | DWORD pointer to default	|
 29916                                  ;	    | FCB to be passed at 6Ch	|
 29917                                  ;	    +---------------------------+
 29918                                  ;
 29919                                  ;	    AL = 1 -> load program
 29920                                  ;
 29921                                  ;	    +---------------------------+
 29922                                  ;	    | WORD segment address of	|
 29923                                  ;	    | environment.		|
 29924                                  ;	    +---------------------------+
 29925                                  ;	    | DWORD pointer to ASCIZ	|
 29926                                  ;	    | command line at 80h	|
 29927                                  ;	    +---------------------------+
 29928                                  ;	    | DWORD pointer to default	|
 29929                                  ;	    | FCB to be passed at 5Ch	|
 29930                                  ;	    +---------------------------+
 29931                                  ;	    | DWORD pointer to default	|
 29932                                  ;	    | FCB to be passed at 6Ch	|
 29933                                  ;	    +---------------------------+
 29934                                  ;	    | DWORD returned value of	|
 29935                                  ;	    | CS:IP			|
 29936                                  ;	    +---------------------------+
 29937                                  ;	    | DWORD returned value of	|
 29938                                  ;	    | SS:IP			|
 29939                                  ;	    +---------------------------+
 29940                                  ;
 29941                                  ;	    AL = 3 -> load overlay
 29942                                  ;
 29943                                  ;	    +---------------------------+
 29944                                  ;	    | WORD segment address where|
 29945                                  ;	    | file will be loaded.	|
 29946                                  ;	    +---------------------------+
 29947                                  ;	    | WORD relocation factor to |
 29948                                  ;	    | be applied to the image.	|
 29949                                  ;	    +---------------------------+
 29950                                  ;
 29951                                  ; Returns:
 29952                                  ;	    AX = error_invalid_function
 29953                                  ;	       = error_bad_format
 29954                                  ;	       = error_bad_environment
 29955                                  ;	       = error_not_enough_memory
 29956                                  ;	       = error_file_not_found
 29957                                  ; =========================================================================
 29958                                  ;
 29959                                  ;   Revision history:
 29960                                  ;
 29961                                  ;	 A000	version 4.00  Jan. 1988
 29962                                  ;
 29963                                  ; =========================================================================
 29964                                  
 29965                                  Exec_Internal_Buffer		EQU	OPENBUF
 29966                                  Exec_Internal_Buffer_Size	EQU	(128+128+53+curdirLen)
 29967                                  
 29968                                  ; =========================================================================
 29969                                  
 29970                                  ;IF1		; warning message on buffers
 29971                                  ;%out	Please make sure that the following are contiguous and of the
 29972                                  ;%out	following sizes:
 29973                                  ;%out
 29974                                  ;%out	OpenBuf     128
 29975                                  ;%out	RenBuf	    128
 29976                                  ;%out	SearchBuf    53
 29977                                  ;%out	DummyCDS    curdirLen
 29978                                  ;ENDIF
 29979                                  
 29980                                  ; =========================================================================
 29981                                  
 29982                                  ; =========================================================================
 29983                                  ;
 29984                                  ; =========================================================================
 29985                                  
 29986                                  _$EXEC:
 29987                                  	; 02/08/2018 - Retro DOS v3.0
 29988                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 5EF1h
 29989                                  
 29990                                  EXEC001S:
 29991                                  
 29992                                  	;LocalVar    Exec_Blk		,DWORD
 29993                                  	;LocalVar    Exec_Func		,BYTE
 29994                                  	;LocalVar    Exec_Load_High	,BYTE
 29995                                  	;LocalVar    Exec_FH		,WORD
 29996                                  	;LocalVar    Exec_Rel_Fac	,WORD
 29997                                  	;LocalVar    Exec_Res_Len_Para	,WORD
 29998                                  	;LocalVar    Exec_Environ	,WORD
 29999                                  	;LocalVar    Exec_Size		,WORD
 30000                                  	;LocalVar    Exec_Load_Block	,WORD
 30001                                  	;LocalVar    Exec_DMA		,WORD
 30002                                  	;LocalVar    ExecNameLen 	,WORD
 30003                                  	;LocalVar    ExecName		,DWORD
 30004                                  	;
 30005                                  	;LocalVar    Exec_DMA_Save	,WORD
 30006                                  	;LocalVar    Exec_NoStack	,BYTE
 30007                                  
 30008                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30009                                  	;%define	Exec_Blk	dword [bp-4]
 30010                                  	%define		Exec_Blk	[bp-4] ; 09/08/2018
 30011                                  	%define		Exec_BlkL	word [bp-4]	
 30012                                  	%define		Exec_BlkH	word [bp-2]
 30013                                  	%define		Exec_Func	byte [bp-5]
 30014                                  	%define		Exec_Load_High	byte [bp-6]
 30015                                  	%define		Exec_FH		word [bp-8]
 30016                                  	%define		Exec_Rel_Fac	word [bp-10]
 30017                                  	%define		Exec_Res_Len_Para word [bp-12]
 30018                                  	%define		Exec_Environ	word [bp-14]
 30019                                  	%define		Exec_Size	word [bp-16]
 30020                                  	%define		Exec_Load_Block	word [bp-18]
 30021                                  	%define		Exec_DMA	word [bp-20]
 30022                                  	%define		ExecNameLen	word [bp-22]
 30023                                  	;%define	ExecName	dword [bp-26]
 30024                                  	%define		ExecName	[bp-26] ; 09/08/2018
 30025                                  	%define		ExecNameL	word [bp-26]	
 30026                                  	%define		ExecNameH	word [bp-24]
 30027                                  	; MSDOS 6.0
 30028                                  	%define		Exec_DMA_Save	word [bp-28]
 30029                                  	%define		Exec_NoStack	byte [bp-29]
 30030                                  	
 30031                                  	; ==================================================================
 30032                                  	; validate function
 30033                                  	; ==================================================================
 30034                                  		      	
 30035                                  	;
 30036                                  	; M068 - Start
 30037                                  	;
 30038                                  	; Reset the A20OFF_COUNT to 0. This is done as there is a 
 30039                                  	; possibility that the count may not be decremented all the way to
 30040                                  	; 0. A typical case is if the program for which we intended to keep 
 30041                                  	; the A20  off for a sufficiently long time (A20OFF_COUNT int 21 
 30042                                  	; calls), exits pre-maturely due to error conditions.
 30043                                  	;
 30044                                  
 30045                                  	; MSDOS 6.0
 30046                                  	;mov	byte [SS:A20OFF_COUNT], 0
 30047                                  
 30048                                  	;
 30049                                  	; If al=5 (ExecReady) we'll change the return address on the stack	
 30050                                  	; to be LeaveDos in msdisp.asm. This ensures that the EXECA20OFF
 30051                                  	; bit set in DOS_FLAG by ExceReady is not cleared in msdisp.asm
 30052                                  	;
 30053                                  	
 30054                                  	;cmp	al,5			; Q: is this ExecReady call
 30055                                  	;jne	@f			; N: continue
 30056                                  					; Y: change ret addr. to LeaveDos.
 30057                                  	;pop	cx			; Note CX is not input to ExecReady
 30058                                  	;mov	cx, offset DOSCODE:LeaveDos
 30059                                  	;push	cx
 30060                                  ;@@:
 30061                                  	;
 30062                                  	; M068 - End
 30063                                  	;
 30064                                  
 30065                                  	;Enter
 30066                                  
 30067 00006329 55                      	push	bp
 30068 0000632A 89E5                    	mov	bp,sp
 30069 0000632C 83EC1E                  	sub	sp,30 ; MSDOS 6.0
 30070                                  	;sub	sp,26 ; MSDOS 3.3
 30071                                  
 30072                                  	; MSDOS 6.0
 30073                                  	;cmp	AL,5			; only 0, 1, 3 or 5 are allowed ;M028
 30074                                  					; M030
 30075                                  	;jna	short Exec_Check_2
 30076                                  
 30077                                  	; MSDOS 3.3
 30078 0000632F 3C03                    	cmp	AL,3
 30079 00006331 760E                    	jna	short Exec_Check_2
 30080                                  
 30081                                  Exec_Bad_Fun:
 30082 00006333 36C606[EF02]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk 
 30083                                  					; Extended Error Locus	;smr;SS Override
 30084                                  	;mov	al,1
 30085 00006339 B001                    	mov	al,error_invalid_function
 30086                                  
 30087                                  Exec_Ret_Err:
 30088                                  	;Leave
 30089 0000633B 89EC                    	mov	sp,bp
 30090 0000633D 5D                      	pop	bp
 30091                                  	;transfer SYS_RET_ERR
 30092 0000633E E963B4                  	jmp	SYS_RET_ERR
 30093                                  
 30094                                  	; MSDOS 6.0
 30095                                  ;ExecReadyJ:
 30096                                  	;call	ExecReady		; M028
 30097                                  	;jmp	norm_ovl		; do a Leave & xfer sysret_OK ; M028
 30098                                  
 30099                                  Exec_Check_2:
 30100 00006341 3C02                    	cmp	AL,2			
 30101 00006343 74EE                    	jz	short Exec_Bad_Fun
 30102                                  
 30103                                  	; MSDOS 6.0
 30104                                  	;cmp	al,4			; 2 & 4 are not allowed
 30105                                  	;je	short Exec_Bad_Fun
 30106                                  	;
 30107                                  	;cmp	al,5			; M028 ; M030
 30108                                  	;je	short ExecReadyJ		; M028
 30109                                  
 30110                                  	;mov	[bp-4],bx
 30111 00006345 895EFC                  	mov	Exec_BlkL,BX		; stash args
 30112                                  	;mov	[bp-2],es
 30113 00006348 8C46FE                  	mov	Exec_BlkH,ES
 30114                                  	;mov	[bp-5],al
 30115 0000634B 8846FB                  	mov	Exec_Func,AL
 30116                                  	;mov	byte [bp-6],0
 30117 0000634E C646FA00                	mov	Exec_Load_High,0
 30118                                  
 30119                                  	;mov	[bp-26],dx
 30120 00006352 8956E6                  	mov	ExecNameL,DX		; set up length of exec name
 30121                                  	;mov	[bp-24],ds
 30122 00006355 8C5EE8                  	mov	ExecNameH,DS
 30123 00006358 89D6                    	mov	SI,DX			; move pointer to convenient place
 30124                                  	;invoke	DStrLen
 30125 0000635A E8BCBC                  	call	DStrLen
 30126                                  	;mov	[bp-22],cx
 30127 0000635D 894EEA                  	mov	ExecNameLen,CX		; save length
 30128                                  
 30129                                  	; MSDOS 6.0
 30130                                  	;mov	al, [AllocMethod]	; M063: save alloc method in 
 30131                                  	;mov	[AllocMsave], al	; M063: AllocMsave
 30132                                  
 30133 00006360 30C0                    	xor	AL,AL			; open for reading
 30134 00006362 55                      	push	BP
 30135                                  
 30136                                  	; MSDOS 6.0
 30137                                  	;or	byte [DOS_FLAG],EXECOPEN ; this flag is set to indicate to 
 30138                                  					; the redir that this open call is
 30139                                  					; due to an exec.
 30140                                  
 30141                                  	;invoke	$OPEN			; is the file there?
 30142 00006363 E81610                  	call	_$OPEN
 30143                                  
 30144                                  	; MSDOS 6.0
 30145                                  	;pushf
 30146                                  	;and	byte [DOS_FLAG],~EXECOPEN; reset flag
 30147                                  	;popf
 30148                                  
 30149 00006366 5D                      	pop	BP
 30150                                  	;MSDOS 3.3
 30151 00006367 72D2                    	jc	short Exec_Ret_Err
 30152                                  
 30153                                  	;mov	[bp-8],ax
 30154 00006369 8946F8                  	mov	Exec_FH,AX
 30155 0000636C 89C3                    	mov	BX,AX
 30156 0000636E 30C0                    	xor	AL,AL
 30157                                  	;invoke	$Ioctl
 30158 00006370 E8BCCC                  	call	_$IOCTL
 30159 00006373 7207                    	jc	short Exec_BombJ
 30160                                  
 30161                                  	;test	dl,80h
 30162 00006375 F6C280                  	test	DL,devid_ISDEV
 30163 00006378 740A                    	jz	short Exec_Check_Environ
 30164                                  
 30165                                  	;mov	al,2
 30166 0000637A B002                    	mov	AL,error_file_not_found
 30167                                  Exec_BombJ:
 30168 0000637C E9CC00                  	jmp	Exec_Bomb
 30169                                  
 30170                                  BadEnv:
 30171                                  	;mov	al,0Ah
 30172 0000637F B00A                    	mov	AL,error_bad_environment
 30173 00006381 E9C700                  	jmp	Exec_Bomb
 30174                                  
 30175                                  Exec_Check_Environ:
 30176                                  	;mov	word [bp-18],0
 30177 00006384 C746EE0000              	mov	Exec_Load_Block,0
 30178                                  	;mov	word [bp-14],0
 30179 00006389 C746F20000              	mov	Exec_Environ,0
 30180                                  					; overlays... no environment
 30181                                  	;test	byte [bp-5],2
 30182 0000638E F646FB02                	test	Exec_Func,exec_func_overlay
 30183 00006392 7554                    	jnz	short Exec_Read_Header
 30184                                  
 30185                                  	;lds	si,[bp-4]
 30186 00006394 C576FC                  	lds	SI,Exec_Blk		; get block
 30187 00006397 8B04                    	mov	ax,[SI]
 30188                                  	;mov	AX,[SI+EXEC1.ENVIRON]	; address of environ
 30189 00006399 09C0                    	or	AX,AX
 30190 0000639B 750C                    	jnz	short Exec_Scan_Env
 30191                                  
 30192 0000639D 368E1E[FC02]            	mov	DS,[SS:CurrentPDB]	;smr;SS Override
 30193                                  	;mov	ax,[44]
 30194 000063A2 A12C00                  	mov	AX,[PDB.ENVIRON]
 30195                                  
 30196                                  ; MSDOS 6.0
 30197                                  ;---------------------------------------------BUG 92 4/30/90-----------------
 30198                                  ;
 30199                                  ; Exec_environ is being correctly initialized after the environment has been
 30200                                  ; allocated and copied form the parent's env. It must not be initialized here.
 30201                                  ; Because if the call to $alloc below fails Exec_dealloc will deallocate the
 30202                                  ; parent's environment.
 30203                                  ;	mov	Exec_Environ,AX
 30204                                  ;
 30205                                  ;----------------------------------------------------------------------------
 30206                                  
 30207                                  	;mov	[bp-14],ax
 30208                                  	;mov	Exec_Environ,ax
 30209                                  
 30210 000063A5 09C0                    	or	AX,AX
 30211 000063A7 743F                    	jz	short Exec_Read_Header
 30212                                  
 30213                                  Exec_Scan_Env:
 30214 000063A9 8EC0                    	mov	ES,AX
 30215 000063AB 31FF                    	xor	DI,DI
 30216                                  	;mov	cx,7FFFh ; MSDOS 3.3
 30217 000063AD B90080                  	mov	CX,8000h ; MSDOS 6.0	; at most 32k of environment ;M040
 30218 000063B0 30C0                    	xor	AL,AL
 30219                                  
 30220                                  Exec_Get_Environ_Len:
 30221 000063B2 F2AE                    	repnz	scasb			; find that nul byte
 30222 000063B4 75C9                    	jnz	short BadEnv
 30223                                  
 30224 000063B6 49                      	dec	CX			; Dec CX for the next nul byte test
 30225 000063B7 78C6                    	js	short BadEnv		; gone beyond the end of the environment
 30226                                  
 30227 000063B9 AE                      	scasb				; is there another nul byte?
 30228 000063BA 75F6                    	jnz	short Exec_Get_Environ_Len ; no, scan some more
 30229                                  
 30230 000063BC 57                      	push	DI
 30231                                  	;lea	bx,[DI+11h]
 30232 000063BD 8D5D11                  	lea	BX,[DI+0Fh+2]
 30233                                  	;add	bx,[bp-22]
 30234 000063C0 035EEA                  	add	BX,ExecNameLen		; BX <- length of environment
 30235                                  					; remember argv[0] length
 30236                                  					; round up and remember argc
 30237 000063C3 B104                    	mov	CL,4
 30238 000063C5 D3EB                    	shr	BX,CL			; number of paragraphs needed
 30239 000063C7 06                      	push	ES
 30240                                  	;invoke	$Alloc			; can we get the space?
 30241 000063C8 E8CA04                  	call	_$ALLOC
 30242 000063CB 1F                      	pop	DS
 30243 000063CC 59                      	pop	CX
 30244 000063CD 7302                    	jnc	short Exec_Save_Environ
 30245                                  
 30246 000063CF EB74                    	jmp	SHORT Exec_No_Mem	; nope... cry and sob
 30247                                  
 30248                                  Exec_Save_Environ:
 30249 000063D1 8EC0                    	mov	ES,AX
 30250                                  	;mov	[bp-14],ax
 30251 000063D3 8946F2                  	mov	Exec_Environ,AX 	; save him for a rainy day
 30252 000063D6 31F6                    	xor	SI,SI
 30253 000063D8 89F7                    	mov	DI,SI
 30254 000063DA F3A4                    	rep	movsb			; copy the environment
 30255 000063DC B80100                  	mov	AX,1
 30256 000063DF AB                      	stosw
 30257                                  	;lds	si,[bp-26]
 30258 000063E0 C576E6                  	lds	SI,ExecName
 30259                                  	;mov	cx,[bp-22]
 30260 000063E3 8B4EEA                  	mov	CX,ExecNameLen
 30261 000063E6 F3A4                    	rep	movsb
 30262                                  
 30263                                  Exec_Read_Header:
 30264                                  	; We read in the program header into the above data area and
 30265                                  	; determine where in this memory the image will be located.
 30266                                  
 30267                                  	;Context DS
 30268 000063E8 16                      	push	ss
 30269 000063E9 1F                      	pop	ds
 30270                                  	;mov	cx,26
 30271 000063EA B91A00                  	mov	CX,Exec_Header_Len	; header size
 30272 000063ED BA[5C14]                	mov	DX,exec_signature
 30273 000063F0 06                      	push	ES
 30274 000063F1 1E                      	push	DS
 30275 000063F2 E87803                  	call	ExecRead
 30276 000063F5 1F                      	pop	DS
 30277 000063F6 07                      	pop	ES
 30278 000063F7 7250                    	jc	short Exec_Bad_File
 30279                                  
 30280 000063F9 09C0                    	or	AX,AX
 30281 000063FB 744C                    	jz	short Exec_Bad_File
 30282                                  	;cmp	ax,26
 30283 000063FD 83F81A                  	cmp	AX,Exec_Header_Len	; did we read the right number?
 30284 00006400 7519                    	jnz	short Exec_Com_Filej	; yep... continue
 30285                                  
 30286 00006402 F706[6814]FFFF          	test	word [exec_max_BSS],-1 	; indicate load high?
 30287 00006408 7504                    	jnz	short Exec_Check_Sig
 30288                                  
 30289                                  	;mov	byte [bp-6],0FFh
 30290 0000640A C646FAFF                	mov	Exec_Load_High,-1
 30291                                  
 30292                                  Exec_Check_Sig:
 30293 0000640E A1[5C14]                	mov	AX,[exec_signature]	; rms;NSS
 30294                                  	;cmp	ax,5A4Dh ; 'MZ'
 30295 00006411 3D4D5A                  	cmp	AX,exe_valid_signature	; zibo arises!
 30296 00006414 7408                    	jz	short Exec_Save_Start 	; assume com file if no signature
 30297                                  
 30298                                  	;cmp	ax,4D5Ah ; 'ZM'
 30299 00006416 3D5A4D                  	cmp	AX,exe_valid_old_signature  ; zibo arises!
 30300 00006419 7403                    	jz	short Exec_Save_Start 	; assume com file if no signature
 30301                                  
 30302                                  Exec_Com_Filej:
 30303 0000641B E9A201                  	jmp	Exec_Com_File
 30304                                  
 30305                                  	; We have the program header... determine memory requirements
 30306                                  
 30307                                  Exec_Save_Start:
 30308 0000641E A1[6014]                	mov	AX,[exec_pages]		; get 512-byte pages	;rms;NSS
 30309 00006421 B105                    	mov	CL,5			; convert to paragraphs
 30310 00006423 D3E0                    	shl	AX,CL
 30311 00006425 2B06[6414]              	sub	AX,[exec_par_dir] 	; AX = size in paragraphs;rms;NSS
 30312                                  	;mov	[bp-12],ax
 30313 00006429 8946F4                  	mov	Exec_Res_Len_Para,AX
 30314                                  
 30315                                  		; Do we need to allocate memory?
 30316                                  		; Yes if function is not load-overlay
 30317                                  
 30318                                  	;test	byte [bp-5],2
 30319 0000642C F646FB02                	test	Exec_Func,exec_func_overlay
 30320 00006430 742C                    	jz	short Exec_Allocate	; allocation of space
 30321                                  
 30322                                  		; get load address from block
 30323                                  
 30324                                  	;les	di,[bp-4]
 30325 00006432 C47EFC                  	les	DI,Exec_Blk
 30326 00006435 268B05                  	mov	ax,[es:di]
 30327                                  	;mov	AX,[ES:DI+EXEC3.load_addr]
 30328                                  	;mov	[bp-20],ax
 30329 00006438 8946EC                  	mov	Exec_DMA,AX
 30330 0000643B 268B4502                	mov	AX,[ES:DI+EXEC3.reloc_fac]
 30331                                  	;mov	[bp-10],ax
 30332 0000643F 8946F6                  	mov	Exec_Rel_Fac,AX
 30333                                  	; 10/08/2018
 30334 00006442 E9AB00                  	jmp	Exec_Find_Res		; M000
 30335                                  
 30336                                  Exec_No_Mem:
 30337                                  	;mov	al,8
 30338 00006445 B008                    	mov	AL,error_not_enough_memory
 30339 00006447 EB02                    	jmp	short Exec_Bomb
 30340                                  
 30341                                  Exec_Bad_File:
 30342                                  	;mov	al,0Bh
 30343 00006449 B00B                    	mov	AL,error_bad_format
 30344                                  
 30345                                  Exec_Bomb:
 30346                                  	;mov	bx,[bp-8]
 30347 0000644B 8B5EF8                  	mov	BX,Exec_FH
 30348 0000644E E82B03                  	call	Exec_Dealloc
 30349                                  	;LeaveCrit CritMem
 30350 00006451 E8C1BC                  	call	LcritMem
 30351                                  	;save	<AX,BP>
 30352 00006454 50                      	push	ax
 30353 00006455 55                      	push	bp
 30354                                  	;invoke	$CLOSE
 30355 00006456 E8B00C                  	call	_$CLOSE
 30356                                  	;restore <BP,AX>
 30357 00006459 5D                      	pop	bp
 30358 0000645A 58                      	pop	ax
 30359 0000645B E9DDFE                  	jmp	Exec_Ret_Err
 30360                                  
 30361                                  Exec_Chk_Mem: 
 30362                                  	; MSDOS 6.0    			; M063 - Start
 30363                                  	;mov	al,[AllocMethod]	; save current alloc method in ax
 30364                                  	;mov	bl,[AllocMsave]
 30365                                  	;mov	[AllocMethod], bl	; restore original allocmethod
 30366                                  	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
 30367                                  	;jnz	short Exec_No_Mem	; Y: no space in UMBs. Quit
 30368                                  	;				; N: continue
 30369                                  	;
 30370                                  	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 30371                                  	;jz	short Exec_No_Mem	; N: no memory 
 30372                                  	;mov	ax,[save_AX]		; Y: restore ax and
 30373                                  	;jmp	short Exec_Norm_Alloc	;    Try again
 30374                                  	;				; M063 - End
 30375                                  
 30376                                  Exec_Allocate:
 30377                                  	; 09/09/2018
 30378                                  
 30379                                  	; M005 - START
 30380                                  	; If there is no STACK segment for this exe file and if this
 30381                                  	; not an overlay and the resident size is less than 64K - 
 30382                                  	; 256 bytes we shall add 256bytes bytes to the programs 
 30383                                  	; resident memory requirement and set Exec_SP to this value.
 30384                                  
 30385                                  	; MSDOS 6.0
 30386 0000645E C646E300                	mov	Exec_NoStack,0
 30387 00006462 833E[6A14]00            	cmp	word [exec_SS],0	; Q: is there a stack seg
 30388 00006467 7512                    	jne	short ea1		; Y: continue normal processing
 30389 00006469 833E[6C14]00            	cmp	word [exec_SP],0	; Q: is there a stack ptr
 30390 0000646E 750B                    	jne	short ea1		; Y: continue normal processing
 30391                                  
 30392 00006470 FE46E3                  	inc	Exec_NoStack
 30393 00006473 3DF00F                  	cmp	ax,1000h-10h		; Q: is this >= 64K-256 bytes
 30394 00006476 7303                    	jae	short ea1		; Y: don't set Exec_SP
 30395                                  
 30396 00006478 83C010                  	add	ax,10h			; add 10h paras to mem requirement
 30397                                  ea1:
 30398                                  	; M005 - END
 30399                                  
 30400                                  	; MSDOS 6.0			; M000 - start
 30401                                  	;test	byte [AllocMethod],HIGH_FIRST
 30402                                  	;				; Q: is the alloc strat high_first
 30403                                  	;jz	short Exec_Norm_Alloc	; N: normal allocate
 30404                                  	;				; Y: set high_only bit
 30405                                  	;or	byte [AllocMethod],HIGH_ONLY
 30406                                  	;				; M000 - end
 30407                                  
 30408                                  ;Exec_Norm_Alloc:
 30409                                  	;mov	[save_ax],ax		; M000: save ax for possible 2nd  
 30410                                  					; M000: attempt at allocating memory
 30411                                  	;;push	ax			; M000
 30412                                  
 30413                                  	; MSDOS 3.3
 30414 0000647B 50                      	push	ax	
 30415                                  
 30416 0000647C BBFFFF                  	mov	BX,0FFFFh		; see how much room in arena
 30417 0000647F 1E                      	push	DS
 30418                                  	;invoke	$Alloc			; should have carry set and BX has max
 30419 00006480 E81204                  	call	_$ALLOC
 30420 00006483 1F                      	pop	DS
 30421                                  
 30422                                  	; MSDOS 6.0
 30423                                  	;mov	ax,[save_ax]		; M000
 30424                                  	;;pop	AX			; M000
 30425                                  
 30426                                  	; MSDOS 3.3
 30427 00006484 58                      	pop	ax
 30428                                  
 30429 00006485 83C010                  	add	AX,10h			; room for header
 30430 00006488 83FB11                  	cmp	BX,11h			; enough room for a header
 30431                                  	; MSDOS 6.0
 30432                                  	;jb	short Exec_Chk_Mem	; M000
 30433                                  	; MSDOS 3.3	
 30434 0000648B 72B8                    	jb	short Exec_No_Mem
 30435                                  
 30436 0000648D 39D8                    	cmp	AX,BX			; is there enough for bare image?
 30437                                  	; MSDOS 6.0
 30438                                  	;ja	short Exec_Chk_Mem	; M000
 30439                                  	; MSDOS 3.3
 30440 0000648F 77B4                    	ja	short Exec_No_Mem
 30441                                  
 30442                                  	;test	byte [bp-6],0FFh
 30443 00006491 F646FAFF                	test	Exec_Load_High,-1	; if load high, use max
 30444 00006495 7518                    	jnz	short Exec_BX_Max	; use max
 30445                                  
 30446                                  	; 09/09/2018
 30447                                  
 30448 00006497 0306[6614]              	add	AX,[exec_min_BSS] 	; go for min allocation;rms;NSS
 30449                                  	; MSDOS 6.0
 30450                                  	;jc	short Exec_Chk_Mem		; M000
 30451                                  	; MSDOS 3.3
 30452 0000649B 72A8                    	jc	short Exec_No_Mem
 30453                                  
 30454 0000649D 39D8                    	cmp	AX,BX			; enough space?
 30455                                  	; MSDOS 6.0
 30456                                  	;ja	short Exec_Chk_Mem	; M000: nope...	
 30457                                  	; MSDOS 3.3
 30458 0000649F 77A4                    	ja	short Exec_No_Mem
 30459                                  
 30460 000064A1 2B06[6614]              	sub	AX,[exec_min_BSS] 	; rms;NSS
 30461 000064A5 0306[6814]              	add	AX,[exec_max_BSS] 	; go for the MAX
 30462 000064A9 7204                    	jc	short Exec_BX_Max
 30463                                  
 30464 000064AB 39D8                    	cmp	AX,BX
 30465 000064AD 7602                    	jbe	short Exec_Got_Block
 30466                                  
 30467                                  Exec_BX_Max:
 30468 000064AF 89D8                    	mov	AX,BX
 30469                                  
 30470                                  Exec_Got_Block:
 30471                                  	; 03/08/2018 - Retro DOS v3.0
 30472                                  
 30473 000064B1 1E                      	push	DS
 30474 000064B2 89C3                    	mov	BX,AX
 30475                                  	;mov	[bp-16],bx
 30476 000064B4 895EF0                  	mov	Exec_Size,BX
 30477                                  	;invoke	$Alloc			; get the space
 30478 000064B7 E8DB03                  	call	_$ALLOC
 30479 000064BA 1F                      	pop	DS
 30480                                  	; MSDOS 6.0
 30481                                  	;jc	short Exec_Chk_Mem	; M000
 30482                                  	; MSDOS 3.3
 30483 000064BB 7288                    	jc	short Exec_No_Mem
 30484                                  
 30485                                  	; MSDOS 6.0
 30486                                  	;mov	cl,[AllocMsave]		; M063: 
 30487                                  	;mov	[AllocMethod],cl	; M063: restore allocmethod
 30488                                  
 30489                                  ;M029; Begin changes
 30490                                  ; This code does special handling for programs with no stack segment. If so,
 30491                                  ;check if the current block is larger than 64K. If so, we do not modify
 30492                                  ;Exec_SP. If smaller than 64K, we make Exec_SP = top of block. In either
 30493                                  ;case Exec_SS is not changed.
 30494                                  ;
 30495                                  	; MSDOS 6.0
 30496 000064BD 807EE300                	cmp	Exec_NoStack,0
 30497                                  	;je	@f
 30498 000064C1 7412                    	je	short ea2
 30499                                  
 30500 000064C3 81FB0010                	cmp	bx,1000h		; Q: >= 64K memory block
 30501                                  	;jae	@f			; Y: Exec_SP = 0
 30502 000064C7 730C                    	jae	short ea2
 30503                                  ;
 30504                                  ;Make Exec_SP point at the top of the memory block
 30505                                  ;
 30506 000064C9 B104                    	mov	cl,4
 30507 000064CB D3E3                    	shl	bx,cl			; get byte offset
 30508 000064CD 81EB0001                	sub	bx,100h			; take care of PSP
 30509 000064D1 891E[6C14]              	mov	[exec_SP],bx		; Exec_SP = top of block
 30510                                  ea2:
 30511                                  ;@@:
 30512                                  ;
 30513                                  ;M029; end changes
 30514                                  ;
 30515                                  	;mov	[bp-18],ax
 30516 000064D5 8946EE                  	mov	Exec_Load_Block,AX
 30517 000064D8 83C010                  	add	AX,10h
 30518                                  	;test	byte [bp-6],0FFh
 30519 000064DB F646FAFF                	test	Exec_Load_High,-1
 30520 000064DF 7409                    	jz	short Exec_Use_AX	; use ax for load info
 30521                                  
 30522                                  	;add	ax,[bp-16]
 30523 000064E1 0346F0                  	add	AX,Exec_Size		; go to end
 30524                                  	;sub	ax,[bp-12]
 30525 000064E4 2B46F4                  	sub	AX,Exec_Res_Len_Para	; drop off header
 30526 000064E7 83E810                  	sub	AX,10h			; drop off pdb
 30527                                  
 30528                                  Exec_Use_AX:
 30529                                  	;mov	[bp-10],ax
 30530 000064EA 8946F6                  	mov	Exec_Rel_Fac,AX 	; new segment
 30531                                  	;mov	[bp-20],ax
 30532 000064ED 8946EC                  	mov	Exec_DMA,AX		; beginning of dma
 30533                                  
 30534                                  	; Determine the location in the file of the beginning of
 30535                                  	; the resident
 30536                                  
 30537                                  Exec_Find_Res:
 30538                                  	; MSDOS 6.0
 30539                                  	;mov	dx,[bp-20]
 30540 000064F0 8B56EC                  	mov	DX,Exec_DMA
 30541                                  	;mov	[bp-28],dx
 30542 000064F3 8956E4                  	mov	Exec_DMA_Save,DX
 30543                                  
 30544                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30545 000064F6 8B16[6414]              	mov	DX,[exec_par_dir]
 30546 000064FA 52                      	push	DX
 30547 000064FB B104                    	mov	CL,4
 30548 000064FD D3E2                    	shl	DX,CL			; low word of location
 30549 000064FF 58                      	pop	AX
 30550 00006500 B10C                    	mov	CL,12
 30551 00006502 D3E8                    	shr	AX,CL			; high word of location
 30552 00006504 89C1                    	mov	CX,AX			; CX <- high
 30553                                  
 30554                                  		; Read in the resident image (first, seek to it)
 30555                                  	;mov	bx,[bp-8]
 30556 00006506 8B5EF8                  	mov	BX,Exec_FH
 30557 00006509 1E                      	push	DS
 30558 0000650A 30C0                    	xor	AL,AL
 30559                                  	;invoke	$Lseek			; Seek to resident
 30560 0000650C E86C0D                  	call	_$LSEEK
 30561 0000650F 1F                      	pop	DS
 30562 00006510 7303                    	jnc	short Exec_Big_Read
 30563                                  
 30564 00006512 E936FF                  	jmp	Exec_Bomb
 30565                                  
 30566                                  Exec_Big_Read:				; Read resident into memory
 30567                                  	;mov	bx,[bp-12]
 30568 00006515 8B5EF4                  	mov	BX,Exec_Res_Len_Para
 30569 00006518 81FB0010                	cmp	BX,1000h		; Too many bytes to read?
 30570 0000651C 7203                    	jb	short Exec_Read_OK
 30571                                  
 30572 0000651E BBE00F                  	mov	BX,0FE0h		; Max in one chunk FE00 bytes
 30573                                  
 30574                                  Exec_Read_OK:
 30575                                  	;sub	[bp-12],bx
 30576 00006521 295EF4                  	sub	Exec_Res_Len_Para,BX	; We read (soon) this many
 30577 00006524 53                      	push	BX
 30578 00006525 B104                    	mov	CL,4
 30579 00006527 D3E3                    	shl	BX,CL			; Get count in bytes from paras
 30580 00006529 89D9                    	mov	CX,BX			; Count in correct register
 30581 0000652B 1E                      	push	DS
 30582                                  	;mov	ds,[bp-20]
 30583 0000652C 8E5EEC                  	mov	DS,Exec_DMA		; Set up read buffer
 30584                                  
 30585 0000652F 31D2                    	xor	DX,DX
 30586 00006531 51                      	push	CX			; Save our count
 30587 00006532 E83802                  	call	ExecRead
 30588 00006535 59                      	pop	CX			; Get old count to verify
 30589 00006536 1F                      	pop	DS
 30590 00006537 7248                    	jc	short Exec_Bad_FileJ
 30591                                  
 30592 00006539 39C1                    	cmp	CX,AX			; Did we read enough?
 30593 0000653B 5B                      	pop	BX			; Get paragraph count back
 30594 0000653C 7408                    	jz	short ExecCheckEnd	; and do reloc if no more to read
 30595                                  
 30596                                  	; The read did not match the request. If we are off by 512
 30597                                  	; bytes or more then the header lied and we have an error.
 30598                                  
 30599 0000653E 29C1                    	sub	CX,AX
 30600 00006540 81F90002                	cmp	CX,512
 30601 00006544 733B                    	jae	short Exec_Bad_FileJ
 30602                                  
 30603                                  	; We've read in CX bytes... bump DTA location
 30604                                  
 30605                                  ExecCheckEnd:
 30606                                  	;add	[bp-20],bx
 30607 00006546 015EEC                  	add	Exec_DMA,BX		; Bump dma address
 30608                                  	;test	word [bp-12],0FFFFh
 30609 00006549 F746F4FFFF              	test	Exec_Res_Len_Para,-1
 30610 0000654E 75C5                    	jnz	short Exec_Big_Read
 30611                                  
 30612                                  	; The image has now been read in. We must perform relocation
 30613                                  	; to the current location.
 30614                                  
 30615                                  exec_do_reloc:
 30616                                  	;mov	cx,[bp-10]
 30617 00006550 8B4EF6                  	mov	CX,Exec_Rel_Fac
 30618 00006553 A1[6A14]                	mov	AX,[exec_SS]		; get initial SS ;rms;NSS
 30619 00006556 01C8                    	add	AX,CX			; and relocate him
 30620 00006558 A3[5614]                	mov	[exec_init_SS],AX 	; rms;NSS
 30621                                  
 30622 0000655B A1[6C14]                	mov	AX,[exec_SP]		; initial SP ;rms;NSS
 30623 0000655E A3[5414]                	mov	[exec_init_SP],AX 	; rms;NSS
 30624                                  
 30625 00006561 C406[7014]              	les	AX,[exec_IP]		; rms;NSS
 30626 00006565 A3[5814]                	mov	[exec_init_IP],AX 	; rms;NSS
 30627 00006568 8CC0                    	mov	AX,ES			; rms;NSS
 30628 0000656A 01C8                    	add	AX,CX			; relocated...
 30629 0000656C A3[5A14]                	mov	[exec_init_CS],AX 	; rms;NSS
 30630                                  
 30631 0000656F 31C9                    	xor	CX,CX
 30632 00006571 8B16[7414]              	mov	DX,[exec_rle_table]	; rms;NSS
 30633                                  	;mov	bx,[bp-8]
 30634 00006575 8B5EF8                  	mov	BX,Exec_FH
 30635 00006578 1E                      	push	DS
 30636 00006579 31C0                    	xor	AX,AX
 30637                                  	;invoke	$Lseek
 30638 0000657B E8FD0C                  	call	_$LSEEK
 30639 0000657E 1F                      	pop	DS
 30640 0000657F 7303                    	jnc	short exec_get_entries
 30641                                  
 30642                                  Exec_Bad_FileJ:
 30643 00006581 E9C5FE                  	jmp	Exec_Bad_File
 30644                                  
 30645                                  exec_get_entries:
 30646 00006584 8B16[6214]              	mov	DX,[exec_rle_count]	; Number of entries left ;rms;NSS
 30647                                  
 30648                                  exec_read_reloc:
 30649 00006588 52                      	push	DX
 30650                                  	;mov	dx,OPENBUF
 30651 00006589 BA[8203]                	mov	DX,Exec_Internal_Buffer
 30652                                  	;mov	cx,388
 30653 0000658C B98401                  	mov	CX,((Exec_Internal_Buffer_Size)/4)*4 ; (390>>2)<<2
 30654 0000658F 1E                      	push	DS
 30655 00006590 E8DA01                  	call	ExecRead
 30656 00006593 07                      	pop	ES
 30657 00006594 5A                      	pop	DX
 30658 00006595 72EA                    	jc	short Exec_Bad_FileJ
 30659                                  
 30660                                  	;mov	cx,97
 30661 00006597 B96100                  	mov	CX,(Exec_Internal_Buffer_Size)/4 ; (390>>2)
 30662                                  					; Pointer to byte location in header
 30663                                  	;mov	di,OPENBUF
 30664 0000659A BF[8203]                	mov	DI,Exec_Internal_Buffer
 30665                                  	;mov	si,[bp-10]
 30666 0000659D 8B76F6                  	mov	SI,Exec_Rel_Fac 	; Relocate a single address
 30667                                  
 30668                                  exec_reloc_one:
 30669 000065A0 09D2                    	or	DX,DX			; Any more entries?
 30670 000065A2 7416                    	jz	short Exec_Set_PDBJ
 30671                                  
 30672                                  exec_get_addr:
 30673 000065A4 26C51D                  	lds	BX,[ES:DI]		; Get ra/sa of entry
 30674 000065A7 8CD8                    	mov	AX,DS			; Relocate address of item
 30675                                  
 30676                                  	; MSDOS 6.0
 30677                                  ;;;;;;	add	AX,SI  ; MSDOS 3.3
 30678                                  	;add	ax,[bp-28]
 30679 000065A9 0346E4                  	add	AX,Exec_DMA_Save
 30680                                  
 30681 000065AC 8ED8                    	mov	DS,AX
 30682 000065AE 0137                    	add	[BX],SI
 30683 000065B0 83C704                  	add	DI,4
 30684 000065B3 4A                      	dec	DX
 30685 000065B4 E2EA                    	loop	exec_reloc_one		; End of internal buffer?
 30686                                  
 30687                                  	; We've exhausted a single buffer's worth. Read in the next
 30688                                  	; piece of the relocation table.
 30689                                  
 30690 000065B6 06                      	push	ES
 30691 000065B7 1F                      	pop	DS
 30692 000065B8 EBCE                    	jmp	short exec_read_reloc
 30693                                  
 30694                                  Exec_Set_PDBJ:
 30695                                  
 30696                                  	; MSDOS 6.0
 30697                                  	;
 30698                                  	; We now determine if this is a buggy exe packed file and if 
 30699                                  	; so we patch in the right code. Note that fixexepatch will
 30700                                  	; point to a ret if dos loads low. The load segment as 
 30701                                  	; determined above will be in exec_dma_save
 30702                                  	;
 30703                                  	;push	es
 30704                                  	;push	ax			; M030
 30705                                  	;push	cx			; M030
 30706                                  	;mov	es,Exec_DMA_Save
 30707                                  	;mov	ax,[exec_init_CS]	; M030
 30708                                  	;mov	cx,[exec_init_IP]	; M030
 30709                                  	;call	word [fixexepatch]
 30710                                  	;call	word [Rational386PatchPtr]
 30711                                  	;pop	cx			; M030
 30712                                  	;pop	ax			; M030
 30713                                  	;pop	es
 30714                                  
 30715 000065BA E99D00                  	jmp	Exec_Set_PDB
 30716                                  
 30717                                  Exec_No_Memj:
 30718 000065BD E985FE                  	jmp	Exec_No_Mem
 30719                                  
 30720                                  	; we have a .COM file. First, determine if we are merely
 30721                                  	; loading an overlay.
 30722                                  
 30723                                  Exec_Com_File:
 30724                                  	;test	byte [bp-5],2
 30725 000065C0 F646FB02                	test	Exec_Func,exec_func_overlay
 30726 000065C4 740C                    	jz	short Exec_Alloc_Com_File
 30727                                  	;lds	si,[bp-4]
 30728 000065C6 C576FC                  	lds	SI,Exec_Blk		; get arg block
 30729 000065C9 AD                      	lodsw				; get load address
 30730                                  	;mov	[bp-20],ax
 30731 000065CA 8946EC                  	mov	Exec_DMA,AX
 30732 000065CD B8FFFF                  	mov	AX,0FFFFh
 30733 000065D0 EB34                    	jmp	SHORT Exec_Read_Block	; read it all!
 30734                                  
 30735                                  Exec_Chk_Com_Mem:			
 30736                                  	; MSDOS 6.0	     		; M063 - Start
 30737                                  	;mov	al,[AllocMethod]	; save current alloc method in ax
 30738                                  	;mov	bl,[AllocMsave]
 30739                                  	;mov	[AllocMethod],bl	; restore original allocmethod
 30740                                  	;test	bl,HIGH_ONLY 		; Q: was the HIGH_ONLY bit already set
 30741                                  	;jnz	short Exec_No_Memj	; Y: no space in UMBs. Quit
 30742                                  	;				; N: continue
 30743                                  	;
 30744                                  	;test	al,HIGH_ONLY		; Q: did we set the HIGH_ONLY bit
 30745                                  	;jz	short Exec_No_Memj	; N: no memory 
 30746                                  	;
 30747                                  	;mov	ax,Exec_Load_Block	; M047: ax = block we just allocated	
 30748                                  	;xor	bx,bx			; M047: bx => free arena
 30749                                  	;call	ChangeOwner		; M047: free this block
 30750                                  	;
 30751                                  	;jmp	short Exec_Norm_Com_Alloc
 30752                                  	;				; M063 - End
 30753                                  	
 30754                                  	; We must allocate the max possible size block (ick!)
 30755                                  	; and set up CS=DS=ES=SS=PDB pointer, IP=100, SP=max
 30756                                  	; size of block.
 30757                                  
 30758                                  Exec_Alloc_Com_File:
 30759                                  	; MSDOS 6.0			; M000 -start
 30760                                  	;test	byte [AllocMethod],HIGH_FIRST
 30761                                  	;				; Q: is the alloc strat high_first
 30762                                  	;jz	short Exec_Norm_Com_Alloc ; N: normal allocate
 30763                                  	;				; Y: set high_only bit
 30764                                  	;or	byte [AllocMethod],HIGH_ONLY
 30765                                  	;				; M000 - end
 30766                                  ;Exec_Norm_Com_Alloc:			; M000
 30767                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30768 000065D2 BBFFFF                  	mov	BX,0FFFFh
 30769                                  	;invoke	$Alloc			; largest piece available as error
 30770 000065D5 E8BD02                  	call	_$ALLOC
 30771 000065D8 09DB                    	or	BX,BX
 30772                                  	; MSDOS 6.0
 30773                                  	;jz	short Exec_Chk_Com_Mem	; M000
 30774                                  	; MSDOS 3.3
 30775 000065DA 74E1                    	jz	short Exec_No_Memj
 30776                                  
 30777                                  	;mov	[bp-16],bx
 30778 000065DC 895EF0                  	mov	Exec_Size,BX		; save size of allocation block
 30779 000065DF 53                      	push	BX
 30780                                  	;invoke	$ALLOC			; largest piece available as error
 30781 000065E0 E8B202                  	call	_$ALLOC
 30782 000065E3 5B                      	pop	BX			; get size of block...
 30783                                  	;mov	[bp-18],ax
 30784 000065E4 8946EE                  	mov	Exec_Load_Block,AX
 30785 000065E7 83C010                  	add	AX,10h			; increment for header
 30786                                  	;mov	[bp-20],ax
 30787 000065EA 8946EC                  	mov	Exec_DMA,AX
 30788 000065ED 31C0                    	xor	AX,AX			; presume 64K read...
 30789 000065EF 81FB0010                	cmp	BX,1000h		; 64k or more in block?
 30790 000065F3 730E                    	jae	short Exec_Read_Com	; yes, read only 64k
 30791                                  
 30792 000065F5 89D8                    	mov	AX,BX			; convert size to bytes
 30793 000065F7 B104                    	mov	CL,4
 30794 000065F9 D3E0                    	shl	AX,CL
 30795                                  	; MSDOS 6.0
 30796 000065FB 3D0002                          cmp     AX,200h                 ; enough memory for PSP and stack?
 30797                                  ;	jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 30798                                  ;	;jbe	short Exec_No_Memj	; M000: jump if not
 30799                                  	; Retro DOS v3.0 modification (on MSDOS 6.0 code) -03/08/2018-
 30800                                  	;jbe	short Exec_Chk_Com_Mem	; M000: jump if not
 30801 000065FE 76BD                    	jbe	short Exec_No_Memj	; M000: jump if not
 30802                                  
 30803                                  					; M047: size of the block is < 64K
 30804 00006600 2D0001                  	sub	ax,100h			; M047: reserve 256 bytes for stack
 30805                                  
 30806                                  Exec_Read_Com:
 30807                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30808 00006603 2D0001                  	sub	AX,100h 		; remember size of psp
 30809                                  
 30810                                  Exec_Read_Block:
 30811 00006606 50                      	push	AX			; save number to read
 30812                                  	;mov	bx,[bp-8]
 30813 00006607 8B5EF8                  	mov	BX,Exec_FH		; of com file
 30814 0000660A 31C9                    	xor	CX,CX			; but seek to 0:0
 30815 0000660C 89CA                    	mov	DX,CX
 30816 0000660E 31C0                    	xor	AX,AX			; seek relative to beginning
 30817                                  	;invoke	$Lseek			; back to beginning of file
 30818 00006610 E8680C                  	call	_$LSEEK
 30819 00006613 59                      	pop	CX			; number to read
 30820                                  	;mov	ds,[bp-20]
 30821 00006614 8E5EEC                  	mov	DS,Exec_DMA
 30822 00006617 31D2                    	xor	DX,DX
 30823 00006619 51                      	push	CX
 30824 0000661A E85001                  	call	ExecRead
 30825 0000661D 5E                      	pop	SI			; get number of bytes to read
 30826 0000661E 7303                    	jnc	short OkRead
 30827 00006620 E926FE                  	jmp	Exec_Bad_File
 30828                                  
 30829                                  	; 10/09/2018
 30830                                  OkRead:
 30831 00006623 39F0                    	cmp	AX,SI			; did we read them all?
 30832                                  	; MSDOS 6.0
 30833                                  	;jz	short Exec_Chk_Com_Mem	; M00: exactly the wrong number...no 
 30834                                  	; MSDOS 3.3
 30835 00006625 7496                    	jz	short Exec_No_Memj	; M00: exactly the wrong number...
 30836                                  	
 30837                                  	; MSDOS 6.0
 30838                                  	;mov	bl,[AllocMsave]		; M063
 30839                                  	;mov	[AllocMethod],bl	; M063: restore allocmethod
 30840                                  
 30841                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30842                                  	;test	byte [bp-5],2
 30843 00006627 F646FB02                	test	Exec_Func,exec_func_overlay
 30844 0000662B 752D                    	jnz	short Exec_Set_PDB	; no starto, chumo!
 30845                                  
 30846                                  	;mov	ax,[bp-20]
 30847 0000662D 8B46EC                  	mov	AX,Exec_DMA
 30848 00006630 83E810                  	sub	AX,10h
 30849 00006633 36A3[5A14]              	mov	[SS:exec_init_CS],AX
 30850 00006637 36C706[5814]0001        	mov	word [SS:exec_init_IP],100h ; initial IP is 100h
 30851                                  
 30852                                  	; SI is AT MOST FF00h. Add FE to account for PSP - word
 30853                                  	; of 0 on stack.
 30854                                  
 30855 0000663E 81C6FE00                	add	SI,0FEh 		; make room for stack
 30856                                  
 30857                                  	; MSDOS 6.0
 30858 00006642 83FEFE                  	cmp	si,0FFFEh		; M047: Q: was there >= 64K available
 30859 00006645 7404                    	je	short Exec_St_Ok	; M047: Y: stack is fine
 30860 00006647 81C60001                	add	si,100h			; M047: N: add the xtra 100h for stack
 30861                                  
 30862                                  Exec_St_Ok:
 30863                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30864 0000664B 368936[5414]            	mov	[SS:exec_init_SP],SI 	; max value for read is also SP!;smr;SS Override
 30865 00006650 36A3[5614]              	mov	[SS:exec_init_SS],AX 					;smr;SS Override
 30866 00006654 8ED8                    	mov	DS,AX
 30867 00006656 C7040000                	mov	WORD [SI],0		; 0 for return
 30868                                  
 30869                                  	; MSDOS 6.0
 30870                                  	;
 30871                                  	; M068
 30872                                  	;
 30873                                  	; We now determine if this is a Copy Protected App. If so the 
 30874                                  	; A20OFF_COUNT is set to 6. Note that ChkCopyProt will point to a 
 30875                                  	; a ret if DOS is loaded low. Also DS contains the load segment.
 30876                                  
 30877                                  	;call	word ptr [ChkCopyProt]	
 30878                                  
 30879                                  Exec_Set_PDB:
 30880                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30881                                  	;mov	bx,[bp-8]
 30882 0000665A 8B5EF8                  	mov	BX,Exec_FH		; we are finished with the file.
 30883 0000665D E81C01                  	call	Exec_Dealloc
 30884 00006660 55                      	push	BP
 30885                                  	;invoke	$Close			; release the jfn
 30886 00006661 E8A50A                  	call	_$CLOSE
 30887 00006664 5D                      	pop	BP
 30888 00006665 E81F01                  	call	Exec_Alloc
 30889                                  	;test	byte [bp-5],2
 30890 00006668 F646FB02                	test	Exec_Func,exec_func_overlay
 30891 0000666C 7406                    	jz	short Exec_Build_Header
 30892                                  
 30893                                  	; MSDOS 6.0
 30894                                  	;call	Scan_Execname
 30895                                  	;call	Scan_Special_Entries
 30896                                  	;
 30897                                  ;SR;
 30898                                  ;The current lie strategy uses the PSP to store the lie version. However,
 30899                                  ;device drivers are loaded as overlays and have no PSP. To handle them, we
 30900                                  ;use the Sysinit flag provided by the BIOS as part of a structure pointed at
 30901                                  ;by BiosDataPtr. If this flag is set, the overlay call has been issued from
 30902                                  ;Sysinit and therefore must be a device driver load. We then get the lie 
 30903                                  ;version for this driver and put it into the Sysinit PSP. When the driver
 30904                                  ;issues the version check, it gets the lie version until the next overlay
 30905                                  ;call is issued.
 30906                                  ;
 30907                                  	;cmp	DriverLoad,0		;was Sysinit processing done?
 30908                                  	;je	norm_ovl		;yes, no special handling
 30909                                  	;push	si
 30910                                  	;push	es
 30911                                  	;les	si,BiosDataPtr		;get ptr to BIOS data block
 30912                                  	;cmp	byte ptr es:[si],0		;in Sysinit?
 30913                                  	;je	sysinit_done		;no, Sysinit is finished
 30914                                  	;
 30915                                  	;mov	es,CurrentPDB		;es = current PSP (Sysinit PSP)
 30916                                  	;push	Special_Version
 30917                                  	;pop	es:PDB_Version		;store lie version in Sysinit PSP
 30918                                  		;;; PDB.VERSION
 30919                                  	;jmp	short setver_done
 30920                                  ;sysinit_done:
 30921                                  	;mov	DriverLoad,0		;Sysinit done,special handling off
 30922                                  ;setver_done:
 30923                                  	;pop	es
 30924                                  	;pop	si
 30925                                  ;norm_ovl:
 30926                                  
 30927                                  	;leave
 30928 0000666E 89EC                    	mov	sp,bp		
 30929 00006670 5D                      	pop	bp
 30930                                  
 30931                                  	;transfer SYS_RET_OK		; overlay load -> done
 30932 00006671 E927B1                  	jmp	SYS_RET_OK
 30933                                  
 30934                                  Exec_Build_Header:
 30935                                  	;mov	dx,[bp-18]
 30936 00006674 8B56EE                  	mov	DX,Exec_Load_Block
 30937                                  					; assign the space to the process
 30938                                  	;mov	si,1
 30939 00006677 BE0100                  	mov	SI,ARENA.OWNER		; pointer to owner field
 30940                                  	;mov	ax,[bp-14]
 30941 0000667A 8B46F2                  	mov	AX,Exec_Environ 	; get environ pointer
 30942 0000667D 09C0                    	or	AX,AX
 30943 0000667F 7405                    	jz	short No_Owner		; no environment
 30944                                  
 30945 00006681 48                      	dec	AX			; point to header
 30946 00006682 8ED8                    	mov	DS,AX
 30947 00006684 8914                    	mov	[SI],DX 		; assign ownership
 30948                                  
 30949                                  No_Owner:
 30950                                  	;mov	ax,[bp-18]
 30951 00006686 8B46EE                  	mov	AX,Exec_Load_Block	; get load block pointer
 30952 00006689 48                      	dec	AX
 30953 0000668A 8ED8                    	mov	DS,AX			; point to header
 30954 0000668C 8914                    	mov	[SI],DX 		; assign ownership
 30955                                  
 30956                                  	; MSDOS 6.0
 30957                                  	;push	DS			;AN000;MS. make ES=DS
 30958                                  	;pop	ES			;AN000;MS.
 30959                                  	;mov	DI,Arena_Name		;AN000;MS. ES:DI points to destination
 30960                                  	;call	Scan_Execname		;AN007;MS. parse execname
 30961                                  	;				;	   ds:si->name, cx=name length
 30962                                  	;push	CX			;AN007;;MS. save for fake version
 30963                                  	;push	SI			;AN007;;MS. save for fake version
 30964                                  	;
 30965                                  ;MoveName:				;AN000;
 30966                                  	;lodsb				;AN000;;MS. get char
 30967                                  	;cmp	AL,'.'			;AN000;;MS. is '.' ,may be name.exe
 30968                                  	;jz	Mem_Done		;AN000;;MS. no, move to header
 30969                                  	;				;AN000;
 30970                                  	;stosb				;AN000;;MS. move char
 30971                                  	;				; MSKK bug fix - limit length copied
 30972                                  	;cmp	di,16			; end of memory arena block?
 30973                                  	;jae	mem_done		; jump if so
 30974                                  	;
 30975                                  	;loop	movename		;AN000;;MS. continue
 30976                                  ;Mem_Done:				;AN000;
 30977                                  	;xor	AL,AL			;AN000;;MS. make ASCIIZ
 30978                                  	;cmp	DI,SIZE ARENA		;AN000;MS. if not all filled
 30979                                  	;jae	Fill8			;AN000;MS.
 30980                                  	;
 30981                                  	;stosb				;AN000;MS.
 30982                                  	;
 30983                                  ;Fill8:					;AN000;
 30984                                  	;pop	SI			;AN007;MS. ds:si -> file name
 30985                                  	;pop	CX			;AN007;MS.
 30986                                  	;
 30987                                  	;call	Scan_Special_Entries	;AN007;MS.
 30988                                  
 30989                                  	; MSDOS 3.3 (& MSDOS 6.0)
 30990 0000668E 52                      	push	DX
 30991                                  	;mov	si,[bp-16]
 30992 0000668F 8B76F0                  	mov	SI,Exec_Size
 30993 00006692 01D6                    	add	SI,DX
 30994                                  	;Invoke	$Dup_PDB		; ES is now PDB
 30995 00006694 E855B8                  	call	_$DUP_PDB
 30996 00006697 5A                      	pop	DX
 30997                                  
 30998                                  	;push	word [bp-14]
 30999 00006698 FF76F2                  	push	Exec_Environ
 31000                                  	;pop	WORD [ES:2Ch]
 31001 0000669B 268F062C00              	pop	word [ES:PDB.ENVIRON]
 31002                                  
 31003                                  	; MSDOS 6.0			; *** Added for DOS 5.00
 31004                                  					; version number in PSP
 31005                                   	;push	word [Special_Version]	; Set the DOS version number to
 31006                                  	;pop	word [ES:PDB_Version]	; to be used for this application
 31007                                  		; PDB.VERSION
 31008                                  
 31009                                  	; MSDOS 3.3 (& MSDOS 6.0)	; set up proper command line stuff
 31010                                  	;lds	si,[bp-4]
 31011 000066A0 C576FC                  	lds	SI,Exec_Blk		; get the block
 31012 000066A3 1E                      	push	DS			; save its location
 31013 000066A4 56                      	push	SI
 31014                                  	;lds	si, [si+6]
 31015 000066A5 C57406                  	lds	SI,[SI+EXEC0.5C_FCB]	; get the 5c fcb
 31016                                  
 31017                                  	; DS points to user space 5C FCB
 31018                                  
 31019 000066A8 B90C00                  	mov	CX,12			; copy drive, name and ext
 31020 000066AB 51                      	push	CX
 31021 000066AC BF5C00                  	mov	DI,5Ch
 31022 000066AF 8A1C                    	mov	BL,[SI]
 31023 000066B1 F3A4                    	rep	movsb
 31024                                  
 31025                                  	; DI = 5Ch + 12 = 5Ch + 0Ch = 68h
 31026                                  
 31027 000066B3 31C0                    	xor	AX,AX			; zero extent, etc for CPM
 31028 000066B5 AB                      	stosw
 31029 000066B6 AB                      	stosw
 31030                                  
 31031                                  	; DI = 5Ch + 12 + 4 = 5Ch + 10h = 6Ch
 31032                                  
 31033 000066B7 59                      	pop	CX
 31034 000066B8 5E                      	pop	SI			; get block
 31035 000066B9 1F                      	pop	DS
 31036 000066BA 1E                      	push	DS			; save (again)
 31037 000066BB 56                      	push	SI
 31038                                  	;lds	si,[si+0Ah]
 31039 000066BC C5740A                  	lds	SI,[SI+EXEC0.6C_FCB]	; get 6C FCB
 31040                                  
 31041                                  	; DS points to user space 6C FCB
 31042                                  
 31043 000066BF 8A3C                    	mov	BH,[SI] 		; do same as above
 31044 000066C1 F3A4                    	rep	movsb
 31045 000066C3 AB                      	stosw
 31046 000066C4 AB                      	stosw
 31047 000066C5 5E                      	pop	SI			; get block (last time)
 31048 000066C6 1F                      	pop	DS
 31049                                  	;ld	si,[si+2]
 31050 000066C7 C57402                  	lds	SI,[SI+EXEC0.COM_LINE]	; command line
 31051                                  
 31052                                  	; DS points to user space 80 command line
 31053                                  
 31054 000066CA 80C980                  	or	CL,80h
 31055 000066CD 89CF                    	mov	DI,CX
 31056 000066CF F3A4                    	rep	movsb			; Wham!
 31057                                  
 31058                                  	; Process BX into default AX (validity of drive specs on args).
 31059                                  	; We no longer care about DS:SI.
 31060                                  
 31061 000066D1 FEC9                    	dec	CL			; get 0FFh in CL
 31062 000066D3 88F8                    	mov	AL,BH
 31063 000066D5 30FF                    	xor	BH,BH
 31064                                  	;invoke	GetVisDrv
 31065 000066D7 E8C605                  	call	GetVisDrv
 31066 000066DA 7302                    	jnc	short Exec_BL
 31067                                  
 31068 000066DC 88CF                    	mov	BH,CL
 31069                                  
 31070                                  Exec_BL:
 31071 000066DE 88D8                    	mov	AL,BL
 31072 000066E0 30DB                    	xor	BL,BL
 31073                                  	;invoke	GetVisDrv
 31074 000066E2 E8BB05                  	call	GetVisDrv
 31075 000066E5 7302                    	jnc	short Exec_Set_Return
 31076                                  
 31077 000066E7 88CB                    	mov	BL,CL
 31078                                  
 31079                                  Exec_Set_Return:
 31080                                  	;invoke	Get_User_Stack			; get his return address
 31081 000066E9 E85DAF                  	call	Get_User_Stack
 31082                                  
 31083                                  	;push	word [si+14h]
 31084 000066EC FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 31085                                  	;push	word [si+12h]
 31086 000066EF FF7412                  	push	word [SI+user_env.user_IP]
 31087                                  	;push	word [si+14h]
 31088 000066F2 FF7414                  	push	word [SI+user_env.user_CS]	; suck out the CS and IP
 31089                                  	;push	word [si+12h]
 31090 000066F5 FF7412                  	push	word [SI+user_env.user_IP]
 31091                                  	;pop	word [ES:0Ah]
 31092 000066F8 268F060A00              	pop	WORD [ES:PDB.EXIT]
 31093                                  	;pop	word [ES:0Ch]
 31094 000066FD 268F060C00              	pop	WORD [ES:PDB.EXIT+2]
 31095                                  
 31096 00006702 31C0                    	xor	AX,AX
 31097 00006704 8ED8                    	mov	DS,AX
 31098                                  					; save them where we can get them
 31099                                  					; later when the child exits.
 31100                                  	;pop	word [88h]
 31101 00006706 8F068800                	pop	word [addr_int_terminate] ; 22h*4
 31102                                  	;pop	word [90h]
 31103 0000670A 8F068A00                	pop	word [addr_int_terminate+2] ; (22h*4)+2
 31104                                  
 31105 0000670E 36C706[F802]8000        	mov	WORD [SS:DMAADD],80h	; SS Override
 31106 00006715 368E1E[FC02]            	mov	DS,[SS:CurrentPDB]	; SS Override
 31107 0000671A 368C1E[FA02]            	mov	[SS:DMAADD+2],DS	; SS Override
 31108                                  
 31109                                  	;test	byte [bp-5],1
 31110 0000671F F646FB01                	test	Exec_Func,exec_func_no_execute
 31111 00006723 7427                    	jz	short exec_go
 31112                                  
 31113 00006725 36C536[5414]            	lds	SI,[SS:exec_init_SP]	; get stack SS Override
 31114                                  	;les	di,[bp-4]
 31115 0000672A C47EFC                  	les	DI,Exec_Blk		; and block for return
 31116                                  	;mov	[es:di+10h],ds
 31117 0000672D 268C5D10                	mov	[ES:DI+EXEC1.SS],DS	; return SS
 31118                                  
 31119 00006731 4E                      	dec	SI			; 'push' default AX
 31120 00006732 4E                      	dec	SI
 31121 00006733 891C                    	mov	[SI],BX 		; save default AX reg
 31122                                  	;mov	[es:di+0Eh], si
 31123 00006735 2689750E                	mov	[ES:DI+EXEC1.SP],SI	; return 'SP'
 31124                                  
 31125 00006739 36C506[5814]            	lds	AX,[SS:exec_init_IP]	; SS Override
 31126                                  	;mov	[es:di+14h],ds
 31127 0000673E 268C5D14                	mov	[ES:DI+EXEC1.CS],DS	; initial entry stuff
 31128                                  	;mov	[es:di+12h],ax
 31129 00006742 26894512                	mov	[ES:DI+EXEC1.IP],AX
 31130                                  
 31131                                  	;leave
 31132 00006746 89EC                    	mov	sp,bp
 31133 00006748 5D                      	pop	bp	
 31134                                  
 31135                                  	;transfer SYS_RET_OK
 31136 00006749 E94FB0                  	jmp	SYS_RET_OK
 31137                                  
 31138                                  exec_go:
 31139 0000674C 36C536[5814]            	lds	SI,[SS:exec_init_IP]	; get entry point SS Override
 31140 00006751 36C43E[5414]            	les	DI,[SS:exec_init_SP]	; new stack SS Override
 31141                                  
 31142 00006756 8CC0                    	mov	AX,ES
 31143                                  
 31144                                  	; MSDOS 6.0
 31145                                  	;cmp	byte [SS:DosHasHMA],0	; Q: is dos in HMA (M021)
 31146                                  	;je	short Xfer_To_User	; N: transfer control to user
 31147                                  
 31148                                  	;push	ds			; Y: control must go to low mem stub
 31149                                  	;	
 31150                                  	;push	cs			;    where we disable a20 and Xfer 
 31151                                  	;pop	ds			;    control to user 
 31152                                  	;
 31153                                  	;or	byte [DOS_FLAG],EXECA20OFF ; M068:
 31154                                  	;				; M004: Set bit to signal int 21
 31155                                  	;				; ah = 25 & ah= 49. See dossym.inc 
 31156                                  	;				; under TAG M003 & M009 for 
 31157                                  	;				; explanation
 31158                                  	;mov	[A20OFF_PSP],dx		; M068: set the PSP for which A20 is
 31159                                  	;				; M068: going to be turned OFF.
 31160                                  	;
 31161                                  	;mov	ax,ds			; ax = segment of low mem stub
 31162                                  	;pop	ds
 31163                                  	;
 31164                                  	;push	ax			; ret far into the low mem stub
 31165                                  	;mov	ax,Disa20_Xfer
 31166                                  	;push	ax
 31167                                  	;mov	AX,ES			; restore ax
 31168                                  	;retf
 31169                                  
 31170                                  Xfer_To_User:
 31171                                  	; DS:SI points to entry point
 31172                                  	; AX:DI points to initial stack
 31173                                  	; DX has PDB pointer
 31174                                  	; BX has initial AX value
 31175                                  
 31176 00006758 FA                      	cli
 31177                                  	; 15/08/2018
 31178 00006759 36C606[ED02]00          	mov	BYTE [SS:INDOS],0	; SS Override
 31179                                  
 31180 0000675F 8ED0                    	mov	SS,AX			; set up user's stack
 31181 00006761 89FC                    	mov	SP,DI			; and SP
 31182 00006763 FB                      	sti
 31183                                  
 31184 00006764 1E                      	push	DS			; fake long call to entry
 31185 00006765 56                      	push	SI
 31186 00006766 8EC2                    	mov	ES,DX			; set up proper seg registers
 31187 00006768 8EDA                    	mov	DS,DX
 31188 0000676A 89D8                    	mov	AX,BX			; set up proper AX
 31189                                  
 31190 0000676C CB                      	retf
 31191                                  
 31192                                  ; 04/08/2018 - Retro DOS v3.0
 31193                                  
 31194                                  ;----------------------------------------------------------------------------
 31195                                  ;
 31196                                  ;----------------------------------------------------------------------------
 31197                                  
 31198                                  ExecRead:
 31199 0000676D E80C00                  	CALL	Exec_Dealloc
 31200                                  	;mov	bx,[bp-8]
 31201 00006770 8B5EF8                  	MOV	bx,Exec_FH
 31202 00006773 55                      	PUSH	BP
 31203 00006774 E8AA0A                  	call	_$READ
 31204 00006777 5D                      	POP	BP
 31205 00006778 E80C00                  	CALL	Exec_Alloc
 31206 0000677B C3                      	retn
 31207                                  
 31208                                  ;----------------------------------------------------------------------------
 31209                                  ;
 31210                                  ;----------------------------------------------------------------------------
 31211                                  
 31212                                  Exec_Dealloc:
 31213 0000677C 53                      	push	BX
 31214                                  	;mov	bx,0
 31215 0000677D 29DB                    	sub	BX,BX		; (bx) = ARENA_OWNER_SYSTEM
 31216 0000677F E88BB9                  	call	EcritMem
 31217 00006782 E81000                  	call	ChangeOwners
 31218 00006785 5B                      	pop	BX
 31219 00006786 C3                      	retn
 31220                                  
 31221                                  ;----------------------------------------------------------------------------
 31222                                  ;
 31223                                  ;----------------------------------------------------------------------------
 31224                                  
 31225                                  Exec_Alloc:
 31226 00006787 53                      	push	BX
 31227                                  	;mov	bx,[SS:CurrentPDB]	; SS Override
 31228 00006788 2E8B1E[FC02]            	mov	BX,[CS:CurrentPDB]  ; MSDOS 3.3
 31229 0000678D E80500                  	call	ChangeOwners
 31230 00006790 E882B9                  	call	LcritMem
 31231 00006793 5B                      	pop	BX
 31232 00006794 C3                      	retn
 31233                                  
 31234                                  ;----------------------------------------------------------------------------
 31235                                  ;
 31236                                  ;----------------------------------------------------------------------------
 31237                                  
 31238                                  ChangeOwners:
 31239 00006795 9C                      	pushf
 31240 00006796 50                      	push	AX
 31241                                  	;mov	ax,[bp-14]
 31242 00006797 8B46F2                  	mov	AX,Exec_Environ
 31243 0000679A E80900                  	call	ChangeOwner
 31244                                  	;mov	ax,[bp-18]
 31245 0000679D 8B46EE                  	mov	AX,Exec_Load_Block
 31246 000067A0 E80300                  	call	ChangeOwner
 31247 000067A3 58                      	pop	AX
 31248 000067A4 9D                      	popf
 31249                                  chgown_retn:
 31250 000067A5 C3                      	retn
 31251                                  
 31252                                  ;----------------------------------------------------------------------------
 31253                                  ;
 31254                                  ;----------------------------------------------------------------------------
 31255                                  
 31256                                  ChangeOwner:
 31257 000067A6 09C0                    	or	AX,AX			; is area allocated?
 31258 000067A8 74FB                    	jz	short chgown_retn	; no, do nothing
 31259 000067AA 48                      	dec	AX
 31260 000067AB 1E                      	push	DS
 31261 000067AC 8ED8                    	mov	DS,AX
 31262 000067AE 891E0100                	mov	[ARENA.OWNER],BX
 31263 000067B2 1F                      	pop	DS
 31264 000067B3 C3                      	retn
 31265                                  
 31266                                  
 31267                                  ; MSDOS 6.0
 31268                                  ;----------------------------------------------------------------------------
 31269                                  ;
 31270                                  ;----------------------------------------------------------------------------
 31271                                  
 31272                                  ;Procedure	Scan_Execname,near
 31273                                  ;	ASSUME	SS:DosData
 31274                                  ;
 31275                                  ;	lds	SI,ExecName		; DS:SI points to name
 31276                                  ;Entry	Scan_Execname1			; M028
 31277                                  ;Save_Begin:				;
 31278                                  ;	mov	CX,SI			; CX= starting addr
 31279                                  ;Scan0:					;
 31280                                  ;	lodsb				; get char
 31281                                  ;
 31282                                  ;	cmp	AL,':'			; is ':' , may be A:name
 31283                                  ;	jz	save_begin		; yes, save si
 31284                                  ;	cmp	AL,'\'                  ; is '\', may be A:\name
 31285                                  ;	jz	save_begin		; yes, save si
 31286                                  ;	cmp	AL,0			; is end of name
 31287                                  ;	jnz	scan0			; no, continue scanning
 31288                                  ;	sub	SI,CX			; get name's length
 31289                                  ;	xchg	SI,CX			; cx= length, si= starting addr
 31290                                  ;
 31291                                  ;	return
 31292                                  ;
 31293                                  ;EndProc Scan_Execname
 31294                                  
 31295                                  ; MSDOS 6.0
 31296                                  ;----------------------------------------------------------------------------
 31297                                  ;
 31298                                  ;----------------------------------------------------------------------------
 31299                                  
 31300                                  ;Procedure    Scan_Special_Entries,near
 31301                                  ;	assume	SS:DOSDATA
 31302                                  ;
 31303                                  ;	dec	CX			; cx= name length
 31304                                  ;;M060	mov	DI,[Special_Entries]	; es:di -> addr of special entries
 31305                                  ;					;reset to current version
 31306                                  ;	mov    [Special_Version],(Minor_Version SHL 8) + Major_Version
 31307                                  ;;***	call	Reset_Version
 31308                                  ;
 31309                                  ;;M060	push	SS
 31310                                  ;;M060	pop	ES
 31311                                  ;
 31312                                  ;	les	DI,SS:UU_IFS_DOS_CALL	;M060; ES:DI --> Table in SETVER.SYS
 31313                                  ;	mov	AX,ES			;M060; First do a NULL ptr check to
 31314                                  ;	or	AX,DI			;M060; be sure the table exists
 31315                                  ;	jz	End_List		;M060; If ZR then no table
 31316                                  ;
 31317                                  ;GetEntries:
 31318                                  ;	mov	AL,ES:[DI]		; end of list
 31319                                  ;	or	AL,AL
 31320                                  ;	jz	End_List		; yes
 31321                                  ;
 31322                                  ;	mov	[Temp_Var2],DI		; save di
 31323                                  ;	cmp	AL,CL			; same length ?
 31324                                  ;	jnz	SkipOne 		; no
 31325                                  ;
 31326                                  ;	inc	DI			; es:di -> special name
 31327                                  ;	push	CX			; save length and name addr
 31328                                  ;	push	SI
 31329                                  ;
 31330                                  ;;
 31331                                  ;; M050 - BEGIN
 31332                                  ;;
 31333                                  ;	push	ax			; save len
 31334                                  ;sse_next_char:
 31335                                  ;	lodsb
 31336                                  ;	call	UCase
 31337                                  ;	scasb
 31338                                  ;	jne	Not_Matched
 31339                                  ;	loop	sse_next_char
 31340                                  ;	
 31341                                  ;;
 31342                                  ;;	repz	cmpsb			; same name ?
 31343                                  ;;
 31344                                  ;;	jnz	Not_Matched		; no
 31345                                  ;;
 31346                                  ;	pop	ax			; take len off the stack
 31347                                  ;;
 31348                                  ;; M050 - END
 31349                                  ;;
 31350                                  ;	mov	AX,ES:[DI]		; get special version
 31351                                  ;	mov	[Special_Version],AX	; save it
 31352                                  ;
 31353                                  ;;***	mov	AL,ES:[DI+2]		; get fake count
 31354                                  ;;***	mov	[Fake_Count],AL 	; save it
 31355                                  ;
 31356                                  ;	pop	SI
 31357                                  ;	pop	CX
 31358                                  ;	jmp	SHORT end_list
 31359                                  ;
 31360                                  ;Not_Matched:
 31361                                  ;	pop	ax			; get len from stack ; M050
 31362                                  ;	pop	SI			; restore si,cx
 31363                                  ;	pop	CX
 31364                                  ;
 31365                                  ;SkipOne:
 31366                                  ;	mov	DI,[Temp_Var2]		; restore old di use SS Override
 31367                                  ;	xor	AH,AH			; position to next entry
 31368                                  ;	add	DI,AX
 31369                                  ;
 31370                                  ;	add	DI,3			; DI -> next entry length
 31371                                  ;;***	add	DI,4			; DI -> next entry length
 31372                                  ;
 31373                                  ;	jmp	Getentries
 31374                                  ;
 31375                                  ;End_List:
 31376                                  ;	return
 31377                                  ;
 31378                                  ;EndProc Scan_Special_Entries
 31379                                  
 31380                                  
 31381                                  ; 04/08/2018 - Retro DOS v3.0
 31382                                  ; IBMDOS.COm (MSDOS 3.3, 1987) - Offset 633Dh
 31383                                  
 31384                                  ;----------------------------------------------------------------------------
 31385                                  ;SUBTTL Terminate and stay resident handler
 31386                                  ;
 31387                                  ; Input:    DX is  an  offset  from  CurrentPDB  at which to
 31388                                  ;	    truncate the current block.
 31389                                  ;
 31390                                  ; output:   The current block is truncated (expanded) to be [DX+15]/16
 31391                                  ;	    paragraphs long.  An exit is simulated via resetting CurrentPDB
 31392                                  ;	    and restoring the vectors.
 31393                                  ;
 31394                                  ;----------------------------------------------------------------------------
 31395                                  
 31396                                  _$KEEP_PROCESS:
 31397 000067B4 50                      	push	AX			; keep exit code around
 31398                                  	;mov	byte [SS:EXIT_TYPE],3
 31399 000067B5 36C606[3905]03          	mov	BYTE [SS:EXIT_TYPE],EXIT_KEEP_PROCESS
 31400 000067BB 368E06[FC02]            	mov	ES,[SS:CurrentPDB]
 31401 000067C0 83FA06                  	cmp	DX,6h			; keep enough space around for system
 31402 000067C3 7303                    	jae	short Keep_Shrink	; info
 31403                                  
 31404 000067C5 BA0600                  	mov	DX,6h
 31405                                  
 31406                                  Keep_Shrink:
 31407 000067C8 89D3                    	mov	BX,DX
 31408 000067CA 53                      	push	BX
 31409 000067CB 06                      	push	ES
 31410 000067CC E8BF01                  	call	_$SETBLOCK		; ignore return codes.
 31411 000067CF 1F                      	pop	DS
 31412 000067D0 5B                      	pop	BX
 31413 000067D1 7207                    	jc	short Keep_Done		; failed on modification
 31414                                  
 31415 000067D3 8CD8                    	mov	AX,DS
 31416 000067D5 01D8                    	add	AX,BX
 31417                                  	;mov	[2],ax
 31418 000067D7 A30200                  	mov	[PDB.BLOCK_LEN],AX	;PBUGBUG
 31419                                  
 31420                                  Keep_Done:
 31421 000067DA 58                      	pop	AX
 31422 000067DB EB26                    	jmp	SHORT exit_inner	; and let abort take care of the rest
 31423                                  
 31424                                  ;----------------------------------------------------------------------------
 31425                                  ;
 31426                                  ;----------------------------------------------------------------------------
 31427                                  
 31428                                  STAY_RESIDENT:
 31429                                  	;mov	ax,3100h
 31430 000067DD B80031                  	mov	AX,(KEEP_PROCESS<<8)+0 ; Lower part is return code;PBUGBUG
 31431 000067E0 83C20F                  	add	DX,15
 31432 000067E3 D1DA                    	rcr	DX,1
 31433 000067E5 B103                    	mov	CL,3
 31434 000067E7 D3EA                    	shr	DX,CL
 31435                                  
 31436 000067E9 E9FCAC                  	jmp	COMMAND
 31437                                  
 31438                                  ;----------------------------------------------------------------------------
 31439                                  ;SUBTTL $EXIT - return to parent process
 31440                                  ;   Assembler usage:
 31441                                  ;	    MOV     AL, code
 31442                                  ;	    MOV     AH, Exit
 31443                                  ;	    INT     int_command
 31444                                  ;   Error return:
 31445                                  ;	    None.
 31446                                  ;
 31447                                  ;----------------------------------------------------------------------------
 31448                                  
 31449                                  _$EXIT:
 31450                                  	; 04/08/2018 - Retro DOS v3.0
 31451                                  	; IBMDOSDOS.COM (MSDOS 3.3, 1987) - Offset 6375h
 31452 000067EC 30E4                    	xor	AH,AH
 31453 000067EE 368626[1703]            	xchg	AH,[SS:DidCTRLC]
 31454 000067F3 08E4                    	or	AH,AH
 31455                                  	;mov	BYTE [SS:EXIT_TYPE],0
 31456 000067F5 36C606[3905]00          	mov	BYTE [SS:EXIT_TYPE],EXIT_TERMINATE
 31457 000067FB 7406                    	jz	short exit_inner
 31458                                  	;mov	BYTE [SS:EXIT_TYPE],1
 31459 000067FD 36C606[3905]01          	mov	BYTE [SS:EXIT_TYPE],EXIT_CTRL_C
 31460                                  
 31461                                  	;entry	Exit_inner
 31462                                  exit_inner:
 31463 00006803 E843AE                  	call	Get_User_Stack		;PBUGBUG
 31464                                  
 31465 00006806 36FF36[FC02]            	push	word [ss:CurrentPDB]
 31466                                  	;pop	word [si+14h]
 31467 0000680B 8F4414                  	pop	word [SI+user_env.user_CS] ;PBUGBUG
 31468 0000680E EB08                    	jmp	short abort_inner
 31469                                  
 31470                                  ;BREAK <$ABORT -- Terminate a process>
 31471                                  ;----------------------------------------------------------------------------
 31472                                  ; Inputs:
 31473                                  ;	user_CS:00 must point to valid program header block
 31474                                  ; Function:
 31475                                  ;	Restore terminate and Cntrl-C addresses, flush buffers and transfer
 31476                                  ;	to the terminate address
 31477                                  ; Returns:
 31478                                  ;	TO THE TERMINATE ADDRESS
 31479                                  ;----------------------------------------------------------------------------
 31480                                  
 31481                                  _$ABORT:
 31482 00006810 30C0                    	xor	AL,AL
 31483                                  	;mov	byte [SS:EXIT_TYPE],0
 31484                                  	;mov	byte [SS:EXIT_TYPE],AL ; = 0
 31485 00006812 36C606[3905]00          	mov	byte [SS:EXIT_TYPE],EXIT_ABORT
 31486                                  
 31487                                  	; abort_inner must have AL set as the exit code! The exit type
 31488                                  	; is retrieved from exit_type. Also, the PDB at user_CS needs
 31489                                  	; to be correct as the one that is terminating.
 31490                                  
 31491                                  abort_inner:
 31492 00006818 368A26[3905]            	mov	AH,[SS:EXIT_TYPE]
 31493 0000681D 36A3[0003]              	mov	[SS:exit_code],AX
 31494 00006821 E825AE                  	call	Get_User_Stack
 31495                                  
 31496                                  	;mov	ds,[si+14h]
 31497 00006824 8E5C14                  	mov	DS,[SI+user_env.user_CS] ; set up old interrupts ;PBUGBUG
 31498 00006827 31C0                    	xor	AX,AX
 31499 00006829 8EC0                    	mov	ES,AX
 31500                                  	;mov	si,10
 31501 0000682B BE0A00                  	mov	SI,SAVEXIT
 31502                                  	;mov	di,88h
 31503 0000682E BF8800                  	mov	DI,addr_int_terminate
 31504 00006831 A5                      	movsw
 31505 00006832 A5                      	movsw
 31506 00006833 A5                      	movsw
 31507 00006834 A5                      	movsw
 31508 00006835 A5                      	movsw
 31509 00006836 A5                      	movsw
 31510 00006837 E929F4                  	jmp	reset_environment
 31511                                  
 31512                                  ; MSDOS 6.0
 31513                                  ;----------------------------------------------------------------------------
 31514                                  ;
 31515                                  ; fixexepatch will point to this is DOS loads low. 
 31516                                  ;
 31517                                  ;----------------------------------------------------------------------------
 31518                                  
 31519                                  ;retexepatch	proc	near
 31520                                  ;	
 31521                                  ;	ret
 31522                                  ;
 31523                                  ;retexepatch 	endp
 31524                                  
 31525                                  
 31526                                  ;============================================================================
 31527                                  ; ALLOC.ASM, MSDOS 6.0, 1991
 31528                                  ;============================================================================
 31529                                  ; 04/08/2018 - Retro DOS v3.0
 31530                                  
 31531                                  ;	TITLE ALLOC.ASM - memory arena manager	NAME Alloc
 31532                                  
 31533                                  ;**
 31534                                  ;	Microsoft Confidential
 31535                                  ;	Copyright (C) Microsoft Corporation 1991
 31536                                  ;	All Rights Reserved.
 31537                                  ;
 31538                                  ;	Memory related system calls and low level routines for MSDOS 2.X.
 31539                                  ;	I/O specs are defined in DISPATCH.
 31540                                  ;
 31541                                  ;	$ALLOC
 31542                                  ;	$SETBLOCK
 31543                                  ;	$DEALLOC
 31544                                  ;	$AllocOper
 31545                                  ;	arena_free_process
 31546                                  ;	arena_next
 31547                                  ;	check_signature
 31548                                  ;	Coalesce
 31549                                  ;
 31550                                  ;	Modification history:
 31551                                  ;
 31552                                  ;	    Created: ARR 30 March 1983
 31553                                  ;
 31554                                  ;	    Revision: M000 - added support for allocing UMBs. 7/9/90
 31555                                  ;		      M003 - added support for link/unlink UMBs from
 31556                                  ;			     DOS arena chain. 7/18/90
 31557                                  ;		      M009 - Added error returns invalid function and 
 31558                                  ;			     arena trashed in set link state call.
 31559                                  ;		      M010 - Release UMB arenas allocated to current PDB
 31560                                  ;			     if UMB_HEAD is initialized.
 31561                                  ;
 31562                                  ;		      M016 - MACE utilities mkeyrate.com version 1.0 
 31563                                  ;			     support. Please see under M009 in 
 31564                                  ;			     ..\inc\dossym.inc. 8/31/90.
 31565                                  ;
 31566                                  ;		      M061 - In GetLastArena, if linking in UMBs check to make
 31567                                  ;			     sure that umb_head arena is valid and also make
 31568                                  ;			     sure that the previous arena is pointing to 
 31569                                  ;			     umb_head.
 31570                                  ;
 31571                                  ;		      M064 - allow HIGH_ONLY bit to be set by a call to 
 31572                                  ;			     set allloc strategy.
 31573                                  ;			     use STRAT_MASK to mask out bits 6 & 7 of 
 31574                                  ;			     bx in AllocSetStrat.
 31575                                  ;
 31576                                  ;		      M068 - use a count value (A20OFF_COUNT) rather than
 31577                                  ;			     a bit to indicate to dos dispatcher to turn
 31578                                  ;			     a20 off before iret. See M016.
 31579                                  ;
 31580                                  
 31581                                  ;	BREAK	<memory allocation utility routines>
 31582                                  
 31583                                  
 31584                                  ; 15/04/2018 - Retro DOS v2.0
 31585                                  ;----------------------------------------------------------------------------
 31586                                  ; xenix memory calls for MSDOS
 31587                                  ;
 31588                                  ; CAUTION: The following routines rely on the fact that arena_signature and
 31589                                  ; arena_owner_system are all equal to zero and are contained in DI.
 31590                                  ;
 31591                                  ;INCLUDE DOSSEG.ASM
 31592                                  
 31593                                  ;CODE	SEGMENT BYTE PUBLIC  'CODE'
 31594                                  ;       ASSUME  SS:DOSGROUP,CS:DOSGROUP
 31595                                  
 31596                                  ;.xlist
 31597                                  ;.xcref
 31598                                  ;INCLUDE DOSSYM.ASM
 31599                                  ;INCLUDE DEVSYM.ASM
 31600                                  ;.cref
 31601                                  ;.list
 31602                                  
 31603                                  ;TITLE ALLOC.ASM - memory arena manager
 31604                                  ;NAME Alloc
 31605                                  
 31606                                  ;SUBTTL memory allocation utility routines
 31607                                  ;PAGE
 31608                                  ;
 31609                                  ; arena data
 31610                                  ;
 31611                                  ;       i_need  arena_head,WORD         ; seg address of start of arena
 31612                                  ;       i_need  CurrentPDB,WORD         ; current process data block addr
 31613                                  ;       i_need  FirstArena,WORD         ; first free block found
 31614                                  ;       i_need  BestArena,WORD          ; best free block found
 31615                                  ;       i_need  LastArena,WORD          ; last free block found
 31616                                  ;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
 31617                                  
 31618                                  ;**	Arena_Free_Process
 31619                                  ;----------------------------------------------------------------------------
 31620                                  ;	Free all arena blocks allocated to a prOcess
 31621                                  ;
 31622                                  ;	ENTRY	(bx) = PID of process
 31623                                  ;	EXIT	none
 31624                                  ;	USES	????? BUGBUG
 31625                                  ;----------------------------------------------------------------------------
 31626                                  
 31627                                  arena_free_process:
 31628                                  	; 04/08/2018 - Retro DOS v3.0
 31629 0000683A 36A1[2400]                      MOV	AX,[SS:arena_head]
 31630                                  arena_free_process_start:
 31631 0000683E BF0000                  	MOV     DI,ARENA.SIGNATURE ; 0
 31632                                  	;MOV	AX,[SS:arena_head] ; 15/04/2018  
 31633 00006841 E81F00                          CALL    check_signature         ; ES <- AX, check for valid block
 31634                                  
 31635                                  arena_free_process_loop:
 31636                                          ;retc
 31637 00006844 722C                            JC	SHORT AFP_RETN	; Retro DOS v2.0 - 05/03/2018
 31638 00006846 06                      	PUSH    ES
 31639 00006847 1F                              POP     DS
 31640                                  	;cmp	[1],bx 
 31641 00006848 391E0100                        CMP     [ARENA.OWNER],BX	; is block owned by pid?
 31642 0000684C 7504                            JNZ     SHORT arena_free_next	; no, skip to next
 31643                                  	; 20/05/2019
 31644                                  	;mov	[1],di
 31645 0000684E 893E0100                        MOV     [ARENA.OWNER],DI	; yes... free him
 31646                                  
 31647                                  arena_free_next:
 31648                                  	;cmp	byte [di],5Ah ;'Z'
 31649 00006852 803D5A                          CMP     BYTE [DI],arena_signature_end
 31650                                                                          ; end of road, Jack?
 31651                                          ;retz				; never come back no more
 31652 00006855 741B                    	JZ	SHORT AFP_RETN  ;msdos 3.3 (& MSDOS 2.11)
 31653                                  	; MSDOS 6.0
 31654                                  	;jz	short arena_chk_umbs
 31655                                          
 31656 00006857 E80200                  	CALL    arena_next              ; next item in ES/AX carry set if trash
 31657 0000685A EBE8                            JMP     SHORT arena_free_process_loop
 31658                                  
 31659                                  	; MSDOS 6.0
 31660                                  ;arena_chk_umbs:			; M010 - Start
 31661                                  	;mov	ax,[umb_head]		; ax = umb_head
 31662                                  	;cmp	ax,0FFFFh		; Q: is umb_head initialized
 31663                                  	;je	short ret_label		; N: we're done
 31664                                  	;
 31665                                  	;mov	di,ds			; di = last arena
 31666                                  	;cmp	di,ax			; Q: is last arena above umb_head
 31667                                  	;jae	short ret_label		; Y: we've scanned umbs also. done.
 31668                                  	;jmp	short arena_free_process_start
 31669                                  					; M010 - End
 31670                                  
 31671                                  ;AFP_RETN:
 31672                                  ;	RETN
 31673                                  
 31674                                  ;	BREAK	<Arena Helper Routines>
 31675                                  
 31676                                  ;**	Arena_Next - Find Next item in Arena
 31677                                  ;----------------------------------------------------------------------------
 31678                                  ;	ENTRY	DS - pointer to block head
 31679                                  ;		(di) = 0
 31680                                  ;	EXIT	AX,ES - pointers to next head
 31681                                  ;		'C' set iff arena damaged
 31682                                  ;----------------------------------------------------------------------------
 31683                                  
 31684                                  arena_next:
 31685 0000685C 8CD8                            MOV     AX,DS                   ; AX <- current block
 31686 0000685E 03060300                        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
 31687 00006862 40                              INC     AX                      ; remember that header!
 31688                                  ;
 31689                                  ;       fall into check_signature and return
 31690                                  ;
 31691                                  ;       CALL    check_signature         ; ES <- AX, carry set if error
 31692                                  ;       RET
 31693                                  
 31694                                  ;**	Check_Signature - Check Memory Block Signature
 31695                                  ;----------------------------------------------------------------------------
 31696                                  ;	ENTRY	(AX) = address of block header
 31697                                  ;		(di) = 0
 31698                                  ;	EXIT	 ES = AX
 31699                                  ;		'C' clear if signature good
 31700                                  ;		'C' set if signature bad
 31701                                  ;	USES	ES, Flags
 31702                                  ;----------------------------------------------------------------------------
 31703                                  
 31704                                  check_signature:        
 31705                                  
 31706 00006863 8EC0                    	MOV     ES,AX                   ; ES <- AX
 31707                                  	;cmp	byte [es:di],4Dh ; 'M'
 31708 00006865 26803D4D                        CMP     BYTE [ES:DI],arena_signature_normal
 31709                                                                          ; IF next signature = not_end THEN
 31710 00006869 7407                            JZ      SHORT check_signature_ok ;   GOTO ok
 31711                                  	;cmp 	byte [es:di],5Ah ; 'Z'
 31712 0000686B 26803D5A                        CMP     BYTE [ES:DI],arena_signature_end
 31713                                                                          ; IF next signature = end then
 31714 0000686F 7401                            JZ      SHORT check_signature_ok ;   GOTO ok
 31715 00006871 F9                              STC                             ; set error
 31716                                  ;ret_label: ; MSDOS 6.0
 31717                                  AFP_RETN:
 31718                                   	;  Retro DOS v.20 - 05/03/2018
 31719                                  check_signature_ok:
 31720                                  COALESCE_RETN:
 31721 00006872 C3                      	RETN
 31722                                  
 31723                                  ;**	Coalesce - Combine free blocks ahead with current block
 31724                                  ;----------------------------------------------------------------------------
 31725                                  ;	Coalesce adds the block following the argument to the argument block,
 31726                                  ;	iff it's free.  Coalesce is usually used to join free blocks, but
 31727                                  ;	some callers (such as $setblock) use it to join a free block to it's
 31728                                  ;	preceeding allocated block.
 31729                                  ;
 31730                                  ;	ENTRY	(ds) = pointer to the head of a free block
 31731                                  ;		(di) = 0
 31732                                  ;	EXIT	'C' clear if OK
 31733                                  ;		  (ds) unchanged, this block updated
 31734                                  ;		  (ax) = address of next block, IFF not at end
 31735                                  ;		'C' set if arena trashed
 31736                                  ;	USES	(cx)
 31737                                  ;----------------------------------------------------------------------------
 31738                                          
 31739                                  Coalesce:
 31740                                  	;cmp	byte [di],5Ah ; 'Z'
 31741 00006873 803D5A                  	CMP     BYTE [DI],arena_signature_end
 31742                                                                          ; IF current signature = END THEN
 31743                                          ;retz				;   GOTO ok
 31744 00006876 74FA                            jz	short COALESCE_RETN
 31745 00006878 E8E1FF                  	CALL    arena_next              ; ES, AX <- next block, Carry set if error
 31746                                          ;retc				; IF no error THEN GOTO check
 31747 0000687B 72F5                    	jc	short COALESCE_RETN
 31748                                  
 31749                                  coalesce_check:
 31750                                  	;cmp	[es:1],di
 31751 0000687D 26393E0100                      CMP     [ES:ARENA.OWNER],DI
 31752                                          ;retnz				; IF next block isnt free THEN return
 31753 00006882 75EE                            JNZ	SHORT COALESCE_RETN
 31754                                  	;mov	cx,[ES:3]
 31755 00006884 268B0E0300              	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
 31756 00006889 41                              INC     CX                      ; CX <- CX + 1 (for header size)
 31757                                          ;ADD	[3],CX
 31758 0000688A 010E0300                	ADD     [ARENA.SIZE],CX		; current size <- current size + CX
 31759 0000688E 268A0D                          MOV     CL,[ES:DI]              ; move up signature
 31760 00006891 880D                            MOV     [DI],CL
 31761 00006893 EBDE                            JMP     SHORT Coalesce		; try again
 31762                                  
 31763                                  ; 04/08/2018 - Retro DOS v3.0
 31764                                  ; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 641Fh
 31765                                  
 31766                                  ;	BREAK  <$Alloc - allocate space in memory>
 31767                                  
 31768                                  ; MSDOS 6.0
 31769                                  ;----------------------------------------------------------------------------
 31770                                  ;**	$Alloc - Allocate Memory Space
 31771                                  ;
 31772                                  ;	$Alloc services the INT21 that allocates memory space to a program.
 31773                                  ;	Alloc returns a pointer to a free block of memory that
 31774                                  ;	has the requested size in paragraphs.
 31775                                  ;
 31776                                  ;	If the allocation strategy is HIGH_FIRST or HIGH_ONLY memory is 
 31777                                  ;	scanned from umb_head if not from arena_head. If the strategy is
 31778                                  ; 	HIGH_FIRST the scan is continued from arena_head if a block of 
 31779                                  ;	appropriate size is not found in the UMBs. If the strategy is 
 31780                                  ;	HIGH_FIRST+HIGH_ONLY only the UMBs are scanned for memory.
 31781                                  ;
 31782                                  ;	In either case if bit 0 of UmbFlag is not initialized then the scan
 31783                                  ;	starts from arena_head.
 31784                                  ;
 31785                                  ;	Assembler usage:
 31786                                  ;           MOV     BX,size
 31787                                  ;           MOV     AH,Alloc
 31788                                  ;           INT     21h
 31789                                  ;
 31790                                  ;	BUGBUG - a lot can be done to improve performance. We can set marks
 31791                                  ;	so that we start searching the arena at it's first non-trivial free
 31792                                  ;	block, we can peephole the code, etc. (We can move some subr calls
 31793                                  ;	inline, etc.) I assume that this is called rarely and that the arena
 31794                                  ;	doesn't have too many memory objects in it beyond the first free one.
 31795                                  ;	verify that this is true; if so, this can stay as is
 31796                                  ;
 31797                                  ;	ENTRY	(bx) = requested size, in bytes
 31798                                  ;		(DS) = (ES) = DOSGROUP
 31799                                  ;	EXIT	'C' clear if memory allocated
 31800                                  ;		  (ax:0) = address of requested memory
 31801                                  ;		'C' set if request failed
 31802                                  ;		  (AX) = error_not_enough_memory
 31803                                  ;		    (bx) = max size we could have allocated
 31804                                  ;		  (ax) = error_arena_trashed
 31805                                  ;	USES	All
 31806                                  ;----------------------------------------------------------------------------
 31807                                  
 31808                                  ; MSDOS 2.11 (& MSDOS 3.3)
 31809                                  ;----------------------------------------------------------------------------
 31810                                  ;SUBTTL $Alloc - allocate space in memory
 31811                                  ;
 31812                                  ;   Assembler usage:
 31813                                  ;           MOV     BX,size
 31814                                  ;           MOV     AH,Alloc
 31815                                  ;           INT     21h
 31816                                  ;         AX:0 is pointer to allocated memory
 31817                                  ;         BX is max size if not enough memory
 31818                                  ;
 31819                                  ;   Description:
 31820                                  ;           Alloc returns  a  pointer  to  a  free  block of
 31821                                  ;       memory that has the requested  size  in  paragraphs.
 31822                                  ;
 31823                                  ;   Error return:
 31824                                  ;           AX = error_not_enough_memory
 31825                                  ;              = error_arena_trashed
 31826                                  ;----------------------------------------------------------------------------
 31827                                  
 31828                                  _$ALLOC:
 31829                                  	; 04/08/2018 - Retro DOS v3.0
 31830                                  	;EnterCrit critMem
 31831 00006895 E875B8                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 31832                                  
 31833                                  	; MSDOS 6.0
 31834                                  	;mov	ax,[arena_head]
 31835                                  	;mov	[start_arena],ax	; assume LOW_FIRST
 31836                                  	;			
 31837                                  	;test	byte [AllocMethod],HIGH_FIRST+HIGH_ONLY
 31838                                  	;				; Q: should we start scanning from 
 31839                                  	;				;    UMB's
 31840                                  	;jz	short norm_alloc	; N: scan from arena_head
 31841                                  	;	
 31842                                  	;;cmp	word [umb_head],-1	; Q: Has umb_head been initialized
 31843                                  	;;je	short norm_alloc	; N: scan from arena_head
 31844                                  	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
 31845                                  	;jz	short norm_alloc	; N: scan from arena_head
 31846                                  	;
 31847                                  	;mov	ax,[umb_head]
 31848                                  	;mov	[start_arena],ax	; start_arena = umb_head
 31849                                  	;
 31850                                  					; M000 - end
 31851                                  ;norm_alloc:
 31852 00006898 31C0                            XOR     AX,AX
 31853 0000689A 89C7                            MOV     DI,AX
 31854                                  	; 15/03/2018
 31855 0000689C 36A3[0A03]                      MOV     [SS:FirstArena],AX	; init the options
 31856 000068A0 36A3[0C03]                      MOV     [SS:BestArena],AX
 31857 000068A4 36A3[0E03]                      MOV     [SS:LastArena],AX
 31858 000068A8 50                              PUSH    AX                      ; alloc_max <- 0
 31859                                  	; 04/08/2018
 31860                                  start_scan:
 31861                                  	; MSDOS 6.0
 31862                                  	;mov	ax,[SS:start_arena]	; M000: AX <- beginning of arena
 31863                                  	;
 31864 000068A9 36A1[2400]              	MOV     AX,[SS:arena_head]	; AX <- beginning of arena
 31865 000068AD E8B3FF                  	CALL    check_signature         ; ES <- AX, carry set if error
 31866 000068B0 7212                            JC      SHORT alloc_err		; IF error THEN GOTO err
 31867                                  
 31868                                  alloc_scan:
 31869 000068B2 06                              PUSH    ES
 31870 000068B3 1F                              POP     DS                      ; DS <- ES
 31871 000068B4 393E0100                        CMP     [ARENA.OWNER],DI
 31872 000068B8 742A                            JZ      SHORT alloc_free	; IF current block is free THEN examine
 31873                                  
 31874                                  alloc_next:
 31875                                  	; MSDOS 6.0			; M000 - start 
 31876                                  	;test	byte [UmbFlag],LINKSTATE ; Q: are umb's linked
 31877                                  	;jz	short norm_strat	; N: see if we reached last arena
 31878                                  	;
 31879                                  	;test	byte [AllocMethod],HIGH_FIRST
 31880                                  	;				; Q: is alloc strategy high_first
 31881                                  	;jz	short norm_strat	; N: see if we reached last arena
 31882                                  	;mov	ax,[start_arena]
 31883                                  	;cmp	ax,[arena_head]		; Q: did we start scan from 
 31884                                  					;    arena_head
 31885                                  	;jne	short norm_strat	; N: see if we reached last arena
 31886                                  	;mov	ax,ds			; ax = current block
 31887                                  	;cmp	ax,[umb_head]		; Q: check against umb_head 
 31888                                  	;jmp	short alloc_chk_end
 31889                                  
 31890                                  ;norm_strat:
 31891                                  	;cmp	byte [di],5Ah ; 'Z'
 31892 000068BA 803D5A                          CMP     BYTE [DI],arena_signature_end
 31893                                                                          ; IF current block is last THEN
 31894 000068BD 740E                            JZ      SHORT alloc_end		;   GOTO end
 31895 000068BF E89AFF                          CALL    arena_next              ; AX, ES <- next block, Carry set if error
 31896 000068C2 73EE                            JNC     SHORT alloc_scan	; IF no error THEN GOTO scan
 31897                                  
 31898                                  alloc_err:
 31899 000068C4 58                              POP     AX
 31900                                  
 31901                                  alloc_trashed:
 31902                                  	;LeaveCrit critMem
 31903 000068C5 E84DB8                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0	
 31904                                          ;error	error_arena_trashed
 31905                                  	;mov	al,7
 31906 000068C8 B007                    	MOV	AL,error_arena_trashed
 31907                                  alloc_errj:
 31908 000068CA E9D7AE                  	JMP	SYS_RET_ERR
 31909                                  
 31910                                  alloc_end:
 31911 000068CD 36833E[0A03]00                  CMP	WORD [SS:FirstArena],0	; 15/03/2018
 31912 000068D3 756B                    	JNZ     SHORT alloc_do_split
 31913                                  
 31914                                  	; MSDOS 6.0
 31915                                  	;mov	ax,[arena_head]
 31916                                  	;cmp	ax,[start_arena]	; Q: started scanning from arena_head
 31917                                  	;je	short alloc_fail	; Y: not enough memory
 31918                                  	;				; N:
 31919                                  	;				; Q: is the alloc strat HIGH_ONLY
 31920                                  	;test 	byte [AllocMethod],HIGH_ONLY
 31921                                  	;jnz	short alloc_fail	; Y: return size of largest UMB
 31922                                  	;
 31923                                  	;mov	[start_arena],ax	; N: start scanning from arena_head
 31924                                  	;jmp	short start_scan
 31925                                  	;				; M000 - end
 31926                                  
 31927                                  alloc_fail:
 31928                                          ;invoke Get_User_Stack
 31929 000068D5 E871AD                          CALL	Get_User_Stack
 31930 000068D8 5B                      	POP     BX
 31931                                          ;MOV	[SI].user_BX,BX
 31932                                  	;MOV	[SI+2],BX
 31933 000068D9 895C02                  	mov	[SI+user_env.user_BX],bx
 31934                                  	;LeaveCrit critMem
 31935 000068DC E836B8                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 31936                                  	;error	error_not_enough_memory
 31937                                  	;mov	al,8
 31938 000068DF B008                    	MOV	AL,error_not_enough_memory
 31939                                  	;jmp	short alloc_errj
 31940 000068E1 E9C0AE                  	JMP	SYS_RET_ERR
 31941                                  
 31942                                  alloc_free:
 31943 000068E4 E88CFF                          CALL    Coalesce		; add following free block to current
 31944 000068E7 72DB                            JC	SHORT alloc_err		; IF error THEN GOTO err
 31945 000068E9 8B0E0300                        MOV     CX,[ARENA.SIZE]
 31946 000068ED 5A                              POP     DX                      ; check for max found size
 31947 000068EE 39D1                            CMP     CX,DX
 31948 000068F0 7602                            JNA     SHORT alloc_test
 31949 000068F2 89CA                            MOV     DX,CX
 31950                                  
 31951                                  alloc_test:
 31952 000068F4 52                              PUSH    DX
 31953 000068F5 39CB                            CMP     BX,CX                   ; IF BX > size of current block THEN
 31954 000068F7 77C1                            JA      SHORT alloc_next	;   GOTO next
 31955                                  
 31956                                  	; 15/03/2018
 31957 000068F9 36833E[0A03]00                  CMP     WORD [SS:FirstArena],0
 31958 000068FF 7505                    	JNZ	SHORT alloc_best
 31959 00006901 368C1E[0A03]                    MOV     [SS:FirstArena],DS	; save first one found	
 31960                                  alloc_best:
 31961 00006906 36833E[0C03]00                  CMP     WORD [SS:BestArena],0
 31962 0000690C 740E                            JZ      SHORT alloc_make_best	; initial best
 31963 0000690E 06                              PUSH	ES
 31964 0000690F 368E06[0C03]                    MOV     ES,[SS:BestArena]
 31965 00006914 26390E0300                      CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
 31966 00006919 07                              POP	ES
 31967 0000691A 7605                            JBE     SHORT alloc_last
 31968                                  alloc_make_best:
 31969 0000691C 368C1E[0C03]                    MOV     [SS:BestArena],DS	; assign best
 31970                                  alloc_last:
 31971 00006921 368C1E[0E03]                    MOV     [SS:LastArena],DS 	; assign last
 31972 00006926 EB92                            JMP     SHORT alloc_next
 31973                                  ;
 31974                                  ; split the block high
 31975                                  ;
 31976                                  alloc_do_split_high:
 31977 00006928 368E1E[0E03]                    MOV     DS,[SS:LastArena]
 31978 0000692D 8B0E0300                        MOV     CX,[ARENA.SIZE]
 31979 00006931 29D9                            SUB     CX,BX
 31980 00006933 8CDA                            MOV     DX,DS
 31981 00006935 7444                            JE      SHORT alloc_set_owner	; sizes are equal, no split
 31982 00006937 01CA                            ADD     DX,CX                   ; point to next block
 31983 00006939 8EC2                            MOV     ES,DX                   ; no decrement!
 31984 0000693B 49                              DEC     CX
 31985 0000693C 87D9                            XCHG    BX,CX                   ; bx has size of lower block
 31986 0000693E EB26                            JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
 31987                                  ;
 31988                                  ; we have scanned memory and have found all appropriate blocks
 31989                                  ; check for the type of allocation desired; first and best are identical
 31990                                  ; last must be split high
 31991                                  ;
 31992                                  alloc_do_split:
 31993                                  	; 04/08/2018
 31994                                  	; MSDOS 6.0			; M000 - start
 31995                                  	;xor	cx,cx
 31996                                  	;mov	cl,[AllocMethod]
 31997                                  	;and	cx,STRAT_MASK		; mask off bit 7
 31998                                  	;cmp	cx,BEST_FIT		; Q; is the alloc strategy best_fit
 31999                                  
 32000                                  	; 15/03/2018
 32001                                          ;CMP     BYTE [SS:AllocMethod], 1
 32002                                  	; 04/08/2018
 32003 00006940 36803E[CE02]01          	CMP     BYTE [SS:AllocMethod],BEST_FIT
 32004 00006946 77E0                            JA      SHORT alloc_do_split_high
 32005 00006948 368E1E[0A03]                    MOV     DS,[SS:FirstArena]        
 32006 0000694D 7205                    	JB      SHORT alloc_get_size
 32007 0000694F 368E1E[0C03]            	MOV     DS,[SS:BestArena]
 32008                                  
 32009                                  alloc_get_size:
 32010 00006954 8B0E0300                        MOV     CX,[ARENA.SIZE]
 32011 00006958 29D9                            SUB     CX,BX                   ; get room left over
 32012 0000695A 8CD8                            MOV     AX,DS
 32013 0000695C 89C2                            MOV     DX,AX                   ; save for owner setting
 32014 0000695E 741B                            JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
 32015 00006960 01D8                            ADD     AX,BX
 32016 00006962 40                              INC     AX                      ; remember the header
 32017 00006963 8EC0                            MOV     ES,AX                   ; ES <- DS + BX (new header location)
 32018 00006965 49                              DEC     CX                      ; CX <- size of split block
 32019                                  alloc_set_sizes:
 32020 00006966 891E0300                        MOV     [ARENA.SIZE],BX		; current size <- BX
 32021 0000696A 26890E0300                      MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
 32022                                  	;mov	bl,4Dh ; 'M'
 32023 0000696F B34D                            MOV     BL,arena_signature_normal
 32024 00006971 861D                            XCHG    BL,[DI]			; current signature <- 4D
 32025 00006973 26881D                          MOV     [ES:DI],BL		; new block sig <- old block sig
 32026 00006976 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 32027                                  
 32028                                  alloc_set_owner:
 32029 0000697B 8EDA                            MOV     DS,DX
 32030 0000697D 36A1[FC02]                      MOV     AX,[SS:CurrentPDB] ; 15/03/2018
 32031 00006981 A30100                          MOV     [ARENA.OWNER],AX
 32032 00006984 8CD8                            MOV     AX,DS
 32033 00006986 40                              INC     AX
 32034 00006987 5B                              POP     BX
 32035                                  	;LeaveCrit critMem
 32036 00006988 E88AB7                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 32037                                          ;transfer SYS_RET_OK
 32038 0000698B E90DAE                  	JMP	SYS_RET_OK
 32039                                  
 32040                                  
 32041                                  ;	BREAK $SETBLOCK - change size of an allocated block (if possible)
 32042                                  
 32043                                  ; MSDOS 6.0
 32044                                  ;----------------------------------------------------------------------------
 32045                                  ;**	$SETBLOCK - Change size of an Alocated Block
 32046                                  ;
 32047                                  ;	Setblock changes the size of an allocated block.  First, we coalesce
 32048                                  ;	any following free space onto this block; then we try to trim the
 32049                                  ;	block down to the size requested.
 32050                                  ;
 32051                                  ;	Note that if the guy wants to grow the block but that growth fails,
 32052                                  ;	we still go ahead and coalesce any trailing free blocks onto it.
 32053                                  ;	Thus the maximum-size-possible value that we return has already
 32054                                  ;	been allocated!  This is a bug, dare we fix it?  BUGBUG
 32055                                  ;
 32056                                  ;	NOTE - $SETBLOCK is in bed with $ALLOC and jumps into $ALLOC to
 32057                                  ;		finish it's work.  FOr this reason we build the allocsf
 32058                                  ;		structure on the frame, to make us compatible with $ALLOCs
 32059                                  ;		code.
 32060                                  ;
 32061                                  ;	ENTRY	(es) = segment of old block
 32062                                  ;		(bx) = newsize
 32063                                  ;		(ah) = SETBLOCK
 32064                                  ;
 32065                                  ;	EXIT	'C' clear if OK
 32066                                  ;		'C' set if error
 32067                                  ;		  (ax) = error_invalid_block
 32068                                  ;		       = error_arena_trashed
 32069                                  ;		       = error_not_enough_memory
 32070                                  ;		       = error_invalid_function
 32071                                  ;		  (bx) = maximum size possible, iff (ax) = error_not_enough_memory
 32072                                  ;	USES	???? BUGBUG
 32073                                  ;----------------------------------------------------------------------------
 32074                                  
 32075                                  ; MSDOS 2.11 (& MSDOS 3.3)
 32076                                  ;----------------------------------------------------------------------------
 32077                                  ;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
 32078                                  ;
 32079                                  ;   Assembler usage:
 32080                                  ;           MOV     ES,block
 32081                                  ;           MOV     BX,newsize
 32082                                  ;           MOV     AH,setblock
 32083                                  ;           INT     21h
 32084                                  ;         if setblock fails for growing, BX will have the maximum
 32085                                  ;         size possible
 32086                                  ;   Error return:
 32087                                  ;           AX = error_invalid_block
 32088                                  ;              = error_arena_trashed
 32089                                  ;              = error_not_enough_memory
 32090                                  ;              = error_invalid_function
 32091                                  ;----------------------------------------------------------------------------
 32092                                  
 32093                                  _$SETBLOCK:        
 32094                                  	; 04/08/2018 - Retro DOS v3.0
 32095                                  	;EnterCrit   critMem
 32096 0000698E E87CB7                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 32097                                  
 32098 00006991 BF0000                  	MOV     DI,ARENA.SIGNATURE
 32099 00006994 8CC0                            MOV     AX,ES
 32100 00006996 48                              DEC     AX
 32101 00006997 E8C9FE                          CALL    check_signature
 32102 0000699A 7303                            JNC     SHORT setblock_grab
 32103                                  
 32104                                  setblock_bad:
 32105 0000699C E926FF                          JMP     alloc_trashed
 32106                                  
 32107                                  setblock_grab:
 32108 0000699F 8ED8                            MOV     DS,AX
 32109 000069A1 E8CFFE                          CALL    Coalesce
 32110 000069A4 72F6                            JC      SHORT setblock_bad
 32111 000069A6 8B0E0300                        MOV     CX,[ARENA.SIZE]
 32112 000069AA 51                              PUSH    CX
 32113 000069AB 39CB                            CMP     BX,CX
 32114 000069AD 76A5                            JBE     SHORT alloc_get_size
 32115 000069AF E923FF                          JMP     alloc_fail
 32116                                  
 32117                                  ;	BREAK $DEALLOC - free previously allocated piece of memory
 32118                                  
 32119                                  ; MSDOS 6.0
 32120                                  ;----------------------------------------------------------------------------
 32121                                  ;**	$DEALLOC - Free Heap Memory
 32122                                  ;
 32123                                  ;	ENTRY	(es) = address of item
 32124                                  ;
 32125                                  ;	EXIT	'C' clear of OK
 32126                                  ;		'C' set if error
 32127                                  ;		  (AX) = error_invalid_block
 32128                                  ;	USES	???? BUGBUG
 32129                                  
 32130                                  ; MSDOS 2.11 (& MSDOS 3.3)
 32131                                  ;----------------------------------------------------------------------------
 32132                                  ;SUBTTL $DEALLOC - free previously allocated piece of memory
 32133                                  ;
 32134                                  ;   Assembler usage:
 32135                                  ;           MOV     ES,block
 32136                                  ;           MOV     AH,dealloc
 32137                                  ;           INT     21h
 32138                                  ;
 32139                                  ;   Error return:
 32140                                  ;           AX = error_invalid_block
 32141                                  ;              = error_arena_trashed
 32142                                  ;---------------------------------------------------------------------------- 
 32143                                  
 32144                                  _$DEALLOC:    
 32145                                  	; 04/08/2018 - Retro DOS v3.0
 32146                                  	;EnterCrit   critMem
 32147 000069B2 E858B7                  	call	EcritMem ; MSDOS 3.3 & MSDOS 6.0
 32148                                  
 32149                                  	; MSDOS 6.0			; M016, M068 - Start
 32150                                  	;test	byte [DOS_FLAG],EXECA20OFF
 32151                                  					; Q: was the previous call an int 21
 32152                                  					;    exec call
 32153                                  	;jz	short deallocate	; N: continue
 32154                                  	;cmp	byte [A20OFF_COUNT], 0	; Q: is count 0
 32155                                  	;jne	short deallocate	; N: continue
 32156                                  	;mov	byte [A20OFF_COUNT], 1	; Y: set count to 1
 32157                                  ;deallocate:				; M016, M068 - End
 32158                                      
 32159 000069B5 BF0000                  	MOV     DI,ARENA.SIGNATURE ; = 0
 32160 000069B8 8CC0                            MOV     AX,ES
 32161 000069BA 48                              DEC     AX
 32162 000069BB E8A5FE                          CALL    check_signature
 32163 000069BE 720B                            JC      SHORT dealloc_err
 32164 000069C0 26893E0100                      MOV     [ES:ARENA.OWNER],DI
 32165                                  	;LeaveCrit critMem
 32166 000069C5 E84DB7                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 32167                                          ;transfer SYS_RET_OK
 32168 000069C8 E9D0AD                  	JMP	SYS_RET_OK
 32169                                  
 32170                                  dealloc_err:
 32171                                  	;LeaveCrit critMem
 32172 000069CB E847B7                  	call    LcritMem ; MSDOS 3.3 & MSDOS 6.0
 32173                                          ;error	error_invalid_block
 32174                                  	;mov	al,9
 32175 000069CE B009                    	MOV	AL,error_invalid_block
 32176 000069D0 E9D1AD                  	JMP	SYS_RET_ERR
 32177                                  
 32178                                  ;	BREAK $AllocOper - get/set allocation mechanism
 32179                                  
 32180                                  ; MSDOS 6.0
 32181                                  ;----------------------------------------------------------------------------
 32182                                  ;**	$AllocOper - Get/Set Allocation Mechanism
 32183                                  ;
 32184                                  ;	Assembler usage:
 32185                                  ;           MOV     AH,AllocOper
 32186                                  ;           MOV     BX,method
 32187                                  ;           MOV     AL,func
 32188                                  ;           INT     21h
 32189                                  ;
 32190                                  ;	ENTRY	
 32191                                  ;		(al) = 0
 32192                                  ;		  Get allocation Strategy in (ax)
 32193                                  ;
 32194                                  ;		(al) = 1, (bx) = method = zw0000xy
 32195                                  ;		  Set allocation strategy.
 32196                                  ;		   w  = 1  => HIGH_ONLY
 32197                                  ;		   z  = 1  => HIGH_FIRST
 32198                                  ;		   xy = 00 => FIRST_FIT
 32199                                  ;		      = 01 => BEST_FIT
 32200                                  ;		      = 10 => LAST_FIT
 32201                                  ;
 32202                                  ;		(al) = 2
 32203                                  ;		  Get UMB link state in (al)
 32204                                  ;
 32205                                  ;		(al) = 3
 32206                                  ;		  Set UMB link state
 32207                                  ;		   (bx) = 0 => Unlink UMBs
 32208                                  ;		   (bx) = 1 => Link UMBs
 32209                                  ;
 32210                                  ;
 32211                                  ;	EXIT	'C' clear if OK
 32212                                  ;
 32213                                  ;		 if (al) = 0
 32214                                  ;		  (ax) = existing method
 32215                                  ;		 if (al) = 1
 32216                                  ;		  Sets allocation strategy
 32217                                  ;		 if (al) = 2
 32218                                  ;		  (al) = 0 => UMBs not linked
 32219                                  ;		  (al) = 1 => UMBs linked in
 32220                                  ;		 if (al) = 3
 32221                                  ;		  Links/Unlinks the UMBs into DOS chain
 32222                                  ;
 32223                                  ;		'C' set if error
 32224                                  ;		  AX = error_invalid_function
 32225                                  ;
 32226                                  ;	Rev. M000 - added support for HIGH_FIRST in (al) = 1. 7/9/90
 32227                                  ; 	Rev. M003 - added functions (al) = 2 and (al) = 3. 7/18/90
 32228                                  ;	Rev. M009 - (al) = 3 will return 'invalid function' in ax if
 32229                                  ;		    umbhead has'nt been initialized by sysinit and 'trashed
 32230                                  ;		    arena' if an arena sig is damaged.
 32231                                  ;----------------------------------------------------------------------------
 32232                                  
 32233                                  ; MSDOS 2.11 (& MSDOS 3.3)
 32234                                  ;----------------------------------------------------------------------------
 32235                                  ;SUBTTL $AllocOper - get/set allocation mechanism
 32236                                  ;
 32237                                  ;   Assembler usage:
 32238                                  ;           MOV     AH,AllocOper
 32239                                  ;           MOV     BX,method
 32240                                  ;           MOV     AL,func
 32241                                  ;           INT     21h
 32242                                  ;
 32243                                  ;   Error return:
 32244                                  ;           AX = error_invalid_function
 32245                                  ;----------------------------------------------------------------------------
 32246                                  
 32247                                  _$ALLOCOPER:
 32248                                  	; MSDOS 6.0
 32249                                  	;or	al, al
 32250                                  	;jz	short AllocGetStrat
 32251                                  	;cmp	al, 1
 32252                                  	;jz	short AllocSetStrat
 32253                                  	;cmp	al, 2
 32254                                  	;jz	short AllocGetLink
 32255                                  	;cmp	al, 3
 32256                                  	;jz	short AllocSetLink
 32257                                  
 32258                                  	; 15/04/2018
 32259 000069D3 3C01                    	CMP     AL,1
 32260 000069D5 720D                            JB      SHORT AllocOperGet
 32261 000069D7 7414                            JZ      SHORT AllocOperSet
 32262                                  
 32263                                  AllocOperError:
 32264                                  	; 04/08/2018 - Retro DOS v3.0
 32265                                  	; MSDOS 3.3 (& MSDOS 6.0)	; Extended Error Locus	
 32266                                  	;mov	byte [ss:EXTERR_LOCUS],5
 32267 000069D9 36C606[EF02]05                  MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 32268                                  	;error	error_invalid_function
 32269                                  	;mov	al,1
 32270 000069DF B001                    	MOV	AL,error_invalid_function
 32271                                  AllocOperErrj:
 32272 000069E1 E9C0AD                  	JMP	SYS_RET_ERR
 32273                                  
 32274                                  ;AllocArenaError:
 32275                                  	; MSDOS 6.0
 32276                                  	;MOV     byte [SS:EXTERR_LOCUS],errLOC_Mem
 32277                                  	;				; M009: Extended Error Locus
 32278                                  	;;error   error_arena_trashed	; M009:
 32279                                  	;MOV	AL,error_arena_trashed
 32280                                  	;;JMP	SYS_RET_ERR
 32281                                  	;jmp	short AllocOperErrj
 32282                                  
 32283                                  ;AllocGetStrat: 
 32284                                  	; MSDOS 6.0
 32285                                  AllocOperGet:
 32286 000069E4 36A0[CE02]                      MOV     AL,[SS:AllocMethod]
 32287 000069E8 30E4                            XOR     AH,AH
 32288                                          ;transfer SYS_RET_OK
 32289 000069EA E9AEAD                  	JMP	SYS_RET_OK
 32290                                  
 32291                                  ;AllocSetStrat: 
 32292                                  	; MSDOS 6.0
 32293                                  	;push	bx			; M000 - start
 32294                                  	;and	bx,STRAT_MASK 		; M064: mask off bit 6 & 7
 32295                                  	;cmp	bx,2			; BX must be 0-2
 32296                                  	;pop	bx			; M000 - end
 32297                                  	;ja	short AllocOperError
 32298                                  
 32299                                  AllocOperSet:
 32300 000069ED 36881E[CE02]                    MOV     [SS:AllocMethod],BL
 32301                                          ;transfer SYS_RET_OK
 32302 000069F2 E9A6AD                  	JMP	SYS_RET_OK
 32303                                  
 32304                                  ;AllocGetLink:
 32305                                  	; MSDOS 6.0
 32306                                  	;mov	al,[UmbFlag]		; return link state in al
 32307                                  	;and 	al,LINKSTATE		
 32308                                  	;;transfer SYS_RET_OK
 32309                                  	;jmp	SYS_RET_OK
 32310                                  
 32311                                  ;AllocSetLink:
 32312                                  	; MSDOS 6.0			; M009 - start
 32313                                  	;mov	cx,[umb_head]		; cx = umb_head
 32314                                  	;cmp	cx,0FFFFh		; Q: has umb_head been initialized
 32315                                  	;je	short AllocOperError	; N: error
 32316                                  	;				; Y: continue
 32317                                  	;				; M009 - end
 32318                                  	;cmp	bx,1			
 32319                                  	;jb	short UnlinkUmbs
 32320                                  	;jz	short LinkUmbs
 32321                                  	;
 32322                                  	;jmp	short AllocOperError
 32323                                  	;
 32324                                  ;UnlinkUmbs:
 32325                                  	;test	byte[UmbFlag],LINKSTATE	; Q: umbs unlinked?
 32326                                  	;jz	short unlinked		; Y: return 
 32327                                  	;
 32328                                  	;call	GetLastArena		; get arena before umb_head in DS
 32329                                  	;jc	short AllocArenaError	; M009: arena trashed
 32330                                  	;
 32331                                  	;				; make it last
 32332                                  	;mov	byte [0],arena_signature_end
 32333                                  	;
 32334                                  	;and	byte [UmbFlag],~LINKSTATE ; indicate unlink'd state in umbflag
 32335                                  	;
 32336                                  ;unlinked:
 32337                                  	;;transfer SYS_RET_OK
 32338                                  	;jmp	SYS_RET_OK
 32339                                  
 32340                                  ;LinkUmbs:
 32341                                  	;test	byte [UmbFlag],LINKSTATE ; Q: umbs linked?
 32342                                  	;jnz	short linked		; Y: return
 32343                                  	;
 32344                                  	;call	GetLastArena		; get arena before umb_head
 32345                                  	;jc	short AllocArenaError	; M009: arena trashed
 32346                                  	;
 32347                                  	;				; make it normal. M061: ds points to
 32348                                  	;				; arena before umb_head
 32349                                  	;mov	byte [0],arena_signature_normal
 32350                                  	;
 32351                                  	;or	byte [UmbFlag],LINKSTATE ; indicate link'd state in umbflag
 32352                                  ;linked:
 32353                                  	;;transfer SYS_RET_OK
 32354                                  	;jmp	SYS_RET_OK
 32355                                  
 32356                                  ; MSDOS 6.0
 32357                                  ;--------------------------------------------------------------------------
 32358                                  ; Procedure Name : GetLastArena		-  M003
 32359                                  ;
 32360                                  ; Inputs	 : cx = umb_head
 32361                                  ;
 32362                                  ;
 32363                                  ; Outputs	 : If UMBs are linked
 32364                                  ;			ES = umb_head
 32365                                  ;			DS = arena before umb_head
 32366                                  ;		   else
 32367                                  ;			DS = last arena
 32368                                  ;			ES = next arena. will be umb_head if NC.
 32369                                  ;
 32370                                  ;		   CY if error
 32371                                  ;
 32372                                  ; Uses		 : DS, ES, DI, BX
 32373                                  ;--------------------------------------------------------------------------
 32374                                  	
 32375                                  ;Procedure	GetLastArena, NEAR
 32376                                  ;
 32377                                  ;	push	ax			; save ax
 32378                                  ;
 32379                                  ;	mov	ax, [arena_head]
 32380                                  ;	mov	es, ax			; es = arena_head
 32381                                  ;	xor	di, di
 32382                                  ;
 32383                                  ;	cmp     byte ptr es:[di],arena_signature_end
 32384                                  ;					; Q: is this the last arena
 32385                                  ;	je	GLA_done		; Y: return last arena in ES		
 32386                                  ;					
 32387                                  ;
 32388                                  ;GLA_next:
 32389                                  ;	mov	ds, ax
 32390                                  ;	call	arena_next		; ax, es -> next arena
 32391                                  ;	jc	GLA_err
 32392                                  ;
 32393                                  ;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
 32394                                  ;	jnz	GLA_chkumb		; Y: terminating condition is 
 32395                                  ;					;    umb_head
 32396                                  ;					; N: terminating condition is 05Ah
 32397                                  ;
 32398                                  ;	cmp     byte ptr es:[di],arena_signature_end
 32399                                  ;					; Q: is this the last arena
 32400                                  ;	jmp	short @f
 32401                                  ;GLA_chkumb:
 32402                                  ;	cmp	ax, cx			; Q: is this umb_head
 32403                                  ;@@:
 32404                                  ;	jne	GLA_next		; N: get next arena
 32405                                  ;
 32406                                  ;GLA_done:
 32407                                  ;					; M061 - Start
 32408                                  ;	test	[UmbFlag], LINKSTATE	; Q: are UMBs linked
 32409                                  ;	jnz	GLA_ret			; Y: we're done
 32410                                  ;					; N: let us confirm that the next 
 32411                                  ;					;    arena is umb_head
 32412                                  ;	mov	ds, ax
 32413                                  ;	call	arena_next		; ax, es -> next arena
 32414                                  ;	jc	GLA_err
 32415                                  ;	cmp	ax, cx			; Q: is this umb_head
 32416                                  ;	jne	GLA_err			; N: error
 32417                                  ;					; M061 - End
 32418                                  ;
 32419                                  ;GLA_ret:				
 32420                                  ;	clc
 32421                                  ;	pop	ax			; M061
 32422                                  ;	ret				; M061
 32423                                  ;
 32424                                  ;GLA_err:
 32425                                  ;	stc				; M061
 32426                                  ;	pop	ax
 32427                                  ;	ret
 32428                                  ;
 32429                                  ;EndProc GetLastArena
 32430                                  
 32431                                  ;============================================================================
 32432                                  ; SRVCALL.ASM, MSDOS 6.0, 1991
 32433                                  ;============================================================================
 32434                                  ; 04/08/2018 - Retro DOS v3.0
 32435                                  
 32436                                  ;	TITLE SRVCALL - Server DOS call
 32437                                  ;	NAME  SRVCALL
 32438                                  
 32439                                  ;**	SRVCALL.ASM - Server DOS call functions
 32440                                  ;
 32441                                  ;
 32442                                  ;	$ServerCall
 32443                                  ;
 32444                                  ;	Modification history:
 32445                                  ;
 32446                                  ;	    Created: ARR 08 August 1983
 32447                                  
 32448                                  ;AsmVars <Installed>
 32449                                  
 32450                                  ;include dpl.asm
 32451                                  
 32452                                  ;Installed = TRUE
 32453                                  
 32454                                  ;BREAK <ServerCall -- Server DOS call>
 32455                                  ;----------------------------------------------------------------------------
 32456                                  ;
 32457                                  ; Procedure Name : $ServerCall
 32458                                  ;
 32459                                  ; Inputs:
 32460                                  ;	DS:DX -> DPL  (except calls 7,8,9)
 32461                                  ; Function:
 32462                                  ;	AL=0	Server DOS call
 32463                                  ;	AL=1	Commit All files
 32464                                  ;	AL=2	Close file by name (SHARING LOADED ONLY) DS:DX in DPL -> name
 32465                                  ;	AL=3	Close all files for DPL_UID
 32466                                  ;	AL=4	Close all files for DPL_UID/PID_PID
 32467                                  ;	AL=5	Get open file list entry
 32468                                  ;		    IN: BX File Index
 32469                                  ;			CX User Index
 32470                                  ;		    OUT:ES:DI -> Name
 32471                                  ;			BX = UID
 32472                                  ;		    CX = # locked blocks held by this UID
 32473                                  ;	AL=6	Get DOS data area
 32474                                  ;		    OUT: DS:SI -> Start
 32475                                  ;			CX size in bytes of swap if indos
 32476                                  ;			DX size in bytes of swap always
 32477                                  ;	AL=7	Get truncate flag
 32478                                  ;	AL=8	Set truncate flag
 32479                                  ;	AL=9	Close all spool files
 32480                                  ;	AL=10	SetExtendedError
 32481                                  ;
 32482                                  ;----------------------------------------------------------------------------
 32483                                  
 32484                                  _$ServerCall:
 32485                                  	; 05/08/2018 - Retro DOS v3.0
 32486                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 657Bh
 32487 000069F5 3C07                    	CMP	AL,7
 32488 000069F7 7204                    	JB	short SET_STUFF
 32489 000069F9 3C09                    	CMP	AL,9
 32490 000069FB 7612                    	JBE	short NO_SET_ID		; No DPL on calls 7,8,9
 32491                                  SET_STUFF:
 32492 000069FD 89D6                    	MOV	SI,DX			; Point to DPL with DS:SI
 32493                                  	;mov	bx,[si+12h]
 32494 000069FF 8B5C12                  	MOV	BX,[SI+DPL.UID]
 32495                                  
 32496                                  	; MSDOS 6.0
 32497                                  ;SR;
 32498                                  ; WIN386 updates the USER_ID itself. If WIN386 is present we skip the updating
 32499                                  ; of USER_ID
 32500                                  ;
 32501                                  	;test	byte [SS:IsWin386],1
 32502                                  	;jnz	short skip_win386
 32503                                  
 32504                                  ;hkn; SS override for user_id and proc_id
 32505                                  	; 15/08/2018
 32506 00006A02 36891E[0803]            	MOV	[SS:USER_ID],BX		; Set UID
 32507                                  
 32508                                  ;skip_win386:
 32509                                  
 32510 00006A07 8B5C14                  	MOV	BX,[SI+DPL.PID]
 32511 00006A0A 36891E[0603]            	MOV	[SS:PROC_ID],BX		; Set process ID
 32512                                  NO_SET_ID:
 32513 00006A0F 36FF36[7814]            	PUSH	word [SS:SERVERLEAVE]	; push return address
 32514 00006A14 36FF36[7614]            	PUSH	word [SS:SERVERTAB]	; push table address
 32515 00006A19 50                      	PUSH	AX
 32516 00006A1A E827B6                  	call	TableDispatch
 32517                                  
 32518                                  ;hkn; SS override
 32519                                  	;mov 	byte [SS:EXETERR_LOCUS],1
 32520 00006A1D 36C606[EF02]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 32521                                  	;error	error_invalid_function
 32522                                  	;mov	al,1
 32523 00006A23 B001                    	MOV	AL,error_invalid_function
 32524                                  servercall_error:
 32525 00006A25 E97CAD                  	JMP	SYS_RET_ERR
 32526                                  
 32527                                  SERVERRETURN:
 32528 00006A28 C3                      	retn
 32529                                  
 32530                                  ; Commit - iterate through the open file list and make sure that the
 32531                                  ; directory entries are correctly updated.
 32532                                  
 32533                                  COMMIT_ALL:
 32534 00006A29 31DB                    	XOR	BX,BX			;   for (i=0; ThisSFT=getSFT(i); i++)
 32535 00006A2B 16                      	push	ss
 32536 00006A2C 1F                      	pop	ds
 32537 00006A2D E8DDB6                  	call	EcritSFT		; Gonna scan SFT cache, lock it down
 32538                                  CommitLoop:
 32539 00006A30 53                      	push	bx
 32540 00006A31 E82501                  	call	SFFromSFN
 32541 00006A34 7223                    	JC	short CommitDone
 32542 00006A36 26833D00                	cmp	word [es:di],0
 32543                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],0
 32544                                  					; if (ThisSFT->refcount != 0)
 32545 00006A3A 7419                    	JZ	short CommitNext
 32546                                  	;cmp	word [es:di],0FFFFh ; -1
 32547 00006A3C 26833DFF                	cmp	word [ES:DI],sf_busy
 32548                                  	;CMP	word [ES:DI+SF_ENTRY.sf_Ref_Count],sf_busy  
 32549                                  					; BUSY SFTs have god knows what
 32550 00006A40 7413                    	JZ	short CommitNext	;   in them.
 32551 00006A42 26F745050080            	TEST	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 32552 00006A48 750B                    	JNZ	short CommitNext	;  Skip Network SFTs so the SERVER
 32553                                  					;	doesn't deadlock
 32554 00006A4A 893E[5A05]              	MOV	[THISSFT],DI
 32555 00006A4E 8C06[5C05]              	MOV	[THISSFT+2],ES
 32556 00006A52 E82BD2                  	call	DOS_COMMIT		;	DOSCommit ();
 32557                                  CommitNext:
 32558 00006A55 5B                      	pop	bx
 32559 00006A56 43                      	INC	BX
 32560 00006A57 EBD7                    	JMP	short CommitLoop
 32561                                  CommitDone:
 32562 00006A59 E8B9B6                  	call	LcritSFT
 32563 00006A5C 5B                      	pop	bx
 32564 00006A5D E93BAD                  	jmp	SYS_RET_OK
 32565                                  
 32566                                  CLOSE_NAME:
 32567                                  
 32568                                  ;if installed
 32569                                  
 32570                                  ;hkn; SS override
 32571 00006A60 36FF1E[7000]            	Call	far [SS:JShare+(5*4)] ; 5 = MFTcloN
 32572                                  ;else
 32573                                  ;	Call	MFTcloN
 32574                                  ;endif
 32575                                  
 32576                                  CheckReturns:
 32577 00006A65 7203                    	JC	short func_err
 32578 00006A67 E931AD                  	jmp	SYS_RET_OK
 32579                                  func_err:
 32580                                  	;transfer SYS_RET_ERR
 32581                                  	;jmp	SYS_RET_ERR
 32582 00006A6A EBB9                    	jmp	short servercall_error
 32583                                  
 32584                                  CLOSE_UID:
 32585                                  
 32586                                  ;if installed
 32587                                  ;hkn; SS override
 32588 00006A6C 36FF1E[6800]            	Call	far [SS:JShare+(3*4)] ; 3 = MTFTclu
 32589                                  ;else
 32590                                  ;	Call	MFTclU
 32591                                  ;endif
 32592 00006A71 EBF2                    	JMP	short CheckReturns
 32593                                  
 32594                                  CLOSE_UID_PID:
 32595                                  
 32596                                  ;if installed
 32597                                  ;hkn; SS override
 32598 00006A73 36FF1E[6C00]            	Call	far [SS:JShare+(4*4)] ; 4 = MFTCloseP 
 32599                                  ;else
 32600                                  ;	Call	MFTCloseP
 32601                                  ;endif
 32602 00006A78 EBEB                    	JMP	CheckReturns
 32603                                  
 32604                                  GET_LIST:
 32605                                  
 32606                                  ;if installed
 32607                                  ;hkn; SS override
 32608 00006A7A 36FF1E[8000]            	Call	far [SS:JShare+(9*4)] ; 9 = MFT_get
 32609                                  ;else
 32610                                  ;	Call	MFT_get
 32611                                  ;endif
 32612 00006A7F 72E9                    	JC	short func_err
 32613 00006A81 E8C5AB                  	call	Get_User_Stack
 32614                                  	;mov	[si+2],bx
 32615 00006A84 895C02                  	MOV	[SI+user_env.user_BX],BX
 32616                                  	;mov	[si+10],di
 32617 00006A87 897C0A                  	MOV	[SI+user_env.user_DI],DI
 32618                                  	;mov	[si+16],es
 32619 00006A8A 8C4410                  	MOV	[SI+user_env.user_ES],ES
 32620                                  SetCXOK:
 32621                                  	;mov	[si+4],cx
 32622 00006A8D 894C04                  	MOV	[SI+user_env.user_CX],CX
 32623 00006A90 E908AD                  	jmp	SYS_RET_OK
 32624                                  
 32625                                  SRV_CALL:
 32626 00006A93 58                      	POP	AX			; get rid of call to $srvcall
 32627 00006A94 1E                      	push	ds
 32628 00006A95 56                      	push	si
 32629 00006A96 E8B0AB                  	call	Get_User_Stack
 32630 00006A99 5F                      	pop	di
 32631 00006A9A 07                      	pop	es
 32632                                  ;
 32633                                  ; DS:SI point to stack
 32634                                  ; ES:DI point to DPL
 32635                                  ;
 32636 00006A9B E885B5                  	call	XCHGP
 32637                                  ;
 32638                                  ; DS:SI point to DPL
 32639                                  ; ES:DI point to stack
 32640                                  ;
 32641                                  ; We now copy the registers from DPL to save stack
 32642                                  ;
 32643 00006A9E 56                      	push	si
 32644 00006A9F B90600                  	MOV	CX,6
 32645 00006AA2 F3A5                    	REP	MOVSW			; Put in AX,BX,CX,DX,SI,DI
 32646 00006AA4 47                      	INC	DI
 32647 00006AA5 47                      	INC	DI			; Skip user_BP
 32648 00006AA6 A5                      	MOVSW				; DS
 32649 00006AA7 A5                      	MOVSW				; ES
 32650 00006AA8 5E                      	pop	si			; DS:SI -> DPL
 32651 00006AA9 8B04                    	mov	ax,[SI]
 32652                                  	;MOV	AX,[SI+DPL.AX]
 32653                                  	;mov	bx,[si+2]
 32654 00006AAB 8B5C02                  	MOV	BX,[SI+DPL.BX]
 32655                                  	;mov	cx,[si+4]
 32656 00006AAE 8B4C04                  	MOV	CX,[SI+DPL.CX]
 32657                                  	;mov	dx,[si+6]
 32658 00006AB1 8B5406                  	MOV	DX,[SI+DPL.DX]
 32659                                  	;mov	di,[si+10]
 32660 00006AB4 8B7C0A                  	MOV	DI,[SI+DPL.DI]
 32661                                  	;mov	es,[si+14]
 32662 00006AB7 8E440E                  	MOV	ES,[SI+DPL.ES]
 32663                                  	;push	word [si+8]
 32664 00006ABA FF7408                  	PUSH	word [SI+DPL.SI]
 32665                                  	;mov	ds,[si+12]
 32666 00006ABD 8E5C0C                  	MOV	DS,[SI+DPL.DS]
 32667 00006AC0 5E                      	POP	SI
 32668                                  
 32669                                  ;hkn; SS override for next 3
 32670 00006AC1 368C1E[A805]            	MOV	[SS:SAVEDS],DS
 32671 00006AC6 36891E[A605]            	MOV	[SS:SAVEBX],BX
 32672 00006ACB 36C606[2F05]FF          	MOV	byte [SS:FSHARING],-1	; set no redirect flag
 32673 00006AD1 E9AFAA                  	jmp	REDISP
 32674                                  
 32675                                  GET_DOS_DATA:
 32676 00006AD4 16                      	push	ss
 32677 00006AD5 07                      	pop	es
 32678 00006AD6 BF[EC02]                	MOV     DI,SWAP_START
 32679 00006AD9 B9[390A]                	MOV     CX,SWAP_END
 32680 00006ADC BA[0403]                	MOV     DX,SWAP_ALWAYS
 32681 00006ADF 29F9                    	SUB     CX,DI
 32682 00006AE1 29FA                    	SUB     DX,DI
 32683 00006AE3 D1E9                    	SHR     CX,1                    ; div by 2, remainder in carry
 32684 00006AE5 83D100                  	ADC     CX,0                    ; div by 2 + round up
 32685 00006AE8 D1E1                    	SHL     CX,1                    ; round up to 2 boundary.
 32686 00006AEA E85CAB                  	call	Get_User_Stack
 32687                                  	;mov	[si+14],es
 32688 00006AED 8C440E                  	MOV     [SI+user_env.user_DS],ES
 32689                                  	;mov	[si+8],di
 32690 00006AF0 897C08                  	MOV     [SI+user_env.user_SI],DI
 32691                                  	;mov	[si+6],dx
 32692 00006AF3 895406                  	MOV     [SI+user_env.user_DX],DX
 32693 00006AF6 EB95                    	JMP	short SetCXOK
 32694                                  
 32695                                  SPOOL_OPER:
 32696                                  	;CallInstall NETSpoolOper,MultNET,37,AX,BX
 32697                                  
 32698 00006AF8 50                      	push    ax
 32699 00006AF9 B82511                  	mov     ax, 1125h
 32700 00006AFC CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - REDIRECTED PRINTER MODE
 32701                                  			; STACK: WORD subfunction
 32702                                  			; Return: CF set on error, AX = error code
 32703                                  			; STACK unchanged
 32704 00006AFE 5B                      	pop	bx
 32705 00006AFF 7203                    	JC	short func_err2
 32706 00006B01 E997AC                  	jmp	SYS_RET_OK
 32707                                  func_err2:
 32708 00006B04 E99DAC                  	jmp	SYS_RET_ERR
 32709                                  
 32710                                  ;Break	<$SetExtendedError - set extended error for later retrieval>
 32711                                  ;--------------------------------------------------------------------------
 32712                                  ;
 32713                                  ; Procedure Name : $SetExtendedError
 32714                                  ;
 32715                                  ; $SetExtendedError takes extended error information and loads it up for the
 32716                                  ; next extended error call.  This is used by interrupt-level proccessors to
 32717                                  ; mask their actions.
 32718                                  ;
 32719                                  ;   Inputs: DS:SI points to DPL which contains all registers
 32720                                  ;   Outputs: none
 32721                                  ;
 32722                                  ;---------------------------------------------------------------------------
 32723                                  
 32724                                  _$SetExtendedError:
 32725                                  
 32726                                  ;hkn; SS override for all variables used
 32727                                  
 32728 00006B07 8B04                    	mov	ax,[si]
 32729                                  	;MOV	AX,[SI+DPL.AX]
 32730 00006B09 36A3[F002]              	MOV	[SS:EXTERR],AX
 32731                                  	;mov	ax,[si+10]
 32732 00006B0D 8B440A                  	MOV	AX,[SI+DPL.DI]
 32733 00006B10 36A3[F402]              	MOV	[SS:EXTERRPT],AX
 32734                                  	;mov	ax,[si+14]
 32735 00006B14 8B440E                  	MOV	AX,[SI+DPL.ES]
 32736 00006B17 36A3[F602]              	MOV	[SS:EXTERRPT+2],AX
 32737                                  	;mov	ax,[si+2]
 32738 00006B1B 8B4402                  	MOV	AX,[SI+DPL.BX]
 32739 00006B1E 36A3[F202]              	MOV	[SS:EXTERR_ACTION],AX
 32740                                  	;mov	ax,[si+4]
 32741 00006B22 8B4404                  	MOV	AX,[SI+DPL.CX]
 32742 00006B25 368826[EF02]            	MOV	[SS:EXTERR_LOCUS],AH
 32743 00006B2A C3                      	retn
 32744                                  
 32745                                  ;============================================================================
 32746                                  ; UTIL.ASM, MSDOS 6.0, 1991
 32747                                  ;============================================================================
 32748                                  ; 05/08/2018 - Retro DOS v3.0
 32749                                  
 32750                                  ;**	Handle related utilities for MSDOS 2.X.
 32751                                  ;
 32752                                  ;	pJFNFromHandle	written
 32753                                  ;	SFFromHandle	written
 32754                                  ;	SFFromSFN	written
 32755                                  ;	JFNFree 	written
 32756                                  ;	SFNFree 	written
 32757                                  ;
 32758                                  ;	Modification history:
 32759                                  ;
 32760                                  ;	    Created: MZ 1 April 1983
 32761                                  
 32762                                  ;	BREAK	<pJFNFromHandle - return pointer to JFN table entry>
 32763                                  
 32764                                  ;**	pJFNFromHandle - Translate Handle to Pointer to JFN
 32765                                  ;----------------------------------------------------------------------------
 32766                                  ;	pJFNFromHandle takes a file handle and turns that into a pointer to
 32767                                  ;	the JFN entry (i.e., to a byte holding the internal file handle #)
 32768                                  ;
 32769                                  ;	NOTE:
 32770                                  ;	  This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 32771                                  ;	  at DOSINIT time with SS NOT DOSGROUP
 32772                                  ;
 32773                                  ;	ENTRY	(bx) = handle
 32774                                  ;	EXIT	'C' clear if ok
 32775                                  ;		  (es:di) = address of JFN value
 32776                                  ;		'C' set if error
 32777                                  ;		  (ax) = error code
 32778                                  ;	USES	AX, DI, ES, Flags
 32779                                  ;----------------------------------------------------------------------------
 32780                                  
 32781                                  pJFNFromHandle:
 32782 00006B2B 2E8E06[FC02]            	MOV	ES,[cs:CurrentPDB]	; get user process data block
 32783                                  	;cmp	bx,[ES:32h]
 32784 00006B30 263B1E3200              	CMP	BX,[ES:PDB.JFN_Length]	; is handle greater than allocated
 32785 00006B35 7204                    	JB	short pjfn10		; no, get offset
 32786                                  ReturnCarry_inv_hndl: ; 05/08/2018 - Retro DOS v3.0
 32787                                  	;mov	al,6
 32788 00006B37 B006                    	MOV     AL,error_invalid_handle ; appropriate error
 32789                                  ReturnCarry:
 32790 00006B39 F9                      	STC                             ; signal error
 32791 00006B3A C3                      	retn				; go back
 32792                                  pjfn10: 
 32793                                  	;les	di,[es:34h]
 32794 00006B3B 26C43E3400              	LES	DI,[ES:PDB.JFN_Pointer]	; get pointer to beginning of table
 32795 00006B40 01DF                    	ADD	DI,BX			; add in offset, clear 'C'
 32796                                  	;clc
 32797                                  pJFNFromHandle_error:
 32798 00006B42 C3                      	retn
 32799                                  
 32800                                  ;BREAK <SFFromHandle - return pointer (or error) to SF entry from handle>
 32801                                  ;----------------------------------------------------------------------------
 32802                                  ;
 32803                                  ; Procedure Name : SFFromHandle
 32804                                  ;
 32805                                  ; SFFromHandle - Given a handle, get JFN and then index into SF table
 32806                                  ;
 32807                                  ;   Input:      BX has handle
 32808                                  ;   Output:     Carry Set
 32809                                  ;                   AX has error code
 32810                                  ;               Carry Reset
 32811                                  ;                   ES:DI has pointer to SF entry
 32812                                  ;   Registers modified: If error, AX,ES, else ES:DI
 32813                                  ; NOTE:
 32814                                  ;   This routine is called from $CREATE_PROCESS_DATA_BLOCK which is called
 32815                                  ;       at DOSINIT time with SS NOT DOSGROUP
 32816                                  ;
 32817                                  ;----------------------------------------------------------------------------
 32818                                  
 32819                                  SFFromHandle:
 32820 00006B43 E8E5FF                  	CALL    pJFNFromHandle          ; get jfn pointer
 32821                                  	;retc				; return if error
 32822 00006B46 72FA                    	jc	short pJFNFromHandle_error
 32823 00006B48 26803DFF                	CMP     BYTE [ES:DI],-1		; unused handle
 32824                                  	;JNZ	short GetSF		; nope, suck out SF
 32825                                  	;;mov	al,6
 32826                                  	;MOV	AL,error_invalid_handle ; appropriate error
 32827                                  	;jmp	short ReturnCarry	; signal it
 32828 00006B4C 74E9                    	jz	short ReturnCarry_inv_hndl ; Retro DOS v3.0 modification
 32829                                  GetSF:
 32830 00006B4E 53                      	push	bx			; save handle
 32831 00006B4F 268A1D                  	MOV     BL,[ES:DI]		; get SFN
 32832 00006B52 30FF                    	XOR     BH,BH                   ; ignore upper half
 32833 00006B54 E80200                  	CALL    SFFromSFN               ; get real sf spot
 32834 00006B57 5B                      	pop	bx			; restore
 32835 00006B58 C3                      	retn                          ; say goodbye
 32836                                  
 32837                                  ;BREAK <SFFromSFN - index into SF table for SFN>
 32838                                  
 32839                                  ;**	SFFromSFN - Get an SF Table entry from an SFN
 32840                                  ;----------------------------------------------------------------------------
 32841                                  ;	SFFromSfn uses an SFN to index an entry into the SF table.  This
 32842                                  ;	is more than just a simple index instruction because the SF table
 32843                                  ;	can be made up of multiple pieces chained together. We follow the
 32844                                  ;	chain to the right piece and then do the index operation.
 32845                                  ;
 32846                                  ;   NOTE:
 32847                                  ;	This routine is called from SFFromHandle which is called
 32848                                  ;       at DOSINIT time with SS NOT DOSGROUP
 32849                                  ;
 32850                                  ;	ENTRY	BX has SF index
 32851                                  ;	EXIT	'C' clear if OK
 32852                                  ;		  ES:DI points to SF entry
 32853                                  ;		'C' set if index too large
 32854                                  ;	USES	BX, DI, ES
 32855                                  ;----------------------------------------------------------------------------
 32856                                  
 32857                                  SFFromSFN:
 32858 00006B59 2EC43E[2A00]            	LES	DI,[CS:SFT_ADDR]	; (es:di) = start of SFT table
 32859                                  sfsfn5:	
 32860                                  	;cmp	bx,[es:di+4]
 32861 00006B5E 263B5D04                	CMP	BX,[ES:DI+SFT.SFCount]	; is handle in this table?
 32862 00006B62 720E                    	JB	short sfsfn7		; yes, go grab it
 32863                                  	;sub	bx,[es:di+4]
 32864 00006B64 262B5D04                	SUB     BX,[ES:DI+SFT.SFCount]
 32865 00006B68 26C43D                  	les	di,[es:di] ; 14/08/2018
 32866                                  	;LES	DI,[ES:DI+SFT.SFLink]	; get next table segment
 32867 00006B6B 83FFFF                  	CMP     DI,-1                   ; end of tables?
 32868 00006B6E 75EE                    	JNZ	short sfsfn5		; no, try again
 32869 00006B70 F9                      	STC
 32870 00006B71 C3                      	retn				; return with error, not found
 32871                                  sfsfn7:
 32872 00006B72 50                      	push	ax
 32873                                  	;mov	ax,53
 32874                                  	;mov	ax,59 ; MSDOS 6.0
 32875                                  	;MOV	AX,SF_ENTRY.size	; put it in a nice place
 32876 00006B73 B03B                    	mov	al,SF_ENTRY.size ; 28/07/2019
 32877 00006B75 F6E3                    	MUL	BL			; (ax) = offset into this SF block
 32878 00006B77 01C7                    	ADD	DI,AX			; add base of SF block
 32879 00006B79 58                      	pop	ax
 32880                                  	;add	di,6
 32881 00006B7A 83C706                  	ADD	DI,SFT.SFTable		; offset into structure, 'C' cleared
 32882 00006B7D C3                      	retn				; return with 'C' clear
 32883                                  
 32884                                  ;	BREAK <JFNFree - return a jfn pointer if one is free>
 32885                                  
 32886                                  ;**	JFNFree - Find a Free JFN Slot
 32887                                  ;----------------------------------------------------------------------------
 32888                                  ;	JFNFree scansthrough the JFN table and returnsa pointer to a free slot
 32889                                  ;
 32890                                  ;	ENTRY	(ss) = DOSDATA
 32891                                  ;	EXIT	'C' clear if OK
 32892                                  ;		  (bx) = new handle
 32893                                  ;		  (es:di) = pointer to JFN slot
 32894                                  ;		'C' set if error
 32895                                  ;		  (al) = error code
 32896                                  ;	USES	bx, di, es, flags
 32897                                  ;----------------------------------------------------------------------------
 32898                                  
 32899                                  JFNFree:
 32900 00006B7E 31DB                    	XOR	BX,BX			; (bx) = initial JFN to try
 32901                                  jfnf1:	
 32902 00006B80 E8A8FF                  	CALL	pJFNFromHandle		; get the appropriate handle
 32903 00006B83 7209                    	JC	short jfnf5		; no more handles
 32904 00006B85 26803DFF                	CMP     BYTE [ES:DI],-1		; free?
 32905 00006B89 7405                    	je	short jfnfx		; yes, carry is clear
 32906 00006B8B 43                      	INC     BX                      ; no, next handle
 32907 00006B8C EBF2                    	JMP	short jfnf1		; and try again
 32908                                  
 32909                                  ;	Error.	'C' set
 32910                                  jfnf5:	
 32911                                  	;mov	al,4
 32912 00006B8E B004                    	MOV	AL,error_too_many_open_files
 32913                                  jfnfx:	
 32914 00006B90 C3                      	retn				; bye
 32915                                  
 32916                                  ;	BREAK <SFNFree - Allocate a free SFN>
 32917                                  
 32918                                  ;**	SFNFree - Allocate a Free SFN/SFT
 32919                                  ;----------------------------------------------------------------------------
 32920                                  ;	SFNFree scans through the sf table looking for a free entry
 32921                                  ;	If it finds one it partially allocates it by setting SFT_REF_COUNT = -1
 32922                                  ;
 32923                                  ;	The problem is that we want to mark the SFT busy so that other threads
 32924                                  ;	can't allocate the SFT before we're finished marking it up.  However,
 32925                                  ;	we can't just mark it busy because we may get blown out of our open
 32926                                  ;	by INT24 and leave the thing orphaned.	To solve this we mark it
 32927                                  ;	"allocation in progress" by setting SFT_REF_COUNT = -1.  If we see
 32928                                  ;	an SFT with this value we look to see if it belongs to this user
 32929                                  ;	and process.  If it does belong to us then it must be an orphan
 32930                                  ;	and we reclaim it.
 32931                                  ;
 32932                                  ;	BUGBUG - improve the performance. I guess it's smaller to call SFFromSFN
 32933                                  ;		over and over, but we could at least set a high water mark...
 32934                                  ;		cause an N^2 loop calling slow SFFromSFN is real slow, too slow
 32935                                  ;		even though this is not a frequently called routine - jgl
 32936                                  ;
 32937                                  ;	ENTRY	(ss) = DOSDATA
 32938                                  ;	EXIT	'C' clear if no error
 32939                                  ;		  (bx) = SFN
 32940                                  ;		  (es:di) = pointer to SFT
 32941                                  ;		  es:[di].SFT_REF_COUNT = -1
 32942                                  ;		'C' set if error
 32943                                  ;		  (al) = error code
 32944                                  ;	USES	bx, di, es, Flags
 32945                                  ;----------------------------------------------------------------------------
 32946                                  
 32947                                  SFNFree:
 32948                                  	;12/08/2018
 32949                                  	;05/08/2018 - Retro DOS v3.0
 32950                                  	; MSDOS 6.0
 32951 00006B91 50                      	push	ax
 32952 00006B92 31DB                    	xor	bx,bx			; (bx) = SFN to consider
 32953                                  sfnf5:	
 32954 00006B94 53                      	push	bx
 32955 00006B95 E8C1FF                  	call	SFFromSFN		; get the potential handle
 32956 00006B98 5B                      	pop	bx
 32957 00006B99 723A                    	jc	short sfnf95		; no more free SFNs
 32958 00006B9B 26833D00                	cmp	word [ES:DI],0
 32959                                  	;cmp	word [ES:DI+SF_ENTRY.sf_Ref_Count],0 ; free?
 32960 00006B9F 741D                    	je	short sfnf20			; yep, got one
 32961                                  	
 32962                                  	;cmp	word [es:di],0FFFFh ; -1
 32963 00006BA1 26833DFF                	cmp	word [ES:DI],sf_busy
 32964                                  	;cmp	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 32965 00006BA5 7403                    	je	short sfnf10		; special busy mark
 32966                                  sfnf7:	
 32967 00006BA7 43                      	inc	bx			; try the next one
 32968 00006BA8 EBEA                    	jmp	short sfnf5
 32969                                  
 32970                                  ;	The SFT has the special "busy" mark; if it belongs to us then
 32971                                  ;	it was abandoned during a earlier call and we can use it.
 32972                                  ;
 32973                                  ;	(bx)	= SFN
 32974                                  ;	(es:di) = pointer to SFT
 32975                                  ;	(TOS)	= caller's (ax)
 32976                                  
 32977                                  sfnf10:	
 32978 00006BAA 36A1[0803]              	mov	ax,[SS:USER_ID]
 32979                                  	;cmp	[es:di+2Fh],ax
 32980 00006BAE 2639452F                	cmp	[ES:DI+SF_ENTRY.sf_UID],ax
 32981 00006BB2 75F3                    	jnz	short sfnf7		; not ours
 32982 00006BB4 36A1[0603]              	mov	ax,[SS:PROC_ID]
 32983                                  	;cmp	[es:di+31h],ax
 32984 00006BB8 26394531                	cmp	[ES:DI+SF_ENTRY.sf_PID],ax
 32985 00006BBC 75E9                    	jnz	short sfnf7		; can't use this one, try the next
 32986                                  
 32987                                  ;	We have an SFT to allocate
 32988                                  ;
 32989                                  ;	(bx)	= SFN
 32990                                  ;	(es:di) = pointer to SFT
 32991                                  ;	(TOS)	= caller's (ax)
 32992                                  
 32993                                  sfnf20:
 32994                                  	; cf = 0 ;; Retro DOS v3.0
 32995                                  
 32996                                  	;mov	word [es:di],0FFFFh
 32997 00006BBE 26C705FFFF              	mov	word [ES:DI],sf_busy
 32998                                  					; make sure that this is allocated
 32999                                  	;mov	word [ES:DI+SF_ENTRY.sf_ref_count],sf_busy
 33000                                  
 33001 00006BC3 36A1[0803]              	mov	ax,[SS:USER_ID]
 33002                                  	;mov	[es:di+2Fh],ax
 33003 00006BC7 2689452F                	mov	[ES:DI+SF_ENTRY.sf_UID],ax
 33004 00006BCB 36A1[0603]              	mov	ax,[SS:PROC_ID]
 33005                                  	;mov	[es:di+31h],ax
 33006 00006BCF 26894531                	mov	[es:DI+SF_ENTRY.sf_PID],ax
 33007                                  sfnf21: ;; Retro DOS v3.0
 33008 00006BD3 58                      	pop	ax
 33009                                  	;clc
 33010 00006BD4 C3                      	retn				; return with no error
 33011                                  
 33012                                  ;**	Error - no more free SFNs
 33013                                  ;
 33014                                  ;	'C' set
 33015                                  ;	(TOS) = saved ax
 33016                                  
 33017                                  sfnf95: 
 33018 00006BD5 58                      	pop	ax
 33019                                  	;mov	al,4
 33020 00006BD6 B004                    	mov	al,error_too_many_open_files
 33021 00006BD8 C3                      	retn				; return with 'C' and error
 33022                                  
 33023                                  ;============================================================================
 33024                                  ; MACRO.ASM, MSDOS 6.0, 1991
 33025                                  ;============================================================================
 33026                                  ; Retro	DOS v3.0 - 11/07/2018
 33027                                  
 33028                                  ;	TITLE	MACRO - Pathname and macro related internal routines
 33029                                  ;	NAME	MACRO
 33030                                  
 33031                                  ;	Microsoft Confidential
 33032                                  ;	Copyright (C) Microsoft Corporation 1991
 33033                                  ;	All Rights Reserved.
 33034                                  
 33035                                  ;**	MACRO.ASM
 33036                                  ;
 33037                                  ;	$AssignOper
 33038                                  ;	FIND_DPB
 33039                                  ;	InitCDS
 33040                                  ;	$UserOper
 33041                                  ;	GetVisDrv
 33042                                  ;	GetThisDrv
 33043                                  ;	GetCDSFromDrv
 33044                                  ;
 33045                                  ;   Revision history:
 33046                                  ;
 33047                                  ;	Created: MZ 4 April 1983
 33048                                  ;		 MZ 18 April 1983   Make TransFCB handle extended FCBs
 33049                                  ;		 AR 2 June 1983     Define/Delete macro for NET redir.
 33050                                  ;		 MZ 3 Nov 83	    Fix InitCDS to reset length to 2
 33051                                  ;		 MZ 4 Nov 83	    Fix NetAssign to use STRLEN only
 33052                                  ;		 MZ 18 Nov 83	    Rewrite string processing for subtree
 33053                                  ;				    aliasing.
 33054                                  ;
 33055                                  ;   MSDOS performs several types of name translation. First, we maintain for
 33056                                  ;   each valid drive letter the text of the current directory on that drive.
 33057                                  ;   For invalid drive letters, there is no current directory so we pretend to
 33058                                  ;   be at the root. A current directory is either the raw local directory
 33059                                  ;   (consisting of drive:\path) or a local network directory (consisting of
 33060                                  ;   \\machine\path. There is a limit on the point to which a .. is allowed.
 33061                                  ;
 33062                                  ;   Given a path, MSDOS will transform this into a real from-the-root path
 33063                                  ;   without . or .. entries. Any component that is > 8.3 is truncated to
 33064                                  ;   this and all * are expanded into ?'s.
 33065                                  ;
 33066                                  ;   The second part of name translation involves subtree aliasing. A list of
 33067                                  ;   subtree pairs is maintained by the external utility SUBST. The results of
 33068                                  ;   the previous 'canonicalization' are then examined to see if any of the
 33069                                  ;   subtree pairs is a prefix of the user path. If so, then this prefix is
 33070                                  ;   replaced with the other subtree in the pair.
 33071                                  ;
 33072                                  ;   A third part involves mapping this "real" path into a "physical" path.  A
 33073                                  ;   list of drive/subtree pairs are maintained by the external utility JOIN.
 33074                                  ;   The output of the previous translation is examined to see if any of the
 33075                                  ;   subtrees in this list are a prefix of the string. If so, then the prefix
 33076                                  ;   is replaced by the appropriate drive letter. In this manner, we can
 33077                                  ;   'mount' one device under another.
 33078                                  ;
 33079                                  ;   The final form of name translation involves the mapping of a user's
 33080                                  ;   logical drive number into the internal physical drive. This is
 33081                                  ;   accomplished by converting the drive number into letter:CON, performing
 33082                                  ;   the above translation and then converting the character back into a drive
 33083                                  ;   number.
 33084                                  ;
 33085                                  ;   There are two main entry points: TransPath and TransFCB. TransPath will
 33086                                  ;   take a path and form the real text of the pathname with all . and ..
 33087                                  ;   removed. TransFCB will translate an FCB into a path and then invoke
 33088                                  ;   TransPath.
 33089                                  ;
 33090                                  ;	A000	version 4.00  Jan. 1988
 33091                                  
 33092                                  ;Installed = TRUE
 33093                                  
 33094                                  ;	I_need	ThisCDS,DWORD		; pointer to CDS used
 33095                                  ;	I_need	CDSAddr,DWORD		; pointer to CDS table
 33096                                  ;	I_need	CDSCount,BYTE		; number of CDS entries
 33097                                  ;	I_need	CurDrv,BYTE		; current macro assignment (old
 33098                                  ;					; current drive)
 33099                                  ;	I_need	NUMIO,BYTE		; Number of physical drives
 33100                                  ;	I_need	fSharing,BYTE		; TRUE => no redirection allowed
 33101                                  ;	I_need	DummyCDS,80h		; buffer for dummy cds
 33102                                  ;	I_need	DIFFNAM,BYTE		; flag for MyName being set
 33103                                  ;	I_need	MYNAME,16		; machine name
 33104                                  ;	I_need	MYNUM,WORD		; machine number
 33105                                  ;	I_need	DPBHEAD,DWORD		; beginning of DPB chain
 33106                                  ;	I_need	EXTERR_LOCUS,BYTE	; Extended Error Locus
 33107                                  ;	I_need	DrvErr,BYTE		; drive error
 33108                                  
 33109                                  ;BREAK <$AssignOper -- Set up a Macro>
 33110                                  ;----------------------------------------------------------------------------
 33111                                  ; Inputs:
 33112                                  ;	AL = 00 get assign mode 		    (ReturnMode)
 33113                                  ;	AL = 01 set assign mode 		    (SetMode)
 33114                                  ;	AL = 02 get attach list entry		    (GetAsgList)
 33115                                  ;	AL = 03 Define Macro (attch start)
 33116                                  ;	    BL = Macro type
 33117                                  ;	       = 0 alias
 33118                                  ;	       = 1 file/device
 33119                                  ;	       = 2 drive
 33120                                  ;	       = 3 Char device -> network
 33121                                  ;	       = 4 File device -> network
 33122                                  ;	    DS:SI -> ASCIZ source name
 33123                                  ;	    ES:DI -> ASCIZ destination name
 33124                                  ;	AL = 04 Cancel Macro
 33125                                  ;	    DS:SI -> ASCIZ source name
 33126                                  ;	AL = 05 Modified get attach list entry
 33127                                  ;	AL = 06 Get ifsfunc item
 33128                                  ;	AL = 07 set in_use of a drive's CDS
 33129                                  ;	     DL = drive number, 0=default  0=A,,
 33130                                  ;	AL = 08 reset in_use of a drive's CDS
 33131                                  ;	     DL = drive number, 0=A, 1=B,,,
 33132                                  ; Function:
 33133                                  ;	Do macro stuff
 33134                                  ; Returns:
 33135                                  ;	Std Xenix style error return
 33136                                  ;----------------------------------------------------------------------------
 33137                                  
 33138                                  _$AssignOper:
 33139                                  	; MSDOS 6.0
 33140                                  	;CMP	AL,7			      ; set in_use ?		;AN000;
 33141                                  	;JNZ	short chk08		      ; no			;AN000;
 33142                                  ;srinuse:								;AN000;
 33143                                  	;PUSH	AX			      ; save al 		;AN000;
 33144                                  	;MOV	AL,DL			      ; AL= drive id		;AN000;
 33145                                  	;CALL	GetCDSFromDrv		      ; ds:si -> cds		;AN000;
 33146                                  	;POP	AX			      ; 			;AN000;
 33147                                  	;JC	short baddrv		      ; bad drive		;AN000;
 33148                                  	;CMP	WORD [SI+curdir.devptr],0     ; dpb ptr =0 ?		;AN000;
 33149                                  	;JZ	short baddrv		      ;     no			;AN000;
 33150                                  	;CMP	AL,7			      ; set ?			;AN000;
 33151                                  	;JNZ	short resetdrv		      ; no			;AN000;
 33152                                  	;OR	word [SI+curdir.flags],curdir_inuse; set in_use		;AN000;
 33153                                  	;JMP	SHORT okdone		      ; 			;AN000;
 33154                                  ;resetdrv:								;AN000;
 33155                                  	;AND	word [SI+curdir_flags],~curdir_inuse ; reset in_use	;AN000;
 33156                                  	;JMP	SHORT okdone			; 			;AN000;
 33157                                  ;baddrv: 								;AN000;
 33158                                  	;MOV	AX,error_invalid_drive	      ; error			;AN000;
 33159                                  	;JMP	SHORT ASS_ERR		      ; 			;AN000;
 33160                                  ;chk08:									;AN000;
 33161                                  	;CMP	AL,8			      ; reset inuse ?		;AN000;
 33162                                  	;JZ	short srinuse 		      ; yes			;AN000;
 33163                                  
 33164                                  	;IF	NOT INSTALLED
 33165                                  	;transfer NET_ASSOPER
 33166                                  	;ELSE
 33167                                  
 33168                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33169 00006BD9 50                      	PUSH	AX
 33170                                  	;mov	ax,111Eh
 33171                                  	;MOV	AX,(MultNET SHL 8) OR 30
 33172 00006BDA B81E11                  	mov	ax,(MultNET*256)+30
 33173 00006BDD CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - DO REDIRECTION
 33174                                  			; SS = DOS CS
 33175                                  			; STACK: WORD function to execute
 33176                                  			; Return: CF set on error, AX = error code
 33177                                  			; STACK unchanged
 33178 00006BDF 5B                      	POP	BX			; Don't zap error code in AX
 33179 00006BE0 7203                    	JC	short ASS_ERR
 33180                                  okdone:
 33181 00006BE2 E9B6AB                  	jmp	SYS_RET_OK
 33182                                  
 33183                                  ASS_ERR:
 33184 00006BE5 E9BCAB                  	jmp	SYS_RET_ERR
 33185                                  
 33186                                  	;ENDIF
 33187                                  
 33188                                  ;Break <FIND_DPB - Find a DPB from a drive number>
 33189                                  ;----------------------------------------------------------------------------
 33190                                  ;**	FIND_DPB - Find a DPB from a Drive #
 33191                                  ;
 33192                                  ;	ENTRY	AL has drive number A = 0
 33193                                  ;	EXIT	'C' set
 33194                                  ;		    No DPB for this drive number
 33195                                  ;		'C' clear
 33196                                  ;		    DS:SI points to DPB for drive
 33197                                  ;	USES	SI, DS, Flags
 33198                                  ;----------------------------------------------------------------------------
 33199                                  
 33200                                  FIND_DPB:
 33201 00006BE8 36C536[2600]            	LDS	SI,[SS:DPBHEAD]		;smr;SS Override
 33202                                  fdpb5:	
 33203 00006BED 83FEFF                  	CMP	SI,-1
 33204 00006BF0 7409                    	JZ	short fdpb10
 33205 00006BF2 3A04                    	cmp	al,[si]
 33206                                  	;CMP	AL,[SI+DPB.DRIVE]
 33207 00006BF4 7406                    	jz	short ret_label15	; Carry clear (retz)
 33208                                  	;lds	si,[si+18h]
 33209 00006BF6 C57419                  	LDS	SI,[SI+DPB.NEXT_DPB]
 33210 00006BF9 EBF2                    	JMP	short fdpb5
 33211                                  
 33212                                  fdpb10:	
 33213 00006BFB F9                      	STC
 33214                                  
 33215                                  ret_label15:
 33216 00006BFC C3                      	retn
 33217                                  
 33218                                  ;	Break <InitCDS - set up an empty CDS>
 33219                                  ;----------------------------------------------------------------------------
 33220                                  ;**	InitCDS - Setup an Empty CDS
 33221                                  ;
 33222                                  ;	ENTRY	ThisCDS points to CDS
 33223                                  ;		AL has uppercase drive letter
 33224                                  ;	EXIT	ThisCDS is now empty
 33225                                  ;		(ES:DI) = CDS
 33226                                  ;		'C' set if no DPB associated with drive
 33227                                  ;	USES	AH,ES,DI, Flags
 33228                                  ;----------------------------------------------------------------------------
 33229                                  
 33230                                  InitCDS:
 33231                                  	; 19/08/2018
 33232                                  	; 05/08/2018 - Retro DOS v3.0
 33233                                  	; MSDOS 6.0
 33234 00006BFD 50                      	push	ax			; save (AL) for caller
 33235 00006BFE 36C43E[5E05]            	LES	DI,[SS:THISCDS]		; (es:di) = CDS address
 33236                                  	;mov	word [es:di+67],0
 33237 00006C03 26C745430000            	MOV	word [ES:DI+curdir.flags],0 ; "free" CDS
 33238 00006C09 2C40                    	SUB	AL,"A"-1                ; A = 1
 33239 00006C0B 363806[4600]            	CMP	[SS:NUMIO],AL		;smr;SS Override
 33240 00006C10 7236                    	JC	short icdsx		; Drive does not map a physical drive
 33241 00006C12 48                      	dec	ax			; (AL) = 0 if A, 1 if B, etc.
 33242 00006C13 50                      	PUSH	AX			; save drive number for later
 33243 00006C14 0441                    	add	al,"A"
 33244 00006C16 B43A                    	MOV	AH,':'
 33245 00006C18 268905                  	mov	[ES:DI],ax
 33246                                  	;MOV	[ES:DI+curdir.text],AX 	; set "x:"
 33247                                  	;mov	ax,"\"
 33248                                  	;mov	[es:di+2],ax
 33249                                  	;MOV	word [ES:DI+curdir.text+2],"\"	; NUL terminate
 33250 00006C1B 26C745025C00            	mov	word [ES:DI+curdir.text+2],005Ch ; 19/08/2018
 33251                                  	;or	word [es:di+67],4000h
 33252                                  	;or	byte [es:di+68],40h
 33253 00006C21 26804D4440              	OR	byte [ES:DI+curdir.flags+1],curdir_inuse>>8
 33254 00006C26 29C0                    	sub	ax,ax
 33255                                  	;MOV	[es:di+73],ax ; 0
 33256 00006C28 26894549                	MOV	[ES:DI+curdir.ID],ax
 33257                                  	;mov	[es:di+75],ax ; 0
 33258 00006C2C 2689454B                	MOV	[ES:DI+curdir.ID+2],ax
 33259 00006C30 B002                    	mov	al,2
 33260                                  	;mov	[es:di+79],aX ; 2
 33261 00006C32 2689454F                	MOV	[ES:DI+curdir.end],ax
 33262 00006C36 58                      	POP	AX			; (al) = drive number
 33263 00006C37 1E                      	push	ds
 33264 00006C38 56                      	push	si
 33265 00006C39 E8ACFF                  	call	FIND_DPB
 33266 00006C3C 7208                    	JC	short icds5		; OOOOPPPPPSSSS!!!!
 33267                                  	;mov	[es:di+69],si
 33268 00006C3E 26897545                	MOV	[ES:DI+curdir.devptr],SI
 33269                                  	;mov	[es:di+71],ds
 33270 00006C42 268C5D47                	MOV	[ES:DI+curdir.devptr+2],DS
 33271                                  icds5:	
 33272 00006C46 5E                      	pop	si
 33273 00006C47 1F                      	pop	ds
 33274                                  icdsx:	
 33275 00006C48 58                      	pop	ax
 33276                                  RET45:
 33277 00006C49 C3                      	retn
 33278                                  
 33279                                  ;Break <$UserOper - get/set current user ID (for net)>
 33280                                  ;----------------------------------------------------------------------------
 33281                                  ;   $UserOper - retrieve or initiate a user id string.	MSDOS will only
 33282                                  ;	maintain this string and do no verifications.
 33283                                  ;
 33284                                  ;   Inputs:	AL has function type (0-get 1-set 2-printer-set 3-printer-get
 33285                                  ;				      4-printer-set-flags,5-printer-get-flags)
 33286                                  ;		DS:DX is user string pointer (calls 1,2)
 33287                                  ;		ES:DI is user buffer (call 3)
 33288                                  ;		BX is assign index (calls 2,3,4,5)
 33289                                  ;		CX is user number (call 1)
 33290                                  ;		DX is flag word (call 4)
 33291                                  ;   Outputs:	If AL = 0 then the current user string is written to DS:DX
 33292                                  ;			and user CX is set to the user number
 33293                                  ;		If AL = 3 then CX bytes have been put at input ES:DI
 33294                                  ;		If AL = 5 then DX is flag word
 33295                                  ;----------------------------------------------------------------------------
 33296                                  
 33297                                  _$UserOper:
 33298                                  	; 05/08/2018 - Retro DOS v3.0
 33299                                  	; MSDOS 6.0 (& MSDOS 3.3)
 33300 00006C4A 50                      	PUSH	AX
 33301 00006C4B 2C01                    	SUB	AL,1			; quick dispatch on 0,1
 33302 00006C4D 58                      	POP	AX
 33303 00006C4E 7211                    	JB	short UserGet 		; return to user the string
 33304 00006C50 742E                    	JZ	short UserSet 		; set the current user
 33305 00006C52 3C05                    	CMP	AL,5			; test for 2,3,4 or 5
 33306 00006C54 763D                    	JBE	short UserPrint		; yep
 33307                                  	;mov	byte [ss:EXTERR_LOCUS],1
 33308 00006C56 36C606[EF02]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ;smr;SS Override 
 33309                                  					; Extended Error Locus
 33310                                  	;error	error_invalid_function	; not 0,1,2,3
 33311                                  	;mov	al,1
 33312 00006C5C B001                    	MOV	AL,error_invalid_function
 33313                                  useroper_error:
 33314 00006C5E E943AB                  	JMP	SYS_RET_ERR
 33315                                  
 33316                                  UserGet:
 33317                                  ; Transfer MYNAME to DS:DX
 33318                                  ; Set Return CX to MYNUM
 33319 00006C61 1E                      	PUSH	DS			; switch registers
 33320 00006C62 07                      	POP	ES
 33321 00006C63 89D7                    	MOV	DI,DX			; destination
 33322 00006C65 368B0E[0E00]            	MOV	CX,[SS:MYNUM]		; Get number	;smr;SS Override
 33323 00006C6A E8DCA9                  	call	Get_User_Stack
 33324 00006C6D 894C04                  	MOV	[SI+user_env.user_CX],CX ; Set number return
 33325 00006C70 16                      	push	ss			; point to DOSDATA
 33326 00006C71 1F                      	pop	ds
 33327 00006C72 BE[D102]                	MOV	SI,MYNAME		; point source to user string
 33328                                  UserMove:
 33329 00006C75 B90F00                  	MOV	CX,15
 33330 00006C78 F3A4                    	REP	MOVSB			; blam.
 33331 00006C7A 31C0                    	XOR	AX,AX			; 16th byte is 0
 33332 00006C7C AA                      	STOSB
 33333                                  UserBye:
 33334 00006C7D E91BAB                  	jmp	SYS_RET_OK		; no errors here
 33335                                  
 33336                                  UserSet:
 33337                                  ; Transfer DS:DX to MYNAME
 33338                                  ; CX to MYNUM
 33339 00006C80 36890E[0E00]            	MOV	[SS:MYNUM],CX				;smr;SS Override
 33340 00006C85 89D6                    	MOV	SI,DX			; user space has source
 33341 00006C87 16                      	push	ss
 33342 00006C88 07                      	pop	es
 33343 00006C89 BF[D102]                	MOV	DI,MYNAME		; point dest to user string
 33344 00006C8C 36FE06[D002]            	INC	byte [SS:DIFFNAM]	; signal change ;smr;SS Override
 33345 00006C91 EBE2                    	JMP	short UserMove
 33346                                  
 33347                                  UserPrint:
 33348                                  
 33349                                  ;IF NOT Installed
 33350                                  ;	transfer PRINTER_GETSET_STRING
 33351                                  ;ELSE
 33352 00006C93 50                      	PUSH	AX
 33353                                  	;mov	ax,111Fh
 33354                                  	;MOV	AX,(MultNET SHL 8) OR 31
 33355 00006C94 B81F11                  	mov	ax,(MultNET<<8)|31
 33356 00006C97 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - PRINTER SETUP
 33357                                  			; STACK: WORD function
 33358                                  			; Return: CF set on error, AX = error code
 33359                                  			; STACK unchanged
 33360 00006C99 5A                      	POP	DX			; Clean stack
 33361 00006C9A 7302                    	JNC	short OKPA
 33362 00006C9C EBC0                    	jmp	short useroper_error
 33363                                  OKPA:
 33364 00006C9E EBDD                    	jmp	short UserBye
 33365                                  ;ENDIF
 33366                                  
 33367                                  
 33368                                  ;Break	<GetVisDrv - return visible drive>
 33369                                  ;----------------------------------------------------------------------------
 33370                                  ;   GetVisDrv - correctly map non-spliced inuse drives
 33371                                  ;
 33372                                  ;   Inputs:	AL has drive identifier (0=default)
 33373                                  ;   Outputs:	Carry Set - invalid drive/macro
 33374                                  ;		Carry Clear - AL has physical drive (0=A)
 33375                                  ;		    ThisCDS points to CDS
 33376                                  ;   Registers modified: AL
 33377                                  ;----------------------------------------------------------------------------
 33378                                  
 33379                                  GetVisDrv:
 33380                                  	; 05/08/2018 - Retro DOS v3.0
 33381                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6839h
 33382 00006CA0 E81400                  	CALL	GETTHISDRV		; get inuse drive
 33383 00006CA3 72A4                    	jc	short RET45
 33384 00006CA5 1E                      	push	ds
 33385 00006CA6 56                      	push	si
 33386 00006CA7 36C536[5E05]            	LDS	SI,[SS:THISCDS]			;smr;SS Override
 33387                                  	;test	word [si+67],2000h
 33388 00006CAC F744430020              	TEST	word [SI+curdir.flags],curdir_splice
 33389 00006CB1 5E                      	pop	si
 33390 00006CB2 1F                      	pop	ds
 33391 00006CB3 7494                    	jz	short RET45		; if not spliced, return OK
 33392                                  	; MSDOS 6.0
 33393                                  	;MOV	[SS:DrvErr],error_invalid_drive ;IFS. ;AN000;smr;SS Override
 33394                                  	;
 33395 00006CB5 F9                      	STC				; signal error
 33396 00006CB6 C3                      	retn
 33397                                  
 33398                                  ;Break <Getthisdrv - map a drive designator (0=def, 1=A...)>
 33399                                  ;----------------------------------------------------------------------------
 33400                                  ;   GetThisDrv - look through a set of macros and return the current drive and
 33401                                  ;	macro pointer
 33402                                  ;
 33403                                  ;   Inputs:	AL has drive identifier (1=A, 0=default)
 33404                                  ;   Outputs:
 33405                                  ;		Carry Set - invalid drive/macro
 33406                                  ;		Carry Clear - AL has physical drive (0=A)
 33407                                  ;		   ThisCDS points to macro
 33408                                  ;   Registers modified: AL
 33409                                  ;----------------------------------------------------------------------------
 33410                                  
 33411                                  GETTHISDRV:
 33412                                  	; 05/08/2018
 33413                                  	; 12/07/2018 - Retro DOS v3.0
 33414                                  	; IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6850h
 33415                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33416 00006CB7 08C0                    	OR	AL,AL			; are we using default drive?
 33417 00006CB9 7506                    	JNZ	SHORT GTD10		; no, go get the CDS pointers
 33418 00006CBB 36A0[0203]              	MOV	AL,[SS:CURDRV]		; get the current drive
 33419                                  	;INC	ax			; Counteract next instruction
 33420                                  	; 04/09/2018
 33421 00006CBF FEC0                    	inc	al
 33422                                  GTD10:	
 33423                                  	;DEC	ax			; 0 = A
 33424 00006CC1 FEC8                    	dec	al
 33425 00006CC3 1E                      	PUSH	DS			; save world
 33426 00006CC4 56                      	PUSH	SI
 33427                                  	;mov	byte [ss:EXTERR_LOCUS],2
 33428 00006CC5 36C606[EF02]02          	MOV	BYTE [SS:EXTERR_LOCUS],errLOC_Disk		;smr;SS Override
 33429 00006CCB 36F606[2F05]FF          	TEST	BYTE [SS:FSHARING],-1	; Logical or Physical?	;smr;SS Override
 33430 00006CD1 7421                    	JZ	SHORT GTD20		; Logical
 33431 00006CD3 50                      	PUSH	AX
 33432 00006CD4 06                      	PUSH	ES
 33433 00006CD5 57                      	PUSH	DI
 33434 00006CD6 36C706[5E05][B704]      	MOV	WORD [SS:THISCDS],DUMMYCDS ;smr;SS Override
 33435 00006CDD 368C0E[6005]            	mov	[SS:THISCDS+2],CS ; MSDOS 3.3
 33436                                  	;MOV	[SS:THISCDS+2],SS	;ThisCDS = &DummyCDS;smr;
 33437 00006CE2 0441                    	ADD	AL,'A'
 33438 00006CE4 E816FF                  	CALL	InitCDS			;	InitCDS(c);
 33439                                  	;test	word [es:di+67],4000h
 33440 00006CE7 26F745430040            	TEST	WORD [ES:DI+curdir.flags],curdir_inuse	; Clears carry
 33441 00006CED 5F                      	POP	DI
 33442 00006CEE 07                      	POP	ES
 33443 00006CEF 58                      	POP	AX
 33444 00006CF0 740E                    	JZ	SHORT GTD30		; Not a physical drive.
 33445 00006CF2 EB13                    	JMP	SHORT GTDX		; carry clear
 33446                                  GTD20:
 33447 00006CF4 E81300                  	CALL	GetCDSFromDrv
 33448 00006CF7 7207                    	JC	SHORT GTD30	; Unassigned CDS -> return error already set
 33449                                  	;test	word [si+43h],4000h
 33450 00006CF9 F744430040              	TEST	WORD [SI+curdir.flags],curdir_inuse ; Clears Carry
 33451 00006CFE 7507                    	JNZ	SHORT GTDX		; carry clear
 33452                                  GTD30:	
 33453                                  	; 14/08/2018
 33454                                  	;MOV	AL,error_invalid_drive	; invalid FAT drive
 33455                                  	;MOV	BYTE [ss:DrvErr],AL	; save this for IOCTL
 33456 00006D00 36C606[EF02]01          	MOV	BYTE [ss:EXTERR_LOCUS],errLOC_Unk
 33457 00006D06 F9                      	STC
 33458                                  GTDX:	
 33459 00006D07 5E                      	POP	SI			; restore world
 33460 00006D08 1F                      	POP	DS
 33461 00006D09 C3                      	RETN
 33462                                   
 33463                                  
 33464                                  ;Break <GetCDSFromDrv - convert a drive number to a CDS pointer>
 33465                                  ;----------------------------------------------------------------------------
 33466                                  ;   GetCDSFromDrv - given a physical drive number, convert it to a CDS
 33467                                  ;	pointer, returning an error if the drive number is greater than the
 33468                                  ;	number of CDS's
 33469                                  ;
 33470                                  ;   Inputs:	AL is physical unit # A=0...
 33471                                  ;   Outputs:	Carry Set if Bad Drive
 33472                                  ;		Carry Clear
 33473                                  ;		    DS:SI -> CDS
 33474                                  ;		    [THISCDS] = DS:SI
 33475                                  ;   Registers modified: DS,SI
 33476                                  ;----------------------------------------------------------------------------
 33477                                  
 33478                                  GetCDSFromDrv:
 33479 00006D0A 363A06[4700]            	CMP	AL,[SS:CDSCOUNT]	; is this a valid designator;smr;SS Override
 33480 00006D0F 7202                    	JB	SHORT GetCDS		; yes, go get the macro
 33481 00006D11 F9                      	STC				; signal error
 33482 00006D12 C3                      	RETN				; bye
 33483                                  GetCDS:
 33484 00006D13 53                      	PUSH	BX
 33485 00006D14 50                      	PUSH	AX
 33486 00006D15 36C536[3C00]            	LDS	SI,[SS:CDSADDR]		; get pointer to table	;smr;SS Override
 33487                                  	;mov	bl,81
 33488 00006D1A B351                    	MOV	BL,curdir.size		; size in convenient spot
 33489 00006D1C F6E3                    	MUL	BL			; get net offset
 33490 00006D1E 01C6                    	ADD	SI,AX			; convert to true pointer
 33491 00006D20 368936[5E05]            	MOV	[SS:THISCDS],SI		; store convenient offset;smr;SS Override
 33492 00006D25 368C1E[6005]            	MOV	[SS:THISCDS+2],DS	; store convenient segment;smr;SS Override
 33493 00006D2A 58                      	POP	AX
 33494 00006D2B 5B                      	POP	BX
 33495 00006D2C F8                      	CLC				; no error
 33496 00006D2D C3                      	RETN				; bye!
 33497                                  
 33498                                  ;============================================================================
 33499                                  ; MACRO2.ASM, MSDOS 6.0, 1991
 33500                                  ;============================================================================
 33501                                  ; Retro	DOS v3.0 - 12/07/2018
 33502                                  
 33503                                  ;BREAK <TransFCB - convert an FCB into a path, doing substitution>
 33504                                  ;----------------------------------------------------------------------------
 33505                                  ;   TransFCB - Copy an FCB from DS:DX into a reserved area doing all of the
 33506                                  ;       gritty substitution.
 33507                                  ;
 33508                                  ;   Inputs:     DS:DX - pointer to FCB
 33509                                  ;               ES:DI - point to destination
 33510                                  ;   Outputs:    Carry Set - invalid path in final map
 33511                                  ;               Carry Clear - FCB has been mapped into ES:DI
 33512                                  ;                   Sattrib is set from possibly extended FCB
 33513                                  ;                   ExtFCB set if extended FCB found
 33514                                  ;   Registers modified: most
 33515                                  ;----------------------------------------------------------------------------
 33516                                  
 33517                                  TransFCB:
 33518                                  	; 12/07/2018 - Retro DOS v3.0
 33519                                  	;LocalVar FCBTmp,16
 33520                                  	;ENTER
 33521 00006D2E 55                      	push	bp
 33522 00006D2F 89E5                    	mov	bp,sp
 33523                                  	;sub	sp,15	; MSDOS 3.3
 33524 00006D31 83EC10                  	sub	sp,16	; MSDOS 6.0
 33525 00006D34 16                      	push	ss
 33526 00006D35 07                      	pop	es
 33527 00006D36 06                      	push	es
 33528 00006D37 57                      	push	di
 33529                                  	;lea	di,[bp-15] ; MSDOS 3.3
 33530                                  	;LEA	DI,FCBTmp 
 33531 00006D38 8D7EF0                  	lea	di,[bp-16]		; point to FCB temp area
 33532 00006D3B 36C606[2905]00          	mov	byte [SS:EXTFCB],0	; no extended FCB found ;smr;SS Override
 33533 00006D41 36C606[2A05]00          	mov	byte [SS:SATTRIB],0	; default search attributes;smr;SS Override
 33534 00006D47 E8E2BC                  	call	GetExtended             ; get FCB, extended or not
 33535 00006D4A 740D                    	jz	short GetDrive		; not an extended FCB, get drive
 33536 00006D4C 8A44FF                  	mov	AL,[SI-1]               ; get attributes
 33537 00006D4F 36A2[2A05]              	mov	[SS:SATTRIB],AL		; store search attributes;smr;SS Override
 33538 00006D53 36C606[2905]FF          	mov	byte [SS:EXTFCB],-1	; signal extended FCB  ;smr;SS Override
 33539                                  GetDrive:
 33540 00006D59 AC                      	lodsb				; get drive byte
 33541 00006D5A E85AFF                  	call	GETTHISDRV
 33542 00006D5D 722C                    	jc	short BadPack
 33543 00006D5F E87C03                  	call	TextFromDrive           ; convert 0-based drive to text
 33544                                  ;
 33545                                  ; Scan the source to see if there are any illegal chars
 33546                                  ;
 33547 00006D62 BB[5413]                	mov	bx,CharType		; load lookup table
 33548 00006D65 B90B00                  	mov	cx,11
 33549 00006D68 56                      	push	si			; back over name, ext
 33550                                  FCBScan:
 33551 00006D69 AC                      	lodsb				; get a byte
 33552                                  	; 09/08/2018
 33553                                  	;xlat	byte [es:bx]
 33554 00006D6A 26D7                    	es	xlat			; get flags
 33555                                  	;test	al,8	
 33556 00006D6C A808                    	test	al,FFCB
 33557 00006D6E 741B                    	jz	short BadPack
 33558                                  NextCh: 
 33559 00006D70 E2F7                    	loop	FCBScan
 33560 00006D72 5E                      	pop	si
 33561 00006D73 89FB                    	mov	bx,di
 33562 00006D75 E81AC1                  	call	PackName                ; crunch the path
 33563 00006D78 5F                      	pop	di			; get original destination
 33564 00006D79 07                      	pop	es
 33565 00006D7A 16                      	push	ss			; get DS addressability
 33566 00006D7B 1F                      	pop	ds
 33567                                  	;lea	si,[bp-15] ; MSDOS 3.3
 33568                                  	;LEA	SI,FCBTmp		; point at new pathname
 33569 00006D7C 8D76F0                  	lea	si,[bp-16]
 33570 00006D7F 803F00                  	cmp	byte [bx],0
 33571 00006D82 7407                    	jz	short BadPack
 33572 00006D84 55                      	push	bp
 33573 00006D85 E80E00                  	call	TransPathSet            ; convert the path
 33574 00006D88 5D                      	pop	bp
 33575 00006D89 7303                    	jnc	short FCBRet		; bye with transPath error code
 33576                                  BadPack:
 33577 00006D8B F9                      	STC
 33578                                  	;mov	al,3
 33579 00006D8C B003                    	MOV     AL,error_path_not_found
 33580                                  FCBRet: 
 33581                                  	;LEAVE
 33582 00006D8E 89EC                    	mov	sp,bp
 33583 00006D90 5D                      	pop	bp
 33584                                  TransPath_retn:
 33585 00006D91 C3                      	retn
 33586                                  
 33587                                  ; 12/07/2018 - Retro DOS v3.0
 33588                                  
 33589                                  ;BREAK <TransPath - copy a path, do string sub and put in current dir>
 33590                                  ;----------------------------------------------------------------------------
 33591                                  ;
 33592                                  ;   TransPath - copy a path from DS:SI to ES:DI, performing component string
 33593                                  ;       substitution, insertion of current directory and fixing . and ..
 33594                                  ;       entries. Perform splicing. Allow input string to match splice
 33595                                  ;       exactly.
 33596                                  ;
 33597                                  ;   TransPathSet - Same as above except No splicing is performed if input path
 33598                                  ;       matches splice.
 33599                                  ;
 33600                                  ;   TransPathNoSet - No splicing/local using is performed at all.
 33601                                  ;
 33602                                  ;   The following anomalous behaviour is required:
 33603                                  ;
 33604                                  ;       Drive letters on devices are ignored. (set up DummyCDS)
 33605                                  ;       Paths on devices are ignored. (truncate to 0-length)
 33606                                  ;       Raw net I/O sets ThisCDS => NULL.
 33607                                  ;       fSharing => dummyCDS and no subst/splice. Only canonicalize.
 33608                                  ;
 33609                                  ;   Other behaviour:
 33610                                  ;
 33611                                  ;       ThisCDS set up.
 33612                                  ;       FatRead done on local CDS.
 33613                                  ;       ValidateCDS done on local CDS.
 33614                                  ;
 33615                                  ;   Brief flowchart:
 33616                                  ;
 33617                                  ;       if fSharing then
 33618                                  ;           set up DummyCDS (ThisCDS)
 33619                                  ;           canonicalize (sets cMeta)
 33620                                  ;           splice
 33621                                  ;           fatRead
 33622                                  ;           return
 33623                                  ;       if \\ or d:\\ lead then
 33624                                  ;           set up null CDS (ThisCDS)
 33625                                  ;           canonicalize (sets cMeta)
 33626                                  ;           return
 33627                                  ;       if device then
 33628                                  ;           set up dummyCDS (ThisCDS)
 33629                                  ;           canonicalize (sets cMeta)
 33630                                  ;           return
 33631                                  ;       if file then
 33632                                  ;           getCDS (sets (ThisCDS) from name)
 33633                                  ;           validateCDS (may reset current dir)
 33634                                  ;           Copy current dir
 33635                                  ;           canonicalize (set cMeta)
 33636                                  ;           splice
 33637                                  ;           generate correct CDS (ThisCDS)
 33638                                  ;           if local then
 33639                                  ;               fatread
 33640                                  ;           return
 33641                                  ;
 33642                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 33643                                  ;               DI - point to buffer in DOSDATA
 33644                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 33645                                  ;                   syntax, etc. or user FAILed to I 24.
 33646                                  ;               WFP_Start - points to beginning of buffer
 33647                                  ;               Curr_Dir_End - points to end of current dir in path
 33648                                  ;               DS - DOSDATA
 33649                                  ;   Registers modified: most
 33650                                  ;
 33651                                  ;----------------------------------------------------------------------------
 33652                                  
 33653                                  TransPath:
 33654 00006D92 30C0                    	XOR     AL,AL
 33655 00006D94 EB02                    	JMP     SHORT SetSplice
 33656                                  TransPathSet:
 33657 00006D96 B0FF                    	MOV     AL,-1
 33658                                  SetSplice:
 33659 00006D98 36A2[1603]              	MOV	[SS:NoSetDir],AL	;   NoSetDir = !fExact; ;smr;SS Override
 33660 00006D9C B0FF                    	MOV     AL,-1
 33661                                  TransPathNoSet:
 33662 00006D9E 36A2[2E05]              	MOV	[SS:FSPLICE],AL		;   fSplice = TRUE;     ;smr;SS Override
 33663 00006DA2 36C606[3705]FF          	MOV	byte [ss:CMETA],-1      			;smr;SS Override
 33664 00006DA8 36893E[6E05]            	MOV     [SS:WFP_START],DI 				;smr;SS Override
 33665 00006DAD 36C706[7205]FFFF        	MOV	word [SS:CURR_DIR_END],-1 ; crack from start	;smr;SS Override
 33666 00006DB4 16                      	push	ss
 33667 00006DB5 07                      	pop	es
 33668                                  	;lea	bp,[di+134]
 33669 00006DB6 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; end of buffer
 33670                                  ;
 33671                                  ; if this is through the server dos call, fsharing is set. We set up a
 33672                                  ; dummy cds and let the operation go.
 33673                                  ;
 33674 00006DBA 36F606[2F05]FF          	TEST	byte [SS:FSHARING],-1	; if no sharing		;smr;SS Override
 33675 00006DC0 7435                    	JZ	short CheckUNC		; skip to UNC check
 33676                                  ;
 33677                                  ; ES:DI point to buffer
 33678                                  ;
 33679 00006DC2 E80203                  	CALL	DriveFromText           ; get drive and advance DS:SI
 33680 00006DC5 E8EFFE                  	call	GETTHISDRV              ; Set ThisCDS and convert to 0-based
 33681 00006DC8 722A                    	jc	short NoPath
 33682 00006DCA E81103                  	CALL	TextFromDrive		; drop in new
 33683 00006DCD 8D5D01                  	LEA	BX,[DI+1]               ; backup limit
 33684 00006DD0 E83801                  	CALL	Canonicalize            ; copy and canonicalize
 33685 00006DD3 72BC                    	jc	short TransPath_retn	; errors
 33686                                  ;
 33687                                  ; Perform splices for net guys.
 33688                                  ;
 33689 00006DD5 16                      	push	ss
 33690 00006DD6 1F                      	pop	ds
 33691 00006DD7 8B36[6E05]              	MOV     SI,[WFP_START] 		; point to name
 33692 00006DDB F606[2E05]FF            	TEST	byte [FSPLICE],-1
 33693 00006DE0 7403                    	JZ	short NoServerSplice
 33694 00006DE2 E83602                  	CALL    Splice
 33695                                  NoServerSplice:
 33696 00006DE5 16                      	push	ss
 33697 00006DE6 1F                      	pop	ds                      ; for FATREAD
 33698 00006DE7 C43E[5E05]              	LES     DI,[THISCDS]		; for fatread
 33699 00006DEB E81FB3                  	call	EcritDisk
 33700 00006DEE E8E0F0                  	call	FATREAD_CDS
 33701 00006DF1 E821B3                  	call	LcritDisk
 33702                                  NoPath:
 33703                                  	;mov	al,3
 33704 00006DF4 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 33705 00006DF6 C3                      	retn				; any errors are in Carry flag
 33706                                  
 33707                                  ;
 33708                                  ; Let the network decide if the name is for a spooled device. It will map
 33709                                  ; the name if so.
 33710                                  ;
 33711                                  CheckUNC:
 33712 00006DF7 36C706[5E05]FFFF        	MOV     WORD [SS:THISCDS],-1	; NULL thisCDS		;smr;SS Override
 33713                                  	;CallInstall NetSpoolCheck,MultNET,35
 33714 00006DFE B82311                  	mov	ax,1123h
 33715 00006E01 CD2F                    	int	2Fh	; Multiplex - NETWORK REDIRECTOR - QUALIFY REMOTE FILENAME
 33716                                  			; DS:SI -> ASCIZ filename to canonicalize
 33717                                  			; ES:DI -> 128-byte buffer for qualified name
 33718                                  			; Return: CF set if not resolved
 33719 00006E03 7329                    	JNC	short UNCDone
 33720                                  ;
 33721                                  ; At this point the name is either a UNC-style name (prefixed with two leading
 33722                                  ; \\s) or is a local file/device. Remember that if a net-spooled device was
 33723                                  ; input, then the name has been changed to the remote spooler by the above net
 33724                                  ; call. Also, there may be a drive in front of the \\.
 33725                                  ;
 33726                                  NO_CHECK:
 33727 00006E05 E8BF02                  	CALL    DriveFromText		; eat drive letter
 33728 00006E08 50                      	PUSH    AX                      ; save it
 33729 00006E09 8B04                    	MOV     AX,[SI]			; get first two bytes of path
 33730 00006E0B E81DEB                  	call    PATHCHRCMP              ; convert to normal form
 33731 00006E0E 86E0                    	XCHG    AH,AL                   ; swap for second byte
 33732 00006E10 E818EB                  	call    PATHCHRCMP              ; convert to normal form
 33733 00006E13 751F                    	JNZ	short CheckDevice	; not a path char
 33734 00006E15 38C4                    	CMP     AH,AL                   ; are they same?
 33735 00006E17 751B                    	JNZ	short CheckDevice	; nope
 33736                                  ;
 33737                                  ; We have a UNC request. We must copy the string up to the beginning of the
 33738                                  ; local machine root path
 33739                                  ;
 33740                                  
 33741 00006E19 58                      	POP     AX
 33742 00006E1A A5                      	MOVSW                           ; get the lead \\.
 33743                                  UNCCpy:
 33744 00006E1B AC                      	LODSB                           ; get a byte
 33745 00006E1C E8D0EA                   	call	UCase                   ;AN000;; convert the char
 33746 00006E1F 08C0                    	OR      AL,AL
 33747 00006E21 740E                    	JZ	short UNCTerm		; end of string. All done.
 33748 00006E23 E805EB                  	call    PATHCHRCMP              ; is it a path char?
 33749 00006E26 89FB                    	MOV     BX,DI                   ; backup position
 33750 00006E28 AA                      	STOSB
 33751 00006E29 75F0                    	JNZ	short UNCCpy		; no, go copy
 33752 00006E2B E8DD00                  	CALL    Canonicalize            ; wham (and set cMeta)
 33753                                  UNCDone:
 33754 00006E2E 16                      	push	ss
 33755 00006E2F 1F                      	pop	ds
 33756 00006E30 C3                       	retn				; return error code
 33757                                  UNCTerm:
 33758 00006E31 AA                      	STOSB                           ;AN000;
 33759 00006E32 EBFA                    	JMP	short UNCDone		;AN000;
 33760                                  
 33761                                  CheckDevice:
 33762                                  ;
 33763                                  ; Check DS:SI for device. First eat any path stuff
 33764                                  ;
 33765 00006E34 58                      	POP     AX                      ; retrieve drive info
 33766 00006E35 803C00                  	CMP     BYTE [SI],0		; check for null file
 33767 00006E38 7504                    	JNZ	short CheckPath
 33768                                  	;mov	al,2 
 33769 00006E3A B002                    	MOV     AL,error_file_not_found ; bad file error
 33770 00006E3C F9                      	STC                             ; signal error on null input
 33771 00006E3D C3                      	RETN				; bye!
 33772                                  CheckPath:
 33773 00006E3E 50                      	push	ax
 33774 00006E3F 55                      	push	bp			; save drive number
 33775                                  
 33776                                  	; MSDOS 6.0
 33777                                  ;;;BUGBUG BUG 10-26-1992 scottq
 33778                                  ;;;This is a hack for the CDROM extensions (2.1) who scan looking
 33779                                  ;;;for the following POP BP == 5Dh (restore <bp,ax>).
 33780                                  ;;;The problem is that a direct call to CheckThisDevice can (and did)
 33781                                  ;;;end up having a 5D in the opcode's displacement field. The
 33782                                  ;;;scanning code would choke on this thinking it was a POP BP instruction.
 33783                                  ;;;
 33784                                  ;;;What we do here is do a call to a function that is less than 5Dh
 33785                                  ;;;bytes away (and assert its not exactly 5D away) that jmps (transfers)
 33786                                  ;;;to the correct function. This cannot accidently insert a 5Dh.
 33787                                  ;;;
 33788                                  ;;;More info:
 33789                                  ;;;  This particular scan is begun at the UNCdone label for 32 bytes
 33790                                  ;;;looking for pop BP, so you cannot put a 5D between here and there.
 33791                                  ;;;
 33792 00006E40 E82000                  	call	no5Dshere
 33793                                  start5Dhack:
 33794                                  ;following is replaced with 5Dhack code--Invoke  CheckThisDevice         
 33795                                  backfrom5Dhack:
 33796 00006E43 5D                      	pop	bp
 33797 00006E44 58                      	pop	ax			; get drive letter back
 33798 00006E45 731F                    	JNC	short DoFile		; yes we have a file.
 33799                                  ;
 33800                                  ; We have a device. AX has drive letter. At this point we may fake a CDS ala
 33801                                  ; sharing DOS call. We know by getting here that we are NOT in a sharing DOS
 33802                                  ; call.
 33803                                  ;
 33804 00006E47 36C606[2F05]FF          	MOV	byte [SS:FSHARING],-1	; simulate sharing dos call;smr;SS Override
 33805 00006E4D E867FE                  	call	GETTHISDRV              ; set ThisCDS and init DUMMYCDS
 33806 00006E50 36C606[2F05]00          	MOV     byte [SS:FSHARING],0	;                       ;smr;SS Override
 33807                                  ;
 33808                                  ; Now that we have noted that we have a device, we put it into a form that
 33809                                  ; getpath can understand. Normally getpath requires d:\ to begin the input
 33810                                  ; string. We relax this to state that if the d:\ is present then the path
 33811                                  ; may be a file. If D:/ (note the forward slash) is present then we have
 33812                                  ; a device.
 33813                                  ;
 33814 00006E56 E88502                  	CALL    TextFromDrive
 33815 00006E59 B02F                    	MOV     AL,'/'                  ; path sep.
 33816 00006E5B AA                      	STOSB
 33817 00006E5C E894B1                  	call	StrCpy			; move remainder of string
 33818                                  
 33819 00006E5F F8                      	CLC                             ; everything OK.
 33820 00006E60 16                      	push	ss
 33821 00006E61 1F                      	pop	ds                      ; remainder of OK stuff
 33822                                  DoFile_retn:
 33823 00006E62 C3                      	retn
 33824                                  
 33825                                  no5Dshere:
 33826                                  	; 10/08/2018
 33827 00006E63 E9B3DF                  	jmp	CheckThisDevice		; snoop for device
 33828                                  
 33829                                  ;.erre (no5Dshere - start5Dhack - 5D)
 33830                                  
 33831                                  ;
 33832                                  ; We have a file. Get the raw CDS.
 33833                                  ;
 33834                                  
 33835                                  DoFile:
 33836                                  	; MSDOS 3.3 (& MSDOS 6.0)
 33837                                  
 33838 00006E66 E837FE                  	call	GetVisDrv               ; get proper CDS
 33839                                  	;mov	al,3 
 33840 00006E69 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad file error
 33841 00006E6B 72F5                    	jc	short DoFile_retn  ; CARRY set -> bogus drive/spliced
 33842                                  ;
 33843                                  ; ThisCDS has correct CDS. DS:SI advanced to point to beginning of path/file.
 33844                                  ; Make sure that CDS has valid directory; ValidateCDS requires a temp buffer
 33845                                  ; Use the one that we are going to use (ES:DI).
 33846                                  ;
 33847                                  	;SAVE    <DS,SI,ES,DI>		; save all string pointers.
 33848 00006E6D 1E                      	push	ds
 33849 00006E6E 56                      	push	si
 33850 00006E6F 06                      	push	es
 33851 00006E70 57                      	push	di
 33852 00006E71 E8F1DE                  	call	ValidateCDS             ; poke CDS and make everything OK
 33853                                  	;RESTORE <DI,ES,SI,DS>		; get back pointers
 33854 00006E74 5F                      	pop	di
 33855 00006E75 07                      	pop	es
 33856 00006E76 5E                      	pop	si
 33857 00006E77 1F                      	pop	ds
 33858                                  	;mov	al,3
 33859 00006E78 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 33860                                  	;retc				; someone failed an operation
 33861 00006E7A 72E6                    	jc	short DoFile_retn
 33862                                  ;
 33863                                  ; ThisCDS points to correct CDS. It contains the correct text of the
 33864                                  ; current directory. Copy it in.
 33865                                  ;
 33866 00006E7C 1E                      	push	ds
 33867 00006E7D 56                      	push	si
 33868 00006E7E 36C536[5E05]            	LDS     SI,[SS:THISCDS]		; point to CDS	;smr;SS Override
 33869 00006E83 89FB                    	MOV     BX,DI                   ; point to destination
 33870 00006E85 035C4F                  	ADD     BX,[SI+curdir.end]	; point to backup limit
 33871                                  ;       LEA     SI,[SI+curdir.text]	; point to text
 33872                                  	;lea	bp,[di+134]
 33873 00006E88 8DAD8600                	LEA     BP,[DI+TEMPLEN]         ; regenerate end of buffer
 33874                                  					;AN000;
 33875 00006E8C E873B1                  	call	FStrCpy                 ; copy string. ES:DI point to end
 33876 00006E8F 4F                      	DEC     DI                      ; point to NUL byte
 33877                                  
 33878                                  ;
 33879                                  ; Make sure that there is a path char at end.
 33880                                  ;
 33881 00006E90 B05C                    	MOV     AL,'\'
 33882 00006E92 263845FF                	CMP     [ES:DI-1],AL
 33883 00006E96 7401                    	JZ	short GetOrig
 33884 00006E98 AA                      	STOSB
 33885                                  ;
 33886                                  ; Now get original string.
 33887                                  ;
 33888                                  GetOrig:
 33889 00006E99 4F                      	DEC     DI                      ; point to path char
 33890 00006E9A 5E                      	pop	si
 33891 00006E9B 1F                      	pop	ds
 33892                                  ;
 33893                                  ; BX points to the end of the root part of the CDS (at where a path char
 33894                                  ; should be). Now, we decide whether we use this root or extend it with the
 33895                                  ; current directory.  See if the input string begins with a leading ;
 33897 00006E9C E8D100                  	CALL    PathSep                 ; is DS:SI a path sep?
 33898 00006E9F 7511                    	JNZ	short PathAssure	; no, DI is correct. Assure a path char
 33899 00006EA1 08C0                    	OR      AL,AL                   ; end of string?
 33900 00006EA3 7410                    	JZ	short DoCanon		; yes, skip.
 33901                                  ;
 33902                                  ; The string does begin with a \. Reset the beginning of the canonicalization
 33903                                  ; to this root. Make sure that there is a path char there and advance the
 33904                                  ; source string over all leading \'s.
 33905                                  ;
 33906 00006EA5 89DF                    	MOV     DI,BX                   ; back up to root point.
 33907                                  SkipPath:
 33908 00006EA7 AC                      	LODSB
 33909 00006EA8 E880EA                  	call    PATHCHRCMP
 33910 00006EAB 74FA                    	JZ	short SkipPath
 33911 00006EAD 4E                      	DEC     SI
 33912 00006EAE 08C0                    	OR      AL,AL
 33913 00006EB0 7403                    	JZ	short DoCanon
 33914                                  ;
 33915                                  ; DS:SI start at some file name. ES:DI points at some path char. Drop one in
 33916                                  ; for yucks.
 33917                                  ;
 33918                                  PathAssure:
 33919 00006EB2 B05C                    	MOV     AL,'\'
 33920 00006EB4 AA                      	STOSB
 33921                                  ;
 33922                                  ; ES:DI point to the correct spot for canonicalization to begin.
 33923                                  ; BP is the max extent to advance DI
 33924                                  ; BX is the backup limit for ..
 33925                                  ;
 33926                                  DoCanon:
 33927 00006EB5 E85300                  	CALL    Canonicalize            ; wham.
 33928                                  	;retc				; badly formatted path.
 33929 00006EB8 72A8                    	jc	short DoFile_retn
 33930                                  
 33931                                  ;
 33932                                  ; The string has been moved to ES:DI. Reset world to DOS context, pointers
 33933                                  ; to wfp_start and do string substitution. BP is still the max position in
 33934                                  ; buffer.
 33935                                  ;
 33936 00006EBA 16                      	push	ss
 33937 00006EBB 1F                      	pop	ds
 33938 00006EBC 8B3E[6E05]              	MOV     DI,[WFP_START]		; DS:SI point to string
 33939 00006EC0 C536[5E05]              	LDS     SI,[THISCDS]		; point to CDS
 33940                                  ;       LEA     SI,[SI+curdir.text]	; point to text
 33941 00006EC4 E81F02                  	CALL    PathPref                ; is there a prefix?
 33942 00006EC7 7514                    	JNZ	short DoSplice		; no, do splice
 33943                                  ;
 33944                                  ; We have a match. Check to see if we ended in a path char.
 33945                                  ;
 33946 00006EC9 8A44FF                  	MOV     AL,[SI-1]		; last char to match
 33947 00006ECC E85CEA                  	call    PATHCHRCMP              ; did we end on a path char? (root)
 33948 00006ECF 740C                    	JZ	short DoSplice		; yes, no current dir here.
 33949                                  Pathline:                               ; 2/13/KK
 33950 00006ED1 26803D00                	CMP     BYTE [ES:DI],0		; end at NUL?
 33951 00006ED5 7406                    	JZ	short DoSplice
 33952 00006ED7 47                      	INC     DI                      ; point to after current path char
 33953 00006ED8 36893E[7205]            	MOV     [SS:CURR_DIR_END],DI	; point to correct spot ;smr;SS Override
 33954                                  ;
 33955                                  ; Splice the result.
 33956                                  ;
 33957                                  DoSplice:
 33958 00006EDD 16                      	push	ss
 33959 00006EDE 1F                      	pop	ds			; back to DOSDATA
 33960 00006EDF 8B36[6E05]              	MOV     SI,[WFP_START]		; point to beginning of string
 33961 00006EE3 31C9                    	XOR     CX,CX
 33962 00006EE5 F606[2E05]FF            	TEST	byte [FSPLICE],-1
 33963 00006EEA 7403                    	JZ	short SkipSplice
 33964 00006EEC E82C01                  	CALL    Splice                  ; replaces in place.
 33965                                  SkipSplice:
 33966                                  ;
 33967                                  ; The final thing is to assure ourselves that a FATREAD is done on the local
 33968                                  ; device.
 33969                                  ;
 33970 00006EEF 16                      	push	ss
 33971 00006EF0 1F                      	pop	ds
 33972 00006EF1 C43E[5E05]              	LES     DI,[THISCDS]		; point to correct drive
 33973                                  	;test	word [es:di+67],8000h
 33974 00006EF5 26F745430080            	TEST	word [ES:DI+curdir.flags],curdir_isnet
 33975 00006EFB 750D                    	JNZ	short Done		; net, no fatread necessary (retnz)
 33976 00006EFD E30B                    	JCXZ    Done
 33977 00006EFF E80BB2                  	call	EcritDisk
 33978 00006F02 E8CCEF                  	call	FATREAD_CDS
 33979 00006F05 E80DB2                  	call	LcritDisk
 33980                                  	;mov	al, 3
 33981 00006F08 B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 33982                                  Done:   
 33983 00006F0A C3                      	retn                         ; any errors in carry flag.
 33984                                  
 33985                                  ; 13/07/2018
 33986                                  
 33987                                  ;BREAK <Canonicalize - copy a path and remove . and .. entries>
 33988                                  ;----------------------------------------------------------------------------
 33989                                  ;   Canonicalize - copy path removing . and .. entries.
 33990                                  ;
 33991                                  ;   Inputs:     DS:SI - point to ASCIZ string path
 33992                                  ;               ES:DI - point to buffer
 33993                                  ;               BX - backup limit (offset from ES) points to slash
 33994                                  ;               BP - end of buffer
 33995                                  ;   Outputs:    Carry Set - invalid path specification: too many .., bad
 33996                                  ;                   syntax, etc.
 33997                                  ;               Carry Clear -
 33998                                  ;                   DS:DI - advanced to end of string
 33999                                  ;                   ES:DI - advanced to end of canonicalized form after nul
 34000                                  ;   Registers modified: AX CX DX (in addition to those above)
 34001                                  ;----------------------------------------------------------------------------
 34002                                  
 34003                                  Canonicalize:
 34004                                  ;
 34005                                  ; We copy all leading path separators.
 34006                                  ;
 34007 00006F0B AC                      	LODSB                           ;   while (PathChr (*s))
 34008 00006F0C E81CEA                  	call    PATHCHRCMP
 34009 00006F0F 7507                    	JNZ	short CanonDec
 34010 00006F11 39EF                    	CMP     DI,BP                   ;       if (d > dlim)
 34011 00006F13 7319                    	JAE	short CanonBad		;           goto error;
 34012 00006F15 AA                      	STOSB
 34013 00006F16 EBF3                    	JMP	short Canonicalize	;           *d++ = *s++;
 34014                                  CanonDec:
 34015 00006F18 4E                      	DEC     SI
 34016                                  ;
 34017                                  ; Main canonicalization loop.  We come here with DS:SI pointing to a textual
 34018                                  ; component (no leading path separators) and ES:DI being the destination
 34019                                  ; buffer.
 34020                                  ;
 34021                                  CanonLoop:
 34022                                  ;
 34023                                  ; If we are at the end of the source string, then we need to check to see that
 34024                                  ; a potential drive specifier is correctly terminated with a path sep char.
 34025                                  ; Otherwise, do nothing
 34026                                  ;
 34027 00006F19 31C0                    	XOR     AX,AX
 34028 00006F1B 3804                    	CMP     [SI],AL                 ;       if (*s == 0) {
 34029 00006F1D 751A                    	JNZ	short DoComponent
 34030 00006F1F 26807DFF3A              	CMP     BYTE [ES:DI-1],':'	;           if (d[-1] == ':')
 34031 00006F24 7505                    	JNZ	short DoTerminate
 34032 00006F26 B05C                    	MOV     AL,'\'                  ;               *d++ = '\';
 34033 00006F28 AA                      	STOSB
 34034 00006F29 88E0                    	MOV     AL,AH
 34035                                  DoTerminate:
 34036 00006F2B AA                      	STOSB                           ;           *d++ = 0;
 34037 00006F2C F8                      	CLC                             ;           return (0);
 34038 00006F2D C3                      	retn
 34039                                  
 34040                                  CanonBad:
 34041 00006F2E E8CE01                  	CALL	ScanPathChar            ; check for path chars in rest of string
 34042                                  	;mov	al,3
 34043 00006F31 B003                    	MOV     AL,error_path_not_found ; Set up for bad path error
 34044 00006F33 7402                    	JZ	short PathEnc		; path character encountered in string
 34045                                  	;mov	al,2
 34046 00006F35 B002                    	MOV     AL,error_file_not_found ; Set bad file error
 34047                                  PathEnc:
 34048 00006F37 F9                      	STC
 34049                                  CanonBad_retn:
 34050 00006F38 C3                      	retn
 34051                                  ;
 34052                                  ; We have a textual component that we must copy.  We uppercase it and truncate
 34053                                  ; it to 8.3
 34054                                  ;
 34055                                  DoComponent:                            ;           }
 34056 00006F39 E85100                  	CALL    CopyComponent		;       if (!CopyComponent (s, d))
 34057 00006F3C 72FA                    	jc	short CanonBad_retn	;           return (-1);
 34058                                  ;
 34059                                  ; We special case the . and .. cases.  These will be backed up.
 34060                                  ;
 34061                                  	;CMP	WORD PTR ES:[DI],'.' + (0 SHL 8)
 34062 00006F3E 26833D2E                	CMP	WORD [ES:DI],002Eh
 34063 00006F42 7408                    	JZ	short Skip1
 34064                                  	;CMP	WORD PTR ES:[DI],'..'
 34065 00006F44 26813D2E2E              	CMP     WORD [ES:DI],2E2Eh
 34066 00006F49 750A                    	JNZ	short CanonNormal
 34067 00006F4B 4F                      	DEC     DI                      ;           d--;
 34068                                  Skip1:  
 34069 00006F4C E82B00                  	CALL    SkipBack                ;           SkipBack ();
 34070                                  	;mov	al,3
 34071 00006F4F B003                    	MOV     AL,error_path_not_found ; Set up for possible bad path error
 34072 00006F51 72E5                    	jc	short CanonBad_retn
 34073 00006F53 EB02                    	JMP     short CanonPath         ;           }
 34074                                  ;
 34075                                  ; We have a normal path.  Advance destination pointer over it.
 34076                                  ;
 34077                                  CanonNormal:                            ;       else
 34078 00006F55 01CF                    	ADD     DI,CX                   ;           d += ct;
 34079                                  ;
 34080                                  ; We have successfully copied a component.  We are now pointing at a path
 34081                                  ; sep char or are pointing at a nul or are pointing at something else.
 34082                                  ; If we point at something else, then we have an error.
 34083                                  ;
 34084                                  CanonPath:
 34085 00006F57 E81600                  	CALL    PathSep
 34086 00006F5A 75D2                    	JNZ	short CanonBad		; something else...
 34087                                  ;
 34088                                  ; Copy the first path char we see.
 34089                                  ;
 34090 00006F5C AC                      	LODSB                           ; get the char
 34091 00006F5D E8CBE9                  	call    PATHCHRCMP              ; is it path char?
 34092 00006F60 75B6                    	JNZ	short CanonDec		; no, go test for nul
 34093 00006F62 39EF                    	CMP     DI,BP                   ; beyond buffer end?
 34094 00006F64 73C8                    	JAE	short CanonBad		; yep, error.
 34095 00006F66 AA                      	STOSB                           ; copy the one byte
 34096                                  ;
 34097                                  ; Skip all remaining path chars
 34098                                  ;
 34099                                  CanonPathLoop:
 34100 00006F67 AC                      	LODSB                           ; get next byte
 34101 00006F68 E8C0E9                  	call    PATHCHRCMP              ; path char again?
 34102 00006F6B 74FA                    	JZ	short CanonPathLoop	; yep, grab another
 34103 00006F6D 4E                      	DEC     SI                      ; back up
 34104 00006F6E EBA9                    	JMP	short  CanonLoop	; go copy component
 34105                                  
 34106                                  ;BREAK <PathSep - determine if char is a path separator>
 34107                                  ;----------------------------------------------------------------------------
 34108                                  ;   PathSep - look at DS:SI and see if char is / \ or NUL
 34109                                  ;   Inputs:     DS:SI - point to a char
 34110                                  ;   Outputs:    AL has char from DS:SI (/ => \)
 34111                                  ;               Zero set if AL is / \ or NUL
 34112                                  ;               Zero reset otherwise
 34113                                  ;   Registers modified: AL
 34114                                  ;----------------------------------------------------------------------------
 34115                                  
 34116                                  PathSep:
 34117 00006F70 8A04                    	MOV     AL,[SI]                 ; get the character
 34118                                  PathSepGotCh:				; already have character
 34119 00006F72 08C0                    	OR      AL,AL                   ; test for zero
 34120 00006F74 74C2                    	jz	short CanonBad_retn	; return if equal to zero (NUL)
 34121 00006F76 E8B2E9                  	call    PATHCHRCMP              ; check for path character
 34122 00006F79 C3                      	retn				; and return HIS determination
 34123                                  
 34124                                  ;BREAK <SkipBack - move backwards to a path separator>
 34125                                  ;----------------------------------------------------------------------------
 34126                                  ;   SkipBack - look at ES:DI and backup until it points to a / ;   Inputs:     ES:DI - point to a char
 34128                                  ;               BX has current directory back up limit (point to a / \)
 34129                                  ;   Outputs:    ES:DI backed up to point to a path char
 34130                                  ;               AL has char from output ES:DI (path sep if carry clear)
 34131                                  ;               Carry set if illegal backup
 34132                                  ;               Carry Clear if ok
 34133                                  ;   Registers modified: DI,AL
 34134                                  ;----------------------------------------------------------------------------
 34135                                  
 34136                                  SkipBack:
 34137 00006F7A 39DF                    	CMP     DI,BX                   ;   while (TRUE) {
 34138 00006F7C 720B                    	JB	short SkipBad		;       if (d < dlim)
 34139 00006F7E 4F                      	DEC     DI                      ;           goto err;
 34140 00006F7F 268A05                  	MOV     AL,[ES:DI]		;       if (pathchr (*--d))
 34141 00006F82 E8A6E9                  	call    PATHCHRCMP              ;           break;
 34142 00006F85 75F3                    	JNZ	short SkipBack		;       }
 34143 00006F87 F8                      	CLC                             ;   return (0);
 34144 00006F88 C3                      	retn				;
 34145                                  SkipBad:                                ;err:
 34146                                  	;mov	al,3
 34147 00006F89 B003                    	MOV     AL,error_path_not_found ; bad path error
 34148 00006F8B F9                      	STC                             ;   return (-1);
 34149 00006F8C C3                      	retn                          ;
 34150                                  
 34151                                  ;Break <CopyComponent - copy out a file path component>
 34152                                  ;----------------------------------------------------------------------------
 34153                                  ;   CopyComponent - copy a file component from a path string (DS:SI) into ES:DI
 34154                                  ;
 34155                                  ;   Inputs:     DS:SI - source path
 34156                                  ;               ES:DI - destination
 34157                                  ;               ES:BP - end of buffer
 34158                                  ;   Outputs:    Carry Set - too long
 34159                                  ;               Carry Clear - DS:SI moved past component
 34160                                  ;                   CX has length of destination
 34161                                  ;   Registers modified: AX,CX,DX
 34162                                  ;----------------------------------------------------------------------------
 34163                                  
 34164                                  CopyComponent:
 34165                                  
 34166                                  %define CopyBP	 [BP]		; word
 34167                                  %define CopyD	 [BP+2]		; dword
 34168                                  %define CopyDoff [BP+2]		; word
 34169                                  %define CopyS	 [BP+6]		; dword
 34170                                  %define CopySoff [BP+6]		; word
 34171                                  %define CopyTemp [BP+10]	; byte
 34172                                  
 34173 00006F8D 83EC0E                  	SUB     SP,14                   ; room for temp buffer
 34174 00006F90 1E                      	push	ds
 34175 00006F91 56                      	push	si
 34176 00006F92 06                      	push	es
 34177 00006F93 57                      	push	di
 34178 00006F94 55                      	push	bp
 34179 00006F95 89E5                    	MOV     BP,SP
 34180 00006F97 B42E                    	MOV     AH,'.'
 34181 00006F99 AC                      	LODSB
 34182 00006F9A AA                      	STOSB
 34183 00006F9B 38E0                    	CMP     AL,AH                   ;   if ((*d++=*s++) == '.') {
 34184 00006F9D 7518                    	JNZ	short NormalComp
 34185 00006F9F E8CEFF                  	CALL    PathSep                 ;       if (!pathsep(*s))
 34186 00006FA2 740B                    	JZ	short NulTerm
 34187                                  TryTwoDot:
 34188 00006FA4 AC                      	LODSB                           ;           if ((*d++=*s++) != '.'
 34189 00006FA5 AA                      	STOSB
 34190 00006FA6 38E0                    	CMP     AL,AH
 34191 00006FA8 7557                    	JNZ	short CopyBad
 34192 00006FAA E8C3FF                  	CALL    PathSep
 34193 00006FAD 7552                    	JNZ	short CopyBad		;               || !pathsep (*s))
 34194                                  NulTerm:                                ;               return -1;
 34195 00006FAF 30C0                    	XOR     AL,AL                   ;       *d++ = 0;
 34196 00006FB1 AA                      	STOSB
 34197 00006FB2 897606                  	MOV     CopySoff,SI
 34198 00006FB5 EB47                    	JMP     SHORT _GoodRet		;       }
 34199                                  NormalComp:                             ;   else {
 34200 00006FB7 8B7606                  	MOV     SI,CopySoff ; [bp+6]
 34201 00006FBA E804E9                  	call	NameTrans               ;       s = NameTrans (s, Name1);
 34202 00006FBD 3B7606                  	CMP     SI,CopySoff             ;       if (s == CopySOff)
 34203 00006FC0 743F                    	JZ	short CopyBad		;           return (-1);
 34204 00006FC2 36F606[2F05]FF          	TEST	byte [SS:FSHARING],-1	;       if (!fSharing) {;smr;SS Override
 34205 00006FC8 7510                    	JNZ	short DoPack
 34206 00006FCA 80E201                  	AND     DL,1                    ;           cMeta += fMeta;
 34207 00006FCD 360016[3705]            	ADD	[ss:CMETA],DL		;           if (cMeta > 0);smr;SS Override
 34208 00006FD2 7F2D                    	JG	short CopyBad		;               return (-1);
 34209 00006FD4 7504                    	JNZ	short DoPack		;           else
 34210 00006FD6 08D2                    	OR      DL,DL                   ;           if (cMeta == 0 && fMeta == 0)
 34211 00006FD8 742F                    	JZ	short CopyBadPath	;               return (-1);
 34212                                  DoPack:                                 ;           }
 34213 00006FDA 897606                  	MOV     CopySoff,SI ; [bp+6]
 34214 00006FDD 16                      	push	ss
 34215 00006FDE 1F                      	pop	ds
 34216 00006FDF BE[0805]                	MOV     SI,NAME1
 34217 00006FE2 8D7E0A                  	LEA     DI,CopyTemp ; [bp+10]
 34218 00006FE5 57                      	push	di
 34219 00006FE6 E8A9BE                  	call	PackName                ;       PackName (Name1, temp);
 34220 00006FE9 5F                      	pop	di
 34221 00006FEA E81EB0                  	call	StrLen                  ;       if (strlen(temp)+d > bp)
 34222 00006FED 49                      	DEC     CX
 34223 00006FEE 034E02                  	ADD     CX,CopyDoff ; [bp+2]
 34224 00006FF1 3B4E00                  	CMP     CX,CopyBP   ; [bp+0]
 34225 00006FF4 730B                    	JAE	short CopyBad		;           return (-1);
 34226 00006FF6 89FE                    	MOV     SI,DI                   ;       strcpy (d, temp);
 34227 00006FF8 C47E02                  	LES     DI,CopyD    ; [bp+2]	
 34228 00006FFB E804B0                  	call	FStrCpy
 34229                                  _GoodRet:				;       }
 34230 00006FFE F8                      	CLC
 34231 00006FFF EB0B                    	JMP     SHORT CopyEnd           ;   return 0;
 34232                                  CopyBad:
 34233 00007001 F9                      	STC
 34234 00007002 E8FA00                  	CALL    ScanPathChar            ; check for path chars in rest of string
 34235                                  	;mov	al,2
 34236 00007005 B002                    	MOV     AL,error_file_not_found ; Set up for bad file error
 34237 00007007 7503                    	JNZ	short CopyEnd
 34238                                  CopyBadPath:
 34239 00007009 F9                      	STC
 34240                                  	;mov	al,3
 34241 0000700A B003                    	MOV     AL,error_path_not_found ; Set bad path error
 34242                                  CopyEnd:
 34243 0000700C 5D                      	pop	bp
 34244 0000700D 5F                      	pop	di
 34245 0000700E 07                      	pop	es
 34246 0000700F 5E                      	pop	si
 34247 00007010 1F                      	pop	ds
 34248 00007011 9F                      	LAHF
 34249 00007012 83C40E                  	ADD     SP,14                   ; reclaim temp buffer
 34250 00007015 E8F3AF                  	call	StrLen
 34251 00007018 49                      	DEC     CX
 34252 00007019 9E                      	SAHF
 34253 0000701A C3                      	retn
 34254                                  
 34255                                  ;Break <Splice - pseudo mount by string substitution>
 34256                                  ;----------------------------------------------------------------------------
 34257                                  ;   Splice - take a string and substitute a prefix if one exists. Change
 34258                                  ;       ThisCDS to point to physical drive CDS.
 34259                                  ;   Inputs:     DS:SI point to string
 34260                                  ;               NoSetDir = TRUE => exact matches with splice fail
 34261                                  ;   Outputs:    DS:SI points to thisCDS
 34262                                  ;               ES:DI points to DPB
 34263                                  ;               String at DS:SI may be reduced in length by removing prefix
 34264                                  ;               and substituting drive letter.
 34265                                  ;               CX = 0 If no splice done
 34266                                  ;               CX <> 0 otherwise
 34267                                  ;               ThisCDS points to proper CDS if spliced, otherwise it is
 34268                                  ;                   left alone
 34269                                  ;               ThisDPB points to proper DPB
 34270                                  ;   Registers modified: DS:SI, ES:DI, BX,AX,CX
 34271                                  ;----------------------------------------------------------------------------
 34272                                  
 34273                                  Splice:
 34274 0000701B 36F606[5A00]FF          	TEST	byte [SS:SPLICES],-1	;smr;SS Override
 34275 00007021 746A                    	JZ	short AllDone
 34276 00007023 36FF36[5E05]            	push	word [SS:THISCDS]
 34277 00007028 36FF36[6005]            	push	word [SS:THISCDS+2]	; TmpCDS = ThisCDS;smr;SS Override
 34278 0000702D 1E                      	push	ds
 34279 0000702E 56                      	push	si
 34280 0000702F 5F                      	pop	di
 34281 00007030 07                      	pop	es
 34282 00007031 31C0                    	XOR     AX,AX                   ;   for (i=1; s = GetCDSFromDrv (i); i++)
 34283                                  SpliceScan:
 34284 00007033 E8D4FC                  	call	GetCDSFromDrv
 34285 00007036 724B                    	JC	short SpliceDone
 34286 00007038 FEC0                    	INC     AL
 34287                                  	;test	word [si+67],2000h
 34288 0000703A F744430020              	TEST    word [SI+curdir.flags],curdir_splice
 34289 0000703F 74F2                    	JZ	short SpliceScan 	;       if ( Spliced (i) ) {
 34290 00007041 57                      	push	di
 34291 00007042 E8A100                  	CALL    PathPref                ;           if (!PathPref (s, d))
 34292 00007045 7403                    	JZ	short SpliceFound	;
 34293                                  SpliceSkip:
 34294 00007047 5F                      	pop	di
 34295 00007048 EBE9                    	JMP	short SpliceScan	;               continue;
 34296                                  SpliceFound:
 34297 0000704A 26803D00                	CMP     BYTE [ES:DI],0		;           if (*s || NoSetDir) {
 34298 0000704E 7508                    	JNZ	short SpliceDo
 34299 00007050 36F606[1603]FF          	TEST	byte [ss:NoSetDir],-1			;smr;SS Override
 34300 00007056 75EF                    	JNZ	short SpliceSkip
 34301                                  SpliceDo:
 34302 00007058 89FE                    	MOV     SI,DI                   ;               p = src + strlen (p);
 34303 0000705A 06                      	push	es
 34304 0000705B 1F                      	pop	ds
 34305 0000705C 5F                      	pop	di
 34306 0000705D E88000                  	CALL    TextFromDrive1          ;               src = TextFromDrive1(src,i);
 34307 00007060 36A1[7205]              	MOV     AX,[SS:CURR_DIR_END]			;smr;SS Override
 34308 00007064 09C0                    	OR      AX,AX
 34309 00007066 7808                    	JS	short NoPoke
 34310 00007068 01F8                    	ADD     AX,DI                   ;               curdirend += src-p;
 34311 0000706A 29F0                    	SUB     AX,SI
 34312 0000706C 36A3[7205]              	MOV     [SS:CURR_DIR_END],AX			;smr;SS Override
 34313                                  NoPoke:
 34314 00007070 803C00                  	CMP     BYTE [SI],0		;               if (*p)
 34315 00007073 7503                    	JNZ	short SpliceCopy	;                   *src++ = '\\';
 34316 00007075 B05C                    	MOV     AL,"\"
 34317 00007077 AA                      	STOSB
 34318                                  SpliceCopy:                             ;               strcpy (src, p);
 34319 00007078 E887AF                  	call	FStrCpy
 34320 0000707B 83C404                  	ADD     SP,4                    ; throw away saved stuff
 34321 0000707E 80C901                  	OR      CL,1                    ; signal splice done.
 34322 00007081 EB0C                    	JMP     SHORT DoSet             ;               return;
 34323                                  SpliceDone:                             ;               }
 34324 00007083 368F06[6005]            	pop	word [SS:THISCDS+2]     ;   ThisCDS = TmpCDS;
 34325 00007088 368F06[5E05]            	pop	word [SS:THISCDS]			;smr;SS Override
 34326                                  AllDone:
 34327 0000708D 31C9                    	XOR     CX,CX
 34328                                  DoSet:
 34329 0000708F 36C536[5E05]            	LDS     SI,[SS:THISCDS]		;   ThisDPB = ThisCDS->devptr;;smr;SS Override
 34330                                  	;les	di,[si+69]
 34331 00007094 C47C45                  	LES     DI,[SI+curdir.devptr]	
 34332 00007097 36893E[4605]            	MOV	[SS:THISDPB],DI				;smr;SS Override
 34333 0000709C 368C06[4805]            	MOV	[SS:THISDPB+2],ES			;smr;SS Override
 34334                                  Splice_retn:
 34335 000070A1 C3                      	retn
 34336                                  
 34337                                  ;Break <$NameTrans - partially process a name>
 34338                                  ;----------------------------------------------------------------------------
 34339                                  ;   $NameTrans - allow users to see what names get mapped to. This call
 34340                                  ;   performs only string substitution and canonicalization, not splicing.  Due
 34341                                  ;   to Transpath playing games with devices, we need to insure that the output
 34342                                  ;   has drive letter and : in it.
 34343                                  ;
 34344                                  ;   Inputs:     DS:SI - source string for translation
 34345                                  ;               ES:DI - pointer to buffer
 34346                                  ;   Outputs:
 34347                                  ;       Carry Clear
 34348                                  ;               Buffer at ES:DI is filled in with data
 34349                                  ;               ES:DI point byte after nul byte at end of dest string in buffer
 34350                                  ;       Carry Set
 34351                                  ;               AX = error_path_not_found
 34352                                  ;   Registers modified: all
 34353                                  ;----------------------------------------------------------------------------
 34354                                  
 34355                                  _$NameTrans:
 34356 000070A2 1E                      	push	ds
 34357 000070A3 56                      	push	si
 34358 000070A4 06                      	push	es
 34359 000070A5 57                      	push	di
 34360 000070A6 51                      	push	cx ; MSDOS 6.0
 34361                                  	
 34362                                  	; MSDOS 6.0	
 34363                                  ; M027 - Start
 34364                                  ;
 34365                                  ; Sattrib must be set up with default values here. Otherwise, the value from
 34366                                  ; a previous DOS call is used for attrib and DevName thinks it is not a 
 34367                                  ; device if the old call set the volume attribute bit. Note that devname in
 34368                                  ; dir2.asm gets ultimately called by Transpath. See also M026. Also save
 34369                                  ; and restore CX.
 34370                                  ;
 34371 000070A7 B516                    	mov     ch,attr_hidden+attr_system+attr_directory
 34372 000070A9 E81C05                  	call	SetAttrib
 34373                                  
 34374                                  ; M027 - End
 34375                                  
 34376                                  	; MSDOS 3.3 (& MSDOS 6.0)
 34377 000070AC BF[8203]                	MOV     DI,OPENBUF
 34378 000070AF E8E0FC                  	CALL    TransPath               ; to translation (everything)
 34379 000070B2 59                      	pop	cx ; MSDOS 6.0
 34380 000070B3 5F                      	pop     di
 34381 000070B4 07                      	pop	es
 34382 000070B5 5E                      	pop     si
 34383 000070B6 1F                      	pop     ds
 34384 000070B7 7303                    	JNC	short TransOK
 34385 000070B9 E9E8A6                  	jmp	SYS_RET_ERR
 34386                                  TransOK:
 34387 000070BC BE[8203]                	MOV     SI,OPENBUF
 34388 000070BF 16                      	push	ss
 34389 000070C0 1F                      	pop	ds
 34390                                  GotText:
 34391 000070C1 E83EAF                  	call	FStrCpy
 34392 000070C4 E9D4A6                  	jmp	SYS_RET_OK
 34393                                  
 34394                                  ;Break   <DriveFromText - return drive number from a text string>
 34395                                  ;----------------------------------------------------------------------------
 34396                                  ;   DriveFromText - examine DS:SI and remove a drive letter, advancing the
 34397                                  ;   pointer.
 34398                                  ;
 34399                                  ;   Inputs:     DS:SI point to a text string
 34400                                  ;   Outputs:    AL has drive number
 34401                                  ;               DS:SI advanced
 34402                                  ;   Registers modified: AX,SI.
 34403                                  ;----------------------------------------------------------------------------
 34404                                  
 34405                                  DriveFromText:
 34406 000070C7 30C0                    	XOR     AL,AL                   ;       drive = 0;
 34407 000070C9 803C00                  	CMP     BYTE [SI],0		;       if (*s &&
 34408 000070CC 74D3                    	jz	short Splice_retn
 34409 000070CE 807C013A                	CMP     BYTE [SI+1],':'		;           s[1] == ':') {
 34410 000070D2 75CD                    	jnz	short Splice_retn
 34411 000070D4 AD                      	LODSW                           ;           drive = (*s | 020) - 'a'+1;
 34412 000070D5 0C20                    	OR      AL,20h
 34413                                  	;sub	al,60h
 34414 000070D7 2C60                    	SUB     AL,'a'-1                ;           s += 2;
 34415 000070D9 75C6                    	jnz	short Splice_retn
 34416 000070DB B0FF                    	MOV     AL,-1                   ; nuke AL...
 34417 000070DD C3                      	retn				;           }
 34418                                  
 34419                                  ;Break   <TextFromDrive - convert a drive number to a text string>
 34420                                  ;----------------------------------------------------------------------------
 34421                                  ;   TextFromDrive - turn AL into a drive letter: and put it at es:di with
 34422                                  ;   trailing :. TextFromDrive1 takes a 1-based number.
 34423                                  ;
 34424                                  ;   Inputs:     AL has 0-based drive number
 34425                                  ;   Outputs:    ES:DI advanced
 34426                                  ;   Registers modified: AX
 34427                                  ;----------------------------------------------------------------------------
 34428                                  
 34429                                  TextFromDrive:
 34430 000070DE FEC0                    	INC     AL
 34431                                  TextFromDrive1:
 34432                                  	;add	al,40h
 34433 000070E0 0440                    	ADD     AL,'A'-1                ;   *d++ = drive-1+'A';
 34434 000070E2 B43A                    	MOV     AH,":"                  ;   strcat (d, ":");
 34435 000070E4 AB                      	STOSW
 34436                                  PathPref_retn:
 34437 000070E5 C3                      	retn
 34438                                  
 34439                                  ;Break   <PathPref - see if one path is a prefix of another>
 34440                                  ;----------------------------------------------------------------------------
 34441                                  ;   PathPref - compare DS:SI with ES:DI to see if one is the prefix of the
 34442                                  ;   other.  Remember that only at a pathchar break are we allowed to have a
 34443                                  ;   prefix: A:\ and A:\FOO
 34444                                  ;
 34445                                  ;   Inputs:     DS:SI potential prefix
 34446                                  ;               ES:DI string
 34447                                  ;   Outputs:    Zero set => prefix found
 34448                                  ;                   DI/SI advanced past matching part
 34449                                  ;               Zero reset => no prefix, DS/SI garbage
 34450                                  ;   Registers modified: CX
 34451                                  ;----------------------------------------------------------------------------
 34452                                  
 34453                                  PathPref:
 34454 000070E6 E830AF                  	call	DStrLen                 ; get length
 34455 000070E9 49                      	DEC     CX                      ; do not include nul byte
 34456 000070EA F3A6                    	REPZ    CMPSB                   ; compare
 34457 000070EC 75F7                    	jnz	short PathPref_retn	; if NZ then return NZ
 34458 000070EE 50                      	push	ax			; save char register
 34459 000070EF 8A44FF                  	MOV     AL,[SI-1]               ; get last byte to match
 34460 000070F2 E836E8                  	call    PATHCHRCMP              ; is it a path char (Root!)
 34461 000070F5 7406                    	JZ	short Prefix		; yes, match root (I hope)
 34462                                  NotSep:                                 ; 2/13/KK
 34463 000070F7 268A05                  	MOV     AL,[ES:DI]		; get next char to match
 34464 000070FA E875FE                  	CALL    PathSepGotCh            ; was it a pathchar?
 34465                                  Prefix:
 34466 000070FD 58                      	pop	ax			; get back original
 34467 000070FE C3                      	retn
 34468                                  
 34469                                  ;Break   <ScanPathChar - see if there is a path character in a string>
 34470                                  ;----------------------------------------------------------------------------
 34471                                  ;     ScanPathChar - search through the string (pointed to by DS:SI) for
 34472                                  ;     a path separator.
 34473                                  ;
 34474                                  ;     Input:    DS:SI target string (null terminated)
 34475                                  ;     Output:   Zero set => path separator encountered in string
 34476                                  ;               Zero clear => null encountered
 34477                                  ;     Registers modified: SI
 34478                                  ;----------------------------------------------------------------------------
 34479                                  
 34480                                  ScanPathChar:
 34481 000070FF AC                      	LODSB                           ; fetch a character
 34482 00007100 E86FFE                  	call    PathSepGotCh
 34483 00007103 75FA                    	JNZ	short ScanPathChar	; not \, / or NUL => go back for more
 34484 00007105 E823E8                  	call    PATHCHRCMP              ; path separator?
 34485 00007108 C3                      	retn
 34486                                  
 34487                                  ;============================================================================
 34488                                  ; HANDLE.ASM, MSDOS 6.0, 1991
 34489                                  ;============================================================================
 34490                                  ; 13/07/2018 - Retro DOS v3.0
 34491                                  
 34492                                  ;	BREAK <$Close - return a handle to the system>
 34493                                  ;----------------------------------------------------------------------------
 34494                                  ;
 34495                                  ;**	$Close - Close a file Handle
 34496                                  ;
 34497                                  ;	BUGBUG - close gets called a LOT with invalid handles - sizzle that
 34498                                  ;		path
 34499                                  ;
 34500                                  ;	Assembler usage:
 34501                                  ;	    MOV     BX, handle
 34502                                  ;	    MOV     AH, Close
 34503                                  ;	    INT     int_command
 34504                                  ;
 34505                                  ;	ENTRY	(bx) = handle
 34506                                  ;	EXIT	<normal INT21 return convention>
 34507                                  ;	USES	all
 34508                                  ;
 34509                                  ;----------------------------------------------------------------------------
 34510                                  
 34511                                  _$CLOSE:
 34512                                  ;	Grab the SFT pointer from the JFN.
 34513                                  
 34514 00007109 E85B02                  	call	CheckOwner		; get system file entry
 34515 0000710C 722B                    	jc	short CloseError	; error return
 34516 0000710E 16                      	push	ss
 34517 0000710F 1F                      	pop	ds			; For DOS_CLOSE
 34518 00007110 893E[5A05]              	MOV	[THISSFT],DI		; save offset of pointer
 34519 00007114 8C06[5C05]              	MOV	[THISSFT+2],ES		; save segment value
 34520                                  
 34521                                  ; DS:SI point to JFN table entry.
 34522                                  ; ES:DI point to SFT
 34523                                  ;
 34524                                  ; We now examine the user's JFN entry; If the file was a 70-mode file (network
 34525                                  ; FCB, we examine the ref count on the SFT;  if it was 1, we free the JFN.
 34526                                  ; If the file was not a net FCB, we free the JFN too.
 34527                                  
 34528                                  	;CMP	word [ES:DI+SF_ENTRY.sf_ref_count],1
 34529 00007118 26833D01                	cmp	word [ES:DI],1		; will the SFT become free?
 34530 0000711C 740A                    	jz	short FreeJFN 		; yes, free JFN anyway.
 34531                                  	;mov	al,[ES:DI+2]
 34532 0000711E 268A4502                	MOV	AL,[ES:DI+SF_ENTRY.sf_mode]
 34533                                  	;and	al,0F0h
 34534 00007122 24F0                    	AND	AL,SHARING_MASK
 34535                                  	;cmp	al,70h
 34536 00007124 3C70                    	CMP	AL,SHARING_NET_FCB
 34537 00007126 7407                    	JZ	short PostFree		; 70-mode and big ref count => free it
 34538                                  
 34539                                  ; The JFN must be freed.  Get the pointer to it and replace the contents with
 34540                                  ; -1.
 34541                                  
 34542                                  FreeJFN:
 34543 00007128 E800FA                  	call	pJFNFromHandle		;   d = pJFN (handle);
 34544 0000712B 26C605FF                	MOV	BYTE [ES:DI],0FFh	; release the JFN
 34545                                  PostFree:
 34546                                  
 34547                                  ; ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_CLOSE!
 34548                                  
 34549 0000712F E8FFC9                  	call	DOS_CLOSE
 34550                                  
 34551                                  ; DOS_Close may return an error.  If we see such an error, we report it but
 34552                                  ; the JFN stays closed because DOS_Close always frees the SFT!
 34553                                  
 34554 00007132 7205                    	JC	short CloseError
 34555                                  	;mov	ah,3Eh
 34556 00007134 B43E                    	MOV	AH,CLOSE		; MZ Bogus multiplan fix
 34557 00007136 E962A6                  	jmp	SYS_RET_OK
 34558                                  CloseError:
 34559 00007139 E968A6                  	jmp	SYS_RET_ERR
 34560                                  
 34561                                  
 34562                                  ;	BREAK <$Commit - commit the file>
 34563                                  ;----------------------------------------------------------------------------
 34564                                  ;
 34565                                  ;**	$Commit - Commit a File
 34566                                  ;
 34567                                  ;	$Commit "commits" a file to disk - all of it's buffers are
 34568                                  ;	flushed out.  BUGBUG - I'm pretty sure that $Commit doesn't update
 34569                                  ;	the directory entry, etc., so this commit is pretty useless.  check
 34570                                  ;	and fix this!! jgl
 34571                                  ;
 34572                                  ;	Assembler usage:
 34573                                  ;	    MOV     BX, handle
 34574                                  ;	    MOV     AH, Commit
 34575                                  ;	    INT     int_command
 34576                                  ;
 34577                                  ;	ENTRY	(bx) = handle
 34578                                  ;	EXIT	none
 34579                                  ;	USES	all
 34580                                  ;;----------------------------------------------------------------------------
 34581                                  
 34582                                  _$COMMIT:
 34583                                  ;	Grab the SFT pointer from the JFN.
 34584                                  
 34585 0000713C E82802                  	call	CheckOwner		; get system file entry
 34586 0000713F 7214                    	JC	short CommitError	; error return
 34587 00007141 16                      	push	ss
 34588 00007142 1F                      	pop	ds			; For DOS_COMMIT
 34589 00007143 893E[5A05]              	MOV	[THISSFT],DI		; save offset of pointer
 34590 00007147 8C06[5C05]              	MOV	[THISSFT+2],ES		; save segment value
 34591                                  
 34592                                  ;	ThisSFT is correctly set, we have DS = DOSDATA.  Looks OK for a DOS_COMMIT
 34593                                  ;
 34594                                  ;	ES:DI point to SFT
 34595                                  
 34596 0000714B E832CB                  	call	DOS_COMMIT
 34597 0000714E 7205                    	JC	short CommitError
 34598                                  	;mov	ah,68h
 34599 00007150 B468                    	MOV	AH,COMMIT		;
 34600 00007152 E946A6                  	jmp	SYS_RET_OK
 34601                                  CommitError:
 34602 00007155 E94CA6                  	jmp	SYS_RET_ERR
 34603                                  
 34604                                  ;	BREAK <$ExtHandle - extend handle count>
 34605                                  
 34606                                  ;**	$ExtHandle - Extend Handle Count
 34607                                  ;----------------------------------------------------------------------------
 34608                                  ;	Assembler usage:
 34609                                  ;	    MOV     BX, Number of Opens Allowed (MAX=65534;66535 is
 34610                                  ;	    MOV     AX, 6700H			 reserved to mark SFT
 34611                                  ;	    INT     int_command 		 busy )
 34612                                  ;
 34613                                  ;	ENTRY	(bx) = new number of handles
 34614                                  ;	EXIT	'C' clear if OK
 34615                                  ;		'C' set iff err
 34616                                  ;		  (ax) = error code
 34617                                  ;			 AX = error_not_enough_memory
 34618                                  ;			      error_too_many_open_files
 34619                                  ;	USES	all
 34620                                  ;----------------------------------------------------------------------------
 34621                                  
 34622                                  _$ExtHandle:
 34623 00007158 31ED                    	XOR	BP,BP			; 0: enlarge   1: shrink  2:psp
 34624                                  	;cmp	bx,20
 34625 0000715A 83FB14                  	CMP	BX,FILPERPROC
 34626 0000715D 7303                    	JAE	short exth2		; Don't set less than FilPerProc no
 34627 0000715F BB1400                  	MOV	BX,FILPERPROC
 34628                                  exth2:	
 34629 00007162 368E06[FC02]            	MOV	ES,[ss:CurrentPDB]	; get user process data block;smr;SS Override
 34630                                  	;mov	cx,[ES:32h]
 34631 00007167 268B0E3200              	MOV	CX,[ES:PDB.JFN_Length]	; get number of handle allowed
 34632 0000716C 39CB                    	CMP	BX,CX			; the requested == current
 34633 0000716E 7452                    	JE	short ok_done 		; yes and exit
 34634 00007170 7722                    	JA	short larger		; go allocate new table
 34635                                  
 34636                                  ;	We're going to shrink the # of handles available
 34637                                  
 34638 00007172 BD0100                  	MOV	BP,1			; shrink
 34639                                  	;mov	ds,[ES:36h]
 34640 00007175 268E1E3600              	MOV	DS,[ES:PDB.JFN_Pointer+2] ;
 34641 0000717A 89DE                    	MOV	SI,BX			;
 34642 0000717C 29D9                    	SUB	CX,BX			; get difference
 34643                                  
 34644                                  ;	BUGBUG - code a SCASB here, should be a bit smaller
 34645                                  chck_handles:
 34646 0000717E 803CFF                  	CMP	BYTE [SI],-1		; scan through handles to ensure close
 34647 00007181 7542                    	JNZ	short too_many_files	; status
 34648 00007183 46                      	INC	SI
 34649 00007184 E2F8                    	LOOP	chck_handles
 34650 00007186 83FB14                  	CMP	BX,FILPERPROC		; = 20
 34651 00007189 7709                    	JA	short larger		; no
 34652                                  
 34653 0000718B BD0200                  	MOV	BP,2			; psp
 34654                                  	;mov	di,24
 34655 0000718E BF1800                  	MOV	DI,PDB.JFN_TABLE	; es:di -> jfn table in psp
 34656 00007191 53                      	PUSH	BX
 34657 00007192 EB1F                    	JMP	short movhandl
 34658                                  
 34659                                  larger:
 34660 00007194 83FBFF                  	CMP	BX,-1			; 65535 is not allowed
 34661 00007197 0F848100                	JZ	invalid_func ; 10/08/2018
 34662 0000719B F8                      	CLC
 34663 0000719C 53                      	PUSH	BX			; save requested number
 34664 0000719D 83C30F                  	ADD	BX,0FH			; adjust to paragraph boundary
 34665 000071A0 B104                    	MOV	CL,4
 34666                                  	;ror	bx,cl			; MSDOS 3.3
 34667 000071A2 D3DB                    	RCR	BX,CL			; DOS 4.00 fix		;AC000;
 34668 000071A4 81E3FF1F                	AND	BX,1FFFH		; clear most 3 bits
 34669                                  
 34670 000071A8 55                      	PUSH	BP
 34671 000071A9 E8E9F6                  	call	_$ALLOC			; allocate memory
 34672 000071AC 5D                      	POP	BP
 34673 000071AD 7267                    	JC	short no_memory		; not enough meory
 34674                                  
 34675 000071AF 8EC0                    	MOV	ES,AX			; es:di points to new table memory
 34676 000071B1 31FF                    	XOR	DI,DI
 34677                                  movhandl:
 34678 000071B3 368E1E[FC02]            	MOV	DS,[ss:CurrentPDB] 	; get user PDB address	;smr;SS Override
 34679                                  
 34680 000071B8 F7C50300                	test	BP,3			; enlarge ?
 34681 000071BC 740C                    	JZ	short enlarge 		; yes
 34682 000071BE 59                      	POP	CX			; cx = the amount you shrink
 34683 000071BF 51                      	PUSH	CX
 34684 000071C0 EB0C                    	JMP	short copy_hand
 34685                                  
 34686                                  ;	Done.  'C' clear
 34687                                  
 34688                                  ok_done:
 34689 000071C2 E9D6A5                  	jmp	SYS_RET_OK
 34690                                  
 34691                                  too_many_files:
 34692                                  	;mov	al,4
 34693 000071C5 B004                    	MOV	AL,error_too_many_open_files
 34694 000071C7 E9DAA5                  	jmp	SYS_RET_ERR
 34695                                  
 34696                                  enlarge:
 34697                                  	;mov	cx,[32h]
 34698 000071CA 8B0E3200                	MOV	CX,[PDB.JFN_Length]	; get number of old handles
 34699                                  copy_hand:
 34700 000071CE 89CA                    	MOV	DX,CX
 34701                                  	;lds	si,[34h]
 34702 000071D0 C5363400                	LDS	SI,[PDB.JFN_Pointer]	; get old table pointer
 34703 000071D4 F3A4                    	REP	MOVSB			; copy infomation to new table
 34704 000071D6 59                      	POP	CX			; get new number of handles
 34705 000071D7 51                      	PUSH	CX			; save it again
 34706 000071D8 29D1                    	SUB	CX,DX			; get the difference
 34707 000071DA B0FF                    	MOV	AL,-1			; set availability to handles
 34708 000071DC F3AA                    	REP	STOSB
 34709 000071DE 368E1E[FC02]            	MOV	DS,[ss:CurrentPDB] 	; get user process data block;smr;SS Override
 34710                                  	;cmp	word [34h],0
 34711 000071E3 833E340000              	CMP	WORD [PDB.JFN_Pointer],0 ; check if original table pointer
 34712 000071E8 750D                    	JNZ	short update_info	; yes, go update PDB entries
 34713 000071EA 55                      	PUSH	BP
 34714 000071EB 1E                      	PUSH	DS			; save old table segment
 34715 000071EC 06                      	PUSH	ES			; save new table segment
 34716 000071ED 8E063600                	MOV	ES,[PDB.JFN_Pointer+2]	; get old table segment
 34717 000071F1 E8BEF7                  	call	_$DEALLOC		; deallocate old table meomory
 34718 000071F4 07                      	POP	ES			; restore new table segment
 34719 000071F5 1F                      	POP	DS			; restore old table segment
 34720 000071F6 5D                      	POP	BP
 34721                                  
 34722                                  update_info:
 34723 000071F7 F7C50200                	test	BP,2			; psp?
 34724 000071FB 7408                    	JZ	short non_psp 		; no
 34725                                  	;mov	word [34h],18h ; 24
 34726 000071FD C70634001800            	MOV	WORD [PDB.JFN_Pointer],PDB.JFN_TABLE ; restore
 34727 00007203 EB06                    	JMP	short final
 34728                                  non_psp:
 34729                                  	;mov	word [34h],0
 34730 00007205 C70634000000            	MOV	WORD [PDB.JFN_Pointer],0 ; new table pointer offset always 0
 34731                                  final:
 34732                                  	;mov	word [36h],es	
 34733 0000720B 8C063600                	MOV	[PDB.JFN_Pointer+2],ES	; update table pointer segment
 34734                                  	;pop	word [32h]
 34735 0000720F 8F063200                	POP	word [PDB.JFN_Length]	; restore new number of handles
 34736 00007213 E985A5                  	jmp	SYS_RET_OK
 34737                                  
 34738                                  no_memory:
 34739 00007216 5B                      	POP	BX			; clean stack
 34740                                  	;mov	al,8
 34741 00007217 B008                    	MOV	AL,error_not_enough_memory
 34742 00007219 E988A5                  	jmp	SYS_RET_ERR
 34743                                  invalid_func:
 34744                                  	;mov	al,1
 34745 0000721C B001                    	MOV	AL,error_invalid_function
 34746 0000721E E983A5                  	jmp	SYS_RET_ERR
 34747                                  
 34748                                  
 34749                                  ;	BREAK <$READ - Read from a file handle>
 34750                                  ;----------------------------------------------------------------------------
 34751                                  ;
 34752                                  ;**	$Read - Read from a File Handle
 34753                                  ;
 34754                                  ;   Assembler usage:
 34755                                  ;
 34756                                  ;	LDS	DX, buf
 34757                                  ;	MOV	CX, count
 34758                                  ;	MOV	BX, handle
 34759                                  ;	MOV	AH, Read
 34760                                  ;	INT	int_command
 34761                                  ;	  AX has number of bytes read
 34762                                  ;
 34763                                  ;	ENTRY	(bx) = file handle
 34764                                  ;		(cx) = byte count
 34765                                  ;		(ds:dx) = buffer address
 34766                                  ;	EXIT	Through system call return so that to user:
 34767                                  ;		  'C' clear if OK
 34768                                  ;		    (ax) = bytes read
 34769                                  ;		  'C' set if error
 34770                                  ;		    (ax) = error code
 34771                                  ;
 34772                                  ;----------------------------------------------------------------------------
 34773                                  
 34774                                  _$READ:
 34775 00007221 BE[C93E]                	MOV	SI,DOS_READ
 34776                                  ReadDo:
 34777 00007224 E804F9                  	call	pJFNFromHandle
 34778 00007227 7208                    	JC	short ReadError
 34779 00007229 268A05                  	MOV	AL,[ES:DI]
 34780 0000722C E83801                  	call	CheckOwner		; get the handle
 34781 0000722F 7303                    	JNC	short ReadSetup		; no errors do the operation
 34782                                  
 34783                                  ;	Have an error.	'C' set
 34784                                  
 34785                                  ReadError:
 34786 00007231 E970A5                  	jmp	SYS_RET_ERR		; go to error traps
 34787                                  
 34788                                  ReadSetup:
 34789 00007234 36893E[5A05]            	MOV	[SS:THISSFT],DI		; save offset of pointer;smr;SS Override
 34790 00007239 368C06[5C05]            	MOV	[ss:THISSFT+2],ES	; save segment value	;smr;SS Override
 34791                                  	;;; MSDOS 6.0 
 34792                                  ;; Extended Open
 34793                                  	;;;testb [ES:DI+SF_ENTRY.sf_mode],INT_24_ERROR  ;AN000;;EO. need i24
 34794                                  	;;;JZ	short needi24 		      ;AN000;;EO. yes
 34795                                  	;;;OR	byte [EXTOPEN_ON],EXT_OPEN_I24_OFF 
 34796                                  					;AN000;;EO. set it off;smr;SS Override
 34797                                  needi24:				;AN000;
 34798                                  ;; Extended Open
 34799 0000723E 36FF36[F802]            	push	word [SS:DMAADD]
 34800 00007243 36FF36[FA02]            	push	word [SS:DMAADD+2]	;smr;SS Override
 34801                                  ;;;;;	BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 34802                                  	;;; MSDOS 6.0
 34803                                  	;;; CALL Align_Buffer		;AN000;MS. align user's buffer
 34804                                  	; MSDOS 3.3
 34805 00007248 89D3                    	MOV	BX,DX			; copy offset
 34806 0000724A 51                      	push	cx			; don't stomp on count
 34807 0000724B B104                    	MOV	CL,4			; bits to shift bytes->para
 34808 0000724D D3EB                    	SHR	BX,CL			; get number of paragraphs
 34809 0000724F 59                      	pop	cx			; get count back
 34810 00007250 8CD8                    	MOV	AX,DS			; get original segment
 34811 00007252 01D8                    	ADD	AX,BX			; get new segment
 34812 00007254 8ED8                    	MOV	DS,AX			; in seg register
 34813 00007256 83E20F                  	AND	DX,0Fh			; normalize offset
 34814 00007259 368916[F802]            	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 34815 0000725E 368C1E[FA02]            	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 34816                                  						;smr;SS Override
 34817                                  ;;;;;	END BAD SPOT FOR 286!!! SEGMENT ARITHMETIC!!!
 34818 00007263 16                      	push	ss			; go for DOS addressability
 34819 00007264 1F                      	pop	ds
 34820                                  
 34821 00007265 FFD6                    	CALL	SI ; DOS_READ		; indirect call to operation
 34822                                  
 34823 00007267 8F06[FA02]              	pop	word [DMAADD+2]
 34824 0000726B 8F06[F802]              	pop	word [DMAADD]
 34825                                  	;JNC	short READ_OK		;AN002;
 34826                                  	;JMP	ReadError		;AN002; if error, say bye bye
 34827 0000726F 72C0                    	jc	short ReadError
 34828                                  READ_OK:
 34829 00007271 89C8                    	MOV	AX,CX			; get correct return in correct reg
 34830 00007273 E925A5                  	jmp	SYS_RET_OK		; successful return
 34831                                  
 34832                                  ; 13/07/2018 - Retro DOS v3.0
 34833                                  
 34834                                  ;   Input: DS:DX points to user's buffer addr
 34835                                  ;   Function: rearrange segment and offset for READ/WRITE buffer
 34836                                  ;   Output: [DMAADD] set
 34837                                  
 34838                                  ;Align_Buffer:
 34839                                  ;	MOV	BX,DX			; copy offset
 34840                                  ;	push	cx			; don't stomp on count
 34841                                  ;	MOV	CL,4			; bits to shift bytes->para
 34842                                  ;	SHR	BX,CL			; get number of paragraphs
 34843                                  ;	pop	cx			; get count back
 34844                                  ;	MOV	AX,DS			; get original segment
 34845                                  ;	ADD	AX,BX			; get new segment
 34846                                  ;	MOV	DS,AX			; in seg register
 34847                                  ;	AND	DX,0Fh			; normalize offset
 34848                                  ;	MOV	[ss:DMAADD],DX		; use user DX as offset	;smr;SS Override
 34849                                  ;	MOV	[ss:DMAADD+2],DS 	; use user DS as segment for DMA
 34850                                  ;						;smr;SS Override
 34851                                  ;	retn
 34852                                  
 34853                                  ;BREAK <$WRITE - write to a file handle>
 34854                                  ;----------------------------------------------------------------------------
 34855                                  ;
 34856                                  ;   Assembler usage:
 34857                                  ;	    LDS     DX, buf
 34858                                  ;	    MOV     CX, count
 34859                                  ;	    MOV     BX, handle
 34860                                  ;	    MOV     AH, Write
 34861                                  ;	    INT     int_command
 34862                                  ;	  AX has number of bytes written
 34863                                  ;   Errors:
 34864                                  ;	    AX = write_invalid_handle
 34865                                  ;	       = write_access_denied
 34866                                  ;
 34867                                  ;   Returns in register AX
 34868                                  ;
 34869                                  ;----------------------------------------------------------------------------
 34870                                  
 34871                                  _$WRITE:
 34872 00007276 BE[5440]                	MOV	SI,DOS_WRITE
 34873 00007279 EBA9                    	JMP	short ReadDo
 34874                                  
 34875                                  ;BREAK <$LSEEK - move r/w pointer>
 34876                                  ;----------------------------------------------------------------------------
 34877                                  ;
 34878                                  ;   Assembler usage:
 34879                                  ;	    MOV     DX, offsetlow
 34880                                  ;	    MOV     CX, offsethigh
 34881                                  ;	    MOV     BX, handle
 34882                                  ;	    MOV     AL, method
 34883                                  ;	    MOV     AH, LSeek
 34884                                  ;	    INT     int_command
 34885                                  ;	  DX:AX has the new location of the pointer
 34886                                  ;   Error returns:
 34887                                  ;	    AX = error_invalid_handle
 34888                                  ;	       = error_invalid_function
 34889                                  ;   Returns in registers DX:AX
 34890                                  ;
 34891                                  ;----------------------------------------------------------------------------
 34892                                  
 34893                                  _$LSEEK:
 34894 0000727B E8E900                  	call	CheckOwner		; get system file entry
 34895                                  LSeekError:
 34896 0000727E 7302                    	JNC	short CHKOWN_OK		;AN002;
 34897 00007280 EBAF                    	JMP	short ReadError		;AN002; error return
 34898                                  
 34899                                  CHKOWN_OK:				;AN002;
 34900 00007282 3C02                    	CMP	AL,2			; is the seek value correct?
 34901 00007284 760A                    	JBE	short LSeekDisp		; yes, go dispatch
 34902                                  	;mov	byte [ss:EXTERR_LOCUS],1 
 34903 00007286 36C606[EF02]01          	MOV	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 34904                                  					;smr;SS Override
 34905                                  	;mov	al,1
 34906 0000728C B001                    	mov	al, error_invalid_function ; invalid method
 34907 0000728E EBA1                    	jmp	short ReadError
 34908                                  LSeekDisp:
 34909 00007290 3C01                    	CMP	AL,1			; best way to dispatch; check middle
 34910 00007292 720A                    	JB	short LSeekStore	; just store CX:DX
 34911 00007294 771C                    	JA	short LSeekEOF		; seek from end of file
 34912                                  	;add	dx,[es:di+21]
 34913 00007296 26035515                	ADD	DX,[ES:DI+SF_ENTRY.sf_position]
 34914                                  	;adc	cx,[es:di+23]
 34915 0000729A 26134D17                	ADC	CX,[ES:DI+SF_ENTRY.sf_position+2]
 34916                                  LSeekStore:
 34917 0000729E 89C8                    	MOV	AX,CX			; AX:DX
 34918 000072A0 92                      	XCHG	AX,DX			; DX:AX is the correct value
 34919                                  LSeekSetpos:
 34920                                  	;mov	[es:di+21],ax
 34921 000072A1 26894515                	MOV	[ES:DI+SF_ENTRY.sf_position],AX
 34922                                  	;mov	[es:di+23],dx
 34923 000072A5 26895517                	MOV	[ES:DI+SF_ENTRY.sf_position+2],DX
 34924 000072A9 E89DA3                  	call	Get_User_Stack
 34925                                  	;mov	[si+6],dx
 34926 000072AC 895406                  	MOV	[SI+user_env.user_DX],DX ; return DX:AX
 34927                                  	;jmp	SYS_RET_OK		; successful return
 34928                                  	; 26/07/2019
 34929 000072AF E9ECA4                  	jmp	SYS_RET_OK_clc
 34930                                  
 34931                                  LSeekEOF:
 34932                                  	;test	word [es:di+5],8000h
 34933 000072B2 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 34934 000072B8 750A                    	JNZ	short Check_LSeek_Mode	; Is Net
 34935                                  LOCAL_LSeek:
 34936                                  	;add	dx,[es:di+17]
 34937 000072BA 26035511                	ADD	DX,[ES:DI+SF_ENTRY.sf_size]
 34938                                  	;adc	cx,[es:di+19]
 34939 000072BE 26134D13                	ADC	CX,[ES:DI+SF_ENTRY.sf_size+2]
 34940 000072C2 EBDA                    	JMP	short LSeekStore	; go and set the position
 34941                                  
 34942                                  Check_LSeek_Mode:
 34943                                  	;test	word [es:di+2],8000h
 34944 000072C4 26F745020080            	test	word [ES:DI+SF_ENTRY.sf_mode],sf_isFCB
 34945 000072CA 75EE                    	JNZ	short LOCAL_LSeek	; FCB treated like local file
 34946                                  	;mov	ax,[es:di+2]
 34947 000072CC 268B4502                	MOV	AX,[ES:DI+SF_ENTRY.sf_mode]
 34948                                  	;and	ax, 0F0h
 34949 000072D0 25F000                  	AND	AX,SHARING_MASK
 34950                                  	;cmp	ax,40h
 34951 000072D3 83F840                  	CMP	AX,SHARING_DENY_NONE
 34952 000072D6 7405                    	JZ	short NET_LSEEK		; LSEEK exported in this mode
 34953                                  	;cmp	ax,30h
 34954 000072D8 83F830                  	CMP	AX,SHARING_DENY_READ
 34955 000072DB 75DD                    	JNZ	short LOCAL_LSeek	; Treated like local Lseek
 34956                                  NET_LSEEK:
 34957                                  ;	JMP	short LOCAL_LSeek
 34958                                  ; REMOVE ABOVE INSTRUCTION TO ENABLE DCR 142
 34959                                  	;CallInstall Net_Lseek,MultNET,33
 34960                                  	;JNC	short LSeekSetPos
 34961                                  
 34962 000072DD B82111                  	mov     ax, 1121h
 34963 000072E0 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - SEEK FROM END OF REMOTE FILE
 34964                                  			; CX:DX = offset (in bytes) from end
 34965                                  			; ES:DI -> SFT, SFT DPB field -> DPB of drive with file
 34966                                  			; SS = DOS CS
 34967                                  			; Return: CF set on error
 34968                                  			; CF clear if successful, DX:AX = new file position
 34969 000072E2 73BD                    	jnb     short LSeekSetpos
 34970 000072E4 E9BDA4                  	jmp	SYS_RET_ERR
 34971                                  
 34972                                  ;BREAK <FileTimes - modify write times on a handle>
 34973                                  ;----------------------------------------------------------------------------
 34974                                  ;
 34975                                  ;   Assembler usage:
 34976                                  ;	    MOV AH, FileTimes (57H)
 34977                                  ;	    MOV AL, func
 34978                                  ;	    MOV BX, handle
 34979                                  ;	; if AL = 1 then then next two are mandatory
 34980                                  ;	    MOV CX, time
 34981                                  ;	    MOV DX, date
 34982                                  ;	    INT 21h
 34983                                  ;	; if AL = 0 then CX/DX has the last write time/date
 34984                                  ;	; for the handle.
 34985                                  ;
 34986                                  ;	AL=02		 get extended attributes
 34987                                  ;	   BX=handle
 34988                                  ;	   CX=size of buffer (0, return max size )
 34989                                  ;	   DS:SI query list (si=-1, selects all EA)
 34990                                  ;	   ES:DI buffer to hold EA list
 34991                                  ;
 34992                                  ;	AL=03		 get EA name list
 34993                                  ;	   BX=handle
 34994                                  ;	   CX=size of buffer (0, return max size )
 34995                                  ;	   ES:DI buffer to hold name list
 34996                                  ;
 34997                                  ;	AL=04		 set extended attributes
 34998                                  ;	   BX=handle
 34999                                  ;	   ES:DI buffer of EA list
 35000                                  ;
 35001                                  ;
 35002                                  ;   Error returns:
 35003                                  ;	    AX = error_invalid_function
 35004                                  ;	       = error_invalid_handle
 35005                                  ;
 35006                                  ;----------------------------------------------------------------------------
 35007                                  
 35008                                  _$FILE_TIMES:
 35009                                  	; 13/07/2018 - Retro DOS v3.0
 35010                                  
 35011                                  	; MSDOS 3.3
 35012 000072E7 3C02                    	cmp	al,2			; correct subfunction ?
 35013 000072E9 720B                    	jb	short ft1
 35014                                  
 35015                                          ;mov	byte [ss:EXTERR_LOCUS], 1
 35016 000072EB 36C606[EF02]01          	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35017                                  						;SS Overr
 35018                                  	;mov	al,1
 35019 000072F1 B001                    	mov	al,error_invalid_function ; give bad return
 35020 000072F3 E9AEA4                  	jmp     SYS_RET_ERR
 35021                                  
 35022                                  	; MSDOS 6.0
 35023                                  	;cmp	al,2			; correct subfunction ?
 35024                                  	;jae	short inval_func
 35025                                  ft1:
 35026 000072F6 E86E00                  	call	CheckOwner		; get sft
 35027 000072F9 7283                    	jc	short LSeekError	; bad handle
 35028                                  
 35029 000072FB 08C0                    	or	al,al			; get time/date ?
 35030 000072FD 7515                    	jnz	short ft_set_time
 35031                                  
 35032                                  ;------ here we get the time & date from the sft for the user
 35033                                  
 35034 000072FF FA                      	cli				; is this cli/sti reqd ? BUGBUG
 35035                                  	;mov	cx,[es:di+13]
 35036 00007300 268B4D0D                	mov	cx,[es:di+SF_ENTRY.sf_time] ; get the time
 35037                                  	;mov	dx,[es:di+15]
 35038 00007304 268B550F                	mov	dx,[es:di+SF_ENTRY.sf_date] ;  & date
 35039 00007308 FB                      	sti
 35040 00007309 E83DA3                  	call	Get_User_Stack
 35041                                  	;mov	[si+4],cx
 35042 0000730C 894C04                  	mov	[si+user_env.user_CX],cx
 35043                                  	;mov	[si+6],dx
 35044 0000730F 895406                  	mov	[si+user_env.user_DX],dx
 35045 00007312 EB20                    	jmp	short ok_ret
 35046                                  
 35047                                  ;------ here we set the time in sft
 35048                                  
 35049                                  ft_set_time:
 35050 00007314 E8F6AD                  	call    EcritSFT
 35051                                  	;mov	[es:di+13],cx
 35052 00007317 26894D0D                	mov	[es:di+SF_ENTRY.sf_time],cx ; drop in new time
 35053                                  	;mov	[es:di+15],dx
 35054 0000731B 2689550F                	mov	[es:di+SF_ENTRY.sf_date],dx ;  and date	
 35055                                  
 35056 0000731F 31C0                    	xor	ax, ax
 35057 00007321 36FF1E[9400]            	call	far [ss:JShare+(14*4)] ; 14 = ShSU	; SS Override
 35058                                  
 35059                                  ;------ set the flags in SFT entry
 35060                                  	;and	word [es:di+5],0FFBFh
 35061 00007326 26836505BF              	and	word [es:di+SF_ENTRY.sf_flags],~devid_file_clean 
 35062                                  							; mark file as dirty
 35063                                  	;or	word [es:di+5],4000h
 35064 0000732B 26814D050040            	or	word [es:di+SF_ENTRY.sf_flags],sf_close_nodate
 35065                                  							; ask close not to
 35066                                  							;   bother about date
 35067                                  							;   and time
 35068 00007331 E8E1AD                  	call	LcritSFT
 35069                                  ok_ret:
 35070 00007334 E964A4                  	jmp	SYS_RET_OK
 35071                                  
 35072                                  ;inval_func:
 35073                                  ;	mov	byte [ss:EXTERR_LOCUS], 1
 35074                                  ;	mov	byte [ss:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35075                                  ;						;SS Overr
 35076                                  ;	;mov	al,1
 35077                                  ;	mov	al,error_invalid_function ; give bad return
 35078                                  ;	jmp     SYS_RET_ERR
 35079                                  
 35080                                  ;BREAK <$DUP - duplicate a jfn>
 35081                                  ;----------------------------------------------------------------------------
 35082                                  ;
 35083                                  ;   Assembler usage:
 35084                                  ;	    MOV     BX, fh
 35085                                  ;	    MOV     AH, Dup
 35086                                  ;	    INT     int_command
 35087                                  ;	  AX has the returned handle
 35088                                  ;   Errors:
 35089                                  ;	    AX = dup_invalid_handle
 35090                                  ;	       = dup_too_many_open_files
 35091                                  ;
 35092                                  ;----------------------------------------------------------------------------
 35093                                  
 35094                                  _$DUP:
 35095 00007337 89D8                    	MOV	AX,BX			; save away old handle in AX
 35096 00007339 E842F8                  	call	JFNFree 		; free handle? into ES:DI, new in BX
 35097                                  DupErrorCheck:
 35098 0000733C 7218                    	JC	short DupErr		; nope, bye
 35099 0000733E 06                      	push	es
 35100 0000733F 57                      	push	di			; save away SFT
 35101 00007340 5E                      	pop	si			; into convenient place DS:SI
 35102 00007341 1F                      	pop	ds
 35103 00007342 93                      	XCHG	AX,BX			; get back old handle
 35104 00007343 E82100                  	call	CheckOwner		; get sft in ES:DI
 35105 00007346 720E                    	JC	short DupErr		; errors go home
 35106 00007348 E804C4                  	call	DOS_Dup_Direct
 35107 0000734B E8DDF7                  	call	pJFNFromHandle		; get pointer
 35108 0000734E 268A1D                  	MOV	BL,[ES:DI]		; get SFT number
 35109 00007351 881C                    	MOV	[SI],BL			; stuff in new SFT
 35110 00007353 E945A4                  	jmp	SYS_RET_OK		; and go home
 35111                                  DupErr:
 35112 00007356 E94BA4                  	jmp	SYS_RET_ERR
 35113                                  
 35114                                  ;BREAK <$DUP2 - force a dup on a particular jfn>
 35115                                  ;----------------------------------------------------------------------------
 35116                                  ;
 35117                                  ;   Assembler usage:
 35118                                  ;	    MOV     BX, fh
 35119                                  ;	    MOV     CX, newfh
 35120                                  ;	    MOV     AH, Dup2
 35121                                  ;	    INT     int_command
 35122                                  ;   Error returns:
 35123                                  ;	    AX = error_invalid_handle
 35124                                  ;
 35125                                  ;----------------------------------------------------------------------------
 35126                                  
 35127                                  _$DUP2:
 35128 00007359 53                      	push	bx
 35129 0000735A 51                      	push	cx			; save source
 35130 0000735B 89CB                    	MOV	BX,CX			; get one to close
 35131 0000735D E8A9FD                  	call	_$CLOSE			; close destination handle
 35132 00007360 5B                      	pop	bx
 35133 00007361 58                      	pop	ax			; old in AX, new in BX
 35134 00007362 E8C6F7                  	call	pJFNFromHandle		; get pointer
 35135 00007365 EBD5                    	JMP	short DupErrorCheck	; check error and do dup
 35136                                  
 35137                                  ;Break	<CheckOwner - verify ownership of handles from server>
 35138                                  ;----------------------------------------------------------------------------
 35139                                  ;   CheckOwner - Due to the ability of the server to close file handles for a
 35140                                  ;   process without the process knowing it (delete/rename of open files, for
 35141                                  ;   example), it is possible for the redirector to issue a call to a handle
 35142                                  ;   that it soes not rightfully own.  We check here to make sure that the
 35143                                  ;   issuing process is the owner of the SFT. At the same time, we do a
 35144                                  ;   SFFromHandle to really make sure that the SFT is good.
 35145                                  ;
 35146                                  ;	ENTRY	BX has the handle
 35147                                  ;		User_ID is the current user
 35148                                  ;	EXIT	Carry Clear => ES:DI points to SFT
 35149                                  ;		Carry Set => AX has error code
 35150                                  ;	USES	none
 35151                                  ;----------------------------------------------------------------------------
 35152                                  
 35153                                  CheckOwner:
 35154                                  	; 13/07/2018 - Retro DOS v3.0
 35155                                  
 35156 00007367 E8D9F7                  	call	SFFromHandle
 35157 0000736A 720F                    	jc	short co_ret_label	; retc
 35158                                  
 35159 0000736C 50                      	push	ax
 35160                                  
 35161                                  	; MSDOS 6.0
 35162                                  ;SR;
 35163                                  ;SR; WIN386 patch - Do not check for USER_ID for using handles since these 
 35164                                  ;SR; are shared across multiple VMs in win386.
 35165                                  ;SR;
 35166                                  	;test	byte [IsWin386],1
 35167                                  	;jz	short no_win386		;win386 is not present
 35168                                  	;xor	ax,ax			;set the zero flag
 35169                                  	;jmp	short skip_win386	
 35170                                  
 35171                                  ;no_win386:
 35172 0000736D 36A1[0803]              	mov	ax,[SS:USER_ID]		;smr;SS Override
 35173                                  	;cmp	ax,[es:di+47]
 35174 00007371 263B452F                	cmp	ax,[es:di+SF_ENTRY.sf_UID]
 35175                                  
 35176                                  ;skip_win386:
 35177 00007375 58                      	pop	ax
 35178                                  	
 35179 00007376 7403                    	jz	short co_ret_label
 35180                                  	
 35181                                  	;mov	al,6
 35182 00007378 B006                    	mov	al,error_invalid_handle
 35183 0000737A F9                      	stc
 35184                                  
 35185                                  co_ret_label:
 35186 0000737B C3                      	retn
 35187                                  
 35188                                  ;============================================================================
 35189                                  ; FILE.ASM, MSDOS 6.0, 1991
 35190                                  ;============================================================================
 35191                                  ; 14/07/2018 - Retro DOS v3.0
 35192                                  
 35193                                  ; MSDOS 2.11
 35194                                  ;BREAK <$Open - open a file handle>
 35195                                  ;----------------------------------------------------------------------------
 35196                                  ;   Assembler usage:
 35197                                  ;           LDS     DX, Name
 35198                                  ;           MOV     AH, Open
 35199                                  ;           MOV     AL, access
 35200                                  ;           INT     int_command
 35201                                  ;
 35202                                  ;       ACCESS          Function
 35203                                  ;       ------          --------
 35204                                  ;       open_for_read   file is opened for reading
 35205                                  ;       open_for_write  file is opened for writing
 35206                                  ;       open_for_both   file is opened for both reading and writing.
 35207                                  ;
 35208                                  ;   Error returns:
 35209                                  ;           AX = error_invalid_access
 35210                                  ;              = error_file_not_found
 35211                                  ;              = error_access_denied
 35212                                  ;              = error_too_many_open_files
 35213                                  ;----------------------------------------------------------------------------
 35214                                  
 35215                                  ; MSDOS 6.0
 35216                                  ;	BREAK <$Open - open a file from a path string>
 35217                                  ;----------------------------------------------------------------------------
 35218                                  ;
 35219                                  ;**	$OPen - Open a File
 35220                                  ;
 35221                                  ;	given a path name in DS:DX and an open mode in AL, $Open opens the
 35222                                  ;	file and and returns a handle
 35223                                  ;
 35224                                  ;	ENTRY	(DS:DX) = pointer to asciz name
 35225                                  ;		(AL) = open mode
 35226                                  ;	EXIT	'C' clear if OK
 35227                                  ;		  (ax) = file handle
 35228                                  ;		'C' set if error
 35229                                  ;		  (ax) = error code
 35230                                  ;	USES	all
 35231                                  ;
 35232                                  ;----------------------------------------------------------------------------
 35233                                  
 35234                                  _$OPEN:       
 35235 0000737C 30E4                    	xor	ah,ah  ; MSDOS 6.0	
 35236                                  _$Open2:
 35237                                  	;mov	ch,16h
 35238 0000737E B516                    	mov	ch,attr_hidden+attr_system+attr_directory
 35239 00007380 E84502                  	call	SetAttrib
 35240 00007383 B9[F137]                	mov	cx,DOS_OPEN
 35241                                  
 35242                                  	;xor	ah,ah  ; MSDOS 3.3
 35243                                  
 35244 00007386 50                      	push	ax
 35245                                  
 35246                                  ;*	General file open/create code. The $CREATE call and the various
 35247                                  ;	$OPEN calls all come here.
 35248                                  ;
 35249                                  ;	We'll share a lot of the standard stuff of allocating SFTs, cracking
 35250                                  ;	path names, etc., and then dispatch to our individual handlers.
 35251                                  ;	WARNING - this info and list is just a guess, not definitive - jgl
 35252                                  ;
 35253                                  ;	(TOS) = create mode
 35254                                  ;	(CX) = address of routine to call to do actual function
 35255                                  ;	(DS:DX) = ASCIZ name
 35256                                  ;	SAttrib = Attribute mask
 35257                                  
 35258                                  ;	Get a free SFT and mark it "being allocated"
 35259                                  
 35260                                  AccessFile:
 35261 00007387 E883AD                  	call	EcritSFT
 35262 0000738A E804F8                  	call	SFNFree			; get a free sfn
 35263 0000738D E885AD                  	call	LcritSFT
 35264 00007390 7214                    	jc	short OpenFailJ		; oops, no free sft's
 35265 00007392 36891E[6605]            	MOV	[SS:SFN],BX		; save the SFN for later;smr;SS Override
 35266 00007397 36893E[5A05]            	MOV	[SS:THISSFT],DI		; save the SF offset	;smr;SS Override
 35267 0000739C 368C06[5C05]            	MOV	[SS:THISSFT+2],ES	; save the SF segment	;smr;SS Override
 35268                                  
 35269                                  ;	Find a free area in the user's JFN table.
 35270                                  
 35271 000073A1 E8DAF7                  	call	JFNFree			; get a free jfn
 35272 000073A4 7303                    	jnc	short SaveJFN
 35273                                  OpenFailJ:
 35274 000073A6 E98100                  	JMP	OpenFail		; there were free JFNs... try SFN
 35275                                  
 35276                                  SaveJFN:
 35277 000073A9 36893E[6A05]            	mov	[ss:PJFN],DI		; save the jfn offset	;smr;SS Override
 35278 000073AE 368C06[6C05]            	MOV	[ss:PJFN+2],ES		; save the jfn segment	;smr;SS Override
 35279 000073B3 36891E[6805]            	MOV	[ss:JFN],BX		; save the jfn itself	;smr;SS Override
 35280                                  
 35281                                  ;	We have been given an JFN. We lock it down to prevent other tasks from
 35282                                  ;	reusing the same JFN.
 35283                                  
 35284 000073B8 368B1E[6605]            	MOV	BX,[ss:SFN]					;smr;SS Override
 35285 000073BD 26881D                  	MOV	[ES:DI],BL		; assign the JFN
 35286 000073C0 89D6                    	MOV	SI,DX			; get name in appropriate place
 35287 000073C2 BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 35288 000073C5 51                      	push	cx			; save routine to call
 35289 000073C6 E8C9F9                  	call	TransPath		; convert the path
 35290 000073C9 5B                      	pop	bx			; (bx) = routine to call
 35291                                  
 35292 000073CA 36C536[5A05]            	LDS	SI,[SS:THISSFT]					;smr;SS Override
 35293 000073CF 720A                    	JC	short OpenCleanJ	; no error, go and open file
 35294 000073D1 36803E[3705]FF          	CMP	byte [ss:CMETA],-1				;smr;SS Override
 35295 000073D7 7404                    	JZ	short SetSearch
 35296                                  	;mov	al,2
 35297 000073D9 B002                    	MOV	AL,error_file_not_found ; no meta chars allowed
 35298                                  OpenCleanJ:
 35299 000073DB EB3E                    	JMP	short OpenClean
 35300                                  
 35301                                  SetSearch:
 35302 000073DD 58                      	pop	ax			; Mode (Open), Attributes (Create)
 35303                                  
 35304                                  ;	We need to get the new inheritance bits.
 35305                                  
 35306 000073DE 31C9                    	xor	cx,cx
 35307                                  	; MSDOS 6.0
 35308                                  	;mov	[si+2],cx ; 0
 35309 000073E0 894C02                  	MOV	[SI+SF_ENTRY.sf_mode],cx ; initialize mode field to 0
 35310                                  	;mov    [si+51],cx ; 0
 35311 000073E3 894C33                  	MOV	[SI+SF_ENTRY.sf_MFT],cx	 ; clean out sharing info
 35312                                  	;
 35313 000073E6 81FB[F137]              	CMP	BX,DOS_OPEN
 35314 000073EA 7509                    	JNZ	short _DoOper
 35315                                  	;test   al,80h
 35316 000073EC A880                    	test	AL,SHARING_NO_INHERIT	; look for no inher
 35317 000073EE 7405                    	JZ	short _DoOper ; 10/08/2018
 35318 000073F0 247F                    	AND	AL,7Fh			; mask off inherit bit
 35319                                  	;mov	cx,1000h
 35320 000073F2 B90010                  	MOV	CX,sf_no_inherit
 35321                                  _DoOper:
 35322                                  	;; MSDOS 3.3
 35323                                  	;;mov	word [si+2], 0
 35324                                  	;;mov	word [si+33h], 0
 35325                                  	;MOV	word [SI+SF_ENTRY.sf_mode],0
 35326                                  	;MOV	word [SI+SF_ENTRY.sf_MFT],0
 35327                                  
 35328                                  	; MSDOS 6.0
 35329                                  ;**	Check if this is an extended open. If so you must set the
 35330                                  ;	modes in sf_mode. Call Set_EXT_mode to do all this. See
 35331                                  ;	Set_EXT_mode in creat.asm
 35332                                  
 35333                                  	; MSDOS 6.0
 35334                                  	;;SAVE	<di, es>                ;M022 conditional removed here
 35335                                  	;push	di
 35336                                  	;push	es
 35337                                  	;push	ds
 35338                                  	;pop	es
 35339                                  	;push	si
 35340                                  	;pop	di			; (es:di) = SFT address
 35341                                  	;call	Set_EXT_mode
 35342                                  	;;RESTORE <es, di>
 35343                                  	;pop	es
 35344                                  	;pop	di
 35345                                  
 35346                                  	;Context DS
 35347 000073F5 16                      	push	ss
 35348 000073F6 1F                      	pop	ds	
 35349                                  
 35350 000073F7 51                      	push	cx
 35351 000073F8 FFD3                    	CALL	BX			; blam!
 35352 000073FA 59                      	pop	cx
 35353 000073FB C536[5A05]              	LDS	SI,[THISSFT]
 35354                                  	;JC	short OpenE2		;AN000;FT. chek extended open hooks first
 35355 000073FF 721B                    	jc	short OpenE ; MSDOS 3.3
 35356                                  
 35357                                  ;	The SFT was successfully opened. Remove busy mark.
 35358                                  
 35359                                  OpenOK:
 35360                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],1
 35361 00007401 C7040100                	mov	word [SI],1
 35362                                  	;or	[SI+5],cx
 35363 00007405 094C05                  	OR	[SI+SF_ENTRY.sf_flags],CX ; set no inherit bit if necessary
 35364                                  
 35365                                  ; If the open mode is 70, we scan the system for other SFT's with the same
 35366                                  ; contents. If we find one, then we can 'collapse' thissft onto the already
 35367                                  ; opened one. Otherwise we use this new one. We compare uid/pid/mode/mft
 35368                                  ;
 35369                                  ; Since this is only relevant on sharer systems, we stick this code into the
 35370                                  ; sharer.
 35371                                  
 35372 00007408 36A1[6805]              	MOV	AX,[ss:JFN]				;smr;SS Override
 35373 0000740C 36FF1E[8C00]            	Call	far [ss:JShare+(12*4)]	; 12 = ShCol	;smr;SS Override
 35374                                  
 35375 00007411 36C706[6605]FFFF        	MOV	word [ss:SFN],-1	; clear out sfn pointer	;smr;SS Override
 35376 00007418 E980A3                  	jmp	SYS_RET_OK		; bye with no errors
 35377                                  
 35378                                  	; MSDOS 6.0
 35379                                  ;Extended Open hooks check
 35380                                  ;OpenE2:					;AN000;;EO.
 35381                                  ;	CMP	AX,error_invalid_parameter ;AN000;;EO. IFS extended open ?
 35382                                  ;	JNZ	short OpenE		;AN000;;EO. no.
 35383                                  ;	JMP	short OpenCritLeave	;AN000;;EO. keep handle
 35384                                  
 35385                                  ;	Extended Open hooks check
 35386                                  ;
 35387                                  ;	AL has error code.  Stack has argument to dos_open/dos_create.
 35388                                  
 35389                                  OpenClean:
 35390 0000741B 5B                      	pop	bx			; clean off stack
 35391                                  OpenE:
 35392                                  	;MOV	word [SI+SF_ENTRY.sf_ref_count],0 ; release SFT
 35393 0000741C C7040000                	mov	word [SI],0
 35394 00007420 36C536[6A05]            	LDS	SI,[ss:PJFN]				;smr;SS Override
 35395 00007425 C604FF                  	MOV	BYTE [SI],0FFh		; free the SFN...
 35396 00007428 EB02                    	JMP	SHORT OpenCritLeave
 35397                                  
 35398                                  OpenFail:
 35399 0000742A FB                      	STI
 35400 0000742B 59                      	pop	cx			; Clean stack
 35401                                  OpenCritLeave:
 35402 0000742C 36C706[6605]FFFF        	MOV	word [SS:SFN],-1	; remove mark.
 35403                                  
 35404                                  	; MSDOS 6.0
 35405                                  ;; File Tagging DOS 4.00
 35406                                  ;	CMP	[SS:EXTERR],error_Code_Page_Mismatched 
 35407                                  ;				;AN000;;FT. code page mismatch;smr;SS Override
 35408                                  ;	JNZ	short NORERR	  	;AN000;;FT. no
 35409                                  ;	jmp	From_GetSet		;AN000;;FT. yes
 35410                                  ;NORERR: 				;AN000;
 35411                                  ;; File Tagging DOS 4.00
 35412                                  
 35413 00007433 E96EA3                  	jmp	SYS_RET_ERR		; no free, return error
 35414                                  
 35415                                  ; MSDOS 2.11
 35416                                  ;BREAK <$CREAT - creat a new file and open him for input>
 35417                                  ;----------------------------------------------------------------------------
 35418                                  ;   Assembler usage:
 35419                                  ;           LDS     DX, name
 35420                                  ;           MOV     AH, Creat
 35421                                  ;           MOV     CX, access
 35422                                  ;           INT     21h
 35423                                  ;       ; AX now has the handle
 35424                                  ;
 35425                                  ;   Error returns:
 35426                                  ;           AX = error_access_denied
 35427                                  ;              = error_path_not_found
 35428                                  ;              = error_too_many_open_files
 35429                                  ;----------------------------------------------------------------------------
 35430                                  
 35431                                  ; MSDOS 6.0
 35432                                  ;	BREAK <$Creat - create a brand-new file>
 35433                                  ;----------------------------------------------------------------------------
 35434                                  ;
 35435                                  ;**	$Creat - Create a File
 35436                                  ;
 35437                                  ;	$Creat creates the directory entry specified in DS:DX and gives it the
 35438                                  ;	initial attributes contained in CX
 35439                                  ;
 35440                                  ;	ENTRY	(DS:DX) = ASCIZ path name
 35441                                  ;		(CX) = initial attributes
 35442                                  ;	EXIT	'C' set if error
 35443                                  ;		  (ax) = error code
 35444                                  ;		'C' clear if OK
 35445                                  ;		  (ax) = file handle
 35446                                  ;	USES	all
 35447                                  ;
 35448                                  ;----------------------------------------------------------------------------
 35449                                  
 35450                                  _$CREAT:
 35451 00007436 51                      	push	cx			; Save attributes on stack
 35452 00007437 B9[5B37]                	mov	CX,DOS_CREATE		; routine to call
 35453                                  AccessSet:
 35454                                  	;mov	byte [ss:SATTRIB],6
 35455 0000743A 36C606[2A05]06          	mov	byte [ss:SATTRIB],attr_hidden+attr_system ;smr;SS Override
 35456                                  	; 10/08/2018
 35457 00007440 E944FF                  	JMP	AccessFile		; use good ol' open
 35458                                  
 35459                                  
 35460                                  ; MSDOS 6.0 (MSDOS 3.3)
 35461                                  ;	BREAK <$CHMOD - change file attributes>
 35462                                  ;----------------------------------------------------------------------------
 35463                                  ;
 35464                                  ;**	$CHMOD - Change File Attributes
 35465                                  ;
 35466                                  ;   Assembler usage:
 35467                                  ;	    LDS     DX, name
 35468                                  ;	    MOV     CX, attributes
 35469                                  ;	    MOV     AL,func (0=get, 1=set)
 35470                                  ;	    INT     21h
 35471                                  ;   Error returns:
 35472                                  ;	    AX = error_path_not_found
 35473                                  ;	    AX = error_access_denied
 35474                                  ;
 35475                                  ;----------------------------------------------------------------------------
 35476                                  
 35477                                  _$CHMOD:
 35478                                  	; 05/08/2018 - Retro DOS v3.0
 35479                                  	;IBMDOS.COM (MSDOS 3.3, 1987) - Offset 6FCCh ,
 35480 00007443 BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 35481 00007446 50                      	push	ax
 35482 00007447 51                      	push	cx			; save function and attributes
 35483 00007448 89D6                    	MOV	SI,DX			; get things in appropriate places
 35484 0000744A E849F9                  	call	TransPathSet		; get correct path
 35485 0000744D 59                      	pop	cx
 35486 0000744E 58                      	pop	ax			; and get function and attrs back
 35487 0000744F 7235                    	JC	short ChModErr		; errors get mapped to path not found
 35488 00007451 16                      	push	ss			; set up for later possible calls
 35489 00007452 1F                      	pop	ds
 35490 00007453 803E[3705]FF            	CMP	byte [CMETA],-1
 35491 00007458 752C                    	JNZ	short ChModErr
 35492                                  	;mov	byte [SATTRIB],16h
 35493 0000745A C606[2A05]16            	MOV	byte [SATTRIB],attr_hidden+attr_system+attr_directory
 35494 0000745F 2C01                    	SUB	AL,1			; fast way to discriminate
 35495 00007461 720B                    	JB	short ChModGet		; 0 -> go get value
 35496 00007463 7417                    	JZ	short ChModSet		; 1 -> go set value
 35497                                  	;mov	byte [EXTERR_LOCUS],1
 35498 00007465 C606[EF02]01            	MOV	byte [EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus
 35499                                  	;mov	al,1
 35500 0000746A B001                    	mov	al,error_invalid_function ; bad value
 35501                                  	;jmp	SYS_RET_ERR
 35502 0000746C EB1A                    	jmp	short ChModE	
 35503                                  ChModGet:
 35504 0000746E E8F1C1                  	call	GET_FILE_INFO		; suck out the ol' info
 35505 00007471 7215                    	JC	short ChModE		; error codes are already set for ret
 35506 00007473 E8D3A1                  	call	Get_User_Stack		; point to user saved vaiables
 35507                                  	;mov	[SI+4],ax
 35508 00007476 894404                  	MOV	[SI+user_env.user_CX],AX  ; return the attributes
 35509                                  	;jmp	SYS_RET_OK		; say sayonara
 35510                                  	; 26/07/2019
 35511 00007479 E922A3                  	jmp	SYS_RET_OK_clc
 35512                                  ChModSet:
 35513 0000747C 89C8                    	MOV	AX,CX			; get attrs in position
 35514 0000747E E842C2                  	call	SET_FILE_ATTRIBUTE	; go set
 35515 00007481 7205                    	JC	short ChModE		; errors are set
 35516 00007483 E915A3                  	jmp	SYS_RET_OK
 35517                                  ChModErr:
 35518                                  	;mov	al, 3
 35519 00007486 B003                    	mov	al,error_path_not_found
 35520                                  ChModE:
 35521 00007488 E919A3                  	jmp	SYS_RET_ERR
 35522                                  
 35523                                  ;	BREAK <$UNLINK - delete a file entry>
 35524                                  ;----------------------------------------------------------------------------
 35525                                  ;
 35526                                  ;**	$UNLINK - Delete a File
 35527                                  ;
 35528                                  ;
 35529                                  ;	Assembler usage:
 35530                                  ;	    LDS     DX, name
 35531                                  ;	    IF VIA SERVER DOS CALL
 35532                                  ;	     MOV     CX,SEARCH_ATTRIB
 35533                                  ;	    MOV     AH, Unlink
 35534                                  ;	    INT     21h
 35535                                  ;
 35536                                  ;	ENTRY	(ds:dx) = path name
 35537                                  ;		(cx) = search_attribute, if via server_dos
 35538                                  ;	EXIT	'C' clear if no error
 35539                                  ;		'C' set if error
 35540                                  ;		  (ax) = error code
 35541                                  ;			= error_file_not_found
 35542                                  ;			= error_access_denied
 35543                                  ;
 35544                                  ;----------------------------------------------------------------------------
 35545                                  
 35546                                  _$UNLINK:
 35547 0000748B 51                      	push	cx			; Save possible CX input parm
 35548 0000748C 89D6                    	MOV	SI,DX			; Point at input string
 35549 0000748E BF[8203]                	MOV	DI,OPENBUF		; temp spot for path
 35550 00007491 E802F9                  	call	TransPathSet		; go get normalized path
 35551 00007494 59                      	pop	cx
 35552 00007495 72EF                    	JC	short ChModErr		; badly formed path
 35553 00007497 36803E[3705]FF          	CMP	byte [ss:CMETA],-1	; meta chars?	;smr;SS Override
 35554 0000749D 750F                    	JNZ	short NotFound
 35555 0000749F 16                      	push	ss
 35556 000074A0 1F                      	pop	ds
 35557                                  	;mov	ch,6
 35558 000074A1 B506                    	mov	ch,attr_hidden+attr_system ; unlink appropriate files
 35559 000074A3 E82201                  	call	SetAttrib
 35560 000074A6 E836BE                  	call	DOS_DELETE		; remove that file
 35561 000074A9 7205                    	JC	short UnlinkE 		; error is there
 35562 000074AB E9EDA2                  	jmp	SYS_RET_OK		; okey doksy
 35563                                  NotFound:
 35564                                  	;mov	al, 3
 35565 000074AE B003                    	MOV	AL,error_path_not_found
 35566                                  UnlinkE:
 35567 000074B0 E9F1A2                  	jmp	SYS_RET_ERR		; bye
 35568                                  
 35569                                  ;BREAK <$RENAME - move directory entries around>
 35570                                  ;----------------------------------------------------------------------------
 35571                                  ;
 35572                                  ;   Assembler usage:
 35573                                  ;	    LDS     DX, source
 35574                                  ;	    LES     DI, dest
 35575                                  ;	    IF VIA SERVER DOS CALL
 35576                                  ;	     MOV     CX,SEARCH_ATTRIB
 35577                                  ;	    MOV     AH, Rename
 35578                                  ;	    INT     21h
 35579                                  ;
 35580                                  ;   Error returns:
 35581                                  ;	    AX = error_file_not_found
 35582                                  ;	       = error_not_same_device
 35583                                  ;	       = error_access_denied
 35584                                  ;
 35585                                  ;----------------------------------------------------------------------------
 35586                                  
 35587                                  _$RENAME:
 35588                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35589 000074B3 51                      	push	cx
 35590 000074B4 1E                      	push	ds
 35591 000074B5 52                      	push	dx			; save source and possible CX arg
 35592 000074B6 06                      	PUSH	ES
 35593 000074B7 1F                      	POP	DS			; move dest to source
 35594 000074B8 89FE                    	MOV	SI,DI			; save for offsets
 35595 000074BA BF[0204]                	MOV	DI,RENBUF
 35596 000074BD E8D6F8                  	call	TransPathSet		; munge the paths
 35597 000074C0 36FF36[6E05]            	PUSH	word [ss:WFP_START]	; get pointer	;smr;SS Override
 35598 000074C5 368F06[7005]            	POP	word [ss:REN_WFP]	; stash it	;smr;SS Override
 35599 000074CA 5E                      	pop	si
 35600 000074CB 1F                      	pop	ds
 35601 000074CC 59                      	pop	cx			; get back source and possible CX arg
 35602                                  epjc2:	
 35603 000074CD 72B7                    	JC	short ChModErr		; get old error
 35604 000074CF 36803E[3705]FF          	CMP	byte [ss:CMETA],-1			;smr;SS Override
 35605 000074D5 75D7                    	JNZ	short NotFound
 35606 000074D7 51                      	push	cx			; Save possible CX arg
 35607 000074D8 BF[8203]                	MOV	DI,OPENBUF		; appropriate buffer
 35608 000074DB E8B8F8                  	call	TransPathSet		; wham
 35609 000074DE 59                      	pop	cx
 35610 000074DF 72EC                    	JC	short epjc2
 35611 000074E1 16                      	push	ss
 35612 000074E2 1F                      	pop	ds
 35613 000074E3 803E[3705]FF            	CMP	byte [CMETA],-1
 35614 000074E8 72C4                    	JB	short NotFound
 35615                                  
 35616                                  	; MSDOS 6.0
 35617 000074EA FF36[5E05]              	PUSH	WORD [THISCDS]		   ;AN000;;MS.save thiscds
 35618 000074EE FF36[6005]              	PUSH	WORD [THISCDS+2]	   ;AN000;;MS.
 35619 000074F2 BF[8203]                	MOV	DI,OPENBUF		   ;AN000;;MS.
 35620 000074F5 16                      	PUSH	SS			   ;AN000;;MS.
 35621 000074F6 07                      	POP	ES			   ;AN000;;MS.es:di-> source
 35622 000074F7 30C0                    	XOR	AL,AL			   ;AN000;;MS.scan all CDS
 35623                                  rnloop: 				   ;AN000;
 35624 000074F9 E80EF8                  	call	GetCDSFromDrv		   ;AN000;;MS.
 35625 000074FC 7211                    	JC	short dorn		   ;AN000;;MS.	end of CDS
 35626 000074FE E8D4AA                  	call	StrCmp			   ;AN000;;MS.	current dir ?
 35627 00007501 7404                    	JZ	short rnerr		   ;AN000;;MS.	yes
 35628 00007503 FEC0                    	INC	AL			   ;AN000;;MS.	next
 35629 00007505 EBF2                    	JMP	short rnloop		   ;AN000;;MS.
 35630                                  rnerr:					   ;AN000;
 35631 00007507 83C404                  	ADD	SP,4			   ;AN000;;MS. pop thiscds
 35632                                  	;error	error_current_directory    ;AN000;;MS.
 35633 0000750A B010                    	mov	al,error_current_directory 
 35634 0000750C E995A2                  	jmp	SYS_RET_ERR
 35635                                  dorn:					   ;AN000;
 35636 0000750F 368F06[6005]            	POP	WORD [SS:THISCDS+2]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 35637 00007514 368F06[5E05]            	POP	WORD [SS:THISCDS]	   ;AN000;;MS.;PBUGBUG;SS REQD??
 35638                                  
 35639 00007519 16                      	push	ss
 35640 0000751A 1F                      	pop	ds
 35641                                  
 35642                                  	; MSDOS 3.3 (& MSDOS 6.0)
 35643                                  	;mov	ch,16h
 35644 0000751B B516                    	mov	ch,attr_directory+attr_hidden+attr_system
 35645                                  					; rename appropriate files
 35646 0000751D E8A800                  	call	SetAttrib
 35647 00007520 E867BF                  	call	DOS_RENAME		; do the deed
 35648 00007523 728B                    	JC	short UnlinkE 		; errors
 35649                                  
 35650 00007525 E973A2                  	jmp	SYS_RET_OK
 35651                                  
 35652                                  
 35653                                  ; 14/07/2018 - Retro DOS v3.0
 35654                                  ; MSDOS 3.3 (& MSDOS 6.0)
 35655                                  
 35656                                  ;Break <$CreateNewFile - Create a new directory entry>
 35657                                  ;----------------------------------------------------------------------------
 35658                                  ;   CreateNew - Create a new directory entry.  Return a file handle if there
 35659                                  ;	was no previous directory entry, and fail if a directory entry with
 35660                                  ;	the same name existed previously.
 35661                                  ;
 35662                                  ;   Inputs:	DS:DX point to an ASCIZ file name
 35663                                  ;		CX contains default file attributes
 35664                                  ;   Outputs:	Carry Clear:
 35665                                  ;		    AX has file handle opened for read/write
 35666                                  ;		Carry Set:
 35667                                  ;		    AX has error code
 35668                                  ;   Registers modified: All
 35669                                  ;----------------------------------------------------------------------------
 35670                                  
 35671                                  _$CreateNewFile:
 35672 00007528 51                      	push	cx			; Save attributes on stack
 35673 00007529 B9[EC37]                	MOV	CX,DOS_Create_New	; routine to call
 35674 0000752C E90BFF                  	JMP	AccessSet		; use good ol' open
 35675                                  
 35676                                  ;**	BinToAscii - convert a number to a string.
 35677                                  ;----------------------------------------------------------------------------
 35678                                  ;	BinToAscii converts a 16 bit number into a 4 ascii characters.
 35679                                  ;	This routine is used to generate temp file names so we don't spend
 35680                                  ;	the time and code needed for a true hex number, we just use
 35681                                  ;	A thorugh O.
 35682                                  ;
 35683                                  ;	ENTRY	(ax) = value
 35684                                  ;		(es:di) = destination
 35685                                  ;	EXIT	(es:di) updated by 4
 35686                                  ;	USES	cx, di, flags
 35687                                  ;----------------------------------------------------------------------------
 35688                                  
 35689                                  ; MSDOS 3.3
 35690                                  ;BinToAscii:
 35691                                  ;	mov     cx,4
 35692                                  ;bta5:
 35693                                  ;	push    cx
 35694                                  ;	mov     cl,4
 35695                                  ;	rol     ax,cl
 35696                                  ;	push    ax
 35697                                  ;	and     al,0Fh
 35698                                  ;	add     al,'0'
 35699                                  ;	cmp     al,'9'
 35700                                  ;	jbe     short bta6
 35701                                  ;	add     al,7
 35702                                  ;bta6: 
 35703                                  ;	stosb
 35704                                  ;	pop     ax
 35705                                  ;	pop     cx
 35706                                  ;	loop    bta5
 35707                                  ;	retn
 35708                                  
 35709                                  ; MSDOS 6.0
 35710                                  BinToAscii:
 35711 0000752F B90404                  	mov	cx,404h			; (ch) = digit counter, (cl) = shift cnt
 35712                                  bta5:	
 35713 00007532 D3C0                    	ROL	AX,CL			; move leftmost nibble into rightmost
 35714 00007534 50                      	push	ax			; preserve remainder of digits
 35715 00007535 240F                    	AND	AL,0Fh			; grab low nibble
 35716 00007537 0441                    	ADD	AL,'A'			; turn into ascii
 35717 00007539 AA                      	STOSB				; drop in the character
 35718 0000753A 58                      	pop	ax			; (ax) = shifted number
 35719 0000753B FECD                    	dec	ch
 35720 0000753D 75F3                    	jnz	short bta5		; process 4 digits
 35721 0000753F C3                      	retn
 35722                                  
 35723                                  ;Break	<$CreateTempFile - create a unique name>
 35724                                  ;----------------------------------------------------------------------------
 35725                                  ;   $CreateTemp - given a directory, create a unique name in that directory.
 35726                                  ;	Method used is to get the current time, convert to a name and attempt
 35727                                  ;	a create new.  Repeat until create new succeeds.
 35728                                  ;
 35729                                  ;   Inputs:	DS:DX point to a null terminated directory name.
 35730                                  ;		CX  contains default attributes
 35731                                  ;   Outputs:	Unique name is appended to DS:DX directory.
 35732                                  ;		AX has handle
 35733                                  ;   Registers modified: all
 35734                                  ;----------------------------------------------------------------------------
 35735                                  
 35736                                  _$CreateTempFile:
 35737                                  	;Enter
 35738 00007540 55                      	push	bp
 35739 00007541 89E5                    	mov	bp,sp
 35740                                  
 35741                                  	;LocalVar    EndPtr,DWORD
 35742                                  	;LocalVar    FilPtr,DWORD
 35743                                  	;LocalVar    Attr,WORD
 35744                                  
 35745 00007543 83EC0A                  	sub	sp,10
 35746                                  
 35747                                  	;test	cx,0FFD8h
 35748 00007546 F7C1D8FF                	test	CX,~attr_changeable
 35749 0000754A 7405                    	JZ	short OKatts		; Ok if no non-changeable bits set
 35750                                  ;
 35751                                  ; We need this "hook" here to detect these cases (like user sets one both of
 35752                                  ; vol_id and dir bits) because of the structure of the or $CreateNewFile loop
 35753                                  ; below.  The code loops on error_access_denied, but if one of the non
 35754                                  ; changeable attributes is specified, the loop COULD be infinite or WILL be
 35755                                  ; infinite because CreateNewFile will fail with access_denied always.  Thus we
 35756                                  ; need to detect these cases before getting to the loop.
 35757                                  ;
 35758                                  	;mov	ax, 5
 35759 0000754C B80500                  	MOV	AX,error_access_denied
 35760 0000754F EB6B                    	JMP	SHORT SETTMPERR
 35761                                  
 35762                                  OKatts:
 35763                                  	;MOV	attr,CX 		; save attribute
 35764 00007551 894EF6                  	mov     [bp-10],cx
 35765                                  	;MOV	FilPtrL,DX		; pointer to file
 35766 00007554 8956F8                  	mov	[bp-8],dx
 35767                                  	;MOV	FilPtrH,DS
 35768 00007557 8C5EFA                  	mov	[bp-6],ds
 35769                                  	;MOV	EndPtrH,DS		; seg pointer to end of dir
 35770 0000755A 8C5EFE                  	mov	[bp-2],ds
 35771 0000755D 1E                      	PUSH	DS
 35772 0000755E 07                      	POP	ES			; destination for nul search
 35773 0000755F 89D7                    	MOV	DI,DX
 35774 00007561 89F9                    	MOV	CX,DI
 35775 00007563 F7D9                    	NEG	CX			; number of bytes remaining in segment
 35776                                  	; MSDOS 6.0
 35777 00007565 09C9                    	OR	CX,CX			;AN000;MS. cx=0 ? ds:dx on segment boundary
 35778 00007567 7501                    	JNZ	short okok		;AN000;MS. no
 35779                                  	;MOV	CX,-1			;AN000;MS.
 35780 00007569 49                      	dec	cx  ; mov cx,-1
 35781                                  	;
 35782                                  okok:					;AN000;
 35783 0000756A 31C0                    	XOR	AX,AX			;AN000;
 35784 0000756C F2AE                    	REPNZ	SCASB			;AN000;
 35785                                  					;AN000;
 35786 0000756E 4F                      	DEC	DI			; point back to the null
 35787 0000756F 268A45FF                	MOV	AL,[ES:DI-1]		; Get char before the NUL
 35788 00007573 E8B5E3                  	call	PATHCHRCMP		; Is it a path separator?
 35789 00007576 7403                    	JZ	short SETENDPTR		; Yes
 35790                                  STOREPTH:
 35791 00007578 B05C                    	MOV	AL,'\'
 35792 0000757A AA                      	STOSB				; Add a path separator (and INC DI)
 35793                                  SETENDPTR:
 35794                                  	;MOV	EndPtrL,DI		; pointer to the tail
 35795 0000757B 8856FC                  	mov	[bp-4],dl
 35796                                  CreateLoop:
 35797 0000757E 16                      	push	ss			; let ReadTime see variables
 35798 0000757F 1F                      	pop	ds
 35799 00007580 55                      	push	bp
 35800 00007581 E8F7A3                  	call	READTIME		; go get time
 35801 00007584 5D                      	pop	bp
 35802                                  ;
 35803                                  ; Time is in CX:DX.  Go drop it into the string.
 35804                                  ;
 35805                                  	;les	di,EndPtr		; point to the string
 35806 00007585 C47EFC                  	les	di,[BP-4]
 35807 00007588 89C8                    	mov	ax,cx
 35808 0000758A E8A2FF                  	call	BinToAscii		; store upper word
 35809 0000758D 89D0                    	mov	ax,dx
 35810 0000758F E89DFF                  	call	BinToAscii		; store lower word
 35811 00007592 30C0                    	xor	al,al
 35812 00007594 AA                      	STOSB				; nul terminate
 35813                                  	;LDS	DX,FilPtr		; get name
 35814 00007595 C556F8                  	lds	dx,[bp-8]
 35815                                  	;MOV	CX,Attr 		; get attr
 35816 00007598 8B4EF6                  	mov	cx,[bp-10]
 35817 0000759B 55                      	push	bp
 35818 0000759C E889FF                  	CALL	_$CreateNewFile		; try to create a new file
 35819 0000759F 5D                      	pop	bp
 35820 000075A0 731B                    	JNC	short CreateDone	; failed, go try again
 35821                                  ;
 35822                                  ; The operation failed and the error has been mapped in AX.  Grab the extended
 35823                                  ; error and figure out what to do.
 35824                                  ;
 35825                                  	;; MSDOS 3.3			; M049 - start
 35826                                  ;;	mov	ax,[ss:EXTERR]				;smr;SS Override
 35827                                  ;;	cmp	al,error_file_exists
 35828                                  ;;	jz	short CreateLoop	; file existed => try with new name
 35829                                  ;;	cmp	al,error_access_denied
 35830                                  ;;	jz	short CreateLoop	; access denied (attr mismatch)
 35831                                  
 35832                                  	; MSDOS 6.0
 35833                                  	;cmp	al,50h
 35834 000075A2 3C50                    	CMP	AL,error_file_exists	; Q: did file already exist
 35835 000075A4 74D8                    	JZ	short CreateLoop	; Y: try again
 35836                                  	;cmp	al,5
 35837 000075A6 3C05                    	CMP	AL,error_access_denied	; Q: was it access denied
 35838 000075A8 7512                    	JNZ	short SETTMPERR		; N: Error out
 35839                                  					; Y: Check to see if we got this due
 35840                                  					;    to the network drive. Note that
 35841                                  					;    the redir will set the exterr
 35842                                  					;    to error_cannot_make if this is 
 35843                                  					;    so. 
 35844 000075AA 36803E[F002]41          	CMP	byte [SS:EXTERR],error_net_access_denied ; M069
 35845                                  					; See if it's REALLY an att mismatch
 35846 000075B0 740A                    	je	short SETTMPERR		; no, network error, stop
 35847                                  ;M070
 35848                                  ; If the user failed on an I24, we do not want to try again
 35849                                  ;
 35850 000075B2 36803E[F002]53          	cmp	byte [SS:EXTERR],error_FAIL_I24 ;User failed on I24? ;M070
 35851 000075B8 7402                    	je	short SETTMPERR		;yes, do not try again ;M070
 35852                                  
 35853 000075BA EBC2                    	jmp	short CreateLoop	;attr mismatch, try again ;M070
 35854                                  
 35855                                  ;;	MOV	AL,error_access_denied	; Return this "extended" error
 35856                                  					; M049 - end
 35857                                  SETTMPERR:
 35858 000075BC F9                      	STC
 35859                                  CreateDone:
 35860                                  	;Leave
 35861 000075BD 89EC                    	mov	sp,bp
 35862 000075BF 5D                      	pop	bp
 35863 000075C0 7203                    	JC	short CreateFail
 35864 000075C2 E9D6A1                  	jmp	SYS_RET_OK		; success!
 35865                                  CreateFail:
 35866 000075C5 E9DCA1                  	jmp	SYS_RET_ERR
 35867                                  
 35868                                  ;
 35869                                  ;   SetAttrib will set the search attribute (SAttrib) either to the normal
 35870                                  ;   (CH) or to the value in CL if the current system call is through
 35871                                  ;   serverdoscall.
 35872                                  ;
 35873                                  ;   Inputs:	fSharing == FALSE => set sattrib to CH
 35874                                  ;		fSharing == TRUE => set sattrib to CL
 35875                                  ;   Outputs:	none
 35876                                  ;   Registers changed:	CX
 35877                                  
 35878                                  SetAttrib:
 35879 000075C8 36F606[2F05]FF          	test	byte [SS:FSHARING],-1		;smr;SS Override
 35880 000075CE 7502                    	jnz	short Set
 35881 000075D0 88E9                    	mov	cl,ch
 35882                                  Set:
 35883 000075D2 36880E[2A05]            	mov	byte [ss:SATTRIB],cl		;smr;SS Override
 35884 000075D7 C3                      	retn
 35885                                  
 35886                                  ; 14/07/2018 - Retro DOS v3.0
 35887                                  ; MSDOS 6.0
 35888                                  
 35889                                  ;Break	<Extended_Open- Extended open the file>
 35890                                  ;----------------------------------------------------------------------------
 35891                                  ; Input: AL= 0 reserved  AH=6CH
 35892                                  ;	 BX= mode
 35893                                  ;	 CL= create attribute  CH=search attribute (from server)
 35894                                  ;	 DX= flag
 35895                                  ;	 DS:SI = file name
 35896                                  ;	 ES:DI = parm list
 35897                                  ;			   DD  SET EA list (-1) null
 35898                                  ;			   DW  n  parameters
 35899                                  ;			   DB  type (TTTTTTLL)
 35900                                  ;			   DW  IOMODE
 35901                                  ; Function: Extended Open
 35902                                  ; Output: carry clear
 35903                                  ;		     AX= handle
 35904                                  ;		     CX=1 file opened
 35905                                  ;			2 file created/opened
 35906                                  ;			3 file replaced/opened
 35907                                  ;	  carry set: AX has error code
 35908                                  ;----------------------------------------------------------------------------
 35909                                  
 35910                                  ;_$Extended_Open:			  ;AN000;
 35911                                  ;	;ASSUME	CS:DOSCODE,SS:DOSDATA	  ;AN000;
 35912                                  ;	MOV	[SS:EXTOPEN_FLAG],DX	  ;AN000;EO. save ext. open flag;smr;SS Override
 35913                                  ;	MOV	word [SS:EXTOPEN_IO_MODE],0 ;AN000;EO. initialize IO mode;smr;SS Override
 35914                                  ;	TEST	DX,reserved_bits_mask	  ;AN000;EO. reserved bits 0  ?
 35915                                  ;	JNZ	short ext_inval2	  ;AN000;EO. no
 35916                                  ;	MOV	AH,DL			  ;AN000;EO. make sure flag is right
 35917                                  ;	CMP	DL,0			  ;AN000;EO. all fail ?
 35918                                  ;	JZ	short ext_inval2	  ;AN000;EO. yes, error
 35919                                  ;	AND	DL,exists_mask		  ;AN000;EO. get exists action byte
 35920                                  ;	CMP	DL,2			  ;AN000;EO, > 02
 35921                                  ;	JA	short ext_inval2	  ;AN000;EO. yes ,error
 35922                                  ;	AND	AH,not_exists_mask	  ;AN000;EO. get no exists action byte
 35923                                  ;	CMP	AH,10H			  ;AN000;EO. > 10
 35924                                  ;	JA	short ext_inval2	  ;AN000;EO. yes error
 35925                                  ;
 35926                                  ;	MOV	[SS:SAVE_ES],ES		  ;AN000;EO. save API parms;smr;SS Override
 35927                                  ;	MOV	[SS:SAVE_DI],DI		  ;AN000;EO.;smr;SS Override
 35928                                  ;	PUSH	word [SS:EXTOPEN_FLAG]	  ;AN000;EO.;smr;SS Override
 35929                                  ;	POP	word [SS:SAVE_DX]	  ;AN000;EO.;smr;SS Override
 35930                                  ;	MOV	[SS:SAVE_CX],CX		  ;AN000;EO.;smr;SS Override
 35931                                  ;	MOV	[SS:SAVE_BX],BX		  ;AN000;EO.;smr;SS Override
 35932                                  ;	MOV	[SS:SAVE_DS],DS		  ;AN000;EO.;smr;SS Override
 35933                                  ;	MOV	[SS:SAVE_SI],SI		  ;AN000;EO.;smr;SS Override
 35934                                  ;	MOV	DX,SI			  ;AN000;EO. ds:dx points to file name
 35935                                  ;	MOV	AX,BX			  ;AN000;EO. ax= mode
 35936                                  ;	JMP	SHORT goopen2		  ;AN000;;EO. do normal
 35937                                  ;ext_inval2:				  ;AN000;;EO.
 35938                                  ;	mov	al,error_invalid_function ;AN000;EO.. invalid function
 35939                                  ;	jmp	SYS_RET_ERR
 35940                                  ;error_return:				  ;AN000;EO.
 35941                                  ;	retn				  ;AN000;EO.. return with error
 35942                                  ;goopen2:				  ;AN000;
 35943                                  ;	TEST	BX,int_24_error 	  ;AN000;EO.. disable INT 24 error ?
 35944                                  ;	JZ	short goopen		  ;AN000;EO.. no
 35945                                  ;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_I24_OFF ;AN000;EO.. set bit to disable;smr;SS Override
 35946                                  ;goopen:					  ;AN000;
 35947                                  ;	OR	byte [SS:EXTOPEN_ON],EXT_OPEN_ON  ;AN000;EO.. set Extended Open active;smr;SS Override
 35948                                  ;	AND	word [SS:EXTOPEN_FLAG],0FFH  ;AN000;EO.create new ?;smr;SS Override
 35949                                  ;	CMP	word [SS:EXTOPEN_FLAG],ext_exists_fail + ext_nexists_create ;AN000;FT.;smr;SS Override
 35950                                  ;	JNZ	short chknext 		  ;AN000;;EO. no
 35951                                  ;	call	_$CreateNewFile		  ;AN000;;EO. yes
 35952                                  ;	JC	short error_return	  ;AN000;;EO. error
 35953                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 35954                                  ;	JZ	short ok_return2	  ;AN000;;EO. yes
 35955                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. creted/opened;smr;SS Override
 35956                                  ;	JMP	short setXAttr		  ;AN000;;EO. set XAs
 35957                                  ;ok_return2:
 35958                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 35959                                  ;chknext:
 35960                                  ;	TEST	word [SS:EXTOPEN_FLAG],ext_exists_open ;AN000;;EO. exists open;smr;SS Override
 35961                                  ;	JNZ	short exist_open	  ;AN000;;EO. yes
 35962                                  ;	call	_$CREAT			  ;AN000;;EO. must be replace open
 35963                                  ;	JC	short error_return	  ;AN000;;EO. return with error
 35964                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS does it;smr;SS Override
 35965                                  ;	JZ	short ok_return2	  ;AN000;;EO. yes
 35966                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened ;AN000;EO. prsume create/open;smr;SS Override
 35967                                  ;	TEST	byte [SS:EXTOPEN_ON],ext_file_not_exists ;AN000;;EO. file not exists ?;smr;SS Override
 35968                                  ;	JNZ	short setXAttr		  ;AN000;;EO. no
 35969                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_replaced_opened ;AN000;;EO. replaced/opened;smr;SS Override
 35970                                  ;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 35971                                  ;error_return2:
 35972                                  ;	STC 				  ; Set Carry again to flag error ;AN001;
 35973                                  ;	retn				  ;AN000;;EO. return with error
 35974                                  ;					  ;AN000;
 35975                                  ;exist_open:				  ;AN000;
 35976                                  ;	test	byte [SS:FSHARING],-1	  ;AN000;;EO. server doscall?;smr;SS Override
 35977                                  ;	jz	short noserver		  ;AN000;;EO. no
 35978                                  ;	MOV	CL,CH			  ;AN000;;EO. cl=search attribute
 35979                                  ;noserver:
 35980                                  ;	call	_$Open2			  ;AN000;;EO. do open
 35981                                  ;	JNC	short ext_ok		  ;AN000;;EO.
 35982                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. error and IFS call;smr;SS Override
 35983                                  ;	JZ	short error_return2	  ;AN000;;EO. return with error
 35984                                  ;local_extopen:
 35985                                  ;	CMP	AX,error_file_not_found   ;AN000;;EO. file not found error
 35986                                  ;	JNZ	short error_return2	  ;AN000;;EO. no,
 35987                                  ;	TEST	word [SS:EXTOPEN_FLAG],ext_nexists_create;AN000;;EO. want to fail;smr;SS Override
 35988                                  ;	JNZ	short do_creat		  ;AN000;;EO. yes
 35989                                  ;	JMP	short extexit 		  ;AN000;;EO. yes
 35990                                  ;do_creat:
 35991                                  ;	MOV	CX,[SS:SAVE_CX]		  ;AN000;;EO. get ds:dx for file name;smr;SS Override
 35992                                  ;	LDS	SI,[SS:SAVE_SI]		  ;AN000;;EO. cx = attribute;smr;SS Override
 35993                                  ;	MOV	DX,SI			  ;AN000;;EO.
 35994                                  ;	call	_$CREAT			  ;AN000;;EO. do create
 35995                                  ;	JC	short extexit 		  ;AN000;;EO. error
 35996                                  ;	MOV	word [SS:EXTOPEN_FLAG],action_created_opened 
 35997                                  ;					  ;AN000;;EO. is created/opened;smr;SS Override
 35998                                  ;	JMP	SHORT setXAttr		  ;AN000;;EO. set XAs
 35999                                  ;
 36000                                  ;ext_ok:
 36001                                  ;	CMP	byte [SS:EXTOPEN_ON],0	  ;AN000;;EO. IFS call ?;smr;SS Override
 36002                                  ;	JZ	short ok_return		  ;AN000;;EO. yes
 36003                                  ;	MOV	[SS:EXTOPEN_FLAG],action_opened ;AN000;;EO.  opened;smr;SS Override
 36004                                  ;setXAttr:
 36005                                  ;	call	Get_User_Stack		  ;AN000;;EO.
 36006                                  ;	MOV	AX,[SS:EXTOPEN_FLAG]	  ;AN000;;EO.;smr;SS Override
 36007                                  ;	MOV	[SI+user_env.user_CX],AX  ;AN000;;EO. set action code for cx
 36008                                  ;	POP	AX			  ;AN000;;EO.
 36009                                  ;	MOV	[SI+user_env.user_AX],AX  ;AN000;;EO. set handle for ax
 36010                                  ;
 36011                                  ;ok_return:				  ;AN000;
 36012                                  ;	jmp	SYS_RET_OK		  ;AN000;;EO.
 36013                                  ;
 36014                                  ;extexit2:				  ;AN000; ERROR RECOVERY
 36015                                  ;	POP	BX			  ;AN000;EO. close the handle
 36016                                  ;	PUSH	AX			  ;AN000;EO. save error code from set XA
 36017                                  ;	CMP	word [SS:EXTOPEN_FLAG],action_created_opened 
 36018                                  ;					  ;AN000;EO. from create;smr;SS Override
 36019                                  ;	JNZ	short justopen		  ;AN000;EO.
 36020                                  ;	LDS	SI,[SS:SAVE_SI]		  ;AN000;EO. cx = attribute;smr;SS Override
 36021                                  ;	LDS	DX,[SI]			  ;AN000;EO.
 36022                                  ;	call	_$UNLINK 		  ;AN000;EO. delete the file
 36023                                  ;	JMP	SHORT reserror		  ;AN000;EO.
 36024                                  ;
 36025                                  ;justopen:				  ;AN000;
 36026                                  ;	call	$CLOSE			  ;AN000;EO. pretend never happend
 36027                                  ;reserror:				  ;AN000;
 36028                                  ;	POP	AX			  ;AN000;EO. restore error code from set XA
 36029                                  ;	JMP	SHORT extexit		  ;AN000;EO.
 36030                                  ;
 36031                                  ;ext_file_unfound:			  ;AN000;
 36032                                  ;	MOV	AX,error_file_not_found   ;AN000;EO.
 36033                                  ;	JMP	SHORT extexit		  ;AN000;EO.
 36034                                  ;ext_inval:				  ;AN000;
 36035                                  ;	MOV	AX,error_invalid_function ;AN000;EO.
 36036                                  ;extexit:
 36037                                  ;	jmp	SYS_RET_ERR		  ;AN000;EO.
 36038                                  
 36039                                  ;============================================================================
 36040                                  ; LOCK.ASM, MSDOS 6.0, 1991
 36041                                  ;============================================================================
 36042                                  ; 14/07/2018 - Retro DOS v3.0
 36043                                  
 36044                                  ;BREAK <$LockOper - Lock Calls>
 36045                                  
 36046                                  ;
 36047                                  ;   Assembler usage:
 36048                                  ;	    MOV     BX, Handle	       (DOS 3.3)
 36049                                  ;	    MOV     CX, OffsetHigh
 36050                                  ;	    MOV     DX, OffsetLow
 36051                                  ;	    MOV     SI, LengthHigh
 36052                                  ;	    MOV     DI, LengthLow
 36053                                  ;	    MOV     AH, LockOper
 36054                                  ;	    MOV     AL, Request
 36055                                  ;	    INT     21h
 36056                                  ;
 36057                                  ;   Error returns:
 36058                                  ;	    AX = error_invalid_handle
 36059                                  ;	       = error_invalid_function
 36060                                  ;	       = error_lock_violation
 36061                                  ;
 36062                                  ;   Assembler usage:
 36063                                  ;	    MOV     AX, 5C??	       (DOS 4.00)
 36064                                  ;
 36065                                  ;				    0? lock all
 36066                                  ;				    8? lock write
 36067                                  ;				    ?2 lock multiple
 36068                                  ;				    ?3 unlock multiple
 36069                                  ;				    ?4 lock/read
 36070                                  ;				    ?5 write/unlock
 36071                                  ;				    ?6 add (lseek EOF/lock/write/unlock)
 36072                                  ;	    MOV     BX, Handle
 36073                                  ;	    MOV     CX, count or size
 36074                                  ;	    LDS     DX, buffer
 36075                                  ;	    INT     21h
 36076                                  ;
 36077                                  ;   Error returns:
 36078                                  ;	    AX = error_invalid_handle
 36079                                  ;	       = error_invalid_function
 36080                                  ;	       = error_lock_violation
 36081                                  
 36082                                  _$LockOper:
 36083 000075D8 3C01                    	CMP	AL,1
 36084 000075DA 770C                    	JA	short lock_bad_func
 36085                                  
 36086 000075DC 57                      	PUSH	DI			       ; Save LengthLow
 36087 000075DD E863F5                  	call	SFFromHandle		       ; ES:DI -> SFT
 36088 000075E0 7311                    	JNC	short lock_do 		       ; have valid handle
 36089 000075E2 5F                      	POP	DI			       ; Clean stack
 36090                                  	;mov	al,6
 36091 000075E3 B006                    	mov	al,error_invalid_handle
 36092 000075E5 E9BCA1                  	jmp	SYS_RET_ERR
 36093                                  
 36094                                  lock_bad_func:
 36095                                  	;mov	byte [ss:EXTERR_LOCUS],1
 36096 000075E8 36C606[EF02]01          	MOV	byte [SS:EXTERR_LOCUS],errLOC_Unk ; Extended Error Locus;smr;SS Override
 36097                                  	;mov	al,1
 36098 000075EE B001                    	mov	al,error_invalid_function
 36099 000075F0 E9B1A1                  	jmp	SYS_RET_ERR
 36100                                  
 36101                                  	; MSDOS 6.0 
 36102                                  ; Align_buffer call has been deleted, since it corrupts the DTA (6/5/88) P5013
 36103                                  ; Dead code deleted, MD, 23 Mar 90
 36104                                  
 36105                                  lock_do:
 36106                                  	; MSDOS 3.3
 36107 000075F3 08C0                    	or	al,al
 36108 000075F5 58                      	pop	ax
 36109 000075F6 741E                    	jz	short DOS_Lock
 36110                                  DOS_Unlock:
 36111                                   	;test	word [es:di+5],8000h
 36112 000075F8 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36113 000075FE 7409                    	JZ	short LOCAL_UNLOCK
 36114 00007600 50                      	push    ax
 36115 00007601 B80B11                  	mov     ax,110Bh
 36116 00007604 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 36117                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 36118                                  			; STACK: WORD low word of size, ES:DI -> SFT for file
 36119                                  			; SFT DPB field -> DPB of drive containing file
 36120                                  			; Return: CF set error
 36121 00007606 5B                      	pop     bx
 36122 00007607 EB05                    	jmp     short ValChk
 36123                                  
 36124                                  LOCAL_UNLOCK:
 36125 00007609 36FF1E[7800]            	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 36126                                  ValChk:
 36127 0000760E 7303                    	JNC	short Lock_OK
 36128                                  lockerror:
 36129 00007610 E991A1                  	jmp	SYS_RET_ERR
 36130                                  Lock_OK:
 36131                                  	;MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 36132 00007613 E985A1                  	jmp	SYS_RET_OK
 36133                                  DOS_Lock:
 36134                                  	;test	word [es:di+5],8000h
 36135 00007616 26F745050080            	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36136 0000761C 7407                    	JZ	short LOCAL_LOCK
 36137                                  	;CallInstall NET_XLock,MultNET,10
 36138 0000761E B80A11                  	mov     ax, 110Ah
 36139 00007621 CD2F                    	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 36140                                  			; BX = file handle, CX:DX = starting offset, SI = high word of size
 36141                                  			; STACK: WORD low word of size, ES:DI -> SFT
 36142                                  			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 36143                                  			; Return: CF set error
 36144 00007623 EBE9                    	JMP	short ValChk
 36145                                  
 36146                                  LOCAL_LOCK:
 36147 00007625 36FF1E[7400]            	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 36148 0000762A EBE2                    	JMP	short ValChk
 36149                                  
 36150                                  ;lock_do:
 36151                                  ;	; MSDOS 6.0
 36152                                  ;	MOV	BX,AX				; save AX
 36153                                  ;	MOV	BP,Lock_Buffer			; get DOS LOCK buffer
 36154                                  ;	MOV	[BP+LockBuf.Lock_position],DX	; set low offset
 36155                                  ;	MOV	[BP+LockBuf.Lock_position+2],CX; set high offset
 36156                                  ;	POP	CX				; get low length
 36157                                  ;	MOV	[BP+LockBuf.Lock_length],CX	; set low length
 36158                                  ;	MOV	[BP+LockBuf.Lock_length+2],SI	; set high length
 36159                                  ;	MOV	CX,1				; one range
 36160                                  ;
 36161                                  ;;	PUSH	CS				;
 36162                                  ;;	POP	DS				; DS:DX points to
 36163                                  ;
 36164                                  ;	push	ss
 36165                                  ;	pop	ds
 36166                                  ;
 36167                                  ;	MOV	DX,BP				;   Lock_Buffer
 36168                                  ;	TEST	AL,Unlock_all			; function 1
 36169                                  ;	JNZ	short DOS_Unlock		; yes
 36170                                  ;	JMP	short DOS_Lock			; function 0
 36171                                  ;
 36172                                  ;DOS_Unlock:
 36173                                  ;	;test	word [es:di+5],8000h
 36174                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36175                                  ;	JZ	short LOCAL_UNLOCK
 36176                                  ;	;CallInstall Net_Xlock,MultNET,10
 36177                                  ;	mov     ax, 110Bh
 36178                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - UNLOCK REGION OF FILE
 36179                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 36180                                  ;			; STACK: WORD low word of size, ES:DI -> SFT for file
 36181                                  ;			; SFT DPB field -> DPB of drive containing file
 36182                                  ;			; Return: CF set error
 36183                                  ;
 36184                                  ;	JMP	SHORT ValChk
 36185                                  ;LOCAL_UNLOCK:
 36186                                  ;	Call	far [ss:JShare+(7*4)]	; 7 = clr_block ;smr;SS Override
 36187                                  ;ValChk:
 36188                                  ;	JNC	short Lock_OK
 36189                                  ;lockerror:
 36190                                  ;	jmp	SYS_RET_ERR
 36191                                  ;Lock_OK:
 36192                                  ;	MOV	AX,[SS:Temp_VAR] ;AN000;;MS. AX= number of bytes ;smr;SS Override
 36193                                  ;	jmp	SYS_RET_OK
 36194                                  ;DOS_Lock:
 36195                                  ;	;test	word [es:di+5],8000h
 36196                                  ;	test	word [ES:DI+SF_ENTRY.sf_flags],sf_isnet
 36197                                  ;	JZ	short LOCAL_LOCK
 36198                                  ;	;CallInstall NET_XLock,MultNET,10
 36199                                  ;	mov     ax,110Ah
 36200                                  ;	int     2Fh	; Multiplex - NETWORK REDIRECTOR - LOCK REGION OF FILE
 36201                                  ;			; BX = file handle, CX:DX = starting offset, SI = high word of size
 36202                                  ;			; STACK: WORD low word of size, ES:DI -> SFT
 36203                                  ;			; SFT DPB field -> DPB of drive containing file, SS = DOS CS
 36204                                  ;			; Return: CF set error
 36205                                  ;	JMP	short ValChk
 36206                                  ;
 36207                                  ;LOCAL_LOCK:
 36208                                  ;	Call	far [ss:JShare+(6*4)]	; 6 = Set_Block ;smr;SS Override
 36209                                  ;	JMP	short ValChk
 36210                                  
 36211                                  ; 14/07/2018 - Retro DOS v3.0
 36212                                  ; LOC_CHECK
 36213                                  ;MSDOS 6.0 (& MSDOS 3.3)
 36214                                  
 36215                                  ; Inputs:
 36216                                  ;	Outputs of SETUP
 36217                                  ;	[USER_ID] Set
 36218                                  ;	[PROC_ID] Set
 36219                                  ; Function:
 36220                                  ;	Check for lock violations on local I/O
 36221                                  ;	Retries are attempted with sleeps in between
 36222                                  ; Outputs:
 36223                                  ;    Carry clear
 36224                                  ;	Operation is OK
 36225                                  ;    Carry set
 36226                                  ;	A lock violation detected
 36227                                  ; Outputs of SETUP preserved
 36228                                  
 36229                                  LOCK_CHECK:
 36230 0000762C 8B1E[1A00]              	MOV	BX,[RetryCount]	; Number retries
 36231                                  LockRetry:
 36232 00007630 53                      	push	bx		; save regs
 36233                                  	; 26/07/2019
 36234                                  	;push	ax ; MSDOS 6.0
 36235                                  	; MSDOS 3.3 (& MSDOS 6.0)
 36236 00007631 FF1E[7C00]              	call	far [JShare+(8*4)] ; 8 = chk_block
 36237                                  	;pop	ax ; MSDOS 6.0
 36238 00007635 5B                      	pop	bx		; restrore regs
 36239 00007636 7307                    	jnc	short lc_ret_label ; There are no locks (retnc)
 36240                                  LockN:
 36241 00007638 E8EFA9                  	call	Idle		; wait a while
 36242 0000763B 4B                      	DEC	BX		; remember a retry
 36243 0000763C 75F2                    	JNZ	short LockRetry	; more retries left...
 36244 0000763E F9                      	STC
 36245                                  lc_ret_label:
 36246 0000763F C3                      	retn
 36247                                  
 36248                                  ; 14/07/2018 - Retro DOS v3.0
 36249                                  ; LOCK_VIOLATION
 36250                                  ;MSDOS 6.0 (& MSDOS 3.3)
 36251                                  
 36252                                  ; Inputs:
 36253                                  ;	[THISDPB] set
 36254                                  ;	[READOP] indicates whether error on read or write
 36255                                  ; Function:
 36256                                  ;	Handle Lock violation on compatibility (FCB) mode SFTs
 36257                                  ; Outputs:
 36258                                  ;	Carry set if user says FAIL, causes error_lock_violation
 36259                                  ;	Carry clear if user wants a retry
 36260                                  ;
 36261                                  ; DS, ES, DI, CX preserved, others destroyed
 36262                                  
 36263                                  LOCK_VIOLATION:
 36264 00007640 1E                      	PUSH	DS
 36265 00007641 06                      	PUSH	ES
 36266 00007642 57                      	PUSH	DI
 36267 00007643 51                      	PUSH	CX
 36268                                  	;mov	ax,21h
 36269 00007644 B82100                  	MOV	AX,error_lock_violation
 36270                                  	;mov	byte [ALLOWED],18h
 36271 00007647 C606[1503]18            	MOV	byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 36272 0000764C C42E[4605]              	LES	BP,[THISDPB]
 36273 00007650 BF0100                  	MOV	DI,1		; Fake some registers
 36274 00007653 89F9                    	MOV	CX,DI
 36275                                  	;mov	dx,[es:bp+11]
 36276 00007655 268B560B                	MOV	DX,[ES:BP+DPB.FIRST_SECTOR]
 36277 00007659 E8CEE4                  	call	HARDERR
 36278 0000765C 59                      	POP	CX
 36279 0000765D 5F                      	POP	DI
 36280 0000765E 07                      	POP	ES
 36281 0000765F 1F                      	POP	DS
 36282 00007660 3C01                    	CMP	AL,1
 36283 00007662 74DB                    	jz	short lc_ret_label ; 1 = retry, carry clear
 36284 00007664 F9                      	STC
 36285 00007665 C3                      	retn
 36286                                  
 36287                                  ; 14/07/2018 - Retro DOS v3.0
 36288                                  
 36289                                  ;	do a retz to return error
 36290                                  
 36291                                  CheckShare:
 36292                                  	; MSDOS 6.0
 36293                                  	;push	ds			;smr;
 36294                                  	;;getdseg <ds>			; ds -> dosdata
 36295                                  	;push	cs
 36296                                  	;pop	ds
 36297                                  	;CMP	byte [fShare],0
 36298                                  	;pop	ds			;smr;
 36299                                  	;retn
 36300                                  	
 36301                                  	; MSDOS 3.3
 36302 00007666 2E803E[CF02]00          	cmp	byte [cs:fShare],0
 36303 0000766C C3                      	retn
 36304                                  
 36305                                  ;============================================================================
 36306                                  ; SHARE.ASM, MSDOS 6.0, 1991
 36307                                  ;============================================================================
 36308                                  ; 14/07/2018 - Retro DOS v3.0
 36309                                  
 36310                                  ; SHARE_CHECK
 36311                                  
 36312                                  ; Inputs:
 36313                                  ;       [THISSFT] Points to filled in local file/device SFT for new
 36314                                  ;               instance of file sf_mode ALWAYS has mode (even on FCB SFTs)
 36315                                  ;       [WFP_START] has full path of name
 36316                                  ;       [USER_ID] Set
 36317                                  ;       [PROC_ID] Set
 36318                                  ; Function:
 36319                                  ;       Check for sharing violations on local file/device access
 36320                                  ; Outputs:
 36321                                  ;    Carry clear
 36322                                  ;       Sharing approved
 36323                                  ;    Carry set
 36324                                  ;       A sharing violation detected
 36325                                  ;           AX is error code
 36326                                  ; USES    ALL but DS
 36327                                  
 36328                                  SHARE_CHECK:
 36329                                  	; 26/07/2019
 36330 0000766D FF1E[6000]              	call	far [JShare+(1*4)] 	; 1 = MFT_Enter
 36331                                  shchk_retn:
 36332 00007671 C3                      	retn
 36333                                  
 36334                                  ; SHARE_VIOLATION
 36335                                  
 36336                                  ; Inputs:
 36337                                  ;       [THISDPB] Set
 36338                                  ;       AX has error code
 36339                                  ; Function:
 36340                                  ;       Handle Sharing errors
 36341                                  ; Outputs:
 36342                                  ;       Carry set if user says FAIL, causes error_sharing_violation
 36343                                  ;       Carry clear if user wants a retry
 36344                                  ;
 36345                                  ; DS, ES, DI preserved, others destroyed
 36346                                  
 36347                                  SHARE_VIOLATION:
 36348 00007672 1E                      	PUSH    DS
 36349 00007673 06                      	PUSH	ES
 36350 00007674 57                      	PUSH    DI
 36351 00007675 C606[3205]00            	MOV     byte [READOP],0		; All share errors are reading
 36352                                  	;mov	byte [ALLOWED],18h
 36353 0000767A C606[1503]18            	MOV     byte [ALLOWED],Allowed_FAIL+Allowed_RETRY
 36354 0000767F C42E[4605]              	LES     BP,[THISDPB]
 36355 00007683 BF0100                  	MOV     DI,1			; Fake some registers
 36356 00007686 89F9                    	MOV     CX,DI
 36357                                  	;mov	dx,[es:bp+16]
 36358 00007688 268B5611                	MOV     DX,[ES:BP+DPB.DIR_SECTOR]
 36359 0000768C E89BE4                  	call	HARDERR
 36360 0000768F 5F                      	POP     DI
 36361 00007690 07                      	POP	ES
 36362 00007691 1F                      	POP     DS
 36363 00007692 3C01                    	CMP     AL,1
 36364 00007694 74DB                    	jz	short shchk_retn	; 1 = retry, carry clear
 36365 00007696 F9                      	STC
 36366 00007697 C3                      	retn
 36367                                  
 36368                                  ;   ShareEnd - terminate sharing info on a particular SFT/UID/PID.  This does
 36369                                  ;       NOT perform a close, it merely asserts that the sharing information
 36370                                  ;       for the SFT/UID/PID may be safely released.
 36371                                  ;
 36372                                  ;   Inputs:     ES:DI points to an SFT
 36373                                  ;   Outputs:    None
 36374                                  ;   Registers modified: all except DS,ES,DI
 36375                                  
 36376                                  ShareEnd:
 36377                                  	; 26/07/2019
 36378 00007698 FF1E[6400]              	call	far [JShare+(2*4)]	; 2 = MFTClose
 36379 0000769C C3                      	retn
 36380                                  
 36381                                  ;Break <ShareEnter - attempt to enter a node into the sharing set>
 36382                                  
 36383                                  ;
 36384                                  ;   ShareEnter - perform a retried entry of a nodde into the sharing set.  If
 36385                                  ;   the max number of retries is exceeded, we notify the user via int 24.
 36386                                  ;
 36387                                  ;   Inputs:     ThisSFT points to the SFT
 36388                                  ;               WFP_Start points to the WFP
 36389                                  ;   Outputs:    Carry clear => successful entry
 36390                                  ;               Carry set => failed system call
 36391                                  ;   Registers modified: all
 36392                                  
 36393                                  ShareEnter:
 36394 0000769D 51                      	push	cx
 36395                                  retry:
 36396 0000769E 8B0E[1A00]              	mov     cx,[RetryCount]
 36397                                  attempt:
 36398 000076A2 C43E[5A05]              	les     di,[THISSFT]		; grab sft
 36399 000076A6 31C0                    	XOR     AX,AX
 36400                                   	;mov	[es:di+51],ax
 36401 000076A8 26894533                	MOV     [ES:DI+SF_ENTRY.sf_MFT],AX ; indicate free SFT
 36402 000076AC 51                      	push	cx
 36403 000076AD E8BDFF                  	call    SHARE_CHECK             ; attempt to enter into the sharing set
 36404 000076B0 59                      	pop	cx
 36405 000076B1 730A                    	jnc	short done		; success, let the user see this
 36406 000076B3 E874A9                  	call	Idle                    ; wait a while
 36407 000076B6 E2EA                    	loop    attempt                 ; go back for another attempt
 36408 000076B8 E8B7FF                  	call    SHARE_VIOLATION         ; signal the problem to the user
 36409 000076BB 73E1                    	jnc	short retry		; user said to retry, go do it
 36410                                  done:
 36411 000076BD 59                      	pop	cx
 36412 000076BE C3                      	retn
 36413                                  
 36414                                  ;----------------------------------------------------------------------------
 36415                                  
 36416                                  ;----------------------------------------------------------------------------
 36417                                  
 36418                                  ;align 2 ; 05/09/2018 (Error!)
 36419                                  
 36420 000076BF 90                      align 16 ; 08/09/2018 (OK.)
 36421                                  
 36422                                  ; 06/08/2018 - Retro DOS v3.0
 36423                                  
 36424                                  ;============================================================================
 36425                                  ; MSINIT.ASM
 36426                                  ;============================================================================
 36427                                  ;
 36428                                  ; MAIN ENTRY FOR DOS INITIALIZATION
 36429                                  ;
 36430                                  	; 15/07/2018 - Retro DOS v3.0
 36431                                  	; (MSDOS 3.3, IBMDOS.COM, 1987)
 36432                                  
 36433                                  SYSBUF:
 36434                                  IRETT:
 36435 000076C0 CF                      	iret
 36436                                  
 36437                                  	; 07/07/2018 - Retro DOS v3.0
 36438                                  	; Retro DOS v2.0 - 03/03/2018
 36439                                  DOSINIT:
 36440                                  	; Far call from SYSINIT
 36441                                  	; DX = Memory size in paragraphs
 36442                                  	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
 36443                                  	;	  (Retro DOS v2.0, 16/03/2018)
 36444 000076C1 FA                              CLI
 36445 000076C2 FC                              CLD
 36446 000076C3 2E8916[1003]                    MOV     [CS:ENDMEM],DX
 36447 000076C8 2E8926[8A04]                    MOV     [CS:INITSP],SP
 36448 000076CD 2E8C16[8C04]                    MOV     [CS:INITSS],SS
 36449 000076D2 8CC8                            MOV     AX,CS
 36450 000076D4 8ED0                            MOV     SS,AX
 36451 000076D6 BC[B879]                        MOV     SP,INITSTACK
 36452                                  	; 08/08/2018
 36453 000076D9 368C1E[4A00]            	MOV     [SS:NULDEV+2],DS
 36454 000076DE 368936[4800]                    MOV     [SS:NULDEV],SI	; DS:SI Points to CONSOLE Device
 36455                                  	; 15/07/2018
 36456                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 36457                                  	; (Set INT 2Ah handler address to an 'IRET')
 36458 000076E3 1E                      	push    ds
 36459 000076E4 31C0                    	xor     ax,ax
 36460 000076E6 8ED8                    	mov     ds,ax
 36461 000076E8 B8[C076]                	mov     ax,IRETT
 36462 000076EB A3A800                  	mov     [2Ah*4],ax ; 00A8h
 36463 000076EE 8CC8                    	mov     ax,cs
 36464 000076F0 A3AA00                  	mov     [(2Ah*4)+2],ax ; 00AAh
 36465 000076F3 1F                      	pop     ds
 36466                                  	;
 36467 000076F4 E81102                          CALL    CHARINIT	; initialize console driver
 36468                                  
 36469 000076F7 56                              PUSH	SI		; save pointer to header	
 36470 000076F8 0E                      	PUSH	CS
 36471 000076F9 07                              POP	ES
 36472                                          ; 07/07/2018
 36473 000076FA BF[9E00]                	MOV     DI,SFTABL+SFT.SFTable	; Point to sft 0
 36474 000076FD B80300                          MOV     AX,3
 36475 00007700 AB                              STOSW           	; Refcount
 36476 00007701 FEC8                            DEC     AL
 36477 00007703 AB                              STOSW           	; Access rd/wr, compatibility
 36478 00007704 30C0                            XOR     AL,AL
 36479 00007706 AA                              STOSB           	; attribute
 36480                                  	;mov	al,0C3h
 36481 00007707 B0C3                    	mov	al,devid_device_EOF|devid_device|ISCIN|ISCOUT
 36482 00007709 AB                      	STOSw			; flags
 36483 0000770A 89F0                            mov	ax,si
 36484 0000770C AB                              stosw			; device pointer in devptr	
 36485 0000770D 8CD8                            mov	ax,ds
 36486 0000770F AB                      	stosw
 36487 00007710 31C0                    	xor	ax,ax	; 0
 36488 00007712 AB                      	stosw			; firclus
 36489 00007713 AB                      	stosw			; time
 36490 00007714 AB                      	stosw			; date
 36491 00007715 48                      	dec	ax	; -1
 36492 00007716 AB                      	stosw			; size
 36493 00007717 AB                      	stosw
 36494 00007718 40                      	inc	ax	; 0
 36495 00007719 AB                      	stosw			; position
 36496 0000771A AB                      	stosw
 36497                                  	;add	di,7
 36498 0000771B 83C707                  	add	di,SF_ENTRY.sf_name - SF_ENTRY.sf_cluspos
 36499                                  				; point at name
 36500                                  	;add	si,10
 36501 0000771E 83C60A                  	add	si,SYSDEV.NAME	; sdevname
 36502                                  				; point to name
 36503 00007721 B90400                  	mov	cx,4
 36504 00007724 F3A5                    	rep	movsw		; name
 36505 00007726 B103                    	mov	cl,3
 36506 00007728 B020                    	mov	al," "
 36507 0000772A F3AA                    	rep	stosb		; extension
 36508 0000772C 5E                      	POP	SI		; get back pointer to header
 36509                                  
 36510                                  				; mark device as CON I/O
 36511                                  	; 15/07/2018
 36512                                          ;OR	BYTE [SI+4],ISCIN|ISCOUT ; or byte [si+4],3
 36513 0000772D 804C0403                	OR	BYTE [SI+SYSDEV.ATT],ISCIN|ISCOUT
 36514                                  	; 12/03/2018
 36515 00007731 368936[3200]            	MOV     [SS:BCON],SI
 36516 00007736 368C1E[3400]                    MOV     [SS:BCON+2],DS
 36517                                  
 36518                                  CHAR_INIT_LOOP:
 36519 0000773B C534                            LDS     SI,[SI]				; AUX device
 36520 0000773D E8C801                          CALL    CHARINIT
 36521                                         	;15/07/2018
 36522                                  	;test	byte [SI+4],8
 36523 00007740 F6440408                	TEST    BYTE [SI+SYSDEV.ATT],ISCLOCK
 36524 00007744 74F5                            JZ      SHORT CHAR_INIT_LOOP
 36525                                  	; 12/03/2018
 36526 00007746 368936[2E00]                    MOV     [SS:BCLOCK],SI
 36527 0000774B 368C1E[3000]                    MOV     [SS:BCLOCK+2],DS
 36528 00007750 BD[BA79]                        MOV     BP,MEMSTRT			; ES:BP points to DPB
 36529                                  PERDRV:
 36530                                  	;lds	si,[SI+SYSDEV.NEXT] ; 15/07/2018
 36531 00007753 C534                            LDS     SI,[SI]				; Next device
 36532 00007755 83FEFF                          CMP     SI,-1
 36533 00007758 7468                    	JZ      SHORT CONTINIT
 36534                                  
 36535 0000775A E8AB01                          CALL    CHARINIT
 36536                                  
 36537                                  	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
 36538                                  	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
 36539                                  	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
 36540                                  	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
 36541                                  	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
 36542                                  	; (.. !DSK$IN' in MSBIO1.ASM)
 36543                                  	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)
 36544                                  
 36545                                          ; 15/07/2018
 36546                                  	;test	word [SI+4],8000h		; DEVTYP
 36547 0000775D F744040080                      TEST    word [SI+SYSDEV.ATT],DEVTYP
 36548 00007762 75EF                    	JNZ     SHORT PERDRV			; Skip any other character devs
 36549                                  
 36550 00007764 368A0E[3103]                    MOV	CL,[SS:CALLUNIT] ; 12/03/2018
 36551 00007769 30ED                    	XOR     CH,CH
 36552                                          ; 07/07/2018
 36553                                  	;MOV	[SI+10],CL		; Number of units in name field
 36554 0000776B 884C0A                  	mov	[si+SYSDEV.NAME],cl	; sdevname        
 36555 0000776E 368A16[4600]            	MOV     DL,[SS:NUMIO]	; 15/03/2018
 36556 00007773 30F6                    	XOR     DH,DH
 36557 00007775 36000E[4600]            	ADD	[SS:NUMIO],CL	; 12/03/2018
 36558 0000777A 1E                      	PUSH    DS
 36559 0000777B 56                              PUSH    SI
 36560 0000777C 36C51E[3603]            	LDS	BX,[SS:CALLBPB]	; 12/03/2018
 36561                                  PERUNIT:
 36562 00007781 8B37                            MOV     SI,[BX]                 ; DS:SI Points to BPB
 36563 00007783 43                              INC     BX
 36564 00007784 43                              INC     BX                      ; On to next BPB
 36565                                  	;07/07/2018
 36566                                          ;mov	[ES:BP+DPB.DRIVE],dl
 36567 00007785 26885600                	MOV     [ES:BP],DL
 36568                                  	;MOV	[ES:BP+1],DH
 36569 00007789 26887601                	MOV	[ES:BP+DPB.UNIT],DH
 36570 0000778D 53                              PUSH    BX
 36571 0000778E 51                              PUSH    CX
 36572 0000778F 52                              PUSH    DX
 36573                                  
 36574                                          ;invoke	$SETDPB
 36575 00007790 E88BA6                          CALL	_$SETDPB
 36576                                  
 36577                                  	; 07/07/2018
 36578                                  	;MOV	AX,[ES:BP+2]
 36579 00007793 268B4602                	mov	ax,[ES:BP+DPB.SECTOR_SIZE]
 36580                                          ; 12/03/2018
 36581 00007797 363B06[3600]            	CMP	AX,[SS:MAXSEC]
 36582 0000779C 7604                    	JBE     SHORT NOTMAX
 36583 0000779E 36A3[3600]              	MOV	[SS:MAXSEC],AX
 36584                                  NOTMAX:
 36585 000077A2 5A                              POP     DX
 36586 000077A3 59                              POP     CX
 36587 000077A4 5B                              POP     BX
 36588 000077A5 8CD8                            MOV     AX,DS                   ; save segment of bpb array
 36589 000077A7 5E                              POP     SI
 36590 000077A8 1F                              POP     DS
 36591                                  					; ds:si -> device header
 36592                                  					; store it in the corresponding dpb
 36593                                  	; 07/07/2018
 36594                                          ;MOV	[ES:BP+18],SI
 36595 000077A9 26897613                	mov	[ES:BP+DPB.DRIVER_ADDR],si
 36596                                          ;MOV	[ES:BP+20],DS
 36597 000077AD 268C5E15                	mov	[ES:BP+DPB.DRIVER_ADDR+2],ds
 36598                                  
 36599 000077B1 1E                              PUSH    DS			; save pointer to device header
 36600 000077B2 56                              PUSH    SI
 36601 000077B3 FEC6                            INC     DH			; inc unit #
 36602 000077B5 FEC2                            INC     DL			; inc drive #
 36603 000077B7 8ED8                            MOV     DS,AX			; restore segment of BPB array
 36604                                          ;add	bp,32 ; 15/07/2018
 36605                                  	;add	bp,33 ; MSDOS 6.0 ; 31/07/2019
 36606 000077B9 83C521                  	ADD     BP,DPBSIZ		; advance pointer to next dpb
 36607 000077BC E2C3                    	LOOP    PERUNIT			; process all units in each driver
 36608                                          
 36609 000077BE 5E                      	POP     SI			; restore pointer to device header
 36610 000077BF 1F                              POP     DS
 36611 000077C0 EB91                    	JMP	SHORT PERDRV		; process all drivers in chain
 36612                                  
 36613                                  CONTINIT:
 36614 000077C2 0E                              PUSH    CS
 36615 000077C3 1F                              POP     DS
 36616                                  ; Calculate true address of buffers, FATs, free space
 36617 000077C4 89EF                            MOV     DI,BP           ; First byte after current DPBs
 36618 000077C6 8B2E[3600]                      MOV     BP,[MAXSEC]
 36619 000077CA B8[C076]                        MOV     AX,SYSBUF	; = IRETT (15/07/2018)
 36620                                          ; 07/07/2018
 36621                                  	;MOV	[BUFFSTRT],AX
 36622 000077CD 01E8                            ADD     AX,BP           ; One I/O buffer
 36623 000077CF 83C014                          ADD     AX,BUFINSIZ ; = 16
 36624 000077D2 A3[2600]                        MOV     [DPBHEAD],AX	; True start of DPBs
 36625 000077D5 89C2                            MOV     DX,AX
 36626 000077D7 81EA[C076]                      SUB     DX,SYSBUF	; = IRETT (15/07/2018)
 36627 000077DB 89D5                            MOV     BP,DX
 36628 000077DD 01FD                            ADD     BP,DI           ; Allocate buffer space
 36629                                  	;sub	bp,918 ; = ADJFAC for current DOSINIT (07/07/2018)
 36630 000077DF 81EDFA02                        SUB     BP,ADJFAC       ; True address of free memory
 36631 000077E3 55                              PUSH    BP ; ### ; *fmem* (start of free memory)		
 36632                                          ; 24/07/2019
 36633 000077E4 BF[BA79]                	MOV     DI,MEMSTRT	; Current start of DPBs  ; 75A6h for MSDOS 3.3
 36634                                  	;add	di,24 ; MSDOS 3.3
 36635                                  	;add	di,25 ; MSDOS 6.0
 36636 000077E7 83C719                          ADD     DI,DPB.NEXT_DPB	; Point at dpb.next_dpb field
 36637 000077EA 8A0E[4600]                      MOV     CL,[NUMIO]
 36638 000077EE 30ED                            XOR     CH,CH
 36639                                  TRUEDPBAD:
 36640                                  	;add	ax,32 ; MSDOS 3.3
 36641                                  	;add	ax,33 ; MSDOS 6.0
 36642 000077F0 83C021                          ADD     AX,DPBSIZ       ; Compute address of next DPB
 36643 000077F3 AB                              STOSW                   ; Set the link to next DPB
 36644 000077F4 83C71F                          ADD     DI,DPBSIZ-2     ; Point at next address
 36645 000077F7 E2F7                            LOOP    TRUEDPBAD
 36646 000077F9 83EF21                          SUB     DI,DPBSIZ       ; Point at last dpb.next_dpb field
 36647 000077FC B8FFFF                          MOV     AX,-1
 36648 000077FF AB                              STOSW                   ; End of list
 36649 00007800 83C50F                          ADD     BP,15           ; True start of free space (round up to segment)
 36650                                  	; 15/07/2018
 36651                                  	;MOV	CL,4
 36652                                          ;SHR	BP,CL           ; Number of segments for DOS resources
 36653 00007803 D1DD                            rcr	bp,1
 36654 00007805 B103                    	mov	cl,3
 36655 00007807 D3ED                    	shr	bp,cl
 36656                                  	;
 36657 00007809 8CCA                    	MOV     DX,CS
 36658 0000780B 01EA                            ADD     DX,BP           ; First free segment
 36659                                  	
 36660                                    	; 06/07/2019
 36661                                  	;MOV	BX,15 ; 0Fh
 36662                                  	;MOV	CX,[ENDMEM]
 36663                                  	
 36664 0000780D 8CCD                    	MOV     BP,CS
 36665                                  
 36666                                  ; BP has segment of DOS (whether to load high or run in place)
 36667                                  ; DX has program segment (whether after DOS or overlaying DOS)
 36668                                  ; CX has size of memory in paragraphs (reduced by DOS size if HIGHMEM)
 36669                                          
 36670                                  	; 06/07/2019
 36671                                  	;MOV	[ENDMEM],CX
 36672                                          ;MOV	ES,BP
 36673                                          ;MOV	[ES:DSKCHRET+3],ES ; mov [ES:DOSEG_INIT],es
 36674                                  
 36675 0000780F 2E892E[6C03]            	mov	[cs:DSKCHRET+3],bp        
 36676                                  
 36677 00007814 31C0                    	XOR     AX,AX
 36678 00007816 8ED8                            MOV     DS,AX
 36679 00007818 8EC0                            MOV     ES,AX
 36680                                  	;mov	di,82h 
 36681 0000781A BF8200                          MOV     DI,INTBASE+2
 36682                                  	; 15/07/2018
 36683 0000781D 89E8                            MOV     AX,BP
 36684                                  	; Set INT 0 (divide by zero) handler
 36685 0000781F C7060000[C35A]          	mov     word [0],DIVOV
 36686 00007825 A30200                  	mov     word [2],ax  ; = cs
 36687                                  	; Set INT 20h to INT 28h handler segments 
 36688                                  	;mov	cx,17
 36689 00007828 B111                    	mov	cl,17 ; 06/07/2019
 36690 0000782A F3AB                    	rep	stosw
 36691                                  	; DI points to INT 29h vector, offset
 36692 0000782C 83C706                  	add	di,6 
 36693                                  	; DI points to INT 2Ah vector, segment
 36694                                  	;Set  INT 2Ah to INT 3Fh handler segments		
 36695                                  	;mov	cx,43
 36696 0000782F B12B                    	mov	cl,43 ; 06/07/2019
 36697 00007831 F3AB                    	rep	stosw
 36698                                  	; DI points to INT 40h vector, segment
 36699 00007833 BF8000                  	mov	di,80h
 36700                                  	; Set INT 20h to INT 28h vectors to their default handler offsets
 36701 00007836 B8[CF14]                	mov	ax,_IRET
 36702                                  	;mov	cx,9
 36703 00007839 B109                    	mov	cl,9 ; 06/07/2019
 36704                                  iset1:
 36705 0000783B AB                      	stosw
 36706 0000783C 83C702                  	add	di,2
 36707 0000783F E2FA                    	loop	iset1
 36708 00007841 83C704                  	add	di,4
 36709                                  	; Set INT 2Ah to INT 3Fh vectors to their default handler offsets
 36710                                  	;mov	cx,22
 36711 00007844 B116                    	mov	cl,22 ; 06/07/2019
 36712                                  iset2:
 36713 00007846 AB                      	stosw
 36714 00007847 83C702                  	add	di,2
 36715 0000784A E2FA                    	loop	iset2
 36716                                  	
 36717                                  	; 06/07/2019
 36718 0000784C 89E8                    	mov	ax,bp ; *ax=cs*
 36719                                  
 36720                                  	; Set	INT 2Fh handler offset to INT2F
 36721 0000784E C706BC00[5C18]          	mov	word [2Fh*4],INT2F  ; 00BCh
 36722                                  
 36723                                  	; set up entry point call at vectors 30-31h
 36724                                  
 36725 00007854 C606C000EA                      MOV     BYTE [ENTRYPOINT],mi_Long_JMP
 36726 00007859 C706C100[D014]                  MOV     WORD [ENTRYPOINT+1],CALL_ENTRY
 36727                                  
 36728 0000785F A3C300                  	MOV    [ENTRYPOINT+3],AX ; = cs
 36729                                  
 36730                                  	; Set	INT 20h, 21h, 22h, 23h handler offsets
 36731 00007862 C7068000[C914]                  MOV     WORD [addr_int_abort],QUIT
 36732 00007868 C7068400[E814]                  MOV     WORD [addr_int_command],COMMAND
 36733 0000786E C70688000001                    MOV     WORD [addr_int_terminate],100H
 36734 00007874 89168A00                        MOV     [addr_int_terminate+2],DX ; *cmc*
 36735                                  	; 15/07/2018 - Retro DOS v3.0
 36736 00007878 C7069400[F616]                  MOV     WORD [addr_int_disk_read],ABSDRD   ; INT 25h
 36737 0000787E C7069800[4117]                  MOV     WORD [addr_int_disk_write],ABSDWRT ; INT 26h
 36738 00007884 C7069C00[DD67]                  MOV     WORD [addr_int_keep_process],STAY_RESIDENT ; INT 27h
 36739                                  
 36740                                  	; 15/07/2018
 36741                                  	; MSDOS 3.3 (IBMDOS.COM, 1987)
 36742 0000788A 0E                      	push	cs
 36743 0000788B 1F                      	pop	ds
 36744 0000788C 0E                      	push	cs
 36745 0000788D 07                      	pop	es
 36746                                  	; initialize the jump table for the sharer..
 36747                                  	;	(MSDOS 6.0, MSINIT.ASM, 1991, "patch_misc_segments")
 36748                                  	; MSDOS 3.3
 36749                                  	; (set JSharer jump table segments)
 36750 0000788E BF[5C00]                	mov	di,JShare
 36751                                  	;mov	ax,cs ; *ax=cs*
 36752                                  	;mov	cx,15
 36753 00007891 B10F                    	mov	cl,15 ; 06/07/2019
 36754                                  iset3:
 36755 00007893 83C702                  	add	di,2
 36756 00007896 AB                      	stosw
 36757 00007897 E2FA                    	loop	iset3
 36758                                  
 36759                                  	; MSDOS 2.11, MSDOS 3.3
 36760 00007899 B8[7A03]                        MOV     AX,INITBLOCK
 36761 0000789C 83C00F                          ADD	AX,0Fh		; round to a paragraph
 36762 0000789F B104                            MOV     CL,4
 36763 000078A1 D3E8                            SHR     AX,CL
 36764 000078A3 8CDF                            MOV     DI,DS
 36765 000078A5 01C7                            ADD     DI,AX
 36766 000078A7 47                              INC     DI
 36767 000078A8 893E[FC02]                      MOV     [CurrentPDB],DI
 36768 000078AC 55                              PUSH    BP ; ## ; = cs
 36769 000078AD 52                              PUSH    DX ; #	; *cmc*	; Save COMMAND address
 36770 000078AE A1[1003]                        MOV     AX,[ENDMEM]
 36771 000078B1 89FA                            MOV     DX,DI
 36772                                  
 36773                                          ;invoke	SETMEM		; Basic Header
 36774 000078B3 E8B9A6                  	CALL	SETMEM
 36775 000078B6 0E                              PUSH	CS
 36776 000078B7 1F                              POP	DS
 36777                                  	;mov	di,24
 36778 000078B8 BF1800                          MOV     DI,PDB.JFN_TABLE
 36779 000078BB 31C0                            XOR     AX,AX
 36780 000078BD AB                              STOSW
 36781 000078BE AA                              STOSB                   ; 0,1 and 2 are CON device
 36782 000078BF B0FF                            MOV     AL,0FFH
 36783                                  	;mov	cx,17
 36784                                          ;MOV	CX,FILPERPROC-3 ; 17
 36785 000078C1 B111                    	mov	cl,FILPERPROC-3 ; 06/07/2019
 36786 000078C3 F3AA                            REP     STOSB           ; Rest are unused
 36787 000078C5 0E                              PUSH	CS
 36788 000078C6 07                              POP	ES
 36789 000078C7 8C1E[2C00]                      MOV     [SFT_ADDR+2],DS	; Must be set to print messages
 36790                                  
 36791                                  	; 15/07/2018 - Retro DOS v3.0
 36792                                  	; MSDOS 3.3
 36793                                  	; (set country cdpg table segments)
 36794 000078CB BE[3B10]                	mov	si,COUNTRY_CDPG ; country_tab
 36795                                  	;mov	[es:si+79],es	; Ucase table segment
 36796                                  	;mov	[es:si+84],es	; File ucase table segment
 36797                                  	;mov	[es:si+89],es	; File char list segment
 36798                                  	;mov	[es:si+94],es	; Collate table segment
 36799                                  	;mov	[es:si+123],es	; Monocase routine segment
 36800 000078CE 8C444F                  	mov	[si+79],es
 36801 000078D1 8C4454                  	mov	[si+84],es
 36802 000078D4 8C4459                  	mov	[Si+89],es
 36803 000078D7 8C445E                  	mov	[si+94],es
 36804 000078DA 8C447B                  	mov	[si+123],es
 36805                                  	; (set SysInitTable -sysinitvars and country_cdpg- segments)
 36806 000078DD BE[6B0F]                	mov     si,SysInitTable
 36807                                  	;;mov	[es:si+6], es
 36808                                  	;;mov	[es:si+2], es
 36809                                  	;mov	[es:si+SYSI_EXT.Country_Tab+2],es
 36810                                  	;mov	[es:si+SYSI_EXT.SysInitVars+2],es
 36811 000078E0 8C4406                  	mov	[si+SYSI_EXT.Country_Tab+2],es
 36812 000078E3 8C4402                  	mov	[si+SYSI_EXT.SysInitVars+2],es
 36813                                  
 36814                                  	; (set FastOpen table FastRet segment)
 36815 000078E6 BE[730F]                	mov     si,FastTable
 36816                                  	;mov	[es:si+4],es
 36817                                  	;;mov	[es:si+8],es
 36818 000078E9 8C4404                  	mov     [si+4],es
 36819                                  	;mov	[si+8],es
 36820                                  
 36821                                  	; 24/07/2019 - Retro DOS v3.2
 36822                                  
 36823                                  	; IBMDOS.COM (Offset 7259h), IBM PC DOS 3.30
 36824                                  	;mov	word [FETCHI_TAG],5872h ; ? ('Xr')
 36825                                  
 36826                                  	; 10/08/2018 - Retro DOS v3.0
 36827                                  
 36828                                  	; MSDOS 2.11 (Retro DOS v2.0), MSDOS 3.3
 36829                                  
 36830                                  ; After this points the char device functions for CON will work for
 36831                                  ; printing messages
 36832                                  
 36833                                  	;;IF	NOT IBM
 36834                                  	;;IF	NOT ALTVECT
 36835                                  	;MOV	SI,HEADER
 36836                                  	;;invoke OUTMES
 36837                                  	;CALL	OUTMES
 36838                                  	;;PUSH	CS		; Outmes stomps on segments
 36839                                  	;;POP	DS
 36840                                  	;;PUSH	CS
 36841                                  	;;POP	ES
 36842                                  	;;ENDIF
 36843                                  	;;ENDIF
 36844                                  
 36845                                  ; Move the FATs into position
 36846 000078EC 5A                              POP     DX ; #	; *cmc*		; Restore COMMAND address
 36847 000078ED 5D                              POP     BP ; ## ; = cs
 36848 000078EE 59                              POP     CX ; ### ; *fmem*	; True address of free memory
 36849 000078EF BE[BA79]                        MOV     SI,MEMSTRT		; Place to move DPBs from
 36850 000078F2 8B3E[2600]                      MOV     DI,[DPBHEAD]		; Place to move DPBs to
 36851 000078F6 29F9                            SUB     CX,DI                   ; Total length of DPBs
 36852 000078F8 39F7                            CMP     DI,SI
 36853 000078FA 7607                            JBE     SHORT MOVJMP		; Are we moving to higher or 
 36854                                  					; lower memory?
 36855 000078FC 49                              DEC     CX                      ; Move backwards to higher memory
 36856 000078FD 01CF                            ADD     DI,CX
 36857 000078FF 01CE                            ADD     SI,CX
 36858 00007901 41                              INC     CX
 36859 00007902 FD                              STD
 36860                                  MOVJMP:
 36861 00007903 8EC5                            MOV	ES,BP
 36862 00007905 E9868B                          JMP	MOVDPB
 36863                                  
 36864                                  CHARINIT:
 36865                                  	; 07/07/2018 - Retro DOS v3.0
 36866 00007908 36C606[2403]1A                  MOV	BYTE [SS:DEVCALL_REQLEN],DINITHL
 36867 0000790E 36C606[2503]00                  MOV	BYTE [SS:DEVCALL_REQUNIT],0
 36868 00007914 36C606[2603]00                  MOV	BYTE [SS:DEVCALL_REQFUNC],DEVINIT
 36869 0000791A 36C706[2703]0000                MOV	WORD [SS:DEVCALL_REQSTAT],0
 36870 00007921 06                              PUSH	ES
 36871 00007922 53                              PUSH	BX
 36872 00007923 50                              PUSH	AX
 36873 00007924 BB[2403]                        MOV	BX,DEVCALL
 36874 00007927 0E                              PUSH	CS
 36875 00007928 07                              POP	ES
 36876 00007929 E806D8                          CALL	DEVIOCALL2	
 36877 0000792C 58                      	POP	AX
 36878 0000792D 5B                              POP	BX
 36879 0000792E 07                              POP	ES
 36880 0000792F C3                              RETN
 36881                                  
 36882                                  align 2
 36883                                          ;;DB	80H DUP(?)
 36884                                  	;TIMES 	64 dw 0 ; 05/09/2018
 36885                                  	; 10/08/2018
 36886                                  	;times	128 dw 0
 36887                                  	; 12/08/2018
 36888                                  	;times	132 dW 0 ; ADJFAC = 918 ; 08/09/2018 (OK.)
 36889                                  	; 08/09/2018 
 36890 00007930 00<rep 88h>             	times	136 db 0 ; ADJFAC = 790	; 08/09/2018 (OK.)
 36891                                  
 36892                                  			 ; ADJFAC = 770 ; 06/07/2019
 36893                                  
 36894                                  	; 06/07/2019 - Retro DOS v3.1
 36895                                  	;times	148 db 0 ; ADJFAC = 918
 36896                                  
 36897                                  INITSTACK:	; INITSTACK LABEL BYTE
 36898 000079B8 0000                    	DW	0 ; DW ?
 36899                                  
 36900                                  ;MEMSTRT LABEL	WORD
 36901                                  MEMSTRT EQU	$
 36902                                  
 36903                                  ADJFAC  EQU     MEMSTRT-SYSBUF
 36904                                  
 36905                                  	; 01/08/2019
 36906                                  
 36907                                  	;db 0,0,0,0,0,0,0,0,0,0
 36908                                  
 36909 000079BA 18                      	db 24
 36910 000079BB 07                      	db 7
 36911 000079BC E307                    	dw 2019
 36912 000079BE 0000                    	dw 0	
 36913                                  
 36914                                  PcDosVersion:
 36915 000079C0 1A4040402323232050-     	db 1Ah,'@@@### PC-DOS Version 3.30',0Dh,0Ah
 36915 000079C9 432D444F5320566572-
 36915 000079D2 73696F6E20332E3330-
 36915 000079DB 0D0A               
 36916 000079DD 1A00                    	db 1Ah,0
 36917                                  
 36918                                          ;do_ext
 36919                                  ;LAST	ENDS
