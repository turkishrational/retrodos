     1                                  ; ****************************************************************************
     2                                  ; SYSINIT.BIN (MSDOS 3.3 Kernel) - RETRO DOS v3.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 15/09/2022 (Previous: 03/08/2019)
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 24/02/2018 (Retro DOS 2.0), 03/06/2018 (Retro DOS 3.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm sysinit.s -l sysinit.lst -o SYSINIT.BIN)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'SYSINIT1.ASM' and 'SYSINIT2.ASM' files of MSDOS 3.3
    13                                  ; source code by Microsoft, 24/07/1987
    14                                  ; ----------------------------------------------------------------------------
    15                                  ; Derived from 'SYSINIT.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
    16                                  ; by Microsoft, 12/10/1983
    17                                  ; ****************************************************************************
    18                                  ; main file: 'retrodos.s'
    19                                  ; incbin 'SYSINIT.BIN' ; (SYINITSEG)
    20                                  
    21                                  ;--------------------------------------------------------------
    22                                  ; SYSINIT.TXT (27/01/1983)
    23                                  ;--------------------------------------------------------------
    24                                  ;    SYSINIT is  a module linked behind the OEM bios.  It takes
    25                                  ;over  the  system  initialization  after  the  OEM  bios   has
    26                                  ;performed any  initialization  it  needs  to  do.   Control is
    27                                  ;transfered with a long jump to the external  variable  SYSINIT
    28                                  ;
    29                                  ;
    30                                  ;   The OEM  has  the  following  variables declared external:
    31                                  ;
    32                                  ;   CURRENT_DOS_LOCATION    WORD
    33                                  ;
    34                                  ;This word  contains  the  segment  number of the DOS before it
    35                                  ;is relocated.  The OEM bios must set this value.
    36                                  ;
    37                                  ;   FINAL_DOS_LOCATION      WORD
    38                                  ;
    39                                  ;This word contains the segment number of the DOS after SYSINIT
    40                                  ;moves it.  The OEM bios must set this value.
    41                                  ;
    42                                  ;   DEVICE_LIST             DWORD
    43                                  ;
    44                                  ;This  double  word  pointer  points  to  the  linked  list  of
    45                                  ;character and block device drivers.  The  OEM  must  set  this
    46                                  ;value.
    47                                  ;
    48                                  ;   MEMORY_SIZE             WORD
    49                                  ;
    50                                  ;This word  contains  the  number  of  RAM  paragraphs.  If the
    51                                  ;bios doesn't set  this  variable  SYSINIT  will  automatically
    52                                  ;calculate it.   NOTE:  systems with PARITY checked memory must
    53                                  ;size memory in the BIOS.  SYSINITs method is to  write  memory
    54                                  ;and read it back until it gets a mismatch.
    55                                  ;
    56                                  ;   DEFAULT_DRIVE           BYTE
    57                                  ;
    58                                  ;This is  the initial default drive when the system first comes
    59                                  ;up.  drive a=0, drive b=1,  etc.   If  the  bios  doesn't  set
    60                                  ;it then drive a is assumed.
    61                                  ;
    62                                  ;   BUFFERS                 BYTE
    63                                  ;
    64                                  ;This is  the  default  number of buffers for the system.  This
    65                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    66                                  ;It is DBed to 2 in SYSINIT it should be greater than 1.
    67                                  ;
    68                                  ;   FILES                   BYTE
    69                                  ;
    70                                  ;This is  the  default  number  of  files for the system.  This
    71                                  ;value may be overridden by the user in  the  CONFIG.SYS  file.
    72                                  ;It is  DBed  to  8 in SYSINIT, values less than 5 are ignored.
    73                                  ;
    74                                  ;   SYSINIT                 FAR
    75                                  ;
    76                                  ;The entry  point  of  the  SYSINIT  module.  OEM BIOS jumps to
    77                                  ;this label at the end of its INIT code.
    78                                  ;
    79                                  ;   The OEM  has  the  following  variables declared public:
    80                                  ;
    81                                  ;   RE_INIT                 FAR
    82                                  ;
    83                                  ;This is an entry point which allows the BIOS to do some INIT
    84                                  ;work  after  the  DOS is initialized.  ALL REGISTERS MUST BE
    85                                  ;PRESERVED.  On entry DS points to the first available memory
    86                                  ;(after  the DOS).  DS:0 points to a 100H byte program header
    87                                  ;prefix which represents  the  "program"  currently  running.
    88                                  ;This  program  should  be  thought  of  as  the OEM BIOS and
    89                                  ;SYSINIT taken together.  This is not  a  normal  program  in
    90                                  ;that  no  memory  is  allocated to it, it is running in free
    91                                  ;memory.
    92                                  ;NOTES:
    93                                  ;     At the time this routine is called SYSINIT occupies the
    94                                  ;highest 10K of memory ("highest" is determined by the  value
    95                                  ;of the MEMORY_SIZE variable), DO NOT DO WRITES THERE.
    96                                  ;     Since this is called AFTER DOS is initialized, you can
    97                                  ;make system calls.  This also implies that the code for this
    98                                  ;routine    CANNOT   be   thrown   away   by   use   of   the
    99                                  ;FINAL_DOS_LOCATION since the DOS has already been moved.
   100                                  ;     If you don't want  anything done just set this to point
   101                                  ;at a FAR RET instruction.
   102                                  
   103                                  ; ----------------------------------------------------------------------------
   104                                  ; TITLE   BIOS SYSTEM INITIALIZATION
   105                                  ; ----------------------------------------------------------------------------
   106                                  
   107                                  FALSE   EQU     0
   108                                  TRUE    EQU     0FFFFh
   109                                  
   110                                  ;IBMVER     EQU     TRUE
   111                                  ;IBM        EQU     IBMVER
   112                                  ;STACKSW    EQU	    TRUE		;Include Switchable Hardware Stacks
   113                                  ;IBMJAPVER  EQU     FALSE		; If TRUE set KANJI true also
   114                                  ;MSVER      EQU     FALSE
   115                                  ;ALTVECT    EQU     FALSE		; Switch to build ALTVECT version
   116                                  ;KANJI      EQU     FALSE
   117                                  
   118                                  ;include version.inc
   119                                  
   120                                  ;	IF	IBMJAPVER
   121                                  ;NOEXEC	EQU	TRUE
   122                                  ;       ELSE
   123                                  ;NOEXEC	EQU	FALSE
   124                                  ;       ENDIF
   125                                  
   126                                  MAJOR_VERSION   EQU     3
   127                                  MINOR_VERSION   EQU     30	;3.30
   128                                  
   129                                  ;DOSSIZE EQU	0A000H
   130                                  
   131                                  ;; (MSDOS 2.0) SYSINITVAR table offsets
   132                                  ;; ----------------------------------------------------------------------
   133                                  
   134                                  ;DPBHEAD  EQU	0  ; dd ; Pointer to head of DPB-FAT list	
   135                                  ;SFT_ADDR EQU	4  ; dd ; Pointer to first FCB table
   136                                  ;BCLOCK	  EQU	8  ; dd ; Pointer to the CLOCK device	
   137                                  ;BCON	  EQU	12 ; dd ; Console device entry points
   138                                  ;NUMIO	  EQU	16 ; db ; Number of disk tables
   139                                  ;MAXSEC   EQU	17 ; dw ; Maximum allowed sector size
   140                                  ;BUFFHEAD EQU	19 ; dd	; Pointer to head of buffer queue
   141                                  ;DEVHEAD  EQU	23 ; dd ; Set to list start passed by BIOS at DOS Init
   142                                  ;NUL_DEV  EQU	23 ; dd	; NUL device header, first 4 bytes of dev header
   143                                  ;			; (4+14 bytes)
   144                                  ;			; Points to the next device in device chain 
   145                                  ;DEVTYPE  EQU   27 ; dw ; = ISNULL
   146                                  ;SNULDEV  EQU 	29 ; dw
   147                                  ;INULDEV  EQU	31 ; dw
   148                                  ;DEVNAME  EQU	33 ; 8 BYTES ; "NUL     "
   149                                  
   150                                  ;; ----------------------------------------------------------------------
   151                                  ;; Internal DOS data returned by DOSINIT
   152                                  ;;
   153                                  ;struc	SYSINITVAR
   154                                  ;.DPBHEAD:	resd 1			; Pointer to head of DPB-FAT list
   155                                  ;.SFT_ADDR:	resd 1			; Pointer to first FCB table
   156                                  ;; The following address points to the CLOCK device
   157                                  ;.BCLOCK:	resd 1
   158                                  ;; The following address is used by DISKSTATCHK it is always
   159                                  ;; points to the console input device header
   160                                  ;.BCON:		resd 1			; Console device entry points
   161                                  ;.NUMIO:	resb 1			; Number of disk tables
   162                                  ;.MAXSEC:	resw 1			; Maximum allowed sector size
   163                                  ;.BUFFHEAD:	resd 1			; Head of buffer queue
   164                                  ;.DEVHEAD:	resd 1			; NUL dev head points to next dev
   165                                  ;.size:
   166                                  ;endstruc
   167                                  
   168                                  ; ----------------------------------------------------------------------
   169                                  ; device definitions
   170                                  
   171                                  ;Attribute bit masks
   172                                  DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
   173                                  DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
   174                                  ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
   175                                  ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
   176                                  ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
   177                                  ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
   178                                  ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
   179                                  ISIBM   EQU     0010H           ;Bit 4 - This device is special
   180                                  
   181                                  ; The device table list has the form:
   182                                  struc	SYSDEV
   183 00000000 ????????                .NEXT:		resd 1		;Pointer to next device header
   184 00000004 ????                    .ATT:		resw 1		;Attributes of the device
   185 00000006 ????                    .STRAT:		resw 1		;Strategy entry point
   186 00000008 ????                    .INT:		resw 1		;Interrupt entry point
   187 0000000A ????????????????        .NAME:		resb 8		;Name of device (only first byte used for block)
   188                                  .size:
   189                                  endstruc
   190                                  
   191                                  ;Static Reguest Header
   192                                  struc	SRHEAD
   193 00000000 ??                      .REQLEN:	resb 1		;Length in bytes of request block
   194 00000001 ??                      .REQUNIT:	resb 1		;Device unit number
   195 00000002 ??                      .REQFUNC:	resb 1		;Type of request
   196 00000003 ????                    .REQSTAT:	resw 1		;Status Word
   197 00000005 ????????????????                	resb 8		;Reserved for queue links
   198                                  .size:
   199                                  endstruc
   200                                  
   201                                  ;Status word masks
   202                                  STERR   EQU     8000H           ;Bit 15 - Error
   203                                  STBUI   EQU     0200H           ;Bit 9 - Buisy
   204                                  STDON   EQU     0100H           ;Bit 8 - Done
   205                                  STECODE EQU     00FFH           ;Error code
   206                                  WRECODE EQU     0
   207                                  
   208                                  ;Function codes
   209                                  DEVINIT EQU     0               ;Initialization
   210                                  DINITHL EQU     26              ;Size of init header
   211                                  DEVMDCH EQU     1               ;Media check
   212                                  DMEDHL  EQU     15              ;Size of media check header
   213                                  DEVBPB  EQU     2               ;Get BPB
   214                                  DEVRDIOCTL EQU  3               ;IOCTL read
   215                                  DBPBHL  EQU     22              ;Size of Get BPB header
   216                                  DEVRD   EQU     4               ;Read
   217                                  DRDWRHL EQU     22              ;Size of RD/WR header
   218                                  DEVRDND EQU     5               ;Non destructive read no wait (character devs)
   219                                  DRDNDHL EQU     14              ;Size of non destructive read header
   220                                  DEVIST  EQU     6               ;Input status
   221                                  DSTATHL EQU     13              ;Size of status header
   222                                  DEVIFL  EQU     7               ;Input flush
   223                                  DFLSHL  EQU     15              ;Size of flush header
   224                                  DEVWRT  EQU     8               ;Write
   225                                  DEVWRTV EQU     9               ;Write with verify
   226                                  DEVOST  EQU     10              ;Output status
   227                                  DEVOFL  EQU     11              ;Output flush
   228                                  DEVWRIOCTL EQU  12              ;IOCTL write
   229                                  
   230                                  ; ----------------------------------------------------------------------
   231                                  struc	SYS_FCB
   232 00000000 ??                      .fcb_drive:	resb 1
   233 00000001 ????????????????        .fcb_name:	resb 8
   234 00000009 ??????                  .fcb_ext:	resb 3
   235 0000000C ????                    .fcb_EXTENT:	resw 1
   236 0000000E ????                    .fcb_RECSIZ:	resw 1	; Size of record (user settable)
   237 00000010 ????                    .fcb_FILSIZ:	resw 1	; Size of file in bytes; used with the following
   238                                                          ; word
   239 00000012 ????                    .fcb_DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
   240 00000014 ????                    .fcb_FDATE:	resw 1	; Date of last writing
   241 00000016 ????                    .fcb_FTIME:	resw 1	; Time of last writing
   242 00000018 ??                      .fcb_DEVID:	resb 1	; Device ID number, bits 0-5 if file.
   243                                                          ; bit 7=0 for file, bit 7=1 for I/O device
   244                                                          ; If file, bit 6=0 if dirty
   245                                                          ; If I/O device, bit 6=0 if EOF (input)
   246                                                          ;               Bit 5=1 if Raw mode
   247                                                          ;               Bit 0=1 if console input device
   248                                                          ;               Bit 1=1 if console output device
   249                                                          ;               Bit 2=1 if null device
   250                                                          ;               Bit 3=1 if clock device
   251 00000019 ????                    .fcb_FIRCLUS:	resw 1	; First cluster of file
   252 0000001B ????                    .fcb_CLUSPOS:	resw 1	; Position of last cluster accessed
   253 0000001D ????                    .fcb_LSTCLUS:	resw 1	; Last cluster accessed and directory
   254 0000001F ??                                   	resb 1	; pack 2 12 bit numbers into 24 bits...
   255 00000020 ??                      .fcb_NR:	resb 1	; Next record
   256 00000021 ????????                .fcb_RR:	resb 4	; Random record
   257                                  .size:
   258                                  endstruc
   259                                  
   260                                  ; ----------------------------------------------------------------------
   261                                  ; Field definition for I/O buffer information
   262                                  
   263                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, BUFFER.INC, 24/07/1987)
   264                                  
   265                                  struc	BUFFINFO
   266 00000000 ????????                .buf_link:	resd 1	; Pointer to next buffer in list
   267 00000004 ??                      .buf_ID:	resb 1	; Drive of buffer (bit 7 = 0)
   268                                  			; SFT table index (bit 7 = 1)
   269                                  			; = FFH if buffer free
   270 00000005 ??                      .buf_flags:	resb 1	; Bit 7 = 1 if Remote file buffer
   271                                  			;	= 0 if Local device buffer
   272                                  			; Bit 6 = 1 if buffer dirty
   273                                  			; Bit 5 = Reserved
   274                                  			; Bit 4 = Search bit (bit 7 = 1)
   275                                  			; Bit 3 = 1 if buffer is DATA
   276                                  			; Bit 2 = 1 if buffer is DIR
   277                                  			; Bit 1 = 1 if buffer is FAT
   278                                  			; Bit 0 = Reserved
   279 00000006 ????                    .buf_sector:	resw 1	; Sector number of buffer (bit 7 = 0)
   280                                  ; The next two items are often refed as a word (bit 7 = 0)
   281 00000008 ??                      .buf_wrtcnt:	resb 1	; For FAT sectors, # times sector written out
   282 00000009 ??                      .buf_wrtcntinc:	resb 1	; "   "     "   , # sectors between each write
   283 0000000A ????????                .buf_DPB :	resd 1	; Pointer to drive parameters
   284 0000000E ????                    .buf_fill:	resw 1	; How full buffer is (bit 7 = 1)
   285                                  .size:
   286                                  endstruc
   287                                  
   288                                  %define buf_offset	dword [buf_sector]
   289                                  			;For bit 7 = 1, this is the byte
   290                                  			;offset of the start of the buffer in
   291                                  			;the file pointed to by buf_ID.  Thus
   292                                  			;the buffer starts at location
   293                                  			;buf_offset in the file and contains
   294                                  			;buf_fill bytes.
   295                                  
   296                                  BUFINSIZ        EQU     BUFFINFO.size ; ; Size of structure in bytes
   297                                  
   298                                  
   299                                  buf_Free	EQU	0FFh		; buf_id of free buffer
   300                                  
   301                                  ;Flag byte masks
   302                                  buf_isnet	EQU	10000000B
   303                                  buf_dirty	EQU	01000000B
   304                                  ;***
   305                                  buf_visit	EQU	00100000B
   306                                  ;***
   307                                  buf_snbuf	EQU	00010000B
   308                                  
   309                                  buf_isDATA	EQU	00001000B
   310                                  buf_isDIR	EQU	00000100B
   311                                  buf_isFAT	EQU	00000010B
   312                                  buf_type_0	EQU	11110001B	; AND sets type to "none"
   313                                  
   314                                  buf_NetID	EQU	BUFINSIZ
   315                                  
   316                                  
   317                                  ; ----------------------------------------------------------------------
   318                                  ; DPB structure
   319                                  
   320                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3, DPB.INC, 24/07/1987)
   321                                  
   322                                  struc	DPB
   323 00000000 ??                      .DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
   324 00000001 ??                      .UNIT:		resb 1		; Driver unit number of DPB
   325 00000002 ????                    .SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
   326 00000004 ??                      .CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
   327 00000005 ??                      .CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
   328 00000006 ????                    .FIRST_FAT:	resw 1		; Starting record of FATs
   329 00000008 ??                      .FAT_COUNT:	resb 1		; Number of FATs for this drive
   330 00000009 ????                    .ROOT_ENTRIES:	resw 1		; Number of directory entries
   331 0000000B ????                    .FIRST_SECTOR:	resw 1		; First sector of first cluster
   332 0000000D ????                    .MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
   333 0000000F ??                      .FAT_SIZE:	resb 1		; Number of records occupied by FAT
   334 00000010 ????                    .DIR_SECTOR:	resw 1		; Starting record of directory
   335 00000012 ????????                .DRIVER_ADDR:	resd 1		; Pointer to driver
   336 00000016 ??                      .MEDIA:		resb 1		; Media byte
   337 00000017 ??                      .FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
   338                                  				; check the first time this DPB is used
   339 00000018 ????????                .NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
   340 0000001C ????                    .NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
   341 0000001E ????                    .FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
   342                                  .size:
   343                                  endstruc
   344                                  
   345                                  DPBSIZ  EQU     DPB.size	; Size of the structure in bytes
   346                                  
   347                                  DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)
   348                                  
   349                                  ; ----------------------------------------------------------------------
   350                                  ; 26/03/2018
   351                                  
   352                                  ; IOCTL SUB-FUNCTIONS
   353                                  IOCTL_GET_DEVICE_INFO	EQU	0
   354                                  IOCTL_SET_DEVICE_INFO	EQU	1
   355                                  IOCTL_READ_HANDLE	EQU	2
   356                                  IOCTL_WRITE_HANDLE	EQU	3
   357                                  IOCTL_READ_DRIVE	EQU	4
   358                                  IOCTL_WRITE_DRIVE	EQU	5
   359                                  IOCTL_GET_INPUT_STATUS	EQU	6
   360                                  IOCTL_GET_OUTPUT_STATUS EQU	7
   361                                  IOCTL_CHANGEABLE?	EQU	8
   362                                  IOCTL_SHARING_RETRY	EQU	11
   363                                  GENERIC_IOCTL_HANDLE	EQU	12
   364                                  GENERIC_IOCTL		EQU	13
   365                                  
   366                                  ; GENERIC IOCTL SUB-FUNCTIONS
   367                                  RAWIO			EQU	8
   368                                  
   369                                  ; RAWIO SUB-FUNCTIONS
   370                                  GET_DEVICE_PARAMETERS	EQU	60H
   371                                  SET_DEVICE_PARAMETERS	EQU	40H
   372                                  READ_TRACK		EQU	61H
   373                                  WRITE_TRACK		EQU	41H
   374                                  VERIFY_TRACK		EQU	62H
   375                                  FORMAT_TRACK		EQU	42H
   376                                  
   377                                  ; DEVICETYPE VALUES
   378                                  MAX_SECTORS_IN_TRACK	EQU	63
   379                                  DEV_5INCH		EQU	0
   380                                  DEV_5INCH96TPI		EQU	1
   381                                  DEV_3INCH720KB		EQU	2
   382                                  DEV_8INCHSS		EQU	3
   383                                  DEV_8INCHDS		EQU	4
   384                                  DEV_HARDDISK		EQU	5
   385                                  DEV_OTHER		EQU	7
   386                                  ;DEV_3INCH1440KB	EQU	7
   387                                  DEV_3INCH2880KB		EQU	9
   388                                  ; Retro DOS v2.0 - 26/03/2018
   389                                  ;;DEV_TAPE		EQU	6
   390                                  ;;DEV_ERIMO		EQU	8
   391                                  ;DEV_3INCH2880KB	EQU	9
   392                                  DEV_3INCH1440KB		EQU	10
   393                                  
   394                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
   395                                  					; CURRENTLY SUPPORT.
   396                                  MAX_DEV_TYPE		EQU	10
   397                                  
   398                                  struc A_SECTORTABLE
   399 00000000 ????                    .ST_SECTORNUMBER:	resw	1
   400 00000002 ????                    .ST_SECTORSIZE:		resw	1
   401                                  .size:
   402                                  endstruc
   403                                  
   404                                  struc A_BPB
   405 00000000 ????                    .BPB_BYTESPERSECTOR:	resw	1
   406 00000002 ??                      .BPB_SECTORSPERCLUSTER:	resb	1
   407 00000003 ????                    .BPB_RESERVEDSECTORS:	resw	1
   408 00000005 ??                      .BPB_NUMBEROFFATS:	resb	1
   409 00000006 ????                    .BPB_ROOTENTRIES: 	resw	1
   410 00000008 ????                    .BPB_TOTALSECTORS:	resw	1
   411 0000000A ??                      .BPB_MEDIADESCRIPTOR:	resb	1
   412 0000000B ????                    .BPB_SECTORSPERFAT:	resw	1
   413 0000000D ????                    .BPB_SECTORSPERTRACK:	resw	1
   414 0000000F ????                    .BPB_HEADS:		resw	1
   415 00000011 ????                    .BPB_HIDDENSECTORS:	resw	1
   416 00000013 ????                    			resw	1
   417 00000015 ????                    .BPB_BIGTOTALSECTORS:	resw	1
   418 00000017 ????                    			resw	1
   419 00000019 ????????????            			resb	6	; NOTE:  many times these
   420                                  ;					; 	 6 bytes are omitted
   421                                  ;					;	 when BPB manipulations
   422                                  ;					;	 are performed!
   423                                  .size:
   424                                  endstruc
   425                                  
   426                                  struc A_DEVICEPARAMETERS
   427 00000000 ??                      .DP_SPECIALFUNCTIONS:	resb	1
   428 00000001 ??                      .DP_DEVICETYPE:		resb	1
   429 00000002 ????                    .DP_DEVICEATTRIBUTES:	resw	1
   430 00000004 ????                    .DP_CYLINDERS:		resw	1
   431 00000006 ??                      .DP_MEDIATYPE:		resb	1
   432 00000007 <res 1Fh>               .DP_BPB:		resb	A_BPB.size
   433 00000026 ????                    .DP_TRACKTABLEENTRIES:	resw	1
   434 00000028 <res FCh>               .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
   435                                  endstruc
   436                                  
   437                                  ; ----------------------------------------------------------------------
   438                                  ; Memory arena structure
   439                                  struc ARENA
   440 00000000 ??                      .SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
   441 00000001 ????                    .OWNER:		resw 1		; owner of arena item
   442 00000003 ????                    .SIZE:		resw 1		; size in paragraphs of item
   443                                  endstruc
   444                                  
   445                                  ; ----------------------------------------------------------------------
   446                                  ;
   447                                  ; Process data block (otherwise known as program header)
   448                                  ;
   449                                  
   450                                  FILPERPROC	EQU     20
   451                                  
   452                                  struc PDB	; Process_data_block
   453 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   454 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   455 00000004 ??                                      resb 1
   456 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   457 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   458 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   459 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   460 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   461 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   462 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   463 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   464 00000032 ????                    .JFN_LENGTH:	resw 1 ; 25/03/18 ; number of handles allowed
   465 00000034 ????????                .JFN_POINTER:	resd 1 ; 25/03/18 ; pointer to JFN table
   466 00000038 ????????                .NEXT_PDB:	resd 1 ; 25/03/18 ; pointer to nested PDB's
   467 0000003C <res 14h>               .PAD1:		resb 20 ; 25/03/2018
   468 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   469 00000055 ??????????????          .PAD2:		resb 7 ; 25/03/2018
   470                                  endstruc
   471                                  
   472                                  ; ----------------------------------------------------------------------
   473                                  ; <system call definitions>
   474                                  
   475                                  ABORT                           EQU 0   ;  0      0
   476                                  STD_CON_INPUT                   EQU 1   ;  1      1
   477                                  STD_CON_OUTPUT                  EQU 2   ;  2      2
   478                                  STD_AUX_INPUT                   EQU 3   ;  3      3
   479                                  STD_AUX_OUTPUT                  EQU 4   ;  4      4
   480                                  STD_PRINTER_OUTPUT              EQU 5   ;  5      5
   481                                  RAW_CON_IO                      EQU 6   ;  6      6
   482                                  RAW_CON_INPUT                   EQU 7   ;  7      7
   483                                  STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
   484                                  STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
   485                                  STD_CON_STRING_INPUT            EQU 10  ; 10      A
   486                                  STD_CON_INPUT_STATUS            EQU 11  ; 11      B
   487                                  STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
   488                                  DISK_RESET                      EQU 13  ; 13      D
   489                                  SET_DEFAULT_DRIVE               EQU 14  ; 14      E
   490                                  FCB_OPEN                        EQU 15  ; 15      F
   491                                  FCB_CLOSE                       EQU 16  ; 16     10
   492                                  DIR_SEARCH_FIRST                EQU 17  ; 17     11
   493                                  DIR_SEARCH_NEXT                 EQU 18  ; 18     12
   494                                  FCB_DELETE                      EQU 19  ; 19     13
   495                                  FCB_SEQ_READ                    EQU 20  ; 20     14
   496                                  FCB_SEQ_WRITE                   EQU 21  ; 21     15
   497                                  FCB_CREATE                      EQU 22  ; 22     16
   498                                  FCB_RENAME                      EQU 23  ; 23     17
   499                                  GET_DEFAULT_DRIVE               EQU 25  ; 25     19
   500                                  SET_DMA                         EQU 26  ; 26     1A
   501                                  GET_DEFAULT_DPB                 EQU 31  ; 31     1F
   502                                  FCB_RANDOM_READ                 EQU 33  ; 33     21
   503                                  FCB_RANDOM_WRITE                EQU 34  ; 34     22
   504                                  GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
   505                                  GET_FCB_POSITION                EQU 36  ; 36     24
   506                                  SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
   507                                  CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
   508                                  FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
   509                                  FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
   510                                  PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
   511                                  GET_DATE                        EQU 42  ; 42     2A
   512                                  SET_DATE                        EQU 43  ; 43     2B
   513                                  GET_TIME                        EQU 44  ; 44     2C
   514                                  SET_TIME                        EQU 45  ; 45     2D
   515                                  SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
   516                                  ; Extended functionality group
   517                                  GET_DMA                         EQU 47  ; 47     2F
   518                                  GET_VERSION                     EQU 48  ; 48     30
   519                                  KEEP_PROCESS                    EQU 49  ; 49     31
   520                                  GET_DPB                         EQU 50  ; 50     32
   521                                  SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
   522                                  GET_INDOS_FLAG                  EQU 52  ; 52     34
   523                                  GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
   524                                  GET_DRIVE_FREESPACE             EQU 54  ; 54     36
   525                                  CHAR_OPER                       EQU 55  ; 55     37
   526                                  INTERNATIONAL                   EQU 56  ; 56     38
   527                                  ; XENIX CALLS
   528                                  ;   Directory Group
   529                                  MKDIR                           EQU 57  ; 57     39
   530                                  RMDIR                           EQU 58  ; 58     3A
   531                                  CHDIR                           EQU 59  ; 59     3B
   532                                  ;   File Group
   533                                  CREAT                           EQU 60  ; 60     3C
   534                                  OPEN                            EQU 61  ; 61     3D
   535                                  CLOSE                           EQU 62  ; 62     3E
   536                                  READ                            EQU 63  ; 63     3F
   537                                  WRITE                           EQU 64  ; 64     40
   538                                  UNLINK                          EQU 65  ; 65     41
   539                                  LSEEK                           EQU 66  ; 66     42
   540                                  CHMOD                           EQU 67  ; 67     43
   541                                  IOCTL                           EQU 68  ; 68     44
   542                                  XDUP                            EQU 69  ; 69     45
   543                                  XDUP2                           EQU 70  ; 70     46
   544                                  CURRENT_DIR                     EQU 71  ; 71     47
   545                                  ;    Memory Group
   546                                  ALLOC                           EQU 72  ; 72     48
   547                                  DEALLOC                         EQU 73  ; 73     49
   548                                  SETBLOCK                        EQU 74  ; 74     4A
   549                                  ;    Process Group
   550                                  EXEC                            EQU 75  ; 75     4B
   551                                  EXIT                            EQU 76  ; 76     4C
   552                                  _WAIT				EQU 77  ; 77     4D
   553                                  FIND_FIRST                      EQU 78  ; 78     4E
   554                                  ;   Special Group
   555                                  FIND_NEXT                       EQU 79  ; 79     4F
   556                                  ; SPECIAL SYSTEM GROUP
   557                                  SET_CURRENT_PDB                 EQU 80  ; 80     50
   558                                  GET_CURRENT_PDB                 EQU 81  ; 81     51
   559                                  GET_IN_VARS                     EQU 82  ; 82     52
   560                                  SETDPB                          EQU 83  ; 83     53
   561                                  GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
   562                                  DUP_PDB                         EQU 85  ; 85     55
   563                                  RENAME                          EQU 86  ; 86     56
   564                                  FILE_TIMES                      EQU 87  ; 87     57
   565                                  
   566                                  ; ----------------------------------------------------------------------
   567                                  ; SYSCONF.ASM (MSDOS 3.3 - 24/07/1987) 	
   568                                  ; ----------------------------------------------------------------------
   569                                  
   570                                  ;;	IF	STACKSW
   571                                  
   572                                  ;;
   573                                  ;; Internal Stack Parameters
   574                                  ;EntrySize		equ	8
   575                                  ;
   576                                  ;MinCount		equ	8
   577                                  ;DefaultCount		equ	9
   578                                  ;MaxCount		equ	64
   579                                  ;
   580                                  ;MinSize 		equ	32
   581                                  ;DefaultSize		equ	128
   582                                  ;MaxSize 		equ	512
   583                                  
   584                                  ;;	ENDIF
   585                                  
   586                                  
   587                                  ; ----------------------------------------------------------------------
   588                                  ; BIOSTRUC.INC (MSDOS 3.3 - 24/07/1987) 	
   589                                  ; ----------------------------------------------------------------------
   590                                  					  ;;Rev 3.30 Modification
   591                                  ; ROM BIOS CALL PACKET STRUCTURES					  
   592                                  									  
   593                                  ;*******************************					  
   594                                  ;System Service call ( Int 15h )					  
   595                                  ;*******************************					  
   596                                  ;Function AH = 0C0h, Return system configuration			  
   597                                  ;For PC and PCJR on return:						  
   598                                  ;	(AH)	= 80h							  
   599                                  ;	(CY)	= 1							  
   600                                  ;For PCXT, PC PORTABLE and PCAT on return:				  
   601                                  ;	(AH)	= 86h							  
   602                                  ;	(CY)	= 1							  
   603                                  ;For all others:							  
   604                                  ;	(AH)	= 0							  
   605                                  ;	(CY)	= 0							  
   606                                  ;	(ES:BX) = pointer to system descriptor vector in ROS		  
   607                                  ; System descriptor :							  
   608                                  ;	DW	xxxx		length of descriptor in bytes,		  
   609                                  ;				minimum length = 8			  
   610                                  ;	DB	xx		model byte				  
   611                                  ;				0FFh	= PC				  
   612                                  ;				0FEh	= PC/XT, Portable		  
   613                                  ;				0FDh	= PC/JR 			  
   614                                  ;				0FCh	= PC/AT				  
   615                                  ;				0F9h	= Convertable			  
   616                                  ;				0F8h	= Model 80			  
   617                                  ;				0E0 thru 0EFh = reserved		  
   618                                  ;									  
   619                                  ;	DB	xx		secondary model byte			  
   620                                  ;				000h	= PC1				  
   621                                  ;				000h	= PC/XT, Portable		  
   622                                  ;				000h	= PC/JR 			  
   623                                  ;				000h	= PC/AT 			  
   624                                  ;				001h	= PC/AT Model 339		  
   625                                  ;				003h	= PC/RT				  
   626                                  ;				000h	= Convertable			  
   627                                  ;									  
   628                                  ;	DB	xx		bios revision level			  
   629                                  ;				00 for first release, subsequent release  
   630                                  ;				of code with same model byte and	  
   631                                  ;				secondary model byte require revison level
   632                                  ;				to increase by one.			  
   633                                  ;									  
   634                                  ;	DB	xx		feature information byte 1		  
   635                                  ;				X0000000 = 1, bios use DMA channel 3	  
   636                                  ;					 = 0, DMA channel 3 not used	  
   637                                  ;									  
   638                                  ;				0X000000 = 1, 2nd Interrupt chip present  
   639                                  ;					 = 0, 2nd Interrupt chip not present
   640                                  ;									  
   641                                  ;				00X00000 = 1, Real Time Clock present	  
   642                                  ;					 = 0, Real Time Clock not present 
   643                                  ;									  
   644                                  ;				000X0000 = 1, Keyboard escape sequence(INT 15h)
   645                                  ;						called in keyboard interrupt
   646                                  ;						(Int 09h).		  
   647                                  ;					 = 0, Keyboard escape sequence not
   648                                  ;						called. 		  
   649                                  ;				0000XXXX reserved			  
   650                                  ;									  
   651                                  ;	DB	xx		feature information byte 2 - reserved	  
   652                                  ;									  
   653                                  ;	DB	xx		feature information byte 2 - reserved	  
   654                                  ;									  
   655                                  ;	DB	xx		feature information byte 2 - reserved	  
   656                                  ;									  
   657                                  ;	DB	xx		feature information byte 2 - reserved	  
   658                                  ;									  
   659                                  									  
   660                                  struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
   661 00000000 ????                    .bios_SD_leng:		resw 1				  
   662 00000002 ??                      .bios_SD_modelbyte:	resb 1					  
   663                                  .bios_SD_scnd_modelbyte: 
   664 00000003 ??                      			resb 1					  
   665 00000004 ??                      			resb 1					  
   666 00000005 ??                      .bios_SD_featurebyte1:	resb 1					  
   667 00000006 ????????                			resb 4					  
   668                                  endstruc					  
   669                                  									  
   670                                  ;FeatureByte1	bit map equates 					  
   671                                  DMAchannel3		equ 10000000b					  
   672                                  ScndIntController	equ 01000000b					  
   673                                  RealTimeClock		equ 00100000b					  
   674                                  KeyEscapeSeq		equ 00010000b					  
   675                                  					;;End of Modification
   676                                  
   677                                  ; ----------------------------------------------------------------------
   678                                  ; SYSVAR.INC (MSDOS 3.3 - 24/07/1987) 	
   679                                  ; ----------------------------------------------------------------------
   680                                  ; 05/06/2018 - Retro DOS v3.0
   681                                  
   682                                  ;	SCCSID = @(#)sysvar.asm 1.1 85/04/10
   683                                  struc SysInitVars
   684 00000000 ????????                .SYSI_DPB:    resd 1			; DPB chain
   685 00000004 ????????                .SYSI_SFT:    resd 1			; SFT chain
   686 00000008 ????????                .SYSI_CLOCK:  resd 1			; CLOCK device
   687 0000000C ????????                .SYSI_CON:    resd 1			; CON device
   688 00000010 ????                    .SYSI_MAXSEC: resw 1			; maximum sector size
   689 00000012 ????????                .SYSI_BUF:    resd 1			; buffer chain
   690 00000016 ????????                .SYSI_CDS:    resd 1			; CDS list
   691 0000001A ????????                .SYSI_FCB:    resd 1			; FCB chain
   692 0000001E ????                    .SYSI_KEEP:   resw 1			; keep count
   693 00000020 ??                      .SYSI_NUMIO:  resb 1			; Number of block devices
   694 00000021 ??                      .SYSI_NCDS:   resb 1			; number of CDS's
   695 00000022 ????????                .SYSI_DEV:    resd 1			; device list
   696                                  .size:
   697                                  endstruc
   698                                  
   699                                  ;This is added for more information exchage between DOS, BIOS.
   700                                  ;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
   701                                  struc SysInitVars_Ext
   702 00000000 ????????                .SYSI_InitVars:	   resd 1	; Points to the above structure.
   703 00000004 ????????                .SYSI_Country_Tab: resd 1	; DOS_Country_cdpg_info
   704                                  endstruc
   705                                  
   706                                  ; 09/06/2018
   707                                  ; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
   708                                  SYSI_DPB    equ	0
   709                                  SYSI_SFT    equ 4
   710                                  SYSI_CLOCK  equ 8
   711                                  SYSI_CON    equ 12
   712                                  SYSI_MAXSEC equ 16
   713                                  SYSI_BUF    equ 18 		
   714                                  SYSI_CDS    equ 22
   715                                  SYSI_FCB    equ 26
   716                                  SYSI_KEEP   equ 30
   717                                  SYSI_NUMIO  equ	32
   718                                  SYSI_NCDS   equ	33
   719                                  SYSI_DEV    equ 34
   720                                  
   721                                  ; ----------------------------------------------------------------------
   722                                  ; CURDIR.INC (MSDOS 3.3 - 24/07/1987) 	
   723                                  ; ----------------------------------------------------------------------
   724                                  ; 08/06/2018 - Retro DOS v3.0
   725                                  
   726                                  ;	SCCSID = @(#)curdir.asm	1.1 85/04/10
   727                                  ;BREAK <Current directory list structure>
   728                                  									  
   729                                  ; CDS items are used by the internal routines to store cluster numbers and
   730                                  ; network identifiers for each logical name.  The ID field is used dually,
   731                                  ; both as net ID and for a cluster number for local devices.  In the case
   732                                  ; of local devices, the cluster number will be -1 if there is a potential
   733                                  ; of the disk being changed or if the path must be recracked.  The END
   734                                  ; field is the location of the end of the definition.  No .. is allowed
   735                                  ; past this point							
   736                                  
   737                                  DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
   738                                  TEMPLEN 	EQU	DIRSTRLEN*2
   739                                  
   740                                  struc 		curdir_list
   741 00000000 <res 43h>               .cdir_text	resb	DIRSTRLEN	; text of assignment and curdir
   742 00000043 ????                    .cdir_flags	resw	1		; various flags
   743 00000045 ????????                .cdir_devptr	resd	1		; local pointer to DPB or net device
   744 00000049 ????                    .cdir_ID	resw	1		; cluster of current dir (net ID)
   745 0000004B ????                    		resw	1
   746 0000004D ????                    .cdir_usr_word	resw	1
   747 0000004F ????                    .cdir_end	resw	1		; end of assignment
   748                                  .size:
   749                                  endstruc
   750                                  
   751                                  curdirLen	EQU	curdir_list.size	; Needed for screwed up
   752                                  						; ASM87 which doesn't allow
   753                                  						; Size directive as a macro
   754                                  						; argument
   755                                  %define curdir_netID	dword [curdir_list.cdir_ID]
   756                                  
   757                                  ;Flag word masks
   758                                  curdir_isnet	EQU	1000000000000000B
   759                                  curdir_inuse	EQU	0100000000000000B
   760                                  curdir_splice	EQU	0010000000000000B
   761                                  curdir_local	EQU	0001000000000000B
   762                                  
   763                                  ; ----------------------------------------------------------------------
   764                                  ; SF.INC (MSDOS 3.3 - 24/07/1987) 	
   765                                  ; ----------------------------------------------------------------------
   766                                  ; 09/06/2018 - Retro DOS v3.0
   767                                  
   768                                  ;
   769                                  ; system file table
   770                                  ;
   771                                  
   772                                  struc	SF
   773 00000000 ????????                .SFLink:	resd	1
   774 00000004 ????                    .SFCount:	resw	1		; number of entries
   775 00000006 ????                    .SFTable:	resw	1		; beginning of array of the following
   776                                  .size:
   777                                  endstruc
   778                                  
   779                                  ;
   780                                  ; system file table entry
   781                                  ;
   782                                  
   783                                  struc	SF_ENTRY
   784 00000000 ????                    .sf_ref_count:	resw	1		; number of processes sharing entry
   785                                  					;   if FCB then ref count
   786 00000002 ????                    .sf_mode: 	resw	1		; mode of access or high bit on if FCB
   787 00000004 ??                      .sf_attr: 	resb	1		; attribute of file
   788 00000005 ????                    .sf_flags:	resw	1		;Bits 8-15
   789                                  					; Bit 15 = 1 if remote file
   790                                  					;	 = 0 if local file or device
   791                                  					; Bit 14 = 1 if date/time is not to be
   792                                  					;   set from clock at CLOSE.  Set by
   793                                  					;   FILETIMES and FCB_CLOSE.  Reset by
   794                                  					;   other reseters of the dirty bit
   795                                  					;   (WRITE)
   796                                  					; Bit 13 = Pipe bit (reserved)
   797                                  					;
   798                                  					; Bits 0-7 (old FCB_devid bits)
   799                                  					; If remote file or local file, bit
   800                                  					; 6=0 if dirty Device ID number, bits
   801                                  					; 0-5 if local file.
   802                                  					; bit 7=0 for local file, bit 7
   803                                  					;      =1 for local I/O device
   804                                  					; If local I/O device, bit 6=0 if EOF (input)
   805                                  					;		Bit 5=1 if Raw mode
   806                                  					;		Bit 0=1 if console input device
   807                                  					;		Bit 1=1 if console output device
   808                                  					;		Bit 2=1 if null device
   809                                  					;		Bit 3=1 if clock device
   810 00000007 ????????                .sf_devptr:	resd	1		; Points to DPB if local file, points
   811                                  					; to device header if local device,
   812                                  					; points to net device header if
   813                                  					; remote
   814 0000000B ????                    .sf_firclus:	resw	1		; First cluster of file (bit 15 = 0)
   815 0000000D ????                    .sf_time: 	resw	1		; Time associated with file
   816 0000000F ????                    .sf_date: 	resw	1		; Date associated with file
   817 00000011 ????????                .sf_size: 	resd	1		; Size associated with file
   818 00000015 ????????                .sf_position:	resd	1		; Read/Write pointer or LRU count for FCBs
   819                                  ;
   820                                  ; Starting here, the next 7 bytes may be used by the file system to store an
   821                                  ; ID
   822                                  ;
   823 00000019 ????                    .sf_cluspos:	resw	1		; Position of last cluster accessed
   824 0000001B ????                    .sf_lstclus:	resw	1		; Last cluster accessed
   825 0000001D ????                    .sf_dirsec:	resw	1		; Sector number of directory sector for this file
   826 0000001F ??                      .sf_dirpos:	resb	1		; Offset of this entry in the above
   827                                  ;
   828                                  ; End of 7 bytes of file-system specific info.
   829                                  ;
   830 00000020 <res Bh>                .sf_name:	resb	11		; 11 character name that is in the
   831                                  					; directory entry.  This is used by
   832                                  					; close to detect file deleted and
   833                                  					; disk changed errors.
   834                                  ; SHARING INFO
   835 0000002B ????????                .sf_chain:	resd	1		; link to next SF
   836 0000002F ????                    .sf_UID:	resw	1
   837 00000031 ????                    .sf_PID:	resw	1
   838 00000033 ????                    .sf_MFT:	resw	1
   839                                  .size:
   840                                  endstruc
   841                                  
   842                                  ; ----------------------------------------------------------------------
   843                                  ; DOSCNTRY.INC (MSDOS 3.3 - 24/07/1987) 	
   844                                  ; ----------------------------------------------------------------------
   845                                  ; 11/06/2018 - Retro DOS v3.0
   846                                  
   847                                  ;Equates for COUNTRY INFORMATION.
   848                                  SetCountryInfo		EQU	1	;country info
   849                                  SetUcase		EQU	2	;uppercase table
   850                                  SetLcase		EQU	3	;lowercase table (Reserved)
   851                                  SetUcaseFile		EQU	4	;uppercase file spec table
   852                                  SetFileList		EQU	5	;valid file character list
   853                                  SetCollate		EQU	6	;collating sequence
   854                                  SetDBCS 		EQU	7	;double byte character set
   855                                  SetALL			EQU	-1	;all the entries
   856                                  
   857                                  ;DOS country and code page information table structure.
   858                                  ;Internally, IBMDOS gives a pointer to this table.
   859                                  ;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
   860                                  ;this structure.
   861                                  
   862                                  struc country_cdpg_info ; DOS_country_cdpg_info
   863 00000000 ????????????????        .ccInfo_reserved :	resb	8	;reserved for internal use
   864 00000008 <res 40h>               .ccPath_CountrySys:	resb	64	;path and filename for country info
   865 00000048 ????                    .ccSysCodePage:		resw	1	;system code page id
   866 0000004A ????                    .ccNumber_of_entries:	resw	1 ; dw 5
   867 0000004C ??                      .ccSetUcase:		resb	1 ; db SetUcase ; = 2
   868 0000004D ????????                .ccUcase_ptr:		resd	1	;pointer to Ucase table
   869                                  
   870 00000051 ??                      .ccSetUcaseFile:	resb	1 ; db SetUcaseFile ; = 4
   871 00000052 ????????                .ccFileUcase_ptr: 	resd	1	;pointer to File Ucase table
   872                                  
   873 00000056 ??                      .ccSetFileList:		resb	1 ; db SetFileList ; = 5
   874 00000057 ????????                .ccFileChar_ptr:	resd	1	;pointer to File char list table
   875                                  
   876 0000005B ??                      .ccSetCollate:		resb	1 ; db SetCollate ; = 6
   877 0000005C ????????                .ccCollate_ptr:		resd	1	;pointer to collate table
   878                                  
   879 00000060 ??                      .ccSetCountryInfo:	resb	1 ; db SetCountryInfo ; = 1
   880 00000061 ????                    .ccCountryInfoLen:	resw	1	;length of country info
   881 00000063 ????                    .ccDosCountry:		resw	1	;system country code id
   882 00000065 ????                    .ccDosCodePage:		resw	1	;system code page id
   883 00000067 ????                    .ccDFormat:		resw	1	;date format
   884 00000069 ??????????              .ccCurSymbol:		resb	5 ; db "    ",0
   885                                  					;5 byte of (currency symbol+0)
   886 0000006E ????                    .cc1000Sep:		resb	2 ; db " ",0 ;2 byte of (1000 sep. + 0)
   887 00000070 ????                    .ccDecSep:		resb	2 ; db " ",0 ;2 byte of (Decimal sep. + 0)
   888 00000072 ????                    .ccDateSep:		resb	2 ; db " ",0 ;2 byte of (date sep. + 0)
   889 00000074 ????                    .ccTimeSep:		resb 	2 ; db " ",0 ;2 byte of (time sep. + 0)
   890 00000076 ??                      .ccCFormat:		resb	1 	;currency format flags
   891 00000077 ??                      .ccCSigDigits:		resb	1	;# of digits in currency
   892 00000078 ??                      .ccTFormat:		resb	1	;time format
   893 00000079 ????????                .ccMono_Ptr:		resd	1	;monocase routine entry point
   894 0000007D ????                    .ccListSep:		resb	2 ; db " ",0 ;data list separator
   895 0000007F <res Ah>                .ccReserved_area: 	resw	5 ; dw 5 dup(?) ;reserved
   896                                  .size:
   897                                  endstruc
   898                                  
   899                                  NEW_COUNTRY_SIZE    equ  country_cdpg_info.size - country_cdpg_info.ccDosCountry
   900                                  
   901                                  ; ----------------------------------------------------------------------
   902                                  
   903                                          ;INCLUDE DOSSYM.ASM
   904                                          ;INCLUDE DEVSYM.ASM
   905                                  
   906                                          ;IF      NOT IBM
   907                                          ;IF      NOT IBMJAPVER
   908                                          ;EXTRN   RE_INIT:FAR
   909                                          ;ENDIF
   910                                          ;ENDIF
   911                                  
   912                                  ;SYSINITSEG      SEGMENT PUBLIC 'SYSTEM_INIT'
   913                                  
   914                                  	;ASSUME  CS:SYSINITSEG,DS:NOTHING,ES:NOTHING,SS:NOTHING
   915                                  
   916                                  SYSINITSEG:
   917                                  
   918                                  	[org 0]
   919                                  
   920                                  	; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
   921                                  
   922                                  	;EXTRN	BADCOM:BYTE					
   923                                  	;EXTRN	SYSSIZE:BYTE					
   924                                  	;EXTRN	CONDEV:BYTE,AUXDEV:BYTE,PRNDEV:BYTE,COMMND:BYTE
   925                                  	;EXTRN	DeviceParameters:byte
   926                                  				
   927                                  	;EXTRN	INT24:NEAR,MEM_ERR:NEAR
   928                                  	;EXTRN	DOCONF:NEAR
   929                                  
   930                                          ;PUBLIC  CURRENT_DOS_LOCATION
   931                                          ;PUBLIC  FINAL_DOS_LOCATION
   932                                          ;PUBLIC  DEVICE_LIST
   933                                          ;PUBLIC  MEMORY_SIZE
   934                                          ;PUBLIC  DEFAULT_DRIVE
   935                                          ;PUBLIC  BUFFERS
   936                                          ;PUBLIC  FILES
   937                                          ;PUBLIC  SYSINIT
   938                                  	;PUBLIC	 CNTRYFILEHANDLE
   939                                  	;PUBLIC	 COMMAND_LINE
   940                                  
   941                                  ; 05/07/2018
   942                                  
   943                                  ; ----------------------------------------------------------------------
   944                                  ; SYSINIT1.ASM (MSDOS 3.3 - 24/07/1987) 	
   945                                  ; ----------------------------------------------------------------------
   946                                  
   947                                  ;Equates for Main stack and stack Initialization program
   948                                  	;IF	STACKSW
   949                                  cr			equ	0Dh
   950                                  lf			equ	0Ah
   951                                  
   952                                  EntrySize		equ	8
   953                                  
   954                                  MinCount		equ	8
   955                                  DefaultCount		equ	9
   956                                  MaxCount		equ	64
   957                                  
   958                                  MinSize 		equ	32
   959                                  DefaultSize		equ	128
   960                                  MaxSize 		equ	512
   961                                  
   962                                  ;%define AllocByte	byte [es:bp+0]
   963                                  %define	AllocByte	byte [es:bp] ; 05/07/2019
   964                                  %define IntLevel	byte [es:bp+1]
   965                                  %define SavedSP 	word [es:bp+2]
   966                                  %define SavedSS 	word [es:bp+4]
   967                                  %define NewSP		word [es:bp+6]
   968                                  
   969                                  Free			equ	0
   970                                  Allocated		equ	1
   971                                  Overflowed		equ	2
   972                                  Clobbered		equ	3
   973                                  	;END IF
   974                                  
   975                                  ; SYSINITSEG	SEGMENT PUBLIC 'SYSTEM_INIT'
   976                                  
   977                                  SYSINIT$:
   978                                  	;IF	STACKSW 
   979                                  	; include MSSTACK.INC	;Main stack program and data definitions
   980                                  	; include STKMES.INC	;Fatal stack error message
   981                                  	;   public Endstackcode
   982                                  ;Endstackcode	label byte
   983                                  	;ENDIF
   984                                  
   985                                  ; 05/07/2018
   986                                  ; ----------------------------------------------------------------------
   987                                  ; MSSTACK.INC - MSDOS 3.3 (02/02/1988)
   988                                  ; ----------------------------------------------------------------------
   989                                  ; 04/06/2018 - Retro DOS v3.0
   990                                  
   991                                  ;	MSStack.inc
   992                                  ;
   993                                  ;	Interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - AT level)
   994                                  ;	should follow the standard Interrupt Sharing Scheme which has
   995                                  ;	a standard header structure.
   996                                  ;	Fyi, the following shows the relations between
   997                                  ;	the interrupt vector and interrupt level.
   998                                  ; VEC(Hex)    2  8  9  A  B  C	D  E  70  72  73  74  76  77
   999                                  ; LVL(Deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
  1000                                  ;	MSSTACK module modifies the following interrupt vectors
  1001                                  ;	to meet the standard Interrupt Sharing standard;
  1002                                  ;	  A, B, C, D, E, 72, 73, 74, 76, 77.
  1003                                  ;	Also, for interrupt level 7 and 15, the FirstFlag in a standard header
  1004                                  ;	should be initialized to indicat whether this interrupt handler is
  1005                                  ;	the first (= 80h) or not.  The FirstFlag entry of INT77h's
  1006                                  ;	program header is initialized in STKINIT.INC module.
  1007                                  ;	FirstFlag is only meaningful for interrupt level 7 and 15.
  1008                                  ;
  1009                                  
  1010                                  ;  User specifies the number of stack elements - default = 9
  1011                                  ;						 minimum = 8
  1012                                  ;						 maximum = 64
  1013                                  ;
  1014                                  ;  Intercepts Asynchronous Hardware Interrupts only
  1015                                  ;
  1016                                  ;  Picks a stack from pool of stacks and switches to it
  1017                                  ;
  1018                                  ;  Calls the previously saved interrupt vector after pushing flags
  1019                                  ;
  1020                                  ;  On return, returns the stack to the stack pool
  1021                                  ;
  1022                                  
  1023                                  ; This is a modification of STACKS:
  1024                                  ; 1. To fix a bug which was causing the program to take up too much space.
  1025                                  ; 2. To dispense stack space from hi-mem first rather than low-mem first.
  1026                                  ;    . Clobbers the stack that got too big instead of innocent stack
  1027                                  ;    . Allows system to work if the only stack that got too big was the most
  1028                                  ;      deeply nested one
  1029                                  ; 3. Disables NMI interrupts while setting the NMI vector.
  1030                                  ; 4. Does not intercept any interupts on a PCjr.
  1031                                  ; 5. Double checks that a nested interrupt didn't get the same stack.
  1032                                  ; 6. Intercepts Ints 70, 72-77 for PC-ATs and other future products
  1033                                  
  1034                                  ;The following variables are for MSSTACK.inc
  1035                                  		;EVEN
  1036                                  ;align 2
  1037 00000000 0000                    		dw	0	; SPARE FIELD BUT LEAVE THESE IN ORDER
  1038 00000002 0000                    StackCount:	dw	0
  1039 00000004 0000                    StackAt: 	dw	0
  1040 00000006 0000                    StackSize:	dw	0
  1041 00000008 0000                    Stacks:		dw	0
  1042 0000000A 0000                    		dw	0
  1043                                  
  1044 0000000C [0800]                  FirstEntry:	dw	Stacks
  1045 0000000E [4800]                  LastEntry:	dw	Stacks+(DefaultCount*EntrySize)-EntrySize
  1046 00000010 [4800]                  NextEntry:	dw	Stacks+(DefaultCount*EntrySize)-EntrySize
  1047                                  
  1048                                  ;End of variables defined for MSSTACK.
  1049                                  
  1050                                  ;********************************************************************
  1051                                  ; THESE ARE THE INDIVIDUAL INTERRUPT HANDLERS
  1052                                  
  1053                                  	;IRP	A,<02,08,09,70>
  1054                                  	;IntSharingFlag=0
  1055                                  	;Stack_Main &A
  1056                                  	;ENDM
  1057                                  
  1058                                  ; 04/06/2018 - Retro DOS v3.0 ("Stack_Main" macro -> normal code)
  1059                                  
  1060                                  ;*******************************************************************
  1061                                  ;Macro Interrupt handler for the ordinary interrupt vectors and
  1062                                  ;the shared interrupt vectors.
  1063                                  ;*****************************
  1064                                  ;Stack_Main	MACRO	AA
  1065                                  ;	ASSUME	DS:NOTHING
  1066                                  ;	ASSUME	ES:NOTHING
  1067                                  ;	ASSUME	SS:NOTHING
  1068                                  ;PUBLIC	Int&AA
  1069                                  ;PUBLIC	Old&AA
  1070                                  ;;-----------------------------
  1071                                  ;	ife	IntSharingFlag		;if not IntSharingFlag
  1072                                  ;;-----------------------------
  1073                                  
  1074 00000012 00000000                Old02:	DD	0
  1075                                  
  1076                                  Int02:
  1077                                  
  1078                                  ; This patches INTERRUPT 75h to be "unhooked".  We do this Wierdness,
  1079                                  ; rather than never hooking INT 75h, to maintain maximum compat. with IBMs
  1080                                  ; post production patch.
  1081                                  
  1082 00000016 50                      	push	ax
  1083                                  
  1084                                  ; *********************************************************************
  1085                                  ;
  1086                                  ; This is special support for the P12 / NMI handler
  1087                                  ;
  1088                                  ;	On the P12, there is a situation where an NMI can be caused by
  1089                                  ;	using the "OUT" instructions to certain ports.  When this
  1090                                  ;	occurs, the P12 hardware *GUARANTEES* that **NOTHING** can stop
  1091                                  ;	the NMI or interfere with getting to the NMI handler.  This
  1092                                  ;	includes other type of interrupts (hardware and software), and
  1093                                  ;	also includes other type of NMI's.  When any NMI has occured,
  1094                                  ;	no other interrtupt (hardware, software or NMI) can occur until
  1095                                  ;	the software takes specific steps to allow further interrupting.
  1096                                  ;
  1097                                  ;	For P12, the situation where the NMI is generated by the "OUT"
  1098                                  ;	to a control port requires "fixing-up" and re-attempting.  In
  1099                                  ;	otherwords, it is actually a "restartable exception".  In this
  1100                                  ;	case, the software handler must be able to get to the stack in
  1101                                  ;	order to figure out what instruction caused the problem, where
  1102                                  ;	it was "OUT"ing to and what value it was "OUT"ing.  Therefore,
  1103                                  ;	we will not switch stacks in this situation.  This situation is
  1104                                  ;	detected by interrogating port 62h, and checking for a bit value
  1105                                  ;	of 80h.  If set, *****DO NOT SWITCH STACKS*****.
  1106                                  ;
  1107                                  ; *********************************************************************
  1108                                  
  1109 00000017 1E                      	push	ds
  1110 00000018 B800F0                  	mov	ax,0F000h
  1111 0000001B 8ED8                    	mov	ds,ax
  1112 0000001D 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;check if P12
  1113 00000022 1F                      	pop	ds
  1114 00000023 750C                    	jne	short Normal02
  1115                                  
  1116 00000025 E462                    	in	al,62h
  1117 00000027 A880                    	test	al,80h
  1118 00000029 7406                    	jz	short Normal02
  1119                                  
  1120                                  Special02:
  1121 0000002B 58                      	pop	ax
  1122                                  	; 17/06/2018
  1123 0000002C 2EFF2E[1200]            	jmp	far [cs:Old02]
  1124                                  
  1125                                  Normal02:
  1126                                  
  1127                                  ; *********************************************************************
  1128                                  
  1129 00000031 55                      	push	bp
  1130 00000032 06                      	push	es
  1131 00000033 2E8E06[0A00]            	mov	es, [cs:Stacks+2]	; Get segment of stacks
  1132                                  
  1133 00000038 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1134 0000003D B001                    	mov	al,Allocated
  1135 0000003F 26864600                	xchg	AllocByte,al		; grab the entry
  1136 00000043 3C00                    	cmp	al,Free 		; still avail?
  1137 00000045 7542                    	jne	short NotFree02
  1138                                  
  1139 00000047 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1140                                  
  1141                                  Found02:
  1142 0000004D 26896602                	mov	SavedSP,sp		; save sp value
  1143 00000051 268C5604                	mov	SavedSS,ss		; save ss also
  1144                                  ;	mov	IntLevel,02h		; save the int level
  1145                                  
  1146 00000055 89E8                    	mov	ax,bp			; temp save of table offset
  1147                                  
  1148 00000057 268B6E06                	mov	bp,NewSP		; get new SP value
  1149 0000005B 26394600                	cmp	[es:bp],ax		; check for offset into table
  1150 0000005F 7535                    	jne	short FoundBad02
  1151                                  
  1152 00000061 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1153 00000063 8ED0                    	mov	ss,ax
  1154 00000065 89EC                    	mov	sp,bp
  1155                                  
  1156 00000067 9C                      	pushf				; go execute the real interrupt handler
  1157                                  	; 17/06/2018
  1158 00000068 2EFF1E[1200]            	call	far [cs:Old02]		;  which will iret back to here
  1159                                  
  1160 0000006D 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1161 0000006F 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1162 00000073 268E5604                	mov	ss,SavedSS		; get old stack back
  1163 00000077 268B6602                	mov	sp,SavedSP
  1164                                  
  1165                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1166                                  ;	jne	short NewError02	;  do not free us
  1167                                  
  1168 0000007B 26C6460000              	mov	AllocByte,Free		; free the entry
  1169 00000080 2E892E[1000]            	mov	[cs:NextEntry],bp		; setup to use next time
  1170                                  
  1171                                  NewError02:
  1172 00000085 07                      	pop	es
  1173 00000086 5D                      	pop	bp			; saved on entry
  1174 00000087 58                      	pop	ax			; saved on entry
  1175                                  
  1176                                  IntRet_02:
  1177 00000088 CF                      	iret				; done with this interrupt
  1178                                  
  1179                                  NotFree02:
  1180 00000089 3C01                    	cmp	al,Allocated		; error flag
  1181 0000008B 7404                    	je	short FindNext02	;  no, continue
  1182 0000008D 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1183                                  
  1184                                  FindNext02:
  1185 00000091 E8D406                  	call	LongPath
  1186 00000094 EBB7                    	jmp	short Found02
  1187                                  
  1188                                  FoundBad02:
  1189 00000096 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1190 0000009B 72F4                    	jc	short FindNext02
  1191 0000009D 89C5                    	mov	bp,ax			; flag this entry
  1192 0000009F 26C6460003              	mov	AllocByte,Clobbered
  1193                                  ;	add	bp,EntrySize		;  and previous entry
  1194                                  ;	mov	AllocByte,Overflowed
  1195                                  ;	sub	bp,EntrySize
  1196 000000A4 EBEB                    	jmp	short FindNext02	; keep looking
  1197                                  
  1198 000000A6 00000000                Old08:	DD	0
  1199                                  
  1200                                  Int08:	
  1201 000000AA 50                      	push	ax
  1202 000000AB 55                      	push	bp
  1203 000000AC 06                      	push	es
  1204 000000AD 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1205 000000B2 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1206 000000B7 B001                    	mov	al,Allocated
  1207 000000B9 26864600                	xchg	AllocByte,al		; grab the entry
  1208 000000BD 3C00                    	cmp	al,Free 		; still avail?
  1209 000000BF 7542                    	jne	short NotFree08
  1210                                  
  1211 000000C1 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1212                                  
  1213                                  Found08:
  1214 000000C7 26896602                	mov	SavedSP,sp		; save sp value
  1215 000000CB 268C5604                	mov	SavedSS,ss		; save ss also
  1216                                  ;	mov	IntLevel,08h		; save the int level
  1217                                  
  1218 000000CF 89E8                    	mov	ax,bp			; temp save of table offset
  1219                                  
  1220 000000D1 268B6E06                	mov	bp,NewSP		; get new SP value
  1221 000000D5 26394600                	cmp	[es:bp],ax		; check for offset into table
  1222 000000D9 7535                    	jne	short FoundBad08
  1223                                  
  1224 000000DB 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1225 000000DD 8ED0                    	mov	ss,ax
  1226 000000DF 89EC                    	mov	sp,bp
  1227                                  
  1228 000000E1 9C                      	pushf				; go execute the real interrupt handler
  1229                                  	; 17/06/2018
  1230 000000E2 2EFF1E[A600]            	call	far [cs:Old08]		;  which will iret back to here
  1231                                  
  1232 000000E7 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1233 000000E9 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1234 000000ED 268E5604                	mov	ss,SavedSS		; get old stack back
  1235 000000F1 268B6602                	mov	sp,SavedSP
  1236                                  
  1237                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1238                                  ;	jne	short NewError08	;  do not free us
  1239                                  
  1240 000000F5 26C6460000              	mov	AllocByte,Free		; free the entry
  1241 000000FA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1242                                  
  1243                                  NewError08:
  1244 000000FF 07                      	pop	es
  1245 00000100 5D                      	pop	bp			; saved on entry
  1246 00000101 58                      	pop	ax			; saved on entry
  1247                                  
  1248                                  IntRet_08:
  1249 00000102 CF                      	iret				; done with this interrupt
  1250                                  
  1251                                  NotFree08:
  1252 00000103 3C01                    	cmp	al,Allocated		; error flag
  1253 00000105 7404                    	je	short FindNext08	;  no, continue
  1254 00000107 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1255                                  
  1256                                  FindNext08:
  1257 0000010B E85A06                  	call	LongPath
  1258 0000010E EBB7                    	jmp	short Found08
  1259                                  
  1260                                  FoundBad08:
  1261 00000110 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1262 00000115 72F4                    	jc	short FindNext08
  1263 00000117 89C5                    	mov	bp,ax			; flag this entry
  1264 00000119 26C6460003              	mov	AllocByte,Clobbered
  1265                                  ;	add	bp,EntrySize		;  and previous entry
  1266                                  ;	mov	AllocByte,Overflowed
  1267                                  ;	sub	bp,EntrySize
  1268 0000011E EBEB                    	jmp	short FindNext08	; keep looking
  1269                                  
  1270 00000120 00000000                Old09:	DD	0
  1271                                  
  1272                                  Int09:
  1273                                  ;
  1274                                  ; Keyboard interrupt must have a three byte jump, a NOP and a zero byte
  1275                                  ; as its first instruction for compatibility reasons
  1276                                  
  1277 00000124 EB02                    	jmp	short Keyboard_lbl
  1278 00000126 90                      	nop
  1279 00000127 00                      	db	0
  1280                                  
  1281                                  Keyboard_lbl:
  1282 00000128 50                      	push	ax
  1283 00000129 55                      	push	bp
  1284 0000012A 06                      	push	es
  1285 0000012B 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1286                                  
  1287 00000130 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1288 00000135 B001                    	mov	al,Allocated
  1289 00000137 26864600                	xchg	AllocByte,al		; grab the entry
  1290 0000013B 3C00                    	cmp	al,Free 		; still avail?
  1291 0000013D 7542                    	jne	short NotFree09
  1292                                  
  1293 0000013F 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1294                                  
  1295                                  Found09:
  1296 00000145 26896602                	mov	SavedSP,sp		; save sp value
  1297 00000149 268C5604                	mov	SavedSS,ss		; save ss also
  1298                                  ;	mov	IntLevel,09h		; save the int level
  1299                                  
  1300 0000014D 89E8                    	mov	ax,bp			; temp save of table offset
  1301                                  
  1302 0000014F 268B6E06                	mov	bp,NewSP		; get new SP value
  1303 00000153 26394600                	cmp	[es:bp],ax		; check for offset into table
  1304 00000157 7535                    	jne	short FoundBad09
  1305                                  
  1306 00000159 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1307 0000015B 8ED0                    	mov	ss,ax
  1308 0000015D 89EC                    	mov	sp,bp
  1309                                  
  1310 0000015F 9C                      	pushf				; go execute the real interrupt handler
  1311                                  	; 17/06/2018
  1312 00000160 2EFF1E[2001]            	call	far [cs:Old09]		;  which will iret back to here
  1313                                  
  1314 00000165 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1315 00000167 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1316 0000016B 268E5604                	mov	ss,SavedSS	     	; get old stack back
  1317 0000016F 268B6602                	mov	sp,SavedSP
  1318                                  
  1319                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1320                                  ;	jne	short NewError09	;  do not free us
  1321                                  
  1322 00000173 26C6460000              	mov	AllocByte,Free		; free the entry
  1323 00000178 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1324                                  
  1325                                  NewError09:
  1326 0000017D 07                      	pop	es
  1327 0000017E 5D                      	pop	bp			; saved on entry
  1328 0000017F 58                      	pop	ax			; saved on entry
  1329                                  
  1330                                  IntRet_09:
  1331 00000180 CF                      	iret				; done with this interrupt
  1332                                  
  1333                                  NotFree09:
  1334 00000181 3C01                    	cmp	al,Allocated		; error flag
  1335 00000183 7404                    	je	short FindNext09	;  no, continue
  1336 00000185 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1337                                  
  1338                                  FindNext09:
  1339 00000189 E8DC05                  	call	LongPath
  1340 0000018C EBB7                    	jmp	short Found09
  1341                                  
  1342                                  FoundBad09:
  1343 0000018E 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1344 00000193 72F4                    	jc	short FindNext09
  1345 00000195 89C5                    	mov	bp,ax			; flag this entry
  1346 00000197 26C6460003              	mov	AllocByte,Clobbered
  1347                                  ;	add	bp,EntrySize		;  and previous entry
  1348                                  ;	mov	AllocByte,Overflowed
  1349                                  ;	sub	bp,EntrySize
  1350 0000019C EBEB                    	jmp	short FindNext09	; keep looking
  1351                                  
  1352 0000019E 00000000                Old70:	DD	0
  1353                                  
  1354                                  Int70:
  1355 000001A2 50                      	push	ax
  1356 000001A3 55                      	push	bp
  1357 000001A4 06                      	push	es
  1358 000001A5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1359                                  
  1360 000001AA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1361 000001AF B001                    	mov	al,Allocated
  1362 000001B1 26864600                	xchg	AllocByte,al		; grab the entry
  1363 000001B5 3C00                    	cmp	al,Free 		; still avail?
  1364 000001B7 7542                    	jne	short NotFree70
  1365                                  
  1366 000001B9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1367                                  
  1368                                  Found70:
  1369 000001BF 26896602                	mov	SavedSP,sp		; save sp value
  1370 000001C3 268C5604                	mov	SavedSS,ss		; save ss also
  1371                                  ;	mov	IntLevel,70h		; save the int level
  1372                                  
  1373 000001C7 89E8                    	mov	ax,bp			; temp save of table offset
  1374                                  
  1375 000001C9 268B6E06                	mov	bp,NewSP		; get new SP value
  1376 000001CD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1377 000001D1 7535                    	jne	short FoundBad70
  1378                                  
  1379 000001D3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1380 000001D5 8ED0                    	mov	ss,ax
  1381 000001D7 89EC                    	mov	sp,bp
  1382                                  
  1383 000001D9 9C                      	pushf				; go execute the real interrupt handler
  1384                                  	; 17/06/2018
  1385 000001DA 2EFF1E[9E01]            	call	far [cs:Old70]		;  which will iret back to here
  1386                                  
  1387 000001DF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1388 000001E1 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1389 000001E5 268E5604                	mov	ss,SavedSS		; get old stack back
  1390 000001E9 268B6602                	mov	sp,SavedSP
  1391                                  
  1392                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1393                                  ;	jne	short NewError70	;  do not free us
  1394                                  
  1395 000001ED 26C6460000              	mov	AllocByte,Free		; free the entry
  1396 000001F2 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1397                                  
  1398                                  NewError70:
  1399 000001F7 07                      	pop	es
  1400 000001F8 5D                      	pop	bp			; saved on entry
  1401 000001F9 58                      	pop	ax			; saved on entry
  1402                                  
  1403                                  IntRet_70:
  1404 000001FA CF                      	iret				; done with this interrupt
  1405                                  
  1406                                  NotFree70:
  1407 000001FB 3C01                    	cmp	al,Allocated		; error flag
  1408 000001FD 7404                    	je	short FindNext70	;  no, continue
  1409 000001FF 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1410                                  
  1411                                  FindNext70:
  1412 00000203 E86205                  	call	LongPath
  1413 00000206 EBB7                    	jmp	short Found70
  1414                                  
  1415                                  FoundBad70:
  1416 00000208 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1417 0000020D 72F4                    	jc	short FindNext70
  1418 0000020F 89C5                    	mov	bp,ax			; flag this entry
  1419 00000211 26C6460003              	mov	AllocByte,Clobbered
  1420                                  ;	add	bp,EntrySize		;  and previous entry
  1421                                  ;	mov	AllocByte,Overflowed
  1422                                  ;	sub	bp,EntrySize
  1423 00000216 EBEB                    	jmp	short FindNext70	; keep looking
  1424                                  
  1425                                  ;********************************************************************
  1426                                  
  1427                                  	;IRP	A,<0A,0B,0C,0D,0E,72,73,74,76,77>
  1428                                  	;IntSharingFlag=1
  1429                                  	;Stack_Main &A
  1430                                  	;ENDM
  1431                                  
  1432                                  ;********************************************************************
  1433                                  
  1434                                  ;Stack_Main	MACRO	AA
  1435                                  ;	ASSUME	DS:NOTHING
  1436                                  ;	ASSUME	ES:NOTHING
  1437                                  ;	ASSUME	SS:NOTHING
  1438                                  ;PUBLIC	Int&AA
  1439                                  ;PUBLIC	Old&AA
  1440                                  ;-----------------------------
  1441                                  ;	ife	IntSharingFlag		;if not IntSharingFlag
  1442                                  ;;-----------------------------
  1443                                  ;	Old&AA	DD	0
  1444                                  ;Int&AA	PROC	FAR
  1445                                  ;;-----------------------------
  1446                                  ;    else				;for shared interrupt. A Header exists.
  1447                                  
  1448                                  ;PUBLIC	FirstFlag&AA
  1449                                  ;Int&AA	PROC	FAR
  1450                                  ;	jmp	short	  Entry_Int&AA&_Stk
  1451                                  ;	Old&AA	dd	  0		;Forward pointer
  1452                                  ;		dw	  424Bh 	;compatible signature for Int. Sharing
  1453                                  ;	FirstFlag&AA db   0		;the firstly hooked.
  1454                                  ;	jmp	short	IntRet_&AA	;Reset routine. We don't care this.
  1455                                  ;		db	  7 dup (0)	;Reserved for future.
  1456                                  ;Entry_Int&AA&_Stk:
  1457                                  ;;-----------------------------
  1458                                  ;	endif
  1459                                  ;;-----------------------------
  1460                                  
  1461                                  Int0A:
  1462 00000218 EB10                    	jmp	short Entry_Int0A_Stk
  1463 0000021A 00000000                Old0A:	dd	0	
  1464 0000021E 4B42                    	dw	424Bh
  1465                                  FirstFlag0A:
  1466 00000220 00                      	db	0
  1467 00000221 EB5F                    	jmp	short IntRet_0A
  1468 00000223 00<rep 7h>              	times	7 db 0
  1469                                  
  1470                                  Entry_Int0A_Stk:
  1471 0000022A 50                      	push	ax
  1472 0000022B 55                      	push	bp
  1473 0000022C 06                      	push	es
  1474 0000022D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1475 00000232 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1476 00000237 B001                    	mov	al,Allocated
  1477 00000239 26864600                	xchg	AllocByte,al		; grab the entry
  1478 0000023D 3C00                    	cmp	al,Free 		; still avail?
  1479 0000023F 7542                    	jne	short NotFree0A
  1480                                  
  1481 00000241 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1482                                  
  1483                                  Found0A:
  1484 00000247 26896602                	mov	SavedSP,sp		; save sp value
  1485 0000024B 268C5604                	mov	SavedSS,ss		; save ss also
  1486                                  ;	mov	IntLevel,0Ah		; save the int level
  1487                                  
  1488 0000024F 89E8                    	mov	ax,bp			; temp save of table offset
  1489                                  
  1490 00000251 268B6E06                	mov	bp,NewSP		; get new SP value
  1491 00000255 26394600                	cmp	[es:bp],ax		; check for offset into table
  1492 00000259 7535                    	jne	short FoundBad0A
  1493                                  
  1494 0000025B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1495 0000025D 8ED0                    	mov	ss,ax
  1496 0000025F 89EC                    	mov	sp,bp
  1497                                  
  1498 00000261 9C                      	pushf				; go execute the real interrupt handler
  1499                                  	; 17/06/2018
  1500 00000262 2EFF1E[1A02]            	call	far [cs:Old0A]		;  which will iret back to here
  1501                                  
  1502 00000267 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1503 00000269 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1504 0000026D 268E5604                	mov	ss,SavedSS		; get old stack back
  1505 00000271 268B6602                	mov	sp,SavedSP
  1506                                  
  1507                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1508                                  ;	jne	short NewError0A	;  do not free us
  1509                                  
  1510 00000275 26C6460000              	mov	AllocByte,Free		; free the entry
  1511 0000027A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1512                                  
  1513                                  NewError0A:
  1514 0000027F 07                      	pop	es
  1515 00000280 5D                      	pop	bp			; saved on entry
  1516 00000281 58                      	pop	ax			; saved on entry
  1517                                  
  1518                                  IntRet_0A:
  1519 00000282 CF                      	iret				; done with this interrupt
  1520                                  
  1521                                  NotFree0A:
  1522 00000283 3C01                    	cmp	al,Allocated		; error flag
  1523 00000285 7404                    	je	short FindNext0A	;  no, continue
  1524 00000287 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1525                                  
  1526                                  FindNext0A:
  1527 0000028B E8DA04                  	call	LongPath
  1528 0000028E EBB7                    	jmp	short Found0A
  1529                                  
  1530                                  FoundBad0A:
  1531 00000290 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1532 00000295 72F4                    	jc	short FindNext0A
  1533 00000297 89C5                    	mov	bp,ax			; flag this entry
  1534 00000299 26C6460003              	mov	AllocByte,Clobbered
  1535                                  ;	add	bp,EntrySize		;  and previous entry
  1536                                  ;	mov	AllocByte,Overflowed
  1537                                  ;	sub	bp,EntrySize
  1538 0000029E EBEB                    	jmp	short FindNext0A	; keep looking
  1539                                  
  1540                                  Int0B:
  1541 000002A0 EB10                    	jmp	short Entry_Int0B_Stk
  1542 000002A2 00000000                Old0B:	dd	0	
  1543 000002A6 4B42                    	dw	424Bh
  1544                                  FirstFlag0B:
  1545 000002A8 00                      	db	0
  1546 000002A9 EB5F                    	jmp	short IntRet_0B
  1547 000002AB 00<rep 7h>              	times	7 db 0
  1548                                  
  1549                                  Entry_Int0B_Stk:
  1550 000002B2 50                      	push	ax
  1551 000002B3 55                      	push	bp
  1552 000002B4 06                      	push	es
  1553 000002B5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1554 000002BA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1555 000002BF B001                    	mov	al,Allocated
  1556 000002C1 26864600                	xchg	AllocByte,al		; grab the entry
  1557 000002C5 3C00                    	cmp	al,Free 		; still avail?
  1558 000002C7 7542                    	jne	short NotFree0B
  1559                                  
  1560 000002C9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1561                                  
  1562                                  Found0B:
  1563 000002CF 26896602                	mov	SavedSP,sp		; save sp value
  1564 000002D3 268C5604                	mov	SavedSS,ss		; save ss also
  1565                                  ;	mov	IntLevel,0Bh		; save the int level
  1566                                  
  1567 000002D7 89E8                    	mov	ax,bp			; temp save of table offset
  1568                                  
  1569 000002D9 268B6E06                	mov	bp,NewSP		; get new SP value
  1570 000002DD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1571 000002E1 7535                    	jne	short FoundBad0B
  1572                                  
  1573 000002E3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1574 000002E5 8ED0                    	mov	ss,ax
  1575 000002E7 89EC                    	mov	sp,bp
  1576                                  
  1577 000002E9 9C                      	pushf				; go execute the real interrupt handler
  1578                                  	; 17/06/2018
  1579 000002EA 2EFF1E[A202]            	call	far [cs:Old0B]		;  which will iret back to here
  1580                                  
  1581 000002EF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1582 000002F1 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1583 000002F5 268E5604                	mov	ss,SavedSS		; get old stack back
  1584 000002F9 268B6602                	mov	sp,SavedSP
  1585                                  
  1586                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1587                                  ;	jne	short NewError0B	;  do not free us
  1588                                  
  1589 000002FD 26C6460000              	mov	AllocByte,Free		; free the entry
  1590 00000302 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1591                                  
  1592                                  NewError0B:
  1593 00000307 07                      	pop	es
  1594 00000308 5D                      	pop	bp			; saved on entry
  1595 00000309 58                      	pop	ax			; saved on entry
  1596                                  
  1597                                  IntRet_0B:
  1598 0000030A CF                      	iret				; done with this interrupt
  1599                                  
  1600                                  NotFree0B:
  1601 0000030B 3C01                    	cmp	al,Allocated		; error flag
  1602 0000030D 7404                    	je	short FindNext0B	;  no, continue
  1603 0000030F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1604                                  
  1605                                  FindNext0B:
  1606 00000313 E85204                  	call	LongPath
  1607 00000316 EBB7                    	jmp	short Found0B
  1608                                  
  1609                                  FoundBad0B:
  1610 00000318 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1611 0000031D 72F4                    	jc	short FindNext0B
  1612 0000031F 89C5                    	mov	bp,ax			; flag this entry
  1613 00000321 26C6460003              	mov	AllocByte,Clobbered
  1614                                  ;	add	bp,EntrySize		;  and previous entry
  1615                                  ;	mov	AllocByte,Overflowed
  1616                                  ;	sub	bp,EntrySize
  1617 00000326 EBEB                    	jmp	short FindNext0B	; keep looking
  1618                                  
  1619                                  Int0C:
  1620 00000328 EB10                    	jmp	short Entry_Int0C_Stk
  1621 0000032A 00000000                Old0C:	dd	0	
  1622 0000032E 4B42                    	dw	424Bh
  1623                                  FirstFlag0C:
  1624 00000330 00                      	db	0
  1625 00000331 EB5F                    	jmp	short IntRet_0C
  1626 00000333 00<rep 7h>              	times	7 db 0
  1627                                  
  1628                                  Entry_Int0C_Stk:
  1629 0000033A 50                      	push	ax
  1630 0000033B 55                      	push	bp
  1631 0000033C 06                      	push	es
  1632 0000033D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1633 00000342 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1634 00000347 B001                    	mov	al,Allocated
  1635 00000349 26864600                	xchg	AllocByte,al		; grab the entry
  1636 0000034D 3C00                    	cmp	al,Free 		; still avail?
  1637 0000034F 7542                    	jne	short NotFree0C
  1638                                  
  1639 00000351 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1640                                  
  1641                                  Found0C:
  1642 00000357 26896602                	mov	SavedSP,sp		; save sp value
  1643 0000035B 268C5604                	mov	SavedSS,ss		; save ss also
  1644                                  ;	mov	IntLevel,0Ch		; save the int level
  1645                                  
  1646 0000035F 89E8                    	mov	ax,bp			; temp save of table offset
  1647                                  
  1648 00000361 268B6E06                	mov	bp,NewSP		; get new SP value
  1649 00000365 26394600                	cmp	[es:bp],ax		; check for offset into table
  1650 00000369 7535                    	jne	short FoundBad0C
  1651                                  
  1652 0000036B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1653 0000036D 8ED0                    	mov	ss,ax
  1654 0000036F 89EC                    	mov	sp,bp
  1655                                  
  1656 00000371 9C                      	pushf				; go execute the real interrupt handler
  1657                                  	; 17/06/2018
  1658 00000372 2EFF1E[2A03]            	call	far [cs:Old0C]		;  which will iret back to here
  1659                                  
  1660 00000377 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1661 00000379 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1662 0000037D 268E5604                	mov	ss,SavedSS		; get old stack back
  1663 00000381 268B6602                	mov	sp,SavedSP
  1664                                  
  1665                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1666                                  ;	jne	short NewError0C	;  do not free us
  1667                                  
  1668 00000385 26C6460000              	mov	AllocByte,Free		; free the entry
  1669 0000038A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1670                                  
  1671                                  NewError0C:
  1672 0000038F 07                      	pop	es
  1673 00000390 5D                      	pop	bp			; saved on entry
  1674 00000391 58                      	pop	ax			; saved on entry
  1675                                  
  1676                                  IntRet_0C:
  1677 00000392 CF                      	iret				; done with this interrupt
  1678                                  
  1679                                  NotFree0C:
  1680 00000393 3C01                    	cmp	al,Allocated		; error flag
  1681 00000395 7404                    	je	short FindNext0C	;  no, continue
  1682 00000397 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1683                                  
  1684                                  FindNext0C:
  1685 0000039B E8CA03                  	call	LongPath
  1686 0000039E EBB7                    	jmp	short Found0C
  1687                                  
  1688                                  FoundBad0C:
  1689 000003A0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1690 000003A5 72F4                    	jc	short FindNext0C
  1691 000003A7 89C5                    	mov	bp,ax			; flag this entry
  1692 000003A9 26C6460003              	mov	AllocByte,Clobbered
  1693                                  ;	add	bp,EntrySize		;  and previous entry
  1694                                  ;	mov	AllocByte,Overflowed
  1695                                  ;	sub	bp,EntrySize
  1696 000003AE EBEB                    	jmp	short FindNext0C	; keep looking
  1697                                  
  1698                                  Int0D:
  1699 000003B0 EB10                    	jmp	short Entry_Int0D_Stk
  1700 000003B2 00000000                Old0D:	dd	0	
  1701 000003B6 4B42                    	dw	424Bh
  1702                                  FirstFlag0D:
  1703 000003B8 00                      	db	0
  1704 000003B9 EB5F                    	jmp	short IntRet_0D
  1705 000003BB 00<rep 7h>              	times	7 db 0
  1706                                  
  1707                                  Entry_Int0D_Stk:
  1708 000003C2 50                      	push	ax
  1709 000003C3 55                      	push	bp
  1710 000003C4 06                      	push	es
  1711 000003C5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1712 000003CA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1713 000003CF B001                    	mov	al,Allocated
  1714 000003D1 26864600                	xchg	AllocByte,al		; grab the entry
  1715 000003D5 3C00                    	cmp	al,Free 		; still avail?
  1716 000003D7 7542                    	jne	short NotFree0D
  1717                                  
  1718 000003D9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1719                                  
  1720                                  Found0D:
  1721 000003DF 26896602                	mov	SavedSP,sp		; save sp value
  1722 000003E3 268C5604                	mov	SavedSS,ss		; save ss also
  1723                                  ;	mov	IntLevel,0Dh		; save the int level
  1724                                  
  1725 000003E7 89E8                    	mov	ax,bp			; temp save of table offset
  1726                                  
  1727 000003E9 268B6E06                	mov	bp,NewSP		; get new SP value
  1728 000003ED 26394600                	cmp	[es:bp],ax		; check for offset into table
  1729 000003F1 7535                    	jne	short FoundBad0D
  1730                                  
  1731 000003F3 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1732 000003F5 8ED0                    	mov	ss,ax
  1733 000003F7 89EC                    	mov	sp,bp
  1734                                  
  1735 000003F9 9C                      	pushf				; go execute the real interrupt handler
  1736                                  	; 17/06/2018
  1737 000003FA 2EFF1E[B203]            	call	far [cs:Old0D]		;  which will iret back to here
  1738                                  
  1739 000003FF 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1740 00000401 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1741 00000405 268E5604                	mov	ss,SavedSS		; get old stack back
  1742 00000409 268B6602                	mov	sp,SavedSP
  1743                                  
  1744                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1745                                  ;	jne	short NewError0D	;  do not free us
  1746                                  
  1747 0000040D 26C6460000              	mov	AllocByte,Free		; free the entry
  1748 00000412 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1749                                  
  1750                                  NewError0D:
  1751 00000417 07                      	pop	es
  1752 00000418 5D                      	pop	bp			; saved on entry
  1753 00000419 58                      	pop	ax			; saved on entry
  1754                                  
  1755                                  IntRet_0D:
  1756 0000041A CF                      	iret				; done with this interrupt
  1757                                  
  1758                                  NotFree0D:
  1759 0000041B 3C01                    	cmp	al,Allocated		; error flag
  1760 0000041D 7404                    	je	short FindNext0D	;  no, continue
  1761 0000041F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1762                                  
  1763                                  FindNext0D:
  1764 00000423 E84203                  	call	LongPath
  1765 00000426 EBB7                    	jmp	short Found0D
  1766                                  
  1767                                  FoundBad0D:
  1768 00000428 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1769 0000042D 72F4                    	jc	short FindNext0D
  1770 0000042F 89C5                    	mov	bp,ax			; flag this entry
  1771 00000431 26C6460003              	mov	AllocByte,Clobbered
  1772                                  ;	add	bp,EntrySize		;  and previous entry
  1773                                  ;	mov	AllocByte,Overflowed
  1774                                  ;	sub	bp,EntrySize
  1775 00000436 EBEB                    	jmp	short FindNext0D	; keep looking
  1776                                  
  1777                                  Int0E:
  1778 00000438 EB10                    	jmp	short Entry_Int0E_Stk
  1779 0000043A 00000000                Old0E:	dd	0	
  1780 0000043E 4B42                    	dw	424Bh
  1781                                  FirstFlag0E:
  1782 00000440 00                      	db	0
  1783 00000441 EB5F                    	jmp	short IntRet_0E
  1784 00000443 00<rep 7h>              	times	7 db 0
  1785                                  
  1786                                  Entry_Int0E_Stk:
  1787 0000044A 50                      	push	ax
  1788 0000044B 55                      	push	bp
  1789 0000044C 06                      	push	es
  1790 0000044D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1791 00000452 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1792 00000457 B001                    	mov	al,Allocated
  1793 00000459 26864600                	xchg	AllocByte,al		; grab the entry
  1794 0000045D 3C00                    	cmp	al,Free 		; still avail?
  1795 0000045F 7542                    	jne	short NotFree0E
  1796                                  
  1797 00000461 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1798                                  
  1799                                  Found0E:
  1800 00000467 26896602                	mov	SavedSP,sp		; save sp value
  1801 0000046B 268C5604                	mov	SavedSS,ss		; save ss also
  1802                                  ;	mov	IntLevel,0Eh		; save the int level
  1803                                  
  1804 0000046F 89E8                    	mov	ax,bp			; temp save of table offset
  1805                                  
  1806 00000471 268B6E06                	mov	bp,NewSP		; get new SP value
  1807 00000475 26394600                	cmp	[es:bp],ax		; check for offset into table
  1808 00000479 7535                    	jne	short FoundBad0E
  1809                                  
  1810 0000047B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1811 0000047D 8ED0                    	mov	ss,ax
  1812 0000047F 89EC                    	mov	sp,bp
  1813                                  
  1814 00000481 9C                      	pushf				; go execute the real interrupt handler
  1815                                  	; 17/06/2018
  1816 00000482 2EFF1E[3A04]            	call	far [cs:Old0E]		;  which will iret back to here
  1817                                  
  1818 00000487 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1819 00000489 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1820 0000048D 268E5604                	mov	ss,SavedSS		; get old stack back
  1821 00000491 268B6602                	mov	sp,SavedSP
  1822                                  
  1823                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1824                                  ;	jne	short NewError0E	;  do not free us
  1825                                  
  1826 00000495 26C6460000              	mov	AllocByte,Free		; free the entry
  1827 0000049A 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1828                                  
  1829                                  NewError0E:
  1830 0000049F 07                      	pop	es
  1831 000004A0 5D                      	pop	bp			; saved on entry
  1832 000004A1 58                      	pop	ax			; saved on entry
  1833                                  
  1834                                  IntRet_0E:
  1835 000004A2 CF                      	iret				; done with this interrupt
  1836                                  
  1837                                  NotFree0E:
  1838 000004A3 3C01                    	cmp	al,Allocated		; error flag
  1839 000004A5 7404                    	je	short FindNext0E	;  no, continue
  1840 000004A7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1841                                  
  1842                                  FindNext0E:
  1843 000004AB E8BA02                  	call	LongPath
  1844 000004AE EBB7                    	jmp	short Found0E
  1845                                  
  1846                                  FoundBad0E:
  1847 000004B0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1848 000004B5 72F4                    	jc	short FindNext0E
  1849 000004B7 89C5                    	mov	bp,ax			; flag this entry
  1850 000004B9 26C6460003              	mov	AllocByte,Clobbered
  1851                                  ;	add	bp,EntrySize		;  and previous entry
  1852                                  ;	mov	AllocByte,Overflowed
  1853                                  ;	sub	bp,EntrySize
  1854 000004BE EBEB                    	jmp	short FindNext0E	; keep looking
  1855                                  
  1856                                  Int72:
  1857 000004C0 EB10                    	jmp	short Entry_Int72_Stk
  1858 000004C2 00000000                Old72:	dd	0	
  1859 000004C6 4B42                    	dw	424Bh
  1860                                  FirstFlag72:
  1861 000004C8 00                      	db	0
  1862 000004C9 EB5F                    	jmp	short IntRet_72
  1863 000004CB 00<rep 7h>              	times	7 db 0
  1864                                  
  1865                                  Entry_Int72_Stk:
  1866 000004D2 50                      	push	ax
  1867 000004D3 55                      	push	bp
  1868 000004D4 06                      	push	es
  1869 000004D5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1870 000004DA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1871 000004DF B001                    	mov	al,Allocated
  1872 000004E1 26864600                	xchg	AllocByte,al		; grab the entry
  1873 000004E5 3C00                    	cmp	al,Free 		; still avail?
  1874 000004E7 7542                    	jne	short NotFree72
  1875                                  
  1876 000004E9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1877                                  
  1878                                  Found72:
  1879 000004EF 26896602                	mov	SavedSP,sp		; save sp value
  1880 000004F3 268C5604                	mov	SavedSS,ss		; save ss also
  1881                                  ;	mov	IntLevel,72h		; save the int level
  1882                                  
  1883 000004F7 89E8                    	mov	ax,bp			; temp save of table offset
  1884                                  
  1885 000004F9 268B6E06                	mov	bp,NewSP		; get new SP value
  1886 000004FD 26394600                	cmp	[es:bp],ax		; check for offset into table
  1887 00000501 7535                    	jne	short FoundBad72
  1888                                  
  1889 00000503 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1890 00000505 8ED0                    	mov	ss,ax
  1891 00000507 89EC                    	mov	sp,bp
  1892                                  
  1893 00000509 9C                      	pushf				; go execute the real interrupt handler
  1894                                  	; 17/06/2018
  1895 0000050A 2EFF1E[C204]            	call	far [cs:Old72]		;  which will iret back to here
  1896                                  
  1897 0000050F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1898 00000511 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1899 00000515 268E5604                	mov	ss,SavedSS		; get old stack back
  1900 00000519 268B6602                	mov	sp,SavedSP
  1901                                  
  1902                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1903                                  ;	jne	short NewError72	;  do not free us
  1904                                  
  1905 0000051D 26C6460000              	mov	AllocByte,Free		; free the entry
  1906 00000522 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1907                                  
  1908                                  NewError72:
  1909 00000527 07                      	pop	es
  1910 00000528 5D                      	pop	bp			; saved on entry
  1911 00000529 58                      	pop	ax			; saved on entry
  1912                                  
  1913                                  IntRet_72:
  1914 0000052A CF                      	iret				; done with this interrupt
  1915                                  
  1916                                  NotFree72:
  1917 0000052B 3C01                    	cmp	al,Allocated		; error flag
  1918 0000052D 7404                    	je	short FindNext72	;  no, continue
  1919 0000052F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1920                                  
  1921                                  FindNext72:
  1922 00000533 E83202                  	call	LongPath
  1923 00000536 EBB7                    	jmp	short Found72
  1924                                  
  1925                                  FoundBad72:
  1926 00000538 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  1927 0000053D 72F4                    	jc	short FindNext72
  1928 0000053F 89C5                    	mov	bp,ax			; flag this entry
  1929 00000541 26C6460003              	mov	AllocByte,Clobbered
  1930                                  ;	add	bp,EntrySize		;  and previous entry
  1931                                  ;	mov	AllocByte,Overflowed
  1932                                  ;	sub	bp,EntrySize
  1933 00000546 EBEB                    	jmp	short FindNext72	; keep looking
  1934                                  
  1935                                  Int73:
  1936 00000548 EB10                    	jmp	short Entry_Int73_Stk
  1937 0000054A 00000000                Old73:	dd	0	
  1938 0000054E 4B42                    	dw	424Bh
  1939                                  FirstFlag73:
  1940 00000550 00                      	db	0
  1941 00000551 EB5F                    	jmp	short IntRet_73
  1942 00000553 00<rep 7h>              	times	7 db 0
  1943                                  
  1944                                  Entry_Int73_Stk:
  1945 0000055A 50                      	push	ax
  1946 0000055B 55                      	push	bp
  1947 0000055C 06                      	push	es
  1948 0000055D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  1949 00000562 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  1950 00000567 B001                    	mov	al,Allocated
  1951 00000569 26864600                	xchg	AllocByte,al		; grab the entry
  1952 0000056D 3C00                    	cmp	al,Free 		; still avail?
  1953 0000056F 7542                    	jne	short NotFree73
  1954                                  
  1955 00000571 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  1956                                  
  1957                                  Found73:
  1958 00000577 26896602                	mov	SavedSP,sp		; save sp value
  1959 0000057B 268C5604                	mov	SavedSS,ss		; save ss also
  1960                                  ;	mov	IntLevel,73h		; save the int level
  1961                                  
  1962 0000057F 89E8                    	mov	ax,bp			; temp save of table offset
  1963                                  
  1964 00000581 268B6E06                	mov	bp,NewSP		; get new SP value
  1965 00000585 26394600                	cmp	[es:bp],ax		; check for offset into table
  1966 00000589 7535                    	jne	short FoundBad73
  1967                                  
  1968 0000058B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  1969 0000058D 8ED0                    	mov	ss,ax
  1970 0000058F 89EC                    	mov	sp,bp
  1971                                  
  1972 00000591 9C                      	pushf				; go execute the real interrupt handler
  1973                                  	; 17/06/2018
  1974 00000592 2EFF1E[4A05]            	call	far [cs:Old73]		;  which will iret back to here
  1975                                  
  1976 00000597 89E5                    	mov	bp,sp			; retrieve the table offset for us
  1977 00000599 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  1978 0000059D 268E5604                	mov	ss,SavedSS		; get old stack back
  1979 000005A1 268B6602                	mov	sp,SavedSP
  1980                                  
  1981                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  1982                                  ;	jne	short NewError73	;  do not free us
  1983                                  
  1984 000005A5 26C6460000              	mov	AllocByte,Free		; free the entry
  1985 000005AA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  1986                                  
  1987                                  NewError73:
  1988 000005AF 07                      	pop	es
  1989 000005B0 5D                      	pop	bp			; saved on entry
  1990 000005B1 58                      	pop	ax			; saved on entry
  1991                                  
  1992                                  IntRet_73:
  1993 000005B2 CF                      	iret				; done with this interrupt
  1994                                  
  1995                                  NotFree73:
  1996 000005B3 3C01                    	cmp	al,Allocated		; error flag
  1997 000005B5 7404                    	je	short FindNext73	;  no, continue
  1998 000005B7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  1999                                  
  2000                                  FindNext73:
  2001 000005BB E8AA01                  	call	LongPath
  2002 000005BE EBB7                    	jmp	short Found73
  2003                                  
  2004                                  FoundBad73:
  2005 000005C0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2006 000005C5 72F4                    	jc	short FindNext73
  2007 000005C7 89C5                    	mov	bp,ax			; flag this entry
  2008 000005C9 26C6460003              	mov	AllocByte,Clobbered
  2009                                  ;	add	bp,EntrySize		;  and previous entry
  2010                                  ;	mov	AllocByte,Overflowed
  2011                                  ;	sub	bp,EntrySize
  2012 000005CE EBEB                    	jmp	short FindNext73	; keep looking
  2013                                  
  2014                                  Int74:
  2015 000005D0 EB10                    	jmp	short Entry_Int74_Stk
  2016 000005D2 00000000                Old74:	dd	0	
  2017 000005D6 4B42                    	dw	424Bh
  2018                                  FirstFlag74:
  2019 000005D8 00                      	db	0
  2020 000005D9 EB5F                    	jmp	short IntRet_74
  2021 000005DB 00<rep 7h>              	times	7 db 0
  2022                                  
  2023                                  Entry_Int74_Stk:
  2024 000005E2 50                      	push	ax
  2025                                  
  2026 000005E3 55                      	push	bp
  2027 000005E4 06                      	push	es
  2028 000005E5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2029 000005EA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2030 000005EF B001                    	mov	al,Allocated
  2031 000005F1 26864600                	xchg	AllocByte,al		; grab the entry
  2032 000005F5 3C00                    	cmp	al,Free 		; still avail?
  2033 000005F7 7542                    	jne	short NotFree74
  2034                                  
  2035 000005F9 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2036                                  
  2037                                  Found74:
  2038 000005FF 26896602                	mov	SavedSP,sp		; save sp value
  2039 00000603 268C5604                	mov	SavedSS,ss		; save ss also
  2040                                  ;	mov	IntLevel,74h		; save the int level
  2041                                  
  2042 00000607 89E8                    	mov	ax,bp			; temp save of table offset
  2043                                  
  2044 00000609 268B6E06                	mov	bp,NewSP		; get new SP value
  2045 0000060D 26394600                	cmp	[es:bp],ax		; check for offset into table
  2046 00000611 7535                    	jne	short FoundBad74
  2047                                  
  2048 00000613 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2049 00000615 8ED0                    	mov	ss,ax
  2050 00000617 89EC                    	mov	sp,bp
  2051                                  
  2052 00000619 9C                      	pushf				; go execute the real interrupt handler
  2053                                  	; 17/06/2018
  2054 0000061A 2EFF1E[D205]            	call	far [cs:Old74]		;  which will iret back to here
  2055                                  
  2056 0000061F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2057 00000621 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2058 00000625 268E5604                	mov	ss,SavedSS		; get old stack back
  2059 00000629 268B6602                	mov	sp,SavedSP
  2060                                  
  2061                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2062                                  ;	jne	short NewError74	;  do not free us
  2063                                  
  2064 0000062D 26C6460000              	mov	AllocByte,Free		; free the entry
  2065 00000632 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2066                                  
  2067                                  NewError74:
  2068 00000637 07                      	pop	es
  2069 00000638 5D                      	pop	bp			; saved on entry
  2070 00000639 58                      	pop	ax			; saved on entry
  2071                                  
  2072                                  IntRet_74:
  2073 0000063A CF                      	iret				; done with this interrupt
  2074                                  
  2075                                  NotFree74:
  2076 0000063B 3C01                    	cmp	al,Allocated		; error flag
  2077 0000063D 7404                    	je	short FindNext74	;  no, continue
  2078 0000063F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2079                                  
  2080                                  FindNext74:
  2081 00000643 E82201                  	call	LongPath
  2082 00000646 EBB7                    	jmp	short Found74
  2083                                  
  2084                                  FoundBad74:
  2085 00000648 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2086 0000064D 72F4                    	jc	short FindNext74
  2087 0000064F 89C5                    	mov	bp,ax			; flag this entry
  2088 00000651 26C6460003              	mov	AllocByte,Clobbered
  2089                                  ;	add	bp,EntrySize		;  and previous entry
  2090                                  ;	mov	AllocByte,Overflowed
  2091                                  ;	sub	bp,EntrySize
  2092 00000656 EBEB                    	jmp	short FindNext74	; keep looking
  2093                                  
  2094                                  Int76:
  2095 00000658 EB10                    	jmp	short Entry_Int76_Stk
  2096 0000065A 00000000                Old76:	dd	0	
  2097 0000065E 4B42                    	dw	424Bh
  2098                                  FirstFlag76:
  2099 00000660 00                      	db	0
  2100 00000661 EB5F                    	jmp	short IntRet_76
  2101 00000663 00<rep 7h>              	times	7 db 0
  2102                                  
  2103                                  Entry_Int76_Stk:
  2104 0000066A 50                      	push	ax
  2105 0000066B 55                      	push	bp
  2106 0000066C 06                      	push	es
  2107 0000066D 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2108 00000672 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2109 00000677 B001                    	mov	al,Allocated
  2110 00000679 26864600                	xchg	AllocByte,al		; grab the entry
  2111 0000067D 3C00                    	cmp	al,Free 		; still avail?
  2112 0000067F 7542                    	jne	short NotFree76
  2113                                  
  2114 00000681 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2115                                  
  2116                                  Found76:
  2117 00000687 26896602                	mov	SavedSP,sp		; save sp value
  2118 0000068B 268C5604                	mov	SavedSS,ss		; save ss also
  2119                                  ;	mov	IntLevel,76h		; save the int level
  2120                                  
  2121 0000068F 89E8                    	mov	ax,bp			; temp save of table offset
  2122                                  
  2123 00000691 268B6E06                	mov	bp,NewSP		; get new SP value
  2124 00000695 26394600                	cmp	[es:bp],ax		; check for offset into table
  2125 00000699 7535                    	jne	short FoundBad76
  2126                                  
  2127 0000069B 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2128 0000069D 8ED0                    	mov	ss,ax
  2129 0000069F 89EC                    	mov	sp,bp
  2130                                  
  2131 000006A1 9C                      	pushf				; go execute the real interrupt handler
  2132                                  	; 17/06/2018
  2133 000006A2 2EFF1E[5A06]            	call	far [cs:Old76]		;  which will iret back to here
  2134                                  
  2135 000006A7 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2136 000006A9 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2137 000006AD 268E5604                	mov	ss,SavedSS		; get old stack back
  2138 000006B1 268B6602                	mov	sp,SavedSP
  2139                                  
  2140                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2141                                  ;	jne	short NewError76	;  do not free us
  2142                                  
  2143 000006B5 26C6460000              	mov	AllocByte,Free		; free the entry
  2144 000006BA 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2145                                  
  2146                                  NewError76:
  2147 000006BF 07                      	pop	es
  2148 000006C0 5D                      	pop	bp			; saved on entry
  2149 000006C1 58                      	pop	ax			; saved on entry
  2150                                  
  2151                                  IntRet_76:
  2152 000006C2 CF                      	iret				; done with this interrupt
  2153                                  
  2154                                  NotFree76:
  2155 000006C3 3C01                    	cmp	al,Allocated		; error flag
  2156 000006C5 7404                    	je	short FindNext76	;  no, continue
  2157 000006C7 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2158                                  
  2159                                  FindNext76:
  2160 000006CB E89A00                  	call	LongPath
  2161 000006CE EBB7                    	jmp	short Found76
  2162                                  
  2163                                  FoundBad76:
  2164 000006D0 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2165 000006D5 72F4                    	jc	short FindNext76
  2166 000006D7 89C5                    	mov	bp,ax			; flag this entry
  2167 000006D9 26C6460003              	mov	AllocByte,Clobbered
  2168                                  ;	add	bp,EntrySize		;  and previous entry
  2169                                  ;	mov	AllocByte,Overflowed
  2170                                  ;	sub	bp,EntrySize
  2171 000006DE EBEB                    	jmp	short FindNext76	; keep looking
  2172                                  
  2173                                  Int77:
  2174 000006E0 EB10                    	jmp	short Entry_Int77_Stk
  2175 000006E2 00000000                Old77:	dd	0	
  2176 000006E6 4B42                    	dw	424Bh
  2177                                  FirstFlag77:
  2178 000006E8 00                      	db	0
  2179 000006E9 EB5F                    	jmp	short IntRet_77
  2180 000006EB 00<rep 7h>              	times	7 db 0
  2181                                  
  2182                                  Entry_Int77_Stk:
  2183 000006F2 50                      	push	ax
  2184 000006F3 55                      	push	bp
  2185 000006F4 06                      	push	es
  2186 000006F5 2E8E06[0A00]            	mov	es,[cs:Stacks+2]	; Get segment of stacks
  2187 000006FA 2E8B2E[1000]            	mov	bp,[cs:NextEntry]	; get most likely candidate
  2188 000006FF B001                    	mov	al,Allocated
  2189 00000701 26864600                	xchg	AllocByte,al		; grab the entry
  2190 00000705 3C00                    	cmp	al,Free 		; still avail?
  2191 00000707 7542                    	jne	short NotFree77
  2192                                  
  2193 00000709 2E832E[1000]08          	sub	word [cs:NextEntry],EntrySize ; set for next interrupt
  2194                                  
  2195                                  Found77:
  2196 0000070F 26896602                	mov	SavedSP,sp		; save sp value
  2197 00000713 268C5604                	mov	SavedSS,ss		; save ss also
  2198                                  ;	mov	IntLevel,77h		; save the int level
  2199                                  
  2200 00000717 89E8                    	mov	ax,bp			; temp save of table offset
  2201                                  
  2202 00000719 268B6E06                	mov	bp,NewSP		; get new SP value
  2203 0000071D 26394600                	cmp	[es:bp],ax		; check for offset into table
  2204 00000721 7535                    	jne	short FoundBad77
  2205                                  
  2206 00000723 8CC0                    	mov	ax,es			; point ss,sp to the new stack
  2207 00000725 8ED0                    	mov	ss,ax
  2208 00000727 89EC                    	mov	sp,bp
  2209                                  
  2210 00000729 9C                      	pushf				; go execute the real interrupt handler
  2211                                  	; 17/06/2018
  2212 0000072A 2EFF1E[E206]            	call	far [cs:Old77]		;  which will iret back to here
  2213                                  
  2214 0000072F 89E5                    	mov	bp,sp			; retrieve the table offset for us
  2215 00000731 268B6E00                	mov	bp,[es:bp]		;  but leave it on the stack
  2216 00000735 268E5604                	mov	ss,SavedSS		; get old stack back
  2217 00000739 268B6602                	mov	sp,SavedSP
  2218                                  
  2219                                  ;	cmp	AllocByte,Allocated	; If an error occured,
  2220                                  ;	jne	short NewError77	;  do not free us
  2221                                  
  2222 0000073D 26C6460000              	mov	AllocByte,Free		; free the entry
  2223 00000742 2E892E[1000]            	mov	[cs:NextEntry],bp	; setup to use next time
  2224                                  
  2225                                  NewError77:
  2226 00000747 07                      	pop	es
  2227 00000748 5D                      	pop	bp			; saved on entry
  2228 00000749 58                      	pop	ax			; saved on entry
  2229                                  
  2230                                  IntRet_77:
  2231 0000074A CF                      	iret				; done with this interrupt
  2232                                  
  2233                                  NotFree77:
  2234 0000074B 3C01                    	cmp	al,Allocated		; error flag
  2235 0000074D 7404                    	je	short FindNext77	;  no, continue
  2236 0000074F 26864600                	xchg	AllocByte,al		;  yes, restore error value
  2237                                  
  2238                                  FindNext77:
  2239 00000753 E81200                  	call	LongPath
  2240 00000756 EBB7                    	jmp	short Found77
  2241                                  
  2242                                  FoundBad77:
  2243 00000758 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2244 0000075D 72F4                    	jc	short FindNext77
  2245 0000075F 89C5                    	mov	bp,ax			; flag this entry
  2246 00000761 26C6460003              	mov	AllocByte,Clobbered
  2247                                  ;	add	bp,EntrySize		;  and previous entry
  2248                                  ;	mov	AllocByte,Overflowed
  2249                                  ;	sub	bp,EntrySize
  2250 00000766 EBEB                    	jmp	short FindNext77	; keep looking
  2251                                  
  2252                                  ;********************************************************************
  2253                                  
  2254                                  ;Common routines
  2255                                  
  2256                                  LongPath:
  2257                                  	; 17/06/2018
  2258 00000768 2E8B2E[0E00]            	mov	bp,[cs:LastEntry]	; start with last entry in table
  2259                                  
  2260                                  LPLOOPP:
  2261 0000076D 26807E0000              	cmp	AllocByte,Free		; is entry free?
  2262 00000772 7512                    	jne	short inuse		;  no, try next one
  2263                                  
  2264 00000774 B001                    	mov	al,Allocated
  2265 00000776 26864600                	xchg	AllocByte,al		; allocate entry
  2266 0000077A 3C00                    	cmp	al,Free 		; is it still free?
  2267 0000077C 7414                    	je	short found		;  yes, go use it
  2268                                  
  2269 0000077E 3C01                    	cmp	al,Allocated		; is it other than Allocated or Free?
  2270 00000780 7404                    	je	short inuse		;  no, check the next one
  2271                                  
  2272 00000782 26884600                	mov	AllocByte,al		;  yes, put back the error state
  2273                                  inuse:
  2274 00000786 2E3B2E[0C00]            	cmp	bp,[cs:FirstEntry]
  2275 0000078B 7406                    	je	short Fatal
  2276 0000078D 83ED08                  	sub	bp,EntrySize
  2277 00000790 EBDB                    	JMP	short LPLOOPP
  2278                                  found:
  2279 00000792 C3                      	retn
  2280                                  
  2281                                  Fatal:
  2282 00000793 1E                      	push	ds
  2283 00000794 B800F0                  	mov	ax, 0F000h		;look at the model byte
  2284 00000797 8ED8                    	mov	ds, ax
  2285 00000799 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;convertible
  2286 0000079E 1F                      	pop	ds
  2287 0000079F 7504                    	jne	short Skip_NMIS
  2288                                  
  2289 000007A1 B007                    	mov	al,07h			; disable p12 NMIs
  2290 000007A3 E672                    	out	72h,al
  2291                                  
  2292                                  Skip_NMIS:
  2293 000007A5 FA                      	cli				; disable and mask
  2294 000007A6 B0FF                    	mov	al,0FFh			;   all other ints
  2295 000007A8 E621                    	out	021h,al
  2296 000007AA E6A1                    	out	0A1h,al
  2297                                  
  2298 000007AC 8CCE                    	mov	si,cs
  2299 000007AE 8EDE                    	mov	ds,si
  2300 000007B0 BE[C207]                	mov	si,FATAL_MSG
  2301                                  
  2302                                  fatal_loop:
  2303 000007B3 AC                      	lodsb
  2304 000007B4 3C24                    	cmp	al,'$'
  2305 000007B6 7408                    	je	short fatal_done
  2306                                  
  2307 000007B8 B307                    	mov	bl,7
  2308 000007BA B40E                    	mov	ah,14
  2309 000007BC CD10                    	int	010h			; whoops, this enables ints
  2310 000007BE EBF3                    	jmp	short fatal_loop
  2311                                  
  2312                                  fatal_done:
  2313 000007C0 EBFE                    	jmp	short fatal_done
  2314                                  
  2315                                  ; ----------------------------------------------------------------------
  2316                                  ; STKMES.INC - MSDOS 3.3 (24/07/1987)
  2317                                  ; ----------------------------------------------------------------------
  2318                                  ; 04/06/2018 - Retro DOS v3.0
  2319                                  
  2320                                  FATAL_MSG:
  2321 000007C2 0D0A                    	DB	0DH,0AH
  2322 000007C4 070D0A                  	DB	7,0DH,0AH
  2323 000007C7 496E7465726E616C20-     	DB	"Internal stack overflow",0DH,0AH
  2323 000007D0 737461636B206F7665-
  2323 000007D9 72666C6F770D0A     
  2324 000007E0 53797374656D206861-     	DB	"System halted",0DH,0AH,"$" 
  2324 000007E9 6C7465640D0A24     
  2325                                  
  2326                                  Endstackcode:
  2327                                  
  2328                                  ; ----------------------------------------------------------------------
  2329                                  ; SYINIT1.ASM (MSDOS 3.3) - SYSINIT.ASM (MSDOS 2.0)
  2330                                  ; ----------------------------------------------------------------------
  2331                                  ; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT1.ASM, 24/07/1987)
  2332                                  
  2333                                  SYSINIT:
  2334 000007F0 E90501                          JMP	GOINIT
  2335                                  	;JMP	SYSIN ; 25/02/2018 - Retro DOS 2.0 modification
  2336 000007F3 90                      align 4
  2337                                  DOSINFO: 
  2338 000007F4 0000                    	dw	0
  2339                                  CURRENT_DOS_LOCATION: 
  2340 000007F6 0000                    	dw	0
  2341                                  MSDOS:	
  2342                                  ENTRY_POINT:
  2343 000007F8 0000                    	dw	0
  2344                                  FINAL_DOS_LOCATION:
  2345 000007FA 0000                    	dw	0
  2346                                  DEVICE_LIST:
  2347 000007FC 00000000                	dd	0
  2348                                  DOSSIZE: ; Retro DOS 2.0 feature - 25/02/2018
  2349 00000800 0000                    	dw	0   ; 'MSDOS.BIN' kernel size in words
  2350                                  
  2351                                  ; 04/06/2018 - Retro DOS v3.0
  2352                                  ; 28/03/2018
  2353                                  ;; MSDOS 3.3 - SYSINIT1.ASM - 24/07/1987
  2354                                  ;
  2355                                  SYSI_Country:	
  2356 00000802 0000                    	dw	0 ; 5/29/86 Pointer to
  2357 00000804 0000                    	dw	0 ;country table in DOS
  2358                                  
  2359                                  ;; STACKSW   EQU   TRUE ;Include Switchable Hardware Stacks
  2360                                  ;; (SYSCONF.ASM, 1987)
  2361                                  ;; Internal Stack Parameters
  2362                                  ;EntrySize	equ	8
  2363                                  ;MinCount	equ	8
  2364                                  ;DefaultCount	equ	9
  2365                                  ;MaxCount	equ	64
  2366                                  ;MinSize 	equ	32
  2367                                  ;DefaultSize	equ	128
  2368                                  ;MaxSize 	equ	512
  2369                                  
  2370                                  	;IF	STACKSW    ; STACKSW TRUE
  2371                                  ;
  2372                                  ; Internal Stack Parameters
  2373                                  
  2374 00000806 0900                    STACK_COUNT:	DW	DefaultCount
  2375 00000808 8000                    STACK_SIZE:	DW	DefaultSize
  2376 0000080A 00000000                STACK_ADDR:	DD	0
  2377                                  	;ENDIF
  2378                                  
  2379                                  ; 05/06/2018 - Retro DOS v3.0
  2380                                  
  2381                                  ; various default values
  2382                                  
  2383                                  MEMORY_SIZE:
  2384 0000080E 0100                    	dw	1
  2385                                  DEFAULT_DRIVE:
  2386 00000810 00                      	db	0
  2387                                  BUFFERS:
  2388 00000811 FFFF                    	DW	-1	; initialized during buffer allocation
  2389                                  ;BUFFERS: 
  2390                                  ;	DW	2	; two buffers
  2391                                  FILES:
  2392 00000813 08                      	db	8	; enough files for pipe
  2393                                  FCBS:
  2394 00000814 04                      	db	4	; performance for recycling
  2395                                  KEEP:
  2396 00000815 00                      	db	0	; keep original set
  2397                                  NUM_CDS:
  2398 00000816 05                      	db	5	; 5 net drives
  2399                                  CONFBOT:
  2400 00000817 0000                    	dw	0
  2401                                  ALLOCLIM:
  2402 00000819 0000                    	dw	0
  2403                                  FOOSTRNG:
  2404 0000081B 413A5C00                	db	"A:\",0
  2405                                  COMMAND_LINE:
  2406 0000081F 020050                  	db	2,0,"P" ; Default Command.com Args
  2407                                          
  2408 00000822 00<rep 1Dh>             	times	29 db 0
  2409                                  ZERO:
  2410 0000083F 00                      	db	0
  2411                                  SEPCHR:
  2412 00000840 00                      	db	0
  2413                                  
  2414                                  ; 10/06/2018
  2415                                  Sys_Model_Byte:
  2416 00000841 FF                      	db	0FFh	;model byte used in SYSINIT
  2417                                  Sys_Scnd_Model_Byte:
  2418 00000842 00                      	db	0	;secondary model byte used in SYSINIT
  2419                                  
  2420                                          ;IF      NOT NOEXEC
  2421                                  ;COMEXE EXEC0 <0,COMMAND_LINE,DEFAULT_DRIVE,ZERO>
  2422                                          ;ENDIF
  2423                                  
  2424                                  ; 01/05/2018
  2425                                  COMEXE:
  2426 00000843 0000                    EXEC0.ENVIRON:	DW	0	; seg addr of environment
  2427 00000845 [1F08]                  EXEC0.COM_LINE:	DW	COMMAND_LINE ; pointer to asciz command line
  2428 00000847 0000                    		DW	0
  2429 00000849 [1008]                  EXEC0.5C_FCB:	DW	DEFAULT_DRIVE ; default fcb at 5C
  2430 0000084B 0000                    		DW	0
  2431 0000084D [3F08]                  EXEC0.6C_FCB:	DW	ZERO	; default fcb at 6C
  2432 0000084F 0000                    		DW	0
  2433                                  
  2434                                  COUNT:
  2435 00000851 0000                    	dw	0
  2436                                  CHRPTR:
  2437 00000853 0000                    	dw	0
  2438                                  
  2439                                  ; 04/06/2018
  2440                                  CntryFileHandle:
  2441 00000855 0000                    	DW 	0 
  2442                                  
  2443 00000857 90                      align 4
  2444                                  
  2445                                  BUFPTR:
  2446                                  	; LEAVE THIS STUFF IN ORDER!
  2447                                  MEMLO:
  2448 00000858 0000                    	dw	0
  2449                                  PRMBLK:
  2450                                  MEMHI:
  2451 0000085A 0000                    	dw	0
  2452                                  LDOFF:
  2453 0000085C 0000                    	dw	0
  2454                                  AREA:
  2455 0000085E 0000                    	dw	0
  2456                                  
  2457                                  PACKET:
  2458 00000860 16                      	db	22
  2459 00000861 00                      	db	0
  2460 00000862 00                      	db	0	; INITIALIZE CODE
  2461 00000863 0000                    	dw	0
  2462 00000865 00<rep 8h>              	times	8 db 0
  2463                                  UNITCOUNT:
  2464 0000086D 00                      	db	0
  2465                                  BREAK_ADDR:
  2466 0000086E 00000000                	dd	0
  2467                                  BPB_ADDR:
  2468 00000872 00000000                	dd	0
  2469                                  DriveNumber:
  2470 00000876 00                      	db	0
  2471                                  
  2472 00000877 90                      align 2
  2473                                  
  2474                                  TempStack:
  2475 00000878 00<rep 80h>             	times	128 db 0
  2476                                  
  2477                                  GOINIT:
  2478                                  	; 06/07/2018
  2479                                  	; 04/06/2018 - Retro DOS v3.0
  2480                                  ; before doing anything else, let's set the model byte
  2481 000008F8 B4C0                    	mov	ah,0C0h 		;get system configuration
  2482 000008FA CD15                    	int	15h			; *
  2483 000008FC 7217                    	jc	short No_ROM_Config
  2484 000008FE 80FC00                  	cmp	ah,0			; double check
  2485 00000901 7512                    	jne	short No_ROM_Config
  2486 00000903 268A4702                	mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_modelbyte]
  2487 00000907 2EA2[4108]              	mov	[cs:Sys_Model_Byte],al 
  2488 0000090B 268A4703                	mov	al,[ES:BX+ROMBIOS_DESC.bios_SD_scnd_modelbyte]
  2489 0000090F 2EA2[4208]              	mov	[cs:Sys_Scnd_Model_Byte],al
  2490                                  	;jmp	short Move_Myself
  2491 00000913 EB0C                    	jmp	short SYSIN
  2492                                  No_ROM_Config:				; Old ROM
  2493 00000915 B800F0                  	mov	ax,0F000h
  2494 00000918 8ED8                    	mov	ds,ax
  2495 0000091A A0FEFF                  	mov	al,[0FFFEh]
  2496 0000091D 2EA2[4108]              	mov	[cs:Sys_Model_Byte],al	;set the model byte.
  2497                                  
  2498                                  ;Move_Myself:
  2499                                  ;	; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
  2500                                  ;	; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
  2501                                  ;
  2502                                  ;	SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
  2503                                  ;
  2504                                  ;      	;CLD
  2505                                  ;      	XOR     SI,SI
  2506                                  ;      	MOV     DI,SI
  2507                                  ;	; 19/03/2018
  2508                                  ;      	mov	CX,[SYSINIT_START+MEMORY_SIZE]
  2509                                  ;;	CMP     CX,1
  2510                                  ;;      JNZ     short NOSCAN
  2511                                  ;;	MOV     CX,2048		; START SCANNING AT 32K BOUNDARY
  2512                                  ;;	XOR     BX,BX
  2513                                  ;;MEMSCAN:
  2514                                  ;;	INC     CX
  2515                                  ;;    	JZ	short SETEND
  2516                                  ;;     	MOV     DS,CX
  2517                                  ;;     	MOV     AL,[BX]
  2518                                  ;;     	NOT     AL
  2519                                  ;;     	MOV     [BX],AL
  2520                                  ;;     	CMP     AL,[BX]
  2521                                  ;;     	NOT     AL
  2522                                  ;;     	MOV     [BX],AL
  2523                                  ;;     	JZ      short MEMSCAN
  2524                                  ;;SETEND:
  2525                                  ;;	MOV     AX,CS
  2526                                  ;;      MOV     DS,AX   
  2527                                  ;;	MOV	[SYSINIT_START+MEMORY_SIZE],CX 
  2528                                  ;;NOSCAN:
  2529                                  ;	MOV     AX,SYSINITSIZE + 15
  2530                                  ;	SHR     AX,1                    ; Divide by 16 for paras
  2531                                  ;	SHR     AX,1
  2532                                  ;	SHR     AX,1
  2533                                  ;	SHR     AX,1
  2534                                  ;
  2535                                  ;	SUB     CX,AX
  2536                                  ;	MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
  2537                                  ;	MOV     CX,SYSINITSIZE + 1
  2538                                  ;	SHR     CX,1                    ; Divide by 2 to get words
  2539                                  ;	REP     MOVSW                   ; RELOCATE SYSINIT
  2540                                  ;
  2541                                  ;	PUSH    ES
  2542                                  ;	MOV	AX,SYSIN  ; 05/06/2018 (MSDOS 3.3, SYSINIT1.ASM)
  2543                                  ;	PUSH    AX
  2544                                  ;	
  2545                                  ;	RETF	; far jump to final location of SYSINIT code
  2546                                  ;
  2547                                  
  2548                                  ;
  2549                                  ;       MOVE THE DOS TO ITS PROPER LOCATION
  2550                                  ;
  2551                                  
  2552                                  	;nop	; 30/03/2018
  2553                                  SYSIN:
  2554                                  	; Retro DOS 2.0 - 25/02/2018 
  2555                                  
  2556 00000921 0E                      	PUSH	CS
  2557 00000922 1F                      	POP	DS
  2558                                  
  2559 00000923 8B0E[0008]                      MOV     CX,[DOSSIZE] ; words (not bytes!)
  2560                                  	        
  2561 00000927 A1[FA07]                	MOV	AX,[FINAL_DOS_LOCATION]
  2562 0000092A 8EC0                    	MOV     ES,AX
  2563 0000092C A1[F607]                        MOV     AX,[CURRENT_DOS_LOCATION]
  2564 0000092F 8ED8                            MOV     DS,AX
  2565                                  
  2566 00000931 31F6                            XOR     SI,SI
  2567 00000933 89F7                            MOV     DI,SI
  2568                                  	;INC	CX
  2569                                  	;SHR	CX,1
  2570 00000935 F3A5                            REP     MOVSW
  2571                                  
  2572 00000937 8CC8                    	MOV	AX,CS
  2573 00000939 8ED8                    	MOV	DS,AX
  2574 0000093B 8B16[0E08]                      MOV	DX,[MEMORY_SIZE]
  2575 0000093F C536[FC07]              	LDS     SI,[DEVICE_LIST]
  2576                                  
  2577 00000943 FA                              CLI
  2578 00000944 8ED0                            MOV     SS,AX
  2579 00000946 BC[4A09]                        MOV     SP,LOCSTACK	
  2580 00000949 FB                      	STI
  2581                                  align 2
  2582                                  	; 30/03/2018
  2583                                  LOCSTACK:
  2584 0000094A 2EFF1E[F807]                    CALL	FAR [CS:MSDOS]	; FINAL_DOS_LOCATION:0 
  2585                                  		       		;('jmp DOSINIT' in 'MSHEAD.ASM')
  2586                                  		       		;('DOSINIT:' is in 'MSINIT.ASM')
  2587                                  
  2588                                  	; DS = PSP address for default process
  2589                                  	; ES:DI = Address of SYSINITVAR (MSDOS 2.0/2.11, Retro DOS 2.0)
  2590                                  
  2591                                  	;MOV     [CS:DOSINFO+2],ES ; SAVE POINTER TO DOS INFO
  2592                                  	;MOV     [CS:DOSINFO],DI
  2593                                  
  2594                                  	; 17/06/2018
  2595 0000094F 1E                      	PUSH	DS			; Save as input to RE_INIT
  2596                                  	
  2597 00000950 0E                      	PUSH	CS
  2598 00000951 1F                      	POP	DS
  2599                                  
  2600                                  	; 05/06/2018 - Retro DOS v3.0
  2601                                  	; ES:DI = Address of pointer to SYSINITVARS structure (MSDOS 3.3)
  2602                                  
  2603                                  	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars] ; 5/29/86
  2604 00000952 268B05                  	mov	ax,[es:di] ; 05/07/2019 
  2605                                  	;mov	[CS:DOSINFO],ax
  2606 00000955 A3[F407]                	mov	[DOSINFO],ax
  2607 00000958 268B4502                	mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars+2]
  2608                                  	;mov	[CS:DOSINFO+2],ax
  2609 0000095C A3[F607]                	mov	[DOSINFO+2],ax ;set the sysvar pointer
  2610                                  
  2611 0000095F 268B4504                	mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab]
  2612                                  	;mov	[CS:SYSI_Country],ax
  2613 00000963 A3[0208]                	mov	[SYSI_Country],ax
  2614 00000966 268B4506                	mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
  2615                                  	;mov	[CS:SYSI_Country+2],ax
  2616 0000096A A3[0408]                	mov	[SYSI_Country+2],ax	;set the SYSI_Country pointer
  2617                                  
  2618 0000096D C43E[F407]              	les	di,[DOSINFO]	;es:di -> dosinfo
  2619                                  
  2620                                  	; 09/06/2018
  2621                                  	; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  2622                                  	;SYSI_NUMIO equ	32
  2623                                   	
  2624                                  	; 25/03/2018 - Retro DOS v2.0 (MSDOS 2.0 <-> 3.3)
  2625                                  	;SYSI_NUMIO equ	16 ; SYSINITVAR NUMIO offset for MSDOS 2.0
  2626                                  
  2627                                  	; MSDOS 3.3 - SYSINIT1.ASM
  2628 00000971 268A4520                	MOV	AL,[ES:DI+SYSI_NUMIO] ; SYSINITVAR.NUMIO
  2629 00000975 A2[7608]                	MOV	[DriveNumber],AL ; Save start of installable block drvs
  2630                                  
  2631 00000978 8CC8                    	MOV	AX,CS
  2632 0000097A 83E811                  	SUB	AX,11H			; room for header we will copy shortly
  2633 0000097D A3[1708]                	MOV	[CONFBOT],AX		; Temp "unsafe" location
  2634                                  
  2635                                  	; 08/06/2018
  2636                                  	;PUSH	DS			; Save as input to RE_INIT
  2637                                  	;PUSH	CS
  2638                                  	;POP	DS
  2639 00000980 E87401                  	CALL	TEMPCDS 		; Set up CDSs so RE_INIT and SYSINIT
  2640                                  					;   can make DISK system calls
  2641                                  
  2642 00000983 1F                      	POP	DS			; Recover DS input to RE_INIT
  2643                                  
  2644                                  	; 06/07/2019
  2645                                  
  2646                                          ;IF	NOT IBMJAPVER
  2647                                  	
  2648 00000984 9A5D1A7000              	CALL	KERNEL_SEGMENT:RE_INIT ; Re-call the BIOS
  2649                                          
  2650                                  	;ENDIF
  2651                                  
  2652 00000989 FB                              STI
  2653 0000098A FC                              CLD
  2654                                  
  2655                                  ; DOSINIT has set up a default "process" (PHP) at DS:0. We will move it out
  2656                                  ; of the way by putting it just below SYSINIT at end of memory.
  2657                                  
  2658 0000098B 8CCB                            MOV     BX,CS
  2659 0000098D 83EB10                          SUB     BX,10H
  2660 00000990 8EC3                            MOV     ES,BX
  2661 00000992 31F6                            XOR     SI,SI
  2662 00000994 89F7                            MOV     DI,SI
  2663 00000996 B98000                          MOV     CX,80H
  2664 00000999 F3A5                            REP     MOVSW
  2665                                  
  2666 0000099B 268C063600              	MOV	[ES:PDB.JFN_POINTER+2],ES ; Relocate
  2667                                  
  2668                                   	; Set Process Data Block - Program Segment Prefix address
  2669                                  	; BX = PDB/PSP segment
  2670 000009A0 B450                            MOV     AH,SET_CURRENT_PDB
  2671 000009A2 CD21                            INT     21H			; Tell DOS we moved it
  2672                                  
  2673 000009A4 1E                              PUSH	DS
  2674 000009A5 0E                              PUSH    CS
  2675 000009A6 1F                              POP     DS
  2676 000009A7 BA[6D1B]                        MOV     DX,INT24	; SET UP INT 24 HANDLER
  2677 000009AA B82425                          MOV     AX,(SET_INTERRUPT_VECTOR*256)+24H
  2678 000009AD CD21                            INT     21H
  2679                                  
  2680                                  	; 25/03/2018 - MSDOS 3.3 - SYSINIT1.ASM
  2681 000009AF BBFFFF                  	MOV	BX,0FFFFH
  2682 000009B2 B448                    	MOV	AH,ALLOC
  2683 000009B4 CD21                    	INT	21H			;FIRST TIME FAILS
  2684 000009B6 B448                    	MOV	AH,ALLOC
  2685 000009B8 CD21                    	INT	21H			;SECOND TIME GETS IT
  2686 000009BA A3[5E08]                	MOV	[AREA],AX
  2687 000009BD A3[5A08]                	MOV	[MEMHI],AX		; MEMHI:MEMLO now points to
  2688                                  					; start of free memory
  2689                                          ;IF	ALTVECT
  2690                                  	; 27/06/2018
  2691 000009C0 BA[801B]                	MOV	DX,BOOTMES
  2692 000009C3 E87D11                          CALL	PRINT		; Print message DOSINIT couldn't
  2693                                          ;ENDIF
  2694                                  
  2695 000009C6 1F                      	POP	DS 
  2696                                  
  2697                                  	; 17/06/2018
  2698 000009C7 2E8A16[1008]                    MOV     DL,[CS:DEFAULT_DRIVE]
  2699                                  
  2700 000009CC 08D2                    	OR      DL,DL
  2701 000009CE 7406                            JZ      SHORT NODRVSET
  2702                                          
  2703 000009D0 FECA                    	DEC     DL                      ; A = 0
  2704 000009D2 B40E                            MOV     AH,SET_DEFAULT_DRIVE
  2705 000009D4 CD21                            INT     21H                     ; SELECT THE DISK
  2706                                  NODRVSET:
  2707 000009D6 E82607                  	CALL	DOCONF                  ; DO THE CONFIG STUFF
  2708                                  
  2709 000009D9 E89301                  	CALL	ENDFILE	; 25/03/2018 - MSDOS 3.3 - SYSINIT1.ASM
  2710                                  
  2711                                  	; 01/05/2018 (NOEXEC = FALSE)
  2712                                  	;IF	NOEXEC
  2713                                  
  2714                                  	;MOV	BP,DS                   ; SAVE COMMAND.COM SEGMENT
  2715                                  
  2716                                  	;;PUSH	DS
  2717                                  	;;POP	ES
  2718                                  
  2719                                  	;; 13/04/2018
  2720                                  	;MOV	ES, BP	
  2721                                  
  2722                                          ;MOV	BX,CS
  2723                                          ;SUB	BX,10H
  2724                                          ;MOV	DS,BX
  2725                                          ;XOR	SI,SI
  2726                                          ;MOV	DI,SI
  2727                                          ;MOV	CX,80H
  2728                                          ;REP	MOVSW
  2729                                  	;MOV	[ES:PDB.JFN_POINTER+2],ES ; Relocate ; 25/03/2018
  2730                                          ;MOV	BX,ES
  2731                                  
  2732                                          ;MOV	AH,SET_CURRENT_PDB
  2733                                          ;INT	21H
  2734                                  
  2735                                          ;MOV	[ES:PDB.PARENT_PID],ES  ; WE ARE THE ROOT
  2736                                          ;ENDIF
  2737                                  
  2738                                  ; We must now close all handles and reopen STDIN,STDOUT,STDERR in order
  2739                                  ; to get a possibly NEW device driver for CON. STDAUX and STDPRN must
  2740                                  ; also be openned.
  2741                                  
  2742 000009DC 0E                              PUSH    CS
  2743 000009DD 1F                              POP     DS
  2744                                  
  2745 000009DE A0[1308]                        MOV     AL,[FILES]
  2746                                  	;CBW
  2747 000009E1 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  2748                                  					;  IT DOES SIGN EXTEND.
  2749 000009E3 89C1                            MOV     CX,AX
  2750 000009E5 31DB                            XOR     BX,BX                   ; Close standard input
  2751 000009E7 B43E                            MOV     AH,CLOSE
  2752 000009E9 CD21                            INT     21H
  2753                                  
  2754 000009EB BB0200                          MOV     BX,2
  2755                                  RCCLLOOP: 				; Close everybody but standard output
  2756 000009EE B43E                            MOV     AH,CLOSE
  2757 000009F0 CD21                            INT     21H
  2758 000009F2 43                              INC     BX
  2759 000009F3 E2F9                            LOOP    RCCLLOOP
  2760                                  
  2761 000009F5 BA[B01B]                        MOV     DX,CONDEV
  2762 000009F8 B002                            MOV     AL,2
  2763 000009FA B43D                            MOV     AH,OPEN                 ; OPEN CON FOR READ/WRITE
  2764 000009FC F9                              STC
  2765 000009FD CD21                            INT     21H
  2766 000009FF 7305                            JNC     SHORT GOAUX
  2767 00000A01 E82111                          CALL    BADFIL
  2768 00000A04 EB13                            JMP     SHORT GOAUX2
  2769                                  
  2770 00000A06 50                      GOAUX:  PUSH    AX
  2771 00000A07 BB0100                          MOV     BX,1                    ; close standard output
  2772 00000A0A B43E                            MOV     AH,CLOSE
  2773 00000A0C CD21                            INT     21H
  2774 00000A0E 58                              POP     AX
  2775                                  
  2776 00000A0F 89C3                            MOV     BX,AX                   ; New device handle
  2777 00000A11 B445                            MOV     AH,XDUP
  2778 00000A13 CD21                            INT     21H                     ; Dup to 1, STDOUT
  2779 00000A15 B445                            MOV     AH,XDUP
  2780 00000A17 CD21                            INT     21H                     ; Dup to 2, STDERR
  2781                                  
  2782 00000A19 BA[B41B]                GOAUX2: MOV     DX,AUXDEV
  2783 00000A1C B002                            MOV     AL,2                    ; READ/WRITE ACCESS
  2784 00000A1E E82711                          CALL    OPEN_DEV
  2785                                  
  2786 00000A21 BA[B81B]                        MOV     DX,PRNDEV
  2787 00000A24 B001                            MOV     AL,1                    ; WRITE ONLY
  2788 00000A26 E81F11                          CALL    OPEN_DEV
  2789                                  
  2790                                  	; 08/06/2018 - Retro DOS v3.0
  2791                                  
  2792                                  ;Global Rearm command for Shared Interrupt devices attached in the system;
  2793                                  ;Shared interrupt attachment has some problem when it issues interrupt
  2794                                  ;during a warm reboot.	Once the interrupt is presented by the attachment,
  2795                                  ;no further interrupts on that level will be presented until a global rearm
  2796                                  ;is issued. BIOS will issue a global rearm after each device driver is loaded.
  2797                                  ;To issue a global rearm:	;For PC1, XT, Palace
  2798                                  ;			  OUT 02F2h, XX  ; Interrupt level 2
  2799                                  ;			  OUT 02F3h, XX  ; Interrupt level 3
  2800                                  ;			  OUT 02F4h, XX  ; Interrupt level 4
  2801                                  ;			  OUT 02F5h, XX  ; Interrupt level 5
  2802                                  ;			  OUT 02F6h, XX  ; Interrupt level 6
  2803                                  ;			  OUT 02F7h, XX  ; Interrupt level 7
  2804                                  ;
  2805                                  ;				;For PC AT, in addition to the above commands,
  2806                                  ;				;need to handle the secondary interrupt handler
  2807                                  ;			  OUT 06F2h, XX  ; Interrupt level 10
  2808                                  ;			  OUT 06F3h, XX  ; Interrupt level 11
  2809                                  ;			  OUT 06F4h, XX  ; Interrupt level 12
  2810                                  ;			  OUT 06F6h, XX  ; Interrupt level 14
  2811                                  ;			  OUT 06F7h, XX  ; Interrupt level 15
  2812                                  ;
  2813                                  ;				;For All others machine
  2814                                  ;			  None.
  2815                                  ;
  2816                                  ; where XX stands for any value.
  2817                                  
  2818                                  ; 05/07/2019
  2819                                  
  2820                                  ; MSDOS 6.0 - SYSINIT1.ASM (IBMDOS 3.3, IBMBIO.COM SYSINIT:0A4Ah)
  2821                                  
  2822                                  ; where xx stands for any value.
  2823                                  ;
  2824                                  ; for your information,after naples level machine,the system service bios
  2825                                  ; call (int 15h),function ah=0c0h returns the system configuration parameters
  2826                                  
  2827                                  	;PUSH	AX			;Save register
  2828                                  	;PUSH	BX			;Save register
  2829                                  	;PUSH	DX			;Save register
  2830                                  	;PUSH	ES			;Save register
  2831                                  
  2832 00000A29 B0FF                    	MOV	AL,0FFH 		;reset h/w by writing to port
  2833 00000A2B BAF202                  	MOV	DX,02F2H		;get starting address
  2834 00000A2E EE                      	OUT	DX,AL			;OUT 02F2H,0FFH
  2835 00000A2F 42                      	INC	DX			;
  2836 00000A30 EE                      	OUT	DX,AL			;OUT 02F3H,0FFH
  2837 00000A31 42                      	INC	DX			;
  2838 00000A32 EE                      	OUT	DX,AL			;OUT 02F4H,0FFH
  2839 00000A33 42                      	INC	DX			;
  2840 00000A34 EE                      	OUT	DX,AL			;OUT 02F5H,0FFH
  2841 00000A35 42                      	INC	DX			;
  2842 00000A36 EE                      	OUT	DX,AL			;OUT 02F6H,0FFH
  2843 00000A37 42                      	INC	DX			;
  2844 00000A38 EE                      	OUT	DX,AL			;OUT 02F7H,0FFH
  2845                                  
  2846                                  ;sb secondary global rearm
  2847                                  
  2848 00000A39 B800F0                  	MOV	AX,0F000H		;Get machine type
  2849 00000A3C 8EC0                    	MOV	ES,AX			;
  2850                                  
  2851                                  	;CMP	BYTE [ES:0FFFEH],0FCH	;Q: Is it an AT type machine?
  2852                                  	;JNE	short REARMDONE		;  N: Skip next rearm
  2853                                  
  2854                                  	; 05/07/2019
  2855 00000A3E 26803EFEFFFC            	cmp	byte [es:0FFFEh],0FCh	;q:is it a at type machine
  2856 00000A44 740D                    	je	short startrearm	; *if at no need to check
  2857                                  
  2858 00000A46 B4C0                    	MOV	AH,0C0H 		;Get system configuration
  2859 00000A48 CD15                    	INT	15H			;Q: Is it an old ROM?
  2860 00000A4A 7216                    	JC	short REARMDONE		;  Y: Skip next rearm
  2861                                  
  2862                                  ; test feature byte for secondary interrupt controller
  2863                                  
  2864 00000A4C 26F6470540              	TEST	byte [ES:BX+ROMBIOS_DESC.bios_SD_featurebyte1],ScndIntController
  2865                                  					; Q: Present?
  2866 00000A51 740F                    	JE	short REARMDONE		;  N: Skip next rearm
  2867                                  
  2868                                  startrearm:
  2869 00000A53 B0FF                    	MOV	AL,0FFH 		;write any pattern to port
  2870 00000A55 BAF206                  	MOV	DX,06F2H		;get starting address
  2871 00000A58 EE                      	OUT	DX,AL			;OUT 06F2H,0FFH
  2872 00000A59 42                      	INC	DX			;
  2873 00000A5A EE                      	OUT	DX,AL			;OUT 06F3H,0FFH
  2874 00000A5B 42                      	INC	DX			;
  2875 00000A5C EE                      	OUT	DX,AL			;OUT 06F4H,0FFH
  2876 00000A5D 42                      	INC	DX			;
  2877 00000A5E 42                      	INC	DX			;
  2878 00000A5F EE                      	OUT	DX,AL			;OUT 02F6H,0FFH
  2879 00000A60 42                      	INC	DX			;
  2880 00000A61 EE                      	OUT	DX,AL			;OUT 02F7H,0FFH
  2881                                  
  2882                                  REARMDONE:
  2883                                  	;POP	ES			;Restore register
  2884                                  	;POP	DX			;Restore register
  2885                                  	;POP	BX			;Restore register
  2886                                  	;POP	AX			;Restore register
  2887                                  
  2888                                  ;Global Rearm end *******************
  2889                                  
  2890                                  ;
  2891                                  ; SET UP THE PARAMETERS FOR COMMAND
  2892                                  ;
  2893                                  GOSET:
  2894 00000A62 BE[2008]                        MOV     SI,COMMAND_LINE+1
  2895                                  
  2896                                  	; 01/05/2018 (NOEXEC = FALSE)
  2897                                          ;IF	NOEXEC
  2898                                          ;MOV	DI,81H
  2899                                          ;ELSE
  2900 00000A65 1E                              PUSH	DS
  2901 00000A66 07                              POP	ES
  2902 00000A67 89F7                            MOV	DI,SI
  2903                                          ;ENDIF
  2904                                  
  2905 00000A69 B1FF                            MOV     CL,-1
  2906                                  COMTRANLP:                              ; FIND LENGTH OF COMMAND LINE
  2907 00000A6B FEC1                            INC     CL
  2908 00000A6D AC                              LODSB
  2909 00000A6E AA                              STOSB                           ; COPY COMMAND LINE IN
  2910 00000A6F 08C0                            OR      AL,AL
  2911 00000A71 75F8                            JNZ     SHORT COMTRANLP
  2912 00000A73 4F                              DEC     DI
  2913 00000A74 B00D                            MOV     AL,0DH
  2914 00000A76 AA                              STOSB
  2915                                  
  2916                                  	; 01/05/2018 (NOEXEC = FALSE)
  2917                                          ;IF	NOEXEC
  2918                                          ;MOV	[ES:80H],CL
  2919                                          ;MOV	AL,[DEFAULT_DRIVE]
  2920                                          ;MOV	[ES:5CH],AL
  2921                                          ;ELSE
  2922 00000A77 880E[1F08]                      MOV	[COMMAND_LINE],CL       ; Count
  2923                                          ;ENDIF
  2924                                  
  2925                                          ;PUSH    CS
  2926                                          ;POP     ES
  2927                                  
  2928 00000A7B BA[151C]                        MOV     DX,COMMND		; NOW POINTING TO FILE DESCRIPTION
  2929                                  
  2930                                  	; 01/05/2018 (NOEXEC = FALSE)
  2931                                          ;IF	NOEXEC
  2932                                          ;MOV     ES,BP			; SET LOAD ADDRESS
  2933                                          ;MOV     BX,100H
  2934                                          ;CALL    LDFIL			; READ IN COMMAND
  2935                                          ;JC      SHORT COMERR
  2936                                          ;MOV     DS,BP
  2937                                          ;MOV     DX,80H
  2938                                          ;MOV     AH,SET_DMA		; SET DISK TRANSFER ADDRESS
  2939                                          ;INT     21H
  2940                                          ;CLI
  2941                                          ;MOV     SS,BP
  2942                                          ;MOV     SP,DX
  2943                                          ;STI
  2944                                          ;XOR     AX,AX			; PUSH A WORD OF ZEROS
  2945                                          ;PUSH    AX
  2946                                          ;PUSH    BP			; SET HIGH PART OF JUMP ADDRESS
  2947                                          ;MOV     AX,100H
  2948                                          ;PUSH    AX			; SET LOW PART OF JUMP ADDRESS
  2949                                          ;RETF				; CRANK UP COMMAND!
  2950                                  
  2951                                          ;ELSE
  2952                                  
  2953                                  	; 08/06/2018 - Retro DOS v3.0  (MSDOS 3.3, SYSINIT1.ASM, 1987)
  2954                                  
  2955                                  ; We are going to open the command interpreter and size it as is done in
  2956                                  ; LDFIL.  The reason we must do this is that SYSINIT is in free memory.  If
  2957                                  ; there is not enough room for the command interpreter, EXEC will probably
  2958                                  ; overlay our stack and code so when it returns with an error SYSINIT won't be
  2959                                  ; here to catch it.  This code is not perfect (for instance .EXE command
  2960                                  ; interpreters are possible) because it does its sizing based on the
  2961                                  ; assumption that the file being loaded is a .COM file.  It is close enough to
  2962                                  ; correctness to be usable.
  2963                                  
  2964 00000A7E 52                      	PUSH	DX			; Save pointer to name
  2965                                  
  2966                                  ; First, find out where the command interpreter is going to go.
  2967 00000A7F BBFFFF                  	MOV	BX,0FFFFH
  2968 00000A82 B448                    	MOV	AH,ALLOC
  2969 00000A84 CD21                    	INT	21H			;Get biggest piece
  2970 00000A86 B448                    	MOV	AH,ALLOC
  2971 00000A88 CD21                    	INT	21H			;SECOND TIME GETS IT
  2972 00000A8A 7244                    	JC	short MEMERRJX		; Oooops
  2973 00000A8C 8EC0                    	MOV	ES,AX
  2974 00000A8E B449                    	MOV	AH,DEALLOC
  2975 00000A90 CD21                    	INT	21H			; Give it right back
  2976 00000A92 89DD                    	MOV	BP,BX
  2977                                  ; ES:0 points to Block, and BP is the size of the block
  2978                                  ;   in para.
  2979                                  
  2980                                  ; We will now adjust the size in BP DOWN by the size of SYSINIT. We
  2981                                  ;   need to do this because EXEC might get upset if some of the EXEC
  2982                                  ;   data in SYSINIT is overlayed during the EXEC.
  2983 00000A94 8B1E[0E08]              	MOV	BX,[MEMORY_SIZE]
  2984 00000A98 8CC8                    	MOV	AX,CS
  2985 00000A9A 29C3                    	SUB	BX,AX			; BX is size of SYSINIT in Para
  2986 00000A9C 83C311                  	ADD	BX,11H			; Add the SYSINIT PHP
  2987 00000A9F 29DD                    	SUB	BP,BX			; BAIS down
  2988 00000AA1 722D                    	JC	short MEMERRJX		; No Way.
  2989                                  
  2990 00000AA3 B8003D                  	MOV	AX,OPEN*256	 	;OPEN THE FILE being EXECED
  2991 00000AA6 F9                      	STC				;IN CASE OF INT 24
  2992 00000AA7 CD21                    	INT	21H
  2993 00000AA9 7244                    	JC	short COMERR		; Ooops
  2994 00000AAB 89C3                    	MOV	BX,AX			;Handle in BX
  2995 00000AAD 31C9                    	XOR	CX,CX
  2996 00000AAF 31D2                    	XOR	DX,DX
  2997 00000AB1 B80242                  	MOV	AX,(LSEEK*256)|2
  2998 00000AB4 F9                      	STC				;IN CASE OF INT 24
  2999 00000AB5 CD21                    	INT	21H			; Get file size in DX:AX
  3000 00000AB7 7236                    	JC	short COMERR
  3001                                      ; Convert size in DX:AX to para in AX
  3002 00000AB9 83C00F                  	ADD	AX,15			; Round up size for conversion to para
  3003 00000ABC 83D200                  	ADC	DX,0
  3004 00000ABF B104                    	MOV	CL,4
  3005 00000AC1 D3E8                    	SHR	AX,CL
  3006 00000AC3 B10C                    	MOV	CL,12
  3007 00000AC5 D3E2                    	SHL	DX,CL			; Low nibble of DX to high nibble
  3008 00000AC7 09D0                    	OR	AX,DX			; AX is now # of para for file
  3009 00000AC9 83C010                  	ADD	AX,10H			; 100H byte PHP
  3010 00000ACC 39E8                    	CMP	AX,BP			; Will it fit?
  3011 00000ACE 7203                    	JB	short OKLD		; Jump if yes.
  3012                                  MEMERRJX:
  3013 00000AD0 E9230E                  	JMP	MEM_ERR
  3014                                  
  3015                                  OKLD:
  3016 00000AD3 B43E                    	MOV	AH,CLOSE
  3017 00000AD5 CD21                    	INT	21H			; Close file
  3018                                  
  3019 00000AD7 5A                      	POP	DX			; Recover pointer to name
  3020                                  
  3021 00000AD8 0E                      	PUSH	CS
  3022 00000AD9 07                      	POP	ES
  3023                                  
  3024 00000ADA BB[4308]                	MOV	BX,COMEXE
  3025                                          ;MOV	[BX+EXEC0.COM_LINE+2],CS
  3026                                          ;MOV	[BX+EXEC0.5C_FCB+2],CS
  3027                                          ;MOV	[BX+EXEC0.6C_FCB+2],CS
  3028 00000ADD 8C0E[4708]              	MOV	[EXEC0.COM_LINE+2],CS
  3029 00000AE1 8C0E[4B08]                      MOV	[EXEC0.5C_FCB+2],CS
  3030 00000AE5 8C0E[4F08]                      MOV	[EXEC0.6C_FCB+2],CS
  3031                                  
  3032                                          ;XOR	AX,AX
  3033                                          ;MOV	AH,EXEC
  3034 00000AE9 B8004B                          MOV	AX,EXEC*256
  3035 00000AEC F9                      	STC				; IN CASE OF INT 24
  3036 00000AED CD21                            INT	21H			; GO START UP COMMAND
  3037                                          ;ENDIF
  3038                                  
  3039                                  COMERR:
  3040 00000AEF BA[AE1D]                        MOV     DX,BADCOM		; WANT TO PRINT COMMAND ERROR
  3041 00000AF2 E83010                          CALL    BADFIL
  3042                                  STALL:  
  3043 00000AF5 EBFE                    	JMP     SHORT STALL
  3044                                  
  3045                                  	; 08/06/2018 - Retro DOS v3.0
  3046                                  
  3047                                  TEMPCDS:
  3048 00000AF7 C43E[F407]              	LES	DI,[DOSINFO]
  3049                                  
  3050 00000AFB 268A4D20                	MOV	CL,[ES:DI+SYSI_NUMIO]
  3051 00000AFF 30ED                    	XOR	CH,CH
  3052 00000B01 26884D21                	MOV	[ES:DI+SYSI_NCDS],CL
  3053 00000B05 88C8                    	MOV	AL,CL
  3054 00000B07 B451                    	MOV	AH,curdir_list.size
  3055 00000B09 F6E4                    	MUL	AH
  3056 00000B0B E8AF02                  	call	ParaRound
  3057 00000B0E 8B36[1708]              	MOV	SI,[CONFBOT]
  3058 00000B12 29C6                    	SUB	SI,AX
  3059 00000B14 8936[1908]              	MOV	[ALLOCLIM],SI		; Can't alloc past here!
  3060 00000B18 26897518                	MOV	[ES:DI+SYSI_CDS+2],SI
  3061 00000B1C 89F0                    	MOV	AX,SI
  3062 00000B1E 26C745160000            	MOV	WORD [ES:DI+SYSI_CDS],0
  3063                                  	;LDS	SI,[ES:DI+SYSI_DPB]
  3064 00000B24 26C535                  	lds	si,[es:di]  ; 05/07/2019
  3065 00000B27 8EC0                    	MOV	ES,AX
  3066 00000B29 31FF                    	XOR	DI,DI
  3067                                  FOOSET: 				; Init CDSs
  3068                                  	; 18/06/2018
  3069 00000B2B 2EA1[1B08]              	MOV	AX,[CS:FOOSTRNG]
  3070 00000B2F AB                      	STOSW
  3071 00000B30 2EA1[1D08]              	MOV	AX,[CS:FOOSTRNG+2]
  3072 00000B34 AB                      	STOSW
  3073 00000B35 2EFE06[1B08]            	INC	BYTE [CS:FOOSTRNG]
  3074 00000B3A 31C0                    	XOR	AX,AX
  3075 00000B3C 51                      	PUSH	CX
  3076 00000B3D B93F00                  	MOV	CX,curdir_list.cdir_flags - 4
  3077 00000B40 F3AA                    	REP	STOSB
  3078 00000B42 83FEFF                  	CMP	SI,-1
  3079 00000B45 7507                    	JNZ	short NORMCDS
  3080                                  	;XOR	AX,AX ; 06/07/2019
  3081 00000B47 B103                    	MOV	CL,3
  3082 00000B49 F3AB                    	REP	STOSW
  3083 00000B4B 59                      	POP	CX
  3084 00000B4C EB0E                    	JMP	SHORT FINCDS
  3085                                  
  3086                                  NORMCDS:
  3087 00000B4E 59                      	POP	CX
  3088 00000B4F B80040                  	MOV	AX,curdir_inuse
  3089 00000B52 AB                      	STOSW				; curdir_flags
  3090 00000B53 89F0                    	MOV	AX,SI
  3091 00000B55 AB                      	STOSW				; curdir_devptr
  3092 00000B56 8CD8                    	MOV	AX,DS
  3093 00000B58 AB                      	STOSW
  3094 00000B59 C57418                  	LDS	SI,[SI+DPB.NEXT_DPB]
  3095                                  FINCDS:
  3096 00000B5C B8FFFF                  	MOV	AX,-1
  3097 00000B5F AB                      	STOSW				; curdir_ID
  3098 00000B60 AB                      	STOSW				; curdir_ID
  3099 00000B61 AB                      	STOSW				; curdir_user_word
  3100 00000B62 B80200                  	mov	ax,2
  3101 00000B65 AB                      	stosw				; curdir_end
  3102 00000B66 E2C3                    	LOOP	FOOSET
  3103 00000B68 2EC606[1B08]41          	MOV	BYTE [CS:FOOSTRNG],"A"
  3104 00000B6E C3                      	retn
  3105                                  
  3106                                  ; 09/06/2018 - Retro DOS v3.0  (MSDOS 3.3, SYSINIT1.ASM, 1987)
  3107                                  
  3108                                  ; Allocate FILEs
  3109                                  ;------------------------------------------------------------------------------
  3110                                  ENDFILE:
  3111                                  ; WE ARE NOW SETTING UP FINAL CDSs, BUFFERS, FILES, FCSs STRINGs etc.  We no
  3112                                  ; longer need the space taken by The TEMP stuff below CONFBOT, so set ALLOCLIM
  3113                                  ; to CONFBOT.
  3114                                  
  3115                                  	; 18/06/2018
  3116                                  	;MOV	AX,[CS:CONFBOT]
  3117                                  	;MOV	[CS:ALLOCLIM],AX
  3118 00000B6F 0E                      	PUSH	CS
  3119 00000B70 1F                      	POP	DS
  3120 00000B71 A1[1708]                	MOV	AX,[CONFBOT]
  3121 00000B74 A3[1908]                	MOV	[ALLOCLIM],AX
  3122 00000B77 E85A0D                  	call	ROUND
  3123 00000B7A A0[1308]                	MOV	AL,[FILES]
  3124 00000B7D 2C05                    	SUB	AL,5
  3125 00000B7F 763F                    	JBE	short DOFCBS
  3126 00000B81 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  3127                                  					;  IT DOES SIGN EXTEND.
  3128 00000B83 8B1E[5808]              	MOV	BX,[MEMLO]
  3129 00000B87 8B16[5A08]              	MOV	DX,[MEMHI]
  3130 00000B8B C53E[F407]              	LDS	DI,[DOSINFO]		;GET POINTER TO DOS DATA
  3131 00000B8F C57D04                  	LDS	DI,[DI+SYSI_SFT]	;DS:BP POINTS TO SFT
  3132                                  	;MOV	[DI+SF.SFLink],BX
  3133 00000B92 891D                    	mov	[di],bx ; 05/07/2019
  3134 00000B94 895502                  	MOV	[DI+SF.SFLink+2],DX	;SET POINTER TO NEW SFT
  3135 00000B97 0E                      	PUSH	CS
  3136 00000B98 1F                      	POP	DS
  3137 00000B99 C43E[5808]              	LES	DI,[MEMLO]		;POINT TO NEW SFT
  3138                                  	;MOV	WORD [ES:DI+SF.SFLink],-1
  3139 00000B9D 26C705FFFF              	mov	word [es:di],-1	 ; 05/07/2019	
  3140 00000BA2 26894504                	MOV	[ES:DI+SF.SFCount],AX
  3141 00000BA6 B335                    	MOV	BL,SF_ENTRY.size
  3142 00000BA8 F6E3                    	MUL	BL			;AX = NUMBER OF BYTES TO CLEAR
  3143 00000BAA 89C1                    	MOV	CX,AX
  3144 00000BAC 0106[5808]              	ADD	[MEMLO],AX		;ALLOCATE MEMORY
  3145 00000BB0 B80600                  	MOV	AX,6
  3146 00000BB3 0106[5808]              	ADD	[MEMLO],AX		;REMEMBER THE HEADER TOO
  3147 00000BB7 E81A0D                  	call	ROUND			; Check for mem error before the STOSB
  3148 00000BBA 01C7                    	ADD	DI,AX
  3149 00000BBC 31C0                    	XOR	AX,AX
  3150 00000BBE F3AA                    	REP	STOSB			;CLEAN OUT THE STUFF
  3151                                  
  3152                                  ; Allocate FCBs
  3153                                  ;------------------------------------------------------------------------------
  3154                                  DOFCBS:
  3155                                  	; 24/06/2018
  3156                                  	;PUSH	CS
  3157                                  	;POP	DS
  3158 00000BC0 E8110D                  	call	ROUND
  3159 00000BC3 A0[1408]                	MOV	AL,[FCBS]
  3160 00000BC6 30E4                    	XOR	AH,AH			; DO NOT USE CBW INSTRUCTION!!!!!
  3161                                  					;  IT DOES SIGN EXTEND.
  3162 00000BC8 8B1E[5808]              	MOV	BX,[MEMLO]
  3163 00000BCC 8B16[5A08]              	MOV	DX,[MEMHI]
  3164 00000BD0 C53E[F407]              	LDS	DI,[DOSINFO]		;GET POINTER TO DOS DATA
  3165                                  
  3166 00000BD4 895D1A                  	MOV	WORD [DI+SYSI_FCB],BX
  3167 00000BD7 89551C                  	MOV	WORD [DI+SYSI_FCB+2],DX ;SET POINTER TO NEW Table
  3168                                  
  3169 00000BDA 2E8A1E[1508]            	MOV	BL,[CS:KEEP]
  3170 00000BDF 30FF                    	XOR	BH,BH
  3171 00000BE1 895D1E                  	MOV	[DI+SYSI_KEEP],BX
  3172 00000BE4 0E                      	PUSH	CS
  3173 00000BE5 1F                      	POP	DS
  3174 00000BE6 C43E[5808]              	LES	DI,[MEMLO]		;POINT TO NEW Table
  3175                                  	;MOV	WORD [ES:DI+SF.SFLink],-1
  3176 00000BEA 26C705FFFF              	mov	word [es:di],-1 ; 05/07/2019
  3177 00000BEF 26894504                	MOV	[ES:DI+SF.SFCount],AX
  3178 00000BF3 B335                    	MOV	BL,SF_ENTRY.size
  3179 00000BF5 89C1                    	MOV	CX,AX
  3180 00000BF7 F6E3                    	MUL	BL			;AX = NUMBER OF BYTES TO CLEAR
  3181 00000BF9 0106[5808]              	ADD	[MEMLO],AX		;ALLOCATE MEMORY
  3182 00000BFD B80600                  	MOV	AX,SF.size-2
  3183 00000C00 0106[5808]              	ADD	[MEMLO],AX		;REMEMBER THE HEADER TOO
  3184 00000C04 E8CD0C                  	call	ROUND			; Check for mem error before the STOSB
  3185 00000C07 01C7                    	ADD	DI,AX			;Skip over header
  3186 00000C09 B041                    	MOV	AL,"A"
  3187                                  FillLoop:
  3188 00000C0B 51                      	PUSH	CX			; save count
  3189 00000C0C B93500                  	MOV	CX,SF_ENTRY.size	; number of bytes to fill
  3190 00000C0F FC                      	cld
  3191 00000C10 F3AA                    	REP	STOSB			; filled
  3192 00000C12 26C745CB0000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_ref_count],0
  3193 00000C18 26C745E00000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_position],0
  3194 00000C1E 26C745E20000            	MOV	WORD [ES:DI-SF_ENTRY.size+SF_ENTRY.sf_position+2],0
  3195 00000C24 59                      	POP	CX
  3196 00000C25 E2E4                    	LOOP	FillLoop
  3197                                  
  3198                                  ; Allocate Buffers
  3199                                  ;------------------------------------------------------------------------------
  3200                                  
  3201                                  ; Search through the list of media supported and allocate 3 buffers if the
  3202                                  ; capacity of the drive is > 360KB
  3203                                  
  3204 00000C27 803E[1108]FF            	CMP	byte [BUFFERS], -1	; Has buffers been already set?
  3205 00000C2C 7403                    	je	short DoDefaultBuff
  3206 00000C2E E98500                  	jmp	DOBUFF			; the user entered the buffers=.
  3207                                  
  3208                                  DoDefaultBuff:
  3209 00000C31 C606[1108]02            	MOV	byte [BUFFERS], 2	; Default to 2 buffers
  3210                                  	; 24/06/2018
  3211                                  	;PUSH	AX
  3212                                  	;PUSH	DS
  3213                                  	;
  3214                                  	;LES	BP,[CS:DOSINFO] 	; Search through the DPB's
  3215                                  	;LES	BP,[ES:BP+SYSI_DPB]	; Get first DPB
  3216                                  
  3217                                  	; 24/06/2018
  3218                                  	;PUSH	CS
  3219                                  	;POP	DS
  3220                                  	; 18/06/2018
  3221 00000C36 C42E[F407]              	LES	BP,[DOSINFO] 		; Search through the DPB's
  3222                                  	;LES	BP,[ES:BP+SYSI_DPB]	; Get first DPB
  3223 00000C3A 26C46E00                	les	bp,[es:bp] ; 05/07/2019
  3224                                  
  3225                                  NEXTDPB:
  3226                                  	; Test if the drive supports removeable media
  3227                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
  3228 00000C3E 268A5E00                	mov	bl,[es:bp] ; 05/07/2019
  3229 00000C42 FEC3                    	INC	BL
  3230 00000C44 B80844                  	MOV	AX,(IOCTL*256)|8
  3231 00000C47 CD21                    	INT	21H
  3232                                  
  3233                                  ; Ignore fixed disks
  3234 00000C49 09C0                    	OR	AX, AX			; AX is nonzero if disk is nonremoveable
  3235 00000C4B 7535                    	JNZ	short NOSETBUF
  3236                                  
  3237                                  ; Get parameters of drive
  3238 00000C4D 31DB                    	XOR	BX,BX
  3239                                  	;MOV	BL,[ES:BP+DPB.DRIVE]
  3240 00000C4F 268A5E00                	mov	bl,[es:bp] ; 05/07/2019
  3241 00000C53 FEC3                    	INC	BL
  3242 00000C55 BA[891C]                	MOV	DX,DEVICEPARAMETERS
  3243 00000C58 B80D44                  	MOV	AX,(IOCTL*256)|GENERIC_IOCTL
  3244 00000C5B B96008                  	MOV	CX,(RAWIO*256)|GET_DEVICE_PARAMETERS
  3245 00000C5E CD21                    	INT	21H
  3246 00000C60 7220                    	JC	short NOSETBUF		; Get next DPB if driver doesn't support
  3247                                  					; Generic IOCTL
  3248                                  ; Determine capacity of drive
  3249                                  ; Media Capacity = #Sectors * Bytes/Sector
  3250 00000C62 8B1E[981C]              	MOV	BX,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
  3251                                  
  3252                                  ; To keep the magnitude of the media capacity within a word,
  3253                                  ; scale the sector size
  3254                                  ; (ie. 1 -> 512 bytes, 2 -> 1024 bytes, ...)
  3255 00000C66 A1[901C]                	MOV	AX,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
  3256 00000C69 31D2                    	XOR	DX,DX
  3257 00000C6B B90002                  	MOV	CX,512
  3258 00000C6E F7F1                    	DIV	CX				; Scale sector size in factor of
  3259                                  						; 512 bytes
  3260                                  
  3261 00000C70 F7E3                    	MUL	BX				; AX = #sectors * size factor
  3262 00000C72 09D2                    	OR	DX,DX				; Just in case of LARGE floppies
  3263 00000C74 7505                    	JNZ	short SETBUF
  3264 00000C76 3DD002                  	CMP	AX,720				; 720 Sectors * size factor of 1
  3265 00000C79 7607                    	JBE	short NOSETBUF
  3266                                  SETBUF:
  3267 00000C7B C606[1108]03            	MOV	byte [BUFFERS], 3
  3268 00000C80 EB0D                    	jmp	short Chk_Memsize_for_Buffers 	; Now check the mem size for default buff count
  3269                                  NOSETBUF:
  3270 00000C82 26837E18FF              	CMP	WORD [ES:BP+DPB.NEXT_DPB],-1
  3271 00000C87 7406                    	jz	short Chk_Memsize_for_Buffers
  3272 00000C89 26C46E18                	LES	BP,[ES:BP+DPB.NEXT_DPB]
  3273 00000C8D EBAF                    	JMP	short NEXTDPB
  3274                                  
  3275                                  ;From DOS 3.3, the default number of buffers will be changed according to the
  3276                                  ;memory size too.
  3277                                  ; Default buffers = 2
  3278                                  ; If diskette Media > 360 kb, then default buffers = 3
  3279                                  ; If memory size > 128 kb (2000H para), then default buffers = 5
  3280                                  ; If memory size > 256 kb (4000H para), then default buffers = 10
  3281                                  ; If memory size > 512 kb (8000H para), then default buffers = 15.
  3282                                  
  3283                                  Chk_Memsize_for_Buffers:
  3284 00000C8F 813E[0E08]0020          	cmp	word [MEMORY_SIZE], 2000h
  3285 00000C95 761F                    	jbe	short BUFSET
  3286                                  	;mov	byte [BUFFERS], 5
  3287                                  	;cmp	word [MEMORY_SIZE], 4000h
  3288                                  	;jbe	short BUFSET
  3289                                  	;mov	byte [BUFFERS], 10
  3290                                  	;cmp	word [MEMORY_SIZE], 8000h
  3291                                  	;jbe	short BUFSET
  3292 00000C97 C606[1108]0F            	mov	byte [BUFFERS], 15
  3293                                  
  3294 00000C9C 813E[0E08]0080          	cmp	word [MEMORY_SIZE], 8000h
  3295 00000CA2 7312                    	jnb	short BUFSET
  3296 00000CA4 C606[1108]0A            	mov	byte [BUFFERS], 10
  3297 00000CA9 813E[0E08]0040          	cmp	word [MEMORY_SIZE], 4000h
  3298 00000CAF 7305                    	jnb	short BUFSET
  3299 00000CB1 C606[1108]05            	mov	byte [BUFFERS], 5
  3300                                  	;cmp	word [MEMORY_SIZE], 8000h
  3301                                  	;jbe	short BUFSET
  3302                                  	;mov	byte [BUFFERS], 15
  3303                                  
  3304                                  BUFSET:
  3305                                  	; 24/06/2018
  3306                                  	;POP	DS
  3307                                  	;POP	AX
  3308                                  DOBUFF:
  3309 00000CB6 E81B0C                  	call	ROUND
  3310 00000CB9 FE0E[1108]              	DEC	byte [BUFFERS]		; FIRST DEC acounts for buffer already
  3311                                  					;    in system.
  3312 00000CBD 742F                    	JZ	short BUF1		; All done
  3313 00000CBF 1E                      	PUSH	DS
  3314 00000CC0 C43E[5808]              	LES	DI,[BUFPTR]
  3315 00000CC4 C51E[F407]              	LDS	BX,[DOSINFO]
  3316 00000CC8 8B4712                  	MOV	AX,[BX+SYSI_BUF]	; Link in new buffer
  3317                                  	;MOV	[ES:DI+BUFFINFO.buf_link],AX
  3318 00000CCB 268905                  	mov	[es:di],ax; 05/07/2019
  3319 00000CCE 8B4714                  	MOV	AX,[BX+SYSI_BUF+2]
  3320 00000CD1 26894502                	MOV	[ES:DI+BUFFINFO.buf_link+2],AX
  3321 00000CD5 897F12                  	MOV	[BX+SYSI_BUF],DI
  3322 00000CD8 8C4714                  	MOV	[BX+SYSI_BUF+2],ES
  3323 00000CDB 26C74504FF00            	MOV	word [ES:DI+BUFFINFO.buf_ID],00FFH ;NEW BUFFER FREE
  3324 00000CE1 8B5F10                  	MOV	BX,[BX+SYSI_MAXSEC]
  3325 00000CE4 1F                      	POP	DS
  3326 00000CE5 83C310                  	ADD	BX,BUFINSIZ
  3327 00000CE8 011E[5808]              	ADD	[MEMLO],BX
  3328 00000CEC EBC8                    	JMP	short DOBUFF
  3329                                  
  3330                                  ; 10/06/2018 - Retro DOS v3.0
  3331                                  
  3332                                  ; Allocate CDSs
  3333                                  ;------------------------------------------------------------------------------
  3334                                  BUF1:
  3335 00000CEE E8E30B                  	call	ROUND
  3336 00000CF1 C43E[F407]              	LES	DI,[DOSINFO]
  3337 00000CF5 268A4D20                	MOV	CL,[ES:DI+SYSI_NUMIO]
  3338 00000CF9 3A0E[1608]              	CMP	CL,[NUM_CDS]
  3339 00000CFD 7304                    	JAE	short GOTNCDS		; User setting must be at least NUMIO
  3340 00000CFF 8A0E[1608]              	MOV	CL,[NUM_CDS]
  3341                                  GOTNCDS:
  3342 00000D03 30ED                    	XOR	CH,CH
  3343 00000D05 26884D21                	MOV	[ES:DI+SYSI_NCDS],CL
  3344 00000D09 A1[5A08]                	MOV	AX,[MEMHI]
  3345 00000D0C 26894518                	MOV	[ES:DI+SYSI_CDS+2],AX
  3346 00000D10 A1[5808]                	MOV	AX,[MEMLO]
  3347 00000D13 26894516                	MOV	[ES:DI+SYSI_CDS],AX
  3348 00000D17 88C8                    	MOV	AL,CL
  3349 00000D19 B451                    	MOV	AH,curdir_list.size
  3350 00000D1B F6E4                    	MUL	AH
  3351 00000D1D E89D00                  	call	ParaRound
  3352 00000D20 0106[5A08]              	ADD	[MEMHI],AX
  3353 00000D24 E8AD0B                  	call	ROUND			; Check for mem error before initializing
  3354                                  	;LDS	SI,[ES:DI+SYSI_DPB]
  3355 00000D27 26C535                  	lds	si,[es:di] ; 05/07/2019
  3356 00000D2A 26C47D16                	LES	DI,[ES:DI+SYSI_CDS]
  3357 00000D2E E8FAFD                  	CALL	FOOSET
  3358                                  
  3359                                  ; Allocate Space for Internal Stack
  3360                                  ;------------------------------------------------------------------------------
  3361                                  
  3362                                  	;IF	STACKSW
  3363 00000D31 0E                      	PUSH	CS
  3364 00000D32 1F                      	POP	DS
  3365                                  	;ASSUME	DS:SYSINITSEG
  3366                                  
  3367                                  	;IF	IBM
  3368                                  ;Don't install the system stack on the PCjr. Ignore STACKS=command too.
  3369 00000D33 803E[4108]FD            	CMP	byte [Sys_Model_Byte],0FDh	; PCjr = 0FDh
  3370 00000D38 7462                    	JE	short SkipStack
  3371                                  	;ENDIF
  3372                                  
  3373                                  ;If the user does not entered STACKS= command, as a default, do not install
  3374                                  ;sytem stacks for PC1, PC XT, PC Portable cases.
  3375                                  ;Otherwise, install it to the user specified value or to the default
  3376                                  ;value of 9, 128 for the rest of the system.
  3377                                  
  3378 00000D3A 833E[0A08]FF            	cmp	word [STACK_ADDR],-1		;Has the user entered "stacks=" command?
  3379 00000D3F 7415                    	je	short DoInstallStack		;Then install as specified by the user
  3380 00000D41 803E[4208]00            	cmp	byte [Sys_Scnd_Model_Byte],0	;PC1, XT has the secondary model byte = 0
  3381 00000D46 750E                    	jne	short DoInstallStack		;Other model should have def. stack of 9, 128
  3382 00000D48 803E[4108]FF            	cmp	byte [Sys_Model_Byte],0FFh	;PC1 ?
  3383 00000D4D 744D                    	je	short SkipStack
  3384 00000D4F 803E[4108]FE            	cmp	byte [Sys_Model_Byte],0FEh	;PC/XT or PC Portable ?	
  3385 00000D54 7446                    	je	short SkipStack
  3386                                  
  3387                                  DoInstallStack:
  3388 00000D56 A1[0608]                	mov	ax,[STACK_COUNT]		; Stack_count = 0?
  3389 00000D59 83F800                  	cmp	ax,0				;then, stack size must be 0 too.
  3390 00000D5C 743E                    	jz	short SkipStack			;Don't install stack.
  3391                                  ; 10/21/86 Dynamic Relocation of Stack code.			
  3392 00000D5E E8730B                  	call	ROUND				;[memhi] = Seg. for stack code
  3393                                  						;[memlo] = 0
  3394 00000D61 A1[5A08]                	mov	ax,[MEMHI]
  3395 00000D64 8EC0                    	mov	es,ax				;ES -> Seg. the stack code is going to move.
  3396                                  	;assume	es:nothing
  3397                                  	; 18/06/2018
  3398                                  	;push	cs
  3399                                  	;pop	ds
  3400                                  	; 05/07/2018
  3401 00000D66 31F6                    	xor	si,si			;!!We know that Stack code is at the beginning of SYSINIT.
  3402 00000D68 31FF                    	xor	di,di
  3403 00000D6A B9[F007]                	mov	cx,Endstackcode
  3404 00000D6D 890E[5808]              	mov	[MEMLO],cx
  3405 00000D71 E8600B                  	call	ROUND				;Have enough space for relocation?
  3406 00000D74 F3A4                    	rep	movsb
  3407                                  
  3408 00000D76 A1[5808]                	MOV	AX,[MEMLO]			; Set address of stacks
  3409 00000D79 A3[0A08]                	MOV	[STACK_ADDR],AX
  3410 00000D7C A1[5A08]                	MOV	AX,[MEMHI]
  3411 00000D7F A3[0C08]                	MOV	[STACK_ADDR+2],AX
  3412                                  
  3413                                  ;	Space for Internal Stack = STACK_COUNT(ENTRYSIZE + STACK_SIZE)
  3414 00000D82 B80800                  	MOV	AX,EntrySize
  3415 00000D85 0306[0808]              	ADD	AX,[STACK_SIZE]
  3416 00000D89 8B0E[0608]              	MOV	CX,[STACK_COUNT]
  3417 00000D8D F7E1                    	MUL	CX
  3418 00000D8F E82B00                  	call	ParaRound		; Convert size to paragraphs
  3419 00000D92 0106[5A08]              	ADD	[MEMHI],AX
  3420 00000D96 E83B0B                  	call	ROUND			; Check for memory error before
  3421                                  					; continuing
  3422 00000D99 E82D00                  	CALL	StackInit		; Initialize hardware stack
  3423                                  
  3424                                  SkipStack:
  3425                                  	;ENDIF
  3426                                  
  3427                                  	; 18/06/2018
  3428                                  	;PUSH	CS
  3429                                  	;POP	DS
  3430                                  	;ASSUME	DS:SYSINITSEG
  3431                                  
  3432                                  ; Allocate rest of memory to system
  3433                                  ;------------------------------------------------------------------------------
  3434 00000D9C E8350B                  	call	ROUND
  3435 00000D9F 8B1E[5A08]              	MOV	BX,[MEMHI]
  3436 00000DA3 A1[5E08]                	MOV	AX,[AREA]
  3437 00000DA6 8EC0                    	MOV	ES,AX			;CALC WHAT WE NEEDED
  3438 00000DA8 29C3                    	SUB	BX,AX
  3439 00000DAA B44A                    	MOV	AH,SETBLOCK
  3440 00000DAC CD21                    	INT	21H			;GIVE THE REST BACK
  3441 00000DAE 06                      	PUSH	ES
  3442 00000DAF 8CC0                    	MOV	AX,ES
  3443 00000DB1 48                      	DEC	AX
  3444 00000DB2 8EC0                    	MOV	ES,AX			;Point to arena
  3445 00000DB4 26C70601000800          	MOV	word [ES:ARENA.OWNER],8	;Set impossible owner
  3446 00000DBB 07                      	POP	ES
  3447                                  
  3448                                  	;IF	NOEXEC   ; (NOEXEC = FALSE)
  3449                                  	;MOV	BX,0FFFFH		;ALLOCATE THE REST OF MEM FOR COMMAND
  3450                                  	;MOV	AH,ALLOC
  3451                                  	;INT	21H
  3452                                  	;MOV	AH,ALLOC
  3453                                  	;INT	21H
  3454                                  	;MOV	DS,AX
  3455                                  	;ENDIF
  3456                                  
  3457 00000DBC C3                      	retn
  3458                                  
  3459                                  ParaRound:
  3460 00000DBD 83C00F                  	ADD	AX,15
  3461 00000DC0 D1D8                    	RCR	AX,1
  3462 00000DC2 D1E8                    	SHR	AX,1
  3463 00000DC4 D1E8                    	SHR	AX,1
  3464 00000DC6 D1E8                    	SHR	AX,1
  3465 00000DC8 C3                      	retn
  3466                                  
  3467                                  ;-------------------------------------------------------------------------
  3468                                  ; 5/6/86. MSSTACK initialization routine.
  3469                                  	;IF	STACKSW 
  3470                                  
  3471                                  ;INCLUDE STKINIT.INC
  3472                                  
  3473                                  	;ENDIF
  3474                                  ;--------------------------------------------------------------------------
  3475                                  
  3476                                  ; 05/07/2018
  3477                                  
  3478                                  ; ----------------------------------------------------------------------
  3479                                  ; STKINIT.INC - MSDOS 3.3 - 24/07/1987
  3480                                  ; ----------------------------------------------------------------------
  3481                                  ; 10/06/2018 - Retro DOS v3.0
  3482                                  
  3483                                  KERNEL_SEGMENT	equ 0070h
  3484                                  
  3485                                  ; retrodos3.s (offset addresses in MSDOS.SYS or RETRODOS.SYS)
  3486                                  ; -----------------------------------------------------------
  3487                                  ; Note: These offset addressses must be chanqed when the code 
  3488                                  ; 	in retrodos3.s (MSDOS.SYS) file will be changed.
  3489                                  ;INT19SEM equ 1870h ; 05/07/2019 - retrodos3.lst
  3490                                  ; 03/09/2022
  3491                                  INT19SEM equ 1832h ; (ibmbio33.s - test version)
  3492                                  ;ORIG19	 equ 1874h ; 17/06/2018 - retrodos3.lst
  3493                                  ; 03/09/2022
  3494                                  ORIG19	 equ 1834h ; (ibmbio33.s - test version)
  3495                                  INT19OLD02 equ ORIG19+4
  3496                                  INT19OLD08 equ ORIG19+8
  3497                                  INT19OLD09 equ ORIG19+12
  3498                                  INT19OLD0A equ ORIG19+16
  3499                                  INT19OLD0B equ ORIG19+20
  3500                                  INT19OLD0C equ ORIG19+24
  3501                                  INT19OLD0D equ ORIG19+28
  3502                                  INT19OLD0E equ ORIG19+32
  3503                                  INT19OLD70 equ ORIG19+36
  3504                                  INT19OLD72 equ ORIG19+40
  3505                                  INT19OLD73 equ ORIG19+44
  3506                                  INT19OLD74 equ ORIG19+48
  3507                                  INT19OLD76 equ ORIG19+52
  3508                                  INT19OLD77 equ ORIG19+56
  3509                                  
  3510                                  ; 06/07/2019
  3511                                  ;RE_INIT equ 1B03h ; 1AA6h for MSDOS 3.3 IBMBIO.COM
  3512                                  ; 03/09/2022
  3513                                  RE_INIT equ 1A5Dh ; 1AA6h for MSDOS 3.3 IBMBIO.COM	
  3514                                  	
  3515                                  ;	To follow the standard interrupt sharing scheme, MSSTACK.ASM
  3516                                  ;	has been modified. This initialization routine also has to
  3517                                  ;	be modified because for the interrupt level 7 and 15, FirstFlag
  3518                                  ;	should be set to signal that this interrupt handler is the
  3519                                  ;	first handler hooked to this interrupt vector.		
  3520                                  ;	We determine this by looking at the instruction pointed by
  3521                                  ;	this vector. If it is IRET, then this handler should be the
  3522                                  ;	first one. In our case, only the interrupt vector 77h is the
  3523                                  ;	interrupt level 15. (We don't hook interrupt level 7.)
  3524                                  ; 9/10/1986
  3525                                  ;	The followings are mainly due to M.R.Turner; PTM fix of P886 12/3/86
  3526                                  ;	Some design changes are needed to the above interrupt sharing
  3527                                  ;	method.  The above sharing scheme assumes that 1). Interrupt
  3528                                  ;	sharing is NEVER done on levels that have BIOS support. 2). "Phantom"
  3529                                  ;	interrupts would only be generated on levels 7 and 15.	
  3530                                  ;	These assumptions are not true any more. We have to use the FirstFlag
  3531                                  ;	for EVERY level of interrupt.  We will set the firstFlag on the following
  3532                                  ;	conditions:						
  3533                                  ;	 a.	 if the CS portion of the vector is 0000, then "first" 
  3534                                  ;	 b. else if CS:IP points to valid shared header, then NOT "first"
  3535                                  ;	 c. else if CS:IP points to an IRET, then "first"     
  3536                                  ;	 d. else if CS:IP points to DUMMY, then "first"       
  3537                                  ;	where DUMMY is - the CS portion must be F000, and the IP portion must
  3538                                  ;	be equal to the value at F000:FF01. This location is the initial value
  3539                                  ;	from VECTOR_TABLE for interrupt 7, one of the preserved addresses in all
  3540                                  ;	the BIOSes for all of the machines.			
  3541                                  ;								
  3542                                  ;	System design group requests BIOS to handle the phantom interrupts.
  3543                                  ;								
  3544                                  ;	The "Phantom" interrupt is an illegal interrupt such as an interrupt
  3545                                  ;	produced by the bogus adapter card even without interrupt request is
  3546                                  ;	set.  More specifically, 1). The 8259 has a feature when running in
  3547                                  ;	edge triggered mode to latch a pulse and present the interrupt when
  3548                                  ;	the processor indicates interrupt acknowledge (INTA).  The interrupt
  3549                                  ;	pulse was exist at the time of INTA to get a "phantom" interrupt.
  3550                                  ;	2). or, this is caused by adapter cards placing a glitch on the
  3551                                  ;	interrupt line. 					
  3552                                  ;								
  3553                                  ;	To handle those "phantom" interrupts, the main stack code will check
  3554                                  ;	the own FirstFlag, and if it is not "first" (which means the forward
  3555                                  ;	pointer points to the legal shared interrupt handler), then pass the
  3556                                  ;	control.  If it is the first, then the following action should be
  3557                                  ;	taken.	We don't have to implement skack logic in this case.   
  3558                                  ;								
  3559                                  ;	To implement this logic, we rather choose a simple method.
  3560                                  ;	If ont of the above "FirstFlag" conditions is met, we are not  
  3561                                  ;	going to hook this interrupt vector.  The reason is if the original
  3562                                  ;	vector points to "IRET" and do nothing, we don't need 
  3563                                  ;	to implement the stack logic for it.  This will simplify implementation
  3564                                  ;	while maintaining compatibility with the old version of DOS.
  3565                                  ;	This implies that in the main stack code, there might be a stack code
  3566                                  ;	that will never be used, a dead code.			
  3567                                  ;								
  3568                                  ; 12/3/86							
  3569                                  								
  3570                                  ;In - CS, DS -> sysinitseg, ES -> relocated stack code & data.	
  3571                                  
  3572                                  							
  3573                                  StackInit:
  3574                                  	; 04/07/2018				
  3575                                  								
  3576                                  	;PUSH	AX				;SAVE ALL	
  3577                                  	;PUSH	DS						
  3578                                  	;PUSH	ES						
  3579                                  	;PUSH	BX						
  3580                                  	;PUSH	CX						
  3581                                  	;PUSH	DX						
  3582                                  	;PUSH	DI						
  3583                                  	;PUSH	SI						
  3584                                  	;PUSH	BP						
  3585                                  								
  3586                                  ;Currently ES -> stack code area
  3587                                  	; 19/06/2018				
  3588                                  	;MOV	AX,[cs:STACK_COUNT]		;defined in CS
  3589 00000DC9 A1[0608]                	MOV	AX,[STACK_COUNT]
  3590 00000DCC 26A3[0200]              	MOV	[es:StackCount],AX		;defined in STACK CODE AREA
  3591                                  	;MOV	AX,[cs:STACK_SIZE]		;in CS		
  3592 00000DD0 A1[0808]                	MOV	AX,[STACK_SIZE]
  3593 00000DD3 26A3[0600]              	MOV	[es:StackSize],AX		;		
  3594                                  	;MOV	AX,[cs:STACK_ADDR]		; OFFSET
  3595 00000DD7 A1[0A08]                	MOV	AX,[STACK_ADDR]
  3596 00000DDA 89C5                    	mov	bp,ax	
  3597 00000DDC 26A3[0800]              	MOV	[es:Stacks],AX			
  3598                                  	;MOV	AX,[cs:STACK_ADDR+2]		; SEGMENT	
  3599 00000DE0 A1[0C08]                	MOV	AX,[STACK_ADDR+2]
  3600 00000DE3 26A3[0A00]              	MOV	[es:Stacks+2],AX			
  3601                                  								
  3602                                  ; INITIALIZE THE DATA FIELDS WITH THE PARAMETERS		
  3603                                  								
  3604                                  ; "FIRSTENTRY" WILL ALWAYS BE AT STACKS                       
  3605                                  								
  3606                                  	;MOV	BP,[es:Stacks]			; GET OFFSET OF STACK
  3607 00000DE7 26892E[0C00]            	MOV	[es:FirstEntry],BP				
  3608                                  								
  3609                                  ; THE STACKS WILL ALWAYS IMMEDIATELY FOLLOW THE TABLE ENTRIES	
  3610                                  								
  3611 00000DEC B80800                  	MOV	AX,EntrySize					
  3612 00000DEF 268B0E[0200]            	MOV	CX,[es:StackCount]		
  3613 00000DF4 F7E1                    	MUL	CX					
  3614 00000DF6 01E8                    	ADD	AX,BP						
  3615 00000DF8 26A3[0400]              	MOV	[es:StackAt],AX					
  3616 00000DFC 89C3                    	MOV	BX,AX						
  3617 00000DFE 83EB02                  	SUB	BX,2						
  3618                                  								
  3619                                  ; ZERO THE ENTIRE STACK AREA TO START WITH			
  3620                                  								
  3621 00000E01 268B3E[0400]            	MOV	DI,[es:StackAt]					
  3622 00000E06 26A1[0600]              	MOV	AX,[es:StackSize] 				
  3623 00000E0A F7E1                    	MUL	CX						
  3624 00000E0C 89C1                    	MOV	CX,AX						
  3625 00000E0E 31C0                    	xor	ax,ax						
  3626 00000E10 06                      	push	es						
  3627 00000E11 1F                      	pop	ds				;ds = Relocated stack code seg.
  3628                                  	;assume	ds:nothing					
  3629                                  ;Now, DS -> stack code area					
  3630 00000E12 8E06[0A00]              	MOV	ES,[Stacks+2]			; GET SEGMENT OF STACK AREA.
  3631 00000E16 FC                      	CLD							
  3632 00000E17 F3AA                    	REP	STOSB						
  3633                                  								
  3634 00000E19 8B0E[0200]              	MOV	CX,[StackCount]				
  3635                                  								
  3636                                  ; LOOP FOR "COUNT" TIMES, BUILDING A TABLE ENTRY              
  3637                                  ;  cs = sysinitseg, ds = Relocated stack code seg, es = segment of stack space
  3638                                  ;  CX = NUMBER OF ENTRIES					
  3639                                  ;  ES:BP => BASE OF STACKS - 2					
  3640                                  ;  ES:BX => FIRST TABLE ENTRY					
  3641                                  								
  3642                                  BUILDLOOP:							
  3643 00000E1D 26C6460000              	MOV	AllocByte,Free					
  3644 00000E22 26884601                	MOV	IntLevel,AL			;AX = 0 	
  3645 00000E26 26894602                	MOV	SavedSP,AX					
  3646 00000E2A 26894604                	MOV	SavedSS,AX					
  3647 00000E2E 031E[0600]              	ADD	BX,[StackSize] 				
  3648 00000E32 26895E06                	MOV	NewSP,BX					
  3649 00000E36 26892F                  	MOV	[ES:BX],BP					
  3650 00000E39 83C508                  	ADD	BP,EntrySize					
  3651                                  								
  3652 00000E3C E2DF                    	LOOP	BUILDLOOP					
  3653                                  								
  3654 00000E3E 83ED08                  	SUB	BP,EntrySize					
  3655 00000E41 892E[0E00]              	MOV	[LastEntry],BP 				
  3656 00000E45 892E[1000]              	MOV	[NextEntry],BP 				
  3657                                  								
  3658 00000E49 1E                      	push	ds ; (((*)))
  3659                                  						
  3660 00000E4A B800F0                  	mov	ax, 0F000h			;loook at the model byte
  3661 00000E4D 8ED8                    	mov	ds, ax						
  3662 00000E4F 803EFEFFF9              	cmp	byte [0FFFEh],0F9h		;convertible?(P12)
  3663 00000E54 1F                      	pop	ds						
  3664 00000E55 7504                    	jne	short Skip_DisableNMIS				
  3665                                  								
  3666 00000E57 B007                    	MOV	AL,07H				; DISABLE P12 NMIS
  3667 00000E59 E672                    	OUT	72H,AL						
  3668                                  								
  3669                                  Skip_DisableNMIS:						
  3670 00000E5B 31C0                    	XOR	AX,AX						
  3671 00000E5D 8EC0                    	MOV	ES,AX				;es - SEGID OF VECTOR TABLE AT 0
  3672                                  	;ASSUME	ES:NOTHING			;ds - Relocated Stack code segment
  3673                                  								
  3674 00000E5F FA                      	CLI							
  3675                                  								
  3676                                  	;IRP	AA,<02,08,09,70>				
  3677                                  	;						
  3678                                  	;MOV	SI,AA&H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3679                                  	;mov	di,offset Int19OLD&AA	;we have to set OLD&AA for Int19 handler too.
  3680                                  	;MOV	BX,OFFSET OLD&AA	;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3681                                  	;MOV	DX,OFFSET INT&AA	;PASS WHERE NEW HANDLER IS
  3682                                  	;CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER,
  3683                                  	;				;  SAVING POINTER TO ORIGINAL OWNER
  3684                                  	;ENDM
  3685                                  
  3686                                          ; ***
  3687 00000E60 BE0800                  	mov	si,02h*4
  3688 00000E63 BF3818                  	mov	di,INT19OLD02 
  3689 00000E66 BB[1200]                	MOV	BX,Old02		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3690 00000E69 BA[1600]                	MOV	DX,Int02		;PASS WHERE NEW HANDLER IS
  3691 00000E6C E86902                  	CALL	NEW_INIT_LOOP
  3692                                  						
  3693 00000E6F BE2000                  	mov	si,08h*4
  3694 00000E72 BF3C18                  	mov	di,INT19OLD08 
  3695 00000E75 BB[A600]                	MOV	BX,Old08
  3696 00000E78 BA[AA00]                	MOV	DX,Int08
  3697 00000E7B E85A02                  	CALL	NEW_INIT_LOOP
  3698                                  
  3699 00000E7E BE2400                  	mov	si,09h*4
  3700 00000E81 BF4018                  	mov	di,INT19OLD09
  3701 00000E84 BB[2001]                	MOV	BX,Old09
  3702 00000E87 BA[2401]                	MOV	DX,Int09
  3703 00000E8A E84B02                  	CALL	NEW_INIT_LOOP
  3704                                  
  3705 00000E8D BEC001                  	mov	si,70h*4
  3706 00000E90 BF5818                  	mov	di,INT19OLD70
  3707 00000E93 BB[9E01]                	MOV	BX,Old70
  3708 00000E96 BA[A201]                	MOV	DX,Int70
  3709 00000E99 E83C02                  	CALL	NEW_INIT_LOOP
  3710                                  
  3711                                  	; ***
  3712                                  								
  3713                                  	;IRP	AA,<0A,0B,0C,0D,0E,72,73,74,76,77>	;shared interrupts
  3714                                  								
  3715                                  	;MOV	SI,AA&H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3716                                  	;push	ds			;save relocated stack code segment
  3717                                  	;lds	bx, es:[si]		;ds:bx -> original interrupt handler
  3718                                  	;push	ds						
  3719                                  	;pop	dx			;dx = segment value	
  3720                                  
  3721                                  	;cmp	dx,0
  3722                                  	;jz	int&AA&_first
  3723                                  
  3724                                  	;cmp	byte ptr ds:[bx],0cfh	;Does vector point to an IRET?
  3725                                  	;jz	int&AA&_first
  3726                                  
  3727                                  	;cmp	word ptr ds:[bx.6],424Bh ;Magic offset (see INT&AA, msstack.inc)
  3728                                  	;jz	int&AA&_Not_first
  3729                                  
  3730                                  	;cmp	dx,0f000h		;ROM BIOS segment
  3731                                  	;jnz	int&AA&_Not_first
  3732                                  
  3733                                  	;push	es
  3734                                  	;push	dx
  3735                                  	;mov	dx,0f000h
  3736                                  	;mov	es,dx
  3737                                  	;cmp	bx,word ptr es:0ff01h
  3738                                         	;pop	dx
  3739                                  	;pop	es
  3740                                  	;jz	int&AA&_first
  3741                                  
  3742                                  ;int&AA&_Not_first:			;Not the first. We are going to hook vector.
  3743                                  	;pop	ds						
  3744                                  	;mov	di, offset Int19OLD&AA	;we have to set OLD&AA for Int19 handler too.
  3745                                  	;mov	BX, OFFSET OLD&AA	;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3746                                  	;MOV	DX, OFFSET INT&AA	;PASS WHERE NEW HANDLER IS
  3747                                  	;CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3748                                  					;POINTER TO ORIGINAL OWNER.
  3749                                  	;jmp	short int&AA&_end				
  3750                                  ;int&AA&_first:				;the first. Don't have to hook stack code.
  3751                                  	;pop	ds						
  3752                                  ;int&AA&_end:							
  3753                                  								
  3754                                  	;ENDM	
  3755                                  
  3756                                  	; ****
  3757                                  
  3758                                  	; 19/06/2018 - Retro DOS v3.0 (IBMDOS 3.3, IBMBIO.COM, SYSINIT)
  3759                                  							
  3760 00000E9C BE2800                  	MOV	SI,0AH*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3761 00000E9F 1E                      	push	ds			;save relocated stack code segment
  3762 00000EA0 26C51C                  	lds	bx,[es:si]		;ds:bx -> original interrupt handler
  3763 00000EA3 1E                      	push	ds						
  3764 00000EA4 5A                      	pop	dx			;dx = segment value	
  3765                                  
  3766 00000EA5 83FA00                  	cmp	dx,0
  3767 00000EA8 7427                    	jz	short int0A_first
  3768                                  
  3769 00000EAA 803FCF                  	cmp	byte [bx],0CFh		;Does vector point to an IRET?
  3770 00000EAD 7422                    	jz	short int0A_first
  3771                                  
  3772 00000EAF 817F064B42              	cmp	word [bx+6],424Bh	;Magic offset (see INT&AA, msstack.inc)
  3773 00000EB4 740C                    	jz	short int0A_Not_first
  3774                                  
  3775 00000EB6 81FA00F0                	cmp	dx,0F000h		;ROM BIOS segment
  3776 00000EBA 7506                    	jnz	short int0A_Not_first
  3777                                  
  3778 00000EBC 3B1E01FF                	cmp	bx,[0FF01h]
  3779 00000EC0 740F                    	jz	short int0A_first
  3780                                  
  3781                                  int0A_Not_first:			;Not the first. We are going to hook vector.
  3782 00000EC2 1F                      	pop	ds ; (((*)))						
  3783 00000EC3 BF4418                  	mov	di,INT19OLD0A		;we have to set OLD&AA for Int19 handler too.
  3784 00000EC6 BB[1A02]                	MOV	BX,Old0A		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3785 00000EC9 BA[1802]                	MOV	DX,Int0A		;PASS WHERE NEW HANDLER IS
  3786 00000ECC E80902                  	CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3787                                  					;POINTER TO ORIGINAL OWNER.
  3788 00000ECF EB01                    	jmp	short int0A_end				
  3789                                  int0A_first:				;the first. Don't have to hook stack code.
  3790 00000ED1 1F                      	pop	ds ; (((*)))						
  3791                                  int0A_end:							
  3792 00000ED2 BE2C00                  	MOV	SI,0BH*4
  3793 00000ED5 1E                      	push	ds
  3794 00000ED6 26C51C                  	lds	bx,[es:si]
  3795 00000ED9 1E                      	push	ds						
  3796 00000EDA 5A                      	pop	dx
  3797                                  
  3798 00000EDB 83FA00                  	cmp	dx,0
  3799 00000EDE 7427                    	jz	short int0B_first
  3800                                  
  3801 00000EE0 803FCF                  	cmp	byte [bx],0CFh
  3802 00000EE3 7422                    	jz	short int0B_first
  3803                                  
  3804 00000EE5 817F064B42              	cmp	word [bx+6],424Bh
  3805 00000EEA 740C                    	jz	short int0B_Not_first
  3806                                  
  3807 00000EEC 81FA00F0                	cmp	dx,0F000h
  3808 00000EF0 7506                    	jnz	short int0B_Not_first
  3809                                  
  3810 00000EF2 3B1E01FF                	cmp	bx,[0FF01h]
  3811 00000EF6 740F                    	jz	short int0B_first
  3812                                  
  3813                                  int0B_Not_first:
  3814 00000EF8 1F                      	pop	ds						
  3815 00000EF9 BF4818                  	mov	di,INT19OLD0B
  3816 00000EFC BB[A202]                	MOV	BX,Old0B
  3817 00000EFF BA[A002]                	MOV	DX,Int0B
  3818 00000F02 E8D301                  	CALL	NEW_INIT_LOOP
  3819 00000F05 EB01                    	jmp	short int0B_end				
  3820                                  int0B_first:
  3821 00000F07 1F                      	pop	ds						
  3822                                  int0B_end:															
  3823 00000F08 BE3000                  	MOV	SI,0CH*4
  3824 00000F0B 1E                      	push	ds
  3825 00000F0C 26C51C                  	lds	bx,[es:si]
  3826 00000F0F 1E                      	push	ds						
  3827 00000F10 5A                      	pop	dx
  3828                                  
  3829 00000F11 83FA00                  	cmp	dx,0
  3830 00000F14 7427                    	jz	short int0C_first
  3831                                  
  3832 00000F16 803FCF                  	cmp	byte [bx],0CFh
  3833 00000F19 7422                    	jz	short int0C_first
  3834                                  
  3835 00000F1B 817F064B42              	cmp	word [bx+6],424Bh
  3836 00000F20 740C                    	jz	short int0C_Not_first
  3837                                  
  3838 00000F22 81FA00F0                	cmp	dx,0F000h
  3839 00000F26 7506                    	jnz	short int0C_Not_first
  3840                                  
  3841 00000F28 3B1E01FF                	cmp	bx,[0FF01h]
  3842 00000F2C 740F                    	jz	short int0C_first
  3843                                  
  3844                                  int0C_Not_first:
  3845 00000F2E 1F                      	pop	ds						
  3846 00000F2F BF4C18                  	mov	di,INT19OLD0C
  3847 00000F32 BB[2A03]                	MOV	BX,Old0C
  3848 00000F35 BA[2803]                	MOV	DX,Int0C
  3849 00000F38 E89D01                  	CALL	NEW_INIT_LOOP
  3850 00000F3B EB01                    	jmp	short int0C_end				
  3851                                  int0C_first:
  3852 00000F3D 1F                      	pop	ds						
  3853                                  int0C_end:		
  3854 00000F3E BE3400                  	MOV	SI,0DH*4
  3855 00000F41 1E                      	push	ds
  3856 00000F42 26C51C                  	lds	bx,[es:si]
  3857 00000F45 1E                      	push	ds						
  3858 00000F46 5A                      	pop	dx
  3859                                  
  3860 00000F47 83FA00                  	cmp	dx,0
  3861 00000F4A 7427                    	jz	short int0D_first
  3862                                  
  3863 00000F4C 803FCF                  	cmp	byte [bx],0CFh
  3864 00000F4F 7422                    	jz	short int0D_first
  3865                                  
  3866 00000F51 817F064B42              	cmp	word [bx+6],424Bh
  3867 00000F56 740C                    	jz	short int0D_Not_first 	
  3868                                  
  3869 00000F58 81FA00F0                	cmp	dx,0F000h
  3870 00000F5C 7506                    	jnz	short int0D_Not_first
  3871                                  
  3872 00000F5E 3B1E01FF                	cmp	bx,[0FF01h]
  3873 00000F62 740F                    	jz	short int0D_first
  3874                                  
  3875                                  int0D_Not_first:
  3876 00000F64 1F                      	pop	ds						
  3877 00000F65 BF5018                  	mov	di,INT19OLD0D
  3878 00000F68 BB[B203]                	MOV	BX,Old0D
  3879 00000F6B BA[B003]                	MOV	DX,Int0D
  3880 00000F6E E86701                  	CALL	NEW_INIT_LOOP
  3881 00000F71 EB01                    	jmp	short int0D_end				
  3882                                  int0D_first:
  3883 00000F73 1F                      	pop	ds						
  3884                                  int0D_end:
  3885 00000F74 BE3800                  	MOV	SI,0EH*4
  3886 00000F77 1E                      	push	ds
  3887 00000F78 26C51C                  	lds	bx,[es:si]
  3888 00000F7B 1E                      	push	ds						
  3889 00000F7C 5A                      	pop	dx
  3890                                  
  3891 00000F7D 83FA00                  	cmp	dx,0
  3892 00000F80 7427                    	jz	short int0E_first
  3893                                  
  3894 00000F82 803FCF                  	cmp	byte [bx],0CFh
  3895 00000F85 7422                    	jz	short int0E_first
  3896                                  
  3897 00000F87 817F064B42              	cmp	word [bx+6],424Bh
  3898 00000F8C 740C                    	jz	short int0E_Not_first
  3899                                  
  3900 00000F8E 81FA00F0                	cmp	dx,0F000h
  3901 00000F92 7506                    	jnz	short int0E_Not_first
  3902                                  
  3903 00000F94 3B1E01FF                	cmp	bx,[0FF01h]
  3904 00000F98 740F                    	jz	short int0E_first
  3905                                  
  3906                                  int0E_Not_first:
  3907 00000F9A 1F                      	pop	ds						
  3908 00000F9B BF5418                  	mov	di,INT19OLD0E
  3909 00000F9E BB[3A04]                	MOV	BX,Old0E
  3910 00000FA1 BA[3804]                	MOV	DX,Int0E
  3911 00000FA4 E83101                  	CALL	NEW_INIT_LOOP
  3912 00000FA7 EB01                    	jmp	short int0E_end				
  3913                                  int0E_first:
  3914 00000FA9 1F                      	pop	ds						
  3915                                  int0E_end:
  3916 00000FAA BEC801                  	MOV	SI,72H*4		;PASS WHERE VECTOR IS TO BE ADJUSTED
  3917 00000FAD 1E                      	push	ds			;save relocated stack code segment
  3918 00000FAE 26C51C                  	lds	bx,[es:si]		;ds:bx -> original interrupt handler
  3919 00000FB1 1E                      	push	ds						
  3920 00000FB2 5A                      	pop	dx			;dx = segment value	
  3921                                  
  3922 00000FB3 83FA00                  	cmp	dx,0
  3923 00000FB6 7427                    	jz	short int72_first
  3924                                  
  3925 00000FB8 803FCF                  	cmp	byte [bx],0CFh		;Does vector point to an IRET?
  3926 00000FBB 7422                    	jz	short int72_first
  3927                                  
  3928 00000FBD 817F064B42              	cmp	word [bx+6],424Bh	;Magic offset (see INT&AA, msstack.inc)
  3929 00000FC2 740C                    	jz	short int72_Not_first
  3930                                  
  3931 00000FC4 81FA00F0                	cmp	dx,0F000h		;ROM BIOS segment
  3932 00000FC8 7506                    	jnz	short int72_Not_first
  3933                                  
  3934 00000FCA 3B1E01FF                	cmp	bx,[0FF01h]
  3935 00000FCE 740F                    	jz	short int72_first
  3936                                  
  3937                                  int72_Not_first:			;Not the first. We are going to hook vector.
  3938 00000FD0 1F                      	pop	ds						
  3939 00000FD1 BF5C18                  	mov	di,INT19OLD72		;we have to set OLD&AA for Int19 handler too.
  3940 00000FD4 BB[C204]                	MOV	BX,Old72		;PASS WHERE TO SAVE ORIGINAL OWNER POINTER
  3941 00000FD7 BA[C004]                	MOV	DX,Int72		;PASS WHERE NEW HANDLER IS
  3942 00000FDA E8FB00                  	CALL	NEW_INIT_LOOP		;ADJUST THE VECTOR TO NEW HANDLER, SAVING
  3943                                  					;POINTER TO ORIGINAL OWNER.
  3944 00000FDD EB01                    	jmp	short int72_end				
  3945                                  int72_first:				;the first. Don't have to hook stack code.
  3946 00000FDF 1F                      	pop	ds						
  3947                                  int72_end:							
  3948 00000FE0 BECC01                  	MOV	SI,73H*4
  3949 00000FE3 1E                      	push	ds
  3950 00000FE4 26C51C                  	lds	bx,[es:si]
  3951 00000FE7 1E                      	push	ds						
  3952 00000FE8 5A                      	pop	dx
  3953                                  
  3954 00000FE9 83FA00                  	cmp	dx,0
  3955 00000FEC 7427                    	jz	short int73_first
  3956                                  
  3957 00000FEE 803FCF                  	cmp	byte [bx],0CFh
  3958 00000FF1 7422                    	jz	short int73_first
  3959                                  
  3960 00000FF3 817F064B42              	cmp	word [bx+6],424Bh
  3961 00000FF8 740C                    	jz	short int73_Not_first
  3962                                  
  3963 00000FFA 81FA00F0                	cmp	dx,0F000h
  3964 00000FFE 7506                    	jnz	short int73_Not_first
  3965                                  
  3966 00001000 3B1E01FF                	cmp	bx,[0FF01h]
  3967 00001004 740F                    	jz	short int73_first
  3968                                  
  3969                                  int73_Not_first:
  3970 00001006 1F                      	pop	ds						
  3971 00001007 BF6018                  	mov	di,INT19OLD73
  3972 0000100A BB[4A05]                	MOV	BX,Old73
  3973 0000100D BA[4805]                	MOV	DX,Int73
  3974 00001010 E8C500                  	CALL	NEW_INIT_LOOP
  3975 00001013 EB01                    	jmp	short int73_end				
  3976                                  int73_first:
  3977 00001015 1F                      	pop	ds						
  3978                                  int73_end:															
  3979 00001016 BED001                  	MOV	SI,74H*4
  3980 00001019 1E                      	push	ds
  3981 0000101A 26C51C                  	lds	bx,[es:si]
  3982 0000101D 1E                      	push	ds						
  3983 0000101E 5A                      	pop	dx
  3984                                  
  3985 0000101F 83FA00                  	cmp	dx,0
  3986 00001022 7427                    	jz	short int74_first
  3987                                  
  3988 00001024 803FCF                  	cmp	byte [bx],0CFh
  3989 00001027 7422                    	jz	short int74_first
  3990                                  
  3991 00001029 817F064B42              	cmp	word [bx+6],424Bh
  3992 0000102E 740C                    	jz	short int74_Not_first
  3993                                  
  3994 00001030 81FA00F0                	cmp	dx,0F000h
  3995 00001034 7506                    	jnz	short int74_Not_first
  3996                                  
  3997 00001036 3B1E01FF                	cmp	bx,[0FF01h]
  3998 0000103A 740F                    	jz	short int74_first
  3999                                  
  4000                                  int74_Not_first:
  4001 0000103C 1F                      	pop	ds						
  4002 0000103D BF6418                  	mov	di,INT19OLD74
  4003 00001040 BB[D205]                	MOV	BX,Old74
  4004 00001043 BA[D005]                	MOV	DX,Int74
  4005 00001046 E88F00                  	CALL	NEW_INIT_LOOP
  4006 00001049 EB01                    	jmp	short int74_end				
  4007                                  int74_first:
  4008 0000104B 1F                      	pop	ds						
  4009                                  int74_end:		
  4010 0000104C BED801                  	MOV	SI,76H*4
  4011 0000104F 1E                      	push	ds
  4012 00001050 26C51C                  	lds	bx,[es:si]
  4013 00001053 1E                      	push	ds						
  4014 00001054 5A                      	pop	dx
  4015                                  
  4016 00001055 83FA00                  	cmp	dx,0
  4017 00001058 7427                    	jz	short int76_first
  4018                                  
  4019 0000105A 803FCF                  	cmp	byte [bx],0CFh
  4020 0000105D 7422                    	jz	short int76_first
  4021                                  
  4022 0000105F 817F064B42              	cmp	word [bx+6],424Bh
  4023 00001064 740C                    	jz	short int76_Not_first
  4024                                  
  4025 00001066 81FA00F0                	cmp	dx,0F000h
  4026 0000106A 7506                    	jnz	short int76_Not_first
  4027                                  
  4028 0000106C 3B1E01FF                	cmp	bx,[0FF01h]
  4029 00001070 740F                    	jz	short int76_first
  4030                                  
  4031                                  int76_Not_first:
  4032 00001072 1F                      	pop	ds						
  4033 00001073 BF6818                  	mov	di,INT19OLD76
  4034 00001076 BB[5A06]                	MOV	BX,Old76
  4035 00001079 BA[5806]                	MOV	DX,Int76
  4036 0000107C E85900                  	CALL	NEW_INIT_LOOP
  4037 0000107F EB01                    	jmp	short int76_end				
  4038                                  int76_first:
  4039 00001081 1F                      	pop	ds						
  4040                                  int76_end:
  4041 00001082 BEDC01                  	MOV	SI,77H*4
  4042 00001085 1E                      	push	ds
  4043 00001086 26C51C                  	lds	bx,[es:si]
  4044 00001089 1E                      	push	ds						
  4045 0000108A 5A                      	pop	dx
  4046                                  
  4047 0000108B 83FA00                  	cmp	dx,0
  4048 0000108E 7427                    	jz	short int77_first
  4049                                  
  4050 00001090 803FCF                  	cmp	byte [bx],0CFh
  4051 00001093 7422                    	jz	short int77_first
  4052                                  
  4053 00001095 817F064B42              	cmp	word [bx+6],424Bh
  4054 0000109A 740C                    	jz	short int77_Not_first
  4055                                  
  4056 0000109C 81FA00F0                	cmp	dx,0F000h
  4057 000010A0 7506                    	jnz	short int77_Not_first
  4058                                  
  4059 000010A2 3B1E01FF                	cmp	bx,[0FF01h]
  4060 000010A6 740F                    	jz	short int77_first
  4061                                  
  4062                                  int77_Not_first:
  4063 000010A8 1F                      	pop	ds						
  4064 000010A9 BF6C18                  	mov	di,INT19OLD77
  4065 000010AC BB[E206]                	MOV	BX,Old77
  4066 000010AF BA[E006]                	MOV	DX,Int77
  4067 000010B2 E82300                  	CALL	NEW_INIT_LOOP
  4068 000010B5 EB01                    	jmp	short int77_end				
  4069                                  int77_first:
  4070 000010B7 1F                      	pop	ds						
  4071                                  int77_end:
  4072                                  
  4073                                  	; ****					
  4074                                  								
  4075 000010B8 1E                      	push	ds						
  4076 000010B9 B800F0                  	mov	ax,0F000h		;loook at the model byte
  4077 000010BC 8ED8                    	mov	ds,ax						
  4078 000010BE 803EFEFFF9              	cmp	byte [0FFFEh],0F9h	;convertible?(P12)
  4079 000010C3 1F                      	pop	ds						
  4080 000010C4 7504                    	jne	short Skip_EnableNMIS 				
  4081                                  								
  4082 000010C6 B027                    	MOV	AL,27H			; ENABLE P12 NMIS
  4083 000010C8 E672                    	OUT	72H,AL						
  4084                                  								
  4085                                  Skip_EnableNMIS:						
  4086 000010CA FB                      	STI							
  4087                                  	;MOV	AX,code 					
  4088 000010CB B87000                  	mov	ax,KERNEL_SEGMENT
  4089 000010CE 8ED8                    	MOV	DS,AX						
  4090                                  	;ASSUME	DS:CODE 					
  4091                                  								
  4092                                  ;	MOV	SI,OFFSET STKMSG1				
  4093                                  ;	CALL	WRMSG						
  4094                                  								
  4095 000010D0 C606321801              	mov	byte [INT19SEM],1	; INDICATE THAT INT 19	
  4096                                  					; INITIALIZATION IS COMPLETE
  4097                                  
  4098                                  	; 04/07/2018
  4099 000010D5 0E                      	push	cs
  4100 000010D6 1F                      	pop	ds
  4101                                  								
  4102                                  	;POP	BP			; RESTORE ALL		
  4103                                  	;POP	SI						
  4104                                  	;POP	DI						
  4105                                  	;POP	DX						
  4106                                  	;POP	CX						
  4107                                  	;POP	BX						
  4108                                  	;POP	ES						
  4109                                  	;POP	DS						
  4110                                  	;assume	ds:sysinitseg					
  4111                                  	;POP	AX						
  4112 000010D7 C3                      	RETN							
  4113                                  ;								
  4114                                  								
  4115                                  NEW_INIT_LOOP:				
  4116                                  ;INPUT: SI=OFSET INTO VECTOR TABLE OF THE PARTICULAR INT VECTOR BEING ADJUSTED
  4117                                  ;	BX=ds:OFFSET OF OLDxx, WHERE WILL BE SAVED THE POINTER TO ORIGINAL OWNER
  4118                                  ;	DX=ds:OFFSET OF INTxx, THE NEW INTERRUPT HANDLER	
  4119                                  ;	di=offset value of Int19OLD&AA variable in BIOS.	
  4120                                  ;	es=ZERO, SEGID OF VECTOR TABLE				
  4121                                  ;	ds=Relocated Stack code segment 			
  4122                                  								
  4123                                  	;mov	ax,[es:si+0]	   	;REMEMBER OFFSET IN VECTOR
  4124 000010D8 268B04                  	mov	ax,[es:si]
  4125 000010DB 8907                    	mov	[bx],ax			; TO ORIGINAL OWNER in DS
  4126 000010DD 268B4402                	mov	ax,[es:si+2]		;REMEMBER SEGID IN VECTOR
  4127 000010E1 894702                  	mov	[bx+2],ax		; TO ORIGINAL OWNER in DS
  4128 000010E4 1E                      	push	ds						
  4129                                  	;mov	ax,code
  4130 000010E5 B87000                  	mov	ax,KERNEL_SEGMENT					
  4131 000010E8 8ED8                    	mov	ds,ax			;Set Int19OLDxx value in BIOS for
  4132                                  	;mov	ax,[es:si+0]		;Int 19 handler 
  4133 000010EA 268B04                  	mov	ax,[es:si]	
  4134 000010ED 8905                    	mov	[di],ax				
  4135 000010EF 268B4402                	mov	ax,[es:si+2]					
  4136 000010F3 894502                  	mov	[di+2],ax				
  4137 000010F6 1F                      	pop	ds						
  4138                                  								
  4139                                  	;mov	[es:si+0],dx		;SET VECTOR TO POINT TO NEW INT HANDLER
  4140 000010F7 268914                  	mov	[es:si],dx
  4141 000010FA 268C5C02                	mov	[es:si+2],ds					
  4142 000010FE C3                      	retn							
  4143                                  
  4144                                  ;SYSINITSEG	ENDS
  4145                                  ;	END
  4146                                  
  4147                                  ;align 16 ; 19/06/2018
  4148                                  
  4149                                  ; ----------------------------------------------------------------------
  4150                                  ; SYSCONF.ASM - MSDOS 3.3 - 24/07/1987
  4151                                  ; ----------------------------------------------------------------------
  4152                                  ; 10/06/2018 - Retro DOS v3.0
  4153                                  ; 25/03/2018 - Retro DOS v2.0
  4154                                  
  4155                                  ;	IF	STACKSW
  4156                                  ;;
  4157                                  ;; Internal Stack Parameters
  4158                                  ;EntrySize		equ	8
  4159                                  ;
  4160                                  ;MinCount		equ	8
  4161                                  ;DefaultCount		equ	9
  4162                                  ;MaxCount		equ	64
  4163                                  ;
  4164                                  ;MinSize 		equ	32
  4165                                  ;DefaultSize		equ	128
  4166                                  ;MaxSize 		equ	512
  4167                                  ;
  4168                                  ;	extrn  stack_count:word
  4169                                  ;	extrn  stack_size:word
  4170                                  ;	extrn  stack_addr:dword
  4171                                  ;
  4172                                  ;	ENDIF
  4173                                  
  4174                                  DOCONF: 		;Take care of Config.sys file.
  4175                                  	
  4176                                  	; 10/06/2018 - Retro DOS v3.0	
  4177                                  	
  4178 000010FF 0E                      	PUSH    CS
  4179 00001100 1F                              POP     DS
  4180                                  
  4181                                  	; 13/04/2018 - Retro DOS v2.0
  4182                                  	
  4183 00001101 B80037                  	MOV     AX,(CHAR_OPER*256)	; GET SWITCH CHARACTER
  4184 00001104 CD21                    	INT     21H
  4185 00001106 8816[2008]              	MOV     [COMMAND_LINE+1],DL
  4186                                  
  4187 0000110A BA[BC1B]                        MOV     DX,CONFIG		; NOW POINTING TO FILE DESCRIPTION
  4188 0000110D B8003D                          MOV     AX,(OPEN*256)		; OPEN FILE "CONFIG.SYS"
  4189 00001110 F9                              STC				; IN CASE OF INT 24
  4190 00001111 CD21                            INT     21H                     ; FUNCTION REQUEST
  4191                                          ;JC     SHORT ENDCONF
  4192                                          ;JMP    NOPROB			; PROBLEM WITH OPEN
  4193 00001113 730A                    	JNC	short NOPROB
  4194                                  
  4195                                  ENDCONF:
  4196 00001115 C3                      	RETN
  4197                                  
  4198                                  BADOP:  
  4199 00001116 BA[541D]                	MOV     DX,BADOPM		; WANT TO PRINT COMMAND ERROR
  4200 00001119 E8270A                          CALL    PRINT
  4201 0000111C E98500                          JMP     COFF
  4202                                  
  4203                                  NOPROB:
  4204                                  					; GET FILE SIZE (NOTE < 64K!!)
  4205 0000111F 89C3                    	MOV     BX,AX
  4206 00001121 31C9                            XOR     CX,CX
  4207 00001123 31D2                            XOR     DX,DX
  4208 00001125 B80242                          MOV     AX,(LSEEK*256)+2
  4209 00001128 CD21                            INT     21H
  4210 0000112A A3[5108]                        MOV     [COUNT],AX
  4211 0000112D 31D2                            XOR     DX,DX
  4212 0000112F B80042                          MOV     AX,(LSEEK*256)		; Reset pointer to beginning of file
  4213 00001132 CD21                            INT     21H
  4214                                          
  4215 00001134 8CCA                    	MOV     DX,CS
  4216 00001136 A1[5108]                        MOV     AX,[COUNT]
  4217 00001139 E881FC                          call	ParaRound
  4218 0000113C 29C2                            SUB     DX,AX
  4219 0000113E 83EA11                          SUB     DX,11H                  ; ROOM FOR HEADER
  4220 00001141 8916[1708]              	MOV	[CONFBOT],DX		; Config starts here
  4221 00001145 E8AFF9                  	CALL	TEMPCDS 		; Finally get CDS to "safe" location
  4222                                  
  4223 00001148 2E8B16[1708]                    MOV	DX,[CS:CONFBOT] ; 19/06/2018
  4224 0000114D 8EDA                            MOV     DS,DX
  4225 0000114F 8EC2                            MOV     ES,DX
  4226 00001151 31D2                            XOR     DX,DX
  4227 00001153 2E8B0E[5108]            	MOV	CX,[CS:COUNT] ; 19/06/2018
  4228 00001158 B43F                            MOV     AH,READ
  4229 0000115A F9                              STC                             ; IN CASE OF INT 24
  4230 0000115B CD21                            INT     21H                     ; Function request
  4231 0000115D 9C                              PUSHF
  4232                                  ;
  4233                                  ; Find the EOF mark in the file. If present, then trim length.
  4234                                  ;	
  4235 0000115E 50                      	PUSH	AX
  4236 0000115F 57                      	PUSH	DI
  4237 00001160 51                      	PUSH	CX
  4238 00001161 B01A                    	MOV	AL,1Ah			; eof mark
  4239 00001163 89D7                    	MOV	DI,DX			; point ro buffer
  4240 00001165 E305                    	JCXZ	PUTEOL			; no chars
  4241 00001167 F2AE                    	REPNZ	SCASB			; find end
  4242 00001169 7501                    	JNZ	SHORT PUTEOL		; none found and count exahusted
  4243                                  ;
  4244                                  ; We found a 1A. Back up
  4245                                  ;
  4246 0000116B 4F                      	DEC	DI			; backup past 1A
  4247                                  ;
  4248                                  ;  Just for the halibut, stick in an extra EOL
  4249                                  ;
  4250                                  PUTEOL:
  4251 0000116C B00D                    	MOV	AL,13
  4252 0000116E AA                      	STOSB				; CR
  4253 0000116F B00A                    	MOV	AL,10
  4254 00001171 AA                      	STOSB				; LF
  4255 00001172 29D7                    	SUB	DI,DX			; difference moved
  4256                                  	; 19/06/2018
  4257 00001174 2E893E[5108]            	MOV	[CS:COUNT],DI		; new count
  4258                                  ;
  4259                                  ; Restore registers
  4260                                  ;
  4261 00001179 59                      	POP	CX
  4262 0000117A 5F                      	POP	DI
  4263 0000117B 58                      	POP	AX
  4264                                  
  4265 0000117C 0E                              PUSH	CS
  4266 0000117D 1F                              POP	DS
  4267                                  
  4268 0000117E 50                              PUSH    AX
  4269 0000117F B43E                            MOV     AH,CLOSE
  4270 00001181 CD21                            INT     21H
  4271 00001183 58                              POP     AX
  4272 00001184 9D                              POPF
  4273 00001185 7204                            JC      SHORT CONFERR		; IF NOT WE'VE GOT A PROBLEM
  4274 00001187 39C1                            CMP     CX,AX
  4275 00001189 7407                            JZ      SHORT GETCOM		; COULDN'T READ THE FILE
  4276                                  CONFERR:
  4277 0000118B BA[BC1B]                        MOV     DX,CONFIG		; WANT TO PRINT CONFIG ERROR
  4278 0000118E E89409                          CALL    BADFIL
  4279                                  ENDCONV:
  4280                                  	;JMP	ENDCONF
  4281 00001191 C3                      	RETN
  4282                                  
  4283                                  GETCOM:
  4284 00001192 E84006                          CALL    ORGANIZE                ; ORGANIZE THE FILE
  4285 00001195 E88404                          CALL    GETCHR
  4286                                  
  4287 00001198 72F7                    CONFLP: JC      SHORT ENDCONV
  4288 0000119A 88C4                            MOV     AH,AL
  4289 0000119C E87D04                          CALL    GETCHR
  4290 0000119F 730A                    	JNC	SHORT TRYB
  4291 000011A1 E972FF                  	JMP	BADOP
  4292                                  
  4293                                  COFF:   
  4294 000011A4 0E                      	PUSH    CS
  4295 000011A5 1F                              POP     DS
  4296 000011A6 E8DF06                          CALL    NEWLINE
  4297 000011A9 EBED                            JMP     SHORT CONFLP
  4298                                  
  4299                                  ;------------------------------------------------------------------------------
  4300                                  ; Buffer command
  4301                                  ;------------------------------------------------------------------------------
  4302                                  TRYB:	
  4303 000011AB 80FC42                  	CMP     AH,'B'                  ; BUFFER COMMAND?
  4304 000011AE 7512                            JNZ     SHORT TRYC
  4305 000011B0 E88807                          CALL    GETNUM
  4306 000011B3 7405                            JZ      SHORT TRYBBAD
  4307 000011B5 83F864                          CMP     AX,100
  4308 000011B8 7203                            JB	SHORT SAVEBUF
  4309                                  TRYBBAD:
  4310 000011BA E959FF                  	JMP	BADOP
  4311                                  SAVEBUF:
  4312 000011BD A2[1108]                        MOV     [BUFFERS],AL
  4313                                  COFFJ1:
  4314 000011C0 EBE2                            JMP     SHORT COFF
  4315                                  
  4316                                  ;------------------------------------------------------------------------------
  4317                                  ; Break command
  4318                                  ;------------------------------------------------------------------------------
  4319                                  TRYC:   
  4320 000011C2 80FC43                  	CMP     AH,'C'
  4321                                          ;JZ	SHORT GOTC
  4322                                          ;JMP	SHORT TRYD
  4323 000011C5 7527                    	JNZ	SHORT TRYD
  4324                                  GOTC:
  4325 000011C7 3C4F                            CMP     AL,'O'                  ; FIRST LETTER OF "ON" OR "OFF"
  4326 000011C9 7520                            JNZ     SHORT TRYCBAD
  4327 000011CB E84E04                          CALL    GETCHR
  4328 000011CE 721B                            JC      SHORT TRYCBAD
  4329 000011D0 3C4E                            CMP     AL,'N'                  ; SECOND LETTER OF "ON"
  4330 000011D2 750A                            JNZ     SHORT TRYCOFF
  4331 000011D4 B433                            MOV     AH,SET_CTRL_C_TRAPPING  ; TURN ON CONTROL-C CHECK
  4332 000011D6 B001                            MOV     AL,1
  4333 000011D8 88C2                            MOV     DL,AL
  4334 000011DA CD21                            INT     21H
  4335                                  COFFJ2:
  4336 000011DC EBC6                    	JMP	SHORT COFF
  4337                                  TRYCOFF: 
  4338 000011DE 3C46                    	CMP	AL,'F'
  4339 000011E0 7509                    	JNZ	SHORT TRYCBAD		; Check for "OFF"
  4340 000011E2 E83704                  	CALL	GETCHR
  4341 000011E5 7204                    	JC	SHORT TRYCBAD
  4342 000011E7 3C46                    	CMP	AL,'F'
  4343 000011E9 74F1                    	JZ	SHORT COFFJ2
  4344                                  TRYCBAD:
  4345 000011EB E928FF                  	JMP	BADOP
  4346                                  
  4347                                  ;------------------------------------------------------------------------------
  4348                                  ; Device command
  4349                                  ;------------------------------------------------------------------------------
  4350                                  
  4351                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
  4352                                  
  4353                                  TRYD:   
  4354 000011EE 80FC44                  	CMP     AH,'D'
  4355 000011F1 7403                            JZ      SHORT GOTD
  4356 000011F3 E9E501                          JMP     TRYQ
  4357                                  GOTD:   
  4358 000011F6 8CCB                    	MOV     BX,CS
  4359 000011F8 8EDB                            MOV     DS,BX
  4360                                  
  4361 000011FA 8936[7208]                      MOV     [BPB_ADDR],SI
  4362 000011FE 8C06[7408]                      MOV     [BPB_ADDR+2],ES
  4363                                  
  4364 00001202 E8CF06                          CALL    ROUND
  4365                                  
  4366 00001205 31C0                    	XOR     AX,AX
  4367 00001207 A3[F807]                        MOV     [ENTRY_POINT],AX
  4368 0000120A A1[5A08]                        MOV     AX,[MEMHI]
  4369 0000120D A3[FA07]                        MOV     [ENTRY_POINT+2],AX	; SET ENTRY POINT
  4370                                  
  4371                                  	; 01/05/2018 (NOEXEC = FALSE)
  4372                                          ;IF     NOT NOEXEC
  4373 00001210 A3[5C08]                        MOV	[LDOFF],AX		; SET LOAD OFFSET
  4374                                          ;ENDIF
  4375                                  
  4376 00001213 06                              PUSH    ES
  4377 00001214 1F                              POP     DS
  4378 00001215 89F2                            MOV     DX,SI                   ; DS:DX POINTS TO FILE NAME
  4379                                  
  4380                                          ;IF	NOEXEC
  4381                                          ;LES     BX,[CS:MEMLO]
  4382                                          ;CALL    LDFIL			; LOAD IN THE DEVICE DRIVER
  4383                                          ;ELSE
  4384                                  
  4385                                  ; We are going to open the cdevice driver and size it as is done
  4386                                  ;  in LDFIL. The reason we must do this is that EXEC does NO checking
  4387                                  ;  for us. We must make sure there is room to load the device without
  4388                                  ;  trashing SYSINIT. This code is not
  4389                                  ;  perfect (for instance .EXE device drivers are possible) because
  4390                                  ;  it does its sizing based on the assumption that the file being loaded
  4391                                  ;  is a .COM file. It is close enough to correctness to be usable.
  4392                                  
  4393 00001217 8EC0                    	MOV	ES,AX			;ES:0 is LOAD addr
  4394 00001219 B8003D                  	MOV	AX,OPEN*256		;OPEN THE FILE
  4395 0000121C F9                      	STC				;IN CASE OF INT 24
  4396 0000121D CD21                    	INT	21H
  4397 0000121F 724A                    	JC	short BADLDRESET
  4398 00001221 89C3                    	MOV	BX,AX			;Handle in BX
  4399 00001223 52                      	PUSH	DX			; Save pointer to name
  4400 00001224 31C9                    	XOR	CX,CX
  4401 00001226 31D2                    	XOR	DX,DX
  4402 00001228 B80242                  	MOV	AX,(LSEEK*256)+2
  4403 0000122B F9                      	STC				;IN CASE OF INT 24
  4404 0000122C CD21                    	INT	21H			; Get file size in DX:AX
  4405 0000122E 7308                    	JNC	short GO_AHEAD_LOAD
  4406 00001230 B43E                    	MOV	AH,CLOSE		; Close file
  4407 00001232 CD21                    	INT	21H
  4408 00001234 5A                      	POP	DX			; Clean stack
  4409 00001235 F9                      	STC				; Close may clear carry
  4410 00001236 EB33                    	JMP	SHORT BADLDRESET
  4411                                  
  4412                                  GO_AHEAD_LOAD:
  4413                                      ; Convert size in DX:AX to para in AX
  4414 00001238 83C00F                  	ADD	AX,15			; Round up size for conversion to para
  4415 0000123B 83D200                  	ADC	DX,0
  4416 0000123E B104                    	MOV	CL,4
  4417 00001240 D3E8                    	SHR	AX,CL
  4418 00001242 B10C                    	MOV	CL,12
  4419 00001244 D3E2                    	SHL	DX,CL			; Low nibble of DX to high nibble
  4420 00001246 09D0                    	OR	AX,DX			; AX is now # of para for file
  4421                                  
  4422 00001248 8CC1                    	MOV	CX,ES			; CX:0 is xaddr
  4423 0000124A 01C1                    	ADD	CX,AX			; New device will take up to here
  4424 0000124C 7207                    	JC	short MEM_ERRJY		; WOW!!!!
  4425 0000124E 2E3B0E[1908]            	CMP	CX,[CS:ALLOCLIM]
  4426 00001253 7203                    	JB	short OKLDX
  4427                                  MEM_ERRJY:
  4428 00001255 E99E06                  	JMP	MEM_ERR
  4429                                  OKLDX:
  4430 00001258 5A                      	POP	DX			; Recover name pointer
  4431 00001259 B43E                    	MOV	AH,CLOSE		; Close file
  4432 0000125B CD21                    	INT	21H
  4433 0000125D 8CCB                    	MOV	BX,CS
  4434 0000125F 8EC3                            MOV	ES,BX
  4435 00001261 BB[5A08]                        MOV	BX,PRMBLK		; ES:BX POINTS TO PARAMETERS
  4436 00001264 B003                            MOV	AL,3
  4437 00001266 B44B                            MOV	AH,EXEC
  4438 00001268 F9                              STC				; IN CASE OF INT 24
  4439 00001269 CD21                            INT	21H                     ; LOAD IN THE DEVICE DRIVER
  4440                                          ;ENDIF
  4441                                  
  4442                                  BADLDRESET:
  4443 0000126B 1E                              PUSH    DS
  4444 0000126C 07                              POP     ES                      ; ES:SI BACK TO CONFIG.SYS
  4445 0000126D 0E                              PUSH    CS
  4446 0000126E 1F                              POP     DS                      ; DS BACK TO SYSINIT
  4447 0000126F 730F                            JNC     SHORT GOODLD
  4448                                  BADBRK: 
  4449 00001271 26803C0D                	cmp	BYTE [ES:SI], 13	; file name is CR?
  4450 00001275 7503                    	jne	SHORT BADBRK_1		;(entered "device=" without filename)
  4451 00001277 E99CFE                  	jmp	BADOP			;"Unrecognized command in CONFIG.SYS"
  4452                                  BADBRK_1:
  4453 0000127A E8AC08                  	CALL    BADLOAD
  4454 0000127D E924FF                          JMP     COFF
  4455                                  GOODLD: 
  4456 00001280 06                      	PUSH    ES                      ; INITIALIZE THE DEVICE
  4457 00001281 56                              PUSH    SI
  4458                                  RESTORE:
  4459 00001282 268A1C                  	MOV	BL,[ES:SI]		;   while ((c=*p) != 0)
  4460 00001285 08DB                    	OR	BL,BL
  4461 00001287 7403                    	JZ	SHORT GOT
  4462 00001289 46                      	INC	SI			;	p++;
  4463 0000128A EBF6                    	JMP	SHORT RESTORE
  4464                                  GOT:	
  4465 0000128C 26C60420                	MOV	BYTE [ES:SI], ' '	;   *p = ' ';
  4466                                  
  4467 00001290 06                      	PUSH    ES
  4468 00001291 56                              PUSH    SI        
  4469 00001292 0E                      	PUSH    CS
  4470 00001293 07                              POP     ES
  4471 00001294 BB0600                          MOV     BX,SYSDEV.STRAT
  4472 00001297 E86706                          CALL    CALLDEV			;   CallDev (SDevStrat);
  4473 0000129A BB0800                          MOV     BX,SYSDEV.INT
  4474 0000129D E86106                          CALL    CALLDEV			;   CallDev (SDevInt);
  4475 000012A0 5E                      	POP	SI
  4476 000012A1 1F                      	POP	DS
  4477 000012A2 C60400                  	MOV	BYTE [SI],0		;   *p = 0;
  4478                                  		
  4479 000012A5 0E                              PUSH    CS
  4480 000012A6 1F                              POP     DS
  4481 000012A7 A1[7008]                	MOV     AX,[BREAK_ADDR+2]	; REMOVE THE INIT CODE
  4482 000012AA 3B06[0E08]                      CMP     AX,[MEMORY_SIZE]
  4483 000012AE 7204                            JB      SHORT BREAKOK
  4484 000012B0 5E                              POP     SI
  4485 000012B1 07                              POP     ES
  4486 000012B2 EBBD                            JMP     SHORT BADBRK
  4487                                  BREAKOK:
  4488 000012B4 C516[F807]                      LDS     DX,[ENTRY_POINT]        ; SET DS:DX TO HEADER
  4489 000012B8 89D6                            MOV     SI,DX
  4490 000012BA 83C604                          ADD     SI,SYSDEV.ATT		; DS:SI POINTS TO ATTRIBUTES
  4491 000012BD 2EC43E[F407]                    LES     DI,[CS:DOSINFO]         ; ES:DI POINT TO DOS INFO
  4492 000012C2 8B04                            MOV     AX,[SI]			; GET ATTRIBUTES
  4493 000012C4 A90080                          TEST    AX,DEVTYP               ; TEST IF BLOCK DEV
  4494 000012C7 7422                            JZ      SHORT ISBLOCK
  4495 000012C9 E8E705                  	CALL	SET_BREAK		; Go ahead and alloc mem for device
  4496 000012CC 7225                    	JC	SHORT ERASE_DEV
  4497 000012CE A90100                          TEST    AX,ISCIN                ; IS IT A CONSOLE IN?
  4498 000012D1 7408                            JZ      SHORT TRYCLK
  4499 000012D3 2689550C                        MOV     [ES:DI+SYSI_CON],DX
  4500 000012D7 268C5D0E                        MOV     [ES:DI+SYSI_CON+2],DS
  4501                                  
  4502                                  TRYCLK: 
  4503 000012DB A90800                  	TEST    AX,ISCLOCK              ; IS IT A CLOCK DEVICE?
  4504 000012DE 7408                            JZ      SHORT GOLINK
  4505 000012E0 26895508                        MOV     [ES:DI+SYSI_CLOCK],DX
  4506 000012E4 268C5D0A                        MOV     [ES:DI+SYSI_CLOCK+2],DS
  4507                                  GOLINK: 
  4508 000012E8 E9C000                  	JMP	LINKIT
  4509                                  
  4510                                  ISBLOCK:
  4511 000012EB 2EA0[6D08]                      MOV     AL,[CS:UNITCOUNT]	; IF NO UNITS FOUND, ERASE THE DEVICE
  4512 000012EF 08C0                            OR      AL,AL
  4513 000012F1 7506                            JNZ     SHORT PERDRV
  4514                                  ERASE_DEV:					
  4515 000012F3 B8FFFF                          MOV     AX,-1			; No call to SET_BREAK yet, so no alloc
  4516 000012F6 E9D700                  	JMP	ENDDEV
  4517                                  
  4518                                  PERDRV:
  4519 000012F9 98                              CBW
  4520 000012FA 89C1                            MOV     CX,AX
  4521 000012FC 88E6                            MOV     DH,AH
  4522 000012FE 268A5520                        MOV     DL,[ES:DI+SYSI_NUMIO]	; GET NUMBER OF DEVICES
  4523 00001302 88D4                    	MOV	AH,DL
  4524 00001304 00C4                    	ADD	AH,AL			; Check for too many devices
  4525 00001306 80FC1A                  	CMP	AH,26			; 'A' - 'Z' is 26 devices
  4526 00001309 760A                    	JBE	SHORT OK_BLOCK
  4527 0000130B 0E                      	PUSH	CS
  4528 0000130C 1F                      	POP	DS
  4529 0000130D BA[591E]                	MOV	DX,BADBLOCK
  4530 00001310 E83008                  	CALL	PRINT
  4531 00001313 EBDE                    	JMP	SHORT ERASE_DEV
  4532                                  
  4533                                  OK_BLOCK:
  4534 00001315 E89B05                  	CALL	SET_BREAK		; Alloc the device
  4535 00001318 26004520                	ADD	[ES:DI+SYSI_NUMIO],AL	; UPDATE THE AMOUNT
  4536 0000131C 2E0006[7608]            	ADD	[CS:DriveNumber],AL	; remember amount for next device
  4537 00001321 2EC51E[7208]                    LDS     BX,[CS:BPB_ADDR]        ; POINT TO BPB ARRAY
  4538                                  PERUNIT:
  4539 00001326 2EC42E[F407]                    LES     BP,[CS:DOSINFO]
  4540                                  	;LES	BP,[ES:BP+SYSI_DPB]	; GET FIRST DPB
  4541 0000132B 26C46E00                	les	bp,[es:bp] ; 05/07/2019
  4542                                  SCANDPB:
  4543 0000132F 26837E18FF              	CMP     WORD [ES:BP+DPB.NEXT_DPB],-1
  4544 00001334 7406                            JZ      SHORT FOUNDPB
  4545 00001336 26C46E18                        LES     BP,[ES:BP+DPB.NEXT_DPB]
  4546 0000133A EBF3                            JMP     SHORT SCANDPB
  4547                                  FOUNDPB:
  4548 0000133C 2EA1[5808]                      MOV     AX,[CS:MEMLO]
  4549 00001340 26894618                        MOV     [ES:BP+DPB.NEXT_DPB],AX
  4550 00001344 2EA1[5A08]                      MOV     AX,[CS:MEMHI]
  4551 00001348 2689461A                        MOV     [ES:BP+DPB.NEXT_DPB+2],AX
  4552 0000134C 2EC42E[5808]                    LES     BP,[CS:MEMLO]
  4553 00001351 2E8306[5808]20                  ADD     WORD [CS:MEMLO],DPBSIZ
  4554 00001357 E87A05                  	CALL	ROUND			;Check for alloc error
  4555 0000135A 26C74618FFFF                    MOV     WORD [ES:BP+DPB.NEXT_DPB],-1
  4556 00001360 26C64617FF                      MOV     BYTE [ES:BP+DPB.FIRST_ACCESS],-1
  4557                                  
  4558 00001365 8B37                            MOV     SI,[BX]                 ; DS:SI POINTS TO BPB
  4559 00001367 43                              INC     BX
  4560 00001368 43                              INC     BX                      ; POINT TO NEXT GUY
  4561                                  	;MOV	[ES:BP+DPB.DRIVE],DX
  4562 00001369 26895600                	mov	[es:bp],dx ; 05/07/2019
  4563 0000136D B453                            MOV     AH,SETDPB               ; HIDDEN SYSTEM CALL
  4564 0000136F CD21                            INT     21H
  4565 00001371 268B4602                        MOV     AX,[ES:BP+DPB.SECTOR_SIZE]
  4566 00001375 06                              PUSH    ES
  4567 00001376 2EC43E[F407]                    LES     DI,[CS:DOSINFO]		; ES:DI POINT TO DOS INFO
  4568 0000137B 263B4510                        CMP     AX,[ES:DI+SYSI_MAXSEC]
  4569 0000137F 07                              POP     ES
  4570 00001380 760E                            JBE     SHORT NOTMAX
  4571 00001382 5E                              POP     SI
  4572 00001383 07                              POP     ES
  4573 00001384 BA[7B1D]                        MOV     DX,BADSIZ_PRE
  4574 00001387 BB[781D]                        MOV     BX,BADSIZ_POST
  4575 0000138A E89F07                          CALL    PRNERR
  4576 0000138D E914FE                          JMP	COFF
  4577                                  
  4578                                  NOTMAX: 
  4579 00001390 1E                      	PUSH    DS
  4580 00001391 52                              PUSH    DX
  4581 00001392 2EC516[F807]                    LDS     DX,[CS:ENTRY_POINT]
  4582 00001397 26895612                        MOV     [ES:BP+DPB.DRIVER_ADDR],DX
  4583 0000139B 268C5E14                        MOV     [ES:BP+DPB.DRIVER_ADDR+2],DS
  4584 0000139F 5A                              POP     DX
  4585 000013A0 1F                              POP     DS
  4586 000013A1 42                              INC     DX
  4587 000013A2 FEC6                            INC     DH
  4588 000013A4 E280                            LOOP    PERUNIT
  4589 000013A6 0E                      	PUSH	CS
  4590 000013A7 1F                      	POP	DS
  4591 000013A8 E84CF7                  	CALL	TEMPCDS 		; Set CDS for new drives
  4592                                  
  4593                                  LINKIT:
  4594 000013AB 2EC43E[F407]                    LES     DI,[CS:DOSINFO]         ; ES:DI = DOS TABLE
  4595 000013B0 268B4D22                        MOV     CX,[ES:DI+SYSI_DEV] 	; DX:CX = HEAD OF LIST
  4596 000013B4 268B5524                        MOV     DX,[ES:DI+SYSI_DEV+2]
  4597                                  
  4598 000013B8 2EC536[F807]                    LDS     SI,[CS:ENTRY_POINT]     ; DS:SI = DEVICE LOCATION
  4599 000013BD 26897522                        MOV     [ES:DI+SYSI_DEV],SI 	; SET HEAD OF LIST IN DOS
  4600 000013C1 268C5D24                        MOV     [ES:DI+SYSI_DEV+2],DS
  4601 000013C5 8B04                            MOV     AX,[SI]			; GET POINTER TO NEXT DEVICE
  4602 000013C7 2EA3[F807]                      MOV     [CS:ENTRY_POINT],AX	; AND SAVE IT
  4603                                  
  4604 000013CB 890C                            MOV    [SI],CX			; LINK IN THE DRIVER
  4605 000013CD 895402                          MOV    [SI+2],DX
  4606                                  ENDDEV:
  4607 000013D0 5E                              POP     SI
  4608 000013D1 07                              POP     ES
  4609 000013D2 40                              INC     AX                      ;AX = FFFF (no more devs if YES)?
  4610 000013D3 7403                            JZ      SHORT COFFJ3
  4611 000013D5 E9A8FE                          JMP	GOODLD			; OTHERWISE PRETEND WE LOADED IT IN
  4612                                  COFFJ3:
  4613                                  COFFV:  
  4614 000013D8 E9C9FD                  	JMP	COFF
  4615                                  
  4616                                  ;------------------------------------------------------------------------------
  4617                                  ; Country command
  4618                                  ;  The syntax is:							  ;3.30
  4619                                  ;	COUNTRY=country id {,codepage {,path}}				  ;3.30
  4620                                  ;	COUNTRY=country id {,,path}	:Default CODEPAGE ID in DOS	  ;3.30
  4621                                  ;------------------------------------------------------------------------------
  4622                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4623                                  
  4624                                  TRYQ:
  4625                                  	; 10/06/2018 - Retro DOS v3.0
  4626                                   
  4627 000013DB 80FC51                          CMP     AH,'Q'
  4628                                          ;JNZ	SHORT TRYF
  4629 000013DE 7403                    	JZ	short TRYQ_CONT
  4630 000013E0 E91C01                  	JMP	TRYF
  4631                                  TRYQ_CONT:
  4632 000013E3 E85505                          CALL    GETNUM
  4633 000013E6 744F                            JZ	short TryQBad		; 0 is never a valid code, or number is
  4634                                  					; bad
  4635 000013E8 89C3                    	MOV	BX,AX			; Country code in BX
  4636                                  					; 5/26/86
  4637 000013EA BA0000                  	MOV	DX,0			; assume no code page id
  4638 000013ED E89B05                  	call	SKIP_DELIM		;skip the delimeters after the first num
  4639 000013F0 7239                    	jc	short TryQ_Def_File	;no more characters left? then use default file
  4640 000013F2 3C0D                    	cmp	al,13			;
  4641 000013F4 7435                    	je	short TryQ_Def_File
  4642 000013F6 3C0A                    	cmp	al,10
  4643 000013F8 750A                    	jne	short TRYQ_YES_EXTENDED
  4644 000013FA FF06[5108]              	inc	word [COUNT] 		;This is for NEWLINE routine in COFF.
  4645 000013FE FF0E[5308]              	dec	word [CHRPTR]
  4646                                  COFFJ41:
  4647 00001402 EB27                    	JMP	short TryQ_Def_File	;O.K. no code page, 
  4648                                  					; no path specified.Use default path.    
  4649                                  TRYQ_YES_EXTENDED:
  4650 00001404 3C2C                    	cmp	al,','			;was the second comma?
  4651 00001406 7505                    	jne	short TRYQ_GETNUM
  4652 00001408 E88005                  	call	SKIP_DELIM		;Yes, skip ',' and other possible delim
  4653 0000140B EB38                    	jmp	short TRYQ_PATH 	;and No code page id entered.
  4654                                  TRYQ_GETNUM:
  4655 0000140D E82B05                  	call	GETNUM
  4656 00001410 722C                    	jc	short TryQBadCOM	;"Country=xxx,path" will not be accepted.
  4657                                  ;	jc	short TRYQ_PATH		;Codepage is not specified. No code page.
  4658                                  ;					;At this point, AL already contain the
  4659                                  ;					;first char of the PATH.
  4660 00001412 7423                    	jz	short TryQBad 		;codepage=0 entered. Error
  4661 00001414 89C2                    	mov	DX,AX			;save code page in DX
  4662 00001416 E87205                  	call	SKIP_DELIM		;move CHRPTR to the path string
  4663 00001419 7210                    	jc	short TryQ_Def_File	;no more char? then use default filename
  4664 0000141B 3C0D                    	cmp	al, 13
  4665 0000141D 740C                    	je	short TryQ_Def_File
  4666 0000141F 3C0A                    	cmp	al, 10	
  4667 00001421 7522                    	jne	short TRYQ_PATH		;path entered.
  4668 00001423 FF06[5108]              	inc	word [COUNT]
  4669 00001427 FF0E[5308]              	dec	word [CHRPTR]
  4670                                  TryQ_Def_File:
  4671 0000142B 52                      	push	dx			;save code page
  4672 0000142C 2EC606[C81B]00          	mov	byte [cs:CNTRY_DRV],0 	;flag that the default path has been used!!!
  4673 00001432 BA[CA1B]                	mov	dx,CNTRY_ROOT		;the default path
  4674 00001435 EB3C                    	jmp	short TRYQ_OPEN
  4675                                  
  4676                                  TryQBad:				;"Invalid country code or code page"
  4677 00001437 F9                      	STC
  4678 00001438 BA[C21D]                	MOV	DX,BADCOUNTRY
  4679 0000143B E9A800                  	jmp	TryQChkErr
  4680                                  
  4681                                  TryQBadCOM:				;Error in COUNTRY command
  4682 0000143E F9                      	STC
  4683 0000143F BA[E81D]                	MOV	DX,BADCOUNTRYCOM
  4684 00001442 E9A100                  	jmp	TryQChkErr
  4685                                  
  4686                                  TRYQ_PATH:				;DS - sysinitseg, ES - CONFBOT,
  4687 00001445 8B0E[5108]              	mov	CX,[COUNT]		;AL - the first char of path
  4688 00001449 41                      	inc	CX			;BX - country id, DX - codepage id, 0 = No code page
  4689 0000144A 89F7                    	mov	DI,SI
  4690                                  TRYQ_PATH_LOOP: 			;find the end of path to put 0 after that.
  4691 0000144C 268A05                  	mov	AL,[ES:DI]
  4692 0000144F E80F04                  	call	DELIM
  4693 00001452 7409                    	jz	short TRYQ_PATH_END
  4694 00001454 3C0D                    	cmp	al, 13
  4695 00001456 7405                    	jz	short TRYQ_PATH_END
  4696 00001458 47                      	inc	DI
  4697 00001459 EBF1                    	jmp	short TRYQ_PATH_LOOP
  4698                                  TryQBad_Brg:
  4699 0000145B EBDA                    	jmp	short TryQBad
  4700                                  TRYQ_PATH_END:
  4701 0000145D 26C60500                	mov	byte [es:di],0		;make it a ASCIIZ string. 
  4702                                  					; (Organize did not handle this string)
  4703 00001461 1E                      	push	ds			;switch ds,es
  4704 00001462 06                      	push	es
  4705 00001463 1F                      	pop	ds
  4706 00001464 07                      	pop	es
  4707                                  
  4708 00001465 BF[C81B]                	mov	di,CNTRY_DRV	;move the user specified path to CNTRY_DRV
  4709 00001468 E8B206                  	call	MOVE_ASCIIZ
  4710                                  
  4711 0000146B 1E                      	push	ds			;restore ds,es
  4712 0000146C 06                      	push	es
  4713 0000146D 1F                      	pop	ds
  4714 0000146E 07                      	pop	es
  4715                                  
  4716                                  ;	call	 Set_Country_Path	;set CNTRY_DRV
  4717                                  
  4718 0000146F 52                      	push	dx			;save DX
  4719 00001470 BA[C81B]                	mov	dx,CNTRY_DRV		;Now DS:DX -> CNTRY_DRV
  4720                                  TRYQ_OPEN:
  4721 00001473 B8003D                  	mov	ax,3D00h		;open a file
  4722 00001476 F9                      	stc
  4723 00001477 CD21                    	int	21h
  4724 00001479 5A                      	pop	dx			;restore codepage id
  4725 0000147A 723F                    	jc	short TryQFileBad	;open failure
  4726                                  
  4727 0000147C 2EA3[5508]              	mov	[cs:CntryFileHandle],ax ;save file handle
  4728 00001480 93                      	xchg	ax,bx			;now, AX = country id, BX = file handle
  4729 00001481 2E8B0E[5A08]            	mov	cx,[cs:MEMHI]
  4730 00001486 81C18000                	add	cx,128			;I need 2K buffer to handle COUNTRY.SYS
  4731 0000148A 2E3B0E[1908]            	cmp	cx,[cs:ALLOCLIM]
  4732 0000148F 7752                    	ja	short TryQMemory	;cannot allocate the buffer for country.sys
  4733                                  
  4734 00001491 BE[C81B]                	mov	si,CNTRY_DRV		;DS:SI -> CNTRY_DRV
  4735 00001494 803C00                  	cmp	byte [si],0 		;default path?
  4736 00001497 7502                    	jne	short TRYQ_Set_for_DOS
  4737 00001499 46                      	inc	si
  4738 0000149A 46                      	inc	si			;DS:SI -> CNTRY_ROOT
  4739                                  TRYQ_Set_for_DOS:
  4740 0000149B 2EC43E[0208]            	les	di,[cs:SYSI_Country]	;ES:DI -> country info tab in DOS
  4741 000014A0 57                      	push	di			;save di
  4742 000014A1 83C708                  	add	di,country_cdpg_info.ccPath_CountrySys
  4743 000014A4 E87606                  	call	MOVE_ASCIIZ		;Set the path to COUNTRY.SYS in DOS.
  4744 000014A7 5F                      	pop	di			;ES:DI -> country info tab again.
  4745 000014A8 2E8B0E[5A08]            	mov	cx,[cs:MEMHI]
  4746 000014AD 8ED9                    	mov	ds, cx
  4747 000014AF 31F6                    	xor	si, si			;DS:SI -> 2K buffer to be used.
  4748 000014B1 E8F504                  	call	SetDOSCountryInfo	;now do the job!!!
  4749 000014B4 7330                    	jnc	short TryQChkErr	;read error or could not find country,
  4750                                  					;	code page combination
  4751 000014B6 83F9FF                  	cmp	cx, -1			;Could not find matching country_id,code page?
  4752 000014B9 74A0                    	je	short TryQBad_Brg	;then "Invalid country code or code page"
  4753                                  TryQFileBad:
  4754 000014BB 2E803E[C81B]00          	cmp	byte [cs:CNTRY_DRV],0	;Is the default file used?
  4755 000014C1 740F                    	je	short TryQDefBad
  4756 000014C3 2E8B36[1708]            	mov	si,[cs:CONFBOT]
  4757 000014C8 8EC6                    	mov	es,si
  4758 000014CA 2E8B36[5308]            	mov	si,[cs:CHRPTR]
  4759 000014CF 4E                      	dec	si			;ES:SI -> path in CONFBOT
  4760 000014D0 EB05                    	jmp	short TryQBADLOAD
  4761                                  TryQDefBad:				;Default file has been used.
  4762 000014D2 0E                      	push	cs
  4763 000014D3 07                      	pop	es
  4764 000014D4 BE[CA1B]                	mov	si,CNTRY_ROOT		;ES:SI -> \COUNTRY.SYS in SYSINIT_SEG
  4765                                  TryQBADLOAD:
  4766 000014D7 E84F06                  	call	BADLOAD 		;DS will be restored to SYSINIT_SEG
  4767 000014DA 2E8B0E[1708]            	mov	cx,[cs:CONFBOT]
  4768 000014DF 8EC1                    	mov	es, cx			;Restore ES -> CONFBOT.
  4769 000014E1 EB11                    	jmp	short CoffJ4
  4770                                  TryQMemory:
  4771 000014E3 BA[051E]                	MOV	DX,INSUFMEMORY
  4772                                  TryQChkErr:
  4773 000014E6 2E8B0E[1708]            	mov	cx,[cs:CONFBOT]
  4774 000014EB 8EC1                    	mov	es,cx			;restore ES -> CONFBOT seg
  4775 000014ED 0E                      	push	cs
  4776 000014EE 1F                      	pop	ds			;restore DS to SYSINIT_SEG
  4777 000014EF 7303                    	jnc	short CoffJ4		;if no error, then exit
  4778 000014F1 E84F06                  	call	PRINT			;else show error message
  4779                                  CoffJ4:
  4780 000014F4 8B1E[5508]              	mov	bx,[CntryFileHandle]
  4781 000014F8 B43E                    	mov	ah,3Eh
  4782 000014FA CD21                    	int	21h			;close a file. Don't care even if it fails.
  4783 000014FC E9A5FC                  	JMP	COFF
  4784                                  
  4785                                  ;------------------------------------------------------------------------------
  4786                                  ; Files command
  4787                                  ;------------------------------------------------------------------------------
  4788                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4789                                  
  4790                                  TRYF:
  4791 000014FF 80FC46                          CMP     AH,'F'
  4792 00001502 7516                    	JNZ	SHORT TRYL
  4793 00001504 E83404                  	CALL    GETNUM
  4794 00001507 83F805                  	CMP	AX,5
  4795 0000150A 720B                    	JB	SHORT TRYFBAD		; Gotta have at least 5
  4796 0000150C 3D0001                  	CMP	AX,256
  4797 0000150F 7306                    	JAE	SHORT TRYFBAD		; Has to be a byte
  4798 00001511 A2[1308]                	MOV	[FILES],AL
  4799                                  COFFJ5: 
  4800 00001514 E98DFC                  	JMP	COFF
  4801                                  TRYFBAD:
  4802 00001517 E9FCFB                  	JMP	BADOP
  4803                                  
  4804                                  ;------------------------------------------------------------------------------
  4805                                  ; LastDrive command
  4806                                  ;------------------------------------------------------------------------------
  4807                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4808                                  
  4809                                  TRYL:
  4810 0000151A 80FC4C                  	CMP	AH,'L'
  4811 0000151D 7515                    	JNZ	SHORT TRYP
  4812 0000151F 0C20                    	OR	AL,020h
  4813 00001521 2C61                    	SUB	AL,'a'
  4814 00001523 720C                    	JB	SHORT TRYLBAD
  4815 00001525 FEC0                    	INC	AL
  4816 00001527 3C1A                    	CMP	AL,26			; a-z are allowed
  4817 00001529 7706                    	JA	SHORT TRYLBAD
  4818 0000152B A2[1608]                	MOV	[NUM_CDS],AL
  4819                                  COFFJ6: 
  4820 0000152E E973FC                  	JMP	COFF
  4821                                  TRYLBAD:
  4822 00001531 E9E2FB                  	JMP	BADOP
  4823                                  
  4824                                  ;-------------------------------------------------------------------------------
  4825                                  ; Setting Drive Parameters
  4826                                  ;-------------------------------------------------------------------------------
  4827                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4828                                  
  4829                                  TRYP:
  4830 00001534 80FC50                  	CMP	AH,'P'
  4831 00001537 7510                    	JNZ	SHORT TRYK
  4832 00001539 E83601                  	CALL	PARSELINE
  4833 0000153C 72F3                    	JC	SHORT TRYLBAD
  4834 0000153E E8F700                  	CALL	SETPARMS
  4835 00001541 E81601                  	CALL	DIDDLEBACK
  4836 00001544 72EB                    	JC	SHORT TRYLBAD
  4837 00001546 E95BFC                  	JMP	COFF
  4838                                  
  4839                                  ;-------------------------------------------------------------------------------
  4840                                  ; Setting Internal Stack Parameters
  4841                                  ; STACK=M,N where
  4842                                  ;	M is the number of stacks (range 8 to 64, default 9)
  4843                                  ;	N is the stack size (range 32 to 512 bytes, default 128)
  4844                                  ;  5/5/86: STACKS=0,0 implies no stack installation.			  ;3.30
  4845                                  ;	Any combinations that are not within the specified limits will	  ;3.30
  4846                                  ;	result in "Unrecognized command" error.                    
  4847                                  ;-------------------------------------------------------------------------------
  4848                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4849                                  
  4850                                  TRYK:
  4851 00001549 80FC4B                  	CMP	AH,'K'
  4852                                  	;JNZ	short TRYW
  4853 0000154C 7559                    	JNZ	short TRYS ; 03/08/2019
  4854                                  
  4855                                  	;IF	STACKSW
  4856                                  
  4857 0000154E C606[4008]2C            	MOV	byte [SEPCHR],','
  4858 00001553 E8E503                  	call	GETNUM			; Get number of stacks
  4859 00001556 C606[4008]00            	MOV	byte [SEPCHR],0
  4860 0000155B 83F800                  	cmp	ax, 0			; 5/5/86
  4861 0000155E 740A                    	je	short TRYK_0		; Let's accept 0.
  4862 00001560 83F808                  	CMP	AX,MinCount		; 8 <= Number of Stacks <= 64
  4863 00001563 7239                    	JB	short TryKBad
  4864 00001565 83F840                  	CMP	AX,MaxCount
  4865 00001568 7734                    	JA	short TryKBad
  4866                                  TRYK_0:
  4867 0000156A A3[0608]                	MOV	[STACK_COUNT],AX
  4868                                  ;
  4869                                  ; Skip delimiters after the ,
  4870                                  ;
  4871 0000156D E81B04                  	call	SKIP_DELIM
  4872 00001570 722C                    	JC	short TryKBad
  4873                                  
  4874 00001572 E8C603                  	call	GETNUM			; Get size of individual stack
  4875 00001575 7227                    	JC	short TryKBad 		; Number bad
  4876                                  
  4877 00001577 83F800                  	cmp	ax, 0			; 5/5/86
  4878 0000157A 740A                    	je	short TRYK_SIZE0	; 5/5/86. Accept 0
  4879                                  
  4880 0000157C 83F820                  	CMP	AX,MinSize		; 32 <= Stack Size <= 512
  4881 0000157F 721D                    	JB	short TryKBad
  4882 00001581 3D0002                  	CMP	AX,MaxSize
  4883 00001584 7718                    	JA	short TryKBad
  4884                                  TRYK_SIZE0:
  4885 00001586 A3[0808]                	MOV	[STACK_SIZE],AX
  4886 00001589 83F800                  	cmp	ax,0
  4887 0000158C 7409                    	je	short TRYK_BOTH0
  4888                                  TRYK_OK:
  4889 0000158E C706[0A08]FFFF          	mov	word [STACK_ADDR], -1	;set flag. user entered stacks=
  4890 00001594 E90DFC                  	JMP	COFF
  4891                                  TRYK_BOTH0:
  4892 00001597 833E[0608]00            	cmp	word [STACK_COUNT],0 	;stack_size=0. Stack_Count=0 too?
  4893 0000159C 74F0                    	je	short TRYK_OK 		;yes. accepted.
  4894                                  TryKBad:
  4895 0000159E BA[741E]                	MOV	DX,BADSTACK		; 5/26/86 "Invalid stack parameter"
  4896 000015A1 E89F05                  	call	PRINT
  4897 000015A4 E9FDFB                  	JMP	COFF
  4898                                  
  4899                                  	;ENDIF
  4900                                  
  4901                                  ;------------------------------------------------------------------------------
  4902                                  ; Switch command
  4903                                  ;------------------------------------------------------------------------------
  4904                                  
  4905                                  	; 03/08/2019
  4906                                  ;TRYW:
  4907                                  ;       CMP     AH,'W'
  4908                                  ;       JNZ     SHORT TRYA
  4909                                  ;	; 10/06/2018 - Retro DOS 3.0
  4910                                  ;	JMP	BADOP			; no longer implemented (MSDOS 3.3)
  4911                                  
  4912                                  	; 01/04/2018 - Retro DOS 2.0
  4913                                  ;	MOV     DL,AL
  4914                                  ;	MOV     AX,(CHAR_OPER*256)+1	; SET SWITCH CHARACTER
  4915                                  ;	MOV     [COMMAND_LINE+1],DL
  4916                                  ;	INT     21H
  4917                                  ;	JMP     COFF
  4918                                  
  4919                                  ;------------------------------------------------------------------------------
  4920                                  ; Availdev command
  4921                                  ;------------------------------------------------------------------------------
  4922                                  
  4923                                  	; 03/08/2019
  4924                                  ;TRYA:
  4925                                  ;       CMP     AH,'A'
  4926                                  ;       JNZ     SHORT TRYS
  4927                                  ;	JMP	BADOP			; no longer implemented (MSDOS 3.3)
  4928                                  
  4929                                  ;	CMP     AL,'F'			; FIRST LETTER OF "FALSE"
  4930                                  ;	JNZ     SHORT COFFJ
  4931                                  ;	MOV     AX,(CHAR_OPER*256)+3	; TURN ON "/DEV" PREFIX
  4932                                  ;	XOR     DL,DL
  4933                                  ;	INT     21H
  4934                                  ;COFFJ7:  
  4935                                  ;	JMP     COFF
  4936                                  
  4937                                  ;------------------------------------------------------------------------------
  4938                                  ; shell command
  4939                                  ;------------------------------------------------------------------------------
  4940                                  
  4941                                  TRYS:
  4942 000015A7 80FC53                          CMP     AH,'S'
  4943 000015AA 752B                            JNZ     SHORT TRYX
  4944 000015AC C606[2008]00                    MOV     BYTE [COMMAND_LINE+1],0
  4945 000015B1 BF[161C]                        MOV     DI,COMMND + 1
  4946 000015B4 8845FF                          MOV     [DI-1],AL
  4947                                  STORESHELL:
  4948 000015B7 E86200                          CALL    GETCHR
  4949 000015BA 08C0                            OR      AL,AL
  4950 000015BC 744C                            JZ      SHORT GETSHPARMS
  4951 000015BE 3C20                            CMP     AL," "
  4952 000015C0 7205                            JB      SHORT ENDSH
  4953 000015C2 8805                            MOV     [DI],AL
  4954 000015C4 47                              INC     DI
  4955 000015C5 EBF0                            JMP     SHORT STORESHELL
  4956                                  
  4957                                  ENDSH:
  4958 000015C7 C60500                          MOV     BYTE [DI],0
  4959 000015CA E84F00                          CALL    GETCHR
  4960 000015CD 3C0A                            CMP     AL,10
  4961 000015CF 7503                            JNZ     SHORT CONV
  4962 000015D1 E84800                          CALL    GETCHR
  4963                                  CONV:   
  4964 000015D4 E9C1FB                  	JMP     CONFLP
  4965                                  
  4966                                  ;------------------------------------------------------------------------------
  4967                                  ; FCBS Command
  4968                                  ;------------------------------------------------------------------------------
  4969                                  ; SYSCONF.ASM, MSDOS 3.3, 24/07/1987
  4970                                  
  4971                                  TRYX:
  4972                                  	; 10/06/2018 -  Retro DOS v3.0
  4973                                   
  4974                                  	;JMP	BADOP	; 25/03/2018 - Retro DOS v2.0 
  4975                                  
  4976 000015D7 80FC58                  	CMP	AH,'X'
  4977 000015DA 752B                    	JNZ	SHORT TRYZ
  4978 000015DC E85C03                  	CALL	GETNUM
  4979 000015DF 7423                    	JZ	SHORT TRYXBAD 		; gotta have at least one
  4980 000015E1 3D0001                  	CMP	AX,256
  4981 000015E4 731E                    	JAE	SHORT TRYXBAD 		; Can't be more than 8 bits worth
  4982 000015E6 A2[1408]                	MOV	[FCBS],AL
  4983                                  ;
  4984                                  ; Skip delimiters after the ,
  4985                                  ;
  4986 000015E9 E89F03                  	CALL	SKIP_DELIM
  4987 000015EC 7216                    	JC	SHORT TRYXBAD
  4988 000015EE E84A03                  	CALL	GETNUM
  4989 000015F1 7211                    	JC	SHORT TRYXBAD		; Number bad (Zero is OK here)
  4990 000015F3 3D0001                  	CMP	AX,256
  4991 000015F6 730C                    	JAE	SHORT TRYXBAD
  4992 000015F8 3A06[1408]              	CMP	AL,[FCBS]
  4993 000015FC 7706                    	JA	SHORT TRYXBAD
  4994 000015FE A2[1508]                	MOV	[KEEP],AL
  4995 00001601 E9A0FB                  	JMP	COFF
  4996                                  TRYXBAD:
  4997 00001604 E90FFB                  	JMP	BADOP
  4998                                  
  4999                                  ;------------------------------------------------------------------------------
  5000                                  ; Bogus command
  5001                                  ;------------------------------------------------------------------------------
  5002                                  
  5003                                  TRYZ:
  5004 00001607 E90CFB                  	JMP	BADOP
  5005                                  
  5006                                  GETSHPARMS:
  5007 0000160A C60500                  	MOV     BYTE [DI],0
  5008 0000160D BF[2008]                	MOV     DI,COMMAND_LINE+1
  5009                                  PARMLOOP:
  5010 00001610 E80900                          CALL    GETCHR
  5011 00001613 3C20                            CMP     AL," "
  5012 00001615 72B0                            JB      SHORT ENDSH
  5013 00001617 8805                            MOV     [DI],AL
  5014 00001619 47                              INC     DI
  5015 0000161A EBF4                            JMP     SHORT PARMLOOP
  5016                                  
  5017                                  GETCHR: 
  5018 0000161C 51                      	PUSH	CX
  5019 0000161D 8B0E[5108]              	MOV     CX,[COUNT] ; 05/07/2018
  5020 00001621 E312                            JCXZ    NOCHAR
  5021 00001623 8B36[5308]                      MOV     SI,[CHRPTR]
  5022 00001627 268A04                          MOV     AL,[ES:SI]
  5023 0000162A FF0E[5108]                      DEC     WORD [COUNT]
  5024 0000162E FF06[5308]                      INC     WORD [CHRPTR]
  5025 00001632 F8                              CLC
  5026                                  GET_RET:
  5027 00001633 59                      	POP	CX
  5028 00001634 C3                              RETN
  5029                                  NOCHAR: 
  5030 00001635 F9                      	STC
  5031 00001636 EBFB                            JMP	SHORT GET_RET
  5032                                  
  5033                                  ; ----------------------------------------------------------------------
  5034                                  ; SYINIT2.ASM (MSDOS 3.3, 02/02/1988)
  5035                                  ; ----------------------------------------------------------------------
  5036                                  ; 10/06/2018 - Retro DOS v3.0
  5037                                  
  5038                                  ;
  5039                                  ; The following set of routines is used to parse the DRIVPARM = command in
  5040                                  ; the CONFIG.SYS file to change the default drive parameters.
  5041                                  ;
  5042                                  SETPARMS:
  5043 00001638 1E                      	push	ds
  5044 00001639 50                      	push	ax
  5045 0000163A 53                      	push	bx
  5046 0000163B 51                      	push	cx
  5047 0000163C 52                      	push	dx
  5048 0000163D 31DB                    	xor	bx,bx
  5049 0000163F 8A1E[B61C]              	mov	bl,[DRIVE]
  5050 00001643 FEC3                    	inc	bl		; get it correct for IOCTL call (1=A,2=B...)
  5051 00001645 0E                      	push	cs
  5052 00001646 1F                      	pop	ds
  5053 00001647 BA[891C]                	mov	dx,DEVICEPARAMETERS
  5054 0000164A B444                    	mov	ah,IOCTL
  5055 0000164C B00D                    	mov	al,GENERIC_IOCTL
  5056 0000164E B508                    	mov	ch,RAWIO
  5057 00001650 B140                    	mov	cl,SET_DEVICE_PARAMETERS
  5058 00001652 CD21                    	int	21H
  5059 00001654 5A                      	pop	dx
  5060 00001655 59                      	pop	cx
  5061 00001656 5B                      	pop	bx
  5062 00001657 58                      	pop	ax
  5063 00001658 1F                      	pop	ds
  5064 00001659 C3                      	retn
  5065                                  
  5066                                  ;
  5067                                  ; Replace default values for further DRIVPARM commands
  5068                                  ;
  5069                                  DIDDLEBACK:
  5070 0000165A C706[8D1C]5000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],80
  5071 00001660 C606[8A1C]02            	mov	byte [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB
  5072 00001665 C706[8B1C]0000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
  5073 0000166B C706[B71C]0000          	mov	word [SWITCHES],0	    ; zero all switches
  5074 00001671 C3                      	retn
  5075                                  
  5076                                  ;
  5077                                  ; Entry point is ParseLine. AL contains the first character in command line.
  5078                                  ;
  5079                                  PARSELINE:			; don't get character first time
  5080 00001672 1E                      	push	ds
  5081 00001673 0E                      	push	cs
  5082 00001674 1F                      	pop	ds
  5083                                  NextSwtch:
  5084 00001675 3C0D                    	cmp	al,13			; carriage return?
  5085 00001677 7421                    	jz	short done_line
  5086 00001679 3C0A                    	cmp	al,10			; linefeed?
  5087 0000167B 743D                    	jz	short put_back		; put it back and done
  5088                                  ; Anything less or equal to a space is ignored.
  5089 0000167D 3C20                    	cmp	al,' '                  ; space?
  5090 0000167F 7610                    	jbe	short get_next		; skip over space
  5091 00001681 3C2F                    	cmp	al,'/'
  5092 00001683 7403                    	jz	short getparm
  5093 00001685 F9                      	stc				; mark error invalid-character-in-input
  5094 00001686 EB30                    	jmp	short exitpl
  5095                                  
  5096                                  getparm:
  5097 00001688 E83900                  	call	Check_Switch
  5098 0000168B 891E[B71C]              	mov	[SWITCHES],BX		; save switches read so far
  5099 0000168F 7207                    	jc	short swterr
  5100                                  get_next:
  5101 00001691 E888FF                  	call	GETCHR
  5102 00001694 7204                    	jc	short done_line
  5103 00001696 EBDD                    	jmp	short NextSwtch
  5104                                  swterr:
  5105 00001698 EB1E                    	jmp	short exitpl		; exit if error
  5106                                  
  5107                                  done_line:
  5108 0000169A F706[B71C]0400          	test	word [SWITCHES],flagdrive  ; see if drive specified
  5109 000016A0 7503                    	jnz	short okay
  5110 000016A2 F9                      	stc				; mark error no-drive-specified
  5111 000016A3 EB13                    	jmp	short exitpl
  5112                                  
  5113                                  okay:
  5114 000016A5 A1[B71C]                	mov	ax,[SWITCHES]
  5115 000016A8 83E003                  	and	ax,0003H	    ; get flag bits for changeline and non-rem
  5116 000016AB A3[8B1C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
  5117 000016AE C706[AF1C]0000          	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
  5118 000016B4 F8                      	clc			    ; everything is fine
  5119 000016B5 E89F00                  	call	SetDeviceParameters
  5120                                  exitpl:
  5121 000016B8 1F                      	pop	ds
  5122 000016B9 C3                      	retn
  5123                                  
  5124                                  put_back:
  5125 000016BA FF06[5108]              	inc	word [COUNT]		; one more char to scan
  5126 000016BE FF0E[5308]              	dec	word [CHRPTR]		; back up over linefeed
  5127 000016C2 EBD6                    	jmp	short done_line
  5128                                  
  5129                                  ;
  5130                                  ; Processes a switch in the input. It ensures that the switch is valid, and
  5131                                  ; gets the number, if any required, following the switch. The switch and the
  5132                                  ; number *must* be separated by a colon. Carry is set if there is any kind of
  5133                                  ; error.
  5134                                  ;
  5135                                  Check_Switch:
  5136 000016C4 E855FF                  	call	GETCHR
  5137 000016C7 7251                    	jc	short err_check
  5138 000016C9 24DF                    	and	al,0DFH			; convert it to upper case
  5139 000016CB 3C41                    	cmp	al,'A'
  5140 000016CD 724B                    	jb	short err_check
  5141 000016CF 3C5A                    	cmp	al,'Z'
  5142 000016D1 7747                    	ja	short err_check
  5143 000016D3 06                      	push	es
  5144 000016D4 0E                      	push	cs
  5145 000016D5 07                      	pop	es
  5146 000016D6 8A0E[4C1D]              	mov	cl,[switchlist]		; get number of valid switches
  5147 000016DA B500                    	mov	ch,0
  5148 000016DC BF[4D1D]                	mov	di,1+switchlist		; point to string of valid switches
  5149 000016DF F2AE                    	repne	scasb
  5150 000016E1 07                      	pop	es
  5151 000016E2 7536                    	jnz	short err_check
  5152 000016E4 B80100                  	mov	ax,1
  5153 000016E7 D3E0                    	shl	ax,cl		; set bit to indicate switch
  5154 000016E9 8B1E[B71C]              	mov	bx,[SWITCHES]	 ; get switches so far
  5155 000016ED 09C3                    	or	bx,ax		; save this with other switches
  5156 000016EF 89C1                    	mov	cx,ax
  5157 000016F1 A97C00                  	test	ax,7CH		; test against switches that require number to follow
  5158 000016F4 7420                    	jz	short done_swtch
  5159 000016F6 E823FF                  	call	GETCHR
  5160 000016F9 721D                    	jc	short err_swtch
  5161 000016FB 3C3A                    	cmp	al,':'
  5162 000016FD 7519                    	jnz	short err_swtch
  5163 000016FF E81AFF                  	call	GETCHR
  5164 00001702 53                      	push	bx			; preserve switches
  5165 00001703 2EC606[4008]20          	mov	byte [cs:SEPCHR],' '	; allow space separators
  5166 00001709 E82F02                  	call	GETNUM
  5167 0000170C 2EC606[4008]00          	mov	byte [cs:SEPCHR],0
  5168 00001712 5B                      	pop	bx			; restore switches
  5169                                  ; Because GetNum does not consider carriage-return or line-feed as OK, we do
  5170                                  ; not check for carry set here. If there is an error, it will be detected
  5171                                  ; further on (hopefully).
  5172 00001713 E80600                  	call	Process_Num
  5173                                  
  5174                                  done_swtch:
  5175 00001716 F8                      	clc
  5176 00001717 C3                      	retn
  5177                                  
  5178                                  err_swtch:
  5179 00001718 31CB                    	xor	bx,cx			; remove this switch from the records
  5180                                  err_check:
  5181 0000171A F9                      	stc
  5182 0000171B C3                      	retn
  5183                                  
  5184                                  ;
  5185                                  ; This routine takes the switch just input, and the number following (if any),
  5186                                  ; and sets the value in the appropriate variable. If the number input is zero
  5187                                  ; then it does nothing - it assumes the default value that is present in the
  5188                                  ; variable at the beginning. Zero is OK for form factor and drive, however.
  5189                                  ;
  5190                                  Process_Num:
  5191 0000171C 850E[B71C]              	test	[SWITCHES],cx		; if this switch has been done before,
  5192 00001720 7533                    	jnz	short done_ret		; ignore this one.
  5193 00001722 F7C10400                	test	cx,flagdrive
  5194 00001726 7405                    	jz	short try_f
  5195 00001728 A2[B61C]                	mov	[DRIVE],al
  5196 0000172B EB28                    	jmp	short done_ret
  5197                                  
  5198                                  try_f:
  5199 0000172D F7C14000                	test	cx,flagff
  5200 00001731 7405                    	jz	short try_t
  5201                                  ; Ensure that we do not get bogus form factors that are not supported
  5202                                  	;cmp	al,Max_Dev_Type
  5203                                  	;ja	short done_ret
  5204 00001733 A2[8A1C]                	mov	byte [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE],al
  5205 00001736 EB1D                    	jmp	short done_ret
  5206                                  
  5207                                  try_t:
  5208 00001738 09C0                    	or	ax,ax
  5209 0000173A 7419                    	jz	short done_ret	 ; if number entered was 0, assume default value
  5210 0000173C F7C10800                	test	cx,flagcyln
  5211 00001740 7405                    	jz	short try_s
  5212 00001742 A3[8D1C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],ax
  5213 00001745 EB0E                    	jmp	short done_ret
  5214                                  
  5215                                  try_s:
  5216 00001747 F7C11000                	test	cx,flagseclim
  5217 0000174B 7405                    	jz	short try_h
  5218 0000174D A3[B41C]                	mov	[SLIM],ax
  5219 00001750 EB03                    	jmp	short done_ret
  5220                                  ;
  5221                                  ; Must be for number of heads
  5222                                  try_h:
  5223 00001752 A3[B21C]                	mov	[HLIM],ax
  5224                                  
  5225                                  done_ret:
  5226 00001755 F8                      	clc
  5227 00001756 C3                      	retn
  5228                                  
  5229                                  ; 05/07/2018 - Retro DOS v3.0
  5230                                  
  5231                                  ;
  5232                                  ; SetDeviceParameters sets up the recommended BPB in each BDS in the
  5233                                  ; system based on the form factor. It is assumed that the BPBs for the
  5234                                  ; various form factors are present in the BPBTable. For hard files,
  5235                                  ; the Recommended BPB is the same as the BPB on the drive.
  5236                                  ; No attempt is made to preserve registers since we are going to jump to
  5237                                  ; SYSINIT straight after this routine.
  5238                                  ;
  5239                                  SetDeviceParameters:
  5240                                  	; 06/07/2018 - Retro DOS v3.0
  5241 00001757 06                      	push	es
  5242 00001758 0E                      	push	cs
  5243 00001759 07                      	pop	es
  5244                                  ;ASSUME ES:SYSINITSEG
  5245 0000175A 31DB                    	xor	bx,bx
  5246 0000175C 8A1E[8A1C]              	mov	bl,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5247 00001760 80FB00                  	cmp	bl,DEV_5INCH
  5248 00001763 7507                    	jnz	short Got_80
  5249 00001765 B92800                  	mov	cx,40			; 48tpi has 40 cylinders
  5250 00001768 890E[8D1C]              	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_CYLINDERS],cx
  5251                                  Got_80:
  5252 0000176C D1E3                    	shl	bx,1			; get index into BPB table
  5253                                  	; 06/07/2018
  5254                                  	;mov	si,BPBTable
  5255 0000176E 81C3[381D]              	add	bx,BPBTable
  5256                                  	;mov	si,[si+bx]		; get address of BPB
  5257 00001772 8B37                    	mov	si,[bx]
  5258                                  Set_RecBPB:
  5259 00001774 BF[901C]                	mov	di,DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB ; es:di -> BPB
  5260                                  	; 06/07/2018
  5261                                  	;mov	cx,A_BPB.size ; = 31
  5262 00001777 B91900                  	mov	cx,BPBSIZ ; = 25 
  5263 0000177A FC                      	cld
  5264 0000177B F3A4                    	repe	movsb
  5265 0000177D 07                      	pop	es
  5266                                  ;ASSUME ES:NOTHING
  5267 0000177E F706[B71C]1000          	test	word [SWITCHES],flagseclim
  5268 00001784 7406                    	jz	short see_heads
  5269 00001786 A1[B41C]                	mov	ax,[SLIM]
  5270 00001789 A3[9D1C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],ax
  5271                                  see_heads:
  5272 0000178C F706[B71C]2000          	test	word [SWITCHES],flagheads
  5273 00001792 743E                    	jz	short Set_All_Done
  5274 00001794 A1[B21C]                	mov	ax,[HLIM]
  5275 00001797 A3[9F1C]                	mov	word [DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax
  5276                                  ;
  5277                                  ; We need to set the media byte and the total number of sectors to reflect the
  5278                                  ; number of heads. We do this by multiplying the number of heads by the number
  5279                                  ; of 'sectors per head'. This is not a fool-proof scheme!!
  5280                                  ;
  5281 0000179A 89C1                    	mov	cx,ax			; cx has number of heads
  5282 0000179C FEC9                    	dec	cl			; get it 0-based
  5283 0000179E A1[981C]                	mov	ax,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
  5284                                  					; this is OK for two heads
  5285 000017A1 D1F8                    	sar	ax,1			; ax contains # of sectors/head
  5286 000017A3 D3E0                    	sal	ax,cl
  5287 000017A5 722B                    	jc	short Set_All_Done	; We have too many sectors - overflow!!
  5288 000017A7 A3[981C]                	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS],ax
  5289                                  ; Set up correct Media Descriptor Byte
  5290 000017AA 80F901                  	cmp	cl,1
  5291 000017AD B3F0                    	mov	bl,0F0H
  5292 000017AF B002                    	mov	al,2			; AL contains sectors/cluster
  5293 000017B1 7717                    	ja	short Got_Correct_Mediad
  5294 000017B3 8A1E[9A1C]              	mov	bl,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
  5295 000017B7 7411                    	je	short Got_Correct_Mediad
  5296                                  ; We have one head - OK for 48tpi medium
  5297 000017B9 B001                    	mov	al,1			; AL contains sectors/cluster
  5298 000017BB 8A2E[8A1C]              	mov	ch,[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_DEVICETYPE]
  5299 000017BF 80FD00                  	cmp	ch,DEV_5INCH
  5300 000017C2 7404                    	jz	short Dec_Mediad
  5301 000017C4 B3F0                    	mov	bl,0F0H
  5302 000017C6 EB02                    	jmp	short Got_Correct_Mediad
  5303                                  Dec_Mediad:
  5304 000017C8 FECB                    	dec	bl			; adjust for one head
  5305                                  Got_Correct_Mediad:
  5306 000017CA 881E[9A1C]              	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR],bl
  5307 000017CE A2[921C]                	mov	[DEVICEPARAMETERS+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al
  5308 000017D1 F8                      	clc
  5309                                  Set_All_Done:
  5310 000017D2 C3                      	RETN
  5311                                  
  5312                                  ;ASSUME DS:NOTHING, ES:NOTHING
  5313                                  
  5314 000017D3 F9                      NOCHAR1: STC
  5315 000017D4 C3                      	 retn
  5316                                  
  5317                                  ; ---------------------------------------
  5318                                  
  5319                                  ORGANIZE:
  5320                                  	;mov	cx,[cs:COUNT] ; 05/07/2018
  5321 000017D5 8B0E[5108]                      MOV     CX,[COUNT]
  5322 000017D9 E3F8                            JCXZ    NOCHAR1
  5323 000017DB E8B700                          CALL    MAPCASE
  5324 000017DE 31F6                            XOR     SI,SI
  5325 000017E0 89F7                            MOV     DI,SI
  5326                                  
  5327                                  ORG1:   
  5328 000017E2 E86F00                  	CALL    GET                     ; SKIP LEADING CONTROL CHARACTERS
  5329 000017E5 3C20                            CMP     AL,' '
  5330 000017E7 72F9                            JB      SHORT ORG1
  5331                                  
  5332 000017E9 51                              PUSH    CX
  5333 000017EA 56                              PUSH    SI
  5334 000017EB 57                              PUSH    DI
  5335 000017EC 89F5                            MOV     BP,SI
  5336 000017EE 4D                              DEC     BP
  5337 000017EF BE[361C]                        MOV     SI,COMTAB		; Prepare to search command table
  5338 000017F2 B500                            MOV     CH,0
  5339                                  FINDCOM:
  5340 000017F4 89EF                            MOV     DI,BP
  5341 000017F6 8A0C                            MOV     CL,[SI]
  5342 000017F8 46                              INC     SI
  5343 000017F9 E30E                            JCXZ    NOCOM
  5344 000017FB F3A6                            REPE    CMPSB
  5345 000017FD 9F                              LAHF
  5346 000017FE 01CE                            ADD     SI,CX                   ; Bump to next position without affecting flags
  5347 00001800 9E                              SAHF
  5348 00001801 AC                              LODSB                           ; Get indicator letter
  5349 00001802 75F0                            JNZ     SHORT FINDCOM
  5350 00001804 5F                              POP     DI
  5351 00001805 5E                              POP     SI
  5352 00001806 59                              POP     CX
  5353 00001807 EB05                            JMP     SHORT GOTCOM
  5354                                  
  5355                                  NOCOM:
  5356 00001809 5F                              POP     DI
  5357 0000180A 5E                              POP     SI
  5358 0000180B 59                              POP     CX
  5359 0000180C B05A                            MOV     AL,'Z'
  5360                                  GOTCOM: 
  5361 0000180E AA                      	STOSB                           ; SAVE INDICATOR CHAR IN BUFFER
  5362                                  
  5363                                  ORG2:   
  5364 0000180F E83A00                  	CALL    GET2                    ; SKIP NAME UNTIL DELIMETER
  5365 00001812 E84C00                          CALL    DELIM                   ;
  5366 00001815 75F8                            JNZ     SHORT ORG2
  5367                                  
  5368                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT2.ASM, 02/02/2018)
  5369                                  ;--------------------------------------------------------------bug330a03
  5370                                  ; - isp
  5371                                  ;* the following two lines in the parsing caused the drivparm line to break
  5372                                  ;* we cannot let the "/" character be counted as a delimiter here. 
  5373                                  ;	CALL	GET			;GET CHARS TO RIGHT OF EQUALS SIGN
  5374                                  ;	STOSB
  5375                                  ;--------------------------------------------------------------bug330a03
  5376                                  
  5377                                  ;--------------------------------------------------------------bug330a03
  5378                                  ; - isp
  5379                                  ;* the following lines replaced the lines taken out
  5380 00001817 E83200                  ORG3:	CALL	GET2
  5381 0000181A E84800                  	call	DELIM1
  5382 0000181D 74F8                    	jz	short ORG3
  5383 0000181F 3C2F                    	cmp	al,'/'
  5384 00001821 7421                    	jz	short ORG_EXT
  5385 00001823 AA                      	stosb
  5386                                  ;--------------------------------------------------------------bug330a03
  5387                                  
  5388                                  ORG4:   
  5389 00001824 E82500                  	CALL    GET2
  5390 00001827 E83700                  	CALL	DELIM ; 26/03/2018
  5391 0000182A 7418                    	JZ	SHORT ORG_EXT
  5392 0000182C AA                              STOSB
  5393 0000182D 3C20                            CMP     AL,' '
  5394 0000182F 77F3                            JA      SHORT ORG4
  5395 00001831 3C0A                            CMP     AL,10
  5396 00001833 74AD                            JZ      SHORT ORG1
  5397                                  
  5398 00001835 26C645FF00                      MOV     BYTE [ES:DI-1],0
  5399                                  ORG5:   
  5400 0000183A E80F00                  	CALL    GET2
  5401 0000183D AA                              STOSB
  5402 0000183E 3C0A                            CMP     AL,10
  5403 00001840 75F8                            JNZ     SHORT ORG5
  5404 00001842 EB9E                            JMP     SHORT ORG1
  5405                                  
  5406                                  ORG_EXT: ; 26/03/2018
  5407 00001844 26C60500                	MOV	BYTE [ES:DI], 0		;put 0 at DI to make it an ASCIIZ
  5408 00001848 47                      	INC	DI
  5409 00001849 AA                      	STOSB				;and copy the delimeter char.
  5410 0000184A EBEE                    	JMP	SHORT ORG5		;and continue as usual.
  5411                                  
  5412                                  GET2:
  5413 0000184C E32E                            JCXZ    NOGET
  5414 0000184E 268A04                          MOV     AL,[ES:SI]
  5415 00001851 46                              INC     SI
  5416 00001852 49                              DEC     CX
  5417 00001853 C3                              RETN
  5418                                  
  5419                                  GET:    
  5420 00001854 E326                    	JCXZ    NOGET
  5421 00001856 268A04                          MOV     AL,[ES:SI]
  5422 00001859 46                              INC     SI
  5423 0000185A 49                              DEC     CX
  5424 0000185B E80300                          CALL    DELIM
  5425 0000185E 74F4                            JZ      SHORT GET
  5426                                  GRET:   
  5427 00001860 C3                      	RETN
  5428                                  
  5429                                  ; 10/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT2.ASM, 02/02/2018)
  5430                                  ;--------------------------------------------------------------bug330a03
  5431                                  ; isp - small changes here, new entry point into routine
  5432                                  DELIM:	
  5433 00001861 3C2F                    	CMP	AL,'/'          ; 5/30/86. IBM will assume "/" delim  ;3.30
  5434 00001863 74FB                    	jz	short GRET					      ;3.30
  5435                                  DELIM1:
  5436 00001865 3C20                    	CMP	AL,' '
  5437 00001867 74F7                    	jz	short GRET
  5438 00001869 3C09                    	CMP	AL,9
  5439 0000186B 74F3                    	jz	short GRET
  5440 0000186D 3C3D                    	CMP	AL,'='
  5441 0000186F 74EF                    	jz	short GRET
  5442 00001871 3C2C                    	CMP	AL,','
  5443 00001873 74EB                    	jz	short GRET
  5444 00001875 3C3B                    	CMP	AL,';'
  5445 00001877 74E7                    	jz	short GRET	; 5/23/86			      ;3.30
  5446 00001879 3C00                    	cmp	al, 0		; 5/23/86 Special case for sysinit!!! ;3.30
  5447 0000187B C3                      	retn
  5448                                  
  5449                                  ;--------------------------------------------------------------bug330a03
  5450                                  
  5451                                  NOGET:  
  5452 0000187C 59                      	POP     CX
  5453                                  	; 20/06/2018
  5454                                          ;MOV	[cs:COUNT],DI
  5455 0000187D 893E[5108]                      MOV     [COUNT],DI ; 05/07/2018
  5456 00001881 31F6                            XOR     SI,SI
  5457                                          ;MOV	[cs:CHRPTR],SI
  5458 00001883 8936[5308]                      MOV	[CHRPTR],SI ; 05/07/2018
  5459 00001887 C3                              RETN
  5460                                  
  5461                                  ;
  5462                                  ;  NEWLINE RETURNS WITH FIRST CHARACTER OF NEXT LINE
  5463                                  ;
  5464                                  NEWLINE:
  5465 00001888 E891FD                  	CALL    GETCHR                  ; SKIP NON-CONTROL CHARACTERS
  5466 0000188B 7207                            JC      SHORT NONEW
  5467 0000188D 3C0A                            CMP     AL,10                   ; LOOK FOR LINE FEED
  5468 0000188F 75F7                            JNZ     SHORT NEWLINE
  5469 00001891 E888FD                          CALL    GETCHR
  5470                                  NONEW:  
  5471 00001894 C3                      	RETN
  5472                                  
  5473                                  MAPCASE:
  5474 00001895 51                              PUSH    CX
  5475 00001896 56                              PUSH    SI
  5476 00001897 1E                              PUSH    DS
  5477 00001898 06                              PUSH    ES
  5478 00001899 1F                              POP     DS
  5479 0000189A 31F6                            XOR     SI,SI
  5480                                  CONVLOOP:
  5481 0000189C AC                              LODSB
  5482                                  
  5483                                          ;IF      KANJI
  5484                                          ;CALL    TESTKANJ
  5485                                          ;JZ      SHORT NORMCONV
  5486                                          ;INC     SI			; Skip next char
  5487                                          ;DEC     CX
  5488                                          ;JCXZ    CONVDONE		; Just ignore 1/2 kanji error
  5489                                  ; Fall through, know AL is not in 'a'-'z' range
  5490                                  ;NORMCONV:
  5491                                          ;ENDIF
  5492                                  
  5493 0000189D 3C61                            CMP     AL,'a'
  5494 0000189F 7209                            JB      SHORT NOCONV
  5495 000018A1 3C7A                            CMP     AL,'z'
  5496 000018A3 7705                            JA      SHORT NOCONV
  5497 000018A5 2C20                            SUB     AL,20H
  5498 000018A7 8844FF                          MOV     [SI-1],AL
  5499                                  NOCONV:
  5500 000018AA E2F0                            LOOP    CONVLOOP
  5501                                  CONVDONE:
  5502 000018AC 1F                              POP     DS
  5503 000018AD 5E                              POP     SI
  5504 000018AE 59                              POP     CX
  5505 000018AF C3                              RETN
  5506                                  
  5507                                          ;IF      KANJI
  5508                                  ;TESTKANJ:
  5509                                          ;CMP     AL,81H
  5510                                          ;JB      SHORT NOTLEAD
  5511                                          ;CMP     AL,9FH
  5512                                          ;JBE     SHORT ISLEAD
  5513                                          ;CMP     AL,0E0H
  5514                                          ;JB      SHORT NOTLEAD
  5515                                          ;CMP     AL,0FCH
  5516                                          ;JBE    SHORT  ISLEAD
  5517                                  ;NOTLEAD:
  5518                                          ;PUSH    AX
  5519                                          ;XOR     AX,AX			; Set zero
  5520                                          ;POP     AX
  5521                                          ;RETN
  5522                                  ;ISLEAD:
  5523                                          ;PUSH    AX
  5524                                          ;XOR     AX,AX			; Set zero
  5525                                          ;INC     AX			; Reset zero
  5526                                          ;POP     AX
  5527                                          ;RETN
  5528                                          ;ENDIF
  5529                                  
  5530                                  Yes_Break_Failed:			;dev drv Init failed and aborted.
  5531 000018B0 F9                      	stc
  5532 000018B1 58                      	pop	ax
  5533 000018B2 C3                      	retn
  5534                                  
  5535                                  SET_BREAK:
  5536                                  	; 22/06/2018
  5537                                  	; 10/06/2018 - Retro DOS v3.0
  5538                                  
  5539                                  ; 8/14/86  For DOS 3.3, this routine is modified to take care of the
  5540                                  ;Device driver's initialization error and abort.
  5541                                  ;If [break_addr+2] == [memhi] && [break_addr] = 0 then assume
  5542                                  ;that the device driver's initialization has an error and wanted to
  5543                                  ;abort the device driver.  In this case, this routine will set carry
  5544                                  ;and return to the caller.
  5545                                  ;
  5546 000018B3 50                      	PUSH	AX
  5547 000018B4 2EA1[7008]              	MOV	AX,[CS:BREAK_ADDR+2]	;REMOVE THE INIT CODE
  5548 000018B8 2E3B06[5A08]            	cmp	ax,[CS:MEMHI]
  5549 000018BD 7508                    	jne	short Set_Break_Continue  ;if not same, then O.K.
  5550                                  
  5551 000018BF 2E833E[6E08]00          	cmp	word [CS:BREAK_ADDR],0 
  5552 000018C5 74E9                    	je	SHORT Yes_Break_Failed	;[Break_addr+2]=[MEMHI] & [Break_addr]=0 
  5553                                  
  5554                                  Set_Break_Continue:
  5555 000018C7 2EA3[5A08]              	MOV	[CS:MEMHI],AX
  5556 000018CB 2EA1[6E08]              	MOV	AX,[CS:BREAK_ADDR]
  5557 000018CF 2EA3[5808]              	MOV	[CS:MEMLO],AX
  5558 000018D3 58                      	POP	AX			    ; NOTE FALL THROUGH
  5559                                  
  5560                                  ;
  5561                                  ; Round the values in MEMLO and MEMHI to paragraph boundary.
  5562                                  ; Perform bounds check.
  5563                                  ;
  5564                                  
  5565                                  ROUND: 
  5566                                  	; 22/06/2018 
  5567                                  	; 10/06/2018 - Retro DOS v3.0
  5568                                  	; 26/03/2018
  5569 000018D4 50                      	PUSH	AX
  5570 000018D5 2EA1[5808]              	MOV     AX,[CS:MEMLO]
  5571 000018D9 E8E1F4                  	CALL	ParaRound
  5572 000018DC 2E0106[5A08]                    ADD     [CS:MEMHI],AX
  5573                                          ;XOR     AX,AX
  5574                                          ;MOV     [CS:MEMLO],AX
  5575                                  	; 06/07/2018
  5576 000018E1 2EC706[5808]0000        	mov	word [CS:MEMLO], 0
  5577 000018E8 2EA1[5A08]              	MOV	AX,[CS:MEMHI]		; ax = new memhi
  5578 000018EC 2E3B06[1908]            	CMP	AX,[CS:ALLOCLIM]	; if new memhi >= alloclim, error
  5579 000018F1 7303                    	JAE	SHORT MEM_ERR
  5580 000018F3 58                      	POP	AX
  5581 000018F4 F8                      	CLC
  5582 000018F5 C3                              RETN
  5583                                  
  5584                                  MEM_ERR:
  5585 000018F6 BA[321E]                	MOV	DX,BADMEM
  5586 000018F9 0E                      	PUSH	CS
  5587 000018FA 1F                      	POP	DS
  5588 000018FB E84502                  	CALL	PRINT
  5589 000018FE E9F4F1                  	JMP	STALL
  5590                                  
  5591                                  CALLDEV:
  5592 00001901 2E8E1E[FA07]            	MOV     DS,[CS:ENTRY_POINT+2]
  5593 00001906 2E031E[F807]                    ADD     BX,[CS:ENTRY_POINT]	; Do a little relocation
  5594 0000190B 8B07                            MOV     AX,[BX]
  5595 0000190D 2EFF36[F807]                    PUSH    WORD [CS:ENTRY_POINT]
  5596 00001912 2EA3[F807]                      MOV     [CS:ENTRY_POINT],AX
  5597 00001916 BB[6008]                        MOV     BX,PACKET
  5598 00001919 2EFF1E[F807]                    CALL    FAR [CS:ENTRY_POINT]	; 10/06/2018
  5599 0000191E 2E8F06[F807]                    POP     WORD [CS:ENTRY_POINT]
  5600 00001923 C3                              RETN
  5601                                  
  5602                                  BADNUM:
  5603                                  	; 10/06/2018 - Retro DOS v3.0
  5604 00001924 2EC606[4008]00          	mov	byte [CS:SEPCHR],0 ; 06/07/2018
  5605 0000192A 31C0                    	XOR	AX,AX		; Set Zero flag, and AX = 0
  5606 0000192C 5B                      	pop	bx
  5607 0000192D F9                      	stc			; AND carry set
  5608 0000192E C3                      	retn
  5609                                  
  5610                                  TODIGIT:
  5611 0000192F 2C30                            SUB     AL,'0'
  5612 00001931 7206                            JB      SHORT NOTDIG
  5613 00001933 3C09                            CMP     AL,9
  5614 00001935 7702                            JA      SHORT NOTDIG
  5615 00001937 F8                              CLC
  5616 00001938 C3                              RETN
  5617                                  NOTDIG: 
  5618 00001939 F9                      	STC
  5619 0000193A C3                              RETN
  5620                                  
  5621                                  ; GetNum parses a decimal number.
  5622                                  ; Returns it in AX, sets zero flag if AX = 0 (MAY BE considered an
  5623                                  ; error), if number is BAD carry is set, zero is set, AX=0.
  5624                                  
  5625                                  GETNUM: 
  5626 0000193B 53                      	push	bx	; 10/06/2018 (Retro DOS 3.0, MSDOS 3.3)
  5627 0000193C 31DB                    	XOR     BX,BX                   ; running count is zero
  5628                                  B2:     
  5629 0000193E E8EEFF                  	CALL    TODIGIT                 ; do we have a digit
  5630 00001941 72E1                            JC      SHORT BADNUM		; no, bomb
  5631 00001943 93                              XCHG    AX,BX                   ; put total in AX
  5632 00001944 53                              PUSH    BX                      ; save digit
  5633 00001945 BB0A00                          MOV     BX,10                   ; base of arithmetic
  5634 00001948 F7E3                            MUL     BX                      ; shift by one decimal digit
  5635 0000194A 5B                              POP     BX                      ; get back digit
  5636 0000194B 00D8                            ADD     AL,BL                   ; get total
  5637 0000194D 80D400                          ADC     AH,0                    ; make that 16 bits
  5638 00001950 72D2                            JC      SHORT BADNUM		; too big a number
  5639 00001952 93                              XCHG    AX,BX                   ; stash total
  5640 00001953 E8C6FC                          CALL    GETCHR                  ; GET NEXT DIGIT
  5641 00001956 722D                            JC      SHORT B1		; no more characters
  5642                                  
  5643                                  	; 10/06/2018
  5644 00001958 3C20                    	cmp	al,' '			; 5/23/86 space? 
  5645 0000195A 741F                    	jz	short B15		; 5/23/86 then end of digits
  5646 0000195C 3C2C                    	cmp	al,','			; 5/23/86 ',' is a seperator!
  5647 0000195E 741B                    	jz	short B15		; 5/23/86 then end of digits.
  5648 00001960 3C09                    	cmp	al,9			; 5/23/86 TAB
  5649 00001962 7417                    	jz	short B15		;
  5650                                  	; 22/06/2018
  5651 00001964 2E3A06[4008]            	CMP	AL,[CS:SEPCHR]		; allow , separators
  5652 00001969 7410                    	JZ	short B15
  5653 0000196B 3C2F                    	cmp	al,SWTCHR		; See if another switch follows
  5654 0000196D 740C                    	JZ	short B15
  5655 0000196F 3C0A                    	cmp	al,10			; Line-feed?
  5656 00001971 7408                    	jz	short B15
  5657 00001973 3C0D                    	cmp	al,13			; Carriage return?
  5658 00001975 7404                    	jz	short B15
  5659                                  	
  5660 00001977 08C0                    	OR      AL,AL                   ; end of line separator?
  5661 00001979 75C3                            JNZ     SHORT B2		; no, try as a valid character
  5662                                  B15:        
  5663 0000197B 2EFF06[5108]            	INC     WORD [CS:COUNT]		; one more character to scan
  5664 00001980 2EFF0E[5308]                    DEC     WORD [CS:CHRPTR]	; back up over separator
  5665                                  B1:     
  5666 00001985 89D8                    	MOV     AX,BX                   ; get proper count
  5667 00001987 09C0                            OR      AX,AX
  5668 00001989 5B                      	pop	bx	; 10/06/2018
  5669 0000198A C3                              RETN
  5670                                  
  5671                                  SKIP_DELIM:
  5672                                  ;Skip the delimeters pointed by CHRPTR. AL will contain the first non delimeter
  5673                                  ;character encountered and CHRPTR will point to the next character.
  5674                                  ;This routine will assume the second "," found as a non delimiter character.
  5675                                  ;So, in case if the string is " , , ", this routine will stop at the second ",".
  5676                                  ;At this time, Zero flag is set.
  5677                                  ;If COUNT is exhausted, then carry will be set.
  5678                                  Skip_delim_char:
  5679 0000198B E88EFC                  	call	GETCHR
  5680 0000198E 7218                    	jc	short Skip_delim_exit
  5681 00001990 3C2C                    	cmp	al,','			;the first comma?
  5682 00001992 7406                    	je	short Skip_delim_next
  5683 00001994 E8CAFE                  	call	DELIM			;check the charater in AL.
  5684 00001997 74F2                    	jz	short Skip_delim_char
  5685                                  	; 06/07/2018
  5686                                  	;jmp	short Skip_delim_exit	;found a non delim char
  5687 00001999 C3                      	retn
  5688                                  Skip_delim_next:
  5689 0000199A E87FFC                  	call	GETCHR
  5690 0000199D 7209                    	jc	short Skip_delim_exit
  5691 0000199F 3C2C                    	cmp	al,','			;the second comma?
  5692 000019A1 7405                    	je	short Skip_delim_exit 	;done
  5693 000019A3 E8BBFE                  	call	DELIM
  5694 000019A6 74F2                    	jz	short Skip_delim_next
  5695                                  Skip_delim_exit:
  5696 000019A8 C3                      	retn
  5697                                  
  5698                                  ; 10/06/2018 (Retro DOS 3.0, MSDOS 3.3)
  5699                                  
  5700                                  ; 5/26/86 *****************************************************************
  5701                                  SetDOSCountryInfo:
  5702                                  ;Input: ES:DI -> pointer to DOS_COUNTRY_CDPG_INFO			 
  5703                                  ;	DS:0  -> buffer.						 
  5704                                  ;	SI = 0								 
  5705                                  ;	AX = country id 						 
  5706                                  ;	DX = code page id. (If 0, then use ccSysCodePage as a default.) 
  5707                                  ;	BX = file handle						 
  5708                                  ;	This routine can handle maxium 72 COUNTRY_DATA entries. 	 
  5709                                  ;Output: DOS_country_cdpg_info set.					 
  5710                                  ;	 Carry set if any file read failure or wrong information in the file.
  5711                                  ;	 Carry set and CX = -1 if cannot find the matching COUNTRY_id, CODEPAGE
  5712                                  ;	 _id in the file.						 
  5713                                  									 
  5714 000019A9 57                      	push	di							 
  5715 000019AA 50                      	push	ax							 
  5716 000019AB 52                      	push	dx							 
  5717                                  									 
  5718 000019AC 31C9                    	xor	cx,cx							 
  5719 000019AE 31D2                    	xor	dx,dx							 
  5720 000019B0 B80002                  	mov	ax,512			;read 512 bytes 		 
  5721 000019B3 E80701                  	call	ReadInControlBuffer	;Read the file header		 
  5722 000019B6 724C                    	jc	short SetDOSData_fail 					 
  5723 000019B8 06                      	push	es							 
  5724 000019B9 56                      	push	si							 
  5725 000019BA 0E                      	push	cs							 
  5726 000019BB 07                      	pop	es							 
  5727 000019BC BF[0B1C]                	mov	di,COUNTRY_FILE_SIGNATURE			 
  5728 000019BF B90800                  	mov	cx,8			;length of the signature	 
  5729 000019C2 F3A6                    	repz	cmpsb							 
  5730 000019C4 5E                      	pop	si							 
  5731 000019C5 07                      	pop	es							 
  5732 000019C6 753C                    	jnz	short SetDOSData_fail 	;signature mismatch		 
  5733                                  									 
  5734 000019C8 83C612                  	add	si,18			;SI -> county info type 	 
  5735 000019CB 803C01                  	cmp	byte [si],1		;Only accept type 1 (Currently only 1 header type)
  5736 000019CE 7534                    	jne	short SetDOSData_fail 	;cannot proceed. error return	 
  5737 000019D0 46                      	inc	si			;SI -> file offset		 
  5738 000019D1 8B14                    	mov	dx,[si]			;Get the INFO file offset.	 
  5739 000019D3 8B4C02                  	mov	cx,[si+2]					 
  5740 000019D6 B80004                  	mov	ax,1024			;read 1024 bytes.		 
  5741 000019D9 E8E100                  	call	ReadInControlBuffer	;Read INFO			 
  5742 000019DC 7226                    	jc	short SetDOSData_fail 					 
  5743 000019DE 8B0C                    	mov	cx,[si]			;get the # of country, codepage combination entries
  5744 000019E0 83F948                  	cmp	cx,72			;cannot handle more than 72 entries.
  5745 000019E3 771F                    	ja	short SetDOSData_fail 					 
  5746 000019E5 46                      	inc	si							 
  5747 000019E6 46                      	inc	si			;SI -> entry information packet 
  5748 000019E7 5A                      	pop	dx			;restore code page id		 
  5749 000019E8 58                      	pop	ax			;restore country id		 
  5750 000019E9 5F                      	pop	di							 
  5751                                  									 
  5752                                  SetDOSCntry_find:			;Search for desired country_id,codepage_id.
  5753 000019EA 3B4402                  	cmp	ax,[si+2]		;compare country_id		 
  5754 000019ED 750A                    	jne	short SetDOSCntry_next					 
  5755 000019EF 83FA00                  	cmp	dx,0			;No user specified code page ?	 
  5756 000019F2 7415                    	je	short SetDOSCntry_any_CodePage ;then no need to match code page id.
  5757 000019F4 3B5404                  	cmp	dx,[si+4]		;compare code page id		 
  5758 000019F7 7413                    	je	short SetDOSCntry_got_it					 
  5759                                  SetDOSCntry_next:							 
  5760 000019F9 0334                    	add	si,[si]			;next entry			 
  5761 000019FB 46                      	inc	si							 
  5762 000019FC 46                      	inc	si			;take a word for size of entry itself
  5763 000019FD E2EB                    	loop	SetDOSCntry_find					 
  5764 000019FF B9FFFF                  	mov	cx, -1			;signals that bad country id entered.
  5765                                  SetDOSCntry_fail:							 
  5766 00001A02 F9                      	stc								 
  5767 00001A03 C3                      	retn								 
  5768                                  									 
  5769                                  SetDOSData_fail:							 
  5770 00001A04 5E                      	pop	si							 
  5771 00001A05 59                      	pop	cx							 
  5772 00001A06 5F                      	pop	di							 
  5773 00001A07 EBF9                    	jmp	short SetDOSCntry_fail				 
  5774                                  									 
  5775                                  SetDOSCntry_any_CodePage:		;use the code_page_id of the country_id found.
  5776 00001A09 8B5404                  	mov	dx,[si+4]					 
  5777                                  SetDOSCntry_got_it:			;found the matching entry	 
  5778 00001A0C 2E8916[131C]            	mov	[cs:CntryCodePage_Id],dx ;save code page ID for this country.
  5779 00001A11 8B540A                  	mov	dx,[si+10]		;get the file offset of country data
  5780 00001A14 8B4C0C                  	mov	cx,[si+12] 				 
  5781 00001A17 B80002                  	mov	ax,512			;read 512 bytes 		 
  5782 00001A1A E8A000                  	call	ReadInControlBuffer					 
  5783 00001A1D 72E3                    	jc	short SetDOSCntry_fail					 
  5784 00001A1F 8B0C                    	mov	cx,[si]			;get the number of entries to handle.
  5785 00001A21 46                      	inc	si							 
  5786 00001A22 46                      	inc	si			;SI -> first entry		 
  5787                                  									 
  5788                                  SetDOSCntry_data:							 
  5789 00001A23 57                      	push	di			;ES:DI -> DOS_COUNTRY_CDPG_INFO 
  5790 00001A24 51                      	push	cx			;save # of entry left		 
  5791 00001A25 56                      	push	si			;si -> current entry in Control buffer
  5792                                  									 
  5793 00001A26 8A4402                  	mov	al,[si+2]		;get data entry id		 
  5794 00001A29 E86300                  	call	GetCountryDestination	;get the address of destination in ES:DI
  5795 00001A2C 7257                    	jc	short SetDOSCntry_data_next ;No matching data entry id in DOS 
  5796                                  									 
  5797 00001A2E 8B5404                  	mov	dx,[si+4]		;get offset of data		 
  5798 00001A31 8B4C06                  	mov	cx,[si+6]					 
  5799 00001A34 B80042                  	mov	ax,4200h						 
  5800 00001A37 F9                      	stc								 
  5801 00001A38 CD21                    	int	21h			;move pointer			 
  5802 00001A3A 72C8                    	jc	short SetDOSData_fail 					 
  5803 00001A3C BA0002                  	mov	dx,512			;start of data buffer		 
  5804 00001A3F 268B0D                  	mov	cx,[es:di]		;length of the corresponding data in DOS.
  5805 00001A42 83C10A                  	add	cx,10			;Signature + A word for the length itself
  5806 00001A45 B43F                    	mov	ah,3Fh 						 
  5807 00001A47 F9                      	stc								 
  5808 00001A48 CD21                    	int	21h			;read the country.sys data	 
  5809 00001A4A 72B8                    	jc	short SetDOSData_fail 	;read failure			 
  5810 00001A4C 39C8                    	cmp	ax, cx							 
  5811 00001A4E 75B4                    	jne	short SetDOSData_fail 					 
  5812                                  									 
  5813 00001A50 8A4402                  	mov	al,[si+2]		;save Data id for future use.	 
  5814 00001A53 BE0802                  	mov	si,(512+8)		;SI-> data buffer + id tag field 
  5815 00001A56 8B0C                    	mov	cx,[si]			;get the length of the file	 
  5816 00001A58 41                      	inc	cx			;Take care of a word for lenght of tab
  5817 00001A59 41                      	inc	cx			;itself.			 
  5818 00001A5A 81F9F805                	cmp	cx,(2048-512-8)		;Fit into the buffer?		 
  5819 00001A5E 77A4                    	ja	short SetDOSData_fail 					 
  5820 00001A60 3C01                    	cmp	al,SetCountryInfo	;is the data for SetCountryInfo table?
  5821 00001A62 7512                    	jne	short SetDOSCntry_Mov 	;no, don't worry                
  5822 00001A64 26FF7518                	push	word [es:di+24]		;Cannot destroy ccMono_ptr address. Save them.
  5823 00001A68 26FF751A                	push	word [es:di+26]					 
  5824 00001A6C 57                      	push	di			;save DI			 
  5825                                  									 
  5826 00001A6D 50                      	push	ax							 
  5827 00001A6E 2EA1[131C]              	mov	ax,[cs:CntryCodePage_Id] ;Do not use the Code Page info in Country_Info
  5828 00001A72 894404                  	mov	[si+4], ax		;Use the saved one for this !!!! 
  5829 00001A75 58                      	pop	ax							 
  5830                                  									 
  5831                                  SetDOSCntry_Mov:							 
  5832 00001A76 F3A4                    	rep	movsb			;copy the table into DOS	 
  5833 00001A78 3C01                    	cmp	al,SetCountryInfo	;was the ccMono_ptr saved?	 
  5834 00001A7A 7509                    	jne	short SetDOSCntry_data_next					 
  5835 00001A7C 5F                      	pop	di			;restore DI			 
  5836 00001A7D 268F451A                	pop	word [es:di+26]		;restore ccMono_ptr in DOS.	 
  5837 00001A81 268F4518                	pop	word [es:di+24]					 
  5838                                  									 
  5839                                  SetDOSCntry_data_next:							 
  5840 00001A85 5E                      	pop	si			;restore control buffer pointer 
  5841 00001A86 59                      	pop	cx			;restore # of entries left	 
  5842 00001A87 5F                      	pop	di			;restore pointer to DSO_COUNTRY_CDPG
  5843 00001A88 0334                    	add	si,[si]			;try to get the next entry	 
  5844 00001A8A 46                      	inc	si							 
  5845 00001A8B 46                      	inc	si			;take a word of entry length itself
  5846 00001A8C E295                    	loop	SetDOSCntry_data					 
  5847 00001A8E C3                      	retn								 
  5848                                  					 
  5849                                  GetCountryDestination:				 
  5850                                  ;Get the destination address in the DOS country info table.		 
  5851                                  ;Input: AL - Data ID							 
  5852                                  ;	ES:DI -> DOS_COUNTRY_CDPG_INFO					 
  5853                                  ;On return:								 
  5854                                  ;	ES:DI -> Destination address of the matching data id		 
  5855                                  ;	carry set if no matching data id found in DOS.			 
  5856                                  									 
  5857 00001A8F 51                      	push	cx							 
  5858 00001A90 83C74A                  	add	di,country_cdpg_info.ccNumber_of_entries
  5859                                  					;skip the reserved area, syscodepage etc.
  5860 00001A93 268B0D                  	mov	cx,[es:di]		;get the number of entries	 
  5861 00001A96 47                      	inc	di							 
  5862 00001A97 47                      	inc	di			;SI -> the first start entry id 
  5863                                  GetCntryDest:								 
  5864 00001A98 263805                  	cmp	[es:di],al					 
  5865 00001A9B 7413                    	je	short GetCntryDest_OK 					 
  5866 00001A9D 26803D01                	cmp	byte [es:di],SetCountryInfo ;was it SetCountryInfo entry?
  5867 00001AA1 7405                    	je	short GetCntryDest_1						 
  5868 00001AA3 83C705                  	add	di,5			;next data id			 
  5869 00001AA6 EB03                    	jmp	short GetCntryDest_loop 				 
  5870                                  GetCntryDest_1: 							 
  5871 00001AA8 83C729                  	add	di,NEW_COUNTRY_SIZE+3	;next data id			 
  5872                                  GetCntryDest_loop:							 
  5873 00001AAB E2EB                    	loop	GetCntryDest						 
  5874 00001AAD F9                      	stc								 
  5875 00001AAE EB0B                    	jmp	short GetCntryDest_Exit				 
  5876                                  GetCntryDest_OK:							 
  5877 00001AB0 3C01                    	cmp	al,SetCountryInfo	;select country info?		 
  5878 00001AB2 7503                    	jne	short GetCntryDest_OK1					 
  5879 00001AB4 47                      	inc	di			;now DI -> ccCountryInfoLen	 
  5880 00001AB5 EB04                    	jmp	short GetCntryDest_Exit				 
  5881                                  GetCntryDest_OK1:							 
  5882 00001AB7 26C47D01                	les	di,[es:di+1]		;get the destination in ES:DI	 
  5883                                  GetCntryDest_Exit:							 
  5884 00001ABB 59                      	pop	cx							 
  5885 00001ABC C3                      	retn								 
  5886                                  								 
  5887                                  ReadInControlBuffer:				 
  5888                                  ;Move file pointer to CX:DX						 
  5889                                  ;Read AX bytes into the control buffer. (Should be less than 2 Kb)	 
  5890                                  ;SI will be set to 0 hence DS:SI points to the control buffer.		 
  5891                                  ;Entry:  CX,DX offset from the start of the file where the read/write pointer
  5892                                  ;	 be moved.							 
  5893                                  ;	 AX - # of bytes to read					 
  5894                                  ;	 BX - file handle						 
  5895                                  ;	 DS - buffer seg.						 
  5896                                  ;Return: The control data information is read into DS:0 - DS:0200.	 
  5897                                  ;	 CX,DX value destroyed. 					 
  5898                                  ;	 Carry set if error in Reading file.				 
  5899                                  ;									 
  5900 00001ABD 50                      	push	ax			;# of bytes to read		 
  5901 00001ABE B80042                  	mov	ax, 4200h						 
  5902 00001AC1 F9                      	stc								 
  5903 00001AC2 CD21                    	int	21h			;move pointer			 
  5904 00001AC4 59                      	pop	cx			;# of bytes to read		 
  5905 00001AC5 7209                    	jc	short RICB_exit						 
  5906 00001AC7 31D2                    	xor	dx,dx			;ds:dx -> control buffer	 
  5907 00001AC9 31F6                    	xor	si,si							 
  5908 00001ACB B43F                    	mov	ah,3Fh			;read into the buffer		 
  5909 00001ACD F9                      	stc								 
  5910 00001ACE CD21                    	int	21h			;should be less than 1024 bytes. 
  5911                                  RICB_exit:								 
  5912 00001AD0 C3                      	retn								 
  5913                                  									 
  5914                                  SET_COUNTRY_PATH:					 
  5915                                  ;In:  DS - SYSINITSEG, ES - CONFBOT, SI -> start of the asciiz path string
  5916                                  ;     DOSINFO_EXT, CNTRY_DRV, CNTRY_ROOT, CNTRY_PATH			 
  5917                                  ;     Assumes current directory is the ROOT directory.			 
  5918                                  ;Out: DS:DI -> full path (CNTRY_DRV).					 
  5919                                  ;     Set the CNTRY_DRV string from the COUNTRY=,,path command. 	 
  5920                                  ;     DS, ES, SI value saved.						 
  5921                                  									 
  5922 00001AD1 56                      	push	si							 
  5923 00001AD2 1E                      	push	ds			;switch ds, es			 
  5924 00001AD3 06                      	push	es							 
  5925 00001AD4 1F                      	pop	ds							 
  5926 00001AD5 07                      	pop	es			;now DS -> CONFBOT, ES -> SYSINITSEG
  5927                                  									 
  5928 00001AD6 E82E00                  	call	CHK_DRIVE_LETTER	;current DS:[SI] is a drive letter? 
  5929 00001AD9 7206                    	jc	short SCP_Default_drv 	;no, use current default drive. 
  5930 00001ADB 8A04                    	mov	al,[SI]					 
  5931 00001ADD 46                      	inc	si							 
  5932 00001ADE 46                      	inc	si			;SI -> next char after ":"      
  5933 00001ADF EB06                    	jmp	short SCP_SetDrv					 
  5934                                  SCP_Default_drv:							 
  5935 00001AE1 B419                    	mov	ah,19h 						 
  5936 00001AE3 CD21                    	int	21h							 
  5937 00001AE5 0441                    	add	al,"A"			;convert it to a character.     
  5938                                  SCP_SetDrv:								 
  5939 00001AE7 2EA2[C81B]              	mov	[cs:CNTRY_DRV],al	;set the drive letter.		 
  5940 00001AEB BF[CB1B]                	mov	di,CNTRY_PATH					 
  5941 00001AEE 8A04                    	mov	al,[SI]	
  5942 00001AF0 3C5C                    	cmp	al, "\"                                                 
  5943 00001AF2 7406                    	je	short SCP_Root_Dir						 
  5944                                  	; 23/06/2018 - Retro DOS v3.0
  5945                                  	;cmp	al,[cs:SWTCHR]	!!!	;let's accept "/" as an directory delim
  5946 00001AF4 3C2F                    	cmp	al,SWTCHR 
  5947 00001AF6 7402                    	je	short SCP_Root_Dir						 
  5948 00001AF8 EB01                    	jmp	short SCP_Path						 
  5949                                  SCP_Root_Dir:								 
  5950 00001AFA 4F                      	dec	di			;DI -> CNTRY_ROOT		 
  5951                                  SCP_Path:								 
  5952 00001AFB E81F00                  	call	MOVE_ASCIIZ		;copy it			 
  5953 00001AFE BF[C81B]                	mov	di,CNTRY_DRV					 
  5954                                  SCPath_Exit:								 
  5955 00001B01 1E                      	push	ds			;switch ds, es			 
  5956 00001B02 06                      	push	es							 
  5957 00001B03 1F                      	pop	ds							 
  5958 00001B04 07                      	pop	es			;DS, ES value restored		 
  5959 00001B05 5E                      	pop	si							 
  5960 00001B06 C3                      	RETN
  5961                                  								 
  5962                                  CHK_DRIVE_LETTER:				 
  5963                                  ;Check if DS:[SI] is a drive letter followed by ":".                    
  5964                                  ;Assume that every alpha charater is already converted to UPPER CASE.	 
  5965                                  ;Carry set if not.							 
  5966                                  ;									 
  5967 00001B07 50                      	push	ax							 
  5968 00001B08 803C41                  	cmp	byte [si], "A"                                   
  5969 00001B0B 720D                    	jb	short CDLetter_NO						 
  5970 00001B0D 803C5A                  	cmp	byte [si], "Z"                                   
  5971 00001B10 7708                    	ja	short CDLetter_NO						 
  5972 00001B12 807C013A                	cmp	byte [si+1], ":"                                 
  5973 00001B16 7502                    	jne	short CDLetter_NO						 
  5974 00001B18 EB01                    	jmp	short CDLetter_exit					 
  5975                                  CDLetter_NO:								 
  5976 00001B1A F9                      	stc								 
  5977                                  CDLetter_exit:								 
  5978 00001B1B 58                      	pop	ax							 
  5979 00001B1C C3                      	retn								 
  5980                                  									 
  5981                                  MOVE_ASCIIZ:				 
  5982                                  ;In: DS:SI -> source ES:DI -> target					 
  5983                                  ;Out: copy the string until 0.						 
  5984                                  ;Assumes there exists a 0.						 
  5985                                  MASCIIZ_loop:								 
  5986 00001B1D A4                      	movsb								 
  5987 00001B1E 807CFF00                	cmp	byte [SI-1], 0	;Was it 0?			 
  5988 00001B22 75F9                    	jne	short MASCIIZ_loop						 
  5989 00001B24 C3                      	retn
  5990                                  
  5991                                  ; 10/06/2018 - Retro DOS v3.0
  5992                                  								 
  5993                                  ;
  5994                                  ;	DS:DX POINTS TO STRING TO OUTPUT (ASCIZ)
  5995                                  ;
  5996                                  ;	PRINTS <BADLD_PRE> <STRING> <BADLD_POST>
  5997                                  ;
  5998                                  
  5999                                  BADFIL:
  6000 00001B25 0E                              PUSH    CS
  6001 00001B26 07                              POP     ES
  6002 00001B27 89D6                            MOV     SI,DX
  6003                                  BADLOAD:
  6004 00001B29 BA[9C1D]                        MOV     DX,BADLD_PRE		; WANT TO PRINT CONFIG ERROR
  6005                                          ;MOV	BX,BADLD_POST
  6006                                  PRNERR:
  6007 00001B2C 0E                              PUSH    CS
  6008 00001B2D 1F                              POP     DS
  6009 00001B2E B409                            MOV     AH,STD_CON_STRING_OUTPUT
  6010 00001B30 CD21                            INT     21H
  6011                                  PRN1:   
  6012 00001B32 268A14                  	MOV     DL,[ES:SI]
  6013 00001B35 08D2                            OR      DL,DL
  6014 00001B37 7407                            JZ      SHORT PRN2
  6015 00001B39 B402                            MOV     AH,STD_CON_OUTPUT
  6016 00001B3B CD21                            INT     21H
  6017 00001B3D 46                              INC     SI
  6018 00001B3E EBF2                            JMP     SHORT PRN1
  6019                                  PRN2:   
  6020                                  	;MOV	DX,BX
  6021 00001B40 BA[781D]                	MOV	DX,BADLD_POST ; 10/04/2018
  6022                                  PRINT:  
  6023 00001B43 B409                    	MOV     AH,STD_CON_STRING_OUTPUT
  6024 00001B45 CD21                            INT     21H
  6025 00001B47 C3                              RETN
  6026                                  
  6027                                  	;IF	NOEXEC  ; (NOEXEC = FALSE)
  6028                                  ;;
  6029                                  ;; LOAD FILE CALLED [DS:DX] AT MEMORY LOCATION ES:BX
  6030                                  ;;
  6031                                  ;LDFIL:
  6032                                  ;	PUSH    AX
  6033                                  ;	PUSH    BX
  6034                                  ;	PUSH    CX
  6035                                  ;	PUSH    DX
  6036                                  ;	PUSH    SI
  6037                                  ;	PUSH    DS
  6038                                  ;	PUSH    BX
  6039                                  ;
  6040                                  ;	XOR     AX,AX                   ; OPEN THE FILE
  6041                                  ;	MOV     AH,OPEN
  6042                                  ;	STC                             ; IN CASE OF INT 24
  6043                                  ;	INT     21H
  6044                                  ;	POP     DX                      ; Trans addr is DS:DX
  6045                                  ;	JC      SHORT LDRET
  6046                                  ;
  6047                                  ;	; 10/06/2018
  6048                                  ;	PUSH	DX
  6049                                  ;	MOV     BX,AX                   ; Handle in BX
  6050                                  ;	XOR	CX,CX
  6051                                  ;	XOR	DX,DX
  6052                                  ;	MOV	AX,(LSEEK*256)+2
  6053                                  ;	STC				;IN CASE OF INT 24
  6054                                  ;	INT	21H			; Get file size in DX:AX
  6055                                  ;	JC	short LDCLSP
  6056                                  ;	POP	DX
  6057                                  ;	PUSH	DX
  6058                                  ;	MOV	CX,ES			; CX:DX is xaddr
  6059                                  ;	ADD	DX,AX			; Add file size to Xaddr
  6060                                  ;	JNC	short DOSIZE
  6061                                  ;	ADD	CX,1000H		; ripple carry
  6062                                  ;DOSIZE:
  6063                                  ;	mov	ax,dx
  6064                                  ;	call	ParaRound
  6065                                  ;	mov	dx,ax
  6066                                  ;
  6067                                  ;	ADD	CX,DX
  6068                                  ;	CMP	CX,[ALLOCLIM]
  6069                                  ;	JB	short OKLD
  6070                                  ;	JMP	short MEM_ERR
  6071                                  ;
  6072                                  ;OKLD:
  6073                                  ;	XOR	CX,CX
  6074                                  ;	XOR	DX,DX
  6075                                  ;	MOV	AX,LSEEK SHL 8		;Reset pointer to beginning of file
  6076                                  ;	STC				;IN CASE OF INT 24
  6077                                  ;	INT	21H
  6078                                  ;	JC	LDCLSP
  6079                                  ;	POP	DX
  6080                                  ;	PUSH	ES			;READ THE FILE IN
  6081                                  ;	POP	DS			;Trans addr is DS:DX
  6082                                  ;	MOV	CX,0FF00H		; .COM files arn't any bigger than
  6083                                  ;					; 64k-100H
  6084                                  ;	MOV	AH,READ
  6085                                  ;	STC				;IN CASE OF INT 24
  6086                                  ;	INT	21H
  6087                                  ;	JC	short LDCLS
  6088                                  ;	MOV	SI,DX			;CHECK FOR EXE FILE
  6089                                  ;	CMP	WORD [SI],"MZ"
  6090                                  ;	CLC				; Assume OK
  6091                                  ;	JNZ	short LDCLS		; Only know how to do .COM files
  6092                                  ;	STC
  6093                                  ;	JMP	SHORT LDCLS
  6094                                  ;
  6095                                  ;LDERRP:  
  6096                                  ;	STC
  6097                                  ;LDCLSP:
  6098                                  ;	POP	DX
  6099                                  ;LDCLS:  
  6100                                  ;	PUSHF
  6101                                  ;	MOV     AH,CLOSE                ; CLOSE THE FILE
  6102                                  ;       STC
  6103                                  ;       INT     21H
  6104                                  ;	POPF
  6105                                  ;
  6106                                  ;LDRET:  
  6107                                  ;	POP     DS
  6108                                  ;	POP     SI
  6109                                  ;	POP     DX
  6110                                  ;	POP     CX
  6111                                  ;	POP     BX
  6112                                  ;	POP     AX
  6113                                  ;	RETN
  6114                                  
  6115                                  	;ENDIF
  6116                                  ;
  6117                                  ;  OPEN DEVICE POINTED TO BY DX, AL HAS ACCESS CODE
  6118                                  ;   IF UNABLE TO OPEN DO A DEVICE OPEN NULL DEVICE INSTEAD
  6119                                  ;
  6120                                  OPEN_DEV:
  6121 00001B48 E81C00                          CALL    OPEN_FILE
  6122 00001B4B 7307                            JNC     SHORT OPEN_DEV3
  6123                                  OPEN_DEV1:
  6124 00001B4D BA[AC1B]                        MOV     DX,NULDEV
  6125 00001B50 E81400                          CALL    OPEN_FILE
  6126                                  OPEN_DEV2:
  6127 00001B53 C3                              RETN
  6128                                  OPEN_DEV3:
  6129                                  	; 05/07/2018
  6130 00001B54 89C3                    	MOV	BX,AX			; Handle from open to BX
  6131 00001B56 31C0                            XOR     AX,AX                   ; GET DEVICE INFO
  6132 00001B58 B444                            MOV     AH,IOCTL
  6133 00001B5A CD21                            INT     21H
  6134 00001B5C F6C280                          TEST    DL,10000000B
  6135 00001B5F 75F2                            JNZ     SHORT OPEN_DEV2
  6136 00001B61 B43E                            MOV     AH,CLOSE
  6137 00001B63 CD21                            INT     21H
  6138 00001B65 EBE6                            JMP     SHORT OPEN_DEV1
  6139                                  
  6140                                  OPEN_FILE:
  6141 00001B67 B43D                            MOV     AH,OPEN
  6142 00001B69 F9                              STC
  6143 00001B6A CD21                            INT     21H
  6144 00001B6C C3                              RETN
  6145                                  
  6146                                  INT24:  
  6147 00001B6D 83C406                  	ADD     SP,6                    ; RESTORE MACHINE STATE
  6148 00001B70 58                              POP     AX
  6149 00001B71 5B                              POP     BX
  6150 00001B72 59                              POP     CX
  6151 00001B73 5A                              POP     DX
  6152 00001B74 5E                              POP     SI
  6153 00001B75 5F                              POP     DI
  6154 00001B76 5D                              POP     BP
  6155 00001B77 1F                              POP     DS
  6156 00001B78 07                              POP     ES
  6157 00001B79 50                              PUSH    AX
  6158 00001B7A B419                            MOV     AH,GET_DEFAULT_DRIVE    ; INITIALIZE DOS
  6159 00001B7C CD21                            INT     21H
  6160 00001B7E 58                              POP     AX
  6161 00001B7F CF                              IRET                            ; BACK TO USER
  6162                                  
  6163                                          ;IF	ALTVECT
  6164                                  BOOTMES:
  6165 00001B80 0D                      	DB      13
  6166 00001B81 0A                      TEN:	DB      10
  6167                                  	; 15/09/2022
  6168                                  	;DB      "MS-DOS version "
  6169                                  	;DB      MAJOR_VERSION + "0"
  6170                                  	;DB      "."
  6171                                  	;DB      (MINOR_VERSION / 10) + "0"
  6172                                  	;DB      (MINOR_VERSION % 10) + "0"
  6173                                  	;DB      13,10
  6174                                  	;;DB	"Copyright 1981,82 Microsoft Corp.",13,10,"$"
  6175                                  	;; 27/06/2018
  6176                                  	;DB	"Copyright 1981,87 Microsoft Corp.",13,10,"$"
  6177                                  	;;ENDIF
  6178                                  	 
  6179                                  	; 15/09/2022
  6180 00001B82 526574726F20444F53-     	db 	"Retro DOS v"
  6180 00001B8B 2076               
  6181 00001B8D 33                      	db	MAJOR_VERSION + "0"
  6182 00001B8E 2E                      	db	"."
  6183 00001B8F 33                      	db	(MINOR_VERSION / 10) + "0"
  6184                                  	%if (MINOR_VERSION % 10)
  6185                                  	db	(MINOR_VERSION % 10) + "0"
  6186                                  	%endif
  6187 00001B90 2028323032322920        	db	" (2022) "
  6188 00001B98 0D0A                    	db	0Dh, 0Ah
  6189 00001B9A 6279204572646F6761-     	db	"by Erdogan Tan "
  6189 00001BA3 6E2054616E20       
  6190 00001BA9 0D0A24                  	db	13,10,"$"	
  6191                                  
  6192                                  	; 10/06/2018 - Retro DOS v3.0
  6193                                  NULDEV: 
  6194 00001BAC 4E554C00                	DB      "NUL",0
  6195                                  CONDEV: 
  6196 00001BB0 434F4E00                	DB      "CON",0
  6197                                  AUXDEV: 
  6198 00001BB4 41555800                	DB      "AUX",0
  6199                                  PRNDEV: 
  6200 00001BB8 50524E00                	DB      "PRN",0
  6201                                  
  6202                                  CONFIG:
  6203 00001BBC 5C434F4E4649472E53-     	DB      "\CONFIG.SYS",0
  6203 00001BC5 595300             
  6204                                  
  6205                                  CNTRY_DRV:
  6206 00001BC8 413A                    	DB	"A:"
  6207                                  CNTRY_ROOT:
  6208 00001BCA 5C                      	DB	"\"
  6209                                  CNTRY_PATH:
  6210 00001BCB 434F554E5452592E53-     	DB	"COUNTRY.SYS",0
  6210 00001BD4 595300             
  6211 00001BD7 00<rep 34h>             	times	52 db 0
  6212                                  
  6213                                  COUNTRY_FILE_SIGNATURE:
  6214 00001C0B FF434F554E545259        	db	0FFh,'COUNTRY' 	 
  6215                                  
  6216                                  CntryCodePage_Id:
  6217 00001C13 0000                    	DW	0	
  6218                                  
  6219                                  COMMND:
  6220 00001C15 5C434F4D4D414E442E-     	DB      "\COMMAND.COM",0
  6220 00001C1E 434F4D00           
  6221 00001C22 00<rep 14h>             	times	20 db 0
  6222                                  
  6223                                  COMTAB:
  6224                                          ;DB	8,"AVAILDEV", 'A'	; NO LONGER SUPPORTED
  6225 00001C36 074255464645525342      	DB	7,"BUFFERS",  'B'
  6226 00001C3F 05425245414B43          	DB	5,"BREAK",    'C'
  6227 00001C46 0644455649434544        	DB	6,"DEVICE",   'D'
  6228 00001C4E 0546494C455346          	DB	5,"FILES",    'F'
  6229 00001C55 044643425358            	DB	4,"FCBS",     'X'
  6230 00001C5B 094C41535444524956-     	DB	9,"LASTDRIVE",'L'
  6230 00001C64 454C               
  6231 00001C66 08445249565041524D-     	DB	8,"DRIVPARM", 'P'       ; RS for DOS 3.2
  6231 00001C6F 50                 
  6232                                  		;IF	STACKSW					; 3.30
  6233 00001C70 06535441434B534B        	DB	6,"STACKS",   'K'       ; BAS for DOS 3.2	; 3.30
  6234                                  		;ENDIF						; 3.30
  6235 00001C78 07434F554E54525951      	DB	7,"COUNTRY",  'Q'
  6236 00001C81 055348454C4C53          	DB	5,"SHELL",    'S'
  6237                                  	;DB	8,"SWITCHAR", 'W'	; NO LONGER SUPPORTED
  6238                                  
  6239 00001C88 00                              DB      0
  6240                                  
  6241                                  DEVICEPARAMETERS:  ; STRUC A_DEVICEPARAMETERS
  6242                                  ;DeviceParameters a_DeviceParameters <0,DEV_3INCH720KB,0,80>
  6243 00001C89 00                      DEVP.SPECIALFUNC:	DB 0
  6244 00001C8A 02                      DEVP.DEVICETYPE:	DB DEV_3INCH720KB
  6245 00001C8B 0000                    DEVP.ATTRIBUTES:	DW 0
  6246 00001C8D 5000                    DEVP.CYLINDERS:		DW 80
  6247 00001C8F 00                      DEVP.MEDIATYPE:		DB 0
  6248 00001C90 00<rep 1Fh>             DEVP.DP_BPB:		TIMES A_BPB.size DB 0
  6249 00001CAF 0000                    DEVP.TRACKTBLENTS:	DW 0
  6250 00001CB1 FC                      DEVP.SECTORTABLE:	DB MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  6251                                  
  6252 00001CB2 0200                    HLIM: DW 2
  6253 00001CB4 0900                    SLIM: DW 9
  6254                                  
  6255 00001CB6 00                      DRIVE: DB 0
  6256 00001CB7 0000                    SWITCHES: DW 0
  6257                                  
  6258                                  ; 06/07/2018
  6259                                  
  6260                                  ;-----------------------------------------------------------------------------
  6261                                  ; BOOT DISK PARAMETERS
  6262                                  ;-----------------------------------------------------------------------------
  6263                                  ; 02/06/2018 - Retro DOS v3.0
  6264                                  ; 07/04/2018 - Retro DOS V2.0
  6265                                  
  6266                                  ;BOOT_DRV_PARMS:
  6267                                  ;		; 1.44MB
  6268                                  ;		dw 512
  6269                                  ;               db 1
  6270                                  ;               dw 1	
  6271                                  ;               db 2
  6272                                  ;               dw 224
  6273                                  ;		dw 2880
  6274                                  ;		; Retro DOS v1.0 - 10/02/2018
  6275                                  ;		db 0F0h		; Media descriptor
  6276                                  ;		dw 9		; FAT size in sectors
  6277                                  ;		dw 18		; Sectors per track
  6278                                  ;		dw 2		; Number of heads
  6279                                  ;		; 02/06/2018 - Retro DOS v3.0
  6280                                  ;		;dw 0		
  6281                                  ;		dd 0		; Hidden sectors
  6282                                  ;		dd 0		; Big total sectors		
  6283                                  ;
  6284                                  ;; Note: These (fd&hd) parameters table sizes are  
  6285                                  ;;						 31 bytes for MSDOS 3.3		
  6286                                  ;;						 19 bytes for MSDOS 2.11
  6287                                  
  6288                                  ;-----------------------------------------------------------------------------
  6289                                  ; FLOPPY DISK PARAMETERS
  6290                                  ;-----------------------------------------------------------------------------
  6291                                  ; 02/06/2018 - Retro DOS v3.0
  6292                                  ; 07/04/2018 - Retro DOS V2.0
  6293                                  
  6294                                  
  6295                                  ; 02/06/2018 - Retro DOS v3.0 - 25 bytes of DOS disk paramaters
  6296                                  
  6297                                  
  6298                                  ;
  6299                                  ; The following are the recommended BPBs for the media that we know of so
  6300                                  ; far.
  6301                                  
  6302                                  ; 48 tpi diskettes
  6303                                  	;EVENB
  6304                                  ;align 2
  6305                                  ;BPB48T:
  6306                                  ;	DW	512
  6307                                  ;	DB	2
  6308                                  ;	DW	1
  6309                                  ;	DB	2
  6310                                  ;	DW	112
  6311                                  ;	DW	2*9*40
  6312                                  ;	DB	0FDH
  6313                                  ;	DW	2
  6314                                  ;	DW	9
  6315                                  ;	DW	2
  6316                                  ;	DD	0		;hidden sectors - sp
  6317                                  ;	DD	0		;big total sectors - sp
  6318                                  ;	;DB	6 DUP(?)	;reserved
  6319                                  ;	;times	6 db 0
  6320                                  
  6321                                  ; 96tpi diskettes
  6322                                  	;EVENB
  6323                                  ;align 2
  6324                                  ;BPB96T:	
  6325                                  ;	DW	512
  6326                                  ;	DB	1
  6327                                  ;	DW	1
  6328                                  ;	DB	2
  6329                                  ;	DW	224
  6330                                  ;	DW	2*15*80
  6331                                  ;	DB	0f9H
  6332                                  ;	DW	7
  6333                                  ;	DW	15
  6334                                  ;	DW	2
  6335                                  ;	DD	0		;hidden sectors - sp
  6336                                  ;	DD	0		;big total sectors - sp
  6337                                  ;	;DB	6 DUP(?)	;reserved
  6338                                  ;	;times	6 db 0
  6339                                  
  6340                                  ;BPBSIZ	equ	$-BPB96T
  6341                                  BPBSIZ	equ	25  ; 02/06/2018
  6342                                  
  6343                                  
  6344                                  ; 3 1/2 inch diskette BPB
  6345                                  	;EVENB
  6346                                  ;align 2
  6347                                  ;BPB35:	
  6348                                  ;	DW	512
  6349                                  ;	DB	2
  6350                                  ;	DW	1		; Double sided with 9 sec/trk
  6351                                  ;	DB	2
  6352                                  ;	DW	70h
  6353                                  ;	DW	2*9*80
  6354                                  ;	DB	0f9H
  6355                                  ;	DW	3
  6356                                  ;	DW	9
  6357                                  ;	DW	2
  6358                                  ;	DD	0		;hidden sectors - sp
  6359                                  ;	DD	0		;big total sectors - sp
  6360                                  ;	;DB	6 DUP(?)	;reserved
  6361                                  ;	;times	6 db 0
  6362                                  
  6363                                  	;EVENB
  6364 00001CB9 90                      align 2
  6365                                  		; Retro DOS v3.0 - 25 bytes disk parameters (02/06/2018)
  6366                                  		; Retro DOS v2.0 - 19 bytes disk parameters (07/04/2018)
  6367                                  _FD_parameters:
  6368                                  		; Retro DOS v1.0 - 10/02/2018
  6369                                  		; 17 bytes of DOS disk parameters
  6370                                  
  6371                                  ; 48 tpi diskettes
  6372                                  BPB48T: 	; 02/06/2018 - Retro DOS v3.0
  6373                                  _360K_parameters:
  6374                                  		; 360KB
  6375 00001CBA 0002                    		dw 512		; Sector size in bytes.
  6376 00001CBC 02                      		db 2		; Sector per allocation unit.
  6377 00001CBD 0100                    		dw 1		; Reserved sectors.
  6378 00001CBF 02                      		db 2		; Number of allocation tables.
  6379 00001CC0 7000                    		dw 112		; Number of directory entrys.
  6380 00001CC2 D002                    		dw 720		; Number of sectors on the disk.
  6381                                  		; Retro Dos v1.0 - 10/02/2018
  6382 00001CC4 FD                      		db 0FDh		; Media descriptor
  6383 00001CC5 0200                    		dw 2		; FAT size in sectors
  6384 00001CC7 0900                    		dw 9		; Sectors per track
  6385 00001CC9 0200                    		dw 2		; Number of heads
  6386                                  		; Retro DOS v2.0 - 07/04/2018
  6387                                  		;dw 0		; Hidden sectors
  6388                                  		; Retro DOS v3.0 - 02/06/2018
  6389 00001CCB 00000000                		dd 0		; Hidden sectors
  6390 00001CCF 00000000                		dd 0		; Big Total sectors
  6391                                  ; 96tpi diskettes
  6392                                  BPB96T:		; 02/06/2018 - Retro DOS v3.0
  6393                                  _1200K_parameters:
  6394                                  		; 1.2MB
  6395 00001CD3 0002                    		dw 512
  6396 00001CD5 01                                      db 1
  6397 00001CD6 0100                                    dw 1	
  6398 00001CD8 02                                      db 2
  6399 00001CD9 E000                                    dw 224
  6400 00001CDB 6009                    		dw 2400
  6401                                  		; Retro DOS v1.0 - 10/02/2018
  6402 00001CDD F9                      		db 0F9h		; Media Descriptor
  6403 00001CDE 0700                    		dw 7		; FAT size in sectors
  6404 00001CE0 0F00                    		dw 15		; Sectors per track
  6405 00001CE2 0200                    		dw 2		; Number of heads
  6406                                  		; Retro DOS v2.0 - 07/04/2018
  6407                                  		;dw 0		; Hidden sectors
  6408                                  		; Retro DOS v3.0 - 02/06/2018
  6409 00001CE4 00000000                		dd 0		; Hidden sectors
  6410 00001CE8 00000000                		dd 0		; Big Total sectors
  6411                                  ; 3 1/2 inch diskette bpb
  6412                                  BPB35:		; 02/06/2018 - Retro DOS v3.0	
  6413                                  _720K_paramaters:
  6414                                  		; 720KB
  6415 00001CEC 0002                    		dw 512		; Sector size in bytes.
  6416 00001CEE 02                      		db 2		; Sector per allocation unit.
  6417 00001CEF 0100                    		dw 1		; Reserved sectors.
  6418 00001CF1 02                      		db 2		; Number of allocation tables.
  6419 00001CF2 7000                    		dw 112		; Number of directory entrys.
  6420 00001CF4 A005                    		dw 1440		; Number of sectors on the disk.
  6421                                  		; Retro DOS v1.0 - 10/02/2018
  6422 00001CF6 F9                      		db 0F9h		; Media descriptor
  6423 00001CF7 0300                    		dw 3		; FAT size in sectors
  6424 00001CF9 0900                    		dw 9		; Sectors per track
  6425 00001CFB 0200                    		dw 2		; Number of heads
  6426                                  		; Retro DOS v2.0 - 07/04/2018
  6427                                  		;dw 0
  6428                                  		; Retro DOS v3.0 - 02/06/2018
  6429 00001CFD 00000000                		dd 0		; Hidden sectors
  6430 00001D01 00000000                		dd 0		; Big Total sectors
  6431                                  BPB35H:		; 03/06/2018 - Retro DOS v3.0 (MSDOS 6.0, SYSINIT2.ASM, 1991)		
  6432                                  _1440K_parameters:
  6433                                  		; 1.44MB
  6434 00001D05 0002                    		dw 512
  6435 00001D07 01                                      db 1
  6436 00001D08 0100                                    dw 1	
  6437 00001D0A 02                                      db 2
  6438 00001D0B E000                                    dw 224
  6439 00001D0D 400B                    		dw 2880
  6440                                  		; Retro DOS v1.0 - 10/02/2018
  6441 00001D0F F0                      		db 0F0h		; Media descriptor
  6442 00001D10 0900                    		dw 9		; FAT size in sectors
  6443 00001D12 1200                    		dw 18		; Sectors per track
  6444 00001D14 0200                    		dw 2		; Number of heads
  6445                                  		; Retro DOS v2.0 - 07/04/2018
  6446                                  		;dw 0
  6447                                  		; Retro DOS v3.0 - 02/06/2018
  6448 00001D16 00000000                		dd 0		; Hidden sectors
  6449 00001D1A 00000000                		dd 0		; Big Total sectors
  6450                                  BPB288:		; 03/06/2018 - Retro DOS v3.0 (MSDOS 6.0, SYSINIT2.ASM, 1991)
  6451                                  _2880K_parameters:
  6452                                  		; 2.88MB
  6453 00001D1E 0002                    		dw 512
  6454 00001D20 02                                      db 2
  6455 00001D21 0100                                    dw 1	
  6456 00001D23 02                                      db 2
  6457 00001D24 F000                                    dw 240
  6458 00001D26 8016                    		dw 5760
  6459                                  		; Retro DOS v1.0 - 10/02/2018
  6460 00001D28 F0                      		db 0F0h		; Media descriptor
  6461 00001D29 0900                    		dw 9		; FAT size in sectors
  6462 00001D2B 2400                    		dw 36		; Sectors per track
  6463 00001D2D 0200                    		dw 2		; Number of heads
  6464                                  		; Retro DOS v2.0 - 07/04/2018
  6465                                  		;dw 0
  6466                                  		; Retro DOS v3.0 - 02/06/2018
  6467 00001D2F 00000000                		dd 0		; Hidden sectors
  6468 00001D33 00000000                		dd 0		; Big Total sectors
  6469                                  
  6470                                  ; 06/07/2018
  6471                                  
  6472 00001D37 90                      align 2
  6473                                  
  6474                                  BPBTable:
  6475                                  	; Retro DOS v3.0 - 03/06/2018  (MSDOS 6.0, SYSINIT2.ASM, 1991)
  6476 00001D38 [BA1C]                  		dw	BPB48T	; 48tpi drives
  6477 00001D3A [D31C]                  		dw	BPB96T	; 96tpi drives
  6478 00001D3C [EC1C]                  		dw	BPB35	; 3.5" drives
  6479                                  ; the following are not supported, so default to 3.5" media layout
  6480 00001D3E [EC1C]                  		dw	BPB35	; not used - 8" drives
  6481 00001D40 [EC1C]                  		dw	BPB35	; not used - 8" drives
  6482 00001D42 [EC1C]                  		dw	BPB35	; not used - hard files
  6483 00001D44 [EC1C]                  		dw	BPB35	; not used - tape drives
  6484 00001D46 [051D]                  		dw	BPB35H	; 3 1/2" 1.44mb drive
  6485 00001D48 [EC1C]                  		dw	BPB35	; ERIMO
  6486 00001D4A [1E1D]                  		dw	BPB288	; 2.88 MB diskette drives
  6487                                  		;dw	BPB35H	; 3 1/2" 1.44mb drive
  6488                                  
  6489                                  END_OF_FDP_TBLS:
  6490                                  
  6491                                  ; ----------------------------------------------------------------------------
  6492                                  
  6493                                  ; 10/06/2018
  6494                                  
  6495                                  switchlist:
  6496 00001D4C 074648535444434E        	 db	7,"FHSTDCN"         ; Preserve the positions of N and C.
  6497                                  
  6498                                  ; The following depend on the positions of the various letters in SwitchList
  6499                                  
  6500                                  flagdrive   equ     0004H
  6501                                  flagcyln    equ     0008H
  6502                                  flagseclim  equ     0010H
  6503                                  flagheads   equ     0020H
  6504                                  flagff	    equ     0040H
  6505                                  
  6506                                  SWTCHR	EQU "/"	
  6507                                  
  6508                                  ;SYSINITSEG      ENDS
  6509                                  ;       END
  6510                                  
  6511                                  ; ----------------------------------------------------------------------------
  6512                                  ; SYSIMES.ASM, 22/09/1983, -- SYSIMES.INC, 24/07/1987 (MSDOS 3.3) --
  6513                                  ; ----------------------------------------------------------------------------
  6514                                  
  6515                                  ;SYSINITSEG      SEGMENT PUBLIC BYTE 'SYSTEM_INIT'
  6516                                  
  6517                                          ;PUBLIC  BADOPM,CRLFM,BADSIZ,BADLD,BADCOM,SYSSIZE
  6518                                  
  6519                                  BADOPM: 
  6520 00001D54 0D0A556E7265636F67-     	DB      13,10,"Unrecognized command in CONFIG.SYS"
  6520 00001D5D 6E697A656420636F6D-
  6520 00001D66 6D616E6420696E2043-
  6520 00001D6F 4F4E4649472E535953 
  6521                                  BADSIZ_POST:
  6522                                  BADLD_POST:
  6523 00001D78 0D0A24                  CRLFM:  DB      13,10,'$'
  6524                                  
  6525                                  ;
  6526                                  ;PRINTED when installed device specifies too large a sector size.'$' terminated.
  6527                                  ; FORM: 	<BADSIZ_PRE>device name<BADSIZ_POST>
  6528                                  ;
  6529                                  
  6530                                  BADSIZ_PRE:
  6531 00001D7B 0D0A536563746F7220-     	DB      13,10,"Sector size too large in file $"
  6531 00001D84 73697A6520746F6F20-
  6531 00001D8D 6C6172676520696E20-
  6531 00001D96 66696C652024       
  6532                                  
  6533                                  ;
  6534                                  ;PRINTED when installed device cannot be found. '$' terminated.
  6535                                  ; FORM: 	<BADLD_PRE>device name<BADLD_POST>
  6536                                  ;
  6537                                  
  6538                                  BADLD_PRE:
  6539 00001D9C 0D0A426164206F7220-     	DB      13,10,"Bad or missing $"
  6539 00001DA5 6D697373696E672024 
  6540                                  
  6541                                  ;
  6542                                  ;PRINTED when command interpreter is not found. NUL terminated.
  6543                                  ; FORM: 	<BADLD_PRE><BADCOM><BADLD_POST>
  6544                                  ;
  6545                                  
  6546 00001DAE 436F6D6D616E642049-     BADCOM: DB      "Command Interpreter",0
  6546 00001DB7 6E7465727072657465-
  6546 00001DC0 7200               
  6547                                  
  6548                                  ;PRINTED when country code, code page combination was not found ;3.30
  6549                                  ;  in country.sys file. '$' terminated.				;3.30
  6550                                  ; FORM: 	<BADCOUNTRY>					; 3.30		
  6551                                  
  6552                                  BADCOUNTRY:
  6553 00001DC2 0D0A496E76616C6964-     	DB	13,10,"Invalid country code or code page",13,10,"$" ; 3.30
  6553 00001DCB 20636F756E74727920-
  6553 00001DD4 636F6465206F722063-
  6553 00001DDD 6F646520706167650D-
  6553 00001DE6 0A24               
  6554                                  
  6555                                  ; 10/06/2018
  6556                                  
  6557                                  ;PRINTED when code page id is missing or wrong syntax. - J.K.	;3.30
  6558                                  ; FORM: 	<BADCOUNTRYCOM> 				;3.30
  6559                                  BADCOUNTRYCOM:
  6560 00001DE8 0D0A4572726F722069-     	DB	13,10,"Error in COUNTRY command",13,10,"$"	;3.30
  6560 00001DF1 6E20434F554E545259-
  6560 00001DFA 20636F6D6D616E640D-
  6560 00001E03 0A24               
  6561                                  
  6562                                  ;PRINTED when the memory left is not sufficient to handle COUTRY.SYS file ;3.30
  6563                                  ; FORM: 	<INSUFMEMORY>						  ;3.30
  6564                                  INSUFMEMORY:
  6565 00001E05 0D0A496E7375666669-     	DB	13,10,"Insufficient memory for COUNTRY.SYS file",13,10,"$" ;3.30
  6565 00001E0E 6369656E74206D656D-
  6565 00001E17 6F727920666F722043-
  6565 00001E20 4F554E5452592E5359-
  6565 00001E29 532066696C650D0A24 
  6566                                  
  6567                                  ; PRINTED when there is insufficient memory. '$' TERMINATED, note
  6568                                  ;   that this message includes crlfm!
  6569                                  ;
  6570                                  BADMEM:
  6571 00001E32 0D0A436F6E66696775-     	DB	13,10,"Configuration too large for memory",13,10,"$"
  6571 00001E3B 726174696F6E20746F-
  6571 00001E44 6F206C617267652066-
  6571 00001E4D 6F72206D656D6F7279-
  6571 00001E56 0D0A24             
  6572                                  
  6573                                  ; 26/03/2018
  6574                                  ; PRINTED when the attempt is made to install a block device which would
  6575                                  ;   have a drive letter > 'Z'
  6576                                  ;
  6577                                  
  6578                                  BADBLOCK:
  6579 00001E59 0D0A546F6F206D616E-     	DB	13,10,"Too many Block Devices",13,10,"$"
  6579 00001E62 7920426C6F636B2044-
  6579 00001E6B 6576696365730D0A24 
  6580                                  
  6581                                  ; 10/06/2018
  6582                                  ; PRINTED when the attempt is made to install a stack with invalid	;3.30
  6583                                  ;   combinations of # of stacks, stack size.	- J.K. 5/23/86		;3.30
  6584                                  BADSTACK:
  6585 00001E74 0D0A496E76616C6964-     	DB	13,10,"Invalid STACK parameters",13,10,"$" 		;3.30
  6585 00001E7D 20535441434B207061-
  6585 00001E86 72616D65746572730D-
  6585 00001E8F 0A24               
  6586                                  
  6587                                  ; 03/09/2022 - Temporary !
  6588                                  ;
  6589                                  ;times 279 db 0
  6590                                  ;
  6591                                  ;PCDOSVERSION:	db 1Ah,'@@@### PC-DOS Version 3.30',0Dh,0Ah
  6592                                  ;		db 1Ah,0
  6593                                  
  6594                                  ;SYSSIZE LABEL   BYTE
  6595                                  
  6596                                  ;SYSINITSEG      ENDS
  6597                                  ;       END
